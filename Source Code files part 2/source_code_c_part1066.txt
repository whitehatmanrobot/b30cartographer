tion routines for LZX decoder
 */

#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memset)

/*
 * Allocate memory for decompression
 */
bool NEAR allocate_decompression_memory(t_decoder_context *context)
{
    ulong   pos_start;

    context->dec_num_position_slots = 4;
    pos_start                                               = 4;

    while (1)
        {
        pos_start += 1L << dec_extra_bits[context->dec_num_position_slots];

        context->dec_num_position_slots++;

        if (pos_start >= context->dec_window_size)
            break;
        }

    if (!(context->dec_mem_window = (byte *) context->dec_malloc( context->dec_mallochandle, context->dec_window_size+(MAX_MATCH+4))))
        return false;

    return true;
}



/*
 * Set/reset decoder trees to initial state
 */
void NEAR reset_decoder_trees(t_decoder_context *context)
{
    memset(context->dec_main_tree_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->dec_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);

    memset(context->dec_secondary_length_tree_len, 0, NUM_SECONDARY_LENGTHS);
    memset(context->dec_secondary_length_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);
}


/*
 * Miscellaneous state initialisations
 */
void NEAR decoder_misc_init(t_decoder_context *context)
{
    context->dec_last_matchpos_offset[0]             = 1;
    context->dec_last_matchpos_offset[1]             = 1;
    context->dec_last_matchpos_offset[2]             = 1;

    context->dec_bufpos = 0;
    context->dec_position_at_start = 0;

    context->dec_decoder_state      = DEC_STATE_START_NEW_BLOCK;
    context->dec_block_size         = 0;

    /* so that initialise_decoder_bitbuf() will succeed */
    context->dec_block_type     = BLOCKTYPE_INVALID;

    context->dec_first_time_this_group      = true;
    context->dec_current_file_size          = 0;

    context->dec_error_condition = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decoder.h ===
/*
 * decoder.h
 *
 * Main decoder header file
 */

#ifndef DECODER_H
#define DECODER_H

#ifdef EXT
#       undef EXT
#endif

#ifdef ALLOC_VARS
#       define EXT
#else
#       define EXT extern
#endif

#ifdef USE_ASSEMBLY
#   define ASM_DECODE_VERBATIM_BLOCK
#   define ASM_TRANSLATE_E8
#   define ASM_MAKE_TABLE
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <stdlib.h>
#include <string.h>
#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "decmacro.h"
#include "decdefs.h"

#include "decvars.h"
#include "decapi.h"
#include "decproto.h"

#ifdef TRACING

#include <stdio.h>

void
__stdcall
TracingMatch(
    ulong BufPos,
    ulong MatchPos,
    ulong WindowSize,
    ulong MatchLength,
    ulong MatchPosSlot
    );

void
__stdcall
TracingLiteral(
    ulong BufPos,
    ulong ch
    );

#endif // TRACING

#endif /* DECODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decout.c ===
/*
 * decout.c
 *
 * Decoder outputting
 */

#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy)

void copy_data_to_output(t_decoder_context *context, long amount, const byte *data)
{
    memcpy(
        context->dec_output_buffer,
        data,
        amount
    );

    /* perform jump translation */
    if ((context->dec_current_file_size != 0) && (context->dec_num_cfdata_frames < E8_CFDATA_FRAME_THRESHOLD))
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decmacro.h ===
/*
 * decmacro.h
 *
 * Macros used by the decoder
 */


/*
 * decode an element from the aligned offset tree, without checking 
 * for the end of the input data
 */
#define DECODE_ALIGNED_NOEOFCHECK(j) \
	(j) = context->dec_aligned_table[dec_bitbuf >> (32-ALIGNED_TABLE_BITS)]; \
	FILL_BUF_NOEOFCHECK(context->dec_aligned_len[(j)]);


/*
 * Decode an element from the main tree
 * Check for EOF
 */
#define DECODE_MAIN_TREE(j) \
	j = context->dec_main_tree_table[dec_bitbuf >> (32-MAIN_TREE_TABLE_BITS)];	\
	if (j < 0)															\
	{																	\
        ulong mask = (1L << (32-1-MAIN_TREE_TABLE_BITS));               \
		do																\
		{																\
	 		j = -j;														\
	 		if (dec_bitbuf & mask)										\
                j = context->dec_main_tree_left_right[j*2+1];                   \
			else														\
                j = context->dec_main_tree_left_right[j*2];                     \
			mask >>= 1;													\
		} while (j < 0);												\
	}																	\
	FILL_BUF_FULLCHECK(context->dec_main_tree_len[j]);


/*
 * Decode an element from the secondary length tree
 * No checking for EOF
 */
#define DECODE_LEN_TREE_NOEOFCHECK(matchlen) \
    matchlen = context->dec_secondary_length_tree_table[dec_bitbuf >> (32-SECONDARY_LEN_TREE_TABLE_BITS)]; \
	if (matchlen < 0)                                                	\
	{                                                                	\
        ulong mask = (1L << (32-1-SECONDARY_LEN_TREE_TABLE_BITS));      \
		do                                                          	\
		{																\
	 		matchlen = -matchlen;                                      	\
	 		if (dec_bitbuf & mask)                                  	\
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2+1];\
			else                                                        \
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2];  \
			mask >>= 1;                                                 \
		} while (matchlen < 0);											\
	}																	\
    FILL_BUF_NOEOFCHECK(context->dec_secondary_length_tree_len[matchlen]);      \
	matchlen += NUM_PRIMARY_LENGTHS;


/*
 * read n bits from input stream into dest_var, but don't
 * check for EOF
 */
#define GET_BITS_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF_NOEOFCHECK((N));					\
}


/* same as above, but don't check for EOF */
#define GET_BITS17_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF17_NOEOFCHECK((N));					\
}


/*
 * Remove n bits from the input stream
 * handles 1 <= n <= 17
 *
 * FORCE an EOF check ALWAYS, whether or not we read in more
 * bytes from memory.
 *
 * This is used to ensure that we always get an EOF check often enough
 * to not overrun the extra bytes in the buffer.
 *
 * This routine is used ONLY when decoding the main tree element,
 * where we know that the code we read in will be 16 bits or less
 * in length.  Therefore we don't have to check for bitcount going
 * less than zero, twice.
 */
#define FILL_BUF_FULLCHECK(N) \
{                                    		\
	if (dec_input_curpos >= dec_end_input_pos)	\
        return -1; \
	dec_bitbuf <<= (N);            			\
	dec_bitcount -= (N);                    \
	if (dec_bitcount <= 0)      			\
	{                                 		\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2;              \
		dec_bitcount += 16;               	\
    }                                       \
}

/*
 * Same as above, but no EOF check 
 *
 * This is used when we know we will not run out of input
 */
#define FILL_BUF_NOEOFCHECK(N) 			\
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
	}                                   \
}

/*
 * Same as above, but handles n=17 bits
 */
#define FILL_BUF17_NOEOFCHECK(N)        \
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
		if (dec_bitcount <= 0) \
		{ \
            dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
            dec_input_curpos += 2; \
			dec_bitcount += 16;         \
		} \
	}                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\dectree.c ===
/*
 * dectree.c
 *
 * Decoding the encoded tree structures
 *
 * To save much code size, the fillbuf()/getbits() calls have
 * been made into functions, rather than being inlined macros.
 * The macros actually take up a lot of space.  There is no
 * performance loss from doing so here.
 */
#include "decoder.h"

/* number of elements in pre-tree */
#define NUM_DECODE_SMALL        20

/* lookup table size */
#define DS_TABLE_BITS           8

/* macro to decode a pre-tree element */
#define DECODE_SMALL(item) \
{ \
        item = small_table[context->dec_bitbuf >> (32-DS_TABLE_BITS) ]; \
        if (item < 0)                                                           \
        {                                                                                       \
      mask = (1L << (32-1-DS_TABLE_BITS));      \
      do                                                                                \
      {                                                                                 \
                        item = -item;                                           \
            if (context->dec_bitbuf & mask)     \
                                item = leftright_s[2*item+1];   \
                        else                                                            \
                                item = leftright_s[2*item];             \
                        mask >>= 1;                                                     \
                } while (item < 0);                                             \
   }                                                                                    \
   fillbuf(context, small_bitlen[item]);                \
}

/*
 * Reads a compressed tree structure
 */
static bool NEAR ReadRepTree(
                            t_decoder_context       *context,
                            int                                     num_elements,
                            byte                            *lastlen,
                            byte                            *len
                            )
{
    ulong   mask;
    int             i;
    int             consecutive;
    byte    small_bitlen[24];
    short   small_table[1 << DS_TABLE_BITS];
    short   leftright_s [2*(2 * 24 - 1)];
    short   Temp;

    /* Declare this inline to help compilers see the optimisation */
    static const byte Modulo17Lookup[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
    };

    /* read pre-tree */
    for (i = 0; i < NUM_DECODE_SMALL; i++)
        {
        small_bitlen[i] = (byte) getbits(context, 4);
        }

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;

    /* make a table for this pre-tree */
    make_table(
              context,
              NUM_DECODE_SMALL,
              small_bitlen,
              DS_TABLE_BITS,
              small_table,
              leftright_s
              );

    for (i = 0; i < num_elements; i++)
        {
        DECODE_SMALL(Temp);

        /* exceeded input buffer? */
        if (context->dec_error_condition)
            return false;

        /* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1" zeroes */
        if (Temp == 17)
            {
            /* code 17 means "a small number of repeated zeroes" */
            consecutive = (byte) getbits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS);
            consecutive += TREE_ENC_REP_MIN;

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            while (consecutive-- > 0)
                len[i++] = 0;

            i--;
            }
        else if (Temp == 18)
            {
            /* code 18 means "a large number of repeated zeroes" */

            /* Repeat "TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1...<ditto>+(1<<TREE_ENC_REPZ_SECOND_EXTRA_BITS)-1" zeroes */
            consecutive = (byte) getbits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS);
            consecutive += (TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST);

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            while (consecutive-- > 0)
                len[i++] = 0;

            i--;
            }
        else if (Temp == 19)
            {
            byte    value;

            /* code 19 means "a small number of repeated somethings" */
            /* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REP_SAME_EXTRA_BITS)-1" elements */
            consecutive = (byte) getbits(context, TREE_ENC_REP_SAME_EXTRA_BITS);
            consecutive += TREE_ENC_REP_MIN;

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            /* get the element number to repeat */
            DECODE_SMALL(Temp);
            value = Modulo17Lookup[(lastlen[i] - Temp)+17];

            while (consecutive-- > 0)
                len[i++] = value;

            i--;
            }
        else
            {
            len[i] = Modulo17Lookup[(lastlen[i] - Temp)+17];
            }
        }

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;
    else
        return true;
}


bool NEAR read_main_and_secondary_trees(t_decoder_context *context)
{
    /* read first 256 elements (characters) of the main tree */
    if (false == ReadRepTree(
                            context,
                            256,
                            context->dec_main_tree_prev_len,
                            context->dec_main_tree_len))
        {
        return false;
        }

    /*
     * read remaining elements (primary match lengths * positions)
     * of the main tree
     */
    if (false == ReadRepTree(
                            context,
                            context->dec_num_position_slots*NUM_LENGTHS,
                            &context->dec_main_tree_prev_len[256],
                            &context->dec_main_tree_len[256]))
        {
        return false;
        }

    /* create lookup table for the main tree */
    if (false == make_table(
                           context,
                           MAIN_TREE_ELEMENTS,
                           context->dec_main_tree_len,
                           MAIN_TREE_TABLE_BITS,
                           context->dec_main_tree_table,
                           context->dec_main_tree_left_right))
        {
        return false;
        }

    /* read secondary length tree */
    if (false == ReadRepTree(
                            context,
                            NUM_SECONDARY_LENGTHS,
                            context->dec_secondary_length_tree_prev_len,
                            context->dec_secondary_length_tree_len))
        {
        return false;
        }

    /* create lookup table for the secondary length tree */
    if (false == make_table(
                           context,
                           NUM_SECONDARY_LENGTHS,
                           context->dec_secondary_length_tree_len,
                           SECONDARY_LEN_TREE_TABLE_BITS,
                           context->dec_secondary_length_tree_table,
                           context->dec_secondary_length_tree_left_right))
        {
        return false;
        }

    return true;
}


/* read 8 element aligned offset tree */
bool NEAR read_aligned_offset_tree(t_decoder_context *context)
{
    int             i;

    /* read bit lengths of the 8 codes */
    for (i = 0; i < 8; i++)
        {
        context->dec_aligned_len[i] = (byte) getbits(context, 3);
        }

    if (context->dec_error_condition)
        return false;

    /*
     * Make table with no left/right, and byte Table[] instead of
     * short Table[]
     */
    if (false == make_table_8bit(
                                context,
                                context->dec_aligned_len,
                                (byte *) context->dec_aligned_table))
        {
        return false;
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decuncmp.c ===
/*
 * decuncmp.c
 *
 * Decoding uncompressed blocks
 */
#include "decoder.h"


int decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    long    bytes_decoded = 0;
    long    bufpos_end;
    long    decode_residue;
    ulong   bufpos_start;
    ulong   end_copy_pos;
    byte *  p;

    bufpos_start = bufpos;
    bufpos_end = bufpos + amount_to_decode;

    p = context->dec_input_curpos;

    while (bufpos < bufpos_end)
        {
        if (p >= context->dec_end_input_pos)
            return -1; // input overflow

#ifdef TRACING
        TracingLiteral(bufpos, *p);
#endif
        context->dec_mem_window[bufpos++] = *p++;
        }

    context->dec_input_curpos = p;

    /*
     * Make sure the MAX_MATCH bytes starting at window[window_size]
     * are always the same as the first MAX_MATCH bytes starting at
     * window[0].  This is for our optimisation in decverb.c and
     * decalign.c which allows us to not have to & window_mask all the
     * time.
     */
    end_copy_pos = min(MAX_MATCH, bufpos_end);

    /*
     * Keep copying until we hit MAX_MATCH or the number of bytes
     * we decoded
     */
    while (bufpos_start < end_copy_pos)
        {
        context->dec_mem_window[bufpos_start + context->dec_window_size] =
        context->dec_mem_window[bufpos_start];
        bufpos_start++;
        }

    decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
    context->dec_bufpos = bufpos;

    return (int) decode_residue;
}


bool handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int     i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes.
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos+4 >= context->dec_end_input_pos)
        return false;

    /*
     * update LRU repeated offset list
     */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
        {
        context->dec_last_matchpos_offset[i] =
        ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decvars.h ===
/*
 * decvars.h
 *
 * Variables for the decoder
 */

/*
 * MAX_MAIN_TREE_ELEMENTS should be >= 256 + 8*num_position_slots
 * (that comes out to 256 + 8*51 right now, for a 2 MB window).
 *
 * Make divisible by 4 so things are longword aligned.
 */
#define MAX_MAIN_TREE_ELEMENTS (256 + (8 * 291))   // 32MB

typedef struct
    {
    /* 16-bit version does not have one big window pointer */
#ifndef BIT16
    /* pointer to beginning of window buffer */
    byte                    *dec_mem_window;
#endif

    /* window/decoding buffer parameters */
    ulong               dec_window_size;
    ulong                           dec_window_mask;

    /* previous match offsets */
    ulong               dec_last_matchpos_offset[NUM_REPEATED_OFFSETS];

    /* main tree table */
    short                           dec_main_tree_table[1 << MAIN_TREE_TABLE_BITS];

    /* secondary length tree table */
    short               dec_secondary_length_tree_table[1 << SECONDARY_LEN_TREE_TABLE_BITS];

    /* main tree bit lengths */
    byte                            dec_main_tree_len[MAX_MAIN_TREE_ELEMENTS];

    /* secondary tree bit lengths */
    byte                dec_secondary_length_tree_len[NUM_SECONDARY_LENGTHS];
    byte                            pad1[3]; /* NUM_SECONDARY_LENGTHS == 249 */

    /* aligned offset table */
    char                            dec_aligned_table[1 << ALIGNED_TABLE_BITS];
    byte                            dec_aligned_len[ALIGNED_NUM_ELEMENTS];

    /* left/right pointers for main tree (2*n shorts left, 2*n shorts for right) */
    short               dec_main_tree_left_right[MAX_MAIN_TREE_ELEMENTS*4];

    /* left/right pointers for secondary length tree */
    short               dec_secondary_length_tree_left_right[NUM_SECONDARY_LENGTHS*4];

    /* input (compressed) data pointers */
    byte *              dec_input_curpos;
    byte *              dec_end_input_pos;

    /* output (uncompressed) data pointer */
    byte *              dec_output_buffer;

    /* position in data stream at start of this decode call */
    long                dec_position_at_start;

    /* previous lengths */
    byte                            dec_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS];
    byte                            dec_secondary_length_tree_prev_len[NUM_SECONDARY_LENGTHS];

    /* bitwise i/o */
    ulong               dec_bitbuf;
    signed char             dec_bitcount;

    /* number of distinct position (displacement) slots */
    ulong               dec_num_position_slots;

    bool                            dec_first_time_this_group;
    bool                dec_error_condition;

    /* misc */
    long                    dec_bufpos;
    ulong                           dec_current_file_size;
    ulong                           dec_instr_pos;
    ulong               dec_num_cfdata_frames;

    /* original size of current block being decoded (in uncompressed bytes) */
    long                dec_original_block_size;

    /* remaining size of current block being decoded (in uncompressed bytes) */
    long                            dec_block_size;

    /* type of current block being decoded */
    lzx_block_type          dec_block_type;

    /* current state of decoder */
    decoder_state           dec_decoder_state;

    /* memory allocation functions */
    PFNALLOC                        dec_malloc;
    HANDLE                          dec_mallochandle;

    } t_decoder_context;


/* declare arrays? */
#ifndef ALLOC_VARS

EXT const byte NEAR     dec_extra_bits[];
EXT const long NEAR     MP_POS_minus2[];

#else

const byte NEAR dec_extra_bits[] =
{
0,0,0,0,1,1,2,2,
3,3,4,4,5,5,6,6,
7,7,8,8,9,9,10,10,
11,11,12,12,13,13,14,14,
15,15,16,16,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17
};

/*
 * first (base) position covered by each slot
 * 2 subtracted for optimisation purposes (see decverb.c/decalign.c comments)
 */
const long NEAR MP_POS_minus2[sizeof(dec_extra_bits)] =
{
0-2,        1-2,        2-2,        3-2,        4-2,        6-2,        8-2,        12-2,
16-2,       24-2,       32-2,       48-2,       64-2,       96-2,       128-2,      192-2,
256-2,      384-2,      512-2,      768-2,      1024-2,     1536-2,     2048-2,     3072-2,
4096-2,     6144-2,     8192-2,     12288-2,    16384-2,    24576-2,    32768-2,    49152-2,
65536-2,    98304-2,    131072-2,   196608-2,   262144-2,   393216-2,   524288-2,   655360-2,
786432-2,   917504-2,   1048576-2,  1179648-2,  1310720-2,  1441792-2,  1572864-2,  1703936-2,
1835008-2,  1966080-2,  2097152-2,  2228224-2,  2359296-2,  2490368-2,  2621440-2,  2752512-2,
2883584-2,  3014656-2,  3145728-2,  3276800-2,  3407872-2,  3538944-2,  3670016-2,  3801088-2,
3932160-2,  4063232-2,  4194304-2,  4325376-2,  4456448-2,  4587520-2,  4718592-2,  4849664-2,
4980736-2,  5111808-2,  5242880-2,  5373952-2,  5505024-2,  5636096-2,  5767168-2,  5898240-2,
6029312-2,  6160384-2,  6291456-2,  6422528-2,  6553600-2,  6684672-2,  6815744-2,  6946816-2,
7077888-2,  7208960-2,  7340032-2,  7471104-2,  7602176-2,  7733248-2,  7864320-2,  7995392-2,
8126464-2,  8257536-2,  8388608-2,  8519680-2,  8650752-2,  8781824-2,  8912896-2,  9043968-2,
9175040-2,  9306112-2,  9437184-2,  9568256-2,  9699328-2,  9830400-2,  9961472-2,  10092544-2,
10223616-2, 10354688-2, 10485760-2, 10616832-2, 10747904-2, 10878976-2, 11010048-2, 11141120-2,
11272192-2, 11403264-2, 11534336-2, 11665408-2, 11796480-2, 11927552-2, 12058624-2, 12189696-2,
12320768-2, 12451840-2, 12582912-2, 12713984-2, 12845056-2, 12976128-2, 13107200-2, 13238272-2,
13369344-2, 13500416-2, 13631488-2, 13762560-2, 13893632-2, 14024704-2, 14155776-2, 14286848-2,
14417920-2, 14548992-2, 14680064-2, 14811136-2, 14942208-2, 15073280-2, 15204352-2, 15335424-2,
15466496-2, 15597568-2, 15728640-2, 15859712-2, 15990784-2, 16121856-2, 16252928-2, 16384000-2,
16515072-2, 16646144-2, 16777216-2, 16908288-2, 17039360-2, 17170432-2, 17301504-2, 17432576-2,
17563648-2, 17694720-2, 17825792-2, 17956864-2, 18087936-2, 18219008-2, 18350080-2, 18481152-2,
18612224-2, 18743296-2, 18874368-2, 19005440-2, 19136512-2, 19267584-2, 19398656-2, 19529728-2,
19660800-2, 19791872-2, 19922944-2, 20054016-2, 20185088-2, 20316160-2, 20447232-2, 20578304-2,
20709376-2, 20840448-2, 20971520-2, 21102592-2, 21233664-2, 21364736-2, 21495808-2, 21626880-2,
21757952-2, 21889024-2, 22020096-2, 22151168-2, 22282240-2, 22413312-2, 22544384-2, 22675456-2,
22806528-2, 22937600-2, 23068672-2, 23199744-2, 23330816-2, 23461888-2, 23592960-2, 23724032-2,
23855104-2, 23986176-2, 24117248-2, 24248320-2, 24379392-2, 24510464-2, 24641536-2, 24772608-2,
24903680-2, 25034752-2, 25165824-2, 25296896-2, 25427968-2, 25559040-2, 25690112-2, 25821184-2,
25952256-2, 26083328-2, 26214400-2, 26345472-2, 26476544-2, 26607616-2, 26738688-2, 26869760-2,
27000832-2, 27131904-2, 27262976-2, 27394048-2, 27525120-2, 27656192-2, 27787264-2, 27918336-2,
28049408-2, 28180480-2, 28311552-2, 28442624-2, 28573696-2, 28704768-2, 28835840-2, 28966912-2,
29097984-2, 29229056-2, 29360128-2, 29491200-2, 29622272-2, 29753344-2, 29884416-2, 30015488-2,
30146560-2, 30277632-2, 30408704-2, 30539776-2, 30670848-2, 30801920-2, 30932992-2, 31064064-2,
31195136-2, 31326208-2, 31457280-2, 31588352-2, 31719424-2, 31850496-2, 31981568-2, 32112640-2,
32243712-2, 32374784-2, 32505856-2, 32636928-2, 32768000-2, 32899072-2, 33030144-2, 33161216-2,
33292288-2, 33423360-2, 33554432-2
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decxlat.c ===
/*
 * xlat.c
 *
 * Translate
 */
#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy,memset)

void NEAR init_decoder_translation(t_decoder_context *context)
{
    context->dec_instr_pos = 0;
}


#ifdef ASM_TRANSLATE_E8
ulong __cdecl asm_decoder_translate_e8(ulong instr_pos, ulong file_size, byte *mem, long bytes);

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
    /*
     * We don't want the ASM code to have to worry about where in the
     * context structure a particular element is
     */
    context->dec_instr_pos = asm_decoder_translate_e8(
                                                     context->dec_instr_pos,
                                                     context->dec_current_file_size,
                                                     mem,
                                                     bytes
                                                     );
}

#else /* !ASM_TRANSLATE_E8 */

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
    ulong   end_instr_pos;
    byte    temp[6];
    byte    *mem_backup;

    if (bytes <= 6)
        {
        context->dec_instr_pos += bytes;
        return;
        }

    mem_backup = mem;

    /* backup these bytes */
    memcpy(temp, &mem[bytes-6], 6);

    /* overwrite them with 0xE8 */
    memset(&mem[bytes-6], 0xE8, 6);

    end_instr_pos = context->dec_instr_pos + bytes - 6;

    while (1)
        {
        unsigned long   absolute;

        /*
         * We are guaranteed to hit one of the 6 0xE8's we stuck at the
         * end of the buffer, even if we ran into some corrupted data
         * that resulted in our jumping over 5 bytes due to a translation
         */
        while (*mem++ != 0xE8)
            context->dec_instr_pos++;

        if (context->dec_instr_pos >= end_instr_pos)
            break;

        /*
         * There are 5 or more bytes in the buffer
         * (i.e. E8 xx xx xx xx)
         *
         * We have a complete offset available to (potentially) translate
         */

        absolute = *(UNALIGNED ulong *) mem;

        if (absolute < context->dec_current_file_size)
            {
            /* absolute >= 0 && absolute < dec_current_file_size */

            *(UNALIGNED ulong *) mem = absolute - context->dec_instr_pos;
            }
        else if ((ulong) (-(long) absolute) <= context->dec_instr_pos)
            {
            /* absolute >= -instr_pos && absolute < 0 */

            *(UNALIGNED ulong *) mem = absolute + context->dec_current_file_size;
            }

        mem += 4;
        context->dec_instr_pos += 5;
        }

    context->dec_instr_pos = end_instr_pos + 6;

    /* restore these bytes */
    memcpy(&mem_backup[bytes-6], temp, 6);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decproto.h ===
/*
 * decproto.h
 *
 * Decoder function prototypes
 */

/* decblk.c */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode);

/* decin.c */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context);
void NEAR init_decoder_input(t_decoder_context *context);
void NEAR fillbuf(t_decoder_context *context, int n);
ulong NEAR getbits(t_decoder_context *context, int n);

/* decinit.c */
bool NEAR allocate_decompression_memory(t_decoder_context *context);
void NEAR free_decompression_memory(t_decoder_context *context);
void NEAR decoder_misc_init(t_decoder_context *context);
void NEAR reset_decoder_trees(t_decoder_context *context);

/* decout.c */
void NEAR copy_data_to_output(t_decoder_context *context, long amount, const byte *data);

/* dectree.c */
bool NEAR read_main_and_secondary_trees(t_decoder_context *context);
bool NEAR read_aligned_offset_tree(t_decoder_context *context);

/* maketbl.c */
bool NEAR __cdecl make_table(
        t_decoder_context *context,
        int                     nchar,
        const byte      *bitlen,
        byte            tablebits,
        short           *table,
        short           *leftright
);

bool NEAR make_table_8bit(t_decoder_context *context, byte *bitlen, byte *table);

/* decxlat.c */
void NEAR init_decoder_translation(t_decoder_context *context);
void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes);

/* decalign.c */
int NEAR decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decverb.c */
int NEAR decode_verbatim_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decuncmp.c */
int NEAR decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode);
bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context);


/*
 * 16-bit stuff:
 */
#ifdef BIT16
void NEAR DComp_Close(t_decoder_context *context);
int  NEAR DComp_Init(t_decoder_context *context);
void NEAR DComp_Reset(t_decoder_context *context);
void NEAR DComp_Save_Output_Pages(t_decoder_context *context, uint bytes_decoded);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\maketbl.c ===
/*
 * Table-building routines
 *
 * make_table() is based on ** Public Domain ** source "AR001.ZIP".
 */

#include <memory.h>
#pragma intrinsic(memset)

#include "decoder.h"


/*
 * Make a decoding table for decoding nchar possible Huffman elements
 * with bit lengths given by bitlen.
 *
 * Output the main lookup table into table[] and use leftright[] for
 * supplementary information (for bitlengths > tablebits).
 *
 * The size of table[] is tablebits elements.
 */
#ifndef ASM_MAKE_TABLE
bool NEAR __cdecl make_table(
        t_decoder_context       *context,
        int                             nchar,
        const byte                      *bitlen,
        byte                            tablebits,
        short                           *table,
        short                           *leftright
)
{
    uint    i;
        int             ch;
    short * p;
    uint    count[17], weight[17], start[18];
    int     avail;
    uint    nextcode;
    uint    k;
        byte    len;
        byte    jutbits;

        for (i = 1; i <= 16; i++)
                count[i] = 0;

        /* count the number of elements of each bit length */
    for (i = 0; i < (uint) nchar; i++)
                count[bitlen[i]]++;

        start[1] = 0;

        for (i = 1; i <= 16; i++)
                start[i + 1] = start[i] + (count[i] << (16 - i));

#ifdef BIT16
    if (start[17])
    {
        return false; /* bad table */
    }
#else
    if (start[17] != 65536)
    {
        if (start[17] == 0)
        {
            /*
             * All elements are length zero
             */
            memset(table, 0, sizeof(ushort)*(1 << tablebits));
            return true; /* success */
        }
        else
        {
            return false; /* bad table */
        }
    }
#endif

        jutbits = 16 - tablebits;

        for (i = 1; i <= tablebits; i++)
        {
                start[i] >>= jutbits;
                weight[i] = 1 << (tablebits - i);
        }

        while (i <= 16)
        {
                weight[i] = 1 << (16 - i);
                i++;
        }

        i = start[tablebits+1] >> jutbits;

#ifdef BIT16
    if (i)
#else
        if (i != 65536)
#endif
        {
                memset(
            &table[i],
            0,
            sizeof(ushort)*((1 << tablebits)-i)
        );
        }

        avail = nchar;

        for (ch = 0; ch < nchar; ch++)
        {
                if ((len = bitlen[ch]) == 0)
                        continue;

                nextcode = start[len] + weight[len];

                if (len <= tablebits)
                {
            if (nextcode > (uint) (1 << tablebits))
                return false; /* bad table */

                        for (i = start[len]; i < nextcode; i++)
                                table[i] = (short)ch;

                        start[len] = nextcode;
                }
                else
                {
                        byte i;

                        k = start[len];
                        start[len] = nextcode;
                        p = &table[k >> jutbits];

                        i = len - tablebits;
                        k <<= tablebits;

                        do
                        {
                                if (*p == 0)
                                {
                                        leftright[avail*2] = leftright[avail*2+1] = 0;
                                        *p = (short) -avail;
                                        avail++;
                                }

                                if ((signed short) k < 0) // if (k & 32768)
                                        p = &leftright[-(*p)*2+1];
                                else
                                        p = &leftright[-(*p)*2];

                                k <<= 1;
                                i--;
                        } while (i);

                        *p = (short)ch;
                }
        }

    return true;
}
#endif


/*
 * Specialised make table routine where it is known that there are
 * only 8 elements (nchar=8) and tablebits=7 (128 byte lookup table).
 *
 * Since there can be no overflow, this will be a direct lookup.
 *
 * Important difference; the lookup table returns a byte, not a ushort.
 */
bool NEAR make_table_8bit(t_decoder_context *context, byte bitlen[], byte table[])
{
        ushort count[17], weight[17], start[18];
        ushort i;
        ushort nextcode;
        byte   len;
        byte   ch;

        for (i = 1; i <= 16; i++)
                count[i] = 0;

        for (i = 0; i < 8; i++)
                count[bitlen[i]]++;

        start[1] = 0;

        for (i = 1; i <= 16; i++)
                start[i + 1] = start[i] + (count[i] << (16 - i));

        if (start[17] != 0)
        return false; /* bad table */

        for (i = 1; i <= 7; i++)
        {
                start[i] >>= 9;
                weight[i]  = 1 << (7 - i);
        }

        while (i <= 16)
        {
                weight[i] = 1 << (16 - i);
                i++;
        }

        memset(table, 0, 1<<7);

        for (ch = 0; ch < 8; ch++)
        {
                if ((len = bitlen[ch]) == 0)
                        continue;

                nextcode = start[len] + weight[len];

                if (nextcode > (1 << 7))
            return false; /* bad table */

                for (i = start[len]; i < nextcode; i++)
                        table[i] = ch;

                start[len] = nextcode;
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\blkinit.c ===
/*
 * blkinit.c
 *
 * Block outputting initialisation
 */

#include "encoder.h"


/*
 * Create lookup table for MP_SLOT() macro
 */
void create_slot_lookup_table(t_encoder_context *context)
{
   int			j;
   int 			p;
   int 			elements_to_init;
   ushort       slotnum;

   context->enc_slot_table[0] = 0;
   context->enc_slot_table[1] = 1;
   context->enc_slot_table[2] = 2;
   context->enc_slot_table[3] = 3;

   elements_to_init = 2;

   slotnum = 4;
   p       = 4;

   do
   {
      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;

      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;
      elements_to_init <<= 1;

   } while (p < 1024);
}


/*
 * Create lookup table for figuring out how many
 * ones there are in a given byte.
 */
void create_ones_table(t_encoder_context *context)
{
	int			i, j;
	byte		ones;

	for (i = 0; i < 256; i++)
	{
		ones = 0;

		for (j = i; j; j >>= 1)
		{
			if (j & 1)
				ones++;
		}

		context->enc_ones[i] = ones;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decverb.c ===
/*
 * decverb.c
 *
 * Decoding verbatim-bit blocks
 */
#include "decoder.h"


static long special_decode_verbatim_block(
                                         t_decoder_context   *context,
                                         long                BufPos,
                                         int                 amount_to_decode
                                         )
{
    ulong   match_pos;
    long    bufpos_end;
    int     match_length;
    int     c;
    ulong   dec_bitbuf;
    byte    *dec_input_curpos;
    byte    *dec_end_input_pos;
    byte    *dec_mem_window;
    char    dec_bitcount;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    /*
     * We may overflow by up to MAX_MATCH
     */
    while (BufPos < bufpos_end)
        {
        /* decode an item from the main tree */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
            /*      it's a character */
            /* note: c - 256 == c if c is a byte */
#ifdef TRACING
            TracingLiteral(BufPos, (byte) c);
#endif
            context->dec_mem_window[BufPos] = (byte) c;

            /* we know BufPos < bufpos_end here, so no need to check for overflow */
            context->dec_mem_window[context->dec_window_size+BufPos] = (byte) c;
            BufPos++;
            }
        else
            {
            /* get match length header */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                /* get match length footer if necessary */
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /* get match position slot */
            m = c >> NL_SHIFT;

            /* read any extra bits for the match position */
            if (m > 2)
                {
                if (m > 3) /* dec_extra_bits[m] != 0 */
                    {
                    GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
                    match_pos += MP_POS_minus2[m];
                    }
                else
                    {
                    match_pos = 1; // MP_POS_minus2[3];
                    }

                /*
                 * Add match base to "extra bits".  Our match base
                 * table has 2 subtracted from all the elements.
                 *
                 * This is because encoded positions 0,1,2 denote
                 * repeated offsets.  Encoded position 3 denotes
                 * a match 1 character away, 4 encodes 2 away, etc.
                 * Hence the subtraction of 2, which has been
                 * incorporated into the table.
                 */

                /* update LRU repeated offset list */
                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                /* positions 0, 1, 2 denote repeated offsets */
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            /* match lengths range from 2...257 */
            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation in decalign.c
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

#ifdef TRACING
            TracingMatch(BufPos,
                         BufPos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            /* copy match data */
            do
                {
                context->dec_mem_window[BufPos] = context->dec_mem_window[(BufPos-match_pos) & context->dec_window_mask];

                /* replicate bytes */
                if (BufPos < MAX_MATCH) // what does this do?  Does it need to be more than MAX_MATCH now?
                    context->dec_mem_window[context->dec_window_size+BufPos] = context->dec_mem_window[BufPos];

                BufPos++;
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return BufPos;
}


#ifdef ASM_DECODE_VERBATIM_BLOCK

long __cdecl fast_decode_verbatim_block(
                                       t_decoder_context   *context,
                                       long                BufPos,
                                       int                 amount_to_decode
                                       );

#else /* !ASM_DECODE_VERBATIM_BLOCK */

long fast_decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   match_ptr;
    long    bufpos_end;
    long    decode_residue;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte    *dec_mem_window;
    char    dec_bitcount;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    while (BufPos < bufpos_end)
        {
        /* decode an item from the main tree */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
            /*      it's a character */
            /* note: c - 256 == c if c is a byte */
#ifdef TRACING
            TracingLiteral(BufPos, (byte) c);
#endif
            context->dec_mem_window[BufPos++] = (byte) c;
            }
        else
            {
            /* get match length header */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                /* get match length footer if necessary */
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /* get match position slot */
            m = c >> NL_SHIFT;

            /* read any extra bits for the match position */
            if (m > 2)
                {
                if (m > 3) /* dec_extra_bits[m] != 0 */
                    {
                    GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
                    match_pos += MP_POS_minus2[m];
                    }
                else
                    {
                    match_pos = MP_POS_minus2[3];
                    }

                /*
                 * Add match base to "extra bits".  Our match base
                 * table has 2 subtracted from all the elements.
                 *
                 * This is because encoded positions 0,1,2 denote
                 * repeated offsets.  Encoded position 3 denotes
                 * a match 1 character away, 4 encodes 2 away, etc.
                 * Hence the subtraction of 2, which has been
                 * incorporated into the table.
                 */

                /* update LRU repeated offset list */
                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                /* positions 0, 1, 2 denote repeated offsets */
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            /* match lengths range from 2...257 */
            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation in decalign.c
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

            match_ptr = (BufPos - match_pos) & context->dec_window_mask;

#ifdef TRACING
            TracingMatch(BufPos,
                         BufPos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            /* copy match data */

            do
                {
                context->dec_mem_window[BufPos++] = context->dec_mem_window[match_ptr++];
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    /* should be zero */
    decode_residue = BufPos - bufpos_end;

    BufPos &= context->dec_window_mask;
    context->dec_bufpos = BufPos;

    return decode_residue;
}
#endif /* ASM_DECODE_VERBATIM_BLOCK */


int decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
        {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_verbatim_block(
                                                  context,
                                                  BufPos,
                                                  amount_to_slowly_decode
                                                  );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
        }

    return fast_decode_verbatim_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\block.c ===
/*
 * block.c
 *
 * LZX block outputting
 */

#include "encoder.h"


/*
 * Internal function definitions
 */
static void do_block_output(
                           t_encoder_context *context,
                           long literal_to_end_at,
                           long distance_to_end_at
                           );


static void do_block_output(
                           t_encoder_context *context,
                           long literal_to_end_at,
                           long distance_to_end_at
                           )
{
    ulong                   bytes_compressed;
    lzx_block_type  block_type;
    ulong                   estimated_block_size;

    /*
     * Calculate frequencies for all tree elements.
     *
     * How many uncompressed bytes does this account for?
     */
    bytes_compressed = get_block_stats(
                                      context,
                                      0,
                                      0,
                                      literal_to_end_at
                                      );

    /*
     * Determine whether we wish to output a verbatim block or an
     * aligned offset block
     */
    block_type = get_aligned_stats(context, distance_to_end_at);

    /*
     * Create trees from the frequency data
     */
    create_trees(context, true); /* we want to generate the codes too */

    /*
     * Determine whether the block should be output as uncompressed
     */
    estimated_block_size = estimate_compressed_block_size(context);

    if (estimated_block_size >= bytes_compressed)
        {
        if (context->enc_bufpos_at_last_block >= context->enc_earliest_window_data_remaining)
            block_type = BLOCKTYPE_UNCOMPRESSED;
        }

    output_bits(context, 3, (byte) block_type);

    /* output 24 bit number, number of bytes compressed here */
    output_bits(context, 8,  (bytes_compressed >> 16) & 255);
    output_bits(context, 8,  ((bytes_compressed >> 8) & 255));
    output_bits(context, 8,  (bytes_compressed & 255));

    if (block_type == BLOCKTYPE_VERBATIM)
        {
        encode_trees(context);
        encode_verbatim_block(context, literal_to_end_at);
        get_final_repeated_offset_states(context, distance_to_end_at);
        }
    else if (block_type == BLOCKTYPE_ALIGNED)
        {
        encode_aligned_tree(context);
        encode_trees(context);
        encode_aligned_block(context, literal_to_end_at);
        get_final_repeated_offset_states(context, distance_to_end_at);
        }
    else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        {
        get_final_repeated_offset_states(context, distance_to_end_at);
        encode_uncompressed_block(context, context->enc_bufpos_at_last_block, bytes_compressed);
        }

    context->enc_bufpos_at_last_block += bytes_compressed;
}


/*
 * Returns the number of distances which correspond
 * to this number of literals
 */
ulong get_distances_from_literals(t_encoder_context *context, ulong literals)
{
    ulong   d = 0;
    ulong   i;

    for (i = 0; i < (literals >> 3); i++)
        d += context->enc_ones[ context->enc_ItemType[i] ];

    /*
     * Handle remaining 0...7
     */
    for (i = (literals & (~7)); i < literals; i++)
        {
        if (IsMatch(i))
            d++;
        }

    return d;
}


/*
 * Output a block
 *
 * If trees_only is true, then only the tree statistics are updated.
 */
void output_block(t_encoder_context *context)
{
    ulong   where_to_split;
    ulong   distances;

    //
    // We have now output a block.
    //
    // We set this here in case someone calls LCIFlushOutput, so that
    // we don't try to redo the first chunk of bytes in the file
    // (since we've been forced to output them)
    //
    context->enc_first_block = 0;

    split_block(
               context,
               0,
               context->enc_literals,
               context->enc_distances,
               &where_to_split,
               &distances /* distances @ literal == where_to_split */
               );

    do_block_output(context, where_to_split, distances);

    if (where_to_split == context->enc_literals)
        {
        /*
         * If we've output ALL of our literals, then clear the itemtype array
         */
        memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

        context->enc_literals   = 0;
        context->enc_distances  = 0;
        }
    else
        {
        /*
         * If we didn't output all of our literals, then move the literals
         * and distances we didn't use, to the beginning of the list
         */
        memcpy(
              &context->enc_ItemType[0],
              &context->enc_ItemType[where_to_split/8],
              &context->enc_ItemType[1+(context->enc_literals/8)] - &context->enc_ItemType[where_to_split/8]
              );

        memset(
              &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8],
              0,
              &context->enc_ItemType[MAX_LITERAL_ITEMS/8] - &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8]
              );

        memcpy(
              &context->enc_LitData[0],
              &context->enc_LitData[where_to_split],
              sizeof( context->enc_LitData[0] ) * ( context->enc_literals-where_to_split )
              );

#ifdef EXTRALONGMATCHES

        memcpy(
              &context->enc_ExtraLength[0],
              &context->enc_ExtraLength[where_to_split],
              sizeof( context->enc_ExtraLength[0] ) * ( context->enc_literals-where_to_split )
              );

#endif

        memcpy(
              &context->enc_DistData[0],
              &context->enc_DistData[distances],
              sizeof(ulong)*(context->enc_distances-distances)
              );

        context->enc_literals  -= where_to_split;
        context->enc_distances -= distances;
        }

    fix_tree_cost_estimates(context);
}


void flush_output_bit_buffer(t_encoder_context *context)
{
    byte temp;

    if (context->enc_bitcount < 32)
        {
        temp = context->enc_bitcount-16;

        output_bits(context, temp, 0);
        }
}


/*
 * Estimate how much it would take to output the compressed
 * data left in the buffer
 */
long estimate_buffer_contents(t_encoder_context *context)
{
    long                    estimated_block_size;

    /*
     * Use frequency data sitting around from last tree creation
     */
    create_trees(context, false); /* don't generate codes */

    estimated_block_size = estimate_compressed_block_size(context);

    /* so the optimal parser doesn't get confused */
    fix_tree_cost_estimates(context);

    return estimated_block_size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encapi.c ===
/*
 * encapi.c
 *
 * Encoder API entrypoints.
 */

#define ALLOC_VARS
#include "encoder.h"


bool
__fastcall
LZX_EncodeInit(
    t_encoder_context **  enc_context,
    long                  compression_window_size,
    long                  second_partition_size,
    PFNALLOC              pfnma,
    HANDLE                hAllocator,
    int (__stdcall * pfnlzx_output_callback)(
        void *            pfol,
        unsigned char *   compressed_data,
        long              compressed_size,
        long              uncompressed_size
        ),
    void *                fci_data
    )
{

    t_encoder_context *context = pfnma( hAllocator, sizeof( t_encoder_context ));

    if ( context == NULL ) {
        return false;
        }

    *enc_context = context;

    /* to pass back in lzx_output_callback() */
    context->enc_fci_data = fci_data;

    context->enc_window_size = compression_window_size;

    /*
     * The second partition size must be a multiple of 32K
     */
    if (second_partition_size & (CHUNK_SIZE-1))
        second_partition_size &= (~(CHUNK_SIZE-1));

    /*
     * The minimum allowed is 32K because of the way that
     * our translation works.
     */
    if (second_partition_size < CHUNK_SIZE)
        second_partition_size = CHUNK_SIZE;

    /*
     * Our window size must be at least 32K
     */
    if (compression_window_size < CHUNK_SIZE)
        return false;

    context->enc_encoder_second_partition_size = second_partition_size;
    context->enc_output_callback_function = pfnlzx_output_callback;

    context->enc_malloc       = pfnma;
    context->enc_mallochandle = hAllocator;

    /* Error allocating memory? */
    if (comp_alloc_compress_memory(context) == false)
        return false;

    LZX_EncodeNewGroup(context);

    return true;
}


/*
 * Sets up the encoder for a new group of files.
 *
 * All this does is reset the lookup table, re-initialise to the
 * default match estimation tables for the optimal parser, and
 * reset a few variables.
 */
void __fastcall LZX_EncodeNewGroup(t_encoder_context *context)
{
    init_compression_memory(context);
}


long __fastcall LZX_Encode(
               t_encoder_context *context,
               byte *             input_data,
               long               input_size,
               long *             estimated_bytes_compressed,
               long               file_size_for_translation
               )
{
    context->enc_input_ptr  = input_data;
    context->enc_input_left = input_size;

    context->enc_file_size_for_translation = file_size_for_translation;

    /* perform the encoding */
    encoder_start(context);

    if (context->enc_output_overflow)
        {
        *estimated_bytes_compressed = 0;
        return ENCODER_WRITE_FAILURE;
        }

    *estimated_bytes_compressed = estimate_buffer_contents(context);

    return ENCODER_SUCCESS;
}


bool __fastcall LZX_EncodeFlush(t_encoder_context *context)
{
    flush_all_pending_blocks(context);

    if (context->enc_output_overflow)
        return false;

    return true;
}


//
// But doesn't remove history data
//
bool __fastcall LZX_EncodeResetState(t_encoder_context *context)
{
    /*
     * Most of this copied from init.c
     */

    /*
     * Clear item array and reset literal and distance
     * counters
     */
    memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

    context->enc_literals      = 0;
    context->enc_distances     = 0;

    /*
     * Reset encoder state
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    context->enc_input_running_total = 0;

    /*
     * The last lengths are zeroed in both the encoder and decoder,
     * since our tree representation is delta format.
     */
    memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

    /* reset bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

    /* need to recalculate stats soon */
    context->enc_need_to_recalc_stats = true;
    context->enc_next_tree_create = TREE_CREATE_INTERVAL;

    /* pretend we just output everything up to now as a block */
    context->enc_bufpos_last_output_block = context->enc_BufPos;

    /* don't allow re-doing */
    context->enc_first_block = false;

    /* reset instruction pointer (for translation) to zero */
    reset_translation(context);

    /* so we output the file xlat header */
    context->enc_first_time_this_group = true;

    /* reset frame counter */
    context->enc_num_cfdata_frames = 0;

    /* haven't split the block */
    context->enc_num_block_splits = 0;

    return true;
}


unsigned char * __fastcall LZX_GetInputData(
                               t_encoder_context *context,
                               unsigned long *input_position,
                               unsigned long *bytes_available
                               )
{
    unsigned long filepos;

    // note that BufPos-window_size is the real position in the file
    filepos = context->enc_BufPos - context->enc_window_size;

    if (filepos < context->enc_window_size)
        {
        *input_position = 0;
        *bytes_available = filepos;
        return &context->enc_MemWindow[context->enc_window_size];
        }
    else
        {
        *input_position = filepos - context->enc_window_size;
        *bytes_available = context->enc_window_size;
        return &context->enc_MemWindow[context->enc_BufPos - context->enc_window_size];
        }
}


//
// This is used to quickly insert the old file into the history.
//

bool __fastcall LZX_EncodeInsertDictionary(
                       t_encoder_context *context,
                       byte *             input_data,
                       ulong              input_size
                       )
{
    ulong   BufPos;
    ulong   RealBufPos;
    ulong   BufPosEnd;
    ulong   BytesRead;
    ulong   i;
    ulong   end_pos;

    context->enc_input_ptr  = input_data;
    context->enc_input_left = input_size;

    context->enc_file_size_for_translation = 0;
    context->enc_first_time_this_group = false;

    RealBufPos = context->enc_BufPos - (ulong)(context->enc_RealMemWindow - context->enc_MemWindow);

    BytesRead = comp_read_input(context, RealBufPos, input_size);

    BufPos    = context->enc_BufPos;
    BufPosEnd = context->enc_BufPos + BytesRead;

    while (BufPos < BufPosEnd)
    {
        quick_insert_bsearch_findmatch(
            context,
            BufPos,
            BufPos - context->enc_window_size+4
        );

        BufPos++;
    }

    context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

    end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

    for (i = 1; (i <= BREAK_LENGTH); i++)
        binary_search_remove_node(context, BufPos-i, end_pos);

    context->enc_BufPos = BufPos;
    context->enc_bufpos_at_last_block = BufPos;

    return true;
}


#ifdef TRACING

ULONG TracingRunningTotal;
ULONG TracingPrevPos;

void
__stdcall
EncTracingMatch(
    ulong BufPos,
    ulong MatchLength,
    ulong MatchPos,
    ulong MatchOff
    )
    {

    if ( BufPos < TracingPrevPos ) {
        printf( "REWIND to %08X\n", BufPos );
        TracingRunningTotal -= ( TracingPrevPos - BufPos );
        }

    TracingPrevPos = BufPos;

    TracingRunningTotal += MatchLength;
#ifdef TRACING2
    printf(
        "MATCH: At %08X, %c%c Off %08X (%08X), Length %5d, Total %08X\n",
        BufPos,
        MatchPos < 3 ? 'R' : ' ',
        MatchPos < 3 ? MatchPos + '0' : ' ',
        MatchOff,
        BufPos - MatchOff,
        MatchLength,
        TracingRunningTotal
        );
#else
    printf(
        "MATCH: At %08X, From %08X, Length %5d\n",
        BufPos,
        BufPos - MatchOff,
        MatchLength
        );
#endif
    }


void
__stdcall
EncTracingLiteral(
    ulong BufPos,
    ulong ch
    )
    {

    if ( BufPos < TracingPrevPos ) {
        printf( "REWIND to %08X\n", BufPos );
        TracingRunningTotal -= ( TracingPrevPos - BufPos );
        }

    TracingPrevPos = BufPos;

    ++TracingRunningTotal;

#ifdef TRACING2
    printf(
        "LITER: At %08X, 0x%02X                                      Total %08X\n",
        BufPos,
        ch,
        TracingRunningTotal
        );
#else
    printf(
        "LITER: At %08X, 0x%02X\n",
        BufPos,
        ch
        );
#endif
    }

void
__stdcall
EncTracingDefineOffsets(
    unsigned long WindowSize,
    unsigned long InterFileBytes,
    unsigned long OldFileSize
    )
{
}

#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encmacro.h ===
/*
 * encmacro.h
 *
 * Encoder macros
 */


/*
 * Returns the slot number of a match position (uses table lookup) 
 */
#define MP_SLOT(matchpos) \
   ((matchpos) < 1024 ?										\
		context->enc_slot_table[(matchpos)] :					\
			( (matchpos) < 524288L ?						\
				(18 + context->enc_slot_table[(matchpos) >> 9]) :   \
				(34 + ((matchpos) >> 17))		\
		)													\
   )


/*
 * Is a given literal a match or an unmatched symbol?
 */
#define IsMatch(literal) (context->enc_ItemType[(literal) >> 3] & (1 << ((literal) & 7)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encdata.c ===
/*
 * encdata.c
 *
 * Encode a block into the output stream
 */

#include "encoder.h"

/*
 * Macro to output bits into the encoding stream
 */

#define OUTPUT_BITS(N,X) output_bits( context, (N), (X))

void output_bits( t_encoder_context *context, ulong numbits, ulong value ) {

    context->enc_bitbuf   |= ( value << ( context->enc_bitcount - numbits ));
    context->enc_bitcount -= (char)numbits;

    while ( context->enc_bitcount <= 16 ) {

        if ( context->enc_output_buffer_curpos >= context->enc_output_buffer_end ) {
             context->enc_output_buffer_curpos = context->enc_output_buffer_start;
             context->enc_output_overflow = true;
             }

        *context->enc_output_buffer_curpos++ = (byte)( context->enc_bitbuf >> 16 );
        *context->enc_output_buffer_curpos++ = (byte)( context->enc_bitbuf >> 24 );

        context->enc_bitbuf  <<= 16;
        context->enc_bitcount += 16;
        }
    }


#ifdef EXTRALONGMATCHES

#define OUTPUT_EXTRA_LENGTH(X) output_extra_length( context, (X))

void output_extra_length( t_encoder_context *context, ulong ExtraLength ) {

    //
    //  Extra match length is encoded like this:
    //
    //      0xxxxxxxx          (8-bit value)
    //      10xxxxxxxxxx       (10-bit value plus 2^8)
    //      110xxxxxxxxxxxx    (12-bit value plus 2^8 plus 2^10)
    //      111xxxxxxxxxxxxxxx (15-bit value)
    //
    //  15 bits is the largest possible because a match cannot
    //  span a 32K boundary.
    //

    ulong EncodingValue = ExtraLength;

    ASSERT( ExtraLength < 32768 );

    if ( EncodingValue < ( 1 << 8 )) {
        OUTPUT_BITS( 9, EncodingValue );
        }
    else {

        EncodingValue -= ( 1 << 8 );

        if ( EncodingValue < ( 1 << 10 )) {
            OUTPUT_BITS( 12, (( 1 << 11 ) | EncodingValue ));
            }

        else {

            EncodingValue -= ( 1 << 10 );

            if ( EncodingValue < ( 1 << 12 )) {
                OUTPUT_BITS( 15, (( 1 << 14 ) | ( 1 << 13 ) | EncodingValue ));
                }

            else {
                OUTPUT_BITS( 3, 7 );    // can't OUTPUT_BITS more than 16 per call
                OUTPUT_BITS( 15, ExtraLength );
                }
            }
        }
    }

#endif /* EXTRALONGMATCHES */


/*
 * Given the initial state of the repeated offset buffers at
 * the beginning of this block, calculate the final state of the
 * repeated offset buffers after outputting this block as if it
 * were compressed data.
 *
 * First try to do it the quick way, by starting at the last
 * match and working backwards, to find three consecutive matches
 * which don't use repeated offsets.  If this fails, we'll have
 * to take the initial state of the three offsets at the beginning
 * of the block, and evolve them to the end of the block.
 */
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances)
{
    ulong                   MatchPos;
    signed long             d; /* must be signed */
    byte                    consecutive;

    consecutive = 0;

    for (d = distances-1; d >= 0; d--)
        {
        if (context->enc_DistData[d] > 2)
            {
            /* NOT a repeated offset */
            consecutive++;

            /* do we have three consecutive non-repeated-offsets? */
            if (consecutive >= 3)
                break;
            }
        else
            {
            consecutive = 0;
            }
        }

    /*
     * If we didn't find three consecutive matches which
     * don't use repeated offsets, then we have to start
     * from the beginning and evolve the repeated offsets.
     *
     * Otherwise, we start at the first of the consecutive
     * matches.
     */
    if (consecutive < 3)
        {
        d = 0;
        }

    for (; d < (signed long) distances; d++)
        {
        MatchPos = context->enc_DistData[d];

        if (MatchPos == 0)
            {
            }
        else if (MatchPos <= 2)
            {
            ulong   temp;

            temp = context->enc_repeated_offset_at_literal_zero[MatchPos];
            context->enc_repeated_offset_at_literal_zero[MatchPos] = context->enc_repeated_offset_at_literal_zero[0];
            context->enc_repeated_offset_at_literal_zero[0] = temp;
            }
        else
            {
            context->enc_repeated_offset_at_literal_zero[2] = context->enc_repeated_offset_at_literal_zero[1];
            context->enc_repeated_offset_at_literal_zero[1] = context->enc_repeated_offset_at_literal_zero[0];
            context->enc_repeated_offset_at_literal_zero[0] = MatchPos-2;
            }
        }
}


/*
 * Encode a block with no compression
 *
 * bufpos is the position in the file from which the first
 * literal in this block starts.  To reference memory, we will
 * use enc_MemWindow[bufpos] (remember that enc_MemWindow is
 * moved backwards every time we copymem).
 *
 * Since this data was originally matched into the compressor,
 * our recent match offsets will have been changed; however,
 * since this is an uncompressed block, the decoder won't be
 * updating them.  Therefore, we need to tell the decoder
 * the state of the match offsets after it has finished
 * decoding the uncompressed data - we store these in this
 * block.
 */
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size)
{
    int     i;
    int     j;
    bool    block_size_odd;
    ulong   val;

    /*
     * Align on a byte boundary
     */
    output_bits(context, context->enc_bitcount-16, 0);

    /*
     * Now output the contents of the repeated offset
     * buffers, since we need to preserve the state of
     * the encoder
     */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
        {
        val = context->enc_repeated_offset_at_literal_zero[i];

        for (j = 0; j < sizeof(long); j++)
            {
            *context->enc_output_buffer_curpos++ = (byte) val;
            val >>= 8;
            }
        }

    block_size_odd = block_size & 1;

    /*
     * Write out uncompressed data
     */
    while (block_size > 0)
        {
        *context->enc_output_buffer_curpos++ = context->enc_MemWindow[bufpos];

        bufpos++;
        block_size--;
        context->enc_input_running_total++;

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }
        }

    /*
     * Add pad byte to keep the output word-aligned
     */
    if (block_size_odd)
        {
        *context->enc_output_buffer_curpos++ = 0;
        }

    context->enc_bitcount   = 32;
    context->enc_bitbuf     = 0;
}


/*
 * Estimate the size of the data in the buffer, in bytes
 */
ulong estimate_compressed_block_size(t_encoder_context *context)
{
    ulong                   block_size = 0; /* output size in bits */
    ulong                   i;
    ulong                   mpslot;

    /* Estimation of tree size */
    block_size = 150*8;

    /* Tally bits to output characters */
    for (i = 0; i < NUM_CHARS; i++)
        block_size += (context->enc_main_tree_len[i]*context->enc_main_tree_freq[i]);

    /* Tally bits to output matches */
    for (mpslot = 0; mpslot < context->enc_num_position_slots; mpslot++)
        {
        long    element;
        int             primary;

        element = NUM_CHARS + (mpslot << NL_SHIFT);

        /* For primary == NUM_PRIMARY_LENGTHS we have secondary lengths */
        for (primary = 0; primary <= NUM_PRIMARY_LENGTHS; primary++)
            {
            block_size += ((context->enc_main_tree_len[element] + enc_extra_bits[mpslot]) *
                           context->enc_main_tree_freq[element]);
            element++;
            }
        }

    for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
        block_size += (context->enc_secondary_tree_freq[i] * context->enc_secondary_tree_len[i]);

    /* round up */
    return (block_size+7) >> 3;
}

/*
 * Encode block with NO special encoding of the lower 3
 * position bits
 */
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at)
{
    ulong           MatchPos;
    ulong           d = 0;
    ulong           l = 0;
    ulong           MatchLength;
    byte            c;
    ulong           mpSlot;

    for ( l = 0; l < literal_to_end_at; l++ ) {

        if (!IsMatch(l))
            {
            c = context->enc_LitData[l];
            OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);
            context->enc_input_running_total++;
            }
        else
            {
            /* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
            MatchLength = context->enc_LitData[l];

            /* Delta match pos */
            MatchPos = context->enc_DistData[d++];

            mpSlot = MP_SLOT(MatchPos);

            if (MatchLength < NUM_PRIMARY_LENGTHS)
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
                           context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
                           );
                }
            else
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len [(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
                           context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
                           );

                OUTPUT_BITS(
                           context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
                           context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
                           );
                }

            if (enc_extra_bits[ mpSlot ])
                {
                OUTPUT_BITS(
                           enc_extra_bits[mpSlot],
                           MatchPos & enc_slot_mask[mpSlot]
                           );
                }

#ifdef EXTRALONGMATCHES

            if ( MatchLength == ( MAX_MATCH - MIN_MATCH )) {
                MatchLength += context->enc_ExtraLength[ l ];
                OUTPUT_EXTRA_LENGTH( context->enc_ExtraLength[ l ] );
                }
#endif

            context->enc_input_running_total += (MatchLength+MIN_MATCH);
            }

        _ASSERTE (context->enc_input_running_total <= CHUNK_SIZE);

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
        }
}


/*
 * aligned block encoding
 */
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at)
{
    ulong   MatchPos;
    ulong   MatchLength;
    byte    c;
    ulong   mpSlot;
    byte    Lower;
    ulong   l = 0;
    ulong   d = 0;

    for ( l = 0; l < literal_to_end_at; l++ ) {

        if (!IsMatch(l))
            {
            c = context->enc_LitData[l];
            OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);
            context->enc_input_running_total++;
            }
        else
            {
            /* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
            MatchLength = context->enc_LitData[l];

            /* Delta match pos */
            MatchPos = context->enc_DistData[d++];

            mpSlot = MP_SLOT(MatchPos);

            if (MatchLength < NUM_PRIMARY_LENGTHS)
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
                           context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
                           );
                }
            else
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ (NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
                           context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
                           );

                OUTPUT_BITS(
                           context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
                           context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
                           );
                }

            if (enc_extra_bits[ mpSlot ] >= 3)
                {
                if (enc_extra_bits[ mpSlot ] > 3)
                    {
                    OUTPUT_BITS(
                               enc_extra_bits[mpSlot] - 3,
                               (MatchPos >> 3) & ( (1 << (enc_extra_bits[mpSlot]-3)) -1)
                               );
                    }

                Lower = (byte) (MatchPos & 7);

                OUTPUT_BITS(
                           context->enc_aligned_tree_len[Lower],
                           context->enc_aligned_tree_code[Lower]
                           );
                }
            else if (enc_extra_bits[ mpSlot ])
                {
                OUTPUT_BITS(
                           enc_extra_bits[mpSlot],
                           MatchPos & enc_slot_mask[ mpSlot ]
                           );
                }

#ifdef EXTRALONGMATCHES

            if ( MatchLength == ( MAX_MATCH - MIN_MATCH )) {
                MatchLength += context->enc_ExtraLength[ l ];
                OUTPUT_EXTRA_LENGTH( context->enc_ExtraLength[ l ] );
                }
#endif

            context->enc_input_running_total += (MatchLength+MIN_MATCH);
            }

        _ASSERTE (context->enc_input_running_total <= CHUNK_SIZE);

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
        }
}


void perform_flush_output_callback(t_encoder_context *context)
{
    long    output_size;

    /*
     * Do this only if there is any input to account for, so we don't
     * end up outputting blocks where comp_size > 0 and uncmp_size = 0.
     */
    if (context->enc_input_running_total > 0)
        {
        flush_output_bit_buffer(context);

        output_size = (ulong)(context->enc_output_buffer_curpos - context->enc_output_buffer_start);

        if (output_size > 0)
            {
            (*context->enc_output_callback_function)(
                                                    context->enc_fci_data,
                                                    context->enc_output_buffer_start,
                                                    (ulong)(context->enc_output_buffer_curpos - context->enc_output_buffer_start),
                                                    context->enc_input_running_total
                                                    );
            }
        }

    context->enc_input_running_total = 0;
    context->enc_output_buffer_curpos = context->enc_output_buffer_start;

    /* initialise bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\bsearch.c ===
/*
 * bsearch.c
 *
 * Binary search for optimal encoder
 */
#include "encoder.h"


#define left    context->enc_Left
#define right   context->enc_Right


/*
 * Define this to force checking that all search locations visited
 * are valid.
 *
 * For debugging purposes only.
 */
#ifdef _DEBUG
    #define VERIFY_SEARCHES
#endif

#define VERIFY_SEARCH_CODE(routine_name) \
{ \
        int debug_search; \
        for (debug_search = 0; debug_search < clen; debug_search++) \
        { \
            _ASSERTE( context->enc_MemWindow[ptr+debug_search] == context->enc_MemWindow[BufPos+debug_search]); \
        } \
}

#define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
_ASSERTE (context->enc_MemWindow[BufPos] == context->enc_MemWindow[ptr]); \
_ASSERTE (context->enc_MemWindow[BufPos+1] == context->enc_MemWindow[ptr+1]);



/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->enc_matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */

#ifndef ASM_BSEARCH_FINDMATCH
long binary_search_findmatch(t_encoder_context *context, long BufPos)
{
    ulong       ptr;
    ulong       a, b;
    ulong       *small_ptr, *big_ptr;
    ulong       end_pos;
    int         val; /* must be signed */
    int         bytes_to_boundary;
    int         clen;
    int         same;
    int         match_length;
    int         small_len, big_len;
    int         i, best_repeated_offset;
    #ifdef MULTIPLE_SEARCH_TREES
    ushort      tree_to_use;

    /*
     * Retrieve root node of tree to search, and insert current node at
     * the root.
     */
    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);

    ptr        = context->enc_tree_root[tree_to_use];
    context->enc_tree_root[tree_to_use] = BufPos;
    #else
    ptr = context->enc_single_tree_root;
    context->enc_single_tree_root = BufPos;
    #endif
    /*
     * end_pos is the furthest location back we will search for matches
     *
     * Remember that our window size is reduced by 3 bytes because of
     * our repeated offset codes.
     *
     * Since BufPos starts at context->enc_window_size when compression begins,
     * end_pos will never become negative.
     */
    end_pos = BufPos - (context->enc_window_size-4);

    /*
     * Root node is either NULL, or points to a really distant position.
     */
    if (ptr <= end_pos)
        {
        left[BufPos] = right[BufPos] = 0;
        return 0;
        }

    #ifdef MULTIPLE_SEARCH_TREES
    /*
     * confirmed length (no need to check the first clen chars in a search)
     *
     * note: clen is always equal to min(small_len, big_len)
     */
    clen            = 2;

    /*
     * current best match length
     */
    match_length    = 2;

    /*
     * longest match which is < our string
     */
    small_len       = 2;

    /*
     * longest match which is > our string
     */
    big_len         = 2;

    /*
     * record match position for match length 2
     */
    context->enc_matchpos_table[2] = BufPos - ptr + 2;

        #ifdef VERIFY_SEARCHES
    VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
        #endif

    #else /* !MULTIPLE_SEARCH_TREES */

    clen            = 0;
    match_length    = 0;
    small_len       = 0;
    big_len         = 0;

    #endif /* MULTIPLE_SEARCH_TREES */

    /*
     * pointers to nodes to check
     */
    small_ptr             = &left[BufPos];
    big_ptr               = &right[BufPos];

    do
        {
        /* compare bytes at current node */
        same = clen;

    #ifdef VERIFY_SEARCHES
        VERIFY_SEARCH_CODE("binary_search_findmatch()")
    #endif

        /* don't need to check first clen characters */
        a    = ptr + clen;
        b    = BufPos + clen;

        while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
            {
            /* don't exceed MAX_MATCH */
            if (++same >= MAX_MATCH)
                goto long_match;
            }

        if (val < 0)
            {
            if (same > big_len)
                {
                if (same > match_length)
                    {
                    long_match:
                    do
                        {
                        context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
                        } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                        {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                        }
                    }

                big_len = same;
                clen = min(small_len, big_len);
                }

            *big_ptr = ptr;
            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
            }
        else
            {
            if (same > small_len)
                {
                if (same > match_length)
                    {
                    do
                        {
                        context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
                        } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                        {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                        }
                    }

                small_len = same;
                clen = min(small_len, big_len);
                }

            *small_ptr = ptr;
            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
            }
        } while (ptr > end_pos); /* while we don't go too far backwards */

    *small_ptr = 0;
    *big_ptr   = 0;


    end_bsearch:

    /*
     * If we have multiple search trees, we are already guaranteed
     * a minimum match length of 2 when we reach here.
     *
     * If we only have one tree, then we're not guaranteed anything.
     */
    #ifndef MULTIPLE_SEARCH_TREES
    if (match_length < MIN_MATCH)
        return 0;
    #endif

    /*
     * Check to see if any of our match lengths can
     * use repeated offsets.
     */

    /*
     * repeated offset 1
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[0]+i])
            break;
        }

    /*
     * the longest repeated offset
     */
    best_repeated_offset = i;

    if (i >= MIN_MATCH)
        {
        /*
         * Yes, we can do a repeated offset for some match lengths; replace
         * their positions with the repeated offset position
         */
        do
            {
            context->enc_matchpos_table[i] = 0; /* first repeated offset position */
            } while (--i >= MIN_MATCH);

        /* A speed optimization to cope with long runs of bytes */
        if (best_repeated_offset > BREAK_LENGTH)
            goto quick_return;
        }

    /*
     * repeated offset 2
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[1]+i])
            break;
        }

    /*
     * Does the second repeated offset provide a longer match?
     *
     * If so, leave the first repeated offset alone, but fill out the
     * difference in match lengths in the table with repeated offset 1.
     */
    if (i > best_repeated_offset)
        {
        do
            {
            context->enc_matchpos_table[++best_repeated_offset] = 1;
            } while (best_repeated_offset < i);
        }

    /*
     * repeated offset 3
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[2]+i])
            break;
        }

    /*
     * Does the third repeated offset provide a longer match?
     */
    if (i > best_repeated_offset)
        {
        do
            {
            context->enc_matchpos_table[++best_repeated_offset] = 2;
            } while (best_repeated_offset < i);
        }

    quick_return:

    /*
     * Don't let a match cross a 32K boundary
     */
    bytes_to_boundary = (CHUNK_SIZE-1) - ((int) BufPos & (CHUNK_SIZE-1));

    if (match_length > bytes_to_boundary)
        {
        match_length = bytes_to_boundary;

        if (match_length < MIN_MATCH)
            match_length = 0;
        }

    return (long) match_length;
}
#endif


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
#ifndef ASM_QUICK_INSERT_BSEARCH_FINDMATCH
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long end_pos)
{
    long        ptr;
    ulong       a,b;
    ulong       *small_ptr, *big_ptr;
    int         val;
    int         small_len, big_len;
    int         same;
    int         clen;
    #ifdef MULTIPLE_SEARCH_TREES
    ushort      tree_to_use;

    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
    ptr        = context->enc_tree_root[tree_to_use];
    context->enc_tree_root[tree_to_use] = BufPos;
    #else
    ptr = context->enc_single_tree_root;
    context->enc_single_tree_root = BufPos;
    #endif

    if (ptr <= end_pos)
        {
        left[BufPos] = right[BufPos] = 0;
        return;
        }

    #ifdef MULTIPLE_SEARCH_TREES
    clen            = 2;
    small_len       = 2;
    big_len         = 2;

        #ifdef VERIFY_SEARCHES
    VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
        #endif

    #else
    clen            = 0;
    small_len       = 0;
    big_len         = 0;
    #endif

    small_ptr       = &left[BufPos];
    big_ptr         = &right[BufPos];

    do
        {
        _ASSERTE ((ulong) ptr >= (ulong) (context->enc_RealLeft - context->enc_Left));

        same = clen;

        a    = ptr+clen;
        b    = BufPos+clen;

    #ifdef VERIFY_SEARCHES
        VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
    #endif

        while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
            {
            /*
             * Here we break on BREAK_LENGTH, not MAX_MATCH
             */
            if (++same >= BREAK_LENGTH)
                break;
            }

        if (val < 0)
            {
            if (same > big_len)
                {
                if (same >= BREAK_LENGTH)
                    {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];
                    return;
                    }

                big_len = same;
                clen = min(small_len, big_len);
                }

            *big_ptr = ptr;
            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
            }
        else
            {
            if (same > small_len)
                {
                if (same >= BREAK_LENGTH)
                    {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];
                    return;
                    }

                small_len = same;
                clen = min(small_len, big_len);
                }

            *small_ptr = ptr;
            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
            }
        } while (ptr > end_pos);

    *small_ptr = 0;
    *big_ptr   = 0;
}
#endif


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos)
{
    ulong   ptr;
    ulong   left_node_pos;
    ulong   right_node_pos;
    ulong   *link;
#ifdef MULTIPLE_SEARCH_TREES
    ushort  tree_to_use;

    /*
     * The root node of tree_to_use should equal BufPos, since that is
     * the most recent insertion into that tree - but if we never
     * inserted this string (because it was a near match or a long
     * string of zeroes), then we can't remove it.
     */
    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);


    /*
     * If we never inserted this string, do not attempt to remove it
     */

    if (context->enc_tree_root[tree_to_use] != (ulong) BufPos)
        return;

    link = &context->enc_tree_root[tree_to_use];
#else
    if (context->enc_single_tree_root != (ulong) BufPos)
        return;

    link = &context->enc_single_tree_root;
#endif

    /*
     * If the last occurence was too far away
     */
    if (*link <= end_pos)
        {
        *link = 0;
        left[BufPos] = right[BufPos] = 0;
        return;
        }

    /*
     * Most recent location of these chars
     */
    ptr             = BufPos;

    /*
     * Most recent location of a string which is "less than" it
     */
    left_node_pos   = left[ptr];

    if (left_node_pos <= end_pos)
        left_node_pos = left[ptr] = 0;

    /*
     * Most recent location of a string which is "greater than" it
     */
    right_node_pos  = right[ptr];

    if (right_node_pos <= end_pos)
        right_node_pos = right[ptr] = 0;

    while (1)
        {
#ifdef VERIFY_SEARCHES
        _ASSERTE (left_node_pos < (ulong) BufPos);
        _ASSERTE (right_node_pos < (ulong) BufPos);
#endif

        /*
         * If left node position is greater than right node position
         * then follow the left node, since that is the more recent
         * insertion into the tree.  Otherwise follow the right node.
         */
        if (left_node_pos > right_node_pos)
            {
            /*
             * If it's too far away, then store that it never happened
             */
            if (left_node_pos <= end_pos)
                left_node_pos = 0;

            ptr = *link = left_node_pos;

            if (!ptr)
                break;

            left_node_pos   = right[ptr];
            link            = &right[ptr];
            }
        else
            {
            /*
             * If it's too far away, then store that it never happened
             */
            if (right_node_pos <= end_pos)
                right_node_pos = 0;

            ptr = *link = right_node_pos;

            if (!ptr)
                break;

            right_node_pos  = left[ptr];
            link            = &left[ptr];
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encdefs.h ===
/*
 * encdefs.h
 *
 * Encoder #define's and structure definitions.
 */

/*
 * NOTES:
 *
 * To maximise compression one can set both BREAK_LENGTH
 * and FAST_DECISION_THRESHOLD to 250, define
 * INSERT_NEAR_LONG_MATCHES, and crank up EXTRA_SIZE to
 * a larger value (don't get too large, otherwise we
 * might overflow our ushort cumbits[]), but the improvement
 * is really  marginal; e.g. 3600 bytes on winword.exe
 * (3.9 MB compressed).  It really hurts performance too.
 */


/*
 * See optenc.c
 *
 * EXTRA_SIZE is the amount of extra data we allocate in addition
 * to the window, and LOOK is the amount of data the optimal
 * parser will look ahead.  LOOK is dependent on EXTRA_SIZE.
 *
 * Changing EXTRA_SIZE to 8K doesn't really do anything for
 * compression.  4K is a fairly optimal value.
 *
 */
#define EXTRA_SIZE   16384
#define LOOK         (EXTRA_SIZE-MAX_MATCH-2)


/*
 * Number of search trees used (for storing root nodes)
 */
#define NUM_SEARCH_TREES 65536


/*
 * Chunk size required by FCI
 */
#define CHUNK_SIZE 32768


/*
 * The maximum amount of data we will allow in our output buffer before
 * calling lzx_output_callback() to get rid of it.  Since we do this
 * for every 32K of input data, the output buffer only has to be able
 * to contain 32K + some spillover, which won't be much, because we
 * output uncompressed blocks if we determine a block is going to be
 * too large.
 */
#define OUTPUT_BUFFER_SIZE (CHUNK_SIZE+MAX_GROWTH)


/*
 * Maximum allowable number of block splits per 32K of uncompressed
 * data; if increased, then MAX_GROWTH will have to be increased also.
 */
#define MAX_BLOCK_SPLITS    4


/*
 * Max growth is calculated as follows:
 *
 * TREE AND BLOCK INFO
 * ===================
 *
 * The very first time the encoder is run, it outputs a 32 bit
 * file translation size.
 *
 * 3 bits to output block type
 * 24 bits for block size in uncompressed bytes.
 *
 * Max size of a tree of n elements is 20*4 + 5*n bits
 *
 * There is a main tree of max 700 elements which is really encoded
 * as two separate trees of 256 and 444(max).  There is also a
 * secondary length tree of 249 elements.
 *
 * That is 1360 bits, plus 2300 bits, plus 1325 bits.
 *
 * There may also be an aligned offset tree, which is 24 bits.
 *
 * Flushing output bit buffer; max 16 bits.
 *
 * Grand total: 5084 bits/block.
 *
 *
 * PARSER INFO
 * ===========
 *
 * Parser worst case scenario is with 2 MB buffer (50 position slots),
 * all matches of length 2, distributed over slots 32 and 33 (since
 * matches of length 2 further away than 128K are prohibited).  These
 * slots have 15 verbatim bits.  Maximum size per code is then
 * 2 bits to say which slot (taking into account that there will be
 * at least another code in the tree) plus 15 verbatim bits, for a
 * total of 17 bits.  Max growth on 32K of input data is therefore
 * 1/16 * 32K, or 2K bytes.
 *
 * Alternatively, if there is only one match and everything else
 * is a character, then 255 characters will be length 8, and one
 * character and the match will be length 9.  Assume the true
 * frequency of the demoted character is almost a 1 in 2^7
 * probability (it got remoted from a 2^8, but it was fairly
 * close to being 2^7).  If there are 32768/256, or 128, occurrences
 * of each character, but, say, almost 256 for the demoted character,
 * then the demoted character will expand the data by less than
 * 1 bit * 256, or 256 bits.  The match will take a little to
 * output, but max growth for "all characters" is about 256 bits.
 *
 *
 * END RESULT
 * ==========
 *
 * The maximum number of blocks which can be output is limited to
 * 4 per 32K of uncompressed data.
 *
 * Therefore, max growth is 4*5084 bits, plus 2K bytes, or 4590
 * bytes.
 */
#define     MAX_GROWTH          6144

/*
 * Don't allow match length 2's which are further away than this
 * (see above)
 */
#define     MAX_LENGTH_TWO_OFFSET (128*1024)


/*
 * When we find a match which is at least this long, prematurely
 * exit the binary search.
 *
 * This avoids us inserting huge match lengths of 257 zeroes, for
 * example.  Compression will improve very *very* marginally by
 * increasing this figure, but it will seriously impact
 * performance.
 *
 * Don't make this number >= (MAX_MATCH-2); see bsearch.c.
 */
#define BREAK_LENGTH 100


/*
 * If this option is defined, the parser will insert all bytes of
 * matches with lengths >= 16 with a distance of 1; this is a bad
 * idea, since matches like that are generally zeroes, which we
 * want to avoid inserting into the search tree.
 */

//#define INSERT_NEAR_LONG_MATCHES


/*
 * If the optimal parser finds a match which is this long or
 * longer, it will take it automatically.  The compression
 * penalty is basically zero, and it helps performance.
 */
#define FAST_DECISION_THRESHOLD 100


/*
 * Every TREE_CREATE_INTERVAL items, recreate the trees from
 * the literals we've encountered so far, to update our cost
 * estimations.
 *
 * 4K seems pretty optimal.
 */
#define TREE_CREATE_INTERVAL 4096


/*
 * When we're forced to break in our parsing (we exceed
 * our span), don't output a match length 2 if it is
 * further away than this.
 *
 * Could make this a variable rather than a constant
 *
 * On a bad binary file, two chars    = 18 bits
 * On a good text file, two chars     = 12 bits
 *
 * But match length two's are very uncommon on text files.
 */
#define BREAK_MAX_LENGTH_TWO_OFFSET 2048


/*
 * When MatchPos >= MPSLOT3_CUTOFF, extra_bits[MP_SLOT(MatchPos)] >= 3
 *
 * matchpos:  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
 * extrabits: 0,0,0,0,1,1,1,1,2,2, 2, 2, 2, 2, 2, 2, 3, ...
 *
 * Used for aligned offset blocks and statistics.
 */
#define MPSLOT3_CUTOFF 16


/*
 * Number of elements in the main tree
 */
#define MAIN_TREE_ELEMENTS                      (NUM_CHARS+(((long) context->enc_num_position_slots) << NL_SHIFT))


/*
 * Max number of literals to hold.
 *
 * Memory required is MAX_LITERAL_ITEMS for enc_LitData[] array,
 * plus MAX_LITERAL_ITEMS/8 for enc_ItemType[] array.
 *
 * Must not exceed 64K, since that will cause our ushort
 * frequencies to overflow.
 */
#define MAX_LITERAL_ITEMS  65536


/*
 * Max number of distances to hold
 *
 * Memory required is MAX_DIST_ITEMS*4 for enc_DistData[] array
 *
 * MAX_DIST_ITEMS should never be greater than MAX_LITERAL_ITEMS,
 * since that just wastes space.
 *
 * However, it's extremely unlikely that one will get 65536 match
 * length 2's!  In any case, the literal and distance buffers
 * are checked independently, and a block is output if either
 * overflows.
 *
 * Bitmaps are highly redundant, though; lots of matches.
 */
#define MAX_DIST_ITEMS     32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encapi.h ===
/*
 * encapi.h
 *
 * Definitions for calling LZX apis (encapi.c)
 */

/*
 * Return codes for LZX_Encode()
 */
#define ENCODER_SUCCESS         0
#define ENCODER_READ_FAILURE    1
#define ENCODER_WRITE_FAILURE   2
#define ENCODER_CONSOLE_FAILURE 3

bool
__fastcall
LZX_EncodeInit(
    t_encoder_context **  enc_context,
    long                  compression_window_size,
    long                  second_partition_size,
    PFNALLOC              pfnma,
    HANDLE                hAllocator,
    int (__stdcall * pfnlzx_output_callback)(
        void *            pfol,
        unsigned char *   compressed_data,
        long              compressed_size,
        long              uncompressed_size
        ),
    void *                fci_data
    );

void __fastcall LZX_EncodeNewGroup(t_encoder_context *context);

long __fastcall LZX_Encode(
        t_encoder_context *     context,
        byte *                  input_data,
        long                    input_size,
        long *                  bytes_compressed,
        long                    file_size_for_translation
);

bool __fastcall LZX_EncodeFlush(t_encoder_context *context);

bool __fastcall LZX_EncodeResetState(t_encoder_context *context);

unsigned char * __fastcall LZX_GetInputData(
    t_encoder_context *context,
    unsigned long *input_position,
    unsigned long *bytes_available
);

bool __fastcall LZX_EncodeInsertDictionary(
                       t_encoder_context *context,
                       byte *             input_data,
                       unsigned long      input_size
                       );


#ifdef TRACING

#include <stdio.h>

void
__stdcall
EncTracingMatch(
    unsigned long BufPos,
    unsigned long MatchLength,
    unsigned long MatchPos,
    unsigned long MatchOff
    );

void
__stdcall
EncTracingLiteral(
    unsigned long BufPos,
    unsigned long ch
    );

void
__stdcall
EncTracingDefineOffsets(
    unsigned long WindowSize,
    unsigned long InterFileBytes,
    unsigned long OldFileSize
    );

#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encoder.h ===
/*
 * encoder.h
 *
 * Main header file; includes everything else
 */

#ifndef ENCODER_H
#define ENCODER_H


#ifdef USE_ASSEMBLY
#   define ASM_BSEARCH_FINDMATCH
//#   define ASM_QUICK_INSERT_BSEARCH_FINDMATCH
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <stdlib.h>
#include <string.h>

#ifndef ASSERT

    #if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

        int
        __stdcall
        Assert(
            const char *szText,
            const char *szFile,
            unsigned    uLine
            );

        #define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))

    #else

        #define ASSERT( a )

    #endif

#endif // ASSERT

#ifndef _ASSERTE

    #define _ASSERTE( a ) ASSERT( a )

#endif

#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "encdefs.h"
#include "encvars.h"
#include "encmacro.h"
#include "encapi.h"
#include "encproto.h"

#endif  /* ENCODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encstats.c ===
/*
 * encstats.c
 *
 * Routines for calculating statistics on a block of data which
 * has been compressed, but not yet output.
 *
 * These routines are used to determine which encoding method to use
 * to output the block.
 */

#include "encoder.h"



static void tally_aligned_bits(t_encoder_context *context, ulong dist_to_end_at)
{
        ulong   *dist_ptr;
        ulong   i;
        ulong   match_pos;

        /*
     * Tally the lower 3 bits
     */
        dist_ptr = context->enc_DistData;

        for (i = dist_to_end_at; i > 0; i--)
        {
                match_pos = *dist_ptr++;

                /*
                 * Only for matches which have >= 3 extra bits
                 */
                if (match_pos >= MPSLOT3_CUTOFF)
                        context->enc_aligned_tree_freq[match_pos & 7]++;
        }
}


/*
 * Determine whether it is advantageous to use aligned block
 * encoding on the block.
 */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at)
{
        byte            i;
        ulong           total_L3 = 0;
        ulong           largest_L3 = 0;

        memset(
                context->enc_aligned_tree_freq,
                0,
                ALIGNED_NUM_ELEMENTS * sizeof(context->enc_aligned_tree_freq[0])
        );

        tally_aligned_bits(context, dist_to_end_at);

        for (i = 0; i < ALIGNED_NUM_ELEMENTS; i++)
        {
                if (context->enc_aligned_tree_freq[i] > largest_L3)
                        largest_L3 = context->enc_aligned_tree_freq[i];

                total_L3 += context->enc_aligned_tree_freq[i];
        }

        /*
         * Do aligned offsets if the largest frequency accounts for 20%
         * or more (as opposed to 12.5% for non-aligned offset blocks).
         *
         * Not worthwhile to do aligned offsets if we have < 100 matches
         */
        if ((largest_L3 > total_L3/5) && dist_to_end_at >= 100)
                return BLOCKTYPE_ALIGNED;
        else
                return BLOCKTYPE_VERBATIM;
}


/*
 * Calculates the frequency of each literal, and returns the total
 * number of uncompressed bytes compressed in the block.
 */
static ulong tally_frequency(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        ulong   i;
        ulong   d;
        ulong   compressed_bytes = 0;

        d = distance_to_start_at;

        for (i = literal_to_start_at; i < literal_to_end_at; i++)
        {
                if (!IsMatch(i))
                {
                        /* Uncompressed symbol */
                        context->enc_main_tree_freq[context->enc_LitData[i]]++;
                        compressed_bytes++;
                }
                else
                {
                        /* Match */
                        if (context->enc_LitData[i] < NUM_PRIMARY_LENGTHS)
                        {
                                context->enc_main_tree_freq[ NUM_CHARS + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT) + context->enc_LitData[i]] ++;
                        }
                        else
                        {
                                context->enc_main_tree_freq[ (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT)] ++;
                                context->enc_secondary_tree_freq[context->enc_LitData[i] - NUM_PRIMARY_LENGTHS] ++;
                        }

                        compressed_bytes += context->enc_LitData[i]+MIN_MATCH;

#ifdef EXTRALONGMATCHES
                        if (( context->enc_LitData[ i ] + MIN_MATCH ) == MAX_MATCH ) {
                            compressed_bytes += context->enc_ExtraLength[ i ];
                            }
#endif

                        d++;
                }
        }

        return compressed_bytes;
}


/*
 * Get statistics
 */
ulong get_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        memset(
                context->enc_main_tree_freq,
                0,
                MAIN_TREE_ELEMENTS * sizeof(context->enc_main_tree_freq[0])
        );

        memset(
                context->enc_secondary_tree_freq,
                0,
                NUM_SECONDARY_LENGTHS * sizeof(context->enc_secondary_tree_freq[0])
        );

        return tally_frequency(
                context,
                literal_to_start_at,
                distance_to_start_at,
                literal_to_end_at
        );
}


/*
 * Update cumulative statistics
 */
ulong update_cumulative_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        return tally_frequency(
                context,
                literal_to_start_at,
                distance_to_start_at,
                literal_to_end_at
        );
}



/*
 * Used in block splitting
 *
 * This routine calculates the "difference in composition" between
 * two different sections of compressed data.
 *
 * Resolution must be evenly divisible by STEP_SIZE, and must be
 * a power of 2.
 */
#define RESOLUTION                              1024

/*
 * Threshold for determining if two blocks are different
 *
 * If enough consecutive blocks are this different, the block
 * splitter will start investigating, narrowing down the
 * area where the change occurs.
 *
 * It will then look for two areas which are
 * EARLY_BREAK_THRESHOLD (or more) different.
 *
 * If THRESHOLD is too small, it will force examination
 * of a lot of blocks, slowing down the compressor.
 *
 * The EARLY_BREAK_THRESHOLD is the more important value.
 */
#define THRESHOLD                               1400

/*
 * Threshold for determining if two blocks are REALLY different
 */
#define EARLY_BREAK_THRESHOLD   1700

/*
 * Must be >= 8 because ItemType[] array is in bits
 *
 * Must be a power of 2.
 *
 * This is the step size used to narrow down the exact
 * best point to split the block.
 */
#define STEP_SIZE               64

/*
 * Minimum # literals required to perform block
 * splitting at all.
 */
#define MIN_LITERALS_REQUIRED   6144

/*
 * Minimum # literals we will allow to be its own block.
 *
 * We don't want to create blocks with too small numbers
 * of literals, otherwise the static tree output will
 * take up too much space.
 */
#define MIN_LITERALS_IN_BLOCK   4096


static const long square_table[17] =
{
        0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256
};


/*
 * log2(x) = x < 256 ? log2_table[x] : 8 + log2_table[(x >> 8)]
 *
 * log2(0)   = 0
 * log2(1)   = 1
 * log2(2)   = 2
 * log2(3)   = 2
 * log2(4)   = 3
 * log2(255) = 8
 * log2(256) = 9
 * log2(511) = 9
 * log2(512) = 10
 *
 * It's not a real log2; it's off by one because we have
 * log2(0) = 0.
 */
static const byte log2_table[256] =
{
        0,1,2,2,3,3,3,3,
        4,4,4,4,4,4,4,4,
        5,5,5,5,5,5,5,5,
        5,5,5,5,5,5,5,5,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8
};


/*
 * Return the difference between two sets of matches/distances
 */
static ulong return_difference(
        t_encoder_context *context,
        ulong item_start1,
        ulong item_start2,
        ulong dist_at_1,
        ulong dist_at_2,
        ulong size
)
{
        ushort  freq1[800];
        ushort  freq2[800];
        ulong   i;
        ulong   cum_diff;
        int             element;

        /*
         * Error!  Too many main tree elements
         */
        if (MAIN_TREE_ELEMENTS >= (sizeof(freq1)/sizeof(freq1[0])))
                return 0;

        memset(freq1, 0, sizeof(freq1[0])*MAIN_TREE_ELEMENTS);
        memset(freq2, 0, sizeof(freq2[0])*MAIN_TREE_ELEMENTS);

        for (i = 0; i < size; i++)
        {
                if (!IsMatch(item_start1))
                {
                        element = context->enc_LitData[item_start1];
                }
                else
                {
                        if (context->enc_LitData[item_start1] < NUM_PRIMARY_LENGTHS)
                                element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_1])<<NL_SHIFT) + context->enc_LitData[item_start1];
                        else
                                element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_1]) << NL_SHIFT);

                        dist_at_1++;
                }

                item_start1++;
                freq1[element]++;

                if (!IsMatch(item_start2))
                {
                        element = context->enc_LitData[item_start2];
                }
                else
                {
                        if (context->enc_LitData[item_start2] < NUM_PRIMARY_LENGTHS)
                                element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_2])<<NL_SHIFT) + context->enc_LitData[item_start2];
                        else
                                element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_2]) << NL_SHIFT);

                        dist_at_2++;
                }

                item_start2++;
                freq2[element]++;
        }

        cum_diff = 0;

        for (i = 0; i < (ulong) MAIN_TREE_ELEMENTS; i++)
        {
                ulong log2a, log2b, diff;

#define log2(x) ((x) < 256 ? log2_table[(x)] : 8+log2_table[(x) >> 8])

                log2a = (ulong) log2(freq1[i]);
                log2b = (ulong) log2(freq2[i]);

                /* diff = (log2a*log2a) - (log2b*log2b); */
                diff = square_table[log2a] - square_table[log2b];

                cum_diff += abs(diff);
        }

        return cum_diff;
}


/*
 * Calculates where and if a block of compressed data should be split.
 *
 * For example, if we have just compressed text data, audio data, and
 * more text data, then the composition of matches and unmatched
 * symbols will be different between the text data and audio data.
 * Therefore we force an end of block whenever the compressed data
 * looks like it's changing in composition.
 *
 * This routine currently cannot tell the difference between blocks
 * which should use aligned offsets, and blocks which should not.
 * However, there is little to be gained from looking for this change,
 * since it the match finder doesn't make an effort to look for
 * aligned offsets either.
 *
 * Returns whether we split the block or not.
 */
bool split_block(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong literal_to_end_at,
        ulong distance_to_end_at,       /* corresponds to # distances at literal_to_end_at */
        ulong *split_at_literal,
        ulong *split_at_distance        /* optional parameter (may be NULL) */
)
{
        ulong   i, j, d;
        int             nd;

        /*
         * num_dist_at_item[n] equals the cumulative number of matches
         * at literal "n / STEP_SIZE".
         */
        ushort  num_dist_at_item[(MAX_LITERAL_ITEMS/STEP_SIZE)+8]; /* +8 is slop */

        /*
         * default return
         */
        *split_at_literal       = literal_to_end_at;

        if (split_at_distance)
                *split_at_distance      = distance_to_end_at;

        /* Not worth doing if we don't have many literals */
        if (literal_to_end_at - literal_to_start_at < MIN_LITERALS_REQUIRED)
                return false;

    /* Not allowed to split blocks any more, so we don't overflow MAX_GROWTH? */
    if (context->enc_num_block_splits >= MAX_BLOCK_SPLITS)
        return false;

        /*
         * Keep track of the number of distances (matches) we've had,
         * at each step of STEP_SIZE literals.
         *
         * Look at 8 items at a time, and ignore the last
         * 0..7 items if they exist.
         */
        nd = 0;
        d = 0;

        for (i = 0; i < (literal_to_end_at >> 3); i++)
        {
                /*
                 * if (i % (STEP_SIZE >> 3)) == 0
                 */
                if ((i & ((STEP_SIZE >> 3)-1)) == 0)
                        num_dist_at_item[nd++] = (ushort) d;

                d += context->enc_ones[ context->enc_ItemType[i] ];
        }

        /*
         * Must be a multiple of STEP_SIZE
         */
        literal_to_start_at = (literal_to_start_at + (STEP_SIZE-1)) & (~(STEP_SIZE-1));

        /*
         * See where the change in composition occurs
         */
        for (   i = literal_to_start_at + 2*RESOLUTION;
                        i < literal_to_end_at - 4*RESOLUTION;
                        i += RESOLUTION)
        {
                /*
                 * If there appears to be a significant variance in composition
                 * between
                 *                    ___________
                 *                   /           \
                 *                A  B  i     X  Y  Z
                 *                \      \___/      /
                 *                 \_______________/
                 */
                if (
                        return_difference(
                                context,
                                i,
                                i+1*RESOLUTION,
                                (ulong) num_dist_at_item[i/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+1*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD
                        &&

                        return_difference(
                                context,
                                i-RESOLUTION,
                                i+2*RESOLUTION,
                                (ulong) num_dist_at_item[(i-RESOLUTION)/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+2*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD

                        &&

                        return_difference(
                                context,
                                i-2*RESOLUTION,
                                i+3*RESOLUTION,
                                (ulong) num_dist_at_item[(i-2*RESOLUTION)/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+3*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD
                        )
                {
                        ulong max_diff = 0;
                        ulong literal_split = 0;

                        /*
                         * Narrow down the best place to split block
                         *
                         * This really could be done much better; we could end up
                         * doing a lot of stepping;
                         *
                         * basically ((5/2 - 1/2) * RESOLUTION) / STEP_SIZE
                         *
                         * which is (2 * RESOLUTION) / STEP_SIZE,
                         * which with RESOLUTION = 1024 and STEP_SIZE = 32,
                         * equals 2048/32 = 64 steps.
                         */
                        for (j = i+RESOLUTION/2; j<i+(5*RESOLUTION)/2; j += STEP_SIZE)
                        {
                                ulong   diff;

                                diff = return_difference(
                                        context,
                                        j - RESOLUTION,
                                        j,
                                        (ulong) num_dist_at_item[(j-RESOLUTION)/STEP_SIZE],
                                        (ulong) num_dist_at_item[j/STEP_SIZE],
                                        RESOLUTION
                                );

                                /* Get largest difference */
                                if (diff > max_diff)
                                {
                                        /*
                                         * j should not be too small, otherwise we'll be outputting
                                         * a very small block
                                         */
                                        max_diff = diff;
                                        literal_split = j;
                                }
                        }

                        /*
                         * There could be multiple changes in the data in our literals,
                         * so if we find something really weird, make sure we break the
                         * block now, and not on some later change.
                         */
                        if (max_diff >= EARLY_BREAK_THRESHOLD &&
                                (literal_split-literal_to_start_at) >= MIN_LITERALS_IN_BLOCK)
                        {
                context->enc_num_block_splits++;

                                *split_at_literal = literal_split;

                                /*
                                 * Return the associated # distances, if required.
                                 * Since we split on a literal which is % STEP_SIZE, we
                                 * can read the # distances right off
                                 */
                                if (split_at_distance)
                                        *split_at_distance = num_dist_at_item[literal_split/STEP_SIZE];

                                return true;
                        }
                }
        }

        /*
         * No good place found to split
         */
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encproto.h ===
/*
 * encproto.h
 *
 * Encoder function prototypes
 */

/* blkinit.c */
void create_slot_lookup_table(t_encoder_context *context);
void create_ones_table(t_encoder_context *context);

/* block.c */
void output_block(t_encoder_context *context);
void flush_output_bit_buffer(t_encoder_context *context);
long estimate_buffer_contents(t_encoder_context *context);
ulong get_distances_from_literals(t_encoder_context *context, ulong literals);

/* bsearch.c */
long binary_search_findmatch(t_encoder_context *context, long BufPos);
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long endpos);
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos);

/* encdata.c */
void output_bits( t_encoder_context *context, ulong numbits, ulong value );
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size);
void perform_flush_output_callback(t_encoder_context *context);
ulong estimate_compressed_block_size(t_encoder_context *context);
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances);

/* encstats.c */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at);

ulong get_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
);

ulong update_cumulative_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
);

bool split_block(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong literal_to_end_at,
        ulong distance_to_end_at,
        ulong *split_at_literal,
        ulong *split_at_distance
);

/* enctree.c */
void create_trees(t_encoder_context *context, bool generate_codes);
void fix_tree_cost_estimates(t_encoder_context *context);
void encode_trees(t_encoder_context *context);
void encode_aligned_tree(t_encoder_context *context);
void prevent_far_matches(t_encoder_context *context);

/* init.c */
void init_compression_memory(t_encoder_context *context);
bool comp_alloc_compress_memory(t_encoder_context *context);

/* io.c */
bool init_compressed_output_buffer(t_encoder_context *context);
void flush_compressed_output_buffer(t_encoder_context *context);
void reset_translation(t_encoder_context *context);
long comp_read_input(t_encoder_context *context, ulong BufPos, long Size);

/* optenc.c */
void opt_encode_top(t_encoder_context *context, long BytesRead);
void reset_encoder_variables(t_encoder_context *context);
void flush_all_pending_blocks(t_encoder_context *context);
void encoder_start(t_encoder_context *context);

void make_tree(
        t_encoder_context *context,
        int             nparm,
        ushort  *freqparm,
        byte    *lenparm,
        ushort  *codeparm,
        bool    make_codes
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\enctree.c ===
/*
 * enctree.c
 *
 * Encode trees into output data
 */

#define EXT extern
#include "encoder.h"

/*
 * Encode a tree
 */
static void WriteRepTree(
	t_encoder_context *context,
	byte    *pLen,
	byte    *pLastLen, 
	int		Num
)
{
	int			i;
	int			j;
	int			Same;
	ushort		SmallFreq[2*24];
	ushort		MiniCode[24];
	char		MiniLen[24];
	char		k;
	byte		temp_store;
    byte * z=context->enc_output_buffer_curpos;

	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	memset(SmallFreq, 0, sizeof(SmallFreq));

	temp_store	= pLen[Num];
	pLen[Num]	= 123; 

	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, compress this information */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		/* Special case if they're zeroes */
	 		if (!pLen[i])
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
	       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			SmallFreq[17]++;
	    		else
	       			SmallFreq[18]++;
	 		}
		 	else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
	       			Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

				SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	    		SmallFreq[19]++;
	 		}

	 		i += Same-1;
      }
      else
			SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	}

	make_tree(
		context,
		20, 
		SmallFreq, 
		(byte *) MiniLen, 
		MiniCode, 
		true
	);

	/* max 10 byte output overrun */
	for (i = 0; i < 20; i++)
	{
		output_bits(context, 4, MiniLen[i]);
	}

	/* Output original tree with new code */
	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, we can do something */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		if (!pLen[i]) /* Zeroes */
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
		       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			k = 17;
	    		else
		       		k = 18;
	 		}
	 		else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
			   		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

	    		k = 19;
	 		}
		}
		else
	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];

		output_bits(context, MiniLen[k], MiniCode[k]);

		if (k == 17)
		{
	 		output_bits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS, Same-TREE_ENC_REP_MIN);
	 		i += Same-1;
		}
		else if (k == 18)
		{
	 		output_bits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS, Same-(TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST));
	 		i += Same-1;
		}
		else if (k == 19)
		{
	 		output_bits(context, TREE_ENC_REP_SAME_EXTRA_BITS, Same-TREE_ENC_REP_MIN);

	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];
			output_bits(context, MiniLen[k], MiniCode[k]);

	 		i += Same-1;
		}
	}

	pLen[Num] = temp_store;

	memcpy(pLastLen, pLen, Num);
}


void create_trees(t_encoder_context *context, bool generate_codes)
{
	/*
	 * Assumption: We can trash PtrLen[NUM_CHARS+(NUM_POSITION_SLOTS*NUM_LENGTHS))], since
	 *             we allocated space for it earlier
	 */
	make_tree(
		context,
		NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)),
		context->enc_main_tree_freq, 
		context->enc_main_tree_len,  
		context->enc_main_tree_code,
		generate_codes
	);

	make_tree(
		context,
		NUM_SECONDARY_LENGTHS, 
		context->enc_secondary_tree_freq,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_code,
		generate_codes
	);

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);
}


void fix_tree_cost_estimates(t_encoder_context *context)
{
	/*
	 *  We're only creating trees for estimation purposes and we do not 
	 *  want to encode the tree.  However, the following loops will set
	 *  the frequency zero tree element lengths to values other than 
	 *  zero, so that the optimal encoder won't get confused when it
	 *  tries to estimate the number of bits it would take to output an
	 *  element.
     *
     *  We also set the bit lengths of match length 2's further away
     *  than MAX_LENGTH_TWO_OFFSET to a large number, so that the
     *  optimal parser will never select such matches.
	 */
	ulong  i;

	/* Set zero lengths to some value */
	for (i = 0; i< NUM_CHARS; i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 11;
	}

	for (; i < NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)); i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 12;
	}		

	for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
	{
		if (context->enc_secondary_tree_len[i] == 0)
			context->enc_secondary_tree_len[i] = 8; 
	}

    prevent_far_matches(context);
}


void prevent_far_matches(t_encoder_context *context)
{
    ulong i;

    /*
     * Set far match length 2's to a high value so they will never
     * be chosen.
     *
     * See description of MAX_GROWTH in encdefs.h
     */
    for (   i = MP_SLOT(MAX_LENGTH_TWO_OFFSET);
            i < context->enc_num_position_slots;
            i++
        )
	{
        context->enc_main_tree_len[NUM_CHARS + (i << NL_SHIFT)] = 100;
	}		
}


/*
 * Encode the trees
 *
 * Assumes trees have already been created with create_trees().
 *
 * Warning, do not call update_tree_cost_estimates() before encoding
 * the trees, since that routine trashes some of the tree elements.
 */
void encode_trees(t_encoder_context *context)
{
	WriteRepTree(
		context,
		context->enc_main_tree_len, 
		context->enc_main_tree_prev_len,
		NUM_CHARS
	);

	WriteRepTree(
		context,
		&context->enc_main_tree_len[NUM_CHARS], 
		&context->enc_main_tree_prev_len[NUM_CHARS], 
		context->enc_num_position_slots * (NUM_PRIMARY_LENGTHS+1)
	);

	WriteRepTree(
		context,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_prev_len,
		NUM_SECONDARY_LENGTHS
	);
}


void encode_aligned_tree(t_encoder_context *context)
{
	int i;

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);

	/* Output original tree with new code */
	for (i = 0; i < 8; i++)
	{
		output_bits(context, 3, context->enc_aligned_tree_len[i]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\encvars.h ===
/*
 * encvars.h
 *
 * Variables for the compressor
 */

#ifdef ALLOC_VARS
    #undef EXT
    #define EXT
#else
    #undef EXT
    #define EXT extern
#endif


/*
 * For the optimal parser
 *
 * Uses less memory if it's ushort, but then we're forcing the CPU
 * to do 16 bit operations.
 *
 * Change this to ulong if you don't mind a small memory hit.
 * Also, if you make LOOK too large, this number may cause the
 * cost estimation to overflow; e.g. 10000 uncompressed symbols
 * @ 8 bits each > 65535 bits.
 */
typedef ulong           numbits_t;


/*
 * For the optimal parser
 */
typedef struct
    {
    ulong                   link;
    ulong                   path;
    ulong                   repeated_offset[NUM_REPEATED_OFFSETS];
    numbits_t               numbits;
#ifdef TRACING
    ulong                   matchoff;
#endif
    } decision_node;


/*
 * 256 + 8 * max_position_slots
 */
#define MAX_MAIN_TREE_ELEMENTS (256 + (8 * 291))   // 32MB

typedef struct
    {
    /* "fake" window pointer, based on enc_RealMemWindow */
    byte                            *enc_MemWindow;

    ulong                           enc_window_size;

#ifdef MULTIPLE_SEARCH_TREES
    /* root node pointers for our search trees */
    ulong                           *enc_tree_root;
#else /* !MULTIPLE_SEARCH_TREES */
    ulong                            enc_single_tree_root;
#endif /* MULTIPLE_SEARCH_TREES */

    /* "fake" start of left nodes */
    ulong                           *enc_Left;

    /* "fake" start of right nodes */
    ulong                           *enc_Right;

    /* bitwise outputting */
    ulong               enc_bitbuf;
    signed char                     enc_bitcount;
    bool                enc_output_overflow;
    char                pad1[2];

    /* used to record literals and displacements */
    ulong               enc_literals;    /* current number of literals */
    ulong               enc_distances;   /* current number of displacements */
    ulong              *enc_DistData;               /* match displacement array */
    byte               *enc_LitData;     /* contains a character or a matchlength */

#ifdef EXTRALONGMATCHES
    ushort             *enc_ExtraLength;    /* parallel to enc_LitData */
#endif

    byte               *enc_ItemType;  /* bitmap for whether it's a character or matchlength */
    ulong                           enc_repeated_offset_at_literal_zero[NUM_REPEATED_OFFSETS];

    /*
     * the last three match offsets (displacements) encoded, the most recent
     * one being enc_last_matchpos_offset[0].
     */
    ulong                           enc_last_matchpos_offset[NUM_REPEATED_OFFSETS];

    /* used for optimal parsing */
    ulong               enc_matchpos_table[MAX_MATCH+1];

    /* current encoding position in data */
    ulong                           enc_BufPos;

    /* lookup table for converting a match position into a slot */
    ushort              enc_slot_table[1024];

    /* buffering the output data */
    byte                *enc_output_buffer_start;
    byte                *enc_output_buffer_curpos;
    byte                *enc_output_buffer_end;
    ulong                           enc_input_running_total;
    ulong                           enc_bufpos_last_output_block;

    /* number of distinct position slots */
    ulong               enc_num_position_slots;

    /* misc */
    ulong               enc_file_size_for_translation;

    /* number of block splits for this 32K of uncompressed data */
    byte                enc_num_block_splits;

    /* the number of 1 bits in any given integer */
    byte                            enc_ones[256];

    /* compression parameters */
    byte                            enc_first_block;
    bool                            enc_need_to_recalc_stats;
    bool                            enc_first_time_this_group;
    ulong                           enc_encoder_second_partition_size;
    ulong                           enc_earliest_window_data_remaining;
    ulong                           enc_bufpos_at_last_block;
    byte                            *enc_input_ptr;
    long                            enc_input_left;
    ulong                           enc_instr_pos;

    /* for tree.c */
    ushort                          *enc_tree_freq;
    ushort                          *enc_tree_sortptr;
    byte                            *enc_len;
    short                           enc_tree_heap[MAX_MAIN_TREE_ELEMENTS + 2];
    ushort                          enc_tree_leftright[2*(2*MAX_MAIN_TREE_ELEMENTS-1)];
    ushort                          enc_tree_len_cnt[17];
    int                                     enc_tree_n;
    short                           enc_tree_heapsize;
    char                            enc_depth;

    ulong                           enc_next_tree_create;
    ulong                           enc_last_literals;
    ulong                           enc_last_distances;
    decision_node           *enc_decision_node;

    /* trees */
    byte                            enc_main_tree_len[MAX_MAIN_TREE_ELEMENTS+1];
    byte                            enc_secondary_tree_len[NUM_SECONDARY_LENGTHS+1];

    ushort                          enc_main_tree_freq[MAX_MAIN_TREE_ELEMENTS*2];
    ushort                          enc_main_tree_code[MAX_MAIN_TREE_ELEMENTS];
    byte                            enc_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS+1];

    ushort                          enc_secondary_tree_freq[NUM_SECONDARY_LENGTHS*2];
    ushort                          enc_secondary_tree_code[NUM_SECONDARY_LENGTHS];
    byte                            enc_secondary_tree_prev_len[NUM_SECONDARY_LENGTHS+1];

    ushort                          enc_aligned_tree_freq[ALIGNED_NUM_ELEMENTS*2];
    ushort                          enc_aligned_tree_code[ALIGNED_NUM_ELEMENTS];
    byte                            enc_aligned_tree_len[ALIGNED_NUM_ELEMENTS];
    byte                            enc_aligned_tree_prev_len[ALIGNED_NUM_ELEMENTS];

    /* start of allocated window memory */
    byte                            *enc_RealMemWindow;

    /* start of allocated left nodes */
    ulong                           *enc_RealLeft;

    /* start of allocated right nodes */
    ulong                           *enc_RealRight;

    /* # cfdata frames this folder */
    ulong               enc_num_cfdata_frames;

    /* misc */
    void                *enc_fci_data;

    PFNALLOC                        enc_malloc;
    HANDLE                          enc_mallochandle;

    int (__stdcall *enc_output_callback_function)(
                                                 void *          pfol,
                                                 unsigned char * compressed_data,
                                                 long            compressed_size,
                                                 long            uncompressed_size
                                                 );


    } t_encoder_context;


/*
 * Declare arrays?
 */

#ifdef ALLOC_VARS

/*
 * (1 << extra_bits[n])-1
 */
const ulong enc_slot_mask[] =
{
0,      0,      0,      0,     1,       1,      3,      3,
7,      7,     15,     15,    31,      31,     63,     63,
127,    127,    255,    255,   511,     511,   1023,   1023,
2047,   2047,   4095,   4095,  8191,    8191,  16383,  16383,
32767,  32767,  65535,  65535, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071
};

const byte enc_extra_bits[] =
{
0,0,0,0,1,1,2,2,
3,3,4,4,5,5,6,6,
7,7,8,8,9,9,10,10,
11,11,12,12,13,13,14,14,
15,15,16,16,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17
};

#else

extern const ulong enc_slot_mask[];
extern const byte enc_extra_bits[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\init.c ===
/*
 * init.c
 *
 * Initialise encoder
 */
#include "encoder.h"


#define MEM_WINDOW_ALLOC_SIZE   \
        (context->enc_window_size+(MAX_MATCH+EXTRA_SIZE)+context->enc_encoder_second_partition_size)

/*
 * Initialise encoder
 */
void init_compression_memory(t_encoder_context *context)
{
    /* set all root pointers to NULL */
#ifdef MULTIPLE_SEARCH_TREES
    memset(
          context->enc_tree_root,
          0,
          NUM_SEARCH_TREES * sizeof(context->enc_tree_root[0])
          );
#else
    context->enc_single_tree_root = 0;
#endif

    context->enc_MemWindow  = context->enc_RealMemWindow - context->enc_window_size;
    context->enc_Left               = context->enc_RealLeft          - context->enc_window_size;
    context->enc_Right              = context->enc_RealRight         - context->enc_window_size;
    context->enc_BufPos             = context->enc_window_size;

    /*
     * Set initial state of repeated match offsets
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    /*
     * repeated offset states the last time we output a block
     * see block.c/encdata.c
     */
    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    /* this is the first compressed block in the file */
    context->enc_first_block = true;

    /* we don't have any cumulative stats yet */
    context->enc_need_to_recalc_stats = true;

    /* bufpos @ last time we output a block */
    context->enc_bufpos_last_output_block = context->enc_BufPos;

    /* initialise bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

    /*
     * The last lengths are zeroed in both the encoder and decoder,
     * since our tree representation is delta format.
     */
    memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

    /*
     * Set the default last tree lengths for cost estimation
     */
    memset(context->enc_main_tree_len, 8, NUM_CHARS);
    memset(&context->enc_main_tree_len[NUM_CHARS], 9, MAIN_TREE_ELEMENTS-NUM_CHARS);
    memset(context->enc_secondary_tree_len, 6, NUM_SECONDARY_LENGTHS);
    memset(context->enc_aligned_tree_len, 3, ALIGNED_NUM_ELEMENTS);
    prevent_far_matches(context); /* prevent far match 2's from being taken */

    context->enc_bufpos_at_last_block                       = context->enc_BufPos;
    context->enc_earliest_window_data_remaining     = context->enc_BufPos;
    context->enc_input_running_total                        = 0;
    context->enc_first_time_this_group                      = true;

    /* Clear the literal types array */
    memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

    /* No literals or distances encoded yet */
    context->enc_literals      = 0;
    context->enc_distances     = 0;

    /* No block splits yet */
    context->enc_num_block_splits = 0;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    /* reset instruction pointer (for translation) to zero */
    reset_translation(context);

    context->enc_num_cfdata_frames = 0;
}


/*
 * Allocate memory for the compressor
 *
 * Returns true if successful, false otherwise
 */
bool comp_alloc_compress_memory(t_encoder_context *context)
{
    ulong   pos_start;

#ifdef MULTIPLE_SEARCH_TREES
    context->enc_tree_root          = NULL;
#endif
    context->enc_RealLeft           = NULL;
    context->enc_RealRight          = NULL;
    context->enc_MemWindow          = NULL;
    context->enc_decision_node      = NULL;
    context->enc_LitData            = NULL;
#ifdef EXTRALONGMATCHES
    context->enc_ExtraLength        = NULL;
#endif
    context->enc_DistData           = NULL;
    context->enc_ItemType           = NULL;
    context->enc_output_buffer_start = NULL;

    /* ALSO NULLIFY BUFFERS! */

    /*
     * Determine the number of position slots in the main tree
     */
    context->enc_num_position_slots = 4;
    pos_start                               = 4;

    while (1)
        {
        pos_start += 1 << enc_extra_bits[context->enc_num_position_slots];

        context->enc_num_position_slots++;

        if (pos_start >= context->enc_window_size)
            break;
        }

#ifdef MULTIPLE_SEARCH_TREES
    context->enc_tree_root = (ulong *) context->enc_malloc(
                                                          context->enc_mallochandle,
                                                          sizeof(context->enc_tree_root[0]) * NUM_SEARCH_TREES
                                                          );

    if (context->enc_tree_root == NULL)
        {
        return false;
        }
#endif

    context->enc_RealLeft = (ulong *) context->enc_malloc(
                                                         context->enc_mallochandle,
                                                         sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
                                                         );

    if (context->enc_RealLeft == NULL)
        {
        return false;
        }

    context->enc_RealRight = (ulong *) context->enc_malloc(
                                                          context->enc_mallochandle,
                                                          sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
                                                          );

    if (context->enc_RealRight == NULL)
        {
        return false;
        }

    context->enc_RealMemWindow = (byte *) context->enc_malloc(
                                                             context->enc_mallochandle,
                                                             MEM_WINDOW_ALLOC_SIZE
                                                             );

    if (context->enc_RealMemWindow == NULL)
        {
        return false;
        }

    context->enc_MemWindow = context->enc_RealMemWindow;

    context->enc_LitData = (byte *) context->enc_malloc(
                                                       context->enc_mallochandle,
                                                       MAX_LITERAL_ITEMS * sizeof(*context->enc_LitData)
                                                       );

    if (context->enc_LitData == NULL)
        {
        return false;
        }

#ifdef EXTRALONGMATCHES

    context->enc_ExtraLength = (ushort *) context->enc_malloc(
                                                             context->enc_mallochandle,
                                                             MAX_LITERAL_ITEMS * sizeof(*context->enc_ExtraLength)
                                                             );

    if (context->enc_ExtraLength == NULL)
        {
        return false;
        }

#endif

    context->enc_DistData = (ulong *) context->enc_malloc(
                                                         context->enc_mallochandle,
                                                         MAX_DIST_ITEMS * sizeof(*context->enc_DistData)
                                                         );

    if (context->enc_DistData == NULL)
        {
        return false;
        }

    context->enc_ItemType = (byte *) context->enc_malloc(
                                                        context->enc_mallochandle,
                                                        MAX_LITERAL_ITEMS/8
                                                        );

    if (context->enc_ItemType == NULL)
        {
        return false;
        }

    create_slot_lookup_table(context);
    create_ones_table(context);

    if (init_compressed_output_buffer(context) == false)
        {
        return false;
        }

    context->enc_decision_node = context->enc_malloc(
                                                    context->enc_mallochandle,
                                                    sizeof(decision_node) * (LOOK+MAX_MATCH+16)
                                                    );

    if (context->enc_decision_node == NULL)
        {
        return false;
        }

    /* success */
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\io.c ===
/*
 * io.c
 */
#include "encoder.h"

/*
 * Similar to the optimisation we have for the decoder.
 *
 * Allow the encoder to "overrun" output buffer by up to X bytes
 * so that we don't have to check for the end of the buffer every
 * single time we call outbits() in encdata.c
 */

#define OUTPUT_EXTRA_BYTES 64


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes);


/*
 * Initialises output buffering
 */
bool init_compressed_output_buffer(t_encoder_context *context)
{
        if (!(context->enc_output_buffer_start = (byte *) context->enc_malloc(
                                                                             context->enc_mallochandle,
                                                                             OUTPUT_BUFFER_SIZE)
                                                                             ))
            {
            return false;
            }

        context->enc_output_buffer_curpos = context->enc_output_buffer_start;

        context->enc_output_buffer_end =
                context->enc_output_buffer_start+(OUTPUT_BUFFER_SIZE-OUTPUT_EXTRA_BYTES);

        return true;
}


void reset_translation(t_encoder_context *context)
{
        context->enc_instr_pos = 0;
}


static long read_input_data(t_encoder_context *context, byte *mem, long amount)
{
        if (amount <= context->enc_input_left)
        {
                memcpy(mem, context->enc_input_ptr, amount);
                context->enc_input_left -= amount;
                context->enc_input_ptr += amount;

                return amount;
        }
        else
        {
                long bytes_read;

                if (context->enc_input_left <= 0)
                        return 0;

                bytes_read = context->enc_input_left;

                memcpy(mem, context->enc_input_ptr, context->enc_input_left);
                context->enc_input_ptr += context->enc_input_left;
                context->enc_input_left = 0;

                return bytes_read;
        }
}


long comp_read_input(t_encoder_context *context, ulong BufPos, long Size)
{
        long    bytes_read;

        if (Size <= 0)
                return 0;

        bytes_read = read_input_data(
                context,
                &context->enc_RealMemWindow[BufPos],
                Size
        );

        if (bytes_read < 0)
        return 0;

        /*
         * If no translation being performed for this file
         */
    if (context->enc_file_size_for_translation == 0 ||
        context->enc_num_cfdata_frames >= E8_CFDATA_FRAME_THRESHOLD)
    {
        context->enc_num_cfdata_frames++;
                return bytes_read;
    }

        encoder_translate_e8(
                context,
                &context->enc_RealMemWindow[BufPos],
                bytes_read
        );

    context->enc_num_cfdata_frames++;

        return bytes_read;
}


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes)
{
        long    offset;
        long    absolute;
        ulong   end_instr_pos;
        byte    temp[6];
        byte    *mem_backup;

        if (bytes <= 6)
        {
                context->enc_instr_pos += bytes;
                return;
        }

        mem_backup = mem;

        /* backup these bytes */
        memcpy(temp, &mem[bytes-6], 6);

        /* overwrite them with 0xE8 */
        memset(&mem[bytes-6], 0xE8, 6);

        end_instr_pos = context->enc_instr_pos + bytes - 6;

        while (1)
        {
                while (*mem++ != 0xE8)
                        context->enc_instr_pos++;

                if (context->enc_instr_pos >= end_instr_pos)
                        break;

                offset = *(UNALIGNED long *) mem;

                absolute = context->enc_instr_pos + offset;

                if (absolute >= 0)
                {
                        if ((ulong) absolute < context->enc_file_size_for_translation+context->enc_instr_pos)
                        {
                                if ((ulong) absolute >= context->enc_file_size_for_translation)
                                        absolute = offset - context->enc_file_size_for_translation;

                                *(UNALIGNED ulong *) mem = (ulong) absolute;
                        }
                }

                mem += 4;
                context->enc_instr_pos += 5;
        }

        /* restore the bytes */
        memcpy(&mem_backup[bytes-6], temp, 6);

        context->enc_instr_pos = end_instr_pos + 6;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\optenc.c ===
/*
 * optenc.c
 *
 * Encoder for optimal parser
 *
 *
 * Future Improvements:
 *
 * When two estimations are equal, for example, "should I output a
 * character or a match?" there should be some way of deciding
 * which to take.  Right now we force it to output a match, but
 * for text files, outputting a character results in a small
 * savings.  Even when comparing two matches, we might want to
 * force it to take one type of match over another.
 */

#include "encoder.h"

#define copymem(src,dst,size) memcpy(dst,src,size)


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr);
static void block_end(t_encoder_context *context, long BufPos);


/*
 * encode a match of length <len> (where <len> >=2), and position <pos>
 */

#ifdef EXTRALONGMATCHES

#define OUT_MATCH(len,pos) \
{ \
   ULONG enclen = (len);                                                                        \
   ULONG extlen = 0;                                                                            \
   if ( enclen > MAX_MATCH ) {                                                                  \
        extlen = enclen - MAX_MATCH;                                                            \
        enclen = MAX_MATCH;                                                                     \
        }                                                                                       \
   context->enc_ItemType   [context->enc_literals >> 3] |= (1 << (context->enc_literals & 7));  \
   context->enc_LitData    [context->enc_literals     ]  = (byte)(enclen-MIN_MATCH);            \
   context->enc_ExtraLength[context->enc_literals++   ]  = (ushort)(extlen);                    \
   context->enc_DistData   [context->enc_distances++  ]  = (pos);                               \
}

#else

#define OUT_MATCH(len,pos) \
{ \
   context->enc_ItemType[(context->enc_literals >> 3)] |= (1 << (context->enc_literals & 7));   \
   context->enc_LitData [context->enc_literals++]  = (byte)(len-2);                             \
   context->enc_DistData[context->enc_distances++] = pos;                                       \
}

#endif

/* encode a character */
#define OUT_CHAR(ch) \
        context->enc_LitData [context->enc_literals++] = ch;


#define TREE_CREATE_CHECK()                                             \
if (context->enc_literals >= context->enc_next_tree_create)                     \
{                                                                                               \
        update_tree_estimates(context);\
        context->enc_next_tree_create += TREE_CREATE_INTERVAL;  \
}


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (context->enc_main_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 *
 * <ml> is the match length, where ml >= 2
 * <mp> is the match position
 *
 * The result is stored in <result>
 */
#define MATCH_EST(ml,mp,result) \
{ \
        ulong mp_slot;                                                                                                           \
        mp_slot = MP_SLOT(mp);                                                                           \
        if (ml < (NUM_PRIMARY_LENGTHS+2))                                                                       \
        {                                                                                                                                       \
                result = (numbits_t)                                                                                    \
                        (context->enc_main_tree_len[(NUM_CHARS-2)+(mp_slot<<NL_SHIFT)+ml] +     \
                        enc_extra_bits[mp_slot]);                                                                       \
        }                                                                                                                                       \
        else                                                                                                                            \
        {                                                                                                                                       \
                result = (numbits_t)                                                                                    \
                        (context->enc_main_tree_len[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mp_slot<<NL_SHIFT)] + \
                        context->enc_secondary_tree_len[ml-(NUM_PRIMARY_LENGTHS+2)] +   \
                        enc_extra_bits[mp_slot]);                                                                       \
        }                                                                                                                                       \
}


#ifdef _DEBUG
static void VERIFY_MATCH(
                        t_encoder_context   *context,
                        long                bufpos,
                        int                 largest_match_len
                        )
{
    int     i, j;
    ulong   match_pos;

    /*
     * Ensure match does not cross boundary
     */
    _ASSERTE(
            largest_match_len <=
            (CHUNK_SIZE-1) - (bufpos & (CHUNK_SIZE-1))
            );

    for (i = MIN_MATCH; i <= largest_match_len; i++)
        {
        match_pos = context->enc_matchpos_table[i];

        if (match_pos < NUM_REPEATED_OFFSETS)
            match_pos = context->enc_last_matchpos_offset[match_pos];
        else
            match_pos -= (NUM_REPEATED_OFFSETS-1);

        _ASSERTE (match_pos <= context->enc_window_size-4);

        for (j = 0; j < i; j++)
            {
            _ASSERTE (
                     context->enc_MemWindow[bufpos+j] ==
                     context->enc_MemWindow[bufpos-match_pos+j]
                     );
            }
        }
}
#else
    #define VERIFY_MATCH(a,b,c) ;
#endif


void flush_all_pending_blocks(t_encoder_context *context)
{
    /*
     * Force all blocks to be output
     */
    while (context->enc_literals > 0)
        output_block(context);

    /*
     * Flush compressed data out to the caller
     */
    perform_flush_output_callback(context);
}


void encoder_start(t_encoder_context *context)
{
    long BytesRead, RealBufPos;

    /*
     * RealBufPos is our position in the window,
     * and equals [0...window_size + second_partition_size - 1]
     */
    RealBufPos = context->enc_BufPos - (ulong)(context->enc_RealMemWindow - context->enc_MemWindow);

    BytesRead = comp_read_input(context, RealBufPos, CHUNK_SIZE);

    if (BytesRead > 0)
        opt_encode_top(context, BytesRead);
}


static void update_tree_estimates(t_encoder_context *context)
{
    if (context->enc_literals)
        {
        /*
         * Get stats on literals from 0...context->enc_literals
         */
        if (context->enc_need_to_recalc_stats)
            {
            /*
             * Cumulative total was destroyed, so need to
             * recalculate
             */
            get_block_stats(
                           context,
                           0,
                           0,
                           context->enc_literals
                           );

            context->enc_need_to_recalc_stats = false;
            }
        else
            {
            /*
             * Add stats from last_literals...context->enc_literals
             * to cumulative total
             */
            update_cumulative_block_stats(
                                         context,
                                         context->enc_last_literals,
                                         context->enc_last_distances,
                                         context->enc_literals
                                         );
            }

        create_trees(context, false); /* don't generate codes */

        fix_tree_cost_estimates(context);

        /*
         * For cumulative total
         */
        context->enc_last_literals = context->enc_literals;
        context->enc_last_distances = context->enc_distances;
        }
}


void opt_encode_top(t_encoder_context *context, long BytesRead)
{
    ulong   BufPos;
    ulong   RealBufPos;
    ulong   BufPosEnd;
    ulong   BufPosEndThisChunk;
    ulong   MatchPos;
    ulong   i;
    ulong   end_pos;
    long    EncMatchLength;  /* must be a signed number */
    long    ExMatchOff = -1; /* initialize to prevent compiler warning */

    /*
     * Current position in encoding window
     */
    BufPos          = context->enc_BufPos;

    /*
     * Stop encoding when we reach here
     */
    BufPosEnd       = context->enc_BufPos + BytesRead;

    /*
     * If this is our first time in here (since a new group), then
     * when we reach this many literals, update our tree cost
     * estimates.
     *
     * Also, output the file size we're using for translation
     * (0 means no translation at all, which will speed things up
     * for the decoder).
     */
    if (context->enc_first_time_this_group)
        {
        context->enc_first_time_this_group = false;

        /*
         * Recreate trees when we reach this many literals
         */
        context->enc_next_tree_create = 10000;

        if (context->enc_file_size_for_translation)
            {
            output_bits(context, 1, 1); /* translation */

            output_bits(context, 16, context->enc_file_size_for_translation >> 16);
            output_bits(context, 16, context->enc_file_size_for_translation & 65535);
            }
        else
            {
            output_bits(context, 1, 0); /* no translation */
            }
        }
    else
        {
        /*
         * If this is our second or later time in here, then add in the
         * strings we removed last time.
         *
 * We have to be careful here, though, because end_pos is
 * equal to our current BufPos - window_size, not
 * BufPos - i - window_size; we don't have that much history
 * around.
         */
        for (i = BREAK_LENGTH; i > 0; i--)
            quick_insert_bsearch_findmatch(
                                          context,
                                          BufPos - (long) i,
                                          BufPos - context->enc_window_size+4
                                          );
        }

    while (1)
        {

        top_of_main_loop:

        /*
         * While we haven't reached the end of the data
         */
        while (BufPos < BufPosEnd)
            {

            BufPosEndThisChunk = ( BufPos + CHUNK_SIZE ) & ~( CHUNK_SIZE - 1 );

            if ( BufPosEndThisChunk > BufPosEnd ) {
                 BufPosEndThisChunk = BufPosEnd;
                 }

            /*
             * Search for matches of all different possible lengths, at BufPos
             */
            EncMatchLength = binary_search_findmatch(context, BufPos);

            if (EncMatchLength < MIN_MATCH)
                {

                output_literal:

                /*
                 * No match longer than 1 character exists in the history
                 * window, so output the character at BufPos as a symbol.
                 */
                OUT_CHAR(context->enc_MemWindow[BufPos]);

#ifdef TRACING
                EncTracingLiteral( BufPos, context->enc_MemWindow[BufPos] );
#endif
                BufPos++;

                /*
                 * Check for exceeding literal buffer
                 */
                if (context->enc_literals >= (MAX_LITERAL_ITEMS-8))
                    block_end(context, BufPos);

                continue;
                }

            /*
             * Found a match.
             *
             * Make sure it cannot exceed the end of the buffer.
             */
            if ( EncMatchLength > (long)( BufPosEndThisChunk - BufPos ))
                {
                EncMatchLength = (long)( BufPosEndThisChunk - BufPos );

                /*
                 * Oops, not enough for even a small match, so we
                 * have to output a literal
                 */
                if (EncMatchLength < MIN_MATCH)
                    goto output_literal;
                }

            VERIFY_MATCH(context, BufPos, EncMatchLength);

            if (EncMatchLength < FAST_DECISION_THRESHOLD)
                {
                /*
                 *  A match has been found that is between MIN_MATCH and
                 *  FAST_DECISION_THRESHOLD bytes in length.  The following
                 *  algorithm is the optimal encoder that will determine the
                 *  most efficient order of matches and unmatched characters
                 *  over a span area defined by LOOK.
                 *
                 *  The code is essentially a shortest path determination
                 *  algorithm.  A stream of data can be encoded in a vast number
                 *  of different ways depending on the match lengths and offsets
                 *  chosen.  The key to good compression ratios is to chose the
                 *  least expensive path.
                 */
                ulong           span;
                ulong           epos, bpos, NextPrevPos, MatchPos;
                decision_node *decision_node_ptr;
                long            iterations;

                /*
                 * Points to the end of the area covered by this match; the span
                 * will continually be extended whenever we find more matches
                 * later on.  It will stop being extended when we reach a spot
                 * where there are no matches, which is when we decide which
                 * path to take to output the matches.
                 */
                span = BufPos + EncMatchLength;

                /*
                 * The furthest position into which we will do our lookahead parsing
                 */
                epos = BufPos + LOOK;

                /*
                 * Temporary BufPos variable
                 */
                bpos = BufPos;


                /*
                 * Calculate the path to the next character if we output
                 * an unmatched symbol.
                 */

                /* bits required to get here */
                context->enc_decision_node[1].numbits = CHAR_EST(context->enc_MemWindow[BufPos]);

                /* where we came from */
                context->enc_decision_node[1].path    = BufPos;


                /*
                 * For the match found, estimate the cost of encoding the match
                 * for each possible match length, shortest offset combination.
                 *
                 * The cost, path and offset is stored at BufPos + Length.
                 */
                for (i = MIN_MATCH; i <= (ulong)EncMatchLength; i++)
                    {
                    /*
                     * Get estimation of match cost given match length = i,
                     * match position = context->enc_matchpos_table[i], and store
                     * the result in context->enc_numbits[i]
                     */
                    MATCH_EST(i, context->enc_matchpos_table[i], context->enc_decision_node[i].numbits);

                    /*
                     * Where we came from
                     */
                    context->enc_decision_node[i].path = BufPos;

                    /*
                     * Associated match position with this path
                     */
                    context->enc_decision_node[i].link = context->enc_matchpos_table[i];

#ifdef TRACING
                        {
                        ULONG TrMatchPos = context->enc_matchpos_table[i];
                        ULONG TrMatchOff;

                        if ( TrMatchPos < NUM_REPEATED_OFFSETS ) {
                            TrMatchOff = context->enc_last_matchpos_offset[ TrMatchPos ];
                            }
                        else {
                            TrMatchOff = TrMatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                            }

                        context->enc_decision_node[i].matchoff = TrMatchOff;
                        }
#endif
                    }

                /*
                 * Set bit counter to zero at the start
                 */
                context->enc_decision_node[0].numbits = 0;

                /*
                 * Initialise relative match position tables
                 *
                 * Really context->enc_repeated_offset_table[BufPos-bpos][x], but here
                 * BufPos == bpos
                 */
                context->enc_decision_node[0].repeated_offset[0] = context->enc_last_matchpos_offset[0];
                context->enc_decision_node[0].repeated_offset[1] = context->enc_last_matchpos_offset[1];
                context->enc_decision_node[0].repeated_offset[2] = context->enc_last_matchpos_offset[2];

                decision_node_ptr = &context->enc_decision_node[-(long) bpos];

#define rpt_offset_ptr(where,which_offset) decision_node_ptr[(where)].repeated_offset[(which_offset)]

                while (1)
                    {
                    numbits_t est, cum_numbits;

                    BufPos++;


                    /*
                     *  Set the proper repeated offset locations depending on the
                     *  shortest path to the location prior to searching for a
                     *  match.
                     */


                    /*
                     * If this is a match (i.e. path skips over more
                     * than one character).
                     */
                    if (decision_node_ptr[BufPos].path != (ulong) (BufPos-1))
                        {
                        ulong LastPos = decision_node_ptr[BufPos].path;

                        /*
                         * link_ptr[BufPos] is the match position for this
                         * location
                         */
                        if (decision_node_ptr[BufPos].link >= NUM_REPEATED_OFFSETS)
                            {
                            context->enc_last_matchpos_offset[0] = decision_node_ptr[BufPos].link-(NUM_REPEATED_OFFSETS-1);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,1);
                            }
                        else if (decision_node_ptr[BufPos].link == 0)
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
                            }
                        else if (decision_node_ptr[BufPos].link == 1)
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
                            }
                        else /* == 2 */
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,2);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,0);
                            }
                        }

                    rpt_offset_ptr(BufPos,0) = context->enc_last_matchpos_offset[0];
                    rpt_offset_ptr(BufPos,1) = context->enc_last_matchpos_offset[1];
                    rpt_offset_ptr(BufPos,2) = context->enc_last_matchpos_offset[2];

                    /*
                     * The following is one of the two possible break points from
                     * the inner encoding loop.  This break will exit the loop if
                     * a point is reached that no match can incorporate; i.e. a
                     * character that does not match back to anything is a point
                     * where all possible paths will converge and the longest one
                     * can be chosen.
                     */
                    if (span == BufPos)
                        break;

                    /*
                     * Search for matches at BufPos
                     */
                    EncMatchLength = binary_search_findmatch(context, BufPos);

                    /*
                     * Make sure that the match does not exceed the stop point
                     */
                    if ((ulong) EncMatchLength + BufPos > BufPosEndThisChunk)
                        {
                        EncMatchLength = BufPosEndThisChunk - BufPos;

                        if (EncMatchLength < MIN_MATCH)
                            EncMatchLength = 0;
                        }

                    VERIFY_MATCH(context, BufPos, EncMatchLength);

                    /*
                     * If the match is very long or it exceeds epos (either
                     * surpassing the LOOK area, or exceeding past the end of the
                     * input buffer), then break the loop and output the path.
                     */
                    if (EncMatchLength > FAST_DECISION_THRESHOLD ||
                        BufPos + (ulong) EncMatchLength >= epos)
                        {
                        MatchPos = context->enc_matchpos_table[EncMatchLength];

#ifdef EXTRALONGMATCHES
                        if ( EncMatchLength == MAX_MATCH ) {
                            if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                                ExMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                                }
                            else {
                                ExMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                }
                            }
#endif

#ifdef TRACING
                            {
                            ULONG TrMatchOff;

                            if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                                TrMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                                }
                            else {
                                TrMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                }

                            decision_node_ptr[BufPos+EncMatchLength].matchoff = TrMatchOff;
                            }
#endif

                        decision_node_ptr[BufPos+EncMatchLength].link = MatchPos;
                        decision_node_ptr[BufPos+EncMatchLength].path = BufPos;

                        /*
                         * Quickly insert data into the search tree without
                         * returning match positions/lengths
                         */
#ifndef INSERT_NEAR_LONG_MATCHES
                        if (MatchPos == 3 && EncMatchLength > 16)
                            {
                            /*
                             * If we found a match 1 character away and it's
                             * length 16 or more, it's probably a string of
                             * zeroes, so don't insert that into the search
                             * engine, since doing so can slow things down
                             * significantly!
                             */
                            quick_insert_bsearch_findmatch(
                                                          context,
                                                          BufPos + 1,
                                                          BufPos - context->enc_window_size + (1 + 4) /* bp+1 -(ws-4) */
                                                          );
                            }
                        else
#endif
                            {
                            for (i = 1; i < (ulong) EncMatchLength; i++)
                                quick_insert_bsearch_findmatch(
                                                              context,
                                                              BufPos + i,
                                                              BufPos + i - context->enc_window_size + 4
                                                              );
                            }

                        BufPos += EncMatchLength;

                        /*
                         * Update the relative match positions
                         */
                        if (MatchPos >= NUM_REPEATED_OFFSETS)
                            {
                            context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
                            context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
                            context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
                            }
                        else if (MatchPos)
                            {
                            ulong t = context->enc_last_matchpos_offset[0];
                            context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
                            context->enc_last_matchpos_offset[MatchPos] = t;
                            }

                        break;
                        }


                    /*
                     * The following code will extend the area spanned by the
                     * set of matches if the current match surpasses the end of
                     * the span.  A match of length two that is far is not
                     * accepted, since it would normally be encoded as characters,
                     * thus allowing the paths to converge.
                     */
                    if (EncMatchLength > 2 ||
                        (EncMatchLength == 2 && context->enc_matchpos_table[2] < BREAK_MAX_LENGTH_TWO_OFFSET))
                        {
                        if (span < (ulong) (BufPos + EncMatchLength))
                            {
                            long end;
                            long i;

                            end = min(BufPos+EncMatchLength-bpos, LOOK-1);

                            /*
                             * These new positions are undefined for now, since we haven't
                             * gone there yet, so put in the costliest value
                             */
                            for (i = span-bpos+1; i <= end; i++)
                                context->enc_decision_node[i].numbits = (numbits_t) -1;

                            span = BufPos + EncMatchLength;
                            }
                        }


                    /*
                     *  The following code will iterate through all combinations
                     *  of match lengths for the current match.  It will estimate
                     *  the cost of the path from the beginning of LOOK to
                     *  BufPos and to every locations spanned by the current
                     *  match.  If the path through BufPos with the found matches
                     *  is estimated to take fewer number of bits to encode than
                     *  the previously found match, then the path to the location
                     *  is altered.
                     *
                     *  The code relies on accurate estimation of the cost of
                     *  encoding a character or a match.  Furthermore, it requires
                     *  a search engine that will store the smallest match offset
                     *  of each possible match length.
                     *
                     *  A match of length one is simply treated as an unmatched
                     *  character.
                     */

                    /*
                     *  Get the estimated number of bits required to encode the
                     *  path leading up to BufPos.
                     */
                    cum_numbits = decision_node_ptr[BufPos].numbits;


                    /*
                     *  Calculate the estimated cost of outputting the path through
                     *  BufPos and outputting the next character as an unmatched byte
                     */
                    est = cum_numbits + CHAR_EST(context->enc_MemWindow[BufPos]);


                    /*
                     *  Check if it is more efficient to encode the next character
                     *  as an unmatched character rather than the previously found
                     *  match.  If so, then update the cheapest path to BufPos + 1.
                     *
                     *  What happens if est == numbits[BufPos-bpos+1]; i.e. it
                     *  works out as well to output a character as to output a
                     *  match?  It's a tough call; however, we will push the
                     *  encoder to use matches where possible.
                     */
                    if (est < decision_node_ptr[BufPos+1].numbits)
                        {
                        decision_node_ptr[BufPos+1].numbits = est;
                        decision_node_ptr[BufPos+1].path    = BufPos;
                        }


                    /*
                     *      Now, iterate through the remaining match lengths and
                     *  compare the new path to the existing.  Change the path
                     *  if it is found to be more cost effective to go through
                     *  BufPos.
                     */
                    for (i = MIN_MATCH; i <= (ulong) EncMatchLength; i++)
                        {
                        MATCH_EST(i, context->enc_matchpos_table[i], est);
                        est += cum_numbits;

                        /*
                         * If est == numbits[BufPos+i] we want to leave things
                         * alone, since this will tend to force the matches
                         * to be smaller in size, which is beneficial for most
                         * data.
                         */
                        if (est < decision_node_ptr[BufPos+i].numbits)
                            {
                            decision_node_ptr[BufPos+i].numbits     = est;
                            decision_node_ptr[BufPos+i].path        = BufPos;
                            decision_node_ptr[BufPos+i].link        = context->enc_matchpos_table[i];

#ifdef TRACING
                                {
                                ULONG TrMatchPos = context->enc_matchpos_table[i];
                                ULONG TrMatchOff;

                                if ( TrMatchPos < NUM_REPEATED_OFFSETS ) {
                                    TrMatchOff = context->enc_last_matchpos_offset[ TrMatchPos ];
                                    }
                                else {
                                    TrMatchOff = TrMatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                    }

                                decision_node_ptr[BufPos+i].matchoff = TrMatchOff;
                                }
#endif
                            }
                        }
                    } /* continue to loop through span of matches */


                /*
                 *  Here BufPos == span, ie. a non-matchable character found.  The
                 *  following code will output the path properly.
                 */


                /*
                 *  Unfortunately the path is stored in reverse; how to get from
                 *  where we are now, to get back to where it all started.
                 *
                 *  Traverse the path back to the original starting position
                 *  of the LOOK span.  Invert the path pointers in order to be
                 *  able to traverse back to the current position from the start.
                 */

                /*
                 * Count the number of iterations we did, so when we go forwards
                 * we'll do the same amount
                 */
                iterations = 0;

                NextPrevPos = decision_node_ptr[BufPos].path;

                do
                    {
                    ulong   PrevPos;

                    PrevPos = NextPrevPos;

                    NextPrevPos = decision_node_ptr[PrevPos].path;
                    decision_node_ptr[PrevPos].path = BufPos;

                    BufPos = PrevPos;

                    iterations++;
                    } while (BufPos != bpos);


                if (context->enc_literals + iterations >= (MAX_LITERAL_ITEMS-8) ||
                    context->enc_distances + iterations >= (MAX_DIST_ITEMS-8))
                    {
                    block_end(context, BufPos);
                    }

                /*
                 * Traverse from the beginning of the LOOK span to the end of
                 * the span along the stored path, outputting matches and
                 * characters appropriately.
                 */
                do
                    {
                    if (decision_node_ptr[BufPos].path > BufPos+1)
                        {
                        /*
                         * Path skips over more than 1 character; therefore it's a match
                         */

#ifdef EXTRALONGMATCHES

                        //
                        //  If the match length to output here is MAX_MATCH,
                        //  this must be the last entry in the decision chain,
                        //  and we can extend the match as far as it will go.
                        //

                        long ExMatchPos    = decision_node_ptr[ decision_node_ptr[BufPos].path ].link;
                        long ExMatchLength = decision_node_ptr[BufPos].path - BufPos;

                        if ( ExMatchLength == MAX_MATCH ) {

                            ulong ExBufPtr = BufPos + MAX_MATCH;

#ifdef TRACING
                            ASSERT( ExMatchOff == (long)decision_node_ptr[ decision_node_ptr[BufPos].path ].matchoff );
#endif /* TRACING */

                            while (( ExBufPtr < BufPosEndThisChunk ) &&
                                   ( context->enc_MemWindow[ ExBufPtr ] == context->enc_MemWindow[ ExBufPtr - ExMatchOff ] )) {

                                ++ExBufPtr;
                                ++ExMatchLength;
                                }
                            }

                        OUT_MATCH( ExMatchLength, ExMatchPos );

#ifdef TRACING

                        EncTracingMatch(
                            BufPos,
                            ExMatchLength,
                            ExMatchPos,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].matchoff
                            );
#endif // TRACING

                        BufPos += ExMatchLength;

#else  /* ! EXTRALONGMATCHES */

                        OUT_MATCH(
                                 decision_node_ptr[BufPos].path - BufPos,
                                 decision_node_ptr[ decision_node_ptr[BufPos].path ].link
                                 );

#ifdef TRACING

                        EncTracingMatch(
                            BufPos,
                            decision_node_ptr[BufPos].path - BufPos,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].link,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].matchpos
                            );
#endif // TRACING

                        BufPos = decision_node_ptr[BufPos].path;

#endif /* ! EXTRALONGMATCHES */

                        }
                    else
                        {
                        /*
                         * Path goes to the next character; therefore it's a symbol
                         */
                        OUT_CHAR(context->enc_MemWindow[BufPos]);

#ifdef TRACING
                        EncTracingLiteral( BufPos, context->enc_MemWindow[BufPos] );
#endif

                        BufPos++;
                        }
                    } while (--iterations != 0);

                TREE_CREATE_CHECK();

                /*
                 * If we're filling up, and are close to outputting a block,
                 * and it's the first block, then recompress the first N
                 * literals using our accumulated stats.
                 */
                if (context->enc_first_block &&
                    (context->enc_literals >= (MAX_LITERAL_ITEMS-512)
                     || context->enc_distances >= (MAX_DIST_ITEMS-512)))
                    {
                    if (redo_first_block(context, &BufPos))
                        goto top_of_main_loop;

                    /*
                     * Unable to redo, so output the block
                     */
                    block_end(context, BufPos);
                    }
                }
            else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
                {
                /*
                 *  This code reflects a speed optimization that will always take
                 *  a match of length >= FAST_DECISION_THRESHOLD characters.
                 */

                /*
                 * The position associated with the match we found
                 */

                MatchPos = context->enc_matchpos_table[EncMatchLength];

#ifdef EXTRALONGMATCHES

                if ( EncMatchLength == MAX_MATCH ) {

                    //
                    //  Extend the match length up to end of input buffer
                    //  or the current position in the history buffer.
                    //

                    ulong BufPtr = BufPos + MAX_MATCH;
                    long MatchOff;

                    if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                        MatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                        }
                    else {
                        MatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                        }

                    while (( BufPtr < BufPosEndThisChunk ) &&
                           ( context->enc_MemWindow[ BufPtr ] == context->enc_MemWindow[ BufPtr - MatchOff ] )) {

                        ++BufPtr;
                        ++EncMatchLength;
                        }
                    }

#endif

                /*
                 * Quickly insert match substrings into search tree
                 * (don't look for new matches; just insert the strings)
                 */
#ifndef INSERT_NEAR_LONG_MATCHES
                if (MatchPos == 3 && EncMatchLength > 16)
                    {
                    quick_insert_bsearch_findmatch(
                                                  context,
                                                  BufPos + 1,
                                                  BufPos - context->enc_window_size + 5 /* bp+1 -(ws-4) */
                                                  );
                    }
                else
#endif
                    {
                    for (i = 1; i < (ulong) EncMatchLength; i++)
                        quick_insert_bsearch_findmatch(
                                                      context,
                                                      BufPos + i,
                                                      BufPos + i - context->enc_window_size + 4
                                                      );
                    }

                /*
                 * Output the match
                 */
                OUT_MATCH(EncMatchLength, MatchPos);

#ifdef TRACING

                {
                ULONG TrMatchOff;

                if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                    TrMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                    }
                else {
                    TrMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                    }

                EncTracingMatch(
                    BufPos,
                    EncMatchLength,
                    MatchPos,
                    TrMatchOff
                    );
                }

#endif // TRACING


                /*
                 * Advance our position in the window
                 */
                BufPos += EncMatchLength;

                if (MatchPos >= NUM_REPEATED_OFFSETS)
                    {
                    context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
                    context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
                    context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
                    }
                else if (MatchPos)
                    {
                    ulong t = context->enc_last_matchpos_offset[0];
                    context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
                    context->enc_last_matchpos_offset[MatchPos] = t;
                    }

                /*
                 * Check to see if we're close to overflowing our output arrays, and
                 * output a block if this is the case
                 */
                if (context->enc_literals >= (MAX_LITERAL_ITEMS-8) ||
                    context->enc_distances >= (MAX_DIST_ITEMS-8))
                    block_end(context, BufPos);

                }  /* EncMatchLength >= FAST_DECISION_THRESHOLD */

            } /* end while ... BufPos < BufPosEnd */

        /*
 * Value of BufPos corresponding to earliest window data
         */
        context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

        /*
         * We didn't read 32K, so we know for sure that
         * this was our last block of data.
         */
        if (BytesRead < CHUNK_SIZE)
            {
            /*
             * If we have never output a block, and we haven't
             * recalculated the stats already, then recalculate
             * the stats and recompress.
             */
            if (context->enc_first_block)
                {
                if (redo_first_block(context, &BufPos))
                    goto top_of_main_loop;
                }

            break;
            }

        /*
         * Remove the last BREAK_LENGTH nodes from the binary search tree,
         * since we have been inserting strings which contain undefined
         * data at the end.
         */
        end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

        for (i = 1; (i <= BREAK_LENGTH); i++)
            binary_search_remove_node(context, BufPos-i, end_pos);

        /*
         * If we're still in the first window_size + second partition size
         * bytes in the file then we don't need to copymem() yet.
         *
         * RealBufPos is the real position in the file.
         */
        RealBufPos = BufPos - (ulong)(context->enc_RealMemWindow - context->enc_MemWindow);

        if (RealBufPos < context->enc_window_size + context->enc_encoder_second_partition_size)
            break;

        /*
         * We're about to trash a whole bunch of history with our copymem,
         * so we'd better redo the first block now if we are ever going to.
         */
        if (context->enc_first_block)
            {
            if (redo_first_block(context, &BufPos))
                goto top_of_main_loop;
            }

        /*
         *  We're about to remove a large number of symbols from the window.
         *  Test to see whether, if we were to output a block now, our compressed
         *  output size would be larger than our uncompressed data.  If so, then
         *  we will output an uncompressed block.
         *
         *  The reason we have to do this check here, is that data in the
         *  window is about to be destroyed.  We can't simply put this check in
         *  the block outputting code, since there is no guarantee that the
         *  memory window contents corresponding to everything in that block,
         *  are still around - all we'd have would be a set of literals and
         *  distances, when we need all the uncompressed literals to output
         *  an uncompressed block.
         */

        /*
         *  What value of bufpos corresponds to the oldest data we have in the
         *  buffer?
         *
         *  After the memory copy, that will be the current buffer position,
         *  minus window_size.
         */

        /*
         * The end of the data buffer is reached, more data needs to be read
         * and the existing data must be shifted into the history window.
         *
         * MSVC 4.x generates code which does REP MOVSD so no need to
         * write this in assembly.
         */
        copymem(
               &context->enc_RealMemWindow[context->enc_encoder_second_partition_size],
               &context->enc_RealMemWindow[0],
               context->enc_window_size
               );

        copymem(
               &context->enc_RealLeft[context->enc_encoder_second_partition_size],
               &context->enc_RealLeft[0],
               sizeof(ulong)*context->enc_window_size
               );

        copymem(
               &context->enc_RealRight[context->enc_encoder_second_partition_size],
               &context->enc_RealRight[0],
               sizeof(ulong)*context->enc_window_size
               );

        context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

        /*
         *   The following bit of code is CRUCIAL yet unorthodox in function
         *   and serves as a speed and syntax optimization and makes the code
         *   easier to understand once grasped.
         *
         *   The three main buffers, context->enc_MemWindow, context->enc_Left and context->enc_Right,
         *   are referensed by BufPos and SearchPos relative to the current
         *   compression window locations.  When the encoder reaches the end
         *   of its block of input memory, the data in the input buffer is
         *   shifted into the compression history window and the new input
         *   stream is loaded.  Typically the BufPos pointer would be reduced
         *   to signify the replaced data.  However, this code reduces the
         *   base pointers to reflect the shift of data, and leaves the BufPos
         *   pointer in its current state.  Therefore, the BufPos pointer is
         *   an absolute pointer reflecting the position in the input stream,
         *   and NOT the position in the buffer.  The base pointers will point
         *   to invalid memory locations with addresses smaller than the
         *   actual array base pointers.  However, when the two pointers are
         *   added together, &(context->enc_MemWindow+BufPos), it will point to the
         *   correct and valid position in the buffer.
         */

        context->enc_MemWindow -= context->enc_encoder_second_partition_size;
        context->enc_Left      -= context->enc_encoder_second_partition_size;
        context->enc_Right     -= context->enc_encoder_second_partition_size;

        break;
        }

    /*
     * Store BufPos in global variable
     */
    context->enc_BufPos = BufPos;
}


static void block_end(t_encoder_context *context, long BufPos)
{
    context->enc_first_block                        = false;
    context->enc_need_to_recalc_stats       = true;

    output_block(context);

    if (context->enc_literals < TREE_CREATE_INTERVAL)
        {
        context->enc_next_tree_create = TREE_CREATE_INTERVAL;
        }
    else
        {
        context->enc_next_tree_create = context->enc_literals + TREE_CREATE_INTERVAL; /* recreate right away */
        }

    context->enc_bufpos_last_output_block = BufPos;
}


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr)
{
    long    start_at;
    long    earliest_can_start_at;
    long    pos_in_file;
    long    history_needed;
    long    history_avail;
    long    BufPos;
    long    split_at_literal;

    context->enc_first_block = false;

    BufPos = *bufpos_ptr;

    /*
     * For the first context->enc_window size bytes in the file, we don't
     * need to have context->enc_window size bytes around.
     *
     * For anything after that, though, we do need to have window_size
     * previous bytes to look into.
     */

    /*
     * How many bytes are we into the file?
     */
    pos_in_file = BufPos - context->enc_window_size;

    /*
     * First let's figure out the total history required from
     * BufPos backwards.  For starters, we need all the bytes
     * we're going to recompress.  We get that by seeing the
     * last time we output a block.
     */
    history_needed = BufPos - context->enc_bufpos_last_output_block;

    /*
     * Plus we will need window_size bytes before that (for matching
     * into) unless we're looking within the first window_size
     * bytes of the file.
     */
    if (context->enc_bufpos_last_output_block-context->enc_window_size < context->enc_window_size)
        history_needed += context->enc_bufpos_last_output_block - context->enc_window_size;
    else
        history_needed += context->enc_window_size;

    history_avail = (ulong)(&context->enc_MemWindow[BufPos] - &context->enc_RealMemWindow[0]);

    if (history_needed <= history_avail)
        {
        earliest_can_start_at = context->enc_bufpos_last_output_block;
        }
    else
        {
        /*
         * Not enough history available
         */
        return false;
        }

    start_at = earliest_can_start_at;

    split_block(
               context,
               0,
               context->enc_literals,
               context->enc_distances,
               &split_at_literal,
               NULL /* don't need # distances returned */
               );

    get_block_stats(
                   context,
                   0,
                   0,
                   split_at_literal
                   );

    create_trees(context, false); /* don't generate codes */
    fix_tree_cost_estimates(context);

#ifdef MULTIPLE_SEARCH_TREES
    /*
     * Now set all the tree root pointers to NULL
     * (don't need to reset the left/right pointers).
     */
    memset(context->enc_tree_root, 0, NUM_SEARCH_TREES * sizeof(ulong));
#else
    context->enc_single_tree_root = 0;
#endif

    /*
     * Clear item array and reset literal and distance
     * counters
     */
    memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

    /*
     * Reset encoder state
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    context->enc_input_running_total = 0;

    context->enc_literals      = 0;
    context->enc_distances     = 0;

    context->enc_need_to_recalc_stats = true;

    context->enc_next_tree_create = split_at_literal;

    *bufpos_ptr = start_at;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\encoder\tree.c ===
/*
 * tree.c
 *
 * Tree building routines.
 *
 * These routines are originally from the Public Domain source "AR001".
 *
 * However, they have been modified for use in LZX.
 */

#include "encoder.h"


/* Function prototypes */
static void downheap(t_encoder_context *context, short i);
static void make_tree2(t_encoder_context *context, short avail, ushort freqparm[], ushort codeparm[]);
static void make_len(t_encoder_context *context, short root);
static void make_code(t_encoder_context *context, int n, char len[], ushort code[]);


static void count_len(t_encoder_context *context, short i)  /* call with i = root */
{
	if (i < context->enc_tree_n)
		context->enc_tree_len_cnt[(context->enc_depth < 16) ? context->enc_depth : 16]++; /* NOTE: 16 is max len allowed */
	else
	{
		context->enc_depth++;
		count_len(context, context->enc_tree_leftright[i*2]);
		count_len(context, context->enc_tree_leftright[i*2+1]);
		context->enc_depth--;
	}
}


static void make_len(t_encoder_context *context, short root)
{
	signed short	k;
	ushort			cum;
	byte			i;

	for (i = 0; i <= 16; i++)
		context->enc_tree_len_cnt[i] = 0;

	count_len(context, root);

	cum = 0;

	for (i = 16; i > 0; i--)
		cum += (ushort) (context->enc_tree_len_cnt[i] << (16 - i));

	/* cum should equal 1<<16, which is 0 since cum is a ushort */
	while (cum)
	{
		context->enc_tree_len_cnt[16]--;

		for (i = 15; i > 0; i--)
		{
			if (context->enc_tree_len_cnt[i])
			{
				context->enc_tree_len_cnt[i]--;
				context->enc_tree_len_cnt[i+1] += 2;
				break;
			}
		}

		cum--;
	}

	for (i = 16; i > 0; i--)
	{
		k = context->enc_tree_len_cnt[i];

		while (--k >= 0)
			context->enc_len[*context->enc_tree_sortptr++] = (byte) i;
	}
}


static void __inline downheap(t_encoder_context *context, short i)
	/* priority queue; send i-th entry down heap */
{
	short  j, k;

	k = context->enc_tree_heap[i];

	while ((j = (i<<1)) <= context->enc_tree_heapsize)
	{
		if (j < context->enc_tree_heapsize && 
			context->enc_tree_freq[context->enc_tree_heap[j]] > context->enc_tree_freq[context->enc_tree_heap[j + 1]])
		 	j++;

		if (context->enc_tree_freq[k] <= context->enc_tree_freq[context->enc_tree_heap[j]])
			break;

		context->enc_tree_heap[i] = context->enc_tree_heap[j];
		i = j;
	}

	context->enc_tree_heap[i] = k;
}


static void make_code(t_encoder_context *context, int n, char len[], ushort code[])
{
    int    i;
	ushort start[18];

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = (start[i] + context->enc_tree_len_cnt[i]) << 1;

	for (i = 0; i < n; i++)
	{
		code[i] = start[len[i]]++;
	}
}


void make_tree(
	t_encoder_context *context,
	int		nparm, 
	ushort	*freqparm, 
	byte	*lenparm, 
	ushort	*codeparm,
	bool	make_codes	/* for estimations, we only want the lengths */
)
{
	short i, avail;

REDO_TREE:
	context->enc_tree_n			= nparm;
	context->enc_tree_freq		= freqparm;
	context->enc_len				= lenparm;
	avail				= (short)context->enc_tree_n;
    context->enc_depth          = 0;
	context->enc_tree_heapsize	= 0;
	context->enc_tree_heap[1]	= 0;

	for (i = 0; i < nparm; i++)
	{
		context->enc_len[i] = 0;

		if (freqparm[i])
         context->enc_tree_heap[++context->enc_tree_heapsize] = i;
	}

	if (context->enc_tree_heapsize < 2)
	{
		if (!context->enc_tree_heapsize)
		{
			codeparm[context->enc_tree_heap[1]] = 0;
			return;
		}

		if (!context->enc_tree_heap[1])
			freqparm[1] = 1;
		else
			freqparm[0] = 1;

		goto REDO_TREE;
	}

	make_tree2(context, avail, freqparm, codeparm);

	if (make_codes)
		make_code(context, nparm, lenparm, codeparm);
}


static void make_tree2(
	t_encoder_context *context,
	short avail, 
	ushort freqparm[], 
	ushort codeparm[]
)
{
	short i, j, k;

	for (i = context->enc_tree_heapsize >> 1; i >= 1; i--)
		downheap(context, i);  /* make priority queue */

	context->enc_tree_sortptr = codeparm;

	do
	{	/* while queue has at least two entries */
		i = context->enc_tree_heap[1];  /* take out least-freq entry */

		if (i < context->enc_tree_n)
			*context->enc_tree_sortptr++ = i;

		context->enc_tree_heap[1] = context->enc_tree_heap[context->enc_tree_heapsize--];
		downheap(context, 1);

		j = context->enc_tree_heap[1];  /* next least-freq entry */

		if (j < context->enc_tree_n)
			*context->enc_tree_sortptr++ = j;

		k = avail++;  /* generate new node */

		freqparm[k] = freqparm[i] + freqparm[j];
		context->enc_tree_heap[1] = k;
		downheap(context, 1);  /* put into queue */

		context->enc_tree_leftright[k*2] = i;
		context->enc_tree_leftright[k*2+1] = j;

	} while (context->enc_tree_heapsize > 1);

	context->enc_tree_sortptr = codeparm;
	make_len(context, k);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\bin86\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=


SOURCES_USED=..\sources.inc

!if "$(ALT_PROJECT)" == "JPN" || "$(ALT_PROJECT)" == "CHT" || "$(ALT_PROJECT)" == "CHS" \
    || "$(ALT_PROJECT)" == "KOR" || "$(ALT_PROJECT)" == "CHP" 
BINPLACE_FLAGS = $(BINPLACE_FLAGS)
!endif

MISCFILES = \
    ..\autoexec.nt \
!if "$(ALT_PROJECT)" != "JPN" && "$(ALT_PROJECT)" != "KOR"
    ..\config.nt   \
    ..\ver.dll     \
!endif
    ..\ctl3dv2.dll \
    ..\ctl3dv2.map \
    ..\ctl3dv2.sym \
!if "$(ALT_PROJECT)" != "JPN" && "$(ALT_PROJECT)" != "CHT" && "$(ALT_PROJECT)" != "CHS" && "$(ALT_PROJECT)" != "CHP" 
    ..\netapi.dll	\
!endif
!if "$(ALT_PROJECT)" != "JPN"
    ..\lanman.drv 	\
    ..\lzexpand.dll \
    ..\pmspl.dll	\
!endif
    ..\$(TARGET_DIRECTORY)\win87em.dll \
!if "$(ALT_PROJECT)" != "JPN" && "$(ALT_PROJECT)" != "CHT" && "$(ALT_PROJECT)" != "CHS" && "$(ALT_PROJECT)" != "KOR" && "$(ALT_PROJECT)" != "CHP" 
    ..\sysedit.exe \
    ..\system.ini \
    ..\olecli.dll \
    ..\winhelp.exe \
    ..\write16.exe \
    ..\write16.map \
    ..\write16.sym \
!else
    ..\$(ALT_PROJECT_TARGET)\sysedit.exe \
    ..\$(ALT_PROJECT_TARGET)\system.ini \
    ..\$(ALT_PROJECT_TARGET)\winhelp.exe \
    ..\$(ALT_PROJECT_TARGET)\write16.exe \
    ..\$(ALT_PROJECT_TARGET)\write16.map \
    ..\$(ALT_PROJECT_TARGET)\write16.sym \
!endif
!if "$(ALT_PROJECT)" == "JPN" 
    ..\$(ALT_PROJECT_TARGET)\_disp.sys \
    ..\$(ALT_PROJECT_TARGET)\_ias.sys \
    ..\$(ALT_PROJECT_TARGET)\_prnescp.sys \
    ..\$(ALT_PROJECT_TARGET)\adddrv.exe \
    ..\$(ALT_PROJECT_TARGET)\appsicon.dll \
    ..\$(ALT_PROJECT_TARGET)\config.nt \
    ..\$(ALT_PROJECT_TARGET)\config.us \
    ..\$(ALT_PROJECT_TARGET)\config.wow \
    ..\$(ALT_PROJECT_TARGET)\deldrv.exe \
    ..\$(ALT_PROJECT_TARGET)\gaijiedt.exe \
    ..\$(ALT_PROJECT_TARGET)\jp.bat \
    ..\$(ALT_PROJECT_TARGET)\kkcfunc.sys \
    ..\$(ALT_PROJECT_TARGET)\lanman.drv \
    ..\$(ALT_PROJECT_TARGET)\lzexpand.dll \
    ..\$(ALT_PROJECT_TARGET)\msime.dic \
    ..\$(ALT_PROJECT_TARGET)\msime.sys \
    ..\$(ALT_PROJECT_TARGET)\msimed.sys \
    ..\$(ALT_PROJECT_TARGET)\msimei.sys \
    ..\$(ALT_PROJECT_TARGET)\msimek.sys \
    ..\$(ALT_PROJECT_TARGET)\msimekey.exe \
    ..\$(ALT_PROJECT_TARGET)\msimelst.exe \
    ..\$(ALT_PROJECT_TARGET)\msimer.dic \
    ..\$(ALT_PROJECT_TARGET)\msimergn.exe \
    ..\$(ALT_PROJECT_TARGET)\msimeset.exe \
    ..\$(ALT_PROJECT_TARGET)\netapi.dll \
    ..\$(ALT_PROJECT_TARGET)\olecli.dll \
    ..\$(ALT_PROJECT_TARGET)\pmspl.dll \
    ..\$(ALT_PROJECT_TARGET)\us.bat \
    ..\$(ALT_PROJECT_TARGET)\ver.dll \
!endif
!if "$(ALT_PROJECT)" == "KOR" 
    ..\$(ALT_PROJECT_TARGET)\config.nt \
    ..\$(ALT_PROJECT_TARGET)\edit.com \
    ..\$(ALT_PROJECT_TARGET)\edit.exe \
    ..\$(ALT_PROJECT_TARGET)\edit.hlp \
    ..\$(ALT_PROJECT_TARGET)\edit2.hlp \
    ..\$(ALT_PROJECT_TARGET)\qbasic.com \
    ..\$(ALT_PROJECT_TARGET)\qbasic.exe \
    ..\$(ALT_PROJECT_TARGET)\qbasic.hlp \
    ..\$(ALT_PROJECT_TARGET)\qbasic2.exe \
    ..\$(ALT_PROJECT_TARGET)\qbasic2.hlp \
    ..\$(ALT_PROJECT_TARGET)\ver.dll \
    ..\$(ALT_PROJECT_TARGET)\olecli.dll \
!endif
!if "$(ALT_PROJECT)" == "CHS" || "$(ALT_PROJECT)" == "CHT" || "$(ALT_PROJECT)" == "CHP"
    ..\$(ALT_PROJECT_TARGET)\country.sys \
    ..\$(ALT_PROJECT_TARGET)\netapi.dll \
    ..\$(ALT_PROJECT_TARGET)\olecli.dll \
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\data.c ===
/*
 *  data.c - Main data of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop

#ifdef i386
PX86CONTEXT     px86;
#endif

DWORD IntelMemoryBase;

DWORD VdmDbgTraceFlags = 0;

BOOL  fDebugged = FALSE;

VDMCONTEXT vcContext;
WORD EventFlags;                // flags defined in VDMDBG.H
VDMINTERNALINFO viInfo;
DWORD EventParams[4];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbg\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=mvdm
MINORCOMP=dbg

TARGETNAME=dbg
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\..\inc;..\..\..\inc

SOURCES=..\dbg.c

C_DEFINES=-DWIN_32 -DDEBUG

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbg\dbg.c ===
/*
 *  dbg.c - Main Module of DBG DLL.
 *
 *  BobDay 13-Jan-1992 Created
 *  Neilsa 13-Mar-1997 Moved guts to dbgdll
 *
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <mvdm.h>
#include <bop.h>
#include <softpc.h>
#include <dbgexp.h>
#include <dbgsvc.h>
#include <vdmdbg.h>
#include <dbginfo.h>
#include <vdm.h>

BOOL (WINAPI *pfnDbgInit)(ULONG, ULONG, PVOID);
BOOL (WINAPI *pfnDbgIsDebuggee)(VOID);
VOID (WINAPI *pfnDbgDispatch)(VOID);
VOID (WINAPI *pfnDbgDosAppStart)(WORD, WORD);
VOID (WINAPI *pfnDbgSegmentNotice)(WORD, WORD, WORD, WORD, LPSTR, LPSTR, DWORD);
VOID (WINAPI *pfnDbgTraceEvent)(PVDM_TRACEINFO, WORD, WORD, DWORD);
BOOL (WINAPI *pfnDbgFault)(ULONG);
BOOL (WINAPI *pfnDbgBPInt)(VOID);
BOOL (WINAPI *pfnDbgTraceInt)(VOID);
VOID (WINAPI *pfnDbgNotifyNewTask)(LPVOID, UINT);
VOID (WINAPI *pfnDbgNotifyRemoteThreadAddress)(LPVOID, DWORD);
VOID (WINAPI *pfnDbgNotifyDebugged)(BOOL);

#ifdef i386
BYTE nt_cpu_info;
#else
extern ULONG Start_of_M_area;
extern BYTE nt_cpu_info;
#define IntelBase Start_of_M_area
//
// This field is used to hold values destined for NTVDMSTATE (at 714)
// Initially, we set it to INITIAL_VDM_TIB_FLAGS just for clarity, since it
// will really only be turned on or off once we look to see if a debugger
// is attached. This way, if you examine it when you first attach with a
// debugger, it will be consistent with the default.
//
ULONG InitialVdmTibFlags = INITIAL_VDM_TIB_FLAGS;

VDM_TRACEINFO TraceInfo;
PVDM_TRACEINFO pVdmTraceInfo = &TraceInfo;
#endif

BOOL bDbgInitCalled = FALSE;
BOOL bDbgDebuggerLoaded = FALSE;

ULONG InitialVdmDbgFlags = 0;

/* DBGInit - DBG Initialiazation routine.
 *
 * This routine is called during ntvdm initialization from host\src.
 * It is responsible for loading ntvdmd.dll, if vdm debugging is required.
 */

BOOL DBGInit (int argc, char *argv[])
{
    HANDLE  hmodDBG;

    // Indicate to VdmDbgAttach that we have gotten far enough into
    // the ntvdm boot that memory layout is valid.
    bDbgInitCalled = TRUE;

    //LATER Decide to load this on a registry switch
    if (!bDbgDebuggerLoaded) {
        if ( (hmodDBG = LoadLibrary("NTVDMD.DLL")) == (HANDLE)NULL ) {
#if DBG
            OutputDebugString("NTVDM: error loading ntvdmd.dll\n");
#endif
            return FALSE;
        } else {
            //
            // pfnDbgDispatch is special in that we always want to call it
            // even if no debugger is attached.
            //
            pfnDbgDispatch      = (VOID (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgDispatch" );
        }
    }
    return TRUE;
}


/* VdmDbgAttach
 *
 * This routine is called from NTVDMD.DLL. It is potentially called
 * at any time, but specifically we are looking to run some code when:

 *  1) the ntvdm has "matured", and
 *  2) a debugger is attached
 *
 * The ntvdm has "matured" when it is initialized sufficiently to determine
 * for example where the start of VDM memory is (on risc platforms).
 *
 */
VOID
VdmDbgAttach(
    VOID
    )
{
    if (bDbgInitCalled) {
        HANDLE  hmodDBG;
        hmodDBG = GetModuleHandle("NTVDMD.DLL");

        if ( hmodDBG == (HANDLE)NULL ) {
            return;
        }

        pfnDbgInit          = (BOOL (WINAPI *)(ULONG, ULONG, PVOID)) GetProcAddress( hmodDBG, "xxxDbgInit" );
        pfnDbgIsDebuggee    = (BOOL (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgIsDebuggee" );
        pfnDbgDosAppStart   = (VOID (WINAPI *)(WORD, WORD)) GetProcAddress( hmodDBG, "xxxDbgDosAppStart" );
        pfnDbgSegmentNotice = (VOID (WINAPI *)(WORD, WORD, WORD, WORD, LPSTR, LPSTR, DWORD)) GetProcAddress( hmodDBG, "xxxDbgSegmentNotice" );
        pfnDbgTraceEvent    = (VOID (WINAPI *)(PVDM_TRACEINFO, WORD, WORD, DWORD)) GetProcAddress( hmodDBG, "xxxDbgTraceEvent" );
        pfnDbgFault         = (BOOL (WINAPI *)(ULONG)) GetProcAddress( hmodDBG, "xxxDbgFault" );
        pfnDbgBPInt         = (BOOL (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgBPInt" );
        pfnDbgTraceInt      = (BOOL (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgTraceInt" );
        pfnDbgNotifyNewTask = (VOID (WINAPI *)(LPVOID, UINT)) GetProcAddress( hmodDBG, "xxxDbgNotifyNewTask" );
        pfnDbgNotifyRemoteThreadAddress = (VOID (WINAPI *)(LPVOID, DWORD)) GetProcAddress( hmodDBG, "xxxDbgNotifyRemoteThreadAddress" );
        pfnDbgNotifyDebugged= (VOID (WINAPI *)(BOOL)) GetProcAddress( hmodDBG, "xxxDbgNotifyDebugged" );
        //
        // DBGinit has already been called. Do an init, and send
        // symbol notifications
        //
        if (pfnDbgInit &&
            (bDbgDebuggerLoaded = (*pfnDbgInit)(IntelBase + FIXED_NTVDMSTATE_LINEAR,
                                                InitialVdmDbgFlags,
                                                &nt_cpu_info))) {
            //LATER: send symbol notifications
        }
    }
}


VOID
DBGNotifyNewTask(
    LPVOID  lpvNTFrame,
    UINT    uFrameSize
    )
{
    if (pfnDbgNotifyNewTask) {
        (*pfnDbgNotifyNewTask)(lpvNTFrame, uFrameSize);
    }
}


VOID
DBGNotifyRemoteThreadAddress(
    LPVOID  lpAddress,
    DWORD   lpBlock
    )
{
    if (pfnDbgNotifyRemoteThreadAddress) {
        (*pfnDbgNotifyRemoteThreadAddress)(lpAddress, lpBlock);
    }
}

VOID DBGNotifyDebugged(
    BOOL    fNewDebugged
    )
{
    if (pfnDbgNotifyDebugged) {
        (*pfnDbgNotifyDebugged)(fNewDebugged);
    }
}

BOOL DbgTraceInt(VOID)
{
    BOOL bRet = FALSE;
    if (pfnDbgTraceInt) {
        bRet = (*pfnDbgTraceInt)();
    }
    return bRet;
}

BOOL DbgFault(ULONG value)
{
    BOOL bRet = FALSE;
    if (pfnDbgFault) {
        bRet = (*pfnDbgFault)(value);
    }
    return bRet;
}

BOOL
DbgIsDebuggee(
    void
    )
{
    if (pfnDbgIsDebuggee) {
        return (*pfnDbgIsDebuggee)();
    }
    return FALSE;
}

VOID
DbgSegmentNotice(
    WORD  wType,
    WORD  wModuleSeg,
    WORD  wLoadSeg,
    WORD  wNewSeg,
    LPSTR lpModuleName,
    LPSTR lpModulePath,
    DWORD dwImageLen
    )
{
    if (pfnDbgSegmentNotice) {
        (*pfnDbgSegmentNotice)(wType, wModuleSeg, wLoadSeg, wNewSeg,
                               lpModuleName, lpModulePath, dwImageLen);
    }
}

VOID
DbgDosAppStart(
    WORD wCS,
    WORD wIP
    )
{
    if (pfnDbgDosAppStart) {
        (*pfnDbgDosAppStart)(wCS, wIP);
    }
}

void DBGDispatch()
{
    if (pfnDbgDispatch) {
        (*pfnDbgDispatch)();
    }
}

BOOL DbgBPInt()
{
    BOOL bRet = FALSE;
    if (pfnDbgBPInt) {
        bRet = (*pfnDbgBPInt)();
    }
    return bRet;
}


VOID
VdmTraceEvent(
    USHORT Type,
    USHORT wData,
    ULONG  lData
    )
{

    if (pfnDbgTraceEvent &&
        (*(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_TRACE_HISTORY)) {

        PVDM_TIB VdmTib = NtCurrentTeb()->Vdm;

        (*pfnDbgTraceEvent)(&((*VdmTib).TraceInfo), Type, wData, lData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\brkpt.c ===
/*
 *  brkpt.c - Breakpoint functions of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop

BOOL bWantsTraceInteractive = FALSE;

VDM_BREAKPOINT VdmBreakPoints[MAX_VDM_BREAKPOINTS] = {0};

#define X86_BP_OPCODE 0xCC


void
DbgSetTemporaryBP(
    WORD Seg,
    DWORD Offset,
    BOOL mode
    )
/*
    This routine writes a 'CC' to the specified location, and sets up
    the breakpoint structure so that we handle it correctly in DbgBPInt().
*/

{
    PBYTE lpInst;

    if (VdmBreakPoints[VDM_TEMPBP].Flags & VDMBP_SET) {

        // remove previous bp

        lpInst = VdmMapFlat(VdmBreakPoints[VDM_TEMPBP].Seg,
                            VdmBreakPoints[VDM_TEMPBP].Offset,
                          ((VdmBreakPoints[VDM_TEMPBP].Flags & VDMBP_V86)==0) ? VDM_PM : VDM_V86 );

        if (lpInst && (*lpInst == X86_BP_OPCODE)) {

            *lpInst = VdmBreakPoints[VDM_TEMPBP].Opcode;

            Sim32FlushVDMPointer(
                    ((ULONG)VdmBreakPoints[VDM_TEMPBP].Seg << 16) +
                            VdmBreakPoints[VDM_TEMPBP].Offset,
                    1,
                    NULL,
                    (BOOL)((VdmBreakPoints[VDM_TEMPBP].Flags & VDMBP_V86)==0) );

        }
    }

    lpInst = VdmMapFlat(Seg, Offset, mode ? VDM_PM : VDM_V86);

    if (lpInst) {

        VdmBreakPoints[VDM_TEMPBP].Seg = Seg;
        VdmBreakPoints[VDM_TEMPBP].Offset = Offset;
        VdmBreakPoints[VDM_TEMPBP].Flags = VDMBP_SET | VDMBP_ENABLED;
        VdmBreakPoints[VDM_TEMPBP].Flags |= (mode ? 0 : VDMBP_V86);
        VdmBreakPoints[VDM_TEMPBP].Opcode = *lpInst;

        *lpInst = X86_BP_OPCODE;

        Sim32FlushVDMPointer(((ULONG)Seg << 16) + Offset, 1, NULL, mode);

    } else {
        VdmBreakPoints[VDM_TEMPBP].Flags = 0;
    }

}




BOOL
xxxDbgBPInt(
    )

/*
 * DbgBPInt
 *
 * Handles an INT 3
 *
 * Exit
 *      Returns TRUE if the event was handled
 *              FALSE if it should be reflected
 */
{
    BOOL            bEventHandled = FALSE;
    ULONG           vdmEip;
    int             i;
    PBYTE           lpInst;


    if ( fDebugged ) {

        DbgGetContext();
        if ((getMSW() & MSW_PE) && SEGMENT_IS_BIG(vcContext.SegCs)) {
            vdmEip = vcContext.Eip;
        } else {
            vdmEip = (ULONG)LOWORD(vcContext.Eip);
        }

        for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

            if ((VdmBreakPoints[i].Flags & VDMBP_ENABLED) &&
                (VdmBreakPoints[i].Flags & VDMBP_SET) &&
                (vcContext.SegCs == VdmBreakPoints[i].Seg) &&
                (vdmEip == VdmBreakPoints[i].Offset+1)  &&
                (!!(getMSW() & MSW_PE) == !(VdmBreakPoints[i].Flags & VDMBP_V86)) ){

                // We must have hit this breakpoint. Back up the eip and
                // restore the original data
                setEIP(getEIP()-1);
                vcContext.Eip--;

                lpInst = VdmMapFlat(VdmBreakPoints[i].Seg, 
                                    VdmBreakPoints[i].Offset,
                                   ((VdmBreakPoints[i].Flags & VDMBP_V86)==0) ? VDM_PM : VDM_V86 );

                if (lpInst && (*lpInst == X86_BP_OPCODE)) {
                    *lpInst = VdmBreakPoints[i].Opcode;

                    Sim32FlushVDMPointer(
                                ((ULONG)VdmBreakPoints[i].Seg << 16) +
                                        VdmBreakPoints[i].Offset,
                                1,
                                NULL,
                                (BOOL)((VdmBreakPoints[i].Flags & VDMBP_V86)==0) );

                    VdmBreakPoints[i].Flags |= VDMBP_PENDING;
                    VdmBreakPoints[i].Flags &= ~VDMBP_FLUSH;
                    if (i == VDM_TEMPBP) {
                        // non-persistent breakpoint
                        VdmBreakPoints[i].Flags &= ~VDMBP_SET;
                    }
                }

                SendVDMEvent( DBG_BREAK );

                bEventHandled = TRUE;

                bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);

                if (bWantsTraceInteractive || (i != VDM_TEMPBP)) {
                    vcContext.EFlags |= V86FLAGS_TRACE;
                }
                RestoreVDMContext(&vcContext);

                break;

            }
        }

        if (!bEventHandled) {
            OutputDebugString("VDM: Unexpected breakpoint hit\n");
            SendVDMEvent( DBG_BREAK );
            bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);
            RestoreVDMContext(&vcContext);
        }

        bEventHandled = TRUE;

    }

    return bEventHandled;
}



BOOL
xxxDbgTraceInt(
    )

/*
 * DbgTraceInt
 *
 * Handles an INT 1 fault
 *
 * Exit
 *      Returns TRUE if the event was handled
 *              FALSE if it should be reflected
 */
{
    BOOL            bEventHandled = FALSE;
    int             i;
    PBYTE           lpInst;


    if ( fDebugged ) {

        DbgGetContext();
        setEFLAGS(vcContext.EFlags & ~V86FLAGS_TRACE);

        for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

            if ((VdmBreakPoints[i].Flags & VDMBP_ENABLED) &&
                (VdmBreakPoints[i].Flags & VDMBP_SET) &&
                (VdmBreakPoints[i].Flags & VDMBP_PENDING)) {


                lpInst = VdmMapFlat(VdmBreakPoints[i].Seg, 
                                    VdmBreakPoints[i].Offset,
                                   ((VdmBreakPoints[i].Flags & VDMBP_V86)==0) ? VDM_PM : VDM_V86 );

                if (lpInst) {
                    *lpInst = X86_BP_OPCODE;
                }

                Sim32FlushVDMPointer(
                            ((ULONG)VdmBreakPoints[i].Seg << 16) +
                                    VdmBreakPoints[i].Offset,
                            1,
                            NULL,
                            (BOOL)((VdmBreakPoints[i].Flags & VDMBP_V86)==0) );

                VdmBreakPoints[i].Flags &= ~(VDMBP_PENDING | VDMBP_FLUSH);

                bEventHandled = TRUE;
            }

        }

        if (bWantsTraceInteractive) {

            SendVDMEvent( DBG_BREAK );
            RestoreVDMContext(&vcContext);
            bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);

        } else if (!bEventHandled) {

            OutputDebugString("VDM: Unexpected trace interrupt\n");
            SendVDMEvent( DBG_BREAK );
            bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);
            RestoreVDMContext(&vcContext);

        }

        bEventHandled = TRUE;

    }

    return bEventHandled;
}


VOID
FlushVdmBreakPoints(
    )
{
    int i;

    for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

        if (VdmBreakPoints[i].Flags & VDMBP_FLUSH) {

            Sim32FlushVDMPointer(
                    ((ULONG)VdmBreakPoints[i].Seg << 16) +
                            VdmBreakPoints[i].Offset,
                    1,
                    NULL,
                    (BOOL)((VdmBreakPoints[i].Flags & VDMBP_V86)==0) );

            VdmBreakPoints[i].Flags &= ~VDMBP_FLUSH;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\dbgdll.h ===
/*
 *  dbgdll.h - Main header file of DBG DLL.
 *
 */


#ifdef i386
extern PX86CONTEXT     px86;
#endif

extern DECLSPEC_IMPORT VDMLDT_ENTRY *ExpLdt;
#define SEGMENT_IS_BIG(sel) (ExpLdt[(sel & ~0x7)/sizeof(VDMLDT_ENTRY)].HighWord.Bits.Default_Big)

extern DWORD IntelMemoryBase;
extern DWORD VdmDbgTraceFlags;
extern BOOL  fDebugged;

extern VDMCONTEXT vcContext;
extern WORD EventFlags;
extern VDMINTERNALINFO viInfo;
extern DWORD EventParams[4];

extern VDM_BREAKPOINT VdmBreakPoints[MAX_VDM_BREAKPOINTS];


#define MAX_MODULE  64
#define MAX_DBG_FRAME   10

typedef struct _trapframe {
    WORD    wCode;          /* Noise from DbgDispatchBop */
    WORD    wAX;            /* AX at time of fault */
    WORD    wDS;            /* DS at time of fault */
    WORD    wRetIP;         /* Noise from DPMI */
    WORD    wRetCS;         /* Noise from DPMI */
    WORD    wErrCode;       /* Noise from 16-bit kernel */
    WORD    wIP;            /* IP at time of fault */
    WORD    wCS;            /* CS at time of fault */
    WORD    wFlags;         /* Flags at time of fault */
    WORD    wSP;            /* SS at time of fault */
    WORD    wSS;            /* SP at time of fault */
} TFRAME16;
typedef TFRAME16 UNALIGNED *PTFRAME16;

typedef struct _faultframe {
    WORD    wES;            /* ES at time of fault */
    WORD    wDS;            /* DS at time of fault */
    WORD    wDI;            /* DI at time of fault */
    WORD    wSI;            /* SI at time of fault */
    WORD    wTempBP;        /* Noise from 16-bit kernel stack frame */
    WORD    wTempSP;        /* Noise from 16-bit kernel stack frame */
    WORD    wBX;            /* BX at time of fault */
    WORD    wDX;            /* DX at time of fault */
    WORD    wCX;            /* CX at time of fault */
    WORD    wAX;            /* AX at time of fault */
    WORD    wBP;            /* BP at time of fault */
    WORD    npszMsg;        /* Noise from 16-bit kernel */
    WORD    wPrevIP;        /* Noise from DPMI */
    WORD    wPrevCS;        /* Noise from DPMI */
    WORD    wRetIP;         /* Noise from DPMI */
    WORD    wRetCS;         /* Noise from DPMI */
    WORD    wErrCode;       /* Noise from 16-bit kernel */
    WORD    wIP;            /* IP at time of fault */
    WORD    wCS;            /* CS at time of fault */
    WORD    wFlags;         /* Flags at time of fault */
    WORD    wSP;            /* SS at time of fault */
    WORD    wSS;            /* SP at time of fault */
} FFRAME16;
typedef FFRAME16 UNALIGNED *PFFRAME16;

typedef struct _newtaskframe {
    DWORD   dwNoise;            /* Noise from InitTask         */
    DWORD   dwModulePath;       /* Module path address         */
    DWORD   dwModuleName;       /* Module name address         */
    WORD    hModule;            /* 16-bit Module handle        */
    WORD    hTask;              /* 16-bit Task handle          */
    WORD    wFlags;             /* Flags at time to task start */
    WORD    wDX;                /* DX at time of task start    */
    WORD    wBX;                /* BX at time of task start    */
    WORD    wES;                /* ES at time of task start    */
    WORD    wCX;                /* CX at time of task start    */
    WORD    wAX;                /* AX at time of task start    */
    WORD    wDI;                /* DI at time of task start    */
    WORD    wSI;                /* SI at time of task start    */
    WORD    wDS;                /* DS at time of task start    */
    WORD    wBP;                /* BP at time of task start    */
    WORD    wIP;                /* IP for task start           */
    WORD    wCS;                /* CS for task start           */
} NTFRAME16;
typedef NTFRAME16 UNALIGNED *PNTFRAME16;

#pragma pack(2)

typedef struct _stoptaskframe {
    WORD    wCode;              /* Noise from BOP Dispatcher  */
    DWORD   dwModulePath;       /* Module path address        */
    DWORD   dwModuleName;       /* Module name address        */
    WORD    hModule;            /* 16-bit Module handle       */
    WORD    hTask;              /* 16-bit Task handle         */
} STFRAME16;
typedef STFRAME16 UNALIGNED *PSTFRAME16;

typedef struct _newdllframe {
    WORD    wCode;              /* Noise from DbgDispatchBop  */
    DWORD   dwModulePath;       /* Module path address        */
    DWORD   dwModuleName;       /* Module name address        */
    WORD    hModule;            /* 16-bit Module handle       */
    WORD    hTask;              /* 16-bit Task handle         */
    WORD    wDS;                /* DS at time of dll start    */
    WORD    wAX;                /* AX at time of dll start    */
    WORD    wIP;                /* IP at time of dll start    */
    WORD    wCS;                /* CS at time of dll start    */
    WORD    wFlags;             /* Flags at time of dll start */
} NDFRAME16;
typedef NDFRAME16 UNALIGNED *PNDFRAME16;

#pragma pack()

VOID
DbgAttach(
    VOID
    );

VOID
FlushVdmBreakPoints(
    VOID
    );

BOOL
SendVDMEvent(
    WORD wEventType
    );

VOID
DbgGetContext(
    VOID
    );

void
DbgSetTemporaryBP(
    WORD Seg,
    DWORD Offset,
    BOOL mode
    );

void SegmentLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Selector,
    WORD    Segment,
    BOOL    fData
    );

void SegmentMove(
    WORD    OldSelector,
    WORD    NewSelector
    );

void SegmentFree(
    WORD    Selector,
    BOOL    fBPRelease
    );

void ModuleLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Segment,
    DWORD   Length
    );

void ModuleSegmentMove(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    ModuleSegment,
    WORD    OldSelector,
    WORD    NewSelector,
    DWORD   Length
    );

void ModuleFree(
    LPSTR   lpModuleName,
    LPSTR   lpPathName
    );

BOOL DbgGPFault2(
    PFFRAME16   pFFrame
    );

BOOL DbgDivOverflow2(
    PTFRAME16   pTFrame
    );

VOID
RestoreVDMContext(
    VDMCONTEXT *vcContext
    );

VOID
DbgDosAppStart(
    WORD wCS,
    WORD wIP
    );

BOOL
DbgDllStart(
    PNDFRAME16  pNDFrame
    );

BOOL
DbgTaskStop(
    PSTFRAME16  pSTFrame
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\excptn.c ===
/*
 *  excptn.c - Exception functions of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop



BOOL DbgGPFault2(
    PFFRAME16   pFFrame
    )
/*
    2nd chance GPFault handler (called via BOP)
*/
{
    BOOL            fResult;

    fResult = FALSE;        // Default to Event not handled

    DbgGetContext();

    vcContext.SegEs = (ULONG)pFFrame->wES;
    vcContext.SegDs = (ULONG)pFFrame->wDS;
    vcContext.SegCs = (ULONG)pFFrame->wCS;
    vcContext.SegSs = (ULONG)pFFrame->wSS;

#ifdef i386
    //
    // On x86 systems, we really might have some data in the high words
    // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
    // blow them away.  Here is where we attempt to recover them.
    //
    vcContext.Edi    = MAKELONG(pFFrame->wDI,   HIWORD(px86->Edi   ));
    vcContext.Esi    = MAKELONG(pFFrame->wSI,   HIWORD(px86->Esi   ));
    vcContext.Ebx    = MAKELONG(pFFrame->wBX,   HIWORD(px86->Ebx   ));
    vcContext.Edx    = MAKELONG(pFFrame->wDX,   HIWORD(px86->Edx   ));
    vcContext.Ecx    = MAKELONG(pFFrame->wCX,   HIWORD(px86->Ecx   ));
    vcContext.Eax    = MAKELONG(pFFrame->wAX,   HIWORD(px86->Eax   ));

    vcContext.Ebp    = MAKELONG(pFFrame->wBP,   HIWORD(px86->Ebp   ));
    vcContext.Eip    = MAKELONG(pFFrame->wIP,   HIWORD(px86->Eip   ));
    vcContext.Esp    = MAKELONG(pFFrame->wSP,   HIWORD(px86->Esp   ));
    vcContext.EFlags = MAKELONG(pFFrame->wFlags,HIWORD(px86->EFlags));
#else
    vcContext.Edi    = (ULONG)pFFrame->wDI;
    vcContext.Esi    = (ULONG)pFFrame->wSI;
    vcContext.Ebx    = (ULONG)pFFrame->wBX;
    vcContext.Edx    = (ULONG)pFFrame->wDX;
    vcContext.Ecx    = (ULONG)pFFrame->wCX;
    vcContext.Eax    = (ULONG)pFFrame->wAX;

    vcContext.Ebp    = (ULONG)pFFrame->wBP;
    vcContext.Eip    = (ULONG)pFFrame->wIP;
    vcContext.Esp    = (ULONG)pFFrame->wSP;
    vcContext.EFlags = (ULONG)pFFrame->wFlags;

#endif

    if ( fDebugged ) {
        fResult = SendVDMEvent(DBG_GPFAULT2);

        if ( !fResult ) {
            DWORD dw;

            dw = SetErrorMode(0);
            try {
                RaiseException((DWORD)DBG_CONTROL_BREAK, 0, 0, (LPDWORD)0);
                fResult = TRUE;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                fResult = FALSE;
            }
            SetErrorMode(dw);
        }

    } else {
        char    text[100];

        // Dump a simulated context

        OutputDebugString("NTVDM:GP Fault detected, register dump follows:\n");

        wsprintf(text,"eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
            vcContext.Eax,
            vcContext.Ebx,
            vcContext.Ecx,
            vcContext.Edx,
            vcContext.Esi,
            vcContext.Edi  );
        OutputDebugString(text);

        wsprintf(text,"eip=%08lx esp=%08lx ebp=%08lx iopl=%d         %s %s %s %s %s %s %s %s\n",
            vcContext.Eip,
            vcContext.Esp,
            vcContext.Ebp,
            (vcContext.EFlags & V86FLAGS_IOPL) >> V86FLAGS_IOPL_BITS,
            (vcContext.EFlags & V86FLAGS_OVERFLOW ) ? "ov" : "nv",
            (vcContext.EFlags & V86FLAGS_DIRECTION) ? "dn" : "up",
            (vcContext.EFlags & V86FLAGS_INTERRUPT) ? "ei" : "di",
            (vcContext.EFlags & V86FLAGS_SIGN     ) ? "ng" : "pl",
            (vcContext.EFlags & V86FLAGS_ZERO     ) ? "zr" : "nz",
            (vcContext.EFlags & V86FLAGS_AUXCARRY ) ? "ac" : "na",
            (vcContext.EFlags & V86FLAGS_PARITY   ) ? "po" : "pe",
            (vcContext.EFlags & V86FLAGS_CARRY    ) ? "cy" : "nc" );
        OutputDebugString(text);

        wsprintf(text,"cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x             efl=%08lx\n",
            (WORD)vcContext.SegCs,
            (WORD)vcContext.SegSs,
            (WORD)vcContext.SegDs,
            (WORD)vcContext.SegEs,
            (WORD)vcContext.SegFs,
            (WORD)vcContext.SegGs,
            vcContext.EFlags );
        OutputDebugString(text);
    }

#ifdef i386
    //
    // On x86 systems, we really might have some data in the FS and GS
    // registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
    // blow them away.  Here is where we attempt to restore them.
    //
    px86->SegGs = (WORD)vcContext.SegGs;
    px86->SegFs = (WORD)vcContext.SegFs;
#else
    // No need to set FS,GS, they don't exist
#endif

    pFFrame->wES = (WORD)vcContext.SegEs;
    pFFrame->wDS = (WORD)vcContext.SegDs;
    pFFrame->wCS = (WORD)vcContext.SegCs;
    pFFrame->wSS = (WORD)vcContext.SegSs;

#ifdef i386
    //
    // On x86 systems, we really might have some data in the high words
    // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
    // blow them away.  Here is where we attempt to restore them.
    //
    pFFrame->wDI = LOWORD(vcContext.Edi);
    px86->Edi = MAKELONG(LOWORD(px86->Edi),HIWORD(vcContext.Edi));

    pFFrame->wSI = LOWORD(vcContext.Esi);
    px86->Esi = MAKELONG(LOWORD(px86->Esi),HIWORD(vcContext.Esi));

    pFFrame->wBX = LOWORD(vcContext.Ebx);
    px86->Ebx = MAKELONG(LOWORD(px86->Ebx),HIWORD(vcContext.Ebx));

    pFFrame->wDX = LOWORD(vcContext.Edx);
    px86->Edx = MAKELONG(LOWORD(px86->Edx),HIWORD(vcContext.Edx));

    pFFrame->wCX = LOWORD(vcContext.Ecx);
    px86->Ecx = MAKELONG(LOWORD(px86->Ecx),HIWORD(vcContext.Ecx));

    pFFrame->wAX = LOWORD(vcContext.Eax);
    px86->Eax = MAKELONG(LOWORD(px86->Eax),HIWORD(vcContext.Eax));

    pFFrame->wBP = LOWORD(vcContext.Ebp);
    px86->Ebp = MAKELONG(LOWORD(px86->Ebp),HIWORD(vcContext.Ebp));

    pFFrame->wIP = LOWORD(vcContext.Eip);
    px86->Eip = MAKELONG(LOWORD(px86->Eip),HIWORD(vcContext.Eip));

    pFFrame->wFlags = LOWORD(vcContext.EFlags);
    px86->EFlags = MAKELONG(LOWORD(px86->EFlags),HIWORD(vcContext.EFlags));

    pFFrame->wSP = LOWORD(vcContext.Esp);
    px86->Esp = MAKELONG(LOWORD(px86->Esp),HIWORD(vcContext.Esp));
#else
    pFFrame->wDI = (WORD)vcContext.Edi;
    pFFrame->wSI = (WORD)vcContext.Esi;
    pFFrame->wBX = (WORD)vcContext.Ebx;
    pFFrame->wDX = (WORD)vcContext.Edx;
    pFFrame->wCX = (WORD)vcContext.Ecx;
    pFFrame->wAX = (WORD)vcContext.Eax;


    pFFrame->wBP = (WORD)vcContext.Ebp;
    pFFrame->wIP = (WORD)vcContext.Eip;
    pFFrame->wFlags = (WORD)vcContext.EFlags;
    pFFrame->wSP = (WORD)vcContext.Esp;
#endif

    return( fResult );
}

BOOL DbgDivOverflow2(
    PTFRAME16   pTFrame
    )
/*
    2nd chance divide exception handler
*/
{
    BOOL        fResult;

    fResult = FALSE;        // Default to Event not handled

    if ( fDebugged ) {

        DbgGetContext();

        vcContext.SegDs = (ULONG)pTFrame->wDS;
        vcContext.SegCs = (ULONG)pTFrame->wCS;
        vcContext.SegSs = (ULONG)pTFrame->wSS;

#ifdef i386
        //
        // On x86 systems, we really might have some data in the high words
        // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
        // blow them away.  Here is where we attempt to recover them.
        //
        vcContext.Eax    = MAKELONG(pTFrame->wAX,   HIWORD(px86->Eax   ));
        vcContext.Eip    = MAKELONG(pTFrame->wIP,   HIWORD(px86->Eip   ));
        vcContext.Esp    = MAKELONG(pTFrame->wSP,   HIWORD(px86->Esp   ));
        vcContext.EFlags = MAKELONG(pTFrame->wFlags,HIWORD(px86->EFlags));
#else
        vcContext.Eax    = (ULONG)pTFrame->wAX;

        vcContext.Eip    = (ULONG)pTFrame->wIP;
        vcContext.Esp    = (ULONG)pTFrame->wSP;
        vcContext.EFlags = (ULONG)pTFrame->wFlags;

#endif

        fResult = SendVDMEvent(DBG_DIVOVERFLOW);

#ifdef i386
        //
        // On x86 systems, we really might have some data in the FS and GS
        // registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
        // blow them away.  Here is where we attempt to restore them.
        //
        px86->SegGs = vcContext.SegGs;
        px86->SegFs = vcContext.SegFs;
#else
        // No need to set FS,GS, they don't exist
#endif

        setES( (WORD)vcContext.SegEs );
        pTFrame->wDS = (WORD)vcContext.SegDs;
        pTFrame->wCS = (WORD)vcContext.SegCs;
        pTFrame->wSS = (WORD)vcContext.SegSs;

#ifdef i386
        //
        // On x86 systems, we really might have some data in the high words
        // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
        // blow them away.  Here is where we attempt to restore them.
        //
        setEDI( vcContext.Edi );
        setESI( vcContext.Esi );
        setEBX( vcContext.Ebx );
        setEDX( vcContext.Edx );
        setECX( vcContext.Ecx );

        pTFrame->wAX = LOWORD(vcContext.Eax);
        px86->Eax = MAKELONG(LOWORD(px86->Eax),HIWORD(vcContext.Eax));

        setEBP( vcContext.Ebp );

        pTFrame->wIP = LOWORD(vcContext.Eip);
        px86->Eip = MAKELONG(LOWORD(px86->Eip),HIWORD(vcContext.Eip));

        pTFrame->wFlags = LOWORD(vcContext.EFlags);
        px86->EFlags = MAKELONG(LOWORD(px86->EFlags),HIWORD(vcContext.EFlags));

        pTFrame->wSP = LOWORD(vcContext.Esp);
        px86->Esp = MAKELONG(LOWORD(px86->Esp),HIWORD(vcContext.Esp));
#else
        setDI( (WORD)vcContext.Edi );
        setSI( (WORD)vcContext.Esi );
        setBX( (WORD)vcContext.Ebx );
        setDX( (WORD)vcContext.Edx );
        setCX( (WORD)vcContext.Ecx );
        pTFrame->wAX = (WORD)vcContext.Eax;


        setBP( (WORD)vcContext.Ebp );
        pTFrame->wIP    = (WORD)vcContext.Eip;
        pTFrame->wFlags = (WORD)vcContext.EFlags;
        pTFrame->wSP    = (WORD)vcContext.Esp;
#endif


    }

    return( fResult );
}



BOOL
xxxDbgFault(
    ULONG IntNumber
    )
/*
    This is the first chance exception handler. It is called by dpmi32
*/

{
    ULONG           vdmEip;
    int             i;
    PBYTE           lpInst;
    BOOL            fResult = FALSE;


    if ( fDebugged ) {

        switch(IntNumber) {
        case 6:
            //BUGBUG: We *could* handle these, but people might be confused by
            // the fact that krnl386 does an intentional opcode exception.
//            GetNormalContext( &vcContext, &viInfo, EventParams, DBG_INSTRFAULT, PX86 );
            break;

        case 12:
            if (*(ULONG *)(IntelMemoryBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_EXCEPTIONS) {
                DbgGetContext();
                fResult = SendVDMEvent(DBG_STACKFAULT);
            }
            break;

        case 13:
            if (*(ULONG *)(IntelMemoryBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_EXCEPTIONS) {
                DbgGetContext();
                fResult = SendVDMEvent(DBG_GPFAULT);
            }
            break;

        default:
            return FALSE;
        }
    }

    return fResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\dbgdll.c ===
/*++
 *  Main module of DBG DLL.
 *
 *  Copyright (c) 1997, Microsoft Corporation
 *
 *  This code runs in the debuggee's process.
 *
--*/
#include <precomp.h>
#pragma hdrstop


BOOL InVdmDebugger = FALSE;
BOOL bWantsNtsdPrompt = FALSE;

ULONG   ulTHHOOK = 0L;          // Address registered from 16-bit world
LPVOID  lpRemoteAddress = NULL; // Address registered from WOW32
DWORD   lpRemoteBlock   = 0;    // Address registered from WOW32
BOOL    f386;
DWORD VdmDbgEFLAGS;

WORD DbgWowhExeHead = 0;
WORD DbgWowhGlobalHeap = 0;
PDWORD lpVdmState = NULL;
PBYTE lpNtCpuInfo = NULL;

UCHAR DbgTimerMode = VDMTI_TIMER_TICK;
BOOL DbgTimerInitialized = FALSE;
VOID VdmDbgAttach(VOID);


BOOLEAN
DbgDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*
 * DBGDllInitialize - DBG Initialiazation routine.
 *
 */

{
    HANDLE      MyDebugPort;
    DWORD       st;
    BOOL        fAlreadyDebugged;

    UNREFERENCED_PARAMETER(Context);

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

#ifdef i386
        // X86 Only, get pointer to Register Context Block
        px86 = getIntelRegistersPointer();
#endif

        st = NtQueryInformationProcess(
                    NtCurrentProcess(),
                    ProcessDebugPort,
                    (PVOID)&MyDebugPort,
                    sizeof(MyDebugPort),
                    NULL );
        if ( NT_SUCCESS(st) ) {
            fDebugged = (MyDebugPort != NULL);
        } else {
            fDebugged = FALSE;
        }

        if (fDebugged) {
            DbgAttach();
        }
        break;

    case DLL_THREAD_ATTACH:
        //
        // See if the debugger is attaching. If it is, then turn on the
        // default of breaking into the debugger.
        //
        fAlreadyDebugged = fDebugged;

        st = NtQueryInformationProcess(
                    NtCurrentProcess(),
                    ProcessDebugPort,
                    (PVOID)&MyDebugPort,
                    sizeof(MyDebugPort),
                    NULL );
        if ( NT_SUCCESS(st) ) {
            fDebugged = (MyDebugPort != NULL);
        } else {
            fDebugged = FALSE;
        }

        if (fDebugged && !fAlreadyDebugged) {
            DbgAttach();
        }
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }
    return( TRUE );
}

void
DbgAttach(
    void
    )
/*
 *  DbgAttach
 *
 *  Called to initiate the communication with a debugger
 *
 */
{
    //
    // Send DBG_ATTACH notification
    //
    DbgGetContext();
    SendVDMEvent(DBG_ATTACH);

    //
    // This call tells ntvdm to resync with us
    //
    VdmDbgAttach();
}

BOOL
WINAPI
xxxDbgInit(
    PVOID pState,
    ULONG InitialVdmDbgFlags,
    PVOID pCpuInfo
    )
/*
 *  DbgInit
 *
 *  Called once ntvdm has completed it's initialization. Now it
 *  is possible to compute for example the IntelMemoryBase.
 *
 */
{

    VdmDbgTraceFlags = InitialVdmDbgFlags;
    lpVdmState = pState;
    IntelMemoryBase = (ULONG)VdmMapFlat(0, 0, VDM_V86);
    lpNtCpuInfo = pCpuInfo;

    //
    // turn on default debugging bits in ntvdmstate
    //
    *lpVdmState |= VDM_BREAK_DEBUGGER;
#if DBG
    *lpVdmState |= VDM_TRACE_HISTORY;
#endif

    if (fDebugged) {
        DbgGetContext();
        SendVDMEvent(DBG_INIT);
    }
    return TRUE;
}

BOOL
WINAPI
xxxDbgIsDebuggee(
    void
    )
/*
 * DbgIsDebuggee
 *
 * Determines if we are being debugged
 *
 * Entry: void
 *
 * Exit:  BOOL bRet - TRUE we are being debugged
 *
 */
{
   return fDebugged;
}

BOOL
SendVDMEvent(
    WORD wEventType
    )

/* SendVDMEvent
 *
 * Sends a VDM event notification to the debugger
 *
 * Entry:
 *
 * Exit:  BOOL bRet
 *        Returns TRUE if exception was handled, FALSE otherwise
 *
 */
{
    BOOL    fResult;

    EventParams[0] = MAKELONG( wEventType, EventFlags );
    EventParams[3] = (DWORD)&viInfo;

    InVdmDebugger = TRUE;

    do {

        bWantsNtsdPrompt = FALSE;


        // Slimyness to determine whether the exception was handled or not.

        try {
            RaiseException( STATUS_VDM_EVENT,
                            0,
                            4,
                            EventParams );
            fResult = TRUE;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            fResult = FALSE;
        }

        //
        // bWantsNtsdPrompt may be changed by vdmexts
        //
        if (bWantsNtsdPrompt) {
            DbgBreakPoint();
        }

    } while (bWantsNtsdPrompt);


    InVdmDebugger = FALSE;
    FlushVdmBreakPoints();

    return( fResult );
}


VOID
DbgGetContext(
    VOID
    )

/* DbgGetContext() - Get the VDM's current context
 *
 * Most of the routines that send VDMEvents need to have a context record
 * associated with them.  This routine is a quick way to get most of the
 * general registers.  Redundant work is being done because AX for example
 * is often on the stack and as such must really be pulled from the frame.
 * Hopefully this is OK because it is fast.
 */

{
    //
    // Everything defaults to 0.
    //
    RtlFillMemory( &vcContext, sizeof(VDMCONTEXT), (UCHAR)0 );
    RtlFillMemory( &viInfo, sizeof(VDMINTERNALINFO), (UCHAR)0 );

    //
    // Fill in the internal info structure
    //
    viInfo.dwLdtBase       = (DWORD)ExpLdt;
    viInfo.dwIntelBase     = IntelMemoryBase;
    viInfo.wKernelSeg      = HIWORD(ulTHHOOK);
    viInfo.dwOffsetTHHOOK  = (DWORD)(LOWORD(ulTHHOOK));
    viInfo.vdmContext      = &vcContext;
    viInfo.lpRemoteAddress = lpRemoteAddress;
    viInfo.lpRemoteBlock   = lpRemoteBlock;
    viInfo.f386            = f386;
    viInfo.lpNtvdmState    = lpVdmState;
    viInfo.lpVdmDbgFlags   = &VdmDbgTraceFlags;
    viInfo.lpNtCpuInfo     = lpNtCpuInfo;
    viInfo.lpVdmBreakPoints= &VdmBreakPoints;

    //
    // Fill in the context structure
    //
    vcContext.SegEs = (ULONG)getES();
    vcContext.SegDs = (ULONG)getDS();
    vcContext.SegCs = (ULONG)getCS();
    vcContext.SegSs = (ULONG)getSS();
    vcContext.SegFs = (ULONG)getFS();
    vcContext.SegGs = (ULONG)getGS();

    vcContext.EFlags = getEFLAGS();
    VdmDbgEFLAGS = vcContext.EFlags;            // save for vdmexts

    vcContext.Edi = getEDI();
    vcContext.Esi = getESI();
    vcContext.Ebx = getEBX();
    vcContext.Edx = getEDX();
    vcContext.Ecx = getECX();
    vcContext.Eax = getEAX();

    vcContext.Ebp = getEBP();
    vcContext.Eip = getEIP();
    vcContext.Esp = getESP();

    //
    // Put in special flags in event field
    //

    EventFlags = 0;
    if (!(getMSW() & MSW_PE) || (getEFLAGS() & V86FLAGS_V86)) {
        EventFlags |= VDMEVENT_V86;  // emulator is in real or v86 mode
    } else {
        EventFlags |= VDMEVENT_PE;

        if ((getMSW() & MSW_PE) && !SEGMENT_IS_BIG(vcContext.SegCs)) {
            EventFlags |= VDMEVENT_PM16;  // emulator is in real or v86 mode
        }
    }
}


void
WINAPI
xxxDbgDispatch()
{
    UNALIGNED WORD  *stack;
    WORD            mode;
    WORD            selector;
    WORD            segment;
    WORD            new_selector;
    BOOL            fBPRelease;
    BOOL            fData;
    LPSTR           lpModuleName;
    LPSTR           lpPathName;
    UCHAR           fPE;
    PFFRAME16       pFFrame;
    PTFRAME16       pTFrame;
    PNDFRAME16      pNDFrame;
    PSTFRAME16      pSTFrame;
    WORD            wFrame;

    fPE = ISPESET;

    stack = (UNALIGNED WORD *)Sim32GetVDMPointer(
                        ((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );

    mode = *stack++;

    //
    // If there is no debugger, then only handle DBG_WOWINIT
    //
    if (!fDebugged && (mode != DBG_WOWINIT)) {
        return;
    }

    switch( mode ) {
        case DBG_SEGLOAD:
            selector = *stack++;
            segment  = *stack++;
            lpModuleName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            stack += 2;
            lpPathName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            if ( lpPathName == NULL ) {
                lpPathName = "";
            }

            stack += 2;
            fData = (BOOL)(*stack++);
            SegmentLoad( lpModuleName, lpPathName, selector, segment, fData );
            break;

        case DBG_SEGMOVE:
            selector = *stack++;
            new_selector = *stack++;
            SegmentMove( selector, new_selector );
            break;

        case DBG_SEGFREE:
            fBPRelease = (BOOL)*stack++;
            selector = *stack++;
            SegmentFree( selector, fBPRelease );
            break;

        case DBG_MODFREE:
            lpModuleName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            stack += 2;
            lpPathName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            if ( lpPathName == NULL ) {
                lpPathName = "";
            }
            ModuleFree( lpModuleName, lpPathName );
            break;

        case DBG_GPFAULT2:
            wFrame = getBP() - (WORD)(FIELD_OFFSET(FFRAME16,wBP));

            pFFrame = (PFFRAME16)Sim32GetVDMPointer(
                        ((ULONG)getSS() << 16) + (ULONG)wFrame,
                        MAX_DBG_FRAME, fPE );


            fData = DbgGPFault2( pFFrame );

            setAX((WORD)fData);
            break;

        case DBG_DIVOVERFLOW:
            pTFrame = (PTFRAME16)Sim32GetVDMPointer(
                        (ULONG)((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );


            fData = DbgDivOverflow2( pTFrame );

            setAX((WORD)fData);
            break;

        case DBG_DLLSTART:
            pNDFrame = (PNDFRAME16)Sim32GetVDMPointer(
                        (ULONG)((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );


            fData = DbgDllStart( pNDFrame );

            setAX((WORD)fData);
            break;

        case DBG_TASKSTOP:
            pSTFrame = (PSTFRAME16)Sim32GetVDMPointer(
                        (ULONG)((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );

            fData = DbgTaskStop( pSTFrame );
            break;

        case DBG_ATTACH:
            break;

        case DBG_TOOLHELP:
            ulTHHOOK = (ULONG)*stack + ((ULONG)(*(stack+1)) << 16);
            stack += 2;
            f386 = (BOOL)*stack;
            break;

        case DBG_WOWINIT:
            //
            // Pass in some data from KRNL386 so that VDMEXTS can get a
            // hold of them.
            //
            DbgWowhExeHead = getDX();
            DbgWowhGlobalHeap = getCX();
            break;

        default:
            setAX(0);       // Event not handled
            break;
    }
}



VOID
xxxDbgNotifyRemoteThreadAddress(
    LPVOID  lpAddress,
    DWORD   lpBlock
) {
    lpRemoteAddress = lpAddress;
    lpRemoteBlock   = lpBlock;
}

VOID
xxxDbgNotifyDebugged(
    BOOL    fNewDebugged
) {
    fDebugged = fNewDebugged;
}



VOID
RestoreVDMContext(
    VDMCONTEXT *vcContext
    )
{

    setEAX(vcContext->Eax);
    setEBX(vcContext->Ebx);
    setECX(vcContext->Ecx);
    setEDX(vcContext->Edx);
    setEIP(vcContext->Eip);
    setESP(vcContext->Esp);
    setEBP(vcContext->Ebp);
    setEFLAGS(vcContext->EFlags);

}

ULONG
DbgEventTime(
    PVDM_TRACEINFO pVdmTraceInfo
    )
{
    ULONG TickCount = 0;
    USHORT id;
    ULONG CurTick;
    LARGE_INTEGER CurTime;
    LARGE_INTEGER DiffTime;
#ifdef _X86_
    ULONG CurHigh, CurLow;
#endif

    if (!DbgTimerInitialized) {

#ifdef _X86_
        ULONG CpuidHigh;
        _asm pushad
        _asm mov eax, 1
        _asm _emit 0fh
        _asm _emit 0a2h         // CPUID
        _asm mov CpuidHigh, edx
        _asm popad
        if (CpuidHigh & 0x10) {
            // cpu has time stamp counter
            DbgTimerMode = VDMTI_TIMER_PENTIUM;
        }
#endif


        switch(DbgTimerMode & VDMTI_TIMER_MODE) {

        case VDMTI_TIMER_TICK:
            pVdmTraceInfo->TimeStamp.LowPart = GetTickCount();
            DbgTimerInitialized = TRUE;
            break;

#ifdef _X86_
        case VDMTI_TIMER_PENTIUM:
            _asm push eax
            _asm push edx
            _asm _emit 0fh
            _asm _emit 031h     // RDTSC
            _asm mov CurLow, eax
            _asm mov CurHigh, edx
            _asm pop edx
            _asm pop eax

            pVdmTraceInfo->TimeStamp.LowPart = CurLow;
            pVdmTraceInfo->TimeStamp.HighPart = CurHigh;
            DbgTimerInitialized = TRUE;
            break;
#endif
        }
    }


    if (DbgTimerInitialized) {

        pVdmTraceInfo->Flags = (pVdmTraceInfo->Flags & ~VDMTI_TIMER_MODE) +
                                  (DbgTimerMode & VDMTI_TIMER_MODE);

        switch(pVdmTraceInfo->Flags & VDMTI_TIMER_MODE) {

        case VDMTI_TIMER_TICK:
            CurTick = GetTickCount();

            if (CurTick > pVdmTraceInfo->TimeStamp.LowPart) {
                TickCount = CurTick - pVdmTraceInfo->TimeStamp.LowPart;
                pVdmTraceInfo->TimeStamp.LowPart = CurTick;
            } else {
                TickCount = 0;
            }

            break;

#ifdef _X86_
        case VDMTI_TIMER_PENTIUM: {
            _asm push eax
            _asm push edx
            _asm _emit 0fh
            _asm _emit 031h     // RDTSC
            _asm mov CurLow, eax
            _asm mov CurHigh, edx
            _asm pop edx
            _asm pop eax
            CurTime.LowPart = CurLow;
            CurTime.HighPart = CurHigh;

            DiffTime.QuadPart = CurTime.QuadPart - pVdmTraceInfo->TimeStamp.QuadPart;
            pVdmTraceInfo->TimeStamp.QuadPart = CurTime.QuadPart;
            TickCount = DiffTime.LowPart;

            //if (DiffTime.HighPart) {
            //    TickCount = 0xffffffff;
            //}
            break;
            }
#endif
        }
    }

    return (TickCount);
}

#define NUM_VDM_TRACE_PAGES 8

VOID
WINAPI
xxxDbgTraceEvent(
    PVDM_TRACEINFO pVdmTraceInfo,
    USHORT Type,
    USHORT wData,
    ULONG  lData
    )
{
    PVDM_TRACEENTRY pEntry;

    if (!(*(ULONG *)(IntelMemoryBase+FIXED_NTVDMSTATE_LINEAR) & VDM_TRACE_HISTORY)) {
        return;
    }

    if (!pVdmTraceInfo->pTraceTable) {
        pVdmTraceInfo->pTraceTable = (PVDM_TRACEENTRY) VirtualAlloc(NULL,
                                                4096*NUM_VDM_TRACE_PAGES,
                                                MEM_COMMIT,
                                                PAGE_READWRITE);

        if (!pVdmTraceInfo->pTraceTable) {
            // couldn't allocate memory
            return;
        }

        pVdmTraceInfo->CurrentEntry = 0;
        pVdmTraceInfo->NumPages = NUM_VDM_TRACE_PAGES;
        pVdmTraceInfo->Flags = 0;
    }

    pEntry = &pVdmTraceInfo->pTraceTable[pVdmTraceInfo->CurrentEntry];

    pEntry->Type = Type;
    pEntry->wData = wData;
    pEntry->lData = lData;
    pEntry->Time = DbgEventTime(pVdmTraceInfo);

    pEntry->eax = getEAX();
    pEntry->ebx = getEBX();
    pEntry->ecx = getECX();
    pEntry->edx = getEDX();
    pEntry->esi = getESI();
    pEntry->edi = getEDI();
    pEntry->ebp = getEBP();
    pEntry->esp = getESP();
    pEntry->eip = getEIP();
    pEntry->eflags = getEFLAGS();

    pEntry->cs = getCS();
    pEntry->ds = getDS();
    pEntry->es = getES();
    pEntry->fs = getFS();
    pEntry->gs = getGS();
    pEntry->ss = getSS();

    if (++pVdmTraceInfo->CurrentEntry >=
        (pVdmTraceInfo->NumPages*4096/sizeof(VDM_TRACEENTRY))) {
        pVdmTraceInfo->CurrentEntry = 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <mvdm.h>
#include <bop.h>
#include <softpc.h>
#include <dbgexp.h>
#include <dbgsvc.h>
#include <vdmdbg.h>
#include <dbginfo.h>
#include <vdm.h>
#include <nt_vdd.h>
#include <dbgdll.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\module.c ===
/*
 *  module.c - Module functions of DBG DLL.
 *
 *
 */
#include <precomp.h>
#pragma hdrstop


VOID
WINAPI
xxxDbgDosAppStart(
    WORD wCS,
    WORD wIP
    )
{
    if ( fDebugged ) {
        if (VdmDbgTraceFlags & VDMDBG_BREAK_DOSTASK) {
            DbgSetTemporaryBP(wCS, wIP, FALSE);
        }
    }
}

BOOL
DbgDllStart(
    PNDFRAME16  pNDFrame
) {
    BOOL        fResult;

    fResult = FALSE;        // Default to Event not handled

    if ( fDebugged ) {
        LPSTR           lpModuleName;
        LPSTR           lpModulePath;
        UINT            length;
        UCHAR           fPE;
        IMAGE_NOTE      im;

        DbgGetContext();

        EventParams[2] = (DWORD)&im;

        // Get the module's path and name

        fPE = ISPESET;

        lpModuleName = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNDFrame->dwModuleName,
                            MAX_MODULE,
                            fPE );

        lpModulePath = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNDFrame->dwModulePath,
                            MAX_PATH,
                            fPE );

        length = (UINT)((UCHAR)*lpModuleName++);

        strncpy( im.Module, lpModuleName, length );
        im.Module[length] = '\0';

        length = (UINT)((UCHAR)*lpModulePath);
        lpModulePath += 8;
        length -= 8;

        strncpy( im.FileName, lpModulePath, length );
        im.FileName[length] = '\0';

        im.hModule = pNDFrame->hModule;
        im.hTask   = pNDFrame->hTask;

        fResult = SendVDMEvent(DBG_DLLSTART);

        if (VdmDbgTraceFlags & VDMDBG_BREAK_LOADDLL) {
            DbgSetTemporaryBP(pNDFrame->wCS, pNDFrame->wIP, (BOOL)(getMSW() & MSW_PE));
        }

    }

    return( fResult );
}


BOOL
DbgTaskStop(
    PSTFRAME16  pSTFrame
) {
    BOOL        fResult;

    fResult = FALSE;        // Default to Event not handled

    if ( fDebugged ) {
        LPSTR           lpModuleName;
        LPSTR           lpModulePath;
        UINT            length;
        UCHAR           fPE;
        IMAGE_NOTE      im;

        DbgGetContext();

        EventParams[2] = (DWORD)&im;

        // The code in TASK.ASM pops the frame off the stack before it IRETs
        vcContext.Esp += sizeof(STFRAME16);

        // Get the module's path and name

        fPE = ISPESET;

        lpModuleName = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pSTFrame->dwModuleName,
                            MAX_MODULE,
                            fPE );

        lpModulePath = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pSTFrame->dwModulePath,
                            MAX_PATH,
                            fPE );

        length = (UINT)((UCHAR)*lpModuleName++);

        strncpy( im.Module, lpModuleName, length );
        im.Module[length] = '\0';

        length = (UINT)((UCHAR)*lpModulePath);
        lpModulePath += 8;
        length -= 8;

        strncpy( im.FileName, lpModulePath, length );
        im.FileName[length] = '\0';

        im.hModule = pSTFrame->hModule;
        im.hTask   = pSTFrame->hTask;

        fResult = SendVDMEvent(DBG_TASKSTOP);

        // See comment about what the code does above
        vcContext.Esp -= sizeof(STFRAME16);
    }

    return( fResult );
}




VOID
xxxDbgNotifyNewTask(
    LPVOID  lpvNTFrame,
    UINT    uFrameSize
) {
    BOOL        fResult;
    PNTFRAME16  pNTFrame;

    pNTFrame = (PNTFRAME16)lpvNTFrame;

    if ( fDebugged ) {
        LPSTR           lpModuleName;
        LPSTR           lpModulePath;
        UINT            length;
        UCHAR           fPE;
        IMAGE_NOTE      im;

        DbgGetContext();

        EventParams[2] = (DWORD)&im;

        // Get the module's path and name

        fPE = ISPESET;

        lpModuleName = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNTFrame->dwModuleName,
                            MAX_MODULE,
                            fPE );

        lpModulePath = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNTFrame->dwModulePath,
                            MAX_PATH,
                            fPE );

        length = (UINT)((UCHAR)*lpModuleName++);

        strncpy( im.Module, lpModuleName, length );
        im.Module[length] = '\0';

        length = (UINT)((UCHAR)*lpModulePath);
        lpModulePath += 8;
        length -= 8;

        strncpy( im.FileName, lpModulePath, length );
        im.FileName[length] = '\0';

        im.hModule = pNTFrame->hModule;
        im.hTask   = pNTFrame->hTask;

        fResult = SendVDMEvent(DBG_TASKSTART);

        if (VdmDbgTraceFlags & VDMDBG_BREAK_WOWTASK) {
            DbgSetTemporaryBP(pNTFrame->wCS, pNTFrame->wIP, (BOOL)(getMSW() & MSW_PE));
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dbgdll\segment.c ===
/*
 *  segment.c - Segment functions of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop

void
SegmentLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Selector,
    WORD    Segment,
    BOOL    fData
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1 = Selector;
        se.Segment   = Segment+1;       // make it one-based
        se.Type      = fData ? SN_DATA : SN_CODE;

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGLOAD);
    }
}

void
SegmentMove(
    WORD    OldSelector,
    WORD    NewSelector
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1   = OldSelector;
        se.Selector2   = NewSelector;

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGMOVE);
    }
}

void
SegmentFree(
    WORD    Selector,
    BOOL    fBPRelease
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1   = Selector;
        se.Type        = (WORD)fBPRelease;

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGFREE);
    }
}

void
ModuleLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Segment,
    DWORD   Length
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1 = Segment;
        se.Length  = Length;

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_MODLOAD);
    }
}

void
ModuleSegmentMove(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    ModuleSegment,
    WORD    OldSelector,
    WORD    NewSelector,
    DWORD   Length
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Segment     = ModuleSegment;
        se.Selector1   = OldSelector;
        se.Selector2   = NewSelector;
        se.Type        = SN_V86;
        se.Length      = Length;

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGMOVE);
    }
}

void
ModuleFree(
    LPSTR   lpModuleName,
    LPSTR   lpPathName
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_MODFREE);
    }
}

void
xxxDbgSegmentNotice(
    WORD wType,
    WORD  wModuleSeg,
    WORD  wLoadSeg,
    WORD  wNewSeg,
    LPSTR lpModuleName,
    LPSTR lpModulePath,
    DWORD dwImageLen )

/* DbgSegmentNotice
 *
 * packs up the data and raises STATUS_SEGMENT_NOTIFICATION
 *
 * Entry - WORD  wType     - DBG_MODLOAD, DBG_MODFREE
 *         WORD  wModuleSeg- segment number within module (1 based)
 *         WORD  wLoadSeg  - Starting Segment (reloc factor)
 *         LPSTR lpName    - ptr to Name of Image
 *         DWORD dwModLen  - Length of module
 *
 *
 *         if wType ==DBG_MODLOAD wOldLoadSeg is unused
 *         if wType ==DBG_MODFREE wLoadSeg,dwImageLen,wOldLoadSeg are unused
 *
 *         Use 0 or NULL for unused parameters
 *
 * Exit  - void
 *
 */

{
    if (!fDebugged) {
         return;
         }

    if (wType == DBG_MODLOAD) {
        ModuleLoad(lpModuleName, lpModulePath, wLoadSeg, dwImageLen);
    } else if (wType == DBG_MODFREE) {
        ModuleFree(lpModuleName, lpModulePath);
    } else if (wType == DBG_SEGMOVE) {
        ModuleSegmentMove(lpModuleName, lpModulePath, wModuleSeg, wLoadSeg, wNewSeg, dwImageLen);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmd.c ===
/*
 *  cmd.c - Main Module of Command.lib
 *
 *  Sudeepb 09-Apr-1991 Craeted
 */

#include "cmd.h"
#include "cmdsvc.h"


/* CmdInit - COmmand Initialiazation routine.
 *
 * Entry
 *	argc,argv - from softpc as it is.
 *		    Full path name of the dos binary is preceded with
 *		    -a or /a. i.e. -a c:\nt\bin86\kernel.exe reversi.exe
 *
 *
 * Exit
 *
 */

BOOL CMDInit (argc,argv)
INT	argc;
PSZ	*argv;
{
CHAR  RootDir [MAX_PATH];
UINT  Len;

    Len = GetSystemDirectory (RootDir,MAX_PATH);
    if (Len <= MAX_PATH && Len > 0)
	cmdHomeDirectory[0] = RootDir[0];
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdconf.c ===
/*  cmdconf.c - handles pre-processing of config.sys\autoexec.bat
 *
 *  Modification History:
 *
 *  21-Nov-1992 Jonle , Created
 */

#include "cmd.h"
#include <cmdsvc.h>
#include <demexp.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <oemuni.h>

#if defined(NEC_98)
// Global stuff
UINT saveCP;
UINT saveOutputCP;
#endif // NEC_98
//
// local stuff
//
CHAR *pchTmpConfigFile;
CHAR *pchTmpAutoexecFile;
CHAR achSYSROOT[] = "%SystemRoot%";
CHAR achCOMMAND[] = "\\System32\\command.com";
CHAR achSHELL[]   = "shell";
CHAR achCOUNTRY[] = "country";
CHAR achREM[]     = "rem";
CHAR achENV[]     = "/e:";
CHAR achEOL[]     = "\r\n";
CHAR achSET[]     = "SET";
CHAR achPROMPT[]  = "PROMPT";
CHAR achPATH[]    = "PATH";
#ifdef JAPAN
// device=...\$disp.sys /hs=%HardwareScroll%
CHAR  achHARDWARESCROLL[] = "%HardwareScroll%";
DWORD dwLenHardwareScroll;
CHAR  achHardwareScroll[64];
#endif // JAPAN
#if defined(KOREA)
// device=...\hbios.sys /k:#
CHAR  achHBIOS[] = "hbios.sys";
CHAR  achFontSys[] = "font_win.sys";
CHAR  achDispSys[] = "disp_win.sys";
DWORD dwLenHotkeyOption;
CHAR  achHotkeyOption[80];
BOOLEAN fKoreanCP;

#define KOREAN_WANSUNG_CP 949
#endif // KOREA

DWORD dwLenSysRoot;
CHAR  achSysRoot[64];



void  ExpandConfigFiles(BOOLEAN bConfig);
DWORD WriteExpanded(HANDLE hFile,  CHAR *pch, DWORD dwBytes);
void  WriteFileAssert(HANDLE hFile, CHAR *pBuff, DWORD dwBytes);
#define ISEOL(ch) ( !(ch) || ((ch) == '\n') || ((ch) == '\r'))
#ifdef JAPAN
DWORD GetHardwareScroll( PCHAR achHardwareScroll, int size );
#endif // JAPAN
#if defined(KOREA)
DWORD GetHotkeyOption( PCHAR achHotkeyOption, UINT size );
#endif // KOREA


/** There are still many items we don't supprot for long path name
     (1). device, install in config.sys
     (2). Third-party shell
     (3). lh, loadhigh and any other commands in autoexec.bat

**/

/* cmdGetConfigSys - Creates a temp file to replace c:\config.sys
 *
 *  Entry - Client (DS:DX)  pointer to receive file name
 *
 *  EXIT  - This routine will Terminate the vdm if it fails
 *          And will not return
 *
 *  The buffer to receive the file name must be at least 64 bytes
 */
VOID cmdGetConfigSys (VOID)
{
     UNICODE_STRING Unicode;
     OEM_STRING     OemString;
     ANSI_STRING    AnsiString;

     ExpandConfigFiles(TRUE);

     RtlInitAnsiString(&AnsiString, pchTmpConfigFile);
     if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&Unicode, &AnsiString, TRUE)) )
         goto ErrExit;

     OemString.Buffer = (char *)GetVDMAddr(getDS(),getDX());
     OemString.MaximumLength = 64;
     if ( !NT_SUCCESS(RtlUnicodeStringToOemString(&OemString,&Unicode,FALSE)) )
         goto ErrExit;

     RtlFreeUnicodeString(&Unicode);
     return;

ErrExit:
     RcErrorDialogBox(ED_INITMEMERR, pchTmpConfigFile, NULL);
     TerminateVDM();
}



/* cmdGetAutoexecBat - Creates a temp file to replace c:\autoexec.bat
 *
 *  Entry - Client  (DS:DX)  pointer to receive file name
 *
 *  EXIT  - This routine will Terminate the vdm if it fails
 *          And will not return
 *
 *
 *  The buffer to receive the file name must be at least 64 bytes
 */
VOID cmdGetAutoexecBat (VOID)
{
     UNICODE_STRING Unicode;
     OEM_STRING     OemString;
     ANSI_STRING    AnsiString;

     ExpandConfigFiles(FALSE);

#if defined(JAPAN) || defined(KOREA)
    // fixed: change code page problem
#if defined(NEC_98) 
    { 
        if (!VDMForWOW) { // BugFix: Change IME status by Screen Saver of 16bit
            saveCP = GetConsoleCP();
            saveOutputCP = GetConsoleOutputCP();
            SetConsoleCP( 932 ); 
            SetConsoleOutputCP( 932 ); 
        }
    } 
#else // !NEC_98

    {
        extern int BOPFromDispFlag;

        if ( !VDMForWOW && !BOPFromDispFlag ) { // mskkbug#2756 10/15/93 yasuho
            SetConsoleCP( 437 );
            SetConsoleOutputCP( 437 );
        }
    }
#endif // !NEC_98
#endif // JAPAN || KOREA
     RtlInitAnsiString(&AnsiString, pchTmpAutoexecFile);
     if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,TRUE)) )
         goto ErrExit;

     OemString.Buffer = (char *)GetVDMAddr(getDS(),getDX());
     OemString.MaximumLength = 64;
     if (!NT_SUCCESS(RtlUnicodeStringToOemString(&OemString,&Unicode,FALSE)) )
         goto ErrExit;

     RtlFreeUnicodeString(&Unicode);

     return;

ErrExit:
     RcErrorDialogBox(ED_INITMEMERR, pchTmpConfigFile, NULL);
     TerminateVDM();  // skip cleanup since I insist that we exit!
}



/*
 *  DeleteConfigFiles - Deletes the temporray config files created
 *                      by cmdGetAutoexecBat and cmdGetConfigSys
 */
VOID DeleteConfigFiles(VOID)
{
    if (pchTmpConfigFile)  {
#if DBG
      if (!(fShowSVCMsg & KEEPBOOTFILES))
#endif
        DeleteFile(pchTmpConfigFile);

        free(pchTmpConfigFile);
        pchTmpConfigFile = NULL;
        }

    if (pchTmpAutoexecFile) {
#if DBG
      if (!(fShowSVCMsg & KEEPBOOTFILES))
#endif
        DeleteFile(pchTmpAutoexecFile);

        free(pchTmpAutoexecFile);
        pchTmpAutoexecFile = NULL;
        }

    return;
}



// if it is a config command
//    returns pointer to character immediatly following the equal sign
// else
//    returns NULL

PCHAR IsConfigCommand(PCHAR pConfigCommand, int CmdLen, PCHAR pLine)
{
      PCHAR pch;

      if (!_strnicmp(pLine, pConfigCommand, CmdLen)) {
           pch = pLine + CmdLen;
           while (!isgraph(*pch) && !ISEOL(*pch))      // skip to "="
                  pch++;

           if (*pch++ == '=') {
               return pch;
               }
           }

       return NULL;
}

#if defined(KOREA)
// if it is a HBIOS related config command
//    returns TRUE
// else
//    returns FALSE

BOOLEAN IsHBIOSConfig(PCHAR pCommand, int CmdLen, PCHAR pLine)
{
  CHAR  *pch = pLine;
  CHAR  achDevice[] = "Device";
  CHAR  achRem[] = "REM";

  while (*pch && !ISEOL(*pch)) {
        if (!_strnicmp(pch, achRem, sizeof(achRem)-sizeof(CHAR)))
            return (FALSE);

        if (!_strnicmp(pch, achDevice, sizeof(achDevice)-sizeof(CHAR))) {
            while (*pch && !ISEOL(*pch)) {
                  if (!_strnicmp(pch, pCommand, CmdLen))
                     return (TRUE);
                  pch++;
            }
        }
        pch++;
  }
  return (FALSE);

}
#endif





/*
 *  Preprocesses the specfied config file (config.sys\autoexec.bat)
 *  into a temporary file.
 *
 *  - expands %SystemRoot%
#ifdef JAPAN
 *  - expands %HardwareScroll%
#endif // JAPAN
#if defined(KOREA)
 *  - expands HotkeyOption
#endif // KOREA
*  - adds SHELL line for config.sys
 *
 *  entry: BOOLEAN bConfig : TRUE  - config.sys
 *                           FALSE - autoexec.bat
 */
void ExpandConfigFiles(BOOLEAN bConfig)
{
   DWORD  dw, dwRawFileSize;

   HANDLE hRawFile;
   HANDLE hTmpFile;
   CHAR **ppTmpFile;
   CHAR *pRawBuffer;
   CHAR *pLine;
   CHAR *pTmp;
   CHAR *pEnvParam= NULL;
   CHAR *pPartyShell=NULL;
   CHAR achRawFile[MAX_PATH+12];
   CHAR *lpszzEnv, *lpszName;
   int  cchEnv;

#ifdef JAPAN
   dwLenHardwareScroll = GetHardwareScroll( achHardwareScroll, sizeof(achHardwareScroll) );
#endif // JAPAN
#if defined(KOREA)
   // HBIOS.SYS is only support WanSung Codepage.
   fKoreanCP = (GetConsoleCP() ==  KOREAN_WANSUNG_CP) ? TRUE : FALSE;
   dwLenHotkeyOption = GetHotkeyOption( achHotkeyOption, sizeof(achHotkeyOption) );
#endif // KOREA
   dw = GetSystemWindowsDirectory(achRawFile, sizeof(achRawFile));
   dwLenSysRoot = GetShortPathNameA(achRawFile, achSysRoot, sizeof(achSysRoot));
   if (dwLenSysRoot >= sizeof(achSysRoot)) {
        dwLenSysRoot = 0;
        achSysRoot[0] = '\0';
        }
#ifdef DBCS
   GetPIFConfigFiles(bConfig, achRawFile, FALSE);
#else // !DBCS
   GetPIFConfigFiles(bConfig, achRawFile);
#endif // !DBCS
   ppTmpFile = bConfig ? &pchTmpConfigFile : &pchTmpAutoexecFile;

   hRawFile = CreateFile(achRawFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

   if (hRawFile == (HANDLE)0xFFFFFFFF
       || !dwLenSysRoot
       || dwLenSysRoot >= sizeof(achSysRoot)
       || !(dwRawFileSize = GetFileSize(hRawFile, NULL))
       || dwRawFileSize == 0xFFFFFFFF   )
      {
       RcErrorDialogBox(ED_BADSYSFILE, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }

   pRawBuffer = malloc(dwRawFileSize+1);
   // allocate buffer to save environment settings in autoexec.nt
   // I know this is bad to allocate this amount of memory at this
   // moment as we dont know if there are anything we want to keep
   // at all. This allocation simply provides the following error
   // handling easily.
   if(!bConfig) {
        lpszzEnv = lpszzcmdEnv16 = (PCHAR)malloc(dwRawFileSize);
        cchEnv = 0;
   }
   if (!pRawBuffer || (!bConfig && lpszzcmdEnv16 == NULL)) {
       RcErrorDialogBox(ED_INITMEMERR, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }

   if (!cmdCreateTempFile(&hTmpFile,ppTmpFile)
       || !ReadFile(hRawFile, pRawBuffer, dwRawFileSize, &dw, NULL)
       || dw != dwRawFileSize )
      {
       GetTempPath(MAX_PATH, achRawFile);
       achRawFile[63] = '\0';
       RcErrorDialogBox(ED_INITTMPFILE, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }
    // CHANGE HERE WHEN YOU CHANGE cmdCreateTempFile !!!!!!!!!!
    // we depend on the buffer size allocated for the file name
    dw = GetShortPathNameA(*ppTmpFile, *ppTmpFile, MAX_PATH +13);
    if (dw == 0 || dw > 63)
      {
       GetTempPath(MAX_PATH, achRawFile);
       achRawFile[63] = '\0';
       RcErrorDialogBox(ED_INITTMPFILE, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }


      // null terminate the buffer so we can use CRT string functions
    *(pRawBuffer+dwRawFileSize) = '\0';

      // ensure no trailing backslash in System Directory
    if (*(achSysRoot+dwLenSysRoot-1) == '\\') {
        *(achSysRoot + --dwLenSysRoot) = '\0';
        }

    pLine = pRawBuffer;
    while (dwRawFileSize) {
               // skip leading white space
       while (dwRawFileSize && !isgraph(*pLine)) {
            pLine++;
            dwRawFileSize -= sizeof(CHAR);
            }
       if (!dwRawFileSize)  // anything left to do ?
           break;


       if (bConfig)  {
           //
           // filter out country= setting we will create our own based
           // on current country ID and codepage.
           //
           pTmp = IsConfigCommand(achCOUNTRY, sizeof(achCOUNTRY) - sizeof(CHAR), pLine);
           if (pTmp) {
               while (dwRawFileSize && !ISEOL(*pLine)) {
                      pLine++;
                      dwRawFileSize -= sizeof(CHAR);
                      }
               continue;
               }

           // filter out shell= command, saving /E:nn parameter
           pTmp = IsConfigCommand(achSHELL, sizeof(achSHELL) - sizeof(CHAR),pLine);
           if (pTmp) {
                       // skip leading white space
               while (!isgraph(*pTmp) && !ISEOL(*pTmp)) {
                      dwRawFileSize -= sizeof(CHAR);
                      pTmp++;
                      }

                  /*  if for a third party shell (not SCS command.com)
                   *     append the whole thing thru /c parameter
                   *  else
                   *     append user specifed /e: parameter
                   */
               if (!_strnicmp(achSYSROOT,pTmp,sizeof(achSYSROOT)-sizeof(CHAR)))
                  {
                   dw = sizeof(achSYSROOT) - sizeof(CHAR);
                   }
               else if (!_strnicmp(achSysRoot,pTmp, strlen(achSysRoot)))
                  {
                   dw = strlen(achSysRoot);
                   }
               else  {
                   dw = 0;
                   }

               if (!dw ||
                   _strnicmp(achCOMMAND,pTmp+dw,sizeof(achCOMMAND)-sizeof(CHAR)) )
                  {
                   pPartyShell = pTmp;
                   }
               else {
                   do {
                      while (*pTmp != '/' && !ISEOL(*pTmp))  // save "/e:"
                             pTmp++;

                      if(ISEOL(*pTmp))
                          break;

                      if (!_strnicmp(pTmp,achENV,sizeof(achENV)-sizeof(CHAR)))
                          pEnvParam = pTmp;

                      pTmp++;

                      } while(1);        // was: while (!ISEOL(*pTmp));
                                         // we have break form this loop now,
                                         // and don't need in additional macro..

                   }

                       // skip the "shell=" line
               while (dwRawFileSize && !ISEOL(*pLine)) {
                      pLine++;
                      dwRawFileSize -= sizeof(CHAR);
                      }
               continue;

               }  // END, really is "shell=" line!
           }

#if defined(KOREA)

           // If current Code page is 437(US), system won't load HBIOS related modules.

           if (!fKoreanCP) {
               if (IsHBIOSConfig(achFontSys, sizeof(achFontSys)-sizeof(CHAR), pLine)) {
                    while (dwRawFileSize && !ISEOL(*pLine)) {
                           pLine++;
                           dwRawFileSize -= sizeof(CHAR);
                    }
                    continue;
               }
               if (IsHBIOSConfig(achHBIOS, sizeof(achHBIOS)-sizeof(CHAR), pLine)) {
                    while (dwRawFileSize && !ISEOL(*pLine)) {
                           pLine++;
                           dwRawFileSize -= sizeof(CHAR);
                    }
                    continue;
               }
               if (IsHBIOSConfig(achDispSys, sizeof(achDispSys)-sizeof(CHAR), pLine)) {
                    while (dwRawFileSize && !ISEOL(*pLine)) {
                           pLine++;
                           dwRawFileSize -= sizeof(CHAR);
                    }
                    continue;
               }
           }
#endif // KOREA

       /** Filter out PROMPT, SET and PATH from autoexec.nt
           for environment merging. The output we prepare here is
           a multiple strings buffer which has the format as :
           "EnvName_1 NULL EnvValue_1 NULL[EnvName_n NULL EnvValue_n NULL] NULL
           We don't take them out from the file because command.com needs
           them.
        **/
       if (!bConfig)
            if (!_strnicmp(pLine, achPROMPT, sizeof(achPROMPT) - 1)){
                // prompt command found.
                // the syntax of prompt can be eithe
                // prompt xxyyzz        or
                // prompt=xxyyzz
                //
                strcpy(lpszzEnv, achPROMPT);    // get the name
                lpszzEnv += sizeof(achPROMPT);
                cchEnv += sizeof(achPROMPT);
                pTmp = pLine + sizeof(achPROMPT) - 1;
                // skip possible white chars
                while (!isgraph(*pTmp) && !ISEOL(*pTmp))
                pTmp++;
                if (*pTmp == '=') {
                    pTmp++;
                    while(!isgraph(*pTmp) && !ISEOL(*pTmp))
                        pTmp++;
                }
                while(!ISEOL(*pTmp)){
                    *lpszzEnv++ = *pTmp++;
                    cchEnv++;
                }
                // null terminate this
                // it may be "prompt NULL NULL" for delete
                // or "prompt NULL something NULL"
                *lpszzEnv++ = '\0';
                cchEnv++;
            }
            else if (!_strnicmp(pLine, achPATH, sizeof(achPATH) - 1)) {
                    // PATH was found, it has the same syntax as
                    // PROMPT
                    strcpy(lpszzEnv, achPATH);
                    lpszzEnv += sizeof(achPATH);
                    cchEnv += sizeof(achPATH);
                    pTmp = pLine + sizeof(achPATH) - 1;
                    while (!isgraph(*pTmp) && !ISEOL(*pTmp))
                        pTmp++;
                    if (*pTmp == '=') {
                        pTmp++;
                        while(!isgraph(*pTmp) && !ISEOL(*pTmp))
                            pTmp++;
                    }
                    while(!ISEOL(*pTmp)) {
                        *lpszzEnv++ = *pTmp++;
                        cchEnv++;
                    }
                    *lpszzEnv++ = '\0';
                    cchEnv++;
                 }
                 else if(!_strnicmp(pLine, achSET, sizeof(achSET) -1 )) {
                        // SET was found, first search for name
                        pTmp = pLine + sizeof(achSET) - 1;
                        while(!isgraph(*pTmp) && !ISEOL(*pTmp))
                            *pTmp ++;
                        // get the name
                        lpszName = pTmp;
                        // looking for the '='
                        // note that the name can have white characters
                        while (!ISEOL(*lpszName) && *lpszName != '=')
                            lpszName++;
                        if (!ISEOL(*lpszName)) {
                            // copy the name
                            while (pTmp < lpszName) {
                                *lpszzEnv++ = *pTmp++;
                                cchEnv++;
                            }
                            *lpszzEnv++ = '\0';
                            cchEnv++;
                            // discard the '='
                            pTmp++;
                            // grab the value(may be nothing
                            while (!ISEOL(*pTmp)) {
                                *lpszzEnv++ = *pTmp++;
                                cchEnv++;
                            }
                            *lpszzEnv++ = '\0';
                            cchEnv++;
                        }
                      }


       dw = WriteExpanded(hTmpFile, pLine, dwRawFileSize);
       pLine += dw;
       dwRawFileSize -=dw;

       WriteFileAssert(hTmpFile,achEOL,sizeof(achEOL) - sizeof(CHAR));

       }  // END, while (dwRawFileSize)



    if (bConfig)  {
        UINT OemCP;
#if defined(JAPAN) || defined(KOREA)
        UINT ConsoleCP;
#endif // JAPAN || KOREA
        UINT CtryId;
        CHAR szCtryId[64]; // expect "nnn" only

         /*  Ensure that the country settings are in sync with NT This is
          *  especially important for DosKrnl file UPCASE tables. The
          *  doskrnl default is "CTRY_UNITED_STATES, 437". But we add the
          *  country= line to config.sys, even if is US,437, so that the DOS
          *  will know where the default country.sys is.
          */
        if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTCOUNTRY,
                          szCtryId, sizeof(szCtryId) - 1) )
          {
           CtryId = strtoul(szCtryId,NULL,10);
           }
        else {
           CtryId = CTRY_UNITED_STATES;
           }

        OemCP = GetOEMCP();
#if defined(JAPAN) || defined(KOREA)
        ConsoleCP = GetConsoleOutputCP();
        if (OemCP != ConsoleCP)
            OemCP = ConsoleCP;
#endif // JAPAN || KOREA

        sprintf(achRawFile,
                "%s=%3.3u,%3.3u,%s\\system32\\%s.sys%s",
                achCOUNTRY, CtryId, OemCP, achSysRoot, achCOUNTRY, achEOL);
        WriteFileAssert(hTmpFile,achRawFile,strlen(achRawFile));



         /*  We cannot allow the user to set an incorrect shell= command
          *  so we will contruct the correct shell= command appending
          *  either (in order of precedence):
          *    1.    /c ThirdPartyShell
          *    2.    /e:NNNN
          *    3.    nothing
          *
          *  If there is a third party shell then we must turn the console
          *  on now since we no longer have control once system32\command.com
          *  spawns the third party shell.
          */

           // write shell=....
        sprintf(achRawFile,
                "%s=%s%s /p %s\\system32",
                achSHELL,achSysRoot, achCOMMAND, achSysRoot);
        WriteFileAssert(hTmpFile,achRawFile,strlen(achRawFile));

           // write extra string (/c ... or /e:nnn)
        if (pPartyShell && isgraph(*pPartyShell)) {
            pTmp = pPartyShell;
            while (!ISEOL(*pTmp))
                   pTmp++;
            }
        else if (pEnvParam && isgraph(*pEnvParam))  {
            pTmp = pEnvParam;
            while (isgraph(*pTmp))
                  pTmp++;
            }
        else {
            pTmp = NULL;
            }

        if (pTmp) {
            *pTmp = '\0';
            if (pPartyShell)  {
                cmdInitConsole();
                strcpy(achRawFile, " /c ");
                strcat(achRawFile, pPartyShell);
                }
            else if (pEnvParam) {
                strcpy(achRawFile, " ");
                strcat(achRawFile, pEnvParam);
                }

            WriteExpanded(hTmpFile, achRawFile, strlen(achRawFile));
            }

        WriteFileAssert(hTmpFile,achEOL,sizeof(achEOL) - sizeof(CHAR));
        }

    SetEndOfFile(hTmpFile);
    CloseHandle(hTmpFile);
    CloseHandle(hRawFile);
    free(pRawBuffer);
    if (!bConfig) {
        // shrink(or free) the memory
        if (cchEnv && lpszzcmdEnv16) {
            // doubld null terminate it
            lpszzcmdEnv16[cchEnv++] = '\0';
            // shrink the memory. If it fails, simple keep
            // it as is
            lpszzEnv = realloc(lpszzcmdEnv16, cchEnv);
            if (lpszzEnv != NULL)
                lpszzcmdEnv16 = lpszzEnv;
        }
        else {
            free(lpszzcmdEnv16);
            lpszzcmdEnv16 = NULL;
        }
    }

}




/*
 *  WriteExpanded - writes up to dwChars or EOL, expanding %SystemRoot%
 *                  returns number of CHARs processed in buffer
 *                          (not number of bytes actually written)
 */
DWORD WriteExpanded(HANDLE hFile,  CHAR *pch, DWORD dwChars)
{
  DWORD dw;
  DWORD dwSave = dwChars;
  CHAR  *pSave = pch;


  while (dwChars && !ISEOL(*pch)) {
        if (*pch == '%' &&
            !_strnicmp(pch, achSYSROOT, sizeof(achSYSROOT)-sizeof(CHAR)) )
           {
            dw = pch - pSave;
            if (dw)  {
                WriteFileAssert(hFile, pSave, dw);
                }

            WriteFileAssert(hFile, achSysRoot, dwLenSysRoot);

            pch     += sizeof(achSYSROOT)-sizeof(CHAR);
            pSave    = pch;
            dwChars -= sizeof(achSYSROOT)-sizeof(CHAR);
            }
#ifdef JAPAN
        // device=...\$disp.sys /hs=%HardwareScroll%
        else if (*pch == '%' &&
            !_strnicmp(pch, achHARDWARESCROLL, sizeof(achHARDWARESCROLL)-sizeof(CHAR)) )
           {
            dw = pch - pSave;
            if (dw)  {
                WriteFileAssert(hFile, pSave, dw);
                }

            WriteFileAssert(hFile, achHardwareScroll, dwLenHardwareScroll);

            pch     += sizeof(achHARDWARESCROLL)-sizeof(CHAR);
            pSave    = pch;
            dwChars -= sizeof(achHARDWARESCROLL)-sizeof(CHAR);
            }
#endif // JAPAN
#if defined(KOREA) // looking for hbios.sys
        else if (fKoreanCP && *pch  == 'h' &&
            !_strnicmp(pch, achHBIOS, sizeof(achHBIOS)-sizeof(CHAR)) )
           {
            dw = pch - pSave;
            if (dw)  {
                WriteFileAssert(hFile, pSave, dw);
                }

            WriteFileAssert(hFile, achHotkeyOption, dwLenHotkeyOption);

            pch     += sizeof(achHBIOS)-sizeof(CHAR);
            pSave    = pch;
            dwChars -= sizeof(achHBIOS)-sizeof(CHAR);
        }
#endif // KOREA
        else {
            pch++;
            dwChars -= sizeof(CHAR);
            }
        }

  dw = pch - pSave;
  if (dw) {
      WriteFileAssert(hFile, pSave, dw);
      }

  return (dwSave - dwChars);
}




/*
 *  WriteFileAssert
 *
 *  Cecks for error in wrtiting the temp boot file,
 *  If one occurs displays warning popup and terminates the vdm.
 *
 */
void WriteFileAssert(HANDLE hFile, CHAR *pBuff, DWORD dwBytes)
{
  DWORD dw;
  CHAR  ach[MAX_PATH];

  if (!WriteFile(hFile, pBuff, dwBytes, &dw, NULL) ||
       dw  != dwBytes)
     {

      GetTempPath(MAX_PATH, ach);
      ach[63] = '\0';
      RcErrorDialogBox(ED_INITTMPFILE, ach, NULL);
      TerminateVDM();  // skip cleanup since I insist that we exit!
      }
}
#ifdef JAPAN
//
// MSKK 8/26/1993 V-KazuyS
// Get HardwareScroll type from registry
// this parameter also use console.
//
DWORD GetHardwareScroll( PCHAR achHardwareScroll, int size )
{
    HKEY  hKey;
    DWORD dwType;
    DWORD retCode;
    CHAR  szBuf[256];
    DWORD cbData=256L;
    DWORD num;
    PCHAR psz;

// Get HardwareScroll type ( ON, LC or OFF ) from REGISTRY file.

  // OPEN THE KEY.

    retCode = RegOpenKeyEx (
                      HKEY_LOCAL_MACHINE,         // Key handle at root level.
                      "HARDWARE\\DEVICEMAP\\VIDEO", // Path name of child key.
                      0,                            // Reserved.
                      KEY_EXECUTE,                  // Requesting read access.
                      &hKey );               // Address of key to be returned.

// If retCode != 0 then we cannot find section in Register file
    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegOpenKeyEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    dwType = REG_SZ;

// Query for line from REGISTER file
    retCode = RegQueryValueEx(  hKey,
                                "\\Device\\Video0",
                                NULL,
                                &dwType,
                                szBuf,
                                &cbData);

    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegQueryValueEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    RegCloseKey(hKey);

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Get \\Device\\Video0=[%s]\n", szBuf );
#endif
    psz = strchr( (szBuf+1), '\\' ); // skip \\REGISTRY\\   *
#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: skip \\registry\\ [%s]\n", psz );
#endif
    if ( psz != NULL )
        psz = strchr( (psz+1), '\\' ); // skip Machine\\    *

    if ( psz == NULL ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: Illegal value[%s]h\n", szBuf );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    psz++;

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Open 2nd Key=[%s]\n", psz );
#endif

    retCode = RegOpenKeyEx (
                      HKEY_LOCAL_MACHINE,         // Key handle at root level.
                      psz,                      // Path name of child key.
                      0,                            // Reserved.
                      KEY_EXECUTE,                  // Requesting read access.
                      &hKey );               // Address of key to be returned.

// If retCode != 0 then we cannot find section in Register file
    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegOpenKeyEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    dwType = REG_SZ;

// Query for line from REGISTER file
    retCode = RegQueryValueEx(  hKey,
                                "ConsoleFullScreen.HardwareScroll",
                                NULL,
                                &dwType,
                                szBuf,
                                &cbData);

    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegQueryValueEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    RegCloseKey(hKey);

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Get FullScreenHardwareScroll=[%s]\n", szBuf );
#endif

    num = ( lstrlen(szBuf)+1 > size ) ? size : lstrlen(szBuf)+1;
    RtlCopyMemory( achHardwareScroll, szBuf, num );
    achHardwareScroll[num] = '\0';

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Set %HardwareScroll%=[%s]\n", achHardwareScroll );
#endif

    return num;
}
#endif // JAPAN

#if defined(KOREA)
/*
 * 8/05/1996 bklee
 * Get keyboard layout from system and set hotkey option for hbios.sys
 * Here are hotkey options for HBIOS.SYS.
 *
 *      Keyboard Type    Hangul          Hanja
 * 1        101a         r + alt         r + ctrl     : default
 * 2        101b         r + ctrl        r + alt
 * 3        103          Hangul          Hanja
 * 4        84           alt + shift     ctrl + shift
 * 5        86           Hangul          Hanja
 * 6        101c         l shift + space l ctrl + space
 * 7        64                                        : N/A. map to default
 */

DWORD GetHotkeyOption( PCHAR achHotkeyOption, UINT size )
{
      // GetKeyboardType(1) return 1 to 6 as sub-keyboard type.
      // No 7 sub-keyboard type will be returned.
      UINT HotkeyIndex[6] = { 4, 5, 1, 2, 6, 3 };
      UINT SubKeyType, HotkeyOption;

      if ( GetKeyboardType(0) == 8 )  { // KOREAN Keyboard layout

           SubKeyType = GetKeyboardType(1);

           if ( SubKeyType > 0 && SubKeyType < 7 )
                HotkeyOption = HotkeyIndex[SubKeyType - 1];
           else
                HotkeyOption = 1; // Set to default.

           wsprintf(achHotkeyOption, "hbios.sys /K:%d", HotkeyOption);
      }
      else
           strcpy(achHotkeyOption, "hbios.sys");
      return(strlen(achHotkeyOption));
}
#endif // KOREA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmddata.c ===
/*  cmddata.c - Misc. SCS global data
 *
 *
 *  Modification History:
 *
 *  Sudeepb 22-Apr-1992 Created
 */

#include "cmd.h"
#include <mvdm.h>

CHAR	 lpszComSpec[64+8];
USHORT	 cbComSpec=0;
BOOL	 IsFirstCall = TRUE;
BOOL	 IsRepeatCall = FALSE;
BOOL	 IsFirstWOWCheckBinary = TRUE;
BOOL	 IsFirstVDMInSystem = FALSE;
BOOL	 SaveWorldCreated;
PCHAR	 pSCS_ToSync;
PSCSINFO pSCSInfo;
BOOL	 fBlock = FALSE;
PCHAR	 pCommand32;
PCHAR	 pEnv32;
DWORD	 dwExitCode32;
CHAR     cmdHomeDirectory [] = "C:\\";
CHAR	 chDefaultDrive;
CHAR	 comspec[]="COMSPEC=";
BOOL     fSoftpcRedirection;
BOOL     fSoftpcRedirectionOnShellOut;
CHAR     ShortCutInfo[MAX_SHORTCUT_SIZE];
BOOL	 DosEnvCreated = FALSE;

BOOL	 IsFirstVDM = TRUE;
// FORCEDOS.EXE supported
BOOL	 DontCheckDosBinaryType = FALSE;
WORD	 Exe32ActiveCount = 0;



// Redirection Support variables

VDMINFO  VDMInfo;
CHAR	 *lpszzInitEnvironment = NULL;
WORD	 cchInitEnvironment = 0;
CHAR	 *lpszzCurrentDirectories = NULL;
DWORD	 cchCurrentDirectories = 0;
BYTE	 * pIsDosBinary;
CHAR	 *lpszzcmdEnv16 = NULL;
CHAR	 *lpszzVDMEnv32 = NULL;
DWORD	 cchVDMEnv32;
VDMENVBLK cmdVDMEnvBlk;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmd.h ===
/* cmd.h - main include file for command.lib
 *
 * Modification History
 *
 * Sudeepb 17-Sep-1991 Created
 */

/*
#define WIN
#define FLAT_32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>

*/

#ifdef DOS
#define SIGNALS
#endif

#ifdef OS2_16
#define OS2
#define SIGNALS
#endif

#ifdef OS2_32
#define OS2
#define FLAT_32
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <process.h>

#ifdef WIN_16
#define WIN
#define API16
#endif

#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#else
#define TRUE_IF_WIN32   0
#endif

#ifdef FLAT_32
#ifndef i386
#define ALIGN_32
#else
#define NOALIGN_32
#endif
#endif

#ifdef WIN
#define _WINDOWS
#include <windows.h>
#endif

#ifdef SIGNALS
#include <conio.h>
#include <signal.h>
#endif

#ifdef OS2_32
#include <excpt.h>
#define XCPT_SIGNAL     0xC0010003
#endif

#include <vdmapi.h>

#define COPY_STD_OUT 1
#define COPY_STD_ERR 2

#define CLOSE_ALL_HANDLES   1
#define CLOSE_STD_OUT       2
#define CLOSE_STD_ERR       4

#define DEFAULT_REDIRECTION_SIZE 1024
#define MAX_SHORTCUT_SIZE        128
#define STDIN_BUF_SIZE           512

/** Command Macros **/

/** Command Basic Typedefs **/

typedef VOID (*PFNSVC)(VOID);

#pragma pack(1)

typedef struct _PARAMBLOCK {
    USHORT  SegEnv;
    USHORT  OffCmdTail;
    USHORT  SegCmdTail;
    ULONG   pFCB1;
    ULONG   pFCB2;
} PARAMBLOCK,*PPARAMBLOCK;

typedef struct _SCSINFO {
    CHAR    SCS_ComSpec [64];
    CHAR    SCS_CmdTail [128];
    PARAMBLOCK SCS_ParamBlock;
    CHAR    SCS_ToSync;
} SCSINFO, *PSCSINFO;

typedef struct _STD_HANDLES {
    ULONG   hStdErr;
    ULONG   hStdOut;
    ULONG   hStdIn;
} STD_HANDLES, *PSTD_HANDLES;

#define PIPE_INPUT_BUFFER_SIZE  512
#define PIPE_OUTPUT_BUFFER_SIZE PIPE_INPUT_BUFFER_SIZE
#define PIPE_INPUT_TIMEOUT              55
#define PIPE_OUTPUT_TIMEOUT     PIPE_INPUT_TIMEOUT

typedef struct  _PIPE_INPUT{
    struct _PIPE_INPUT  *Next;
    HANDLE              hFileRead;
    HANDLE              hFileWrite;
    HANDLE              hPipe;
    HANDLE              hDataEvent;
    HANDLE              hThread;
    CHAR                *pFileName;
    DWORD               BufferSize;
    BOOL                fEOF;
    BOOL                WaitData;
    BYTE                *Buffer;
    CRITICAL_SECTION    CriticalSection;
} PIPE_INPUT, *PPIPE_INPUT;

typedef struct  _PIPE_OUTPUT {
    HANDLE              hFile;
    HANDLE              hPipe;
    HANDLE              hExitEvent;
    CHAR                *pFileName;
    DWORD               BufferSize;
    BYTE                *Buffer;
} PIPE_OUTPUT, *PPIPE_OUTPUT;

typedef struct _RedirComplete_Info {
    HANDLE  ri_hStdErr;
    HANDLE  ri_hStdOut;
    HANDLE  ri_hStdIn;
    HANDLE  ri_hStdErrFile;
    HANDLE  ri_hStdOutFile;
    HANDLE  ri_hStdInFile;
    HANDLE  ri_hStdOutThread;
    HANDLE  ri_hStdErrThread;
    PPIPE_INPUT ri_pPipeStdIn;
    PPIPE_OUTPUT ri_pPipeStdOut;
    PPIPE_OUTPUT ri_pPipeStdErr;

} REDIRCOMPLETE_INFO, *PREDIRCOMPLETE_INFO;

typedef struct  _VDMENVBLK {
    DWORD       cchEnv;
    DWORD       cchRemain;
    CHAR        *lpszzEnv;
} VDMENVBLK, *PVDMENVBLK;

#pragma pack()

/** Command Function Prototypes */


VOID   cmdComSpec                   (VOID);
VOID   cmdGetEnv                    (VOID);
VOID   cmdGetNextCmd                (VOID);
VOID   cmdGetNextCmdForSeparateWow  (VOID);
VOID   cmdGetStdHandle              (VOID);
VOID   cmdExec                      (VOID);
VOID   cmdExecComspec32             (VOID);
VOID   cmdExitVDM                   (VOID);
VOID   cmdReturnExitCode            (VOID);
VOID   cmdSaveWorld                 (VOID);
VOID   cmdSetInfo                   (VOID);
VOID   cmdGetCurrentDir             (VOID);
VOID   cmdSetDirectories            (PCHAR,VDMINFO *);
VOID   CheckDotExeForWOW            (LPSTR);
BOOL   cmdCheckCopyForRedirection   (PREDIRCOMPLETE_INFO, BOOL);
BOOL   cmdCreateTempFile            (PHANDLE,PCHAR *);
VOID   cmdCheckBinary               (VOID);
VOID   cmdInitConsole               (VOID);
VOID   nt_init_event_thread         (VOID);
VOID   cmdExec32                    (PCHAR,PCHAR);
VOID   cmdCreateProcess             (PSTD_HANDLES pStdHandles);
USHORT cmdMapCodePage               (ULONG);
VOID    cmdCheckForPIF              (PVDMINFO);
VOID   cmdGetConfigSys              (VOID);
VOID   cmdGetAutoexecBat            (VOID);
VOID   DeleteConfigFiles            (VOID);
VOID   cmdGetKbdLayout              (VOID);
BOOL   cmdXformEnvironment          (PCHAR, PANSI_STRING);
VOID   cmdGetInitEnvironment        (VOID);
VOID   cmdUpdateCurrentDirectories  (BYTE);
BOOL   cmdCreateVDMEnvironment      (PVDMENVBLK);
DWORD  cmdGetEnvironmentVariable    (PVDMENVBLK, PCHAR, PCHAR, DWORD);
BOOL   cmdSetEnvironmentVariable    (PVDMENVBLK, PCHAR, PCHAR);
DWORD  cmdExpandEnvironmentStrings  (PVDMENVBLK, PCHAR, PCHAR, DWORD);
PREDIRCOMPLETE_INFO  cmdCheckStandardHandles      (PVDMINFO,USHORT UNALIGNED *);
VOID   cmdGetStartInfo              (VOID);
BOOL   cmdHandleStdinWithPipe       (PREDIRCOMPLETE_INFO);
BOOL   cmdHandleStdOutErrWithPipe   (PREDIRCOMPLETE_INFO, USHORT);
LPSTR  cmdSkipOverPathName          (LPSTR);
BOOL   cmdPipeFileDataEOF           (HANDLE, BOOL *);
BOOL   cmdPipeFileEOF               (HANDLE);
VOID   cmdPipeInThread              (LPVOID);
VOID   cmdPipeOutThread             (LPVOID);
VOID   cmdSetWinTitle               (VOID);
BOOL   cmdIllegalFunc(VOID);
VOID   cmdGetCursorPos(VOID);

/** Command Externs **/

extern USHORT   nDrives;
extern BOOL     IsFirstVDMInSystem;
extern BOOL     VDMForWOW;
extern CHAR     lpszComSpec[];
extern USHORT   cbComSpec;
extern BOOL     IsFirstCall;
extern BOOL     IsRepeatCall;
extern BOOL     IsFirstWOWCheckBinary;
extern BOOL     IsFirstVDMInSystem;
extern BOOL     SaveWorldCreated;
extern PCHAR    pSCS_ToSync;
extern BOOL     fBlock;
extern PCHAR    pCommand32;
extern PCHAR    pEnv32;
extern DWORD    dwExitCode32;
extern PSCSINFO pSCSInfo;
extern HANDLE   hFileStdOut;
extern HANDLE   hFileStdOutDup;
extern HANDLE   hFileStdErr;
extern HANDLE   hFileStdErrDup;
extern VDMINFO  VDMInfo;
extern PSZ      pszFileStdOut;
extern PSZ      pszFileStdErr;
extern CHAR     cmdHomeDirectory[];
extern HANDLE   SCS_hStdIn;
extern HANDLE   SCS_hStdOut;
extern HANDLE   SCS_hStdErr;
extern CHAR     chDefaultDrive;
extern BOOL     DontCheckDosBinaryType;
extern WORD     Exe32ActiveCount;
extern BOOL     fSoftpcRedirection;
extern BOOL     fSoftpcRedirectionOnShellOut;
extern VOID     nt_std_handle_notification (BOOL);
extern VOID     cmdPushExitInConsoleBuffer (VOID);


// control handler state, defined in nt_event.h, nt_event.c
extern  ULONG CntrlHandlerState;
#define CNTRL_SHELLCOUNT         0x0FFFF  // The LOWORD is used for shell count
#define CNTRL_PIFALLOWCLOSE      0x10000
#define CNTRL_VDMBLOCKED         0x20000
#define CNTRL_SYSTEMROOTCONSOLE  0x40000
#define CNTRL_PUSHEXIT           0x80000


// Temporary variable till we standardized on wowexec
extern ULONG    iWOWTaskId;
extern CHAR     comspec[];
extern CHAR     ShortCutInfo[];

extern VOID     nt_pif_callout (LPVOID);
extern CHAR     *lpszzInitEnvironment;
extern WORD     cchInitEnvironment;
extern CHAR     *lpszzCurrentDirectories;
extern DWORD    cchCurrentDirectories;
extern BYTE     * pIsDosBinary;
extern WORD     * pFDAccess;
extern CHAR     *lpszzcmdEnv16;
extern BOOL     DosEnvCreated;
extern BOOL     IsFirstVDM;
extern VDMENVBLK cmdVDMEnvBlk;
extern CHAR     *lpszzVDMEnv32;
extern DWORD    cchVDMEnv32;
extern UINT     VdmExitCode;

// application path name extention type.
#define EXTENTION_STRING_LEN    4
#define BAT_EXTENTION_STRING    ".BAT"
#define EXE_EXTENTION_STRING    ".EXE"
#define COM_EXTENTION_STRING    ".COM"

#ifdef DBCS // MUST fix for FE NT
#define FIX_375051_NOW
#endif

#ifdef FIX_375051_NOW

#define WOW32_strupr(psz)    CharUpperA(psz)

#else

#define WOW32_strupr(psz)    _strupr(psz)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmddisp.c ===
/*
 *  cmddisp.c - SVC dispatch module of command
 *
 *  Modification History:
 *
 *  Sudeepb 17-Sep-1991 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>

//'cmdSetWinTitle' and 'cmdGetCursorPos' are not available in NON-DBCS builds. 
#ifndef DBCS
#define cmdSetWinTitle cmdIllegalFunc
#endif
#ifndef NEC_98
#define cmdGetCursorPos cmdIllegalFunc
#endif

PFNSVC	apfnSVCCmd [] = {
     cmdExitVDM,		//SVC_CMDEXITVDM
     cmdGetNextCmd,		//SVC_CMDGETNEXTCMD
     cmdComSpec,		//SVC_CMDCOMSPEC
     cmdSaveWorld,		//SVC_CMDSAVEWORLD
     cmdGetCurrentDir,		//SVC_CMDGETCURDIR
     cmdSetInfo,		//SVC_CMDSETINFO
     cmdGetStdHandle,		//SVC_GETSTDHANDLE
     cmdCheckBinary,		//SVC_CMDCHECKBINARY
     cmdExec,			//SVC_CMDEXEC
     cmdInitConsole,		//SVC_CMDINITCONSOLE
     cmdExecComspec32,		//SVC_EXECCOMSPEC32
     cmdReturnExitCode,         //SVC_RETURNEXITCODE
     cmdGetConfigSys,           //SVC_GETCONFIGSYS
     cmdGetAutoexecBat,		//SVC_GETAUTOEXECBAT
     cmdGetKbdLayout,		//SVC_GETKBDLAYOUT
     cmdGetInitEnvironment,     //SVC_GETINITENVIRONMENT
     cmdGetStartInfo,            //SVC_GETSTARTINFO
     cmdSetWinTitle,		//SVC_CHANGEWINTITLE
     cmdIllegalFunc,            // 18 
     cmdIllegalFunc,            // 19 
     cmdIllegalFunc,            // 20 
     cmdIllegalFunc,            // 21 
     cmdIllegalFunc,            // 22 
     cmdIllegalFunc,            // 23 
     cmdIllegalFunc,            // 24 
     cmdIllegalFunc,            // 25 
     cmdIllegalFunc,            // 26 
     cmdIllegalFunc,            // 27 
     cmdIllegalFunc,            // 28 
     cmdIllegalFunc,            // 29 
     cmdGetCursorPos            //SVC_GETCURSORPOS 
};


/* cmdDispatch - Dispatch SVC call to right command handler.
 *
 * Entry - iSvc (SVC byte following SVCop)
 *
 * Exit  - None
 *
 */

BOOL CmdDispatch (ULONG iSvc)
{
#if DBG
    if (iSvc >= SVC_CMDLASTSVC){
	DbgPrint("Unimplemented SVC index for COMMAND %x\n",iSvc);
	setCF(1);
	return FALSE;
    }
#endif
    (apfnSVCCmd [iSvc])();

    return TRUE;
}


BOOL cmdIllegalFunc ()                                 
{                                                                
#if DBG                                                       
    DbgPrint("Unimplemented SVC index for COMMAND\n");       
#endif                                                         
    setCF(1);                                                 
    return FALSE;                                            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdexit.c ===
/*  cmdexit.c - Exit related SVC routines
 *
 *  cmdExit
 *
 *  Modification History:
 *
 *  Sudeepb 05-Jul-1991 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>
#include <winbase.h>

/* cmdExitVDM - Terminate the VDM
 *
 *
 * Entry - None
 *
 * Exit  - None
 *
 *
 *
 */

VOID cmdExitVDM (VOID)
{
    // Kill the VDM process
    TerminateVDM();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdexec.c ===
/*  cmdexec.c - Misc SCS routines for non-dos exec and re-entering
 *              the DOS.
 *
 *
 *  Modification History:
 *
 *  Sudeepb 22-Apr-1992 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <oemuni.h>
#include <wowcmpat.h>

//*****************************************************************************
// IsWowAppRunnable
//
//    Returns FALSE if the WOW-specific compatibility flags for the specified
//    task include the bit WOWCF_NOTDOSSPAWNABLE. This is done mostly for
//    "dual mode" executables, e.g., Windows apps that have a real program
//    as a DOS stub. Certain apps that are started via a DOS command shell,
//    for example PWB, really do expect to be started as a DOS app, not a WOW
//    app. For these apps, the compatibility bit should be set in the
//    registry.
//
//*****************************************************************************

BOOL IsWowAppRunnable(LPSTR lpAppName)
{
    BOOL Result = TRUE;
    LONG lError;
    HKEY hKey = 0;
    char szModName[9];
    char szHexAsciiFlags[12];
    DWORD dwType = REG_SZ;
    DWORD cbData = sizeof(szHexAsciiFlags);
    ULONG ul = 0;
    LPSTR pStrt, pEnd;
    SHORT len;

    lError = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                            "Software\\Microsoft\\Windows NT\\CurrentVersion\\WOW\\Compatibility",
                            0,
                            KEY_QUERY_VALUE,
                            &hKey
                            );

    if (ERROR_SUCCESS != lError) {
        goto Cleanup;
    }

    //
    // The following code strips the file name (<9 chars) out of a dos
    // path name.
    //

    pStrt = strrchr (lpAppName, '\\');

    if (pStrt==NULL)
        pStrt = lpAppName;
    else
        pStrt++;

    if ( (pEnd = strchr (pStrt, '.')) == NULL)
        strncpy (szModName, pStrt, 9);

    else {
        len = (SHORT) (pEnd - pStrt);
        if (len>8) goto Cleanup;
        strncpy (szModName, pStrt, len);
        szModName[len] = '\0';
    }


    //
    // Look for the file name in the registry
    //

    lError = RegQueryValueEx( hKey,
                              szModName,
                              0,
                              &dwType,
                              szHexAsciiFlags,
                              &cbData
                              );

    if (ERROR_SUCCESS != lError) {
        goto Cleanup;
    }

    if (REG_SZ != dwType) {
        goto Cleanup;
    }

    //
    // Force the string to lowercase for the convenience of sscanf.
    //

    _strlwr(szHexAsciiFlags);

    //
    // sscanf() returns the number of fields converted.
    //

    if (1 != sscanf(szHexAsciiFlags, "0x%lx", &ul)) {
        goto Cleanup;
    }

    if ((ul & WOWCF_NOTDOSSPAWNABLE) != 0)
        Result = FALSE;

Cleanup:
    if (hKey) {
        RegCloseKey(hKey);
    }

    return Result;
}

/* cmdCheckBinary - check that the supplied binary name is a 32bit binary
 *
 *
 *  Entry - Client (DS:DX) - pointer to pathname for the executable to be tested
 *          Client (ES:BX) - pointer to parameter block
 *
 *  EXIT  - SUCCESS Client (CY) clear
 *          FAILURE Client (CY) set
 *                  Client (AX) - error_not_enough_memory if command tail
 *                                cannot accomodate /z
 *                              - error_file_not_found if patname not found
 */

VOID cmdCheckBinary (VOID)
{

    LPSTR  lpAppName;
    ULONG  BinaryType;
    PPARAMBLOCK lpParamBlock;
    PCHAR  lpCommandTail,lpTemp;
    ULONG  AppNameLen,CommandTailLen = 0;
    USHORT CommandTailOff,CommandTailSeg,usTemp;
    NTSTATUS       Status;
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    ANSI_STRING    AnsiString;


    if(DontCheckDosBinaryType){
        setCF(0);
        return;         // DOS Exe
    }

    lpAppName = (LPSTR) GetVDMAddr (getDS(),getDX());

    Unicode.Buffer = NULL;
    AnsiString.Buffer = NULL;
    RtlInitString((PSTRING)&OemString, lpAppName);
    Status = RtlOemStringToUnicodeString(&Unicode,&OemString,TRUE);
    if ( NT_SUCCESS(Status) ) {
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &Unicode, TRUE);
        }
    if ( !NT_SUCCESS(Status) ) {
        Status = RtlNtStatusToDosError(Status);
        }
    else if (GetBinaryType (AnsiString.Buffer,(LPLONG)&BinaryType) == FALSE)
       {
        Status =  GetLastError();
        }

    if (Unicode.Buffer != NULL) {
        RtlFreeUnicodeString( &Unicode );
        }
    if (AnsiString.Buffer != NULL) {
        RtlFreeAnsiString( &AnsiString);
        }

    if (Status){
        setCF(1);
        setAX((USHORT)Status);
        return;         // Invalid path
    }


    if (BinaryType == SCS_DOS_BINARY) {
        setCF(0);
        return;         // DOS Exe
    }
                        // Prevent certain WOW apps from being spawned by DOS exe's
                        // This is for win31 compatibility
    else if (BinaryType == SCS_WOW_BINARY) {
        if (!IsWowAppRunnable(lpAppName)) {
            setCF(0);
            return;     // Run as DOS Exe
        }
    }


    if (VDMForWOW && BinaryType == SCS_WOW_BINARY && IsFirstWOWCheckBinary) {
        IsFirstWOWCheckBinary = FALSE;
        setCF(0);
        return;         // Special Hack for krnl286.exe
    }

    // dont allow running 32bit binaries from autoexec.nt. Reason is that
    // running non-dos binary requires that we should have read the actual
    // command from GetNextVDMCommand. Otherwise the whole design gets into
    // synchronization problems.

    if (IsFirstCall) {
        setCF(1);
        setAX((USHORT)ERROR_FILE_NOT_FOUND);
        return;
    }

    // Its a 32bit exe, replace the command with "command.com /z" and add the
    // original binary name to command tail.

    AppNameLen = strlen (lpAppName);

    lpParamBlock = (PPARAMBLOCK) GetVDMAddr (getES(),getBX());

    if (lpParamBlock) {
        CommandTailOff = FETCHWORD(lpParamBlock->OffCmdTail);
        CommandTailSeg = FETCHWORD(lpParamBlock->SegCmdTail);

        lpCommandTail = (PCHAR) GetVDMAddr (CommandTailSeg,CommandTailOff);

        if (lpCommandTail){
            CommandTailLen = *(PCHAR)lpCommandTail;
            lpCommandTail++;        // point to the actual command tail
            if (CommandTailLen)
                CommandTailLen++;   // For CR
        }

        // We are adding 3 below for "/z<space>" and anothre space between
        // AppName and CommandTail.

        if ((3 + AppNameLen + CommandTailLen ) > 128){
            setCF(1);
            setAX((USHORT)ERROR_NOT_ENOUGH_MEMORY);
            return;
        }
    }

    // copy the stub command.com name
    strcpy ((PCHAR)&pSCSInfo->SCS_ComSpec,lpszComSpec+8);
    lpTemp = (PCHAR) &pSCSInfo->SCS_ComSpec;
    lpTemp = (PCHAR)((ULONG)lpTemp - (ULONG)GetVDMAddr(0,0));
    usTemp = (USHORT)((ULONG)lpTemp >> 4);
    setDS(usTemp);
    usTemp = (USHORT)((ULONG)lpTemp & 0x0f);
    setDX((usTemp));

    // Form the command tail, first "3" is for "/z "
    pSCSInfo->SCS_CmdTail [0] = (UCHAR)(3 +
                                        AppNameLen +
                                        CommandTailLen);
    RtlCopyMemory ((PCHAR)&pSCSInfo->SCS_CmdTail[1],"/z ",3);
    strcpy ((PCHAR)&pSCSInfo->SCS_CmdTail[4],lpAppName);
    if (CommandTailLen) {
        pSCSInfo->SCS_CmdTail[4+AppNameLen] = ' ';
        RtlCopyMemory ((PCHAR)((ULONG)&pSCSInfo->SCS_CmdTail[4]+AppNameLen+1),
                lpCommandTail,
                CommandTailLen);
    }
    else {
        pSCSInfo->SCS_CmdTail[4+AppNameLen] = 0xd;
    }

    // Set the parameter Block
    if (lpParamBlock) {
        STOREWORD(pSCSInfo->SCS_ParamBlock.SegEnv,lpParamBlock->SegEnv);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB1,lpParamBlock->pFCB1);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB2,lpParamBlock->pFCB2);
    }
    else {
        STOREWORD(pSCSInfo->SCS_ParamBlock.SegEnv,0);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB1,0);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB2,0);
    }

    lpTemp = (PCHAR) &pSCSInfo->SCS_CmdTail;
    lpTemp = (PCHAR)((ULONG)lpTemp - (ULONG)GetVDMAddr(0,0));
    usTemp = (USHORT)((ULONG)lpTemp & 0x0f);
    STOREWORD(pSCSInfo->SCS_ParamBlock.OffCmdTail,usTemp);
    usTemp = (USHORT)((ULONG)lpTemp >> 4);
    STOREWORD(pSCSInfo->SCS_ParamBlock.SegCmdTail,usTemp);

    lpTemp = (PCHAR) &pSCSInfo->SCS_ParamBlock;
    lpTemp = (PCHAR)((ULONG)lpTemp - (ULONG)GetVDMAddr(0,0));
    usTemp = (USHORT)((ULONG)lpTemp >> 4);
    setES (usTemp);
    usTemp = (USHORT)((ULONG)lpTemp & 0x0f);
    setBX (usTemp);

    setCF(0);
    return;
}

#define MAX_DIR 68

VOID cmdCreateProcess ( PSTD_HANDLES pStdHandles )
{

    VDMINFO VDMInfoForCount;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    HANDLE hStd16In,hStd16Out,hStd16Err;
    CHAR CurDirVar [] = "=?:";
    CHAR Buffer [MAX_DIR];
    CHAR *CurDir = Buffer;
    DWORD dwRet;
    BOOL  Status;
    NTSTATUS NtStatus;
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    LPVOID lpNewEnv=NULL;
    ANSI_STRING Env_A;

    // we have one more 32 executable active
    Exe32ActiveCount++;

    // Increment the Re-enterancy count for the VDM
    VDMInfoForCount.VDMState = INCREMENT_REENTER_COUNT;
    GetNextVDMCommand (&VDMInfoForCount);

    RtlZeroMemory((PVOID)&StartupInfo,sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    CurDirVar [1] = chDefaultDrive;

    dwRet = GetEnvironmentVariable (CurDirVar,Buffer,MAX_DIR);

    if (dwRet == 0 || dwRet == MAX_DIR)
        CurDir = NULL;

    if ((hStd16In = (HANDLE) FETCHDWORD(pStdHandles->hStdIn)) != (HANDLE)-1)
        SetStdHandle (STD_INPUT_HANDLE, hStd16In);

    if ((hStd16Out = (HANDLE) FETCHDWORD(pStdHandles->hStdOut)) != (HANDLE)-1)
        SetStdHandle (STD_OUTPUT_HANDLE, hStd16Out);

    if ((hStd16Err = (HANDLE) FETCHDWORD(pStdHandles->hStdErr)) != (HANDLE)-1)
        SetStdHandle (STD_ERROR_HANDLE, hStd16Err);

    /*
     *  Warning, pEnv32 currently points to an ansi environment.
     *  The DOS is using an ANSI env which isn't quite correct.
     *  If the DOS is changed to use an OEM env then we will
     *  have to convert the env back to ansi before spawning
     *  non-dos exes ?!?
     *  16-Jan-1993 Jonle
     */

    Env_A.Buffer = NULL;

    RtlInitString((PSTRING)&OemString, pCommand32);
    NtStatus = RtlOemStringToUnicodeString(&Unicode,&OemString,TRUE);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlUnicodeStringToAnsiString((PANSI_STRING)&OemString, &Unicode, FALSE);
        RtlFreeUnicodeString( &Unicode );
        }
    if (!NT_SUCCESS(NtStatus)) {
        SetLastError(RtlNtStatusToDosError(NtStatus));
        Status = FALSE;
        }
    else {
        if (pEnv32 != NULL && !cmdXformEnvironment (pEnv32, &Env_A)) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            Status = FALSE;
        }
        else {
            Status = CreateProcess (
                           NULL,
                           (LPTSTR)pCommand32,
                           NULL,
                           NULL,
                           TRUE,
                           CREATE_SUSPENDED | CREATE_DEFAULT_ERROR_MODE,
                           Env_A.Buffer,
                           (LPTSTR)CurDir,
                           &StartupInfo,
                           &ProcessInformation);
        }
    }

    if (Status == FALSE)
        dwExitCode32 = GetLastError ();

    if (hStd16In != (HANDLE)-1)
        SetStdHandle (STD_INPUT_HANDLE, SCS_hStdIn);

    if (hStd16Out != (HANDLE)-1)
        SetStdHandle (STD_OUTPUT_HANDLE, SCS_hStdOut);

    if (hStd16Err != (HANDLE)-1)
        SetStdHandle (STD_ERROR_HANDLE, SCS_hStdErr);

    if (Status) {
        ResumeThread (ProcessInformation.hThread);
        WaitForSingleObject(ProcessInformation.hProcess, (DWORD)-1);
        GetExitCodeProcess (ProcessInformation.hProcess, &dwExitCode32);
        CloseHandle (ProcessInformation.hProcess);
        CloseHandle (ProcessInformation.hThread);
    }

    if (Env_A.Buffer)
        RtlFreeAnsiString(&Env_A);

    // Decrement the Re-enterancy count for the VDM
    VDMInfoForCount.VDMState = DECREMENT_REENTER_COUNT;
    GetNextVDMCommand (&VDMInfoForCount);

    // one less 32 executable active
    Exe32ActiveCount--;

    // Kill this thread
    ExitThread (0);
}


VOID cmdExec32 (PCHAR pCmd32, PCHAR pEnv)
{

    DWORD dwThreadId;
    HANDLE hThread;
    PSTD_HANDLES pStdHandles;

    pCommand32 = pCmd32;
    pEnv32 = pEnv;

    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))+1);

    nt_block_event_thread(0);
    fSoftpcRedirectionOnShellOut = fSoftpcRedirection;
    fBlock = TRUE;


    pStdHandles = (PSTD_HANDLES) GetVDMAddr (getSS(), getBP());
    if((hThread = CreateThread (NULL,
                     0,
                     (LPTHREAD_START_ROUTINE)cmdCreateProcess,
                     pStdHandles,
                     0,
                     &dwThreadId)) == FALSE) {
        setCF(0);
        setAL((UCHAR)GetLastError());
        nt_resume_event_thread();
        nt_std_handle_notification(fSoftpcRedirectionOnShellOut);
        fBlock = FALSE;
        CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))-1);
        return;
    }
    else
        CloseHandle (hThread);

    // Wait for next command to be re-entered
    RtlZeroMemory(&VDMInfo, sizeof(VDMINFO));
    VDMInfo.VDMState = NO_PARENT_TO_WAKE | RETURN_ON_NO_COMMAND;
    GetNextVDMCommand (&VDMInfo);
    if (VDMInfo.CmdSize > 0){
        setCF(1);
        IsRepeatCall = TRUE;
    }
    else {
        setCF(0);
        setAL((UCHAR)dwExitCode32);
        nt_resume_event_thread();
        nt_std_handle_notification(fSoftpcRedirectionOnShellOut);
        fBlock = FALSE;
    }


    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))-1);
    return;
}

/* cmdExecComspec32 - Exec 32bit COMSPEC
 *
 *
 *  Entry - Client (ES) - environment segment
 *          Client (AL) - default drive
 *
 *  EXIT  - SUCCESS Client (CY) Clear - AL has return error code
 *          FAILURE Client (CY) set - means DOS is being re-entered
 */

VOID cmdExecComspec32 (VOID)
{

    CHAR Buffer[MAX_PATH];
    DWORD dwRet;
    PCHAR   pEnv;

    dwRet = GetEnvironmentVariable ("COMSPEC",Buffer,MAX_PATH);

    if (dwRet == 0 || dwRet >= MAX_PATH){
        setCF(0);
        setAL((UCHAR)ERROR_BAD_ENVIRONMENT);
        return;
    }

    pEnv = (PCHAR) GetVDMAddr ((USHORT)getES(),0);

    chDefaultDrive = (CHAR)(getAL() + 'A');

    cmdExec32 (Buffer,pEnv);

    return;
}

/* cmdExec - Exec a non-dos binary
 *
 *
 *  Entry - Client (DS:SI) - command to execute
 *          Client (AL) - default drive
 *          Client (ES) - environment segment
 *          Client (SS:BP) - Pointer to STD_HANDLES
 *          Client (AH) - if 1 means do "cmd /c command" else "command"
 *
 *  EXIT  - SUCCESS Client (CY) Clear - AL has return error code
 *          FAILURE Client (CY) set - means DOS is being re-entered
 */

VOID cmdExec (VOID)
{

    DWORD   i;
    DWORD   dwRet;
    PCHAR   pCommandTail;
    PCHAR   pEnv;
    CHAR Buffer[MAX_PATH];

    pCommandTail = (PCHAR) GetVDMAddr ((USHORT)getDS(),(USHORT)getSI());
    pEnv = (PCHAR) GetVDMAddr ((USHORT)getES(),0);
    for (i=0 ; i<124 ; i++) {
        if (pCommandTail[i] == 0x0d){
            pCommandTail[i] = 0;
            break;
        }
    }

    if (i == 124){
        setCF(0);
        setAL((UCHAR)ERROR_BAD_FORMAT);
        return;
    }

    chDefaultDrive = (CHAR)(getAL() + 'A');

    if (getAH() == 0) {
        cmdExec32 (pCommandTail,pEnv);
    }
    else {
        dwRet = GetEnvironmentVariable ("COMSPEC",Buffer,MAX_PATH);

        if (dwRet == 0 || dwRet >= MAX_PATH){
            setCF(0);
            setAL((UCHAR)ERROR_BAD_ENVIRONMENT);
            return;
        }

        if ((dwRet + 4 + strlen(pCommandTail)) > MAX_PATH) {
            setCF(0);
            setAL((UCHAR)ERROR_BAD_ENVIRONMENT);
            return;
        }

        strcat (Buffer, " /c ");
        strcat (Buffer, pCommandTail);
        cmdExec32 (Buffer,pEnv);
    }

    return;
}

/* cmdReturnExitCode - command.com has run a dos binary and returing
 *                     the exit code.
 *
 * Entry - Client (DX) - exit code
 *         Client (AL) - current drive
 *         Client (BX:CX) - RdrInfo address
 *
 * Exit
 *         Client Carry Set - Reenter i.e. a new DOS binary to execute.
 *         Client Carry Clear - This shelled out session is over.
 */

VOID cmdReturnExitCode (VOID)
{
VDMINFO VDMInfo;
PREDIRCOMPLETE_INFO pRdrInfo;

    RtlZeroMemory(&VDMInfo, sizeof(VDMINFO));
    VDMInfo.VDMState = RETURN_ON_NO_COMMAND;
    VDMInfo.ErrorCode = (ULONG)getDX();

    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))+1);

    nt_block_event_thread(0);
    fBlock = TRUE;

    // a dos program just terminate, inherit its current directories
    // and tell base too.
    cmdUpdateCurrentDirectories((BYTE)getAL());

    // Check for any copying needed for redirection
    pRdrInfo = (PREDIRCOMPLETE_INFO) (((ULONG)getBX() << 16) + (ULONG)getCX());

    if (!cmdCheckCopyForRedirection (pRdrInfo, FALSE))
            VDMInfo.ErrorCode = ERROR_NOT_ENOUGH_MEMORY;

    GetNextVDMCommand (&VDMInfo);
    if (VDMInfo.CmdSize > 0){
        setCF(1);
        IsRepeatCall = TRUE;
    }
    else {
        setCF(0);
        setAL((UCHAR)dwExitCode32);
        nt_resume_event_thread();
        nt_std_handle_notification(fSoftpcRedirectionOnShellOut);
        fBlock = FALSE;
    }

    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))-1);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdkeyb.h ===
/*  cmdkeyb.h - Keyboard layout support routines
 *  include file for CMDKEYB.C
 *
 *  Modification History:
 *
 *  YST 14-Jan_1993 Created
 */


#define DOSKEYBCODES	"DOSKeybCodes"	      // section name in layout.inf
#define LAYOUT_FILE     "\\LAYOUT.INF"        // INF file name
#define DEFAULT_KB_ID   "US"                  // Default keyboard ID
#define KEYBOARD_SYS    "\\KEYBOARD.SYS"      // Data file for KEYB.COM
#define US_CODE         "00000409"            // Code for US keyboard in REGISTER.INI
#define KEYB_COM        "\\KB16.COM"          // File name for keyboard program
#define KBDLAYOUT_PATH	"System\\CurrentControlSet\\Control\\Keyboard Layout\\"
#define DOSCODES_PATH	"DosKeybCodes"
#define DOSIDS_PATH	"DosKeybIDs"
#define REG_STR_ALTKDF_FILES	"AlternativeKDFs"
#define REG_STR_WOW	"SYSTEM\\CurrentControlSet\\Control\\Wow"
#define KDF_SIGNATURE	"\xFFKEYB   "
#define LANGID_BUFFER_SIZE	20
#define KEYBOARDID_BUFFER_SIZE	20
#define KDF_AX		    "\\KEYAX.SYS"     // AX standard keyboard
#define KDF_106 	    "\\KEY01.SYS"     // 106 keys
#define KDF_IBM5576_02_03   "\\KEY02.SYS"     // IBM 5576 002/003 keyboard
#define KDF_TOSHIBA_J3100   "\\KEYJ31.SYS"    // Toshiba J3100 keyboard


//
// Dos KDF(Keyboard Definition File) format description:
//
// The file starts with a header(KDF_HEADER), followed
// by an array of KDF_LANGID_OFFSET and then by an array of
// KDF_KEYBOARDID_OFFSET. The KDF_LANGID_OFFSET array size is
// determined by KDF_HEADER.TotalLangIDs while the KDF_KEYBOARDID_OFFSET
// array size is determined by KDF_HEADER.TotalKeybIDs
//
// Each KDF_LANGID_OFFSET contains a file offset to its KDF_LANGID_ENTRY.
// Each KDF_LANGID_ENTRY is followed by an array of KDF_CODEPAGEID_OFFSET.
// The KDF_CODEPAGEID_OFFSET array size is determined by its assocated
// KDF_LANGID_ENTRY's TotalCodePageIDs.
//
// For a language ID with multiple keyboard IDs, Only one entry
// will be in the KDF_LANGID_OFFSET table. The rest of them are
// stored in the KDF_KEYBOARDID_OFFSET table.
//
// Each KDF_LANGID_ENTRY plus its code page table is enough
// to determine if a (language id, keyboard id, code page id) is
// support by the kdf file.
//
// KDF file header
//

// must pack the structures
#pragma pack(1)

typedef struct tagKDFHeader
{
    CHAR    Signature[8];   // signature, must be 0xFF"KEYB    "
    CHAR    Reserved1[8];
    WORD    MaxCommXlatSize;	// maximum common xlat section size
    WORD    MaxSpecialXlatSize; // maximum special xlat section size
    WORD    MaxStateLogicSize;	// maximum state logic section size
    WORD    Reserved2;
    WORD    TotalKeybIDs;	// total keyboard ids defined in this file
    WORD    TotalLangIDs;	// total language ids defined in this file
}KDF_HEADER, *PKDF_HEADER;

#define IS_LANGID_EQUAL(src, dst)   (toupper(src[0]) == toupper(dst[0])  && \
				     toupper(src[1]) == toupper(dst[1]) )
//
//
//
typedef struct tagKDFLangIdOffset
{
    CHAR    ID[2];			    // the id, "us" for U.S.A
    DWORD   DataOffset; 		    // file offset to its KDF_LANGID_ENTRY
}KDF_LANGID_OFFSET, *PKDF_LANGID_OFFSET;

typedef struct tagKDFKeyboardIdOffset
{
    WORD    ID;				    // the id
    DWORD   DataOffset; 		    // file offset to its KDF_LANGID_ENTRY
}KDF_KEYBOARDID_OFFSET, *PKDF_KEYBOARDID_OFFSET;


// A single lang id may associate with multiple keyboard ids and for each
// keyboard id, there is one KDF_LANGID_ENTRY allocated for it.
// The TotalKaybordIDs is tricky. Suppose the language id has <n> different
// keyboard ids, the <i>th KDF_LANGID_ENTRY's TotalKeyboardIDs contains
// the value of <n - i + 1>. As far as we are only interested in if
// the kdf supports a given (language id, keyboard id, code page id> combination
// we donot care how the value is set by simply following these steps:
// (1). Read the KDF_LANGID_OFFSET table and for each KDF_LANGID_OFFSET,
//	compare the language id. If it matches, go get its KDF_LANGID_ENTRY
//	and compare the primary keyboard id and all its code page. If
//	the combination matches, we are done, otherwise, go to step 2.
// (2). Read KDF_KEYBOARDID_OFFSET table and for each KDF_KEYBOARDID_OFFSET,
//	compare the keyboard id. If the keyboard id matches, go get its
//	KDF_LANGID_ENTRY and compare the language id and code page against
//	the KDF_LANGID_ENTRY. If both the language id and the code page id
//	match, we are done, otherwise, goto step 3.
// (3). We conclude that this kdf does not meet the requirement.
//
typedef struct tagLangEntry
{
    CHAR    ID[2];			    // the id
    WORD    PrimaryKeybId;		    // primary keyboard id
    DWORD   DataOffset; 		    // file offset to state logic section
    BYTE    TotalKeyboardIDs;		    // total keyboard ids
    BYTE    TotalCodePageIDs;		    // total code pages
}KDF_LANGID_ENTRY, *PKDF_LANGID_ENTRY;
//
// An array of supported KDF_CODEPAGEID_OFFSET immediately follow its
// KDF_LANGID_ENTRY. The size of the array is determined by
// KDF_LANGID_ENTRY.TotalCodePageIDs
typedef struct tagCodePageIdOffset
{
    WORD    ID; 			    // the id
    DWORD   DataOffset; 		    // file offset to the xlat section
}KDF_CODEPAGEID_OFFSET, *PKDF_CODEPAGEID_OFFSET;

#pragma pack()

BOOL
LocateKDF(
    CHAR* LanguageID,
    WORD  KeyboardID,
    WORD  CodePageID,
    LPSTR Buffer,
    DWORD* BufferSize
    );

BOOL
MatchKDF(
    CHAR* LanguageID,
    WORD  KeyboardID,
    WORD  CodePageID,
    LPCSTR KDFPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdkeyb.c ===
/*  cmdkeyb.c - Keyboard layout support routines
 *
 *
 *  Modification History:
 *
 *  YST 14-Jan_1993 Created
 *
 *  08-Sept-1998, williamh, add third-party KDF support.
 */

#include "cmd.h"
#include <winconp.h>
#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <string.H>
#include "cmdkeyb.h"
#include <winnls.h>

CHAR szPrev[5] = "US";
INT  iPrevCP = 437;
CHAR szPrevKbdID[8] = "";

extern BOOL bPifFastPaste;

/************************************************************************\
*
*  FUNCTION:	VOID cmdGetKbdLayout( VOID )
*
*  Input	Client (DX) = 0 - Keyb.com not installed
*			      1 - Keyb.com installed
*		Client (DS:SI) = pointer where exe name has to be placed
*		Client (DS:CX) = pointer where command options are placed
*
*  Output
*	Success (DX = 1 )
*		Client (DS:SI) = Keyb.com execuatable string
*		Client (DS:CX) = command options
*
*	Failure (DX = 0)
*
*  COMMENTS:    This function check KEYBOARD ID for Win session
*		and if ID != US then return lines with
*               filename and options to COMMAND.COM
*
*               If bPifFastPaste is FALSE, then we always run kb16
*               for all keyboard ID including US, to give us a more
*               bios compatible Int 9 handler. 10-Jun-1993 Jonle
*
*
*  HISTORY:     01/05/93 YSt Created.
*
\************************************************************************/

VOID cmdGetKbdLayout( VOID )
{
  INT  iSize,iSaveSize;
  CHAR szKeybCode[12];
  CHAR szDir[MAX_PATH+15];
  CHAR szBuf[28];
  CHAR szNewKbdID[8];
  CHAR szAutoLine[MAX_PATH+40];
  CHAR szKDF[MAX_PATH];
  PCHAR pVDMKeyb;
  INT  iKeyb;
  HKEY	 hKey;
  HKEY	 hKeyLayout;
  DWORD  dwType;
  DWORD  retCode;
  INT	 iNewCP;
  DWORD  cbData;
  WORD	 KeybID;
  OFSTRUCT  ofstr;
  LANGID LcId = GetSystemDefaultLangID();
  int	 keytype;


#if defined(NEC_98) 
    setDX(0); 
    return;  
#endif // NEC_98

// Get information about 16 bit KEYB.COM from VDM
   iKeyb = getDX();


// The whole logic here is to decide:
// (1). if we have to run kb16.com at all.
// (2). if we have to run kb16.com, what parameters we should pass along,
//	such as keyboard id, language id, code page id and kdf file name.
// We do not load kb16.com at all if one of the following
// conditions is met:
// (1). We can not find the console keyboard layout id.
// (2). The console keyvoard layout id is US and kb16.com is not loaded
//	and fast paste is disabled.
// (3). We can not get the dos keyboard id/dos key code.
// (4). The new (language id, keyboard id, code page id) is the same
//	as the one we loaded previously.
// (5). we can not find kb16.com.
// (6). we can not find the kdf file that supports the
//	(language id, keyboard id, code page id) combination.
//
// If everything goes as planned, we end up with a command
// contains kb16.com fully qualified name and a command line contains
// appropriate parameters to kb16.com
//

    if (LcId == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
        // JAPAN build. Language id is always "JP" and code page is either 932
        // or 437 depends on keyboard type.
            iNewCP = 437;
            if (7 == GetKeyboardType(0))
            {
	        keytype = GetKeyboardType(1);
                if (keytype == 1 || keytype == 2 || keytype == 3 || (keytype & 0xff00) == 0x1200)
	            iNewCP = 932;
            }
            szBuf[0] = 'J';
            szBuf[1] = 'P';
            szBuf[2] = '\0';
            // no keyboard id available.
            szNewKbdID[0] = '\0';
    }
    else {
//
// check point #1: see if we can get the console keyboard layout id
//
        if (!GetConsoleKeyboardLayoutName(szKeybCode))
	    goto NoInstallkb16;
//
// check point #2: see if the layout is US and kb16.com is loaded and
//		   fast paste is disabled.
//		   If kb16.com is loaded, we need to run it again
//		   so that it will load the correct layout.
//		   If fast paste is disable, we load kb16.com which
//		   definitely will slow down keys delivery.
//
        if( bPifFastPaste && !strcmp(szKeybCode, US_CODE) && !iKeyb)
	    goto NoInstallkb16;
//
// check point #3: see if we can get the language id and keyboard id(if any)
//

  // OPEN THE KEY.
        sprintf(szAutoLine, "%s%s", KBDLAYOUT_PATH, DOSCODES_PATH);
        if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, // Key handle at root level.
			      szAutoLine, // Path name of child key.
                              0,           // Reserved.
                              KEY_EXECUTE, // Requesting read access.
			      &hKey))      // Address of key to be returned.
	    goto NoInstallkb16;


        cbData  = sizeof(szBuf);
        // Query for line from REGISTER file
        retCode = RegQueryValueEx(hKey, szKeybCode, NULL, &dwType, szBuf, &cbData);

        RegCloseKey(hKey);
        if (ERROR_SUCCESS != retCode || REG_SZ != dwType || !cbData)
	    goto NoInstallkb16;
        //
        // szBuf now contains language id('SP' for spanish, for example).
        //
        // look for keyboard id number. For Daytona, Turkish and Italian both
        // have one key code and two layouts.
        szNewKbdID[0] = '\0';
        cbData = sizeof(szNewKbdID);
        sprintf(szAutoLine, "%s%s", KBDLAYOUT_PATH, DOSIDS_PATH);
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		          szAutoLine,
		          0,
		          KEY_EXECUTE,
		          &hKey
		          ) == ERROR_SUCCESS)
        {
	    retCode = RegQueryValueEx(hKey, szKeybCode, NULL, &dwType, szNewKbdID, &cbData);
	    if (ERROR_SUCCESS != retCode || REG_SZ != dwType || !cbData)
	        szNewKbdID[0] = '\0';

	    RegCloseKey(hKey);
        }

        iNewCP = GetConsoleCP();

    }

//
// check point #4: see if there are any changes in ids
//

// see if there are changes in language id, keyboard id and code page id.

    if(bPifFastPaste && iNewCP == iPrevCP &&
       !_stricmp(szBuf, szPrev) &&
       !_stricmp(szNewKbdID, szPrevKbdID))
    {
	goto NoInstallkb16;
    }

//
// Check point #5: see if kb16.com can be found.
//
// kb16.com should be found in GetSystemDirectory()\system32 subdirectory.
//
    iSaveSize = iSize = GetSystemDirectory(szDir, MAX_PATH);

    // can't get the system directory!
    if (!iSize || iSize > MAX_PATH)
    {
	goto NoInstallkb16;
    }
    // convert the system directory to short name
    cbData = GetShortPathName(szDir, szDir, MAX_PATH);
    if (!cbData || cbData >= MAX_PATH)
	goto NoInstallkb16;

    sprintf(szAutoLine, "%s%s",
        szDir,              // System directory
        KEYB_COM            // keyb.com
	);
    // if the fully qualified path name to kb16.com is too long
    // we must fail because Dos can not swallow a long path name.
    if (strlen(szAutoLine) > 128)
	goto NoInstallkb16;

    dwType = GetFileAttributes(szAutoLine);
    if (dwType == 0xFFFFFFFF || (dwType & FILE_ATTRIBUTE_DIRECTORY) != 0)
    {
	goto NoInstallkb16;
    }

//
// Check point #6: see if we can find kdf file that support the
//		   (language id, keyboard id, code page id) combination
//

    //
    // first, convert keyboard id from string to binary if we have one.
    //
    KeybID = (szNewKbdID[0]) ? (WORD)strtoul(szNewKbdID, NULL, 10) : 0;
    cbData = sizeof(szKDF) / sizeof(CHAR);

    // locate the kdf file.
    if (!LocateKDF(szBuf, KeybID, (WORD)iNewCP, szKDF, &cbData))
    {
	goto NoInstallkb16;
    }
    // convert the kdf name to short name
    cbData = GetShortPathName(szKDF, szKDF, sizeof(szKDF)/ sizeof(CHAR));
    if (!cbData || cbData >= sizeof(szKDF) / sizeof(CHAR))
    {
	goto NoInstallkb16;
    }
    //
    // everything is checked and in place. Now compose the command
    // line to execute kb16.com

    // first, the command
    pVDMKeyb = (PCHAR) GetVDMAddr((USHORT) getDS(), (USHORT) getSI());
    strcpy(pVDMKeyb, szAutoLine);
    // then the parameters
    // The format is: XX,YYY, <kdf file>, where XXX is the language id
    // and YYY is the code page id.
    pVDMKeyb = (PCHAR) GetVDMAddr((USHORT) getDS(), (USHORT) getCX());
    // The first byte is resevered for the length of the string.
    sprintf(szAutoLine, " %s,%d,%s",
	szBuf,		    // keyboard code
	iNewCP, 	    // new code page
	szKDF		    // keyboard.sys
	);
    // if we have a keyboard id, pass it also
    if (szNewKbdID[0])
    {
	strcat(szAutoLine, " /id:");
	strcat(szAutoLine, szNewKbdID);
    }
    // standard parameter line has the format:
    // <length><line text><\0xd>, <length> is the length of <line text>
    //
    iSize = strlen(szAutoLine);
    szAutoLine[iSize] = 0xd;
    // Move the line to 16bits, including the terminated cr char
    RtlMoveMemory(pVDMKeyb + 1, szAutoLine, iSize + 1);
    *pVDMKeyb = (CHAR)iSize;
// Save new layout ID  and code page for next call
    strcpy(szPrev, szBuf);
    strcpy(szPrevKbdID, szNewKbdID);
    iPrevCP = iNewCP;

    setDX(1);
    return;

NoInstallkb16:
    setDX(0);
    cmdInitConsole();      // make sure conoutput is on
    return;
}

//
// This function locates the appropriate keyboard definition file from
// the given language, keyboard and code page id. It searches the registry
// for third-party installed KDF files first and then falls back to
// the system default, %systemroot%\system32\keyboard.sys.
//
// INPUT:
//	LanguageID	-- the language id
//	KeyboardID	-- the optional keyboard id, 0 means do not care
//	CodePageID	-- the code page id
//	Buffer		-- the buffer to receive fully qualified kdf file name
//	BufferSize	-- the size of Buffer in bytes
//
// OUTPUT:
//	TRUE -- Buffer is filled with the kdf fully qualified file name and
//		*BufferSize is set with the size of the file name, not including
//		the null terminated char. If no kdf file can be found,
//		the Buffer is terminated with NULL and *BufferSize if set to 0.
//	FALSE -- error. GetLastError() should return the error code
//		 If the error occurs because the provided buffer is too small
//		*BufferSize will set to the required size(excluding null
//		terminated char) and error code will be set to
//		ERROR_INSUFFICIENT_BUFFER
//
BOOL
LocateKDF(
    CHAR*   LanguageID,
    WORD    KeyboardID,
    WORD    CodePageID,
    LPSTR   Buffer,
    DWORD*   BufferSize
    )
{
    HKEY  hKeyWow;
    BOOL  Result;
    DWORD dw, Type;
    DWORD Attributes;
    DWORD ErrorCode;
    CHAR* KDFName;
    CHAR* LocalBuffer;
    CHAR* FinalKDFName;
    CHAR  FullName[MAX_PATH + 1];

    // validate buffer parameter first
    if (!CodePageID || !LanguageID || !BufferSize || (*BufferSize && !Buffer))
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
    // Open the registry to see if we have alternative kdf files avaialble.
    // We seach the file from atlternative file list in the registry first.
    // The first KDF in the list has the highest rank and the last one has
    // the lowest. The search starts from highest rank and then goes
    // on toward the lower ones. As soon as a KDF file is found, the search
    // stops. If no appropriate KDF can be found in the alternative list,
    // the default kdf, keyboard.sys, will be used.
    //
    // FinalKDFName serves as an indicator. If it is NULL,
    // we do not find any file that satisfies the request.
    FinalKDFName = NULL;
    LocalBuffer = NULL;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     REG_STR_WOW,
		     0,
		     KEY_EXECUTE,
		     &hKeyWow
		     ) == ERROR_SUCCESS)
    {
	// first probe for size
	dw = 0;
	RegQueryValueEx(hKeyWow, REG_STR_ALTKDF_FILES, NULL, &Type, NULL, &dw);
	if (dw && (REG_MULTI_SZ == Type))
	{
	    // we have something in the registry. Allocate a buffer to reteive
	    // it. We want the value to be double null terminated,
	    // so we add one more char in case it is a REG_SZ.
	    // The returned size from RegQueryValueEx includes the
	    // null terminated char(and the double null chars for
	    // REG_MULTI_SZ. By adding one more char, we are in
	    // good shape.

	    ASSERT(!LocalBuffer);
	    LocalBuffer = malloc((dw + 1)* sizeof(CHAR));
	    if (LocalBuffer)
	    {
		LocalBuffer[0] = '\0';
		if (RegQueryValueEx(hKeyWow, REG_STR_ALTKDF_FILES, NULL, &Type,
				LocalBuffer, &dw) == ERROR_SUCCESS && dw)
		{
		    KDFName = LocalBuffer;
		    while ('\0' != *KDFName)
		    {
			// See if we can find the file first.
			Attributes = GetFileAttributesA(KDFName);
			if (0xFFFFFFFF == Attributes)
			{
			    // file not found, do a search
			    if (SearchPathA(NULL,	// no path
					    KDFName,
					    NULL,	// no extension
					    sizeof(FullName) / sizeof(CHAR),
					    FullName,
					    NULL
					    ))
			    {
				FinalKDFName = FullName;
			    }
			}
			else
			{
			    FinalKDFName = KDFName;
			}
			if (MatchKDF(LanguageID, KeyboardID, CodePageID, FinalKDFName))
				break;
			KDFName += strlen(KDFName) + 1;
			FinalKDFName = NULL;
		    }
		}
	    }
	    else
	    {
		// not enough memory
		RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		 TerminateVDM();
	    }
	}
	if (!FinalKDFName)
	{
	    // either no alternative kdf files are specified in the registry
	    // or none of them contains the required specification,
	    // use the default kdf file
	    FullName[0] = '\0';
	    GetSystemDirectory(FullName, sizeof(FullName) / sizeof(CHAR));

            if (!_stricmp(LanguageID, "JP") &&
	        7 == GetKeyboardType(0)
               ) {
	        // For Japanese language ID, different keyboard types have different
	        // default kdf.

                int Keytype;

                Keytype = GetKeyboardType(1);
                if (Keytype == 1)
                    strcat(FullName, KDF_AX);
                else if (Keytype == 2)
                    strcat(FullName, KDF_106);
                else if (Keytype == 3)
                    strcat(FullName, KDF_IBM5576_02_03);
                else if ((Keytype & 0xFF00) == 0x1200)
                    strcat(FullName, KDF_TOSHIBA_J3100);
                else
                    strcat(FullName, KEYBOARD_SYS);
            }
            else
	        strcat(FullName, KEYBOARD_SYS);

	    FinalKDFName = FullName;
	}
	RegCloseKey(hKeyWow);
    }
    if (FinalKDFName)
    {
	dw = strlen(FinalKDFName);
	if (dw && dw < *BufferSize)
	{
	    strcpy(Buffer, FinalKDFName);
	    *BufferSize = dw;
	    Result = TRUE;
	}
	else
	{
	    *BufferSize = dw;
	    SetLastError(ERROR_INSUFFICIENT_BUFFER);
	    Result = FALSE;
	}
    }
    else
    {
	Result = FALSE;
	*BufferSize = 0;
	SetLastError(ERROR_FILE_NOT_FOUND);
    }
    //
    // finally, free the buffer we allocated
    //
    if (LocalBuffer)
	free(LocalBuffer);
    return Result;
}

//
// This function determines if the given kdf supports the given
// (language id, keyboard id, code page id) combination
//
// INPUT:
//	LanguageID	-- the language.
//	KeyboardID	-- optional keyboard id. 0 if do not care
//	CodePageID	-- code page id
//	KDFPath		-- fully qualified kdf file
// OUTPUT:
//	TRUE  -- The kdf contains the given combination
//	FALSE -- either the kdf does not contain the combination or
//		 can not determine.
//
BOOL
MatchKDF(
    CHAR* LanguageID,
    WORD KeyboardID,
    WORD CodePageID,
    LPCSTR KDFPath
    )
{
    HANDLE hKDF;
    KDF_HEADER	Header;
    KDF_LANGID_ENTRY	  LangIdEntry;
    DWORD BytesRead, BufferSize;
    WORD  Index;
    DWORD LangIdEntryOffset;
    PKDF_CODEPAGEID_OFFSET pCodePageIdOffset;
    BOOL Matched;

    if (!KDFPath || !LanguageID || !CodePageID)
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
    Matched = FALSE;

    LangIdEntryOffset = 0;
    // open the kdf file.
    hKDF = CreateFile(KDFPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
			  NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE != hKDF &&
	ReadFile(hKDF, &Header, sizeof(Header),&BytesRead, NULL) &&
	BytesRead == sizeof(Header) && Header.TotalLangIDs &&
	Header.TotalKeybIDs &&
	!strncmp(Header.Signature, KDF_SIGNATURE, sizeof(Header.Signature))
	)
    {
	// The file header is loaded, the signature checked and sanity check
	// on language and keyboard id counts is also done.
	// We are now ready to verfiy if the given language id, keyboard id
	// and code page id is supported in this file.
	// A KDF has two sets of offset table. One is based on language ID
	// while the other one is based on keyboard id. Since a language ID
	// may contain multiple keyboard id, the keyboard id set is always
	// encompass the language id table.
	// If the caller gives us a keyboard id, we use the id as the
	// key for search and verify language id when we found the keyboard
	// id. If no keyboard id is provided, we use the language id as the
	// key.
	if (KeyboardID)
	{
	    // move the file pointer to the keyboard id offset array
	    BufferSize = sizeof(KDF_LANGID_OFFSET) * Header.TotalLangIDs;
	    BufferSize = SetFilePointer(hKDF, BufferSize, NULL, FILE_CURRENT);
	    if (0xFFFFFFFF != BufferSize)
	    {
		PKDF_KEYBOARDID_OFFSET pKeybIdOffset;
		BufferSize = sizeof(KDF_KEYBOARDID_OFFSET) * Header.TotalKeybIDs;
		pKeybIdOffset = (PKDF_KEYBOARDID_OFFSET)malloc(BufferSize);
		if (!pKeybIdOffset)
		{
		    // not enough memory
		    RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
				 RMB_ICON_BANG | RMB_ABORT);
		     TerminateVDM();
		}
		if (ReadFile(hKDF, pKeybIdOffset, BufferSize, &BytesRead, NULL) &&
		    BytesRead == BufferSize)
		{
		    // loop though each KDF_KEYBOARDID_OFFSET to see
		    // if the keyboard id matches.
		    for (Index = 0; Index < Header.TotalKeybIDs; Index++)
		    {
			if (pKeybIdOffset[Index].ID == KeyboardID)
			{
			    // got it. Remeber the file offset to
			    // the KDF_LANGID_ENTRY
			    LangIdEntryOffset = pKeybIdOffset[Index].DataOffset;
			    break;
			}
		    }
		}
		free(pKeybIdOffset);
	    }
	}
	else
	{
	    PKDF_LANGID_OFFSET	pLangIdOffset;
	    BufferSize = sizeof(KDF_LANGID_OFFSET) * Header.TotalLangIDs;
	    pLangIdOffset = (PKDF_LANGID_OFFSET)malloc(BufferSize);
	    if (!pLangIdOffset)
	    {
		// not enough memory
		RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		TerminateVDM();
	    }
	    if (ReadFile(hKDF, pLangIdOffset, BufferSize, &BytesRead, NULL) &&
		BytesRead == BufferSize)
	    {
		// loop through each KDF_LANGID_OFFSET to see if
		// language id matches
		for (Index = 0; Index < Header.TotalLangIDs; Index++)
		{
		    if (IS_LANGID_EQUAL(pLangIdOffset[Index].ID, LanguageID))
		    {
			LangIdEntryOffset = pLangIdOffset[Index].DataOffset;
			break;
		    }
		}
	    }
	    free(pLangIdOffset);
	}
	if (LangIdEntryOffset)
	{
	    BufferSize = SetFilePointer(hKDF, LangIdEntryOffset, NULL, FILE_BEGIN);
	    if (0xFFFFFFFF != BufferSize &&
		ReadFile(hKDF, &LangIdEntry, sizeof(LangIdEntry), &BytesRead, NULL) &&
		BytesRead == sizeof(LangIdEntry))
	    {
		// sanity checks
		if (IS_LANGID_EQUAL(LangIdEntry.ID, LanguageID) &&
		    LangIdEntry.TotalCodePageIDs)
		{
		    // the KDF_LANGID_ENTRY looks fine. Now retrieve
		    // its code page offset table and search the given
		    // code page id

		    BufferSize = LangIdEntry.TotalCodePageIDs * sizeof(KDF_CODEPAGEID_OFFSET);
		    pCodePageIdOffset = (PKDF_CODEPAGEID_OFFSET)malloc(BufferSize);
		    if (!pCodePageIdOffset)
		    {
			// not enough memory
			RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
				     RMB_ICON_BANG | RMB_ABORT);
			TerminateVDM();
		    }
		    if (ReadFile(hKDF, pCodePageIdOffset, BufferSize, &BytesRead, NULL) &&
			BytesRead == BufferSize)
		    {
			for (Index = 0; Index < LangIdEntry.TotalCodePageIDs; Index++)
			{
			    if (CodePageID == pCodePageIdOffset[Index].ID)
			    {
				Matched = TRUE;
				break;
			    }
			}
		    }
		    free(pCodePageIdOffset);
		}
	    }
	}
	CloseHandle(hKDF);
    }
    return Matched;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdmisc.c ===
/*  cmdmisc.c - Misc. SVC routines of Command.lib
 *
 *
 *  Modification History:
 *
 *  Sudeepb 17-Sep-1991 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <demexp.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <memory.h>
#include "oemuni.h"
#include "nt_pif.h"
#include "nt_uis.h"       // For resource id

#if defined(NEC_98)
extern UINT saveCP;
extern UINT saveOutputCP;
#endif // NEC_98

VOID GetWowKernelCmdLine(VOID);
extern ULONG fSeparateWow;
#if defined(KOREA)
//To fix HaNa spread sheet IME hot key problem
//09/20/96 bklee. See mvdm\v86\monitor\i386\monitor.c
BOOL bIgnoreExtraKbdDisable = FALSE;
#endif

VOID cmdGetNextCmd (VOID)
{
LPSTR   lpszCmd;
PCMDINFO pCMDInfo;
ULONG   cb;
PREDIRCOMPLETE_INFO pRdrInfo;
VDMINFO MyVDMInfo;

char    *pSrc, *pDst;
char    achCurDirectory[MAXIMUM_VDM_CURRENT_DIR + 4];
char    CmdLine[MAX_PATH];

    //
    // This routine is called once for WOW VDMs, to retrieve the
    // "krnl386" command line.
    //                                         5
    if (VDMForWOW) {
        GetWowKernelCmdLine();
#if defined(NEC_98)
        cmdInitConsole();
#endif // NEC_98
        return;
    }

    VDMInfo.VDMState = 0;
    pCMDInfo = (LPVOID) GetVDMAddr ((USHORT)getDS(),(USHORT)getDX());

    VDMInfo.ErrorCode = FETCHWORD(pCMDInfo->ReturnCode);
    VDMInfo.CmdSize = sizeof(CmdLine);
    VDMInfo.CmdLine = CmdLine;
    VDMInfo.AppName = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->ExecPathSeg),
                                        FETCHWORD(pCMDInfo->ExecPathOff));
    VDMInfo.AppLen = FETCHWORD(pCMDInfo->ExecPathSize);
    VDMInfo.PifLen = 0;
    VDMInfo.EnviornmentSize = 0;
    VDMInfo.Enviornment = NULL;
    VDMInfo.CurDrive = 0;
    VDMInfo.TitleLen = 0;
    VDMInfo.ReservedLen = 0;
    VDMInfo.DesktopLen = 0;
    VDMInfo.CurDirectoryLen = MAX_PATH + 1;
    VDMInfo.CurDirectory = achCurDirectory;

    if(IsFirstCall){
        VDMInfo.VDMState = ASKING_FOR_FIRST_COMMAND;
        VDMInfo.ErrorCode = 0;

        DeleteConfigFiles();   // get rid of the temp boot files

        // When COMMAND.COM issues first cmdGetNextCmd, it has
        // a completed environment already(cmdGetInitEnvironment),
        // Therefore, we don't have to ask environment from BASE
        cmdVDMEnvBlk.lpszzEnv = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->EnvSeg),0);
        cmdVDMEnvBlk.cchEnv = FETCHWORD(pCMDInfo->EnvSize);

        // Check BLASTER environment variable to determine if Sound Blaster
        // emulation should be disabled.
        if (cmdGetEnvironmentVariable(NULL, "BLASTER", CmdLine, MAX_PATH)) {
            SbReinitialize(CmdLine, MAX_PATH);
        }
        //clear bits that track printer flushing
        host_lpt_flush_initialize();
    }
    else {

        // program has terminated. If the termiation was issued from
        // second(or later) instance of command.com(cmd.exe), don't
        // reset the flag.
        if (Exe32ActiveCount == 0)
            DontCheckDosBinaryType = FALSE;

        // tell the base our new current directories (in ANSI)
        // we don't do it on repeat call(the shell out case is handled in
        // return exit code
        if (!IsRepeatCall) {
            cmdUpdateCurrentDirectories((BYTE)pCMDInfo->CurDrive);
        }

        VDMInfo.VDMState = 0;
        if(!IsRepeatCall){
            demCloseAllPSPRecords ();

            if (!pfdata.CloseOnExit && DosSessionId)
                nt_block_event_thread(1);
            else
                nt_block_event_thread(0);

            if (DosSessionId) {
                pRdrInfo = (PREDIRCOMPLETE_INFO) FETCHDWORD(pCMDInfo->pRdrInfo);
                if (!pfdata.CloseOnExit){
                    char  achTitle[MAX_PATH];
                    char  achInactive[60];     //should be plenty for 'inactive'
                    strcpy (achTitle, "[");
                    if (!LoadString(GetModuleHandle(NULL), EXIT_NO_CLOSE,
                                                              achInactive, 60))
                        strcat (achTitle, "Inactive ");
                    else
                        strcat(achTitle, achInactive);
                    cb = strlen(achTitle);
                    // GetConsoleTitleA and SetConsoleTitleA
                    // are working on OEM character set.
                    GetConsoleTitleA(achTitle + cb, MAX_PATH - cb - 1);
                    cb = strlen(achTitle);
                    achTitle[cb] = ']';
                    achTitle[cb + 1] = '\0';
                    SetConsoleTitleA(achTitle);
                    // finish touch on redirection stuff
                    cmdCheckCopyForRedirection (pRdrInfo, FALSE);
                    Sleep(INFINITE);
                }
                else {
                    // finish touch on redirection stuff
                    // this will wait on the output thread if there
                    // are any.
                    cmdCheckCopyForRedirection (pRdrInfo, TRUE);
                    VdmExitCode = VDMInfo.ErrorCode;
                    TerminateVDM();
                }
            }
            fBlock = TRUE;
#if defined(NEC_98)
            if (!VDMForWOW) { // BugFix: Change IME status by Screen Saver of 16bit
                SetConsoleCP(saveCP);
                SetConsoleOutputCP(saveOutputCP);
            }
#endif // NEC_98
        }
    }

    if(IsRepeatCall) {
        VDMInfo.VDMState |= ASKING_FOR_SECOND_TIME;
        if( VDMInfo.ErrorCode != 0 )
            IsRepeatCall = FALSE;
    }

    VDMInfo.VDMState |= ASKING_FOR_DOS_BINARY;

    if (!IsFirstCall && !(VDMInfo.VDMState & ASKING_FOR_SECOND_TIME)) {
        pRdrInfo = (PREDIRCOMPLETE_INFO) FETCHDWORD(pCMDInfo->pRdrInfo);
        if (!cmdCheckCopyForRedirection (pRdrInfo, FALSE))
            VDMInfo.ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
    }

    // Leave the current directory in a safe place, so that other 32bit
    // apps etc. can delnode this directory (and other such operations) later.
    if ( IsFirstCall == FALSE && IsRepeatCall == FALSE )
        SetCurrentDirectory (cmdHomeDirectory);

    // TSRExit will be set to 1, only if we are coming from command.com's
    // prompt and user typed an exit. We need to kill our parent also, so we
    // should write an exit in the console buffer.
    if (FETCHWORD(pCMDInfo->fTSRExit)) {
        cmdPushExitInConsoleBuffer ();
    }

    /**
        Merging environment is required if
        (1). Not the first comamnd &&
        (2). NTVDM is running on an existing console ||
             NTVDM has been shelled out.
        Note that WOW doesn't need enviornment merging.
    **/
    if (!DosEnvCreated && !IsFirstCall && (!DosSessionId || Exe32ActiveCount)) {
        RtlZeroMemory(&MyVDMInfo, sizeof(VDMINFO));
        MyVDMInfo.VDMState = ASKING_FOR_ENVIRONMENT | ASKING_FOR_DOS_BINARY;
        if (IsRepeatCall) {
            MyVDMInfo.VDMState |= ASKING_FOR_SECOND_TIME;
            MyVDMInfo.ErrorCode = 0;
        }
        else
            MyVDMInfo.ErrorCode = VDMInfo.ErrorCode;
        MyVDMInfo.Enviornment = lpszzVDMEnv32;
        MyVDMInfo.EnviornmentSize = (USHORT) cchVDMEnv32;
        if (!GetNextVDMCommand(&MyVDMInfo) && MyVDMInfo.EnviornmentSize > cchVDMEnv32) {
            MyVDMInfo.Enviornment = realloc(lpszzVDMEnv32, MyVDMInfo.EnviornmentSize);
            if (MyVDMInfo.Enviornment == NULL) {
                RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                TerminateVDM();
            }
            lpszzVDMEnv32 = MyVDMInfo.Enviornment;
            cchVDMEnv32 = MyVDMInfo.EnviornmentSize;
            MyVDMInfo.VDMState = ASKING_FOR_DOS_BINARY | ASKING_FOR_ENVIRONMENT |
                                 ASKING_FOR_SECOND_TIME;

            MyVDMInfo.TitleLen =
            MyVDMInfo.DesktopLen =
            MyVDMInfo.ReservedLen =
            MyVDMInfo.CmdSize =
            MyVDMInfo.AppLen =
            MyVDMInfo.PifLen =
            MyVDMInfo.CurDirectoryLen = 0;
            MyVDMInfo.ErrorCode = 0;
            if (!GetNextVDMCommand(&MyVDMInfo)) {
                RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
                TerminateVDM();
            }
        }
        if (!cmdCreateVDMEnvironment(&cmdVDMEnvBlk)) {
            RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
            TerminateVDM();
        }
        DosEnvCreated = TRUE;
        VDMInfo.ErrorCode = 0;
    }
    if (cmdVDMEnvBlk.cchEnv > FETCHWORD(pCMDInfo->EnvSize)) {
        setAX((USHORT)cmdVDMEnvBlk.cchEnv);
        setCF(1);
        IsFirstCall = FALSE;
        IsRepeatCall = TRUE;
#if defined(NEC_98)
        cmdInitConsole();
#endif // NEC_98
        return;
    }
    if (DosEnvCreated)
        VDMInfo.VDMState |= ASKING_FOR_SECOND_TIME;

    if(!GetNextVDMCommand(&VDMInfo)){
       RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
       TerminateVDM();
    }


    IsRepeatCall = FALSE;
    IsFirstCall = FALSE;

    if(fBlock){
#if defined(NEC_98)
        if (!VDMForWOW) { // BugFix: Change IME status by Screen Saver of 16bit
            saveCP = GetConsoleCP();
            saveOutputCP = GetConsoleOutputCP();
            SetConsoleCP(932);
            SetConsoleOutputCP(932);
        }
#endif // NEC_98
         nt_resume_event_thread();
         fBlock = FALSE;
    }

    // Sync VDMs enviornment variables for current directories
    cmdSetDirectories (lpszzVDMEnv32, &VDMInfo);

    // tell DOS that this is a dos executable and no further checking is
    // necessary
    *pIsDosBinary = 1;


    // Check for PIF files. If a pif file is being executed extract the
    // executable name, command line, current directory and title from the pif
    // file and place the stuff appropriately in VDMInfo. Note, if pif file
    // is invalid, we dont do any thing to vdminfo. In such a case we
    // pass the pif as it is to scs to execute which we know will fail and
    // will come back to cmdGettNextCmd with proper error code.

    cmdCheckForPIF (&VDMInfo);

    //
    // if forcedos, then don't check binary type on int 21 exec process,
    // so that child spawns stay in dos land. Begining with NT 4.0 forcedos.exe
    // no longer uses pif files to force execution of a binary as a dos exe.
    // It now uses a bit in CreateProcess (dwCreationFlags).
    //

    DontCheckDosBinaryType = (VDMInfo.dwCreationFlags & CREATE_FORCEDOS) != 0;


    // convert exec path name to upper case. This is what command.com expect
    if (WOW32_strupr(VDMInfo.AppName) == NULL) {
       pSrc = VDMInfo.AppName;
       while (*pSrc)
            *pSrc++ = (char)toupper((int)*pSrc);
    }
    // figure out the extention type
    // at least one char for the base name plus
    // EXTENTION_STRING_LEN for the extention
    // plus the NULL char
    if (VDMInfo.AppLen > 1 + EXTENTION_STRING_LEN  + 1) {
        pSrc = (PCHAR)VDMInfo.AppName + VDMInfo.AppLen - 5;
        if (!strncmp(pSrc, EXE_EXTENTION_STRING, EXTENTION_STRING_LEN))
            STOREWORD(pCMDInfo->ExecExtType, EXE_EXTENTION);
        else if (!strncmp(pSrc, COM_EXTENTION_STRING, EXTENTION_STRING_LEN))
            STOREWORD(pCMDInfo->ExecExtType, COM_EXTENTION);
        else if (!strncmp(pSrc, BAT_EXTENTION_STRING, EXTENTION_STRING_LEN))
            STOREWORD(pCMDInfo->ExecExtType, BAT_EXTENTION);
        else
            STOREWORD(pCMDInfo->ExecExtType, UNKNOWN_EXTENTION);
    }
    else
        STOREWORD(pCMDInfo->ExecExtType, UNKNOWN_EXTENTION);

    // tell command.com the length of the app full path name.
    STOREWORD(pCMDInfo->ExecPathSize, VDMInfo.AppLen);

    //
    // Prepare ccom's UCOMBUF
    //
    lpszCmd = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->CmdLineSeg),
                                FETCHWORD(pCMDInfo->CmdLineOff));

    // Copy filepart of AppName excluding extension to ccom's buffer
    pSrc = strrchr(VDMInfo.AppName, '\\');

#if defined(KOREA)
    // To fix HaNa spread sheet IME hotkey problem.
    {
    LPSTR pStrt, pEnd;
    char  szModName[9];
    SHORT len;

    pStrt = pSrc;

    if (pStrt==NULL)
        pStrt = VDMInfo.AppName;
    else
        pStrt++;

    if ( (pEnd = strchr (pStrt, '.')) == NULL)
        strncpy (szModName, pStrt, 9);

    else {
        len = (SHORT) (pEnd - pStrt);
        if (len<=8) {
            strncpy (szModName, pStrt, len);
            szModName[len] = '\0';
        }
    }

    bIgnoreExtraKbdDisable = !(strcmp("HANASP", szModName));

    }
#endif
    if (!pSrc) {
         pSrc = VDMInfo.AppName;
        }
    else {
         pSrc++;
        }
    pDst = lpszCmd + 2;
    while (*pSrc && *pSrc != '.') {
         *pDst++ = *pSrc++;
         }
    cb = strlen(CmdLine);

    // cmd line must be terminated with "\0xd\0xa\0". This is either done
    // by BASE or cmdCheckForPif function(cmdpif.c).

    ASSERT((cb >= 2) && (0xd == CmdLine[cb - 2]) && (0xa == CmdLine[cb - 1]));

    // if cmd line is not blank, separate program base name and
    // cmd line with a SPACE. If it IS blank, do not insert any white chars
    // or we end up passing white chars to the applications as cmd line
    // and some applications just can not live with that.
    // We do not strip leading white characters in the passed command line
    // so the application sees the original data.
    if (cb > 2)
        *pDst++ = ' ';

    // append the command tail(at least, "\0xd\0xa")
    strncpy(pDst, CmdLine, cb + 1);

    // set the count
    // cb has the cmd line length including the terminated 0xd and 0xa
    // It does NOT count the terminated NULL char.
    ASSERT((cb + pDst - lpszCmd - 2) <= 127);

    // minus 2 because the real data in lpszCmd start from lpszCmd[2]
    lpszCmd[1] = (CHAR)(cb + pDst - lpszCmd - 2);



    if (DosEnvCreated) {
        VDMInfo.Enviornment = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->EnvSeg),0);
        RtlMoveMemory(VDMInfo.Enviornment,
                      cmdVDMEnvBlk.lpszzEnv,
                      cmdVDMEnvBlk.cchEnv
                     );
        STOREWORD(pCMDInfo->EnvSize,cmdVDMEnvBlk.cchEnv);
        free(cmdVDMEnvBlk.lpszzEnv);
        DosEnvCreated = FALSE;
    }

    STOREWORD(pCMDInfo->fBatStatus,(USHORT)VDMInfo.fComingFromBat);
    STOREWORD(pCMDInfo->CurDrive,VDMInfo.CurDrive);
    STOREWORD(pCMDInfo->NumDrives,nDrives);
    VDMInfo.CodePage = (ULONG) cmdMapCodePage (VDMInfo.CodePage);
    STOREWORD(pCMDInfo->CodePage,(USHORT)VDMInfo.CodePage);

    cmdVDMEnvBlk.lpszzEnv = NULL;
    cmdVDMEnvBlk.cchEnv = 0;

    IsFirstVDM = FALSE;

    // Handle Standard IO redirection
    pRdrInfo = cmdCheckStandardHandles (&VDMInfo,&pCMDInfo->bStdHandles);
    STOREDWORD(pCMDInfo->pRdrInfo,(ULONG)pRdrInfo);

    // Tell DOS that it has to invalidate the CDSs
    *pSCS_ToSync = (CHAR)0xff;
    setCF(0);

#if defined(NEC_98)
        cmdInitConsole();
#endif // NEC_98
    return;
}



VOID GetWowKernelCmdLine(VOID)
{
CMDINFO UNALIGNED *pCMDInfo;
PCHAR    pch, pEnvStrings;
PCHAR    pSlash;
int      Len;
LPSTR    pszCmdLine;


    DeleteConfigFiles();   // get rid of the temp boot files
    host_lpt_flush_initialize();

    //
    // Only a few things need be set for WOW.
    //   1. NumDrives
    //   2. Kernel CmdLine (get from ntvdm command tail)
    //   3. Current drive
    //
    //  Command.com has setup correct enviroment block at
    //  this moment, so don't bother to mess with environment stuff.

    pCMDInfo = (LPVOID) GetVDMAddr ((USHORT)getDS(),(USHORT)getDX());
    pCMDInfo->NumDrives = nDrives;

    //
    // Get the command line parameter, which consists of a fully
    // qualified short path file name: "-a %SystemRoot%\system32\krnl386.exe".
    //
    // Note that the first token of cmdline is "%SystemRoot%\system32\ntvdm ",
    // and may be a long file name surrounded by quotes.
    //
    pszCmdLine = GetCommandLine();
    if (pszCmdLine) {

        // skip leading spaces
        while (*pszCmdLine && !isgraph(*pszCmdLine)) {
               pszCmdLine++;
               }

        // skip first token
        if (*pszCmdLine == '"') {
            pszCmdLine++;
            while (*pszCmdLine && *pszCmdLine++ != '"')
                   ;
            }
        else {
            while (isgraph(*pszCmdLine)) {
                   pszCmdLine++;
                   }
            }

        // mov to beg of WowKernelPathName
        pszCmdLine = strstr(pszCmdLine, " -a ");
        pszCmdLine += 4;
        while (*pszCmdLine && *pszCmdLine == ' ') {
               pszCmdLine++;
        }
    }

    if (!pszCmdLine || !*pszCmdLine) {
        RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
        TerminateVDM();
    }


    //
    // Copy first token to ExecPath, and find the beg of the file part.
    //
    Len = FETCHWORD(pCMDInfo->ExecPathSize);
    pch = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->ExecPathSeg),
                            FETCHWORD(pCMDInfo->ExecPathOff));

    pSlash = pszCmdLine;
    while (--Len && isgraph(*pszCmdLine)) {
         if (*pszCmdLine == '\\') {
             pSlash = pszCmdLine + 1;
         }
         *pch++ = *pszCmdLine++;
    }
    *pch = '\0';
    pCMDInfo->ExecPathSize -= (USHORT)Len;
    pCMDInfo->ExecExtType = EXE_EXTENTION; // for WOW, use EXE extention

    pszCmdLine = pSlash;              // filepart begins here


    //
    // Copy filepart of first token and rest to CmdLine buffer
    //
    Len = FETCHWORD(pCMDInfo->CmdLineSize);
    pch = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->CmdLineSeg),
                            FETCHWORD(pCMDInfo->CmdLineOff));

    while (--Len && *pszCmdLine) {
         *pch++ = *pszCmdLine++;
    }
    strcpy(pch, "\x0d\x0a");


    *pIsDosBinary = 1;
    IsRepeatCall = FALSE;
    IsFirstCall = FALSE;

    // Tell DOS that it has to invalidate the CDSs
    *pSCS_ToSync = (CHAR)0xff;
    setCF(0);

    return;
}


/* cmdGetCurrentDir - Return the current directory for a drive.
 *
 *
 *  Entry - Client (DS:SI) - buffer to return the directory
 *          Client (AL)   - drive being queried (0 = A)
 *
 *  EXIT  - SUCCESS Client (CY) clear
 *          FAILURE Client (CY) set
 *                         (AX) = 0 (Directory was bigger than 64)
 *                         (AX) = 1 (the drive is not valid)
 *
 */

VOID cmdGetCurrentDir (VOID)
{
PCHAR lpszCurDir;
UCHAR chDrive;
CHAR  EnvVar[] = "=?:";
CHAR  RootName[] = "?:\\";
DWORD EnvVarLen;
UINT  DriveType;


    lpszCurDir = (PCHAR) GetVDMAddr ((USHORT)getDS(),(USHORT)getSI());
    chDrive = getAL();
    EnvVar[1] = chDrive + 'A';
    RootName[0] = chDrive + 'A';

    // if the drive doesn't exist, blindly clear the environment var
    // and return error
    DriveType = demGetPhysicalDriveType(chDrive);
    if (DriveType == DRIVE_UNKNOWN) {
        DriveType = GetDriveTypeOem(RootName);
        }

    if (DriveType == DRIVE_UNKNOWN || DriveType == DRIVE_NO_ROOT_DIR){
        SetEnvironmentVariableOem(EnvVar, NULL);
        setCF(1);
        setAX(0);
        return;
    }

    if((EnvVarLen = GetEnvironmentVariableOem (EnvVar,lpszCurDir,
                                            MAXIMUM_VDM_CURRENT_DIR+3)) == 0){

        // if its not in env then and drive exist then we have'nt
        // yet touched it.
        strcpy(lpszCurDir, RootName);
        SetEnvironmentVariableOem (EnvVar,RootName);
        setCF(0);
        return;
    }
    if (EnvVarLen > MAXIMUM_VDM_CURRENT_DIR+3) {
        setCF(1);
        setAX(0);
    }
    else {
        setCF(0);
    }
    return;
}

/* cmdSetInfo -     Set the address of SCS_ToSync variable in DOSDATA.
 *                  This variable is set whenever SCS dispatches a new
 *                  command to command.com. Setting of this variable
 *                  indicates to dos to validate all the CDS structures
 *                  for local drives.
 *
 *
 *  Entry - Client (DS:DX) - pointer to SCSINFO.
 *
 *  EXIT  - None
 */

VOID cmdSetInfo (VOID)
{

    pSCSInfo = (PSCSINFO) GetVDMAddr (getDS(),getDX());

    pSCS_ToSync  =  (PCHAR) &pSCSInfo->SCS_ToSync;

    pIsDosBinary = (BYTE *) GetVDMAddr(getDS(), getBX());

    pFDAccess = (WORD *) GetVDMAddr(getDS(), getCX());
    return;
}


VOID cmdSetDirectories (PCHAR lpszzEnv, VDMINFO * pVdmInfo)
{
LPSTR   lpszVal;
CHAR    ch, chDrive, achEnvDrive[] = "=?:";

    ch = pVdmInfo->CurDrive + 'A';
    if (pVdmInfo->CurDirectoryLen != 0){
        SetCurrentDirectory(pVdmInfo->CurDirectory);
        achEnvDrive[1] = ch;
        SetEnvironmentVariable(achEnvDrive, pVdmInfo->CurDirectory);
    }
    if (lpszzEnv) {
        while(*lpszzEnv) {
            if(*lpszzEnv == '=' &&
                    (chDrive = (CHAR)toupper(*(lpszzEnv+1))) >= 'A' &&
                    chDrive <= 'Z' &&
                    (*(PCHAR)((ULONG)lpszzEnv+2) == ':') &&
                    chDrive != ch) {
                    lpszVal = (PCHAR)((ULONG)lpszzEnv + 4);
                    achEnvDrive[1] = chDrive;
                    SetEnvironmentVariable (achEnvDrive,lpszVal);
            }
            lpszzEnv = strchr(lpszzEnv,'\0');
            lpszzEnv++;
        }
    }
}

static BOOL fConOutput = FALSE;

VOID cmdComSpec (VOID)
{
LPSTR   lpszCS;


    if(IsFirstCall == FALSE)
        return;

    lpszCS =    (LPVOID) GetVDMAddr ((USHORT)getDS(),(USHORT)getDX());
    strcpy(lpszComSpec,"COMSPEC=");
    strcpy(lpszComSpec+8,lpszCS);
    cbComSpec = strlen(lpszComSpec) +1;

    setAL((BYTE)(!fConOutput || VDMForWOW));

    return;
}


VOID cmdSaveWorld (VOID)
{
#ifdef CHECK_IT_LATER
SAVEWORLD VDMState;
HANDLE  hFile;
PCHAR   pVDM;
DWORD   dwBytesWritten;

    if(IsFirstVDMInSystem) {
        IsFirstVDMInSystem = FALSE;
        if ((hFile = CreateFile("c:\\nt\\bin86\\savevdm.wld",
                            GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_ALWAYS,
                            0,
                            NULL)) == (HANDLE)-1){
            SaveWorldCreated = FALSE;
            return;
        }
        VDMState.ax    =    getAX();
        VDMState.bx    =    getBX();
        VDMState.cx    =    getCX();
        VDMState.dx    =    getDX();
        VDMState.cs    =    getCS();
        VDMState.ss    =    getSS();
        VDMState.ds    =    getDS();
        VDMState.es    =    getES();
        VDMState.si    =    getSI();
        VDMState.di    =    getDI();
        VDMState.bp    =    getBP();
        VDMState.sp    =    getSP();
        VDMState.ip    =    getIP() + 1;
        VDMState.flag  =    0;
        VDMState.ImageSize = 1024*1024;

        pVDM = (PVOID)GetVDMAddr(0,0);

        if (WriteFile (hFile,
                       (LPVOID)&VDMState,
                       (DWORD)sizeof(VDMState),
                       &dwBytesWritten,
                       NULL) == FALSE){
            SaveWorldCreated = FALSE;
            CloseHandle(hFile);
            return;
        }

        if (WriteFile (hFile,
                       (LPVOID)pVDM,
                       (DWORD)VDMState.ImageSize,
                       &dwBytesWritten,
                       NULL) == FALSE){
            SaveWorldCreated = FALSE;
            CloseHandle(hFile);
            return;
        }
        CloseHandle(hFile);
    }
#endif
    return;
}


/* cmdInitConsole - Let Video VDD know that it can start console output
 *                  operations.
 *
 *
 *  Entry - None
 *
 *
 *  EXIT  - None
 *
 */

VOID cmdInitConsole (VOID)
{
    if (fConOutput == FALSE) {
        fConOutput = TRUE;
        nt_init_event_thread ();
        }
    return;
}


/* cmdMapCodePage - Map the Win32 Code page to DOS code page
 */

USHORT cmdMapCodePage (ULONG CodePage)
{
    // Currently We understand US code page only
    if (CodePage == 1252)
        return 437;
    else
        return ((USHORT)CodePage);
}



/* GetWOWShortCutInfo - returns the startupinf.reserved field of
 *                      vdminfo for the first wow task.
 *
 * Input - Bufsize - pointer to bufsize
 *         Buf     - buffer where the info is returned
 *
 * Output
 *        Success - returns TRUE, BufSize has the length of buffer filled in
 *        Failure - returns FALSE, Bufsize has the required buffer size.
 */

BOOL GetWOWShortCutInfo (PULONG Bufsize, PVOID Buf)
{
    if (*Bufsize >= VDMInfo.ReservedLen) {
        *Bufsize =  VDMInfo.ReservedLen;
        if (Bufsize)
            strncpy (Buf, VDMInfo.Reserved, VDMInfo.ReservedLen);
        return TRUE;
    }
    else {
        *Bufsize =  VDMInfo.ReservedLen;
        return FALSE;
    }
}

VOID cmdUpdateCurrentDirectories(BYTE CurDrive)
{
    DWORD cchRemain, cchCurDir;
    CHAR *lpszCurDir;
    BYTE Drive;
    DWORD DriveType;
    CHAR achName[] = "=?:";
    CHAR RootName[] = "?:\\";


    // allocate new space for the new current directories
    lpszzCurrentDirectories = (CHAR*) malloc(MAX_PATH);
    cchCurrentDirectories = 0;
    cchRemain = MAX_PATH;
    lpszCurDir = lpszzCurrentDirectories;
    if (lpszCurDir != NULL) {
        Drive = 0;
        // current directory is the first entry
        achName[1] = CurDrive + 'A';
        cchCurrentDirectories = GetEnvironmentVariable(
                                                        achName,
                                                        lpszCurDir,
                                                        cchRemain
                                                      );

        if (cchCurrentDirectories == 0 || cchCurrentDirectories > MAX_PATH) {
            free(lpszzCurrentDirectories);
            lpszzCurrentDirectories = NULL;
            cchCurrentDirectories = 0;
            return;
        }

        cchRemain -= ++cchCurrentDirectories;
        // we got current directory already. Keep the drive number
        lpszCurDir += cchCurrentDirectories;

        while (Drive < 26) {

            // ignore invalid drives and current drive
            if (Drive != CurDrive) {
                DriveType = demGetPhysicalDriveType(Drive);
                if (DriveType == DRIVE_UNKNOWN) {
                    RootName[0] = (CHAR)('A' + Drive);
                    DriveType = GetDriveTypeOem(RootName);
                }

                if (DriveType != DRIVE_UNKNOWN &&
                    DriveType != DRIVE_NO_ROOT_DIR )
                 {
                    achName[1] = Drive + 'A';
                    cchCurDir = GetEnvironmentVariable(
                                                       achName,
                                                       lpszCurDir,
                                                       cchRemain
                                                       );
                    if(cchCurDir > cchRemain) {
                        lpszCurDir = (CHAR *)realloc(lpszzCurrentDirectories,
                                                     cchRemain + MAX_PATH + cchCurrentDirectories
                                                     );
                        if (lpszCurDir == NULL) {
                            free(lpszzCurrentDirectories);
                            lpszzCurrentDirectories = NULL;
                            cchCurrentDirectories = 0;
                            return;
                        }
                        lpszzCurrentDirectories = lpszCurDir;
                        lpszCurDir += cchCurrentDirectories;
                        cchRemain += MAX_PATH;
                        cchCurDir = GetEnvironmentVariable(
                                                           achName,
                                                           lpszCurDir,
                                                           cchRemain
                                                           );
                    }
                    if (cchCurDir != 0) {
                        // GetEnvironmentVariable doesn't count the NULL char
                        lpszCurDir += ++cchCurDir;
                        cchRemain -= cchCurDir;
                        cchCurrentDirectories += cchCurDir;
                    }
                }
            }
            // next drive
            Drive++;
        }


        lpszCurDir = lpszzCurrentDirectories;
        // need space for the ending NULL and shrink the space if necessary
        lpszzCurrentDirectories = (CHAR *) realloc(lpszCurDir, cchCurrentDirectories + 1);
        if (lpszzCurrentDirectories != NULL && cchCurrentDirectories != 0){
            lpszzCurrentDirectories[cchCurrentDirectories++] = '\0';
            SetVDMCurrentDirectories(cchCurrentDirectories, lpszzCurrentDirectories);
            free(lpszzCurrentDirectories);
            lpszzCurrentDirectories = NULL;
            cchCurrentDirectories = 0;
        }
        else {
            free(lpszCurDir);
            cchCurrentDirectories = 0;
        }

    }
}

/* This SVC function tells command.com, if the VDM was started without an
 * existing console. If so, on finding a TSR, command.com will return
 * back to GetNextVDMCommand, rather than putting its own popup.
 *
 * Entry - None
 *
 * Exit  - Client (AL) = 0 if started with an existing console
 *         Client (AL) = 1 if started with new console
 */

VOID cmdGetStartInfo (VOID)
{
    setAL((BYTE) (DosSessionId ? 1 : 0));
    return;
}

#ifdef DBCS     // this should go to US build also
/* This SVC function changes the window title. This function get called
 * from command.com when TSRs are installed and scs_cmdprompt is off
 * (command.com does its prompt).
 *
 * Entry - Client (AL) = 0, restore bare title
 *         Client (AL) != 1, set new program title,
 *                           DS:SI point to a CRLF terminated program name
 *
 * Exit  - none
 *
 */

 VOID cmdSetWinTitle(VOID)
 {
    static CHAR achCommandPrompt[64] = {'\0'};

    CHAR    achBuf[256], *pch, *pch1;

    if (achCommandPrompt[0] == '\0') {
        if (!LoadString(GetModuleHandle(NULL),
                        IDS_PROMPT,
                        achCommandPrompt,
                        64
                       ))
            strcpy(achCommandPrompt, "Command Prompt");

    }
    if (getAL() == 0)
        SetConsoleTitleA(achCommandPrompt);
    else {
        pch = (CHAR *)GetVDMAddr(getDS(), getSI());
        pch1 = strchr(pch, 0x0d);
        if (pch1 == NULL)
            SetConsoleTitleA(achCommandPrompt);
        else {
            *pch1 = '\0';
            strcpy(achBuf, achCommandPrompt);
            strcat(achBuf, " - ");
            strcat(achBuf, pch);
            *pch1 = 0x0d;
            SetConsoleTitleA(achBuf);
        }
    }
 }
#endif // DBCS

#if defined(NEC_98)
/* cmdGetCursorPos -
 *
 *
 *  Entry - None
 *
 *
 *  EXIT  - DX cursor position
 *
 */

VOID cmdGetCursorPos(VOID)
{
        setDX( (USHORT)(nt_get_cursor_pos()));
        return;
}

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdenv.c ===
/*  cmdenv.c - Environment supporting functions for command.lib
 *
 *
 *  Modification History:
 *
 *  williamh 13-May-1993 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <demexp.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <memory.h>
#include <oemuni.h>

#include <userenv.h>
#include <userenvp.h>

#define VDM_ENV_INC_SIZE    512

CHAR windir[] = "windir";
extern BOOL fSeparateWow;

// These two functions are temp var filtering instruments
//
//

VOID cmdCheckTempInit(VOID);
LPSTR cmdCheckTemp(LPSTR lpszzEnv);

// Transform the given DOS environment to 32bits environment.
// WARNING!! The environment block we passed to 32bits must be in sort order.
//           Therefore, we call RtlSetEnvironmentVariable to do the work
// The result string must be in ANSI character set.
BOOL    cmdXformEnvironment(PCHAR pEnv16, PANSI_STRING Env_A)
{
    UNICODE_STRING  Name_U, Value_U, Temp_U;
    STRING          String;
    PWCHAR          pwch, NewEnv, CurEnv, CurEnvCopy, pTmp;
    NTSTATUS        Status;
    BOOL            fFoundComSpec;
    USHORT          NewEnvLen;
    PCHAR           pEnv;
    DWORD           Length;

    if (pEnv16 == NULL)
        return FALSE;

    // flag true if we alread found comspec envirnment
    // !!!! Do we allow two or more comspec in environment????????
    fFoundComSpec = FALSE;

    CurEnv = GetEnvironmentStringsW();
    pwch = CurEnv;
    // figure how long the environment strings is
    while (*pwch != UNICODE_NULL || *(pwch + 1) != UNICODE_NULL)
        pwch++;

    // plus 2  to include the last two NULL chars
    CurEnvCopy = malloc((pwch - CurEnv + 2) * sizeof(WCHAR));
    if (!CurEnvCopy)
        return FALSE;

    // make a copy of current process environment so we can walk through
    // it. The environment can be changed by any threads in the process
    // thus is not safe to walk through without a local copy
    RtlMoveMemory(CurEnvCopy, CurEnv, (pwch - CurEnv + 2) * sizeof(WCHAR));

    // create a new environment block. We don't want to change
    // any currnt process environment variables, instead, we are
    // preparing a new one for the new process.
    Status = RtlCreateEnvironment(FALSE, (PVOID *)&NewEnv);
    if (!NT_SUCCESS(Status)) {
        free(CurEnvCopy);
        return FALSE;
    }
    NewEnvLen = 0;
    // now pick up environment we want from the current environment
    // and set it to the new environment block
    // the variables we want:
    // (1). comspec
    // (2). current directories settings

    pwch = CurEnvCopy;

    while (*pwch != UNICODE_NULL) {
        if (*pwch == L'=') {
            // variable names started with L'=' are current directroy settings
            pTmp = wcschr(pwch + 1, L'=');
            if (pTmp) {
                Name_U.Buffer = pwch;
                Name_U.Length = (pTmp - pwch) * sizeof(WCHAR);
                RtlInitUnicodeString(&Value_U, pTmp + 1);
                Status = RtlSetEnvironmentVariable(&NewEnv, &Name_U, &Value_U);
                if (!NT_SUCCESS(Status)) {
                    RtlDestroyEnvironment(NewEnv);
                    free(CurEnvCopy);
                    return FALSE;
                }
                // <name> + <'='> + <value> + <'\0'>
                NewEnvLen += Name_U.Length + Value_U.Length + 2 * sizeof(WCHAR);
            }
        }
        else if (!fFoundComSpec) {
                fFoundComSpec = !_wcsnicmp(pwch, L"COMSPEC=", 8);
                if (fFoundComSpec) {
                    Name_U.Buffer = pwch;
                    Name_U.Length = 7 * sizeof(WCHAR);
                    RtlInitUnicodeString(&Value_U, pwch + 8);
                    Status = RtlSetEnvironmentVariable(&NewEnv,
                                                       &Name_U,
                                                       &Value_U
                                                       );
                    if (!NT_SUCCESS(Status)) {
                        RtlDestroyEnvironment(NewEnv);
                        free(CurEnvCopy);
                        return FALSE;
                    }
                    NewEnvLen += Name_U.Length + Value_U.Length + 2 * sizeof(WCHAR);
                }
        }
        pwch += wcslen(pwch) + 1;
    }
    // we are done with current process environment.
    free(CurEnvCopy);

    cmdCheckTempInit();

    // now deal with 16bits settings passed from dos.
    // characters in 16bits environment are in OEM character set

    // 16bit comspec environment variable
    fFoundComSpec = FALSE;
    while (*pEnv16 != '\0') {

        if (NULL != (pEnv = cmdCheckTemp(pEnv16))) {
           RtlInitString(&String, pEnv);
           Length = strlen(pEnv16);
        }
        else {
           RtlInitString(&String, pEnv16);
           Length = String.Length;
        }

        // discard 16bits comspec
        if (!fFoundComSpec) {
            fFoundComSpec = !_strnicmp(pEnv16, comspec, 8);
            if (fFoundComSpec) {
                // ignore 16bits comspec environment
                pEnv16 += Length + 1;
                continue;
            }
        }
        Status = RtlOemStringToUnicodeString(&Temp_U, &String, TRUE);
        if (!NT_SUCCESS(Status)) {
            RtlDestroyEnvironment(NewEnv);
            return FALSE;
        }
        pwch = wcschr(Temp_U.Buffer, L'=');
        if (pwch) {
            Name_U.Buffer = Temp_U.Buffer;
            Name_U.Length = (pwch - Temp_U.Buffer) * sizeof(WCHAR);
            RtlInitUnicodeString(&Value_U, pwch + 1);
            Status = RtlSetEnvironmentVariable( &NewEnv, &Name_U, &Value_U);
            RtlFreeUnicodeString(&Temp_U);
            if (!NT_SUCCESS(Status)) {
                RtlDestroyEnvironment(NewEnv);
                return FALSE;
            }
            NewEnvLen += Name_U.Length + Value_U.Length + 2 * sizeof(WCHAR);
        }
        pEnv16 += Length + 1;
    }
    // count the last terminated null char
    Temp_U.Length = NewEnvLen + sizeof(WCHAR);
    Temp_U.Buffer = NewEnv;
    Status = RtlUnicodeStringToAnsiString(Env_A, &Temp_U, TRUE);
    RtlDestroyEnvironment(NewEnv);      /* don't need it anymore */
    return(NT_SUCCESS(Status));
}


CHAR* cmdFilterTempEnvironmentVariables(CHAR* lpzzEnv, DWORD cchInit)
{
   PCHAR pTmp;
   PCHAR lpzzEnv32;
   DWORD cchRemain = cchInit;
   DWORD cchIncrement = MAX_PATH;
   DWORD Len, LenTmp;
   DWORD Offset = 0;

   lpzzEnv32 = (PCHAR)malloc(cchInit);
   if (NULL == lpzzEnv32) {
      return(NULL);
   }

   cmdCheckTempInit();

   while('\0' != *lpzzEnv) {
      LenTmp = Len = strlen(lpzzEnv) + 1;

      // now copy the string
      if (NULL != (pTmp = cmdCheckTemp(lpzzEnv))) {
         LenTmp = strlen(pTmp) + 1;
      }
      else {
         pTmp = lpzzEnv;
      }

      if (cchRemain < (LenTmp + 1)) {
         if (cchIncrement < LenTmp) {
            cchIncrement = LenTmp;
         }

         lpzzEnv32 = (PCHAR)realloc(lpzzEnv32, cchInit + cchIncrement);
         if (NULL == lpzzEnv32) {
            return(NULL);
         }

         cchInit += cchIncrement;
         cchRemain += cchIncrement;
      }

      strcpy(lpzzEnv32 + Offset, pTmp);

      Offset += LenTmp;
      cchRemain -= LenTmp;
      lpzzEnv += Len;
   }

   *(lpzzEnv32 + Offset) = '\0';
   return(lpzzEnv32);

}



/* get ntvdm initial environment. This initial environment is necessary
 * for the first instance of command.com before it processing autoexec.bat
 * this function strips off an environment headed with "=" and
 * replace the comspec with 16bits comspec and upper case all environment vars.
 *
 * Entry: Client (ES:0) = buffer to receive the environment
 *        Client (BX) = size in paragraphs of the given buffer
 *
 * Exit:  (BX) = 0 if nothing to copy
 *        (BX)  <= the given size, function okay
 *        (BX) > given size, (BX) has the required size
 */

VOID cmdGetInitEnvironment(VOID)
{
    CHAR *lpszzEnvBuffer, *lpszEnv;
    WORD cchEnvBuffer;
    CHAR *lpszzEnvStrings, * lpszz;
    WORD cchString;
    WORD cchRemain;
    WORD cchIncrement = MAX_PATH;
    BOOL fFoundComSpec = FALSE;
    BOOL fFoundWindir = FALSE;
    BOOL fVarIsWindir = FALSE;

    // if not during the initialization return nothing
    if (!IsFirstCall) {
        setBX(0);
        return;
    }
    if (cchInitEnvironment == 0) {
        //
        // If the PROMPT variable is not set, add it as $P$G. This is to
        // keep the command.com shell consistent with SCS cmd.exe(which
        // always does this) when we don't have a top level cmd shell.
        //
        {
           CHAR *pPromptStr = "PROMPT";
           char ach[2];

           if (!GetEnvironmentVariable(pPromptStr,ach,1)) {
                SetEnvironmentVariable(pPromptStr, "$P$G");
           }
        }

        cchRemain = 0;
        fFoundComSpec = FALSE;
        lpszEnv =
        lpszzEnvStrings = GetEnvironmentStrings();
	if (!lpszzEnvStrings)
	{
	    // not enough memory
	    RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
			 RMB_ICON_BANG | RMB_ABORT);
	    TerminateVDM();
	}
        while (*lpszEnv) {
            cchString = strlen(lpszEnv) + 1;
            cchVDMEnv32 += cchString;
            lpszEnv += cchString;
        }
        lpszz = lpszzEnvStrings;

        if (lpszzVDMEnv32 != NULL)
            free(lpszzVDMEnv32);

        ++cchVDMEnv32;
        lpszzVDMEnv32 = cmdFilterTempEnvironmentVariables(lpszzEnvStrings, cchVDMEnv32);
        if (lpszzVDMEnv32 == NULL) {
            RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
                         RMB_ICON_BANG | RMB_ABORT);
            TerminateVDM();
        }

        lpszz = lpszzVDMEnv32; // we iterate through our copy


        // we have to form a presentable 32-bit environment
        // since we make our own copy -- deal with temp issues now


        // RtlMoveMemory(lpszzVDMEnv32, lpszzEnvStrings, cchVDMEnv32);

        while (*lpszz != '\0') {
            cchString = strlen(lpszz) + 1;
            if (*lpszz != '=') {

                if (!fFoundComSpec && !_strnicmp(lpszz, comspec, 8)){
                    fFoundComSpec = TRUE;
                    lpszz += cchString;
                    continue;
                }

                if (!fFoundWindir && !_strnicmp(lpszz, windir, 6)) {
                    fFoundWindir = TRUE;
                    if (fSeparateWow) {
                        // starting a separate WOW box - flag this one so its
                        // name won't be converted to uppercase later.
                        fVarIsWindir = TRUE;
                    } else {
                        // starting a DOS app, so remove "windir" to make sure
                        // they don't think they are running under Windows.
                        lpszz += cchString;
                        continue;
                    }
                }

                ///////////////////////// TEMP Var filtering ///////////////

                if (cchRemain < cchString) {
                    if (cchIncrement < cchString)
                        cchIncrement = cchString;
                    lpszzEnvBuffer =
                    (CHAR *)realloc(lpszzInitEnvironment,
                                    cchInitEnvironment + cchRemain + cchIncrement
                                    );
                    if (lpszzEnvBuffer == NULL) {
                        if (lpszzInitEnvironment != NULL) {
                            free(lpszzInitEnvironment);
                            lpszzInitEnvironment = NULL;
                        }
                        cchInitEnvironment = 0;
                        break;
                    }
                    lpszzInitEnvironment = lpszzEnvBuffer;
                    lpszzEnvBuffer += cchInitEnvironment;
                    cchRemain += cchIncrement;
                }
                // the environment strings from base is in ANSI and dos needs OEM
                AnsiToOemBuff(lpszz, lpszzEnvBuffer, cchString);
                // convert the name to upper case -- ONLY THE NAME, NOT VALUE.
                if (!fVarIsWindir && (lpszEnv = strchr(lpszzEnvBuffer, '=')) != NULL){
                    *lpszEnv = '\0';
                    _strupr(lpszzEnvBuffer);
                    *lpszEnv = '=';
                } else {
                    fVarIsWindir = FALSE;
                }
                cchRemain -= cchString;
                cchInitEnvironment += cchString ;
                lpszzEnvBuffer += cchString;
            }
            lpszz += cchString;
        }
        FreeEnvironmentStrings(lpszzEnvStrings);

        lpszzEnvBuffer = (CHAR *) realloc(lpszzInitEnvironment,
                                          cchInitEnvironment + 1
                                          );
        if (lpszzInitEnvironment != NULL ) {
            lpszzInitEnvironment = lpszzEnvBuffer;
            lpszzInitEnvironment[cchInitEnvironment++] = '\0';
        }
        else {
            if (lpszzInitEnvironment != NULL) {
                free(lpszzInitEnvironment);
                lpszzInitEnvironment = NULL;
            }
            cchInitEnvironment = 0;
        }
    }
    lpszzEnvBuffer = (CHAR *) GetVDMAddr(getES(), 0);
    cchEnvBuffer =  (WORD)getBX() << 4;
    if (cchEnvBuffer < cchInitEnvironment + cbComSpec) {
        setBX((USHORT)((cchInitEnvironment + cbComSpec + 15) >> 4));
        return;
    }
    else {
        strncpy(lpszzEnvBuffer, lpszComSpec, cbComSpec);
        lpszzEnvBuffer += cbComSpec;
    }
    if (lpszzInitEnvironment != NULL) {
        setBX((USHORT)((cchInitEnvironment + cbComSpec + 15) >> 4));
        memcpy(lpszzEnvBuffer, lpszzInitEnvironment, cchInitEnvironment);
        free(lpszzInitEnvironment);
        lpszzInitEnvironment = NULL;
        cchInitEnvironment = 0;

    }
    else
        setBX(0);

    return;
}

CHAR szUserenv[] = "Userenv.dll";
CHAR szGetSystemTempDirectory[] = "GetSystemTempDirectoryA";
CHAR szHKTSTemp[] = "Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server";
CHAR szTSTempVal[] = "RootDrive";

typedef BOOL (WINAPI *PFNGETSYSTEMTEMPDIRECTORYA)(LPSTR lpDir, LPDWORD lpcchSize);

#define MAX_DOS_TEMPVAR_LENGTH 11


//
// this function is located in dem/demlfn.c
//
extern BOOL demIsShortPathName(LPSTR pszPath, BOOL fAllowWildCardName);


typedef enum tageSysRootType {
   _SYSTEMROOT,        // from systemroot env var
   _SYSTEMDRIVE,       // from systemdrive env var
   _ROOTDRIVE          // as specified in the buffer

}  SYSROOTTYPE;


BOOL cmdGetSystemrootTemp(LPSTR lpszBuffer, DWORD Length, SYSROOTTYPE SysRoot)
{
   CHAR *szTemp = "\\temp";
   CHAR *szSystemRoot  = "SystemRoot";
   CHAR *szSystemDrive = "SystemDrive";
   CHAR *szSystemVar;
   DWORD len = 0;
   DWORD dwAttributes = 0xffffffff;
   DWORD dwError = ERROR_SUCCESS;
   BOOL fRet = FALSE;

   if (_SYSTEMROOT == SysRoot || _SYSTEMDRIVE == SysRoot) {
      szSystemVar = _SYSTEMROOT == SysRoot ? szSystemRoot : szSystemDrive;

      len = GetEnvironmentVariable(szSystemVar, lpszBuffer, Length);
      if (!len || len >= Length || (len + strlen(szTemp)) >= Length) {
         return(FALSE);
      }


  }
   else if (_ROOTDRIVE == SysRoot) {
      // so we have to look up the registry and see
      HKEY hkey;
      LONG lError;
      DWORD dwType;

      lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            szHKTSTemp,
                            0,
                            KEY_QUERY_VALUE,
                            &hkey);
      if (ERROR_SUCCESS == lError) {
         len = Length;
         lError = RegQueryValueEx(hkey,
                                  szTSTempVal,
                                  NULL,
                                  &dwType,
                                  lpszBuffer,
                                  &len);
         RegCloseKey(hkey);
         if (ERROR_SUCCESS != lError || REG_SZ != dwType) {
            return(FALSE);
         }
         --len; // length not to include terminating 0
      }

   }

   if (*(lpszBuffer + len - 1) == '\\') {
       ++szTemp;
   }

   strcat(lpszBuffer, szTemp);

   len = GetShortPathName(lpszBuffer, lpszBuffer, Length);
   if (len > 0 && len < Length) {
      dwAttributes = GetFileAttributes(lpszBuffer);
   }

   if (0xffffffff == dwAttributes) {
      dwError = GetLastError();
      if (ERROR_PATH_NOT_FOUND == dwError || ERROR_FILE_NOT_FOUND == dwError) {
         // we create this temp
         fRet = CreateDirectory(lpszBuffer, NULL);
         if (fRet) {
            dwAttributes = GetFileAttributes(lpszBuffer);
         }
      }
   }

   if (0xffffffff != dwAttributes) {
      fRet = !!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY);
   }

   return(fRet);
}

#define FOUND_TMP  0x01
#define FOUND_TEMP 0x02

#define GETSYSTEMTEMPDIRECTORYAORD 125
#define GETSYSTEMTEMPDIRECTORYWORD 126

DWORD gfFoundTmp = 0;


BOOL cmdCreateTempEnvironmentVar(
LPSTR lpszTmpVar,  // temp variable (or just it's name)
DWORD Length,      // the length of TmpVar or 0
LPSTR lpszBuffer,  // buffer containing
DWORD LengthBuffer
)
{
   PCHAR pch;
   PFNGETSYSTEMTEMPDIRECTORYA pfnGetSystemTempDirectoryA;
   HANDLE hUserenv;
   BOOL fSysTemp = FALSE;
   DWORD LengthTemp;

   if (NULL != (pch = strchr(lpszTmpVar, '='))) {
      // we have a var to check

      LengthTemp = (DWORD)(pch - lpszTmpVar);

      ++pch;
      if (!Length) { // no length supplied
         Length = strlen(pch);
      }
      else {
         Length -= (DWORD)(pch - lpszTmpVar);
      }


      // pch points to a variable that is to be checked for being dos-compliant
      if (strlen(pch) <= MAX_DOS_TEMPVAR_LENGTH && demIsShortPathName(pch, FALSE)) {
         return(FALSE); // no need to create anything
      }
   }
   else {
      LengthTemp = strlen(lpszTmpVar);
   }


   strncpy(lpszBuffer, lpszTmpVar, LengthTemp);
   *(lpszBuffer + LengthTemp) =  '=';
   lpszBuffer += LengthTemp+1; // past =
   LengthBuffer -= LengthTemp+1;

   // see if there is a registry override, used for Terminal Server
   fSysTemp = cmdGetSystemrootTemp(lpszBuffer, LengthBuffer, _ROOTDRIVE);
   if (fSysTemp && strlen(lpszBuffer) <= MAX_DOS_TEMPVAR_LENGTH) {
      return(fSysTemp);
   }

   if (NULL != (hUserenv = LoadLibrary(szUserenv))) {
      pfnGetSystemTempDirectoryA =
               (PFNGETSYSTEMTEMPDIRECTORYA)GetProcAddress(hUserenv,
                                                          (LPCTSTR)MAKELONG(GETSYSTEMTEMPDIRECTORYAORD, 0));
                                                          /* szGetSystemTempDirectory); */
      if (NULL != pfnGetSystemTempDirectoryA) {
         LengthTemp = LengthBuffer;
         fSysTemp = (*pfnGetSystemTempDirectoryA)(lpszBuffer, &LengthTemp);
         if (fSysTemp) {
            fSysTemp = demIsShortPathName(lpszBuffer, FALSE);
         }
      }

      if (!fSysTemp) {
         fSysTemp = cmdGetSystemrootTemp(lpszBuffer, LengthBuffer, _SYSTEMROOT);
      }

      FreeLibrary(hUserenv);
   }

   return(fSysTemp);


}

VOID cmdCheckTempInit(VOID)
{
   gfFoundTmp = 0;
}

CHAR*rgpszLongPathNames[] = {
   "ALLUSERSPROFILE",
   "APPDATA",
   "COMMONPROGRAMFILES",
   "COMMONPROGRAMFILES(x86)",
   "PROGRAMFILES",
   "PROGRAMFILES(X86)",
   "SYSTEMROOT",
   "USERPROFILE",
   //build environment vars   
   "_NTTREE",
   "_NTX86TREE",
   "_NTPOSTBLD",
   "BINPLACE_EXCLUDE_FILE",
   "BINPLACE_LOG",
   "CLUSTERLOG",
   "INIT",
   "NTMAKEENV",
   "MSWNET",
   "PREFAST_ROOT",
   "RAZZLETOOLPATH",
   "SDXROOT"   
   };


BOOL cmdMakeShortEnvVar(LPSTR lpvarName, LPSTR lpvarValue, LPSTR lpszBuffer, DWORD Length)
{
   DWORD lName, lValue;

   lName = strlen(lpvarName);
   if (lName + 2 > Length ) {
      return(FALSE);
   }

   strcpy(lpszBuffer, lpvarName);
   *(lpszBuffer + lName) = '=';
   lpszBuffer += lName + 1;
   Length -= lName + 1;

   lValue = GetShortPathNameOem(lpvarValue, lpszBuffer, Length);
   return (0 != lValue && lValue <= Length);
}



LPSTR cmdCheckTemp(LPSTR lpszzEnv)
{
   CHAR *szTemp = "Temp";
   CHAR *szTmp  = "Tmp";
   static CHAR szTmpVarBuffer[MAX_PATH+1];
   LPSTR pszTmpVar = NULL;
   BOOL fSubst = FALSE;
   CHAR *peq;
   DWORD i;


   peq = strchr(lpszzEnv, '=');
   if (NULL == peq) {
      return(NULL);
   }

   for (i = 0; i < sizeof(rgpszLongPathNames)/sizeof(rgpszLongPathNames[0]);++i) {
      INT llpn = strlen(rgpszLongPathNames[i]);
      if (!_strnicmp(lpszzEnv, rgpszLongPathNames[i], llpn) &&
          (llpn == (INT)(peq - lpszzEnv))) {
             // found a candidate to subst
          if (cmdMakeShortEnvVar(rgpszLongPathNames[i],
                                 peq+1,
                                 szTmpVarBuffer,
                                 sizeof(szTmpVarBuffer)/sizeof(szTmpVarBuffer[0]))) {
              pszTmpVar = szTmpVarBuffer;
          }
          return(pszTmpVar);
      }
   }

   if (!(gfFoundTmp & FOUND_TMP) || !(gfFoundTmp & FOUND_TEMP)) {

      if (!(gfFoundTmp & FOUND_TEMP) &&
          !_strnicmp(lpszzEnv, szTemp, 4) &&
          (4 == (int)(peq - lpszzEnv))) {
          // this is Temp env variable -- make a new one
         fSubst = TRUE;
         gfFoundTmp |= FOUND_TEMP;
      }
      else {
         if (!(gfFoundTmp & FOUND_TMP) &&
             !_strnicmp(lpszzEnv, szTmp, 3) &&
             (3 ==  (int)(peq - lpszzEnv))) {
             // this is tmp variable

            fSubst = TRUE;
            gfFoundTmp |= FOUND_TMP;
         }
      }

      if (fSubst) {
         // we have a candidate for substitution
         if (cmdCreateTempEnvironmentVar(lpszzEnv,
                                         0,
                                         szTmpVarBuffer,
                                         sizeof(szTmpVarBuffer)/sizeof(szTmpVarBuffer[0]))) {
            pszTmpVar = szTmpVarBuffer;
         }
      }

   }

   return(pszTmpVar);
}




/** create a DOS environment for DOS.
    This is to get 32bits environment(comes with the dos executanle)
    and merge it with the environment settings in autoexec.nt so that
    COMMAND.COM gets the expected environment. We already created a
    double-null terminated string during autoexec.nt parsing. The string
    has mutltiple substring:
    "EnvName_1 NULL EnvValue_1 NULL[EnvName_n NULL EnvValue_n NULL] NULL"
    When name conflicts happened(a environment name was found in both
    16 bits and 32 bits), we do the merging based on the rules:
    get 16bits value, expands any environment variables in the string
    by using the current environment.

WARINING !!! The changes made by applications through directly manipulation
             in command.com environment segment will be lost.

**/
BOOL cmdCreateVDMEnvironment(
PVDMENVBLK  pVDMEnvBlk
)
{
PCHAR   p1, p2;
BOOL    fFoundComSpec;
BOOL    fFoundWindir;
BOOL    fVarIsWindir;
DWORD   Length, EnvStrLength;
PCHAR   lpszzVDMEnv, lpszzEnv, lpStrEnv;
CHAR    achBuffer[MAX_PATH + 1];

    pVDMEnvBlk->lpszzEnv = malloc(cchVDMEnv32 + cbComSpec + 1);
    if ((lpszzVDMEnv = pVDMEnvBlk->lpszzEnv) == NULL)
        return FALSE;

    pVDMEnvBlk->cchRemain = cchVDMEnv32 + cbComSpec + 1;
    pVDMEnvBlk->cchEnv = 0;

    // grab the 16bits comspec first
    if (cbComSpec && lpszComSpec && *lpszComSpec) {
        RtlCopyMemory(lpszzVDMEnv, lpszComSpec, cbComSpec);
        pVDMEnvBlk->cchEnv += cbComSpec;
        pVDMEnvBlk->cchRemain -= cbComSpec;
        lpszzVDMEnv += cbComSpec;
    }
    if (lpszzVDMEnv32) {

        // go through the given 32bits environmnet and take what we want:
        // everything except:
        // (1). variable name begin with '='
        // (2). compsec
        // (3). string without a '=' -- malformatted environment variable
        // (4). windir, so DOS apps don't think they're running under Windows
        // Note that strings pointed by lpszzVDMEnv32 are in ANSI character set


        fFoundComSpec = FALSE;
        fFoundWindir = FALSE;
        fVarIsWindir = FALSE;
        lpszzEnv = lpszzVDMEnv32;

        cmdCheckTempInit();

        while (*lpszzEnv) {
            Length = strlen(lpszzEnv) + 1;
            if (*lpszzEnv != '=' &&
                (p1 = strchr(lpszzEnv, '=')) != NULL &&
                (fFoundComSpec || !(fFoundComSpec = _strnicmp(lpszzEnv,
                                                             comspec,
                                                             8
                                                            ) == 0)) ){
                if (!fFoundWindir) {
                    fFoundWindir = (_strnicmp(lpszzEnv,
                                                            windir,
                                                            6) == 0);
                    fVarIsWindir = fFoundWindir;
                }

                // subst temp variables

                lpStrEnv = cmdCheckTemp(lpszzEnv);
                if (NULL == lpStrEnv) {
                   lpStrEnv = lpszzEnv;
                   EnvStrLength = Length;
                }
                else {
                   EnvStrLength = strlen(lpStrEnv) + 1;
                }

                if (!fVarIsWindir || fSeparateWow) {
                    if (EnvStrLength >= pVDMEnvBlk->cchRemain) {
                        lpszzVDMEnv = realloc(pVDMEnvBlk->lpszzEnv,
                                              pVDMEnvBlk->cchEnv +
                                              pVDMEnvBlk->cchRemain +
                                              VDM_ENV_INC_SIZE
                                             );
                        if (lpszzVDMEnv == NULL){
                            free(pVDMEnvBlk->lpszzEnv);
                            return FALSE;
                        }
                        pVDMEnvBlk->cchRemain += VDM_ENV_INC_SIZE;
                        pVDMEnvBlk->lpszzEnv = lpszzVDMEnv;
                        lpszzVDMEnv += pVDMEnvBlk->cchEnv;
                    }
                    AnsiToOemBuff(lpStrEnv, lpszzVDMEnv, EnvStrLength);
                    if (!fVarIsWindir) {
                        *(lpszzVDMEnv + (DWORD)(p1 - lpszzEnv)) = '\0';
                        _strupr(lpszzVDMEnv);
                        *(lpszzVDMEnv + (DWORD)(p1 - lpszzEnv)) = '=';
                    } else {
                        fVarIsWindir = FALSE;
                    }
                    pVDMEnvBlk->cchEnv += EnvStrLength;
                    pVDMEnvBlk->cchRemain -= EnvStrLength;
                    lpszzVDMEnv += EnvStrLength;
                }
                else
                    fVarIsWindir = FALSE;
            }
            lpszzEnv += Length;
        }
    }
    *lpszzVDMEnv = '\0';
    pVDMEnvBlk->cchEnv++;
    pVDMEnvBlk->cchRemain--;

    if (lpszzcmdEnv16 != NULL) {
        lpszzEnv = lpszzcmdEnv16;

        while (*lpszzEnv) {
            p1 = lpszzEnv + strlen(lpszzEnv) + 1;
            p2 = NULL;
            if (*p1) {
                p2 = achBuffer;
                // expand the strings pointed by p1
                Length = cmdExpandEnvironmentStrings(pVDMEnvBlk,
                                                     p1,
                                                     p2,
                                                     MAX_PATH + 1
                                                     );
                if (Length && Length > MAX_PATH) {
                    p2 =  (PCHAR) malloc(Length);
                    if (p2 == NULL) {
                        free(pVDMEnvBlk->lpszzEnv);
                        return FALSE;
                    }
                    cmdExpandEnvironmentStrings(pVDMEnvBlk,
                                                p1,
                                                p2,
                                                Length
                                               );
                }
            }
            if (!cmdSetEnvironmentVariable(pVDMEnvBlk,
                                           lpszzEnv,
                                           p2
                                           )){
                if (p2 && p2 != achBuffer)
                    free(p2);
                free(pVDMEnvBlk->lpszzEnv);
                return FALSE;
            }
            lpszzEnv = p1 + strlen(p1) + 1;
        }
    }
    lpszzVDMEnv = realloc(pVDMEnvBlk->lpszzEnv, pVDMEnvBlk->cchEnv);
    if (lpszzVDMEnv != NULL) {
        pVDMEnvBlk->lpszzEnv = lpszzVDMEnv;
        pVDMEnvBlk->cchRemain = 0;
    }
    return TRUE;
}


BOOL  cmdSetEnvironmentVariable(
PVDMENVBLK  pVDMEnvBlk,
PCHAR   lpszName,
PCHAR   lpszValue
)
{
    PCHAR   p, p1, pEnd;
    DWORD   ExtraLength, Length, cchValue, cchOldValue;

    pVDMEnvBlk = (pVDMEnvBlk) ? pVDMEnvBlk : &cmdVDMEnvBlk;

    if (pVDMEnvBlk == NULL || lpszName == NULL)
        return FALSE;
    if (!(p = pVDMEnvBlk->lpszzEnv))
        return FALSE;
    pEnd = p + pVDMEnvBlk->cchEnv - 1;

    cchValue = (lpszValue) ? strlen(lpszValue) : 0;

    Length = strlen(lpszName);
    while (*p && ((p1 = strchr(p, '=')) == NULL ||
                  (DWORD)(p1 - p) != Length ||
                  _strnicmp(p, lpszName, Length)))
        p += strlen(p) + 1;

    if (*p) {
        // name was found in the base environment, replace it
        p1++;
        cchOldValue = strlen(p1);
        if (cchValue <= cchOldValue) {
            if (!cchValue) {
                RtlMoveMemory(p,
                              p1 + cchOldValue + 1,
                              (DWORD)(pEnd - p) - cchOldValue
                             );
                pVDMEnvBlk->cchRemain += Length + cchOldValue + 2;
                pVDMEnvBlk->cchEnv -=  Length + cchOldValue + 2;
            }
            else {
                RtlCopyMemory(p1,
                              lpszValue,
                              cchValue
                             );
                if (cchValue != cchOldValue) {
                    RtlMoveMemory(p1 + cchValue,
                                  p1 + cchOldValue,
                                  (DWORD)(pEnd - p1) - cchOldValue + 1
                                  );
                    pVDMEnvBlk->cchEnv -= cchOldValue - cchValue;
                    pVDMEnvBlk->cchRemain += cchOldValue - cchValue;
                }
            }
            return TRUE;
        }
        else {
            // need more space for the new value
            // we delete it from here and fall through
            RtlMoveMemory(p,
                          p1 + cchOldValue + 1,
                          (DWORD)(pEnd - p1) - cchOldValue
                         );
            pVDMEnvBlk->cchRemain += Length + 1 + cchOldValue + 1;
            pVDMEnvBlk->cchEnv -= Length + 1 + cchOldValue + 1;
        }
    }
    if (cchValue) {
        ExtraLength = Length + 1 + cchValue + 1;
        if (pVDMEnvBlk->cchRemain  < ExtraLength) {
            p = realloc(pVDMEnvBlk->lpszzEnv,
                        pVDMEnvBlk->cchEnv + pVDMEnvBlk->cchRemain + ExtraLength
                       );
            if (p == NULL)
                return FALSE;
            pVDMEnvBlk->lpszzEnv = p;
            pVDMEnvBlk->cchRemain += ExtraLength;
        }
        p = pVDMEnvBlk->lpszzEnv + pVDMEnvBlk->cchEnv - 1;
        RtlCopyMemory(p, lpszName, Length + 1);
        _strupr(p);
        p += Length;
        *p++ = '=';
        RtlCopyMemory(p, lpszValue, cchValue + 1);
        *(p + cchValue + 1) = '\0';
        pVDMEnvBlk->cchEnv += ExtraLength;
        pVDMEnvBlk->cchRemain -= ExtraLength;
        return TRUE;
    }
    return FALSE;

}


DWORD cmdExpandEnvironmentStrings(
PVDMENVBLK  pVDMEnvBlk,
PCHAR   lpszSrc,
PCHAR   lpszDst,
DWORD   cchDst
)
{


    DWORD   RequiredLength, RemainLength, Length;
    PCHAR   p1;

    RequiredLength = 0;
    RemainLength = (lpszDst) ? cchDst : 0;
    pVDMEnvBlk = (pVDMEnvBlk) ? pVDMEnvBlk : &cmdVDMEnvBlk;
    if (pVDMEnvBlk == NULL || lpszSrc == NULL)
        return 0;

    while(*lpszSrc) {
        if (*lpszSrc == '%') {
            p1 = strchr(lpszSrc + 1, '%');
            if (p1 != NULL) {
                if (p1 == lpszSrc + 1) {        // a "%%"
                    lpszSrc += 2;
                    continue;
                }
                *p1 = '\0';
                Length = cmdGetEnvironmentVariable(pVDMEnvBlk,
                                                   lpszSrc + 1,
                                                   lpszDst,
                                                   RemainLength
                                                  );
                *p1 = '%';
                lpszSrc = p1 + 1;
                if (Length) {
                    if (Length < RemainLength) {
                        RemainLength -= Length;
                        lpszDst += Length;
                    }
                    else {
                        RemainLength = 0;
                        Length --;
                    }
                    RequiredLength += Length;
                }
                continue;
            }
            else {
                 RequiredLength++;
                 if (RemainLength) {
                    *lpszDst++ = *lpszSrc;
                    RemainLength--;
                 }
                 lpszSrc++;
                 continue;
            }
        }
        else {
            RequiredLength++;
            if (RemainLength) {
                *lpszDst++ = *lpszSrc;
                RemainLength--;
            }
            lpszSrc++;
        }
    }   // while(*lpszSrc)
    RequiredLength++;
    if (RemainLength)
        *lpszDst = '\0';
    return RequiredLength;
}


DWORD cmdGetEnvironmentVariable(
PVDMENVBLK pVDMEnvBlk,
PCHAR   lpszName,
PCHAR   lpszValue,
DWORD   cchValue
)
{

    DWORD   RequiredLength, Length;
    PCHAR   p, p1;

    pVDMEnvBlk = (pVDMEnvBlk) ? pVDMEnvBlk : &cmdVDMEnvBlk;
    if (pVDMEnvBlk == NULL || lpszName == NULL)
        return 0;

    RequiredLength = 0;
    Length = strlen(lpszName);

    // if the name is "windir", get its value from ntvdm process's environment
    // for DOS because we took it out of the environment block the application
    // will see.
    if (Length == 6 && !fSeparateWow && !_strnicmp(lpszName, windir, 6)) {
        return(GetEnvironmentVariableOem(lpszName, lpszValue, cchValue));
    }

    if (p = pVDMEnvBlk->lpszzEnv) {
       while (*p && ((p1 = strchr(p, '=')) == NULL ||
                     (DWORD)(p1 - p) != Length ||
                     _strnicmp(lpszName, p, Length)))
            p += strlen(p) + 1;
       if (*p) {
            RequiredLength = strlen(p1 + 1);
            if (cchValue > RequiredLength && lpszValue)
                RtlCopyMemory(lpszValue, p1 + 1, RequiredLength + 1);
            else
                RequiredLength++;
       }
    }
    return RequiredLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdpif.c ===
/*  cmdpif.c - PIF Handling Routines For SCS
 *
 *
 *  Modification History:
 *
 *  Sudeepb 19-Aug-1992 Created
 *  williamh 10-Nov-1992 (1). get params from w386 extention if exist
 *			 (2). null terminate caption
 *  williamh 27-May-1993 almost rewrote for better pif support
 */

#include "cmd.h"
#include <ctype.h>
#include <pif.h>
#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <oemuni.h>
#include "nt_pif.h"

VOID cmdCheckForPIF (PVDMINFO pvi)
{
PCHAR   pCmdLine = pvi->CmdLine;
PCHAR   pDot;
ULONG   size;
UCHAR   ch;
DWORD   dw;
CHAR	lpszEnvDir [] = "=?:";
CHAR	FullPathName[MAX_PATH + 1];
CHAR	* pFilePart;
BOOL	IsPIFFile, IsFromForceDos;
CHAR	AppFullPathName[MAX_PATH + 1];

    //
    // Advance CmdLine pointer to beg of command tail
    //
    while (*pCmdLine && !isgraph(*pCmdLine)) { // skip to first nonwhite
        pCmdLine++;
        }

    pDot = strrchr(pvi->AppName, '.');
    if (pDot)
	IsPIFFile = pDot && !_strnicmp(pDot, ".pif", 4);
    else
       IsPIFFile = FALSE;


    // if the command is not a pif file and it is not
    // running on a new console
    if (!IsPIFFile && !DosSessionId)
	goto CleanUpAndReturn;

    if (IsPIFFile) {
	if (!IsFirstVDM) {
            //
            // Get the pif data. If no pif data, or not from forcedos
            // just return -- command.com will receive the pif file
            // name and fail.
            //
            pfdata.AppHasPIFFile =
	    pfdata.IgnoreStartDirInPIF =
	    pfdata.IgnoreTitleInPIF =
	    pfdata.IgnoreCmdLineInPIF =
	    pfdata.IgnoreConfigAutoexec = 1;
            if (!GetPIFData(&pfdata, pvi->AppName))
		goto CleanUpAndReturn;
        }

	// we only run a pif file on two occasions:
	// (1). it is from a new console
	// (2). it is from forcedos.
        if (!DosSessionId && pfdata.SubSysId != SUBSYS_DOS)
            goto CleanUpAndReturn;

    }
    if (IsFirstVDM) {
	// if this is the first vdm, take cmdline, startupdir and title
	// if they are there
	if (pfdata.StartDir){
	    dw = cmdExpandEnvironmentStrings(NULL,
					     pfdata.StartDir,
					     FullPathName,
					     MAX_PATH + 1
					     );
            if (dw != 0 &&      dw <= MAX_PATH) {
		dw = GetFullPathNameOem(FullPathName,
					MAX_PATH + 1,
					pfdata.StartDir,
					&pFilePart
                                        );
            }

	    if (dw != 0 && dw <= MAX_PATH)
		dw = GetFileAttributesOem(pfdata.StartDir);
	    else
                dw = 0;

	    if (dw == 0 || dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
		{
		RcMessageBox(EG_PIF_STARTDIR_ERR,
			     NULL,
			     NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		goto CleanUpAndReturn;
            }

            dw = GetShortPathNameOem(pfdata.StartDir,
                                     pfdata.StartDir,
                                     MAX_PATH + 1
                                     );
	    if (dw == 0 || dw > MAX_PATH || dw > 64) {
		RcMessageBox(EG_PIF_STARTDIR_ERR,
			     NULL,
			     NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		goto CleanUpAndReturn;
            }

	    lpszEnvDir[1] = pfdata.StartDir[0];
	    SetEnvironmentVariableOem(lpszEnvDir, pfdata.StartDir);
	    SetCurrentDirectoryOem(pfdata.StartDir);
	    pvi->CurDrive = toupper(pfdata.StartDir[0]) - 'A';
        }

	if (pfdata.WinTitle) {
	    strcpy(FullPathName, pfdata.WinTitle);
	    dw = cmdExpandEnvironmentStrings(NULL,
					     FullPathName,
					     pfdata.WinTitle,
					     MAX_PATH + 1
					     );
	    pfdata.WinTitle[MAX_PATH] = '\0';
        }

        if (!*pCmdLine && pfdata.CmdLine) {

	    // if the optinal parameter is '?'
	    // prompt the user
	    pDot = pfdata.CmdLine;
	    while (*pDot && *pDot <= ' ')
                pDot++;

	    if (*pDot == '?') {
		pfdata.CmdLine[0] = '\0';
		RcMessageBox(EG_PIF_ASK_CMDLINE,
			     NULL,
			     pfdata.CmdLine,
			     RMB_EDIT | RMB_ICON_INFO | (128 << 16)
			     );
            }

	    if (*pfdata.CmdLine) {
		strcpy(FullPathName, pfdata.CmdLine);
		dw = cmdExpandEnvironmentStrings(NULL,
						 FullPathName,
						 pfdata.CmdLine,
						 MAX_PATH + 1
						);
	    }
	}
    }


    if(IsPIFFile) {
        dw = cmdExpandEnvironmentStrings(NULL,
                                         pfdata.StartFile,
					 FullPathName,
                                         MAX_PATH + 1
                                        );
        if (!dw || dw > MAX_PATH) {
            RcMessageBox(EG_PIF_STARTFILE_ERR,
                         NULL, NULL, RMB_ICON_BANG | RMB_ABORT);
            goto CleanUpAndReturn;
        }



        // search from the current directory
        // note that the startup directory specified in
        // the pif file has been set as our current directory
        // when we got here
        dw = SearchPathOem(".",
                           FullPathName,
                           NULL,
                           MAX_PATH + 1,
			   AppFullPathName,
                           &pFilePart
                           );
        // if couldn't find the file from the current dir
        // ask win32api help
        if (dw == 0 || dw > MAX_PATH) {
            dw = SearchPathOem(NULL,
                               FullPathName,
                               NULL,
                               MAX_PATH + 1,
			       AppFullPathName,
                               &pFilePart
                               );
        }

        // couldn't find the file, give up
        if (dw == 0 || dw > MAX_PATH) {
            RcMessageBox(EG_PIF_STARTFILE_ERR,
                         NULL, NULL, RMB_ICON_BANG | RMB_ABORT);
            goto CleanUpAndReturn;
        }

	dw = GetFileAttributesOem(AppFullPathName);
        if (dw == (DWORD)(-1) || (dw & FILE_ATTRIBUTE_DIRECTORY)) {
            RcMessageBox(EG_PIF_STARTFILE_ERR, NULL, NULL,
                         RMB_ICON_BANG | RMB_ABORT
                         );
            goto CleanUpAndReturn;
        }

        // convert to shortfilename
	dw = GetShortPathNameOem(AppFullPathName, pvi->AppName,
                                 MAX_PATH + 1);
        if (dw == 0 || dw > MAX_PATH) {

            RcMessageBox(EG_PIF_STARTFILE_ERR, NULL, NULL,
                         RMB_ICON_BANG | RMB_ABORT
                         );
            goto CleanUpAndReturn;
        }
	// update the application path name length(including the terminate NULL)
	pvi->AppLen = strlen(pvi->AppName) + 1;

	// pvi->AppName contains the application short name.
	// verify that it has the correct extension(.EXE, .COM or .BAT).
	pDot = (PCHAR)pvi->AppName + pvi->AppLen - 5;
	if (pvi->AppLen < 5 ||
	    (_strnicmp(pDot, EXE_EXTENTION_STRING, EXTENTION_STRING_LEN) &&
	     _strnicmp(pDot, COM_EXTENTION_STRING, EXTENTION_STRING_LEN) &&
	     _strnicmp(pDot, BAT_EXTENTION_STRING, EXTENTION_STRING_LEN)))
	{

	    RcMessageBox(EG_DOS_PROG_EXTENSION,AppFullPathName, NULL, RMB_ICON_BANG | RMB_ABORT);
	    goto CleanUpAndReturn;

	}
    }


    //
    // Copy in pif command tail if original command tail is empty
    //
    if (!*pCmdLine && pfdata.CmdLine) {
        strcpy(FullPathName, pfdata.CmdLine);
        strcat(FullPathName, "\x0d\x0a");
        if (strlen(FullPathName) >= 128 - 13) {
	    // too bad, the command line is too long
            RcMessageBox(EG_PIF_CMDLINE_ERR,NULL,NULL,RMB_ICON_BANG | RMB_ABORT);
	    goto CleanUpAndReturn;

	}
	strcpy(pvi->CmdLine, FullPathName);
	pvi->CmdSize = strlen(FullPathName) + 1;
    }

    if (IsPIFFile)
	// we don't know the binary type at this point.
	*pIsDosBinary = 0;

    if (pfdata.WinTitle)
	SetConsoleTitle(pfdata.WinTitle);

    DontCheckDosBinaryType = (pfdata.SubSysId == SUBSYS_DOS);

CleanUpAndReturn:
    if (pfdata.CmdLine) {
	free(pfdata.CmdLine);
	pfdata.CmdLine = NULL;
    }
    if (pfdata.StartDir) {
	free(pfdata.StartDir);
	pfdata.StartDir = NULL;
    }
    if (pfdata.StartFile) {
	free(pfdata.StartFile);
	pfdata.StartFile = NULL;
    }
    if (pfdata.WinTitle) {
	free(pfdata.WinTitle);
	pfdata.WinTitle = NULL;
    }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=command
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=\
    ..\..\..\inc;\
    $(WINDOWS_INC_PATH);\
    $(DS_INC_PATH);\
    $(SOFTPC_TREE)\base\inc;\
    $(SOFTPC_TREE)\host\inc

SOURCES=..\cmd.c      \
        ..\cmddata.c  \
        ..\cmddisp.c  \
        ..\cmdexec.c  \
        ..\cmdexit.c  \
        ..\cmdmisc.c  \
        ..\cmdpif.c   \
        ..\cmdredir.c \
        ..\cmdconf.c  \
        ..\cmdkeyb.c  \
        ..\cmdenv.c

C_DEFINES=-DWIN_32

UMTYPE=console
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdpif.h ===
/*================================================================
Structure used to hold the data that CONFIG will need from the PIF
file. This is gleaned from both the main data block and from the
file extensions for Windows 286 and 386.
================================================================*/


/* WARNING !!!!!!
   This structure is copied from NT_PIF.H in insiginia
   hsot\inc\nt_pif.h. Make sure you keep them synchronized
   when you make changes.
*/
#pragma pack()
typedef struct
   {
   char *WinTitle;		    /* caption text(Max. 30 chars) + NULL */
   char *CmdLine;		    /* command line (max 63 hars) + NULL */
   char *StartDir;		    /* program file name (max 63 chars + NULL */
   char *StartFile;
   WORD fullorwin;
   WORD graphicsortext;
   WORD memreq;
   WORD memdes;
   WORD emsreq;
   WORD emsdes;
   WORD xmsreq;
   WORD xmsdes;
   char menuclose;
   char reskey;
   WORD ShortMod;
   WORD ShortScan;
   char idledetect;
   char fgprio;
   char CloseOnExit;
   char AppHasPIFFile;
   char IgnoreTitleInPIF;
   char IgnoreStartDirInPIF;
   char IgnoreShortKeyInPIF;
   char IgnoreCmdLineInPIF;
   char IgnoreConfigAutoexec;
   char SubSysId;
   } PIF_DATA;

extern PIF_DATA pfdata;
BOOL   GetPIFData(PIF_DATA *, char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\command\cmdredir.c ===
/*  cmdredir.c - SCS routines for redirection
 *
 *
 *  Modification History:
 *
 *  Sudeepb 22-Apr-1992 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>

#define CMDREDIR_DEBUG  1

PPIPE_INPUT   cmdPipeList = NULL;

BOOL cmdCheckCopyForRedirection (pRdrInfo, bIsNTVDMDying)
PREDIRCOMPLETE_INFO pRdrInfo;
BOOL                bIsNTVDMDying;
{
PPIPE_INPUT  pPipe, pPipePrev;
PPIPE_OUTPUT pPipeOut;

    if (pRdrInfo == NULL)
        return TRUE;
    if (pRdrInfo->ri_pPipeStdIn != NULL) {

        //Piping and Pipe list is empty?
        ASSERT(cmdPipeList != NULL);

        // in most cases, we have only one pipe for stdin
        if (pRdrInfo->ri_pPipeStdIn == cmdPipeList){
            pPipe = pRdrInfo->ri_pPipeStdIn;
            cmdPipeList = pPipe->Next;
        }
        // multiple piping
        // search for the right one
        else {
            pPipe = pPipePrev = cmdPipeList;
            while (pPipe != NULL && pPipe != pRdrInfo->ri_pPipeStdIn){
                pPipePrev = pPipe;
                pPipe = pPipe->Next;
            }
            if (pPipe != NULL)
                // remove it from the list
                pPipePrev->Next = pPipe->Next;
        }
        if (pPipe != NULL) {
            // grab the critical section. As soon as we have a
            // a hold on the critical section, it is safe to kill
            // the piping thread because it is in dormant unless
            // it has terminated which is also safe for us.
            EnterCriticalSection(&pPipe->CriticalSection);
            // if the thread is till running, kill it
            if (WaitForSingleObject(pPipe->hThread, 0)) {
                TerminateThread(pPipe->hThread, 0);
                WaitForSingleObject(pPipe->hThread, INFINITE);
            }
            LeaveCriticalSection(&pPipe->CriticalSection);
            CloseHandle(pPipe->hFileWrite);
            CloseHandle(pPipe->hPipe);
            CloseHandle(pPipe->hDataEvent);
            CloseHandle(pPipe->hThread);
            DeleteCriticalSection(&pPipe->CriticalSection);
            DeleteFile(pPipe->pFileName);
            free(pPipe->pFileName);
            free (pPipe);
        }
    }
    // the application is terminating, let the output thread knows
    // about it so it can exit appropriately.
    // the output thread is responsible for clean up
    if (pRdrInfo->ri_pPipeStdOut) {
        // The output thread must wait for the event before
        // it can exit.
        SetEvent((pRdrInfo->ri_pPipeStdOut)->hExitEvent);
        // If NTVDM is terminating, we have to wait for
        // the output thread until it is done, otherwise, the
        // thread may be killed while it still has some
        // output to do.
        // if NTVDM is not terminating, we can not wait for
        // the output thread to exit because a scenario like
        // "dosapp1 | dosapp2"  would deadlock. Also
        // we can not return immediately because
        // our parent process may put up its prompt before our sibling
        // process has a chance to completely display data on
        // its display surface, for example:
        // <cmd> "dosapp | cat32"
        // <cmd>
        // so here, we wait for 1 second to give the output
        // thread a chance to flush all its output.
        WaitForSingleObject(pRdrInfo->ri_hStdOutThread,
                            bIsNTVDMDying ? INFINITE : 1000);
        CloseHandle(pRdrInfo->ri_hStdOutThread);
    }
    if (pRdrInfo->ri_pPipeStdErr) {
        SetEvent((pRdrInfo->ri_pPipeStdErr)->hExitEvent);
        WaitForSingleObject(pRdrInfo->ri_hStdErrThread,
                            bIsNTVDMDying ? INFINITE : 1000);
        CloseHandle(pRdrInfo->ri_hStdErrThread);
    }
    free (pRdrInfo);

    return TRUE;
}


// this function is in cmdenv.c and is used to retrieve temp directory for
// 16-bit apps
BOOL cmdCreateTempEnvironmentVar(
     LPSTR lpszTmpVar,  // temp variable (or just it's name)
     DWORD Length,      // the length of TmpVar or 0
     LPSTR lpszBuffer,  // buffer containing
     DWORD LengthBuffer
);

DWORD cmdGetTempPathConfig(
     DWORD Length,
     LPSTR lpszPath)
{
   CHAR szTempPath[MAX_PATH+4];
   PCHAR pchPath;
   DWORD PathSize = 0;
   BOOL fOk;

   fOk = cmdCreateTempEnvironmentVar("",
                                      0,
                                      szTempPath,
                                      sizeof(szTempPath)/sizeof(szTempPath[0]));
   if (fOk) {
      pchPath = &szTempPath[1]; // the very first char is '='
      PathSize = strlen(pchPath);
      if ((PathSize + 1) < Length) {
         strcpy(lpszPath, pchPath);
      }
   }
   return(PathSize);
}


BOOL cmdCreateTempFile (phTempFile,ppszTempFile)
PHANDLE phTempFile;
PCHAR   *ppszTempFile;
{

PCHAR pszTempPath = NULL;
DWORD TempPathSize;
PCHAR pszTempFileName;
HANDLE hTempFile;
SECURITY_ATTRIBUTES sa;

    pszTempPath = malloc(MAX_PATH + 12);

    if (pszTempPath == NULL)
        return FALSE;

    TempPathSize = cmdGetTempPathConfig(MAX_PATH, pszTempPath);
    if (0 == TempPathSize || MAX_PATH <= TempPathSize) {
       free(pszTempPath);
       return(FALSE);
    }

    // CMDCONF.C depends on the size of this buffer
    if ((pszTempFileName = malloc (MAX_PATH + 13)) == NULL){
        free (pszTempPath);
        return FALSE;
    }

         // if this fails it probably means we have a bad path
    if (!GetTempFileName(pszTempPath, "scs", 0, pszTempFileName))
       {
          // lets get something else, which should succeed
         TempPathSize = GetWindowsDirectory(pszTempPath, MAX_PATH);
         if (!TempPathSize || TempPathSize >= MAX_PATH)
             strcpy(pszTempPath, "\\");

          // try again and hope for the best
         GetTempFileName(pszTempPath, "scs", 0, pszTempFileName);
         }


    // must have a security descriptor so that the child process
    // can inherit this file handle. This is done because when we
    // shell out with piping the 32 bits application must have inherited
    // the temp filewe created, see cmdGetStdHandle
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    if ((hTempFile = CreateFile (pszTempFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 &sa,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_TEMPORARY,
                                 NULL)) == (HANDLE)-1){
        free (pszTempFileName);
        free (pszTempPath);
        return FALSE;
    }

    *phTempFile = hTempFile;
    *ppszTempFile = pszTempFileName;
    free (pszTempPath);
    return TRUE;
}

/* cmdCheckStandardHandles - Check if we have to do anything to support
 *                           standard io redirection, if so save away
 *                           pertaining information.
 *
 *  Entry - pVDMInfo - VDMInfo Structure
 *          pbStdHandle - pointer to bit array for std handles
 *
 *  EXIT  - return NULL if no redirection involved
 *          return pointer to REDIRECTION_INFO
 */

PREDIRCOMPLETE_INFO cmdCheckStandardHandles (
    PVDMINFO pVDMInfo,
    USHORT UNALIGNED *pbStdHandle
    )
{
USHORT bTemp = 0;
PREDIRCOMPLETE_INFO pRdrInfo;

    if (pVDMInfo->StdIn)
        bTemp |= MASK_STDIN;

    if (pVDMInfo->StdOut)
        bTemp |= MASK_STDOUT;

    if (pVDMInfo->StdErr)
        bTemp |= MASK_STDERR;

    if(bTemp){

        if ((pRdrInfo = malloc (sizeof (REDIRCOMPLETE_INFO))) == NULL) {
            RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
            TerminateVDM();
        }

        RtlZeroMemory ((PVOID)pRdrInfo, sizeof(REDIRCOMPLETE_INFO));
        pRdrInfo->ri_hStdErr = pVDMInfo->StdErr;
        pRdrInfo->ri_hStdOut = pVDMInfo->StdOut;
        pRdrInfo->ri_hStdIn  = pVDMInfo->StdIn;

        nt_std_handle_notification(TRUE);
        fSoftpcRedirection = TRUE;
    }
    else{
        pRdrInfo = NULL;
        nt_std_handle_notification(FALSE);
        fSoftpcRedirection = FALSE;
    }

    *pbStdHandle = bTemp;
    return pRdrInfo;
}

/* cmdGetStdHandle - Get the 32 bit NT standard handle for the VDM
 *
 *
 *  Entry - Client (CX) - 0,1 or 2 (stdin stdout stderr)
 *          Client (AX:BX) - redirinfo pointer
 *
 *  EXIT  - Client (BX:CX) - 32 bit handle
 *          Client (DX:AX) - file size
 */

VOID cmdGetStdHandle (VOID)
{
USHORT iStdHandle;
PREDIRCOMPLETE_INFO pRdrInfo;

    iStdHandle = getCX();
    pRdrInfo = (PREDIRCOMPLETE_INFO) (((ULONG)getAX() << 16) + (ULONG)getBX());

    switch (iStdHandle) {

        case HANDLE_STDIN:

            if (GetFileType(pRdrInfo->ri_hStdIn) == FILE_TYPE_PIPE) {
                if (!cmdHandleStdinWithPipe (pRdrInfo)) {
                    RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                    TerminateVDM();
                    setCF(1);
                    return;
                }
                setCX ((USHORT)pRdrInfo->ri_hStdInFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdInFile >> 16));
            }
            else {
                setCX ((USHORT)pRdrInfo->ri_hStdIn);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdIn >> 16));
            }
            break;

        case HANDLE_STDOUT:
            if (GetFileType (pRdrInfo->ri_hStdOut) == FILE_TYPE_PIPE){
                if (!cmdHandleStdOutErrWithPipe(pRdrInfo, HANDLE_STDOUT)) {
                    RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                    TerminateVDM();
                    setCF(1);
                    return;
                }
                setCX ((USHORT)pRdrInfo->ri_hStdOutFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdOutFile >> 16));

            }
            else {
                // sudeepb 16-Mar-1992; This will be a compatibilty problem.
                // If the user gives the command "dosls > lpt1" we will
                // inherit the 32 bit handle of lpt1, so the ouput will
                // directly go to the LPT1 and a DOS TSR/APP hooking int17
                // wont see this printing. Is this a big deal???
                setCX ((USHORT)pRdrInfo->ri_hStdOut);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdOut >> 16));
            }
            break;

        case HANDLE_STDERR:

            if (pRdrInfo->ri_hStdErr == pRdrInfo->ri_hStdOut
                              && pRdrInfo->ri_hStdOutFile != 0) {
                setCX ((USHORT)pRdrInfo->ri_hStdOutFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdOutFile >> 16));
                pRdrInfo->ri_hStdErrFile = pRdrInfo->ri_hStdOutFile;
                break;
            }

            if (GetFileType (pRdrInfo->ri_hStdErr) == FILE_TYPE_PIPE){
                if(!cmdHandleStdOutErrWithPipe(pRdrInfo, HANDLE_STDERR)) {
                    RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                    TerminateVDM();
                    setCF(1);
                    return;
                }
                setCX ((USHORT)pRdrInfo->ri_hStdErrFile);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdErrFile >> 16));
            }
            else {
                setCX ((USHORT)pRdrInfo->ri_hStdErr);
                setBX ((USHORT)((ULONG)pRdrInfo->ri_hStdErr >> 16));
            }
            break;
    }
    setAX(0);
    setDX(0);
    setCF(0);
    return;
}

BOOL cmdHandleStdOutErrWithPipe(
    PREDIRCOMPLETE_INFO pRdrInfo,
    USHORT  HandleType
    )
{

    HANDLE  hFile;
    PCHAR   pFileName;
    PPIPE_OUTPUT pPipe;
    BYTE    *Buffer;
    DWORD   ThreadId;
    HANDLE  hEvent;
    HANDLE  hFileWrite;
    HANDLE  hThread;

    if(!cmdCreateTempFile(&hFile,&pFileName))
        return FALSE;
    // must have a different handle so that writter(dos app) and reader(us)
    // wont use the same handle object(especially, file position)
    hFileWrite = CreateFile(pFileName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_TEMPORARY,
                            NULL
                           );
    if (hFileWrite == INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        DeleteFile(pFileName);
        return FALSE;
    }
    Buffer = malloc(sizeof(PIPE_OUTPUT) + PIPE_OUTPUT_BUFFER_SIZE);
    if (Buffer == NULL) {
        CloseHandle(hFile);
        CloseHandle(hFileWrite);
        DeleteFile(pFileName);
        return FALSE;
    }
    pPipe = (PPIPE_OUTPUT)Buffer;
    pPipe->Buffer = Buffer + sizeof(PIPE_OUTPUT);
    pPipe->BufferSize = PIPE_OUTPUT_BUFFER_SIZE;
    pPipe->hFile = hFileWrite;
    pPipe->pFileName = pFileName;
    pPipe->hExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (pPipe->hExitEvent == NULL) {
        CloseHandle(hFile);
        CloseHandle(hFileWrite);
        DeleteFile(pFileName);
        free(pPipe);
        return FALSE;
    }

    if (HandleType == HANDLE_STDOUT) {
        pPipe->hPipe = pRdrInfo->ri_hStdOut;
        pRdrInfo->ri_pPipeStdOut = pPipe;
        pRdrInfo->ri_hStdOutFile = hFile;

    }
    else {
        pPipe->hPipe = pRdrInfo->ri_hStdErr;
        pRdrInfo->ri_pPipeStdErr = pPipe;
        pRdrInfo->ri_hStdErrFile = hFile;

    }
    hThread = CreateThread ((LPSECURITY_ATTRIBUTES)NULL,
                            (DWORD)0,
                            (LPTHREAD_START_ROUTINE)cmdPipeOutThread,
                            (LPVOID)pPipe,
                            0,
                            &ThreadId
                            );
    if (hThread == NULL) {
        CloseHandle(pPipe->hExitEvent);
        CloseHandle(hFileWrite);
        CloseHandle(hFile);
        DeleteFile(pFileName);
        free(Buffer);
        return FALSE;
    }
    if (HandleType == HANDLE_STDOUT)
        pRdrInfo->ri_hStdOutThread = hThread;
    else
        pRdrInfo->ri_hStdErrThread = hThread;
    return TRUE;
}

/* independent thread to read application stdout(file) to NTVDM stdout(PIPE).
   The CPU thread would notify us through hExitEvent when the application
   is terminating(thus, we can detect EOF and exit
 */

VOID  cmdPipeOutThread(LPVOID lpParam)
{
    PPIPE_OUTPUT pPipe;
    DWORD        BytesRead;
    DWORD        BytesWritten;
    BOOL         ExitPending;

    pPipe = (PPIPE_OUTPUT)lpParam;

    ExitPending = FALSE;

    while(ReadFile(pPipe->hFile, pPipe->Buffer, pPipe->BufferSize, &BytesRead, NULL) ) {
        // go nothing doesn't mean it hits EOF!!!!!!
        // we can not just exit now, instead, we have to wait and poll
        // until the application is terminated.
        //
        if (BytesRead == 0) {
            // if read nothing and the application is gone, we can quit now
            if (ExitPending)
                break;
            if (!WaitForSingleObject(pPipe->hExitEvent, PIPE_OUTPUT_TIMEOUT))
                ExitPending = TRUE;
        }
        else {
            if (!WriteFile(pPipe->hPipe, pPipe->Buffer, BytesRead, &BytesWritten, NULL) ||
                BytesWritten != BytesRead)
                break;
        }
    }
    // if we were out of loop because of errors, wait for the cpu thread.
    if (!ExitPending)
        WaitForSingleObject(pPipe->hExitEvent, INFINITE);

    CloseHandle(pPipe->hFile);
    CloseHandle(pPipe->hPipe);
    CloseHandle(pPipe->hExitEvent);
    DeleteFile(pPipe->pFileName);
    free(pPipe->pFileName);
    free(pPipe);
    ExitThread(0);
}

BOOL cmdHandleStdinWithPipe (
    PREDIRCOMPLETE_INFO pRdrInfo
    )
{

    HANDLE  hStdinFile;
    PCHAR   pStdinFileName;
    PPIPE_INPUT pPipe;
    BYTE    *Buffer;
    DWORD   ThreadId;
    HANDLE  hEvent;
    HANDLE  hFileWrite;

    if(!cmdCreateTempFile(&hStdinFile,&pStdinFileName))
        return FALSE;


    // must have a different handle so that reader(dos app) and writter(us)
    // wont use the same handle object(especially, file position)
    hFileWrite = CreateFile(pStdinFileName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_TEMPORARY,
                            NULL
                           );
    if (hFileWrite == INVALID_HANDLE_VALUE) {
        CloseHandle(hStdinFile);
        DeleteFile(pStdinFileName);
        return FALSE;
    }
    Buffer = malloc(sizeof(PIPE_INPUT) + PIPE_INPUT_BUFFER_SIZE);
    if (Buffer == NULL) {
        CloseHandle(hStdinFile);
        CloseHandle(hFileWrite);
        DeleteFile(pStdinFileName);
        return FALSE;
    }
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL) {
        CloseHandle(hStdinFile);
        CloseHandle(hFileWrite);
        DeleteFile(pStdinFileName);
        free(Buffer);
        return FALSE;
    }
    pPipe = (PPIPE_INPUT)Buffer;
    pPipe->Buffer = Buffer + sizeof(PIPE_INPUT);
    pPipe->BufferSize = PIPE_INPUT_BUFFER_SIZE;
    pPipe->fEOF = FALSE;
    pPipe->hFileWrite = hFileWrite;
    pPipe->hFileRead  = hStdinFile;
    pPipe->hDataEvent = hEvent;
    pPipe->hPipe = pRdrInfo->ri_hStdIn;
    pPipe->pFileName = pStdinFileName;
    InitializeCriticalSection(&pPipe->CriticalSection);
    pPipe->hThread = CreateThread ((LPSECURITY_ATTRIBUTES)NULL,
                               (DWORD)0,
                               (LPTHREAD_START_ROUTINE)cmdPipeInThread,
                               (LPVOID)pPipe,
                               0,
                               &ThreadId
                              );
    if (pPipe->hThread == NULL) {
        CloseHandle(hFileWrite);
        CloseHandle(pPipe->hDataEvent);
        CloseHandle(hStdinFile);
        DeleteFile(pStdinFileName);
        free(Buffer);
        return FALSE;
    }
    // always have the new node in the head of the list because
    // it is the node used by the top command.com running in the process.
    // We may have multiple command.com instances running in the same
    // ntvdm proecess and each command.com has a private PREDIRCOMPLETE_INFO
    // associated with it if its stdin is redirected to a pipe.
    pPipe->Next = cmdPipeList;
    cmdPipeList = pPipe;
    pRdrInfo->ri_hStdInFile = hStdinFile;
    pRdrInfo->ri_pPipeStdIn = pPipe;
    return TRUE;
}

/* Independent thread to read from pipe(NTVDM STDIN) and write to
   file(DOS application STDIN) until either the pipe is broken or
   there are some errors.
   This thread may never terminate itself because it can block
   in the ReadFile call to the pipe forever. If this is the case,
   we have to rely on the CPU thread to kill it. To allow the CPU
   thread safely launching the killing, this thread yields the
   critical section when it is safe to be killed and the CPU thread
   would claim the critical section first before going for kill.
 */

VOID cmdPipeInThread(LPVOID lpParam)
{
    PPIPE_INPUT pPipe;
    DWORD       BytesRead, BytesWritten;
    BOOL        ReadStatus, WriteStatus;
    BOOL        ApplicationTerminated, fEOF;

    pPipe = (PPIPE_INPUT)lpParam;
    while (TRUE) {

        // this read can take forever without getting back anything
        ReadStatus = ReadFile(pPipe->hPipe, pPipe->Buffer,
                              pPipe->BufferSize, &BytesRead, NULL);

        // claim the critical section so we won't get killed
        // by the CPU thread
        EnterCriticalSection(&pPipe->CriticalSection);
        if (ReadStatus) {
            if (BytesRead != 0) {
                WriteStatus = WriteFile(pPipe->hFileWrite,
                                        pPipe->Buffer,
                                        BytesRead,
                                        &BytesWritten,
                                        NULL
                                        );
                if (pPipe->WaitData && WriteStatus && BytesWritten != 0) {
                    PulseEvent(pPipe->hDataEvent);

                    //
                    // Reset WaitData so we won't signal Event again before
                    // data is read out.
                    //
                    pPipe->WaitData = FALSE;
                }
            }
        } else {
            if (GetLastError() == ERROR_BROKEN_PIPE) {

                // pipe is broken and more data to read?
                ASSERT(BytesRead == 0);
                pPipe->fEOF = TRUE;
                LeaveCriticalSection(&pPipe->CriticalSection);
                break;
            }
        }
        // as soon as we leave the critical seciton, the CPU thread may
        // step in and kill us
        LeaveCriticalSection(&pPipe->CriticalSection);
    }
    ExitThread(0);
}

/* cmdPipeFileDataEOF - Check for new data or EOF
 *
 *
 *  Entry - hFile, DOS application STDIN file handle(file)
 *          &fEOF, to return if the pipe is broken
 *  EXIT  - TRUE if either there are new data or EOF is true
 *          *fEOF == TRUE if EOF
 */

BOOL cmdPipeFileDataEOF(HANDLE hFile, BOOL *fEOF)
{
    PPIPE_INPUT pPipe;
    BOOL        NewData;
    DWORD       WaitStatus;
    DWORD       FilePointerLow, FilePointerHigh = 0;
    DWORD       FileSizeLow, FileSizeHigh;

    pPipe = cmdPipeList;
    while (pPipe != NULL && pPipe->hFileRead != hFile)
        pPipe = pPipe->Next;

    if (pPipe != NULL) {
        *fEOF = pPipe->fEOF;
        if (!(*fEOF)) {

            //
            // If not EOF, check file pointer and file size to see
            // if new data is available.
            //
            FilePointerLow = SetFilePointer(
                                 hFile,
                                 (LONG)0,
                                 &FilePointerHigh,
                                 (DWORD)FILE_CURRENT
                                 );
            ASSERT(FilePointerLow != 0xffffffff);

            NewData = FALSE;
            EnterCriticalSection(&pPipe->CriticalSection);

            *fEOF = pPipe->fEOF;
            FileSizeLow = GetFileSize(hFile, &FileSizeHigh);
            ASSERT(FileSizeLow != 0xffffffff);

            //
            // If (file size == file pointer) there is NO new data
            // Just in case the file grows bigger than 4G.  We compare the
            // whole 64 bits.
            //
            if ((FilePointerLow == FileSizeLow) && (FilePointerHigh == FileSizeHigh)) {
                pPipe->WaitData = TRUE;
            } else {
                NewData = TRUE;
            }
            LeaveCriticalSection(&pPipe->CriticalSection);

            if (!NewData) {

                //
                // If InThread enters critical section, writes data and
                // pulses event before we start wait.  We will not be waken up.
                // But, we should be able to pick up the new data next
                // time we enter this routine.
                //
                WaitStatus = WaitForSingleObject(pPipe->hDataEvent, PIPE_INPUT_TIMEOUT);
                NewData = WaitStatus == WAIT_OBJECT_0 ? TRUE : FALSE;
                pPipe->WaitData = FALSE; // Not in Critical Section
            }
        }
    } else {
        *fEOF = TRUE;
    }
    return(NewData || *fEOF);
}

/* cmdPipeFileEOF - Check if the pipe is broken
 *
 *
 *  Entry - hFile, DOS application STDIN file handle(file)
 *
 *  EXIT  - TRUE if the write end of the pipe is closed
 */


BOOL cmdPipeFileEOF(HANDLE hFile)
{
    PPIPE_INPUT pPipe;
    BOOL       fEOF;

    pPipe = cmdPipeList;
    while (pPipe != NULL && pPipe->hFileRead != hFile)
        pPipe = pPipe->Next;

    fEOF = TRUE;

    if (pPipe != NULL) {
        EnterCriticalSection(&pPipe->CriticalSection);
        fEOF = pPipe->fEOF;
        LeaveCriticalSection(&pPipe->CriticalSection);
    }
    if (!fEOF) {
        Sleep(PIPE_INPUT_TIMEOUT);
        EnterCriticalSection(&pPipe->CriticalSection);
        fEOF = pPipe->fEOF;
        LeaveCriticalSection(&pPipe->CriticalSection);
    }
    return (fEOF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\dem.c ===
/*
 *  dem.c - Main Module of DOS Emulation DLL.
 *
 *  Sudeepb 09-Apr-1991 Craeted
 */

#include "io.h"
#include "dem.h"

/* DemInit - DEM Initialiazation routine. (This name may change when DEM is
 *           converted to DLL).
 *
 * Entry
 *      argc,argv - from softpc as it is.
 *
 *
 * Exit
 *      None
 */

PSZ pszDefaultDOSDirectory;

extern VOID     TerminateVDM(VOID);
extern VOID     dempInitLFNSupport(VOID);


CHAR demDebugBuffer [256];

#if DBG
BOOL ToDebugOnF11 = FALSE;
#endif

BOOL DemInit (int argc, char *argv[])
{
    PSZ psz;
    DWORD dw;

    // Modify default hard error handling
    // - turn off all file io related popups
    // - keep GP fault popups from system
    //
    SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    pszDefaultDOSDirectory =  (PCHAR) malloc(MAX_PATH+14);
    if (!pszDefaultDOSDirectory ||
        !(dw = GetSystemDirectory(pszDefaultDOSDirectory, MAX_PATH)) ||
        dw >= MAX_PATH )
      {
        return FALSE;
        }

    dempInitLFNSupport();

    if (VDMForWOW)
        return TRUE;

    // Check the debugging level
    while (--argc > 0) {
        psz = *++argv;
        if (*psz == '-' || *psz == '/') {
            psz++;
            if(tolower(*psz) == 'd'){
                fShowSVCMsg = DEMDOSDISP | DEMFILIO;
                break;
            }
        }
    }


#if DBG
#ifndef i386
    if( getenv( "YODA" ) != 0 )
#else
    if( getenv( "DEBUGDOS" ) != 0 )
#endif
        ToDebugOnF11 = TRUE;
#endif

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demdasd.h ===
#pragma pack(1)

#if defined(NEC_98) 
#define MAX_FLOPPY_TYPE     7
#else  // !NEC_98
#define MAX_FLOPPY_TYPE     5
#endif // !NEC_98
typedef struct A_DISKIO {
    DWORD   StartSector;
    WORD    Sectors;
    WORD    BufferOff;
    WORD    BufferSeg;
} DISKIO, * PDISKIO;

// Bios Parameter Block  (BPB)
typedef struct	A_BPB {
WORD	    SectorSize; 		// sector size in bytes
BYTE	    ClusterSize;		// cluster size in sectors
WORD	    ReservedSectors;		// number of reserved sectors
BYTE	    FATs;			// number of FATs
WORD	    RootDirs;			// number of root directory entries
WORD	    Sectors;			// number of sectors
BYTE	    MediaID;			// media descriptor
WORD	    FATSize;			// FAT size in sectors
WORD	    TrackSize;			// track size in sectors;
WORD	    Heads;			// number of heads
DWORD	    HiddenSectors;		// number of hidden sectors
DWORD	    BigSectors; 		// number of sectors for big media
} BPB, *PBPB;

typedef struct A_DPB {

BYTE	    DriveNum;			// driver numer, 0 - A, 1 -B and so on
BYTE	    Unit;			// unit number of DPB in the driver
WORD	    SectorSize; 		// sector size in bytes
BYTE	    ClusterMask;		// cluster mask
BYTE	    ClusterShift;		// cluster shift count
WORD	    FATSector;			// starting sector of FAT
BYTE	    FATs;			// number of FAT
WORD	    RootDirs;			// number of root directory entries
WORD	    FirstDataSector;		// first sector for the first cluster
WORD	    MaxCluster; 		// number of cluster + 1
WORD	    FATSize;			// FAT size in sectors
WORD	    DirSector;			// starting sector of directory
DWORD	    DriveAddr;			// address of the corresponding driver
BYTE	    MediaID;			// media ID
BYTE	    FirstAccess;		// 0xFF if this DPB is first accessed
struct A_DPB * Next;			// next DPB
WORD	    FreeCluster;		// cluster # of the last allocated
WORD	    FreeClusters;		// number of free clusters, 0xFFFF
					// if unknown
} DPB, * PDPB;


typedef struct A_DEVICEPARAMETERS {
BYTE	    Functions;
BYTE	    DeviceType;
WORD	    DeviceAttrs;
WORD	    Cylinders;
BYTE	    MediaType;
BPB	    bpb;
} DEVICEPARAMETERS, *PDEVICE_PARAMETERS;

#define LABEL_LENGTH		11
#define FILESYSTYPE_LENGTH	8


typedef struct	_DISK_LABEL {
CHAR	    Name[LABEL_LENGTH];
} DISK_LABEL, *PDISK_LABEL;

typedef struct _FILESYSTYPE {
CHAR	    Name[FILESYSTYPE_LENGTH];
} FILESYSTYPE, * PFILESYSTYPE;

// Functions for Get Device Parameters
#define BUILD_DEVICE_BPB		    0x01

// Functions for Set Device Parameters
#define INSTALL_FAKE_BPB	    0x01
#define ONLY_SET_TRACKLAYOUT	    0x02
#define TRACK_LAYOUT_IS_GOOD	    0x04
// Functions for Format Track
#define STATUS_FOR_FORMAT	    0x01
// error code from format status call
#define FORMAT_NO_ROM_SUPPORTED     0x01
#define FORMAT_COMB_NOT_SUPPORTED   0x02


// read and write block
typedef struct _RWBLOCK {
BYTE	Functions;
WORD	Head;
WORD	Cylinder;
WORD	StartSector;
WORD	Sectors;
WORD	BufferOff;
WORD	BufferSeg;
} RW_BLOCK, *PRW_BLOCK;

// format and verify track block
typedef struct _FMT_BLOCK{
BYTE	Functions;
WORD	Head;
WORD	Cylinder;
} FMT_BLOCK, *PFMT_BLOCK;

// media id block
typedef struct _MID {
WORD	    InfoLevel;
DWORD	    SerialNum;
DISK_LABEL  Label;
FILESYSTYPE FileSysType;
} MID, *PMID;

// access flage
typedef struct _ACCESSCTRL {
BYTE	    Functions;
BYTE	    AccessFlag;
} ACCESSCTRL, * PACCESSCTRL;

// bit definitions for flags

// definitions for misc flags
#define NON_REMOVABLE		0x01
#define HAS_CHANGELINE		0x02
#define RETURN_FAKE_BPB		0x04
#define GOOD_TRACKLAYOUT	0x08
#define MULTI_OWNER		0x10
#define PHYS_OWNER		0x20
#define MEDIA_CHANGED		0x40
#define CHANGED_BY_FORMAT	0x100
#define UNFORMATTED_MEDIA	0x200
#define FIRSTACCESS		0x8000

#define EXT_BOOTSECT_SIG	0x29

typedef struct	_BOOTSECTOR {
    BYTE    Jump;
    BYTE    Target[2];
    BYTE    OemName[8];
    BPB     bpb;
    BYTE    DriveNum;
    BYTE    Reserved;
    BYTE    ExtBootSig;
    DWORD   SerialNum;
    DISK_LABEL Label;
    FILESYSTYPE	FileSysType;
} BOOTSECTOR, * PBOOTSECTOR;

// Bios Data Structure	 (BDS)
typedef struct A_BDS {
struct	A_BDS  *Next;			//pointer to next bds
BYTE		DrivePhys;		//physical drive number, 0 based
BYTE		DriveLog;		//logical drive number, 0 based
BPB		bpb;
BYTE		FatSize;
WORD		OpenCount;
BYTE		MediaType;
WORD		Flags;
WORD		Cylinders;
BPB		rbpb;
BYTE		LastTrack;
DWORD		Time;
DWORD		SerialNum;
DISK_LABEL	Label;
FILESYSTYPE	FileSysType;
BYTE		FormFactor;
// the fllowing fields are dedicated for the drive itself
WORD		DriveType;
WORD		Sectors;
HANDLE		fd;
DWORD		TotalSectors;
} BDS, *PBDS;

#pragma pack()

// drive type
#define DRIVETYPE_NULL		0
#define DRIVETYPE_360		1
#define DRIVETYPE_12M		2
#define DRIVETYPE_720		3
#define DRIVETYPE_144		4
#define DRIVETYPE_288		5
#define DRIVETYPE_FDISK 	0xff
// FORM FACTOR

#define     FF_360		0
#define     FF_120		1
#define     FF_720		2
#define     FF_FDISK		5
#define     FF_144		7
#define     FF_288		9
#if defined(NEC_98) 
#define     FF_125              4                    
#define     FF_640              2                    
#endif // NEC_98
#define DOS_DIR_ENTRY_LENGTH		   32
#define DOS_DIR_ENTRY_LENGTH_SHIFT_COUNT    5

// bios diskette i/o functions
#define DISKIO_RESET		0
#define DISKIO_GETSTATUS	1
#define DISKIO_READ		2
#define DISKIO_WRITE		3
#define DISKIO_VERIFY		4
#define DISKIO_FORMAT		5
#define DISKIO_GETPARAMS	8
#define DISKIO_DRIVETYPE	0x15
#define DISKIO_DISKCHANGE	0x16
#define DISKIO_SETTYPE		0x17
#define DISKIO_SETMEDIA 	0x18
#define DISKIO_INVALID		0xff

// Block device generic IOCTL(RAWIO) subfunction code

#define IOCTL_SETDPM	    0x40
#define IOCTL_WRITETRACK    0x41
#define IOCTL_FORMATTRACK   0x42
#define IOCTL_SETMEDIA	    0x46
#define IOCTL_SETACCESS     0x47
#define IOCTL_GETDPM	    0x60
#define IOCTL_READTRACK     0x61
#define IOCTL_VERIFYTRACK   0x62
#define IOCTL_GETMEDIA	    0x66
#define IOCTL_GETACCESS	    0x67
#define IOCTL_SENSEMEDIA    0x68

#define IOCTL_GENERIC_MIN   IOCTL_SETDPM
#define IOCTL_GENERIC_MAX   IOCTL_SENSEMEDIA


// dos error code

#define DOS_WRITE_PROTECTION	0
#define DOS_UNKNOWN_UNIT	1
#define DOS_DRIVE_NOT_READY	2
#define DOS_CRC_ERROR		4
#define DOS_SEEK_ERROR		6
#define DOS_UNKNOWN_MEDIA	7
#define DOS_SECTOR_NOT_FOUND	8
#define DOS_WRITE_FAULT 	10
#define DOS_READ_FAULT		11
#define DOS_GEN_FAILURE 	12
#define DOS_INVALID_MEDIA_CHANGE 15

//BIOS disk io error code
#define BIOS_INVALID_FUNCTION	0x01
#define BIOS_BAD_ADDRESS_MARK	0x02
#define BIOS_WRITE_PROTECTED	0x03
#define BIOS_BAD_SECTOR 	0x04
#define BIOS_DISK_CHANGED	0x05
#define BIOS_DMA_OVERRUN	0x06
#define BIOS_DMA_BOUNDARY	0x08
#define BIOS_NO_MEDIA		0x0C
#define BIOS_CRC_ERROR		0x10
#define BIOS_FDC_ERROR		0x20
#define BIOS_SEEK_ERROR 	0x40
#define BIOS_TIME_OUT		0x80

// dos disk generic io control error code
#define DOS_INVALID_FUNCTION	1
#define DOS_FILE_NOT_FOUND	2
#define DOS_ACCESS_DENIED	5

#define BIOS_DISKCHANGED	6

#if defined(NEC_98) 
#define BYTES_PER_SECTOR       1024                
#else  // !NEC_98
#define BYTES_PER_SECTOR	512
#endif // !NEC_98

VOID demDasdInit(VOID);
VOID demFloppyInit(VOID);
VOID demFdiskInit(VOID);
VOID demAbsReadWrite(BOOL IsWrite);
DWORD demDasdRead(PBDS pbds, DWORD StartSector, DWORD Sectors,
		  WORD BufferOff, WORD BufferSeg);
DWORD demDasdWrite(PBDS pbds, DWORD StartSector, DWORD Sectors,
		   WORD BufferOff, WORD BufferSeg);
BOOL demDasdFormat(PBDS pbds, DWORD Head, DWORD Cylinder, MEDIA_TYPE * Media);
BOOL demDasdVerify(PBDS pbds, DWORD Cylinder, DWORD Head);
PBDS demGetBDS(BYTE Drive);
BOOL demGetBPB(PBDS pbds);
WORD demWinErrorToDosError(DWORD LastError);
VOID diskette_io(VOID);

DWORD BiosErrorToNTError(BYTE BiosError);
DWORD demBiosDiskIoRW(PBDS pbds, DWORD StartSector, DWORD Sectors,
		      WORD BufferOff, WORD BufferSeg, BOOL IsWrite);
VOID	sas_loadw(DWORD, WORD *);

// imported from host floppy support module
BOOL   nt_floppy_close(BYTE drive);
ULONG  nt_floppy_read(BYTE drive, ULONG offset, ULONG size, PBYTE buffer);
ULONG  nt_floppy_write(BYTE drive, ULONG offset, ULONG size, PBYTE buffer);
ULONG  nt_floppy_format(BYTE drive, WORD cylinder, WORD head, MEDIA_TYPE media);
BOOL   nt_floppy_media_check(BYTE drive);
MEDIA_TYPE nt_floppy_get_media_type(BYTE Drive, WORD Cylinders, WORD Sectors, WORD Heads);
BOOL   nt_floppy_verify(BYTE drive, DWORD offset, DWORD size);

BOOL   nt_fdisk_init(BYTE drive, PBPB bpb, PDISK_GEOMETRY disk_geometry);
ULONG  nt_fdisk_read(BYTE drive, PLARGE_INTEGER offset, ULONG size, PBYTE buffer);
ULONG  nt_fdisk_write(BYTE drive,PLARGE_INTEGER offset, ULONG size, PBYTE buffer);
BOOL   nt_fdisk_verify(BYTE drive, PLARGE_INTEGER offset, ULONG size);
BOOL   nt_fdisk_close(BYTE drive);
extern PBDS	demBDS;
extern BYTE	NumberOfFloppy, NumberOfFdisk;

#if defined(NEC_98) 
BOOL demIsDriveFloppy(BYTE DriveLog); // defined in demdasd.c
#else  // !NEC_98
#define demIsDriveFloppy(DriveLog)  (DriveLog < NumberOfFloppy)
#endif // !NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demdata.c ===
/* demdata.c - All the VDM instance Data.
 *
 * Sudeepb 06-Apr-1991 Created
 */

#include "dem.h"

/** VDM's DTA Address **/
ULONG  UNALIGNED *pulDTALocation; // Address in ntdos where DTA address is kept.


/** VDM's Current PDB **/

PUSHORT pusCurrentPDB;

/** SFT Chain Head **/

PDOSSF pSFTHead = NULL;

//
// address of extended error information in DOS data segment
//

PDEMEXTERR pExtendedError;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\dem.h ===
/* dem.h - main include file for dem
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 */

#ifndef _DEMINCLUDED_
#define _DEMINCLUDED_

/*
#define WIN
#define FLAT_32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>

*/

#ifdef DOS
#define SIGNALS
#endif

#ifdef OS2_16
#define OS2
#define SIGNALS
#endif

#ifdef OS2_32
#define OS2
#define FLAT_32
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <process.h>

#ifdef WIN_16
#define WIN
#define API16
#endif

#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#else
#define TRUE_IF_WIN32   0
#endif

#ifdef FLAT_32
#ifndef i386
#define ALIGN_32
#else
#define NOALIGN_32
#endif
#endif

#ifdef WIN
#define _WINDOWS
#include <windows.h>
#endif

#ifdef SIGNALS
#include <conio.h>
#include <signal.h>
#endif

#ifdef OS2_32
#include <excpt.h>
#define XCPT_SIGNAL 0xC0010003
#endif
#define SIGHIT(flChk)   ((iSigCheck++ & 0x7FF)?(flSignals & (flChk)):(kbhit(),(flSignals & (flChk))))

#include <oemuni.h>




/** Basic Typedefs of DEM **/

typedef VOID (*PFNSVC)(VOID);

typedef struct _SAVEDEMWORLD {
    USHORT  ax;
    USHORT  bx;
    USHORT  cx;
    USHORT  dx;
    USHORT  ds;
    USHORT  es;
    USHORT  si;
    USHORT  di;
    USHORT  bp;
    ULONG   iSVC;
} SAVEDEMWORLD, *PSAVEDEMWORLD;


typedef struct _DISKINFO {
    WORD   wSectorsPerCluster;
    WORD   wBytesPerSector;
    WORD   wFreeClusters;
    WORD   wTotalClusters;
} DISKINFO, *PDISKINFO;

#include "dosdef.h"
#include "dossvc.h"



/** DEM Externs **/

extern ULONG  UNALIGNED *pulDTALocation;
extern BOOL   VDMForWOW;
extern PVHE   pHardErrPacket;
extern ULONG  CurrentISVC;
extern PCHAR  aSVCNames[];
extern PFNSVC apfnSVC[];
extern PSZ    pszDefaultDOSDirectory;
extern USHORT nDrives;
extern PUSHORT pusCurrentPDB;
extern PDEMEXTERR pExtendedError;


#include "demexp.h"
#if DEVL
extern CHAR demDebugBuffer [];
#endif




/** DEM Macros **/

#define GETULONG(hi,lo)     (DWORD)((((int) hi) << 16) + ((int) lo))
#define GETHANDLE(hi,lo)    (HANDLE)(GETULONG(hi,lo))
#define IS_ASCII_PATH_SEPARATOR(ch)     (((ch) == '/') || ((ch) == '\\'))


/** Function Prototypes */

VOID demChgFilePtr      (VOID);
VOID demChMod           (VOID);
VOID demClose           (VOID);
VOID demCloseFCB        (VOID);
VOID demCreate          (VOID);
VOID demCreateFCB       (VOID);
VOID demCreateDir       (VOID);
VOID demCreateNew       (VOID);
VOID demDate16          (VOID);
VOID demDelete          (VOID);
VOID demDeleteDir       (VOID);
VOID demDeleteFCB       (VOID);
VOID demFCBIO           (VOID);
VOID demFileTimes       (VOID);
VOID demFindFirst       (VOID);
VOID demFindFirstFCB    (VOID);
VOID demFindNext        (VOID);
VOID demFindNextFCB     (VOID);
VOID demGetBootDrive    (VOID);
VOID demGetDriveFreeSpace   (VOID);
VOID demGetDrives       (VOID);
VOID demGetFileInfo     (VOID);
VOID demGSetMediaID     (VOID);
VOID demIOCTL           (VOID);
VOID demLoadDos         (VOID);
VOID demLockOper        (VOID);
VOID demOpen            (VOID);
VOID demOpenFCB         (VOID);
VOID demQueryCurrentDir (VOID);
VOID demQueryDate       (VOID);
VOID demQueryTime       (VOID);
VOID demRead            (VOID);
VOID demRename          (VOID);
VOID demRenameFCB       (VOID);
VOID demRetry           (VOID);
VOID demSetCurrentDir   (VOID);
VOID demSetDate         (VOID);
VOID demSetDefaultDrive (VOID);
VOID demSetDTALocation  (VOID);
VOID demSetHardErrorInfo(VOID);
VOID demSetTime         (VOID);
VOID demSetV86KernelAddr(VOID);
VOID demWrite           (VOID);
VOID demGetDriveInfo    (VOID);
VOID demDiskReset       (VOID);
VOID demLoadDosAppSym   (VOID);
VOID demFreeDosAppSym   (VOID);
VOID demEntryDosApp     (VOID);
VOID demDOSDispCall     (VOID);
VOID demDOSDispRet      (VOID);
VOID demOutputString    (VOID);
VOID demInputString     (VOID);
VOID demIsDebug         (VOID);
VOID demTerminatePDB    (VOID);
VOID demExitVDM         (VOID);
VOID demWOWFiles        (VOID);
VOID demGetComputerName (VOID);
VOID demCheckPath       (VOID);
VOID demSystemSymbolOp  (VOID);
VOID demCommit          (VOID);
VOID demClientError         (HANDLE,CHAR);
ULONG demClientErrorEx      (HANDLE,CHAR,BOOL);
VOID demCreateCommon        (ULONG);
BOOL demGetMiscInfo         (HANDLE, LPWORD, LPWORD, LPDWORD);
VOID demFCBCommon           (ULONG);

VOID demIoctlChangeable     (VOID);
VOID demIoctlInvalid        (VOID);
VOID demSaveHardErrInfo     (VOID);
VOID demRestoreHardErrInfo  (VOID);
VOID demAbsRead             (VOID);
VOID demAbsWrite            (VOID);
VOID demIoctlDiskGeneric    (VOID);
VOID demIoctlDiskQuery      (VOID);
VOID demGetDPB              (VOID);
VOID demGetDPBList          (VOID);
VOID demNotYetImplemented   (VOID);
BOOL GetDiskSpaceInformation(CHAR chDrive, PDISKINFO pDiskInfo);
BOOL demGetDiskFreeSpace(BYTE Drive, WORD * BytesPerSector,
                         WORD * SectorsPerCluster, WORD * TotalClusters,
                         WORD * FreeClusters);
BOOL IsCdRomFile            (PSTR pszPath);

BOOL GetMediaId( CHAR DriveNum, PVOLINFO pVolInfo);
VOID demPipeFileDataEOF     (VOID);
VOID demPipeFileEOF         (VOID);
VOID demLFNEntry            (VOID);

VOID demSetDosVarLocation   (VOID);
#ifdef FE_SB /* ConvNwPathToDosPath() */
VOID ConvNwPathToDosPath   (CHAR *,CHAR *);
#endif /* FE_SB */

/** Debug Function Prototypes */

#if DBG

VOID demPrintMsg (ULONG iMsg);

#else

#define demPrintMsg(x)

#endif

/* Label functions and constants */
USHORT demDeleteLabel(BYTE Drive);
USHORT demCreateLabel(BYTE Drive, LPSTR szName);
#define DRIVEBYTE   0
#define LABELOFF    3

extern  BOOL cmdPipeFileDataEOF (HANDLE,BOOL *);
extern  BOOL cmdPipeFileEOF(HANDLE);


#endif /* _DEMINCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demdasd.c ===
/*
 *  demdasd.c - module for direct disk access related support functions
 *
 *  Williamh 09-Dec-1992 Created
 *  Revision 24-Mar-1993 added fdisk support
 */

#include "io.h"
#include "dem.h"
#include "stdio.h"
#include "windows.h"
#include "demdasd.h"
#include "softpc.h"

PBDS    demBDS;
BYTE    NumberOfFloppy;
BYTE    NumberOfFdisk;

#if defined(NEC_98)
#define LPTBL_adr   0x0066c
#define EXLPTBL_adr 0x03286
#define FLOPY_LPTBL 0x90                       // Floppy
#define FDISK_LPTBL 0xA0                       // Shown as SCSI
#endif // NEC_98

extern  WORD int13h_vector_off, int13h_vector_seg;
extern  WORD int13h_caller_off, int13h_caller_seg;
#if defined(NEC_98)
extern  void sas_store(char*,unsigned char);
#endif // NEC_98

BPB     StdBpb[MAX_FLOPPY_TYPE] = {
            {512, 2, 1, 2, 112, 2*9*40,  0xFD, 2, 9,  2, 0, 0}, // 360KB
            {512, 1, 1, 2, 224, 2*15*80, 0xF9, 7, 15, 2, 0, 0}, // 1.2MB
            {512, 2, 1, 2, 112, 2*9*80,  0xF9, 3, 9,  2, 0, 0}, // 720KB
            {512, 1, 1, 2, 224, 2*18*80, 0xF0, 9, 18, 2, 0, 0}, // 1.44MB
            {512, 2, 1, 2, 240, 2*36*80, 0xF0, 9, 36, 2, 0, 0}  // 2.88MB
#if defined(NEC_98)
          , {1024, 1, 1, 2, 192, 2*8*77, 0xFE, 2, 8, 2, 0, 0},  // 1.2MB
            {512, 2, 1, 2, 112, 2*8*80, 0xFB, 2, 8, 2, 0, 0}    // 640KB
#endif // !NEC_98
        };

BYTE    FormFactorTable[MAX_FLOPPY_TYPE] = {
                                            FF_360,
                                            FF_120,
                                            FF_720,
                                            FF_144,
#if defined(NEC_98)
                                            FF_288,
                                            FF_125,
                                            FF_640
#else  // !NEC_98
                                            FF_288
#endif // !NEC_98
        };

/* demDasdInit - dem diskette system Initialiazation
 *
 * Entry
 *      none
 *
 *
 * Exit
 *      None
 */
VOID demDasdInit(VOID)
{
    demBDS = NULL;
    NumberOfFloppy = NumberOfFdisk = 0;
    demFloppyInit();
    demFdiskInit();
}
/* demAbsRead - int 25, absolute read
 *
 * Entry
 *      Client (AL) = drive number (0 based)
 *             (DS:BX) = pointer to the buffer to receive the read data
 *                       or pointer to the DISKIO structure
 *             (CX)    = number of sectors to read
 *                      if (0FFFFh) then DS:DX points to DISKIO
 *                          DX contents are discarded
 *             (DX)    = starting sector number
 *
 *
 * Exit
 *      Client (CY) = 0 if operation succeed
 *             (AX) = 0
 *
 *             (CY) = 1 if operation failed
 *             (AX) = error code
 */

VOID demAbsRead (VOID)
{
#if DBG
    if (fShowSVCMsg & DEM_ABSDRD)
        OutputDebugStringOem("DEM: INT 25 Called \n");
#endif
    demAbsReadWrite(FALSE);
}




/* demAbsWrite - int 26, absolute read
 *
 *
 * Entry
 *      Client (AL) = drive number (0 based)
 *             (DS:BX) = pointer to the buffer to receive the read data
 *                       or pointer to the DISKIO structure
 *             (CX)    = number of sectors to read
 *                      if (0FFFFh) then DS:DX points to DISKIO
 *                          DX contents are discarded
 *             (DX)    = starting sector number
 *
 *
 * Exit
 *      Client (CY) = 0 if operation succeed
 *             (AX) = 0
 *
 *             (CY) = 1 if operation failed
 *             (AX) = error code
 */

VOID demAbsWrite(VOID)
{
#if DBG
    if (fShowSVCMsg & DEM_ABSWRT)
        OutputDebugStringOem("DEM: INT 26 Called \n");
#endif
    demAbsReadWrite(TRUE);
}

extern BOOL (*DosWowDoDirectHDPopup)(VOID); // defined in demlfn.c

VOID demAbsReadWrite(BOOL IsWrite)
{
    BYTE    Drive;
    DWORD   LastError;
    DWORD    Sectors;
    DWORD    StartSector;
    PDISKIO DiskIo;
    DWORD    SectorsReturned;
    PBDS    pBDS;
    WORD    BufferOff, BufferSeg;

    Drive = getAL();
    if ((Sectors = getCX()) == 0xFFFF) {
        DiskIo = (PDISKIO) GetVDMAddr(getDS(), getBX());
        Sectors = DiskIo->Sectors;
        StartSector = DiskIo->StartSector;
        BufferOff = DiskIo->BufferOff;
        BufferSeg = DiskIo->BufferSeg;
    }
    else {
        StartSector =   getDX();
        BufferOff = getBX();
        BufferSeg = getDS();
    }
    if ((pBDS = demGetBDS(Drive)) == NULL) {
        if (!demIsDriveFloppy(Drive) && Drive < 26) {
           if (NULL == DosWowDoDirectHDPopup || (*DosWowDoDirectHDPopup)()) {
              host_direct_access_error(NOSUPPORT_HARDDISK);
           }
        }
        setAX(DOS_DRIVE_NOT_READY);
        setCF(1);
        return;
    }
#if DBG
    if (fShowSVCMsg & (DEM_ABSDRD | DEM_ABSWRT)) {
        sprintf(demDebugBuffer, "Drive Number: %d\n", Drive);
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer, "StartSector: %d\n", StartSector);
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer, "Total Sectors: %d\n", Sectors);
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer, "Buffer: %x:%x\n", BufferSeg, BufferOff);
    }
#endif

    if (IsWrite)
        SectorsReturned = demDasdWrite(pBDS,
                                       StartSector,
                                       Sectors,
                                       BufferOff,
                                       BufferSeg
                                       );
    else
        SectorsReturned = demDasdRead(pBDS,
                                      StartSector,
                                      Sectors,
                                      BufferOff,
                                      BufferSeg
                                      );
   if (SectorsReturned != Sectors) {
        LastError = GetLastError();
#if DBG
        if (fShowSVCMsg & (DEM_ABSDRD | DEM_ABSWRT)) {
            sprintf(demDebugBuffer, "dem: AbsRDWR Failed, error=%lx\n", LastError);
            OutputDebugStringOem(demDebugBuffer);
        }
#endif
        setAX(demWinErrorToDosError(LastError));
        setCF(1);
        return;
    }
    setCF(0);
    return;
}

DWORD demDasdRead(
    PBDS pbds,
    DWORD StartSector,
    DWORD Sectors,
    WORD  BufferOff,
    WORD  BufferSeg
)

{

    ULONG   SizeReturned;
    LARGE_INTEGER LargeInteger;
    DWORD   Size;
    DWORD   SectorSize;
    WORD    CurBiosDiskIoOff, CurBiosDiskIoSeg;
    PBYTE   Buffer;

    // if this is the first time we access the BDS or
    // the media has been changed, build the bds -- floppy
    if (!(pbds->Flags & NON_REMOVABLE) &&
        ((pbds->Flags & UNFORMATTED_MEDIA) ||
         !nt_floppy_media_check(pbds->DrivePhys))) {
        if (!demGetBPB(pbds))
            return 0;
    }
    if (StartSector >= pbds->TotalSectors ||
        StartSector + Sectors > pbds->TotalSectors) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0 ;
    }
    SectorSize = pbds->bpb.SectorSize;
    LargeInteger.QuadPart = Int32x32To64(Sectors, SectorSize);
    // size must fit in ulong
    if (LargeInteger.HighPart != 0) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0;
    }
    Size = LargeInteger.LowPart;

    Buffer = (PBYTE) GetVDMAddr(BufferSeg, BufferOff);

    if (pbds->Flags & NON_REMOVABLE) {
        LargeInteger.QuadPart  = Int32x32To64(StartSector, SectorSize);
        SizeReturned = nt_fdisk_read(
                                    pbds->DrivePhys,
                                    &LargeInteger,
                                    Size,
                                    Buffer
                                    );
    }
    else {
    // floppy need special care beacuse application may hook
    // bios disk interrupt. We dont' do this for hard disks because
    // we don't allow int13 to them
        sas_loadw(0x13*4, &CurBiosDiskIoOff);
        sas_loadw(0x13* 4 + 2, &CurBiosDiskIoSeg);
#if defined(NEC_98)
        if ( 1 )                        // if NEC_98, always TRUE
#else  // !NEC_98
        if (int13h_vector_off == CurBiosDiskIoOff &&
            int13h_vector_seg == CurBiosDiskIoSeg)
#endif // !NEC_98
            SizeReturned = nt_floppy_read(
                                          pbds->DrivePhys,
                                          StartSector * SectorSize,
                                          Size,
                                          Buffer
                                          );
        else
            return (demBiosDiskIoRW(pbds,
                                    StartSector,
                                    Sectors,
                                    BufferOff,
                                    BufferSeg,
                                    FALSE
                                    ));
    }
    if (SizeReturned == Size)
        return Sectors;
    else
        return SizeReturned / SectorSize;

}

DWORD demDasdWrite(
    PBDS pbds,
    DWORD StartSector,
    DWORD Sectors,
    WORD  BufferOff,
    WORD  BufferSeg
)


{
    ULONG   SizeReturned;
    LARGE_INTEGER LargeInteger;
    DWORD   Size;
    DWORD   SectorSize;
    WORD    CurBiosDiskIoOff, CurBiosDiskIoSeg;
    PBYTE   Buffer;

    // if this is the first time we access the BDS or
    // the media has been changed, build the bds
    if (!(pbds->Flags & NON_REMOVABLE) &&
        ((pbds->Flags & UNFORMATTED_MEDIA) ||
         !nt_floppy_media_check(pbds->DrivePhys))) {
        if (!demGetBPB(pbds))
            return 0;
    }
    if (StartSector >= pbds->TotalSectors ||
        StartSector + Sectors > pbds->TotalSectors) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0 ;
    }
    SectorSize = pbds->bpb.SectorSize;
    LargeInteger.QuadPart  = Int32x32To64(Sectors, SectorSize);
    // size must fit in ulong
    if (LargeInteger.HighPart != 0) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0;
    }
    Size = LargeInteger.LowPart;
    Buffer = (PBYTE) GetVDMAddr(BufferSeg, BufferOff);


    if (pbds->Flags & NON_REMOVABLE) {
        LargeInteger.QuadPart  = Int32x32To64(StartSector, SectorSize);
        SizeReturned = nt_fdisk_write(
                                      pbds->DrivePhys,
                                      &LargeInteger,
                                      Size,
                                      Buffer
                                      );
    }
    else {
    // floppy need special care beacuse application may hook
    // bios disk interrupt. We dont' do this for hard disks because
    // we don't allow int13 to them
        sas_loadw(0x13*4, &CurBiosDiskIoOff);
        sas_loadw(0x13* 4 + 2, &CurBiosDiskIoSeg);
#if defined(NEC_98)
        if ( 1 )                         // if NEC_98, always TRUE
#else  // !NEC_98
        if (int13h_vector_off == CurBiosDiskIoOff &&
            int13h_vector_seg == CurBiosDiskIoSeg)
#endif // !NEC_98
            SizeReturned = nt_floppy_write(
                                           pbds->DrivePhys,
                                           StartSector * SectorSize,
                                           Size,
                                           Buffer
                                           );
        else
            return(demBiosDiskIoRW(pbds,
                                   StartSector,
                                   Sectors,
                                   BufferOff,
                                   BufferSeg,
                                   TRUE
                                   ));
    }

    if (Size == SizeReturned)
        return Sectors;
    else
        return SizeReturned / SectorSize;


}

BOOL demDasdFormat(PBDS pbds, DWORD Head, DWORD Cylinder, MEDIA_TYPE * Media)
{
    BOOL    Result;

    if (pbds->Flags & NON_REMOVABLE)
        Result = demDasdVerify(pbds, Head, Cylinder);
    else {

       if (*Media == Unknown) {
            *Media = nt_floppy_get_media_type(pbds->DrivePhys,
                                              pbds->Cylinders,
                                              pbds->bpb.TrackSize,
                                              pbds->bpb.Heads
                                              );
            return TRUE;
        }
        else {
            Result = nt_floppy_format(pbds->DrivePhys,
                                      (WORD)Cylinder,
                                      (WORD)Head,
                                      *Media
                                      );
        }
    }
    return (Result);
}


BOOL demDasdVerify(PBDS pbds, DWORD Head, DWORD Cylinder)
{
    DWORD   Size, StartSector;
    LARGE_INTEGER LargeInteger;

    // if floppy, make sure we have up-to-date BPB and a valid media is in
    if (!(pbds->Flags & NON_REMOVABLE)) {
        if (!demGetBPB(pbds))
            return FALSE;
        Size = pbds->bpb.TrackSize * pbds->bpb.SectorSize;
        StartSector = pbds->bpb.TrackSize * (Cylinder * pbds->bpb.Heads + Head) + 1;
        return (nt_floppy_verify(pbds->DrivePhys,
                                 StartSector * pbds->bpb.SectorSize,
                                 Size));
    }
    // hard disk needs special care because of their size
    Size = pbds->bpb.TrackSize * pbds->bpb.SectorSize;
    StartSector = pbds->bpb.TrackSize * (Cylinder *  pbds->bpb.Heads + Head) + 1;
    LargeInteger.QuadPart  = Int32x32To64(StartSector, pbds->bpb.SectorSize);
    return (nt_fdisk_verify(pbds->DrivePhys,
                            &LargeInteger,
                                Size
                                ));
}

PBDS demGetBDS(BYTE DriveLog)
{
    PBDS    pbds;
    pbds = demBDS;
    while (pbds != NULL && pbds->DriveLog != DriveLog)
        pbds = pbds->Next;
    return pbds;
}

BOOL demGetBPB(PBDS pbds)
{
    PBOOTSECTOR pbs;
    BYTE    SectorBuffer[BYTES_PER_SECTOR];

    // when RETURN_FAKE_BPB is set(set by Set Device Parameter IOCTL,
    // the appplication has set a new BPB, we simply return it
    if (!(pbds->Flags & RETURN_FAKE_BPB) &&
        !(pbds->Flags & NON_REMOVABLE) &&
        ((pbds->Flags & UNFORMATTED_MEDIA) || !nt_floppy_media_check(pbds->DrivePhys))
       ) {
        pbds->Flags &= ~(UNFORMATTED_MEDIA);
        nt_floppy_close(pbds->DrivePhys);
        if (nt_floppy_read(pbds->DrivePhys,
                           0,
                           BYTES_PER_SECTOR,
                           SectorBuffer
                           ) != BYTES_PER_SECTOR)
            return FALSE;
        pbs = (PBOOTSECTOR)SectorBuffer;
        if ((pbs->Jump == 0x69 || pbs->Jump == 0xE9 ||
            (pbs->Jump == 0xEB && pbs->Target[1] == 0x90)) &&
            (pbs->bpb.MediaID & 0xF0) == 0xF0) {
            pbds->bpb = pbs->bpb;
            pbds->TotalSectors = (pbs->bpb.Sectors) ? pbs->bpb.Sectors :
                                                      pbs->bpb.BigSectors;
            return TRUE;
        }
        // an unknown media found
        else {
            pbds->Flags |= UNFORMATTED_MEDIA;
            // What should we do here? The diskette has strange boot sector
            // should we guess it or what?
            //
#if DEVL
            if (fShowSVCMsg & (DEM_ABSDRD | DEM_ABSWRT)) {
                sprintf(demDebugBuffer, "Invalid Boot Sector Found\n");
                OutputDebugStringOem(demDebugBuffer);
            }
#endif
            host_direct_access_error(NOSUPPORT_FLOPPY);
            return FALSE;
        }
    }
    return TRUE;
}

DWORD demBiosDiskIoRW(
    PBDS    pbds,
    DWORD   StartSector,
    DWORD   Sectors,
    WORD    BufferOff,
    WORD    BufferSeg,
    BOOL    IsWrite
)
{
    BYTE    CurHead, CurSector, BiosErrorCode;
    WORD    CurTrack, TrackSize, Heads, SectorTrack;
    WORD    AX, BX, CX, DX, ES, CS, IP;
    BYTE    SectorsRead, SectorsToRead;
    WORD    wRetry = 3;

    AX = getAX();
    BX = getBX();
    CX = getCX();
    DX = getDX();
    ES = getES();
    CS = getCS();
    IP = getIP();

    TrackSize = pbds->bpb.TrackSize;
    Heads = pbds->bpb.Heads;
    SectorsRead = 0;
    CurSector = (BYTE) ((StartSector % TrackSize) + 1);
    CurTrack  = (WORD) (StartSector / TrackSize);
    CurHead   = CurTrack  % Heads;
    CurTrack /= Heads;
    SectorsToRead = TrackSize - CurSector + 1;
    while (Sectors != 0) {
        if (Sectors < SectorsToRead)
            SectorsToRead = (BYTE) Sectors;
        // low byte:  bit 6 and 7 are high bits of track,
        //            bit 0 - 5 are sector number
        // high byte: bit 0 - bit 7 ->track lower 8 bits
        SectorTrack = ((CurTrack & 0x300) >> 2) | (CurSector & 0x3f) |
                      ((CurTrack &0xFF) << 8);
        wRetry = 3;
BiosRetry:
        setAH((BYTE) ((IsWrite) ? DISKIO_WRITE : DISKIO_READ));
        setAL(SectorsToRead);
        setBX(BufferOff);
        setES(BufferSeg);
        setDH(CurHead);
        setDL(pbds->DrivePhys);
        setCX(SectorTrack);
        setCS(int13h_caller_seg);
        setIP(int13h_caller_off);
        host_simulate();
        if (getCF() == 0) {
            SectorsRead += SectorsToRead;
            if ((Sectors -= SectorsToRead) == 0)
                break;
            CurSector = 1;
            if (++CurHead == Heads) {
                CurHead = 0;
                CurTrack++;
            }
            SectorsToRead = (BYTE) TrackSize;
        }
        else {
            BiosErrorCode = getAH();
            // reset the disk
            setAH(DISKIO_RESET);
            setDL(pbds->DrivePhys);
            setCS(int13h_caller_seg);
            setIP(int13h_caller_off);
            host_simulate();
            // NOTE that we dont' handle DMA boundary here
            // because it shouldn't happen.  -- the NT disk DD
            // will take care of that.
            if (BiosErrorCode & BIOS_TIME_OUT) {
                SetLastError(ERROR_NO_MEDIA_IN_DRIVE);
                break;
            }
            if (wRetry--)
                goto BiosRetry;
            SetLastError(BiosErrorToNTError(BiosErrorCode));
            break;
        }

    }
    setAX(AX);
    setBX(BX);
    setCX(CX);
    setDX(DX);
    setES(ES);
    setCS(CS);
    setIP(IP);
    return SectorsRead;

}

DWORD   BiosErrorToNTError(BYTE BiosErrorCode)
{
    DWORD NtErrorCode;

    switch (BiosErrorCode) {
        case BIOS_INVALID_FUNCTION:
                NtErrorCode = ERROR_BAD_COMMAND;
                break;
        case BIOS_BAD_ADDRESS_MARK:
                NtErrorCode = ERROR_FLOPPY_ID_MARK_NOT_FOUND;
                break;
        case BIOS_WRITE_PROTECTED:
                NtErrorCode = ERROR_WRITE_PROTECT;
                break;
        case BIOS_BAD_SECTOR:
        case BIOS_CRC_ERROR:
                NtErrorCode = ERROR_SECTOR_NOT_FOUND;
                break;
        case BIOS_DISK_CHANGED:
                NtErrorCode = ERROR_DISK_CHANGE;
                break;
        case BIOS_NO_MEDIA:
                NtErrorCode = ERROR_NO_MEDIA_IN_DRIVE;
                break;
        case BIOS_SEEK_ERROR:
                NtErrorCode = ERROR_SEEK;
                break;
        default:
                NtErrorCode = ERROR_FLOPPY_UNKNOWN_ERROR;
    }
    return NtErrorCode;


}


WORD demWinErrorToDosError(DWORD LastError)
{
    WORD    DosError;

    switch(LastError) {
        case ERROR_SEEK:
                DosError = DOS_SEEK_ERROR;
                break;
        case ERROR_BAD_UNIT:
                DosError = DOS_UNKNOWN_UNIT;
                break;
        case ERROR_NO_MEDIA_IN_DRIVE:
        case ERROR_NOT_READY:
                DosError = DOS_DRIVE_NOT_READY;
                break;
        case ERROR_NOT_DOS_DISK:
                DosError = DOS_UNKNOWN_MEDIA;
                break;
        case ERROR_SECTOR_NOT_FOUND:
        case ERROR_FLOPPY_WRONG_CYLINDER:
                DosError = DOS_SECTOR_NOT_FOUND;
                break;
        case ERROR_READ_FAULT:
                DosError = DOS_READ_FAULT;
                break;
        case ERROR_WRITE_FAULT:
                DosError = DOS_WRITE_FAULT;
                break;
        case ERROR_WRONG_DISK:
        case ERROR_DISK_CHANGE:
        case ERROR_MEDIA_CHANGED:
                DosError = DOS_INVALID_MEDIA_CHANGE;
                break;
        case ERROR_WRITE_PROTECT:
                DosError = DOS_WRITE_PROTECTION;
                break;
        default:
                DosError = DOS_GEN_FAILURE;

    }
    return (DosError);
}


VOID demFdiskInit(VOID)
{
    PBDS    pbds;
    UCHAR   Drive;
    DISK_GEOMETRY  DiskGeometry;
    BPB    bpb;

#if defined(NEC_98)
    CHAR numFlop = 0;
    CHAR numFdisk = 0;
#endif // NEC_98

    Drive = 0;
    do {
          // first, the drive must be valid
          // second, the drive must be a hard disk(fixed)
          // third, the drive must be a FAT
      if (demGetPhysicalDriveType(Drive) == DRIVE_FIXED &&
          nt_fdisk_init(Drive, &bpb, &DiskGeometry)) {
#if defined(NEC_98)
          sas_store( LPTBL_adr+Drive , (FDISK_LPTBL+numFdisk) );
          sas_store( EXLPTBL_adr+Drive*2, 0 );
          sas_store( EXLPTBL_adr+Drive*2+1, (FDISK_LPTBL+numFdisk++) );
#endif // NEC_98
          pbds = (PBDS) malloc(sizeof(BDS));
          if (pbds != NULL) {
              pbds->bpb = bpb;
              pbds->rbpb = bpb;
              pbds->DrivePhys = NumberOfFdisk++;
              pbds->DriveLog = Drive;
              pbds->DriveType = DRIVETYPE_FDISK;
              pbds->FormFactor = FF_FDISK;
              pbds->TotalSectors = (bpb.Sectors) ?
                                        bpb.Sectors :
                                        bpb.BigSectors;
              pbds->Cylinders = (WORD) DiskGeometry.Cylinders.LowPart;
              pbds->Next = demBDS;
              pbds->Flags = NON_REMOVABLE | PHYS_OWNER;
              demBDS = pbds;
           }
      }
#if defined(NEC_98)
      else if (demGetPhysicalDriveType(Drive) == DRIVE_REMOVABLE ) {
          sas_store( LPTBL_adr+Drive, (FLOPY_LPTBL+numFlop) );
          sas_store( EXLPTBL_adr+Drive*2, 0 );
          sas_store( EXLPTBL_adr+Drive*2+1, (FLOPY_LPTBL+numFlop++) );
          }
#endif // NEC_98

   } while (++Drive < 26);

}

VOID demFloppyInit(VOID)
{

    WORD    AX, BX, CX, DX, DI, ES;
#if defined(NEC_98)
    // BUG???: NumberOfFloppy is defined before.
    BYTE    i;
#else  // !NEC_98
    BYTE    i, NumberOfFloppy;
#endif // NEC_98
    PBDS    pbds;
    BYTE    DriveType;
#if defined(NEC_98)
    DWORD  DriveMask;
    CHAR   achRoot[] = "A:\\";
#endif // NEC_98

    AX = getAX();
    BX = getBX();
    CX = getCX();
    DX = getDX();
    DI = getDI();
    ES = getES();


    // reset the floppy system
#if defined(NEC_98)
    DriveMask = GetLogicalDrives();
    i=0;
    if ( DriveMask ) {
        while (DriveMask != 0) {
            achRoot[0] = i + 'A';
            if ((DriveMask & 1)
                &&(GetDriveType(achRoot) == DRIVE_REMOVABLE)){
                pbds = (PBDS) malloc(sizeof(BDS));
                if (pbds == NULL) {
                    OutputDebugStringOem("dem: not enough memory for BDS\n");
                    break;
                }
                pbds->DrivePhys = pbds->DriveLog = i;
                pbds->DriveType = DriveType = 6;        // 1.2 MB 2HD
                pbds->fd = NULL;                        //
                pbds->Cylinders = 77;                   //
                pbds->Sectors = 8;                      //
                pbds->rbpb = StdBpb[DriveType - 1];
                pbds->TotalSectors = 0;
                pbds->Next = demBDS;
                pbds->FormFactor = FormFactorTable[DriveType - 1];
                demBDS = pbds;
                pbds->Flags = UNFORMATTED_MEDIA | PHYS_OWNER;
                pbds->Flags |= HAS_CHANGELINE;
           }
           DriveMask>>=1;
           i++;
           NumberOfFloppy++;
       }
    }

#else  // !NEC_98
    setDL(0);
    setAH(DISKIO_RESET);
    diskette_io();

    setDL(0);
    setAH(DISKIO_GETPARAMS);
    diskette_io();
    if (getCF() == 0 && (NumberOfFloppy = getDL()) != 0) {
       for(i = 0;  i < NumberOfFloppy; i++) {
                setDL(i);
                setAH(DISKIO_GETPARAMS);
                diskette_io();
        if (getCF() == 0) {
                pbds = (PBDS) malloc(sizeof(BDS));
                if (pbds == NULL) {
                    OutputDebugStringOem("dem: not enough memory for BDS\n");
                break;
                }
           pbds->DrivePhys = pbds->DriveLog = i;
           pbds->DriveType = DriveType = getBL() & 0x0F;
           pbds->fd = NULL;
           pbds->Cylinders = getCH() + 1;
           pbds->Sectors = getCL();
           pbds->rbpb = StdBpb[DriveType - 1];
           pbds->TotalSectors = 0;
           pbds->Next = demBDS;
           pbds->FormFactor = FormFactorTable[DriveType - 1];
           demBDS = pbds;
           pbds->Flags = UNFORMATTED_MEDIA | PHYS_OWNER;
           setAH(DISKIO_DRIVETYPE);
           setDL(i);
           diskette_io();
           if (getAH() == 2 )
              pbds->Flags |= HAS_CHANGELINE;
               }
          }
        }
#endif //NEC_98

    setAX(AX);
    setBX(BX);
    setCX(CX);
    setDX(DX);
    setDI(DI);
    setES(ES);
}
#if defined(NEC_98)
BOOL demIsDriveFloppy(BYTE DriveLog){
    CHAR   achRoot[] = "A:\\";
        achRoot[0]='A'+DriveLog;
        return (GetDriveType(achRoot) == DRIVE_REMOVABLE );
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demdisp.c ===
/*
 *  demdisp.c - SVC dispatch module
 *
 *  Modification History:
 *
 *  Sudeepb 31-Mar-1991 Created
 */

#include "dem.h"
#include <stdio.h>
#include <softpc.h>
#include <dbgsvc.h>


#if DBG

PCHAR   aSVCNames[] = {
     "demChgFilePtr",
     "demChMod",
     "demClose",
     "demCreate",
     "demCreateDir",
     "demDelete",
     "demDeleteDir",
     "demDeleteFCB",
     "demFileTimes",
     "demFindFirst",
     "demFindFirstFCB",
     "demFindNext",
     "demFindNextFCB",
     "demGetBootDrive",
     "demGetDriveFreeSpace",
     "demGetDrives",
     "demGSetMediaID",
     "demLoadDos",
     "demOpen",
     "demQueryCurrentDir",
     "demQueryDate",
     "demQueryTime",
     "demRead",
     "demRename",
     "demSetCurrentDir",
     "demSetDate",
     "demSetDefaultDrive",
     "demSetDTALocation",
     "demSetTime",
     "demSetV86KernelAddr",
     "demWrite",
     "demGetDriveInfo",
     "demRenameFCB",
     "demIOCTL",
     "demCreateNew",
     "DemDiskReset",
     "DemSetDPB",
     "DemGetDPB",
     "DemSleazeFunc",
     "demCommit",
     "DemExtHandle",
     "DemAbsDRD",
     "DemAbsDWRT",
     "DemGsetCDPG",
     "DemCreateFCB",
     "DemOpenFCB",
     "DemCloseFCB",
     "DemFCBIO",
     "DemDate16",
     "DemGetFileInfo",
     "DemSetHardErrorInfo",
     "DemRetry",
     "DemLoadDosAppSym",
     "DemFreeDosAppSym",
     "DemEntryDosApp",
     "DemDOSDispCall",
     "DemDOSDispRet",
     "DemOutputString",
     "DemInputString",
     "DemIsDebug",
     "DemTerminatePDB",
     "DemExitVDM",
     "DemWOWFiles",
     "DemLockOper",
     "demNotYetImplemented",
     "DemGetComputerName",
     "DemFastRead",
     "DemFastWrite",
     "DemCheckPath",
     "DemSystemSymbolOp",
     "DemGetDpbList",
     "DemPipeFileDataEOF",
     "DemPipeFileEOF",
     "DemLFNEntry",
     "DemSetDosVarLocation"
};

#endif   // DBG

DWORD  fShowSVCMsg = 0;
ULONG  CurrentISVC;


PFNSVC  apfnSVC [] = {
     demChgFilePtr,     //SVC_DEMCHGFILEPTR
     demChMod,          //SVC_DEMCHMOD
     demClose,          //SVC_DEMCLOSE
     demCreate,         //SVC_DEMCREATE
     demCreateDir,      //SVC_DEMCREATEDIR
     demDelete,         //SVC_DEMDELETE
     demDeleteDir,      //SVC_DEMDELETEDIR
     demDeleteFCB,      //SVC_DEMDELETEFCB
     demFileTimes,      //SVC_DEMFILETIMES
     demFindFirst,      //SVC_DEMFINDFIRST
     demFindFirstFCB,       //SVC_DEMFINDFIRSTFCB
     demFindNext,       //SVC_DEMFINDNEXT
     demFindNextFCB,        //SVC_DEMFINDNEXTFCB
     demGetBootDrive,       //SVC_DEMGETBOOTDRIVE
     demGetDriveFreeSpace,  //SVC_DEMGETDRIVEFREESPACE
     demGetDrives,      //SVC_DEMGETDRIVES
     demGSetMediaID,        //SVC_DEMGSETMEDIAID
     demLoadDos,        //SVC_DEMLOADDOS
     demOpen,           //SVC_DEMOPEN
     demQueryCurrentDir,    //SVC_DEMQUERYCURRENTDIR
     demQueryDate,      //SVC_DEMQUERYDATE
     demQueryTime,      //SVC_DEMQUERYTIME
     demRead,           //SVC_DEMREAD
     demRename,         //SVC_DEMRENAME
     demSetCurrentDir,      //SVC_DEMSETCURRENTDIR
     demSetDate,        //SVC_DEMSETDATE
     demSetDefaultDrive,    //SVC_DEMSETDEFAULTDRIVE
     demSetDTALocation,     //SVC_DEMSETDTALOCATION
     demSetTime,        //SVC_DEMSETTIME
     demSetV86KernelAddr,   //SVC_DEMSETV86KERNELADDR
     demWrite,          //SVC_DEMWRITE
     demNotYetImplemented,  //SVC_GETDRIVEINFO
     demRenameFCB,      //SVC_DEMRENAMEFCB
     demIOCTL,          //SVC_DEMIOCTL
     demCreateNew,      //SVC_DEMCREATENEW
     demDiskReset,      //SVC_DEMDISKRESET
     demNotYetImplemented,  //SVC_DEMSETDPB
     demGetDPB,         //SVC_DEMGETDPB
     demNotYetImplemented,  //SVC_DEMSLEAZEFUNC
     demCommit,         //SVC_DEMCOMMIT
     demNotYetImplemented,  //SVC_DEMEXTHANDLE
     demAbsRead,        //SVC_DEMABSDRD
     demAbsWrite,       //SVC_DEMABSDWRT
     demNotYetImplemented,  //SVC_DEMGSETCDPG
     demCreateFCB,      //SVC_DEMCREATEFCB
     demOpenFCB,        //SVC_DEMOPENFCB
     demCloseFCB,       //SVC_DEMCLOSEFCB
     demFCBIO,          //SVC_FCBIO
     demDate16,         //SVC_DEMDATE16
     demGetFileInfo,        //SVC_DEMGETFILEINFO
     demSetHardErrorInfo,   //SVC_DEMSETHARDERRORINFO
     demRetry,          //SVC_DEMRETRY
     demLoadDosAppSym,      //SVC_DEMLOADDOSAPPSYM
     demFreeDosAppSym,          //SVC_DEMFREEDOSAPPSYM
     demEntryDosApp,            //SVC_DEMENTRYDOSAPP
     demDOSDispCall,            //SVC_DEMDOSDISPCALL
     demDOSDispRet,             //SVC_DEMDOSDISPRET
     demOutputString,           //SVC_OUTPUT_STRING
     demInputString,        //SVC_INPUT_STRING
     demIsDebug,        //SVC_ISDEBUG
     demTerminatePDB,       //SVC_PDBTERMINATE
     demExitVDM,        //SVC_DEMEXITVDM
     demWOWFiles,       //SVC_DEMWOWFILES
     demLockOper,               //SVC_DEMLOCKOPER
     demNotYetImplemented,      //SVC_DEMNOTYETIMPLEMENTED
     demGetComputerName,        //SVC_DEMGETCOMPUTERNAME
     demNotYetImplemented,      //SVC_DEMFASTREAD
     demNotYetImplemented,  //SVC_DEMFASTWRITE
     demCheckPath,      //SVC_DEMCHECKPATH
     demSystemSymbolOp,     //SVC_DEMSYSTEMSYMBOLOP
     demGetDPBList,     //SVC_DEMBUILDDPBLIST
     demPipeFileDataEOF,    //SVC_DEMPIPEFILEDATAEOF
     demPipeFileEOF,     //SVC_DEMPIPEFILEEOF
     demLFNEntry,               //SVC_DEMLFNENTRY
     demSetDosVarLocation       //SVC_SETDOSVARLOCATION
};


/* DemDispatch - Dispatch SVC call to right handler.
 *
 * Entry - iSvc (SVC byte following SVCop)
 *
 * Exit  - None
 *
 * Note  - Some mechanism has to be worked out to let the emulator know
 *     about DOSKRNL code segment and size. Using these it will figure
 *     out whether SVCop (hlt for the moment) has to be passed to
 *     DEM or to be handled as normal invalid opcode.
 */

BOOL DemDispatch (ULONG iSvc)
{

    DBGTRACE(VDMTR_TYPE_DEM + DEM_EVENT_DISPATCH, 0, iSvc);

    if (iSvc >= SVC_DEMLASTSVC){
#if DBG
        sprintf(demDebugBuffer,"Unimplemented SVC index %x\n",iSvc);
        OutputDebugStringOem(demDebugBuffer);
#endif
        setCF(1);
        return FALSE;
    }

    if (pHardErrPacket) {
        pHardErrPacket->vhe_fbInt24 = 0;
    }

    CurrentISVC = iSvc;
    (apfnSVC [iSvc])();

    DBGTRACE(VDMTR_TYPE_DEM + DEM_EVENT_DISPATCH_EXIT, 0, iSvc);

    return TRUE;
}

VOID demNotYetImplemented (VOID)
{
    if (fShowSVCMsg)  {
        sprintf(demDebugBuffer,"Unimplemented SVC %d\n",CurrentISVC);
        OutputDebugStringOem(demDebugBuffer);
        }

    setCF(0);
    return;
}

VOID demSetV86KernelAddr (VOID)
{
    // Here debugger callout has to be made for DOSKRNL symbols
    return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demerror.c ===
/*  demerror.c - Error handling routines of DEM
 *
 *  demSetHardErrorInfo
 *  demClientError
 *  demRetry
 *
 *  Modification History:
 *
 *  Sudeepb 27-Nov-1991 Created
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>

PVHE    pHardErrPacket;
PSYSDEV pDeviceChain;
SAVEDEMWORLD RetryInfo;

CHAR GetDriveLetterByHandle(HANDLE hFile);
VOID SubstituteDeviceName( PUNICODE_STRING InputDeviceName,
                           LPSTR OutputDriveLetter);

/* demSetHardErrorInfo - Store away harderr related address of DOSKRNL
 *
 * Entry
 *      Client (DS:DX) - VHE structure
 *
 * Exit
 *      None
 */

VOID demSetHardErrorInfo (VOID)
{
    pHardErrPacket = (PVHE) GetVDMAddr (getDS(),getDX());
    pDeviceChain = (PSYSDEV) GetVDMAddr(getDS(),getBX());
    return;
}

/* demRetry - Retry the operation which last resulted in hard error
 *
 * Entry
 *      None
 *
 * Exit
 *      None
 */

VOID demRetry (VOID)
{
ULONG iSvc;

    demRestoreHardErrInfo ();
    iSvc = CurrentISVC;

#if DBG
    if(iSvc < SVC_DEMLASTSVC && (fShowSVCMsg & DEMSVCTRACE) &&
         apfnSVC[iSvc] != demNotYetImplemented){
        sprintf(demDebugBuffer,"demRetry:Retrying %s\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
               aSVCNames[iSvc],getAX(),getBX(),getCX(),getDX(),getDI(),getSI());
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x\n",
                getCS(),getIP(), getDS(),getES(),getSS(),getSP(),getBP());
        OutputDebugStringOem(demDebugBuffer);
    }

    if (iSvc >= SVC_DEMLASTSVC || apfnSVC[iSvc] == demNotYetImplemented ){
        ASSERT(FALSE);
        setCF(1);
        setAX(0xff);
        return;
    }
#endif // DBG

    (apfnSVC [iSvc])();

#if DBG
    if((fShowSVCMsg & DEMSVCTRACE)){
        sprintf(demDebugBuffer,"demRetry:After %s\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
               aSVCNames[iSvc],getAX(),getBX(),getCX(),getDX(),getDI(),getSI());
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x CF=%x\n",
               getCS(),getIP(), getDS(),getES(),getSS(),getSP(),getBP(),getCF());
        OutputDebugStringOem(demDebugBuffer);
    }
#endif
    return;
}

/* demClientError - Update client registers to signal error
 *
 * Entry
 *       HANDLE hFile; file handle  , if none == -1
 *       char chDrive; drive letter , if none == -1
 *
 * Exit
 *      Client (CF) = 1
 *      Client (AX) = Error Code
 *
 * Notes
 *      the following errors cause hard errors
 *      errors above ERROR_GEN_FAILURE are mapped to general fail by the DOS
 *
 *
 *      ERROR_WRITE_PROTECT              19L
 *      ERROR_BAD_UNIT                   20L
 *      ERROR_NOT_READY                  21L
 *      ERROR_BAD_COMMAND                22L
 *      ERROR_CRC                        23L
 *      ERROR_BAD_LENGTH                 24L
 *      ERROR_SEEK                       25L
 *      ERROR_NOT_DOS_DISK               26L
 *      ERROR_SECTOR_NOT_FOUND           27L
 *      ERROR_OUT_OF_PAPER               28L
 *      ERROR_WRITE_FAULT                29L
 *      ERROR_READ_FAULT                 30L
 *      ERROR_GEN_FAILURE                31L
 *      ERROR_WRONG_DISK                 34l
 *      ERROR_NO_MEDIA_IN_DRIVE        1112l
 *      #ifdef JAPAN
 *      ERROR_UNRECOGNIZED_MEDIA       1785L
 *      #ifdef JAPAN
 *
 */

VOID demClientError (HANDLE hFile, CHAR chDrive)
{
    demClientErrorEx (hFile, chDrive, TRUE);
}

ULONG demClientErrorEx (HANDLE hFile, CHAR chDrive, BOOL bSetRegs)
{
ULONG ulErrCode;

    if(!(ulErrCode = GetLastError()))
        ulErrCode = ERROR_ACCESS_DENIED;

#ifdef JAPAN
    if ((ulErrCode < ERROR_WRITE_PROTECT || ulErrCode > ERROR_GEN_FAILURE)
        && ulErrCode != ERROR_WRONG_DISK && ulErrCode != ERROR_UNRECOGNIZED_MEDIA)
#else // !JAPAN
    if ((ulErrCode < ERROR_WRITE_PROTECT || ulErrCode > ERROR_GEN_FAILURE)
        && ulErrCode != ERROR_WRONG_DISK )
#endif // !JAPAN
       {
#if DBG
       if (fShowSVCMsg & DEMERROR) {
           sprintf(demDebugBuffer,"demClientErr: ErrCode=%ld\n", ulErrCode);
           OutputDebugStringOem(demDebugBuffer);
           }
#endif
        if (bSetRegs) {
            setAX((USHORT)ulErrCode);
            }
        }
    else {   // handle hard error case
        if (ulErrCode > ERROR_GEN_FAILURE)
            ulErrCode = ERROR_GEN_FAILURE;

        // Set the hard error flag
        pHardErrPacket->vhe_fbInt24 = 1;

        // Get the drive letter
        if (hFile != INVALID_HANDLE_VALUE)
            chDrive = GetDriveLetterByHandle(hFile);

        pHardErrPacket->vhe_bDriveNum = chDrive == -1
                                        ? -1 : toupper(chDrive) - 'A';

        // convert error code to i24 based error.
        ulErrCode -= ERROR_WRITE_PROTECT;
        pHardErrPacket->vhe_HrdErrCode =  (UCHAR)ulErrCode;

#if DBG
        if (fShowSVCMsg & DEMERROR) {
            sprintf(demDebugBuffer,
                    "demClientErr HRDERR: DriveNum=%ld ErrCode=%ld\n",
                    (DWORD)pHardErrPacket->vhe_bDriveNum,
                    (DWORD)pHardErrPacket->vhe_HrdErrCode);
            OutputDebugStringOem(demDebugBuffer);
            }
#endif
        // Save Away Information for possible retry operation
        demSaveHardErrInfo ();


        }

    if (bSetRegs)
        setCF(1);
    return (ulErrCode);
}



/*
 *  GetDriveLetterByHandle
 *
 *  retrieves the drive letter for the file handle
 *  if its a remote drive or fails returns -1
 */
CHAR GetDriveLetterByHandle(HANDLE hFile)
{
     NTSTATUS Status;
     ULONG    ul;
     ANSI_STRING  AnsiString;
     FILE_FS_DEVICE_INFORMATION DeviceInfo;
     IO_STATUS_BLOCK IoStatusBlock;
     POBJECT_NAME_INFORMATION pObNameInfo;
     CHAR    Buffer[MAX_PATH+sizeof(OBJECT_NAME_INFORMATION)];
     CHAR    ch;

       // if a remote drive return -1 for drive letter
     Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatusBlock,
                &DeviceInfo,
                sizeof(DeviceInfo),
                FileFsDeviceInformation );

     if (NT_SUCCESS(Status) &&
         DeviceInfo.Characteristics & FILE_REMOTE_DEVICE )
         return (CHAR) -1;

       // get the name
     pObNameInfo = (POBJECT_NAME_INFORMATION)Buffer;
     Status = NtQueryObject(              // get len of name
                hFile,
                ObjectNameInformation,
                pObNameInfo,
                sizeof(Buffer),
                &ul);

     if (!NT_SUCCESS(Status))
          return -1;

     RtlUnicodeStringToAnsiString(&AnsiString, &(pObNameInfo->Name), TRUE);
     if (strstr(AnsiString.Buffer,"\\Device") == AnsiString.Buffer)
         SubstituteDeviceName(&(pObNameInfo->Name), AnsiString.Buffer);

     ch = AnsiString.Buffer[0];
     RtlFreeAnsiString(&AnsiString);
     return ch;
}

static WCHAR wszDosDevices[] = L"\\DosDevices\\?:";

/*
 *  SubstituteDeviceName
 *
 *  lifted this code from the user\harderror hard error thread
 */
VOID SubstituteDeviceName( PUNICODE_STRING InputDeviceName,
                           LPSTR OutputDriveLetter )
{
    UNICODE_STRING LinkName;
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status;
    ULONG i;
    PWCHAR p;
    PWCHAR pSlash = L"\\";
    WCHAR DeviceNameBuffer[MAXIMUM_FILENAME_LENGTH];

       /*
        *  Ensure have trailing backslash
        */

    if (InputDeviceName->Buffer[(InputDeviceName->Length >>1) - 1] != *pSlash)
        RtlAppendUnicodeToString(InputDeviceName, pSlash);

    RtlInitUnicodeString(&LinkName,wszDosDevices);
    p = (PWCHAR)LinkName.Buffer;
    p = p+12;
    for(i=0;i<26;i++){
        *p = (WCHAR)'A' + (WCHAR)i;

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
        Status = NtOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //
            DeviceName.Length = 0;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Buffer = DeviceNameBuffer;

            Status = NtQuerySymbolicLinkObject(
                        LinkHandle,
                        &DeviceName,
                        NULL
                        );
            NtClose(LinkHandle);
            if ( NT_SUCCESS(Status) ) {

                if (DeviceName.Buffer[(DeviceName.Length >>1) - 1] != *pSlash)
                    RtlAppendUnicodeToString(&DeviceName, pSlash);

#ifdef JAPAN
                // #6197 compare only device name
                if (InputDeviceName->Length > DeviceName.Length)
                    InputDeviceName->Length = DeviceName.Length;

#endif // JAPAN
                if ( RtlEqualUnicodeString(InputDeviceName,&DeviceName,TRUE) )
                   {
                    OutputDriveLetter[0]='A'+(WCHAR)i;
                    OutputDriveLetter[1]='\0';
                    return;
                    }
                }
            }
        }

     // just in case we don't find it
    OutputDriveLetter[0]=(char)-1;
    OutputDriveLetter[1]='\0';
    return;


}





/* demSaveHardErrInfo
 * demRestoreHardErrInfo
 *
 * These two routines are used to preserve all the DOSKRNL registers
 * which will be needed to retry an SVC handler, in case user opts for
 * retry in harderr popup. This is a preferred way to handle retry
 * as it gives the DOSKRNL code the freedom to trash any register
 * even though it might have to retry the operation. It saves lots
 * of code bytes in heavily used DOS macro "HrdSVC".
 *
 * Entry
 *      None
 *
 * Exit
 *      None
 *
 * Notes
 *
 *  1. Doing things this way means, DOSKRNL cannot change the
 *     registers for retry. Under any circumstances, i can't think
 *     why it would need to do that anyway.
 *
 *  2. This mechanism also assumes that DOSKRNL never uses CS,IP,SS,SP
 *     for passing SVC parameters.
 *
 *  3. DOS does'nt allow int24 hookers to make any call which comes
 *     to DEM, so using CurrentISVC is safe.
 *
 *  4. If an SVC handler can pssibly return a hard error it should never
 *     modify the client registers.
 */


VOID demSaveHardErrInfo (VOID)
{
    RetryInfo.ax    =   getAX();
    RetryInfo.bx    =   getBX();
    RetryInfo.cx    =   getCX();
    RetryInfo.dx    =   getDX();
    RetryInfo.ds    =   getDS();
    RetryInfo.es    =   getES();
    RetryInfo.si    =   getSI();
    RetryInfo.di    =   getDI();
    RetryInfo.bp    =   getBP();
    RetryInfo.iSVC  =   CurrentISVC;
    return;
}


VOID demRestoreHardErrInfo (VOID)
{
    setAX(RetryInfo.ax);
    setBX(RetryInfo.bx);
    setCX(RetryInfo.cx);
    setDX(RetryInfo.dx);
    setDS(RetryInfo.ds);
    setES(RetryInfo.es);
    setSI(RetryInfo.si);
    setDI(RetryInfo.di);
    setBP(RetryInfo.bp);
    CurrentISVC =   RetryInfo.iSVC;
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demdir.c ===
/* demdir.c - SVC handlers for directory calls
 *
 * DemCreateDir
 * DemDeleteDir
 * DemQueryCurrentDir
 * DemSetCurrentDir
 *
 * Modification History:
 *
 * Sudeepb 04-Apr-1991 Created
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>

/* demCreateDir - Create a directory
 *
 *
 * Entry - Client (DS:DX) directory name to create
 *         Client (BX:SI) EAs (NULL if no EAs)
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 *
 * Notes : Extended Attributes is not yet taken care of.
 */

VOID demCreateDir (VOID)
{
LPSTR   lpDir;
#ifdef DBCS /* demCreateDir() for CSNW */
CHAR    achPath[MAX_PATH];
#endif /* DBCS */

    // EAs not yet implemented
    if (getBX() || getSI()){
        demPrintMsg (MSG_EAS);
        return;
    }

    lpDir = (LPSTR) GetVDMAddr (getDS(),getDX());

#ifdef DBCS /* demCreateDir() for CSNW */
    /*
     * convert Netware path to Dos path
     */
    ConvNwPathToDosPath(achPath,lpDir);
    lpDir = achPath;
#endif /* DBCS */

    if(CreateDirectoryOem (lpDir,NULL) == FALSE){
        demClientError(INVALID_HANDLE_VALUE, *lpDir);
        return;
    }

    setCF(0);
    return;
}


/* demDeleteDir - Create a directory
 *
 *
 * Entry - Client (DS:DX) directory name to create
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demDeleteDir (VOID)
{
LPSTR  lpDir;

    lpDir = (LPSTR) GetVDMAddr (getDS(),getDX());

    if (RemoveDirectoryOem(lpDir) == FALSE){
        demClientError(INVALID_HANDLE_VALUE, *lpDir);
        return;
    }

    setCF(0);
    return;
}



/* demQueryCurrentDir - Verifies current dir provided in CDS structure
 *                      for $CURRENT_DIR
 *
 * First Validates Media, if invalid -> i24 error
 * Next  Validates Path, if invalid set path to root (not an error)
 *
 * Entry - Client (DS:SI) Buffer to CDS path to verify
 *         Client (AL)    Physical Drive in question (A=0, B=1, ...)
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1 , I24 drive invalid
 */
VOID demQueryCurrentDir (VOID)
{
PCDS  pcds;
DWORD dw;
CHAR  chDrive;
CHAR  pPath[]="?:\\";
CHAR  EnvVar[] = "=?:";

    pcds = (PCDS)GetVDMAddr(getDS(),getSI());

          // validate media
    chDrive = getAL() + 'A';
    pPath[0] = chDrive;
    dw = GetFileAttributesOem(pPath);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
      {
        demClientError(INVALID_HANDLE_VALUE, chDrive);
        return;
        }

       // if invalid path, set path to the root
       // reset CDS, and win32 env for win32
    dw = GetFileAttributesOem(pcds->CurDir_Text);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
      {
        strcpy(pcds->CurDir_Text, pPath);
        pcds->CurDir_End = 2;
        EnvVar[1] = chDrive;
        SetEnvironmentVariableOem(EnvVar,pPath);
        }

    setCF(0);
    return;
}



/* demSetCurrentDir - Set the current directory
 *
 *
 * Entry - Client (DS:DX) directory name
 *         Dos default drive (AL) , CurDrv, where 1 == A.
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

extern NTSTATUS demSetCurrentDirectoryLCDS(UCHAR, LPSTR);

VOID demSetCurrentDir (VOID)
{
DWORD  dw;
LPSTR  lpBuf;
CHAR   EnvVar[] = "=?:";
CHAR   ch;
PCDS   pCDS;
BOOL   bLongDirName;


    lpBuf = (LPSTR) GetVDMAddr (getDS(),getDX());
    ch = (CHAR) toupper(*(PCHAR)lpBuf);
    if (ch < 'A' || ch > 'Z'){
        setCF(1);
        return;
    }

    // got the darn cds ptr
    pCDS = (PCDS)GetVDMAddr(getES(), getDI());

    // now see if the directory name is too long
    bLongDirName = (strlen(lpBuf) > DIRSTRLEN);
            //
        // if the current dir is for the default drive
        // set the win32 process's current drive,dir. This
        // will open an NT dir handle, and verify that it
        // exists.
        //

    if (ch == getAL() + 'A') {
       if (SetCurrentDirectoryOem (lpBuf) == FALSE){
           demClientError(INVALID_HANDLE_VALUE, ch);
           return;
           }
       }

        //
        // if its not for the default drive, we still need
        // to verify that the dir\drive combinations exits.
        //

    else {
       dw = GetFileAttributesOem(lpBuf);
       if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
         {
           demClientError(INVALID_HANDLE_VALUE, ch);
           return;
           }
       }


    EnvVar[1] = *(PCHAR)lpBuf;
    if(SetEnvironmentVariableOem ((LPSTR)EnvVar,lpBuf) == FALSE)
        setCF(1);
    else {
        // this is what '95 is doing for dos apps.
        // upon a getcurdir call -- it is going to be invalid

        // if we came here -- update a long directory as well
        demSetCurrentDirectoryLCDS((UCHAR)(ch - 'A'), lpBuf);

        strncpy(pCDS->CurDir_Text, lpBuf, DIRSTRLEN);
        if (bLongDirName) {
           setCF(1);
        }
        else {
           setCF(0);
        }
    }

    return;
}
#ifdef DBCS /* ConvNwPathToDosPath() for CSNW */
//
// TO BT LATER and IT SHOULD BE...
//
//  This routine does change Novell-J-laized file name to
// our well-known filename, but this code is only for the
// request from Novell utilities. these code should be
// laied onto nw16.exe (nw\nw16\tsr\resident.asm).
//
VOID ConvNwPathToDosPath(CHAR *lpszDos,CHAR *lpszNw)
{
    /*
     * check parameter
     */
    if((lpszDos == NULL) || (lpszNw == NULL)) return;

    /*
     * copy data from vdm buffer to our local buffer
     */
    strcpy(lpszDos,lpszNw);

    /*
     * replace the specified character
     */
    while(*lpszDos) {

        if(IsDBCSLeadByte(*lpszDos)) {
            /*
             * This is a DBCS character, check trailbyte is 0x5C or not.
             */
            lpszDos++;

            if( *lpszDos == 0x13 ) {
                *lpszDos++ = (UCHAR)0x5C;
                continue;
            }
        }

        switch((UCHAR)*lpszDos) {
            case 0x10 :
                *lpszDos = (UCHAR)0xBF;
                break;
            case 0x11 :
                *lpszDos = (UCHAR)0xAE;
                break;
            case 0x12 :
                *lpszDos = (UCHAR)0xAA;
                break;
        }

        /*
         * next char
         */
        lpszDos++;
    }
}
#endif /* DBCS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demfcb.c ===
/* demfcb.c - SVC handlers for misc. FCB operations
 *
 * demCloseFCB
 * demCreateFCB
 * demDate16
 * demDeleteFCB
 * demFCBIO
 * demGetFileInfo
 * demOpenFCB
 * demRenameFCB
 *
 * Modification History:
 *
 * Sudeepb 09-Apr-1991 Created
 * Sudeepb 21-Nov-1991 Added FCB based IO functions
 * Jonle   30-Jun-1994 add wild card support for fcb rename
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <winbase.h>
#include <mvdm.h>

#define DOT '.'
#define QMARK '?'


/* demDeleteFCB - FCB based File Delete
 *
 *
 * Entry - Client (ES:DI) - Full File Path
 *	   Client (AL)	  - 0 if not extended FCB
 *	   Client (DL)	  - File Attr. to be deleted (valid only if Al !=0 )
 *
 * Exit
 *	   SUCCESS
 *	     Client (CF) = 0
 *
 *	   FAILURE
 *	     Client (CF) = 1
 *	     Client (AX) = system status code
 *	    HARD ERROR
 *	     Client (CF) = 1
 *	     Client (AX) = 0ffffh
 *
 * Notes:  Following are the rules for FCB based delete:
 *	1. If normal FCB than dont allow delete on hidden,system files
 *	2. if extended FCB than search attributes should include hidden,
 *	   system or read-only if that kind of file is to be deleted.
 */

VOID demDeleteFCB (VOID)
{
HANDLE	hFind;
LPSTR	lpFileName;
BYTE	bClientAttr=0;
BOOL	fExtendedFCB=FALSE;
WIN32_FIND_DATA  wfBuffer;
BOOL	fSuccess = FALSE;
DWORD	dwAttr;
USHORT	uErr;

CHAR szPath_buffer[_MAX_PATH];
CHAR szDrive[_MAX_DRIVE];
CHAR szDir[_MAX_DIR];
CHAR szFname[_MAX_FNAME];
CHAR szExt[_MAX_EXT];

DWORD dwErrCode = 0, dwErrCodeKeep = 0;

    // Get the file name
    lpFileName = (LPSTR) GetVDMAddr (getES(),getDI());

    _splitpath( lpFileName, szDrive, szDir, szFname, szExt );

    // Check if handling extended FCB
    if(getAL() != 0){
	bClientAttr = getDL();

    /* Special case for delete volume label (INT 21 Func 13H, Attr = 8H */

    if((bClientAttr == ATTR_VOLUME_ID)) {
	if((uErr = demDeleteLabel(lpFileName[DRIVEBYTE]))) {
	    setCF(1);
	    setAX(uErr);
	    return;
	}
	setAX(0);
	setCF(0);
	return;
    }


	bClientAttr &= (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM);
	fExtendedFCB = TRUE;
    }

    // Find the first instance of file
    if((hFind = FindFirstFileOem (lpFileName,&wfBuffer)) == (HANDLE)-1){
        demClientError(INVALID_HANDLE_VALUE, *lpFileName);
        return;
    }

    // loop for all files which match the name and attributes
    do {
	// Check if read_only,hidden or system file
	if((dwAttr= wfBuffer.dwFileAttributes & (FILE_ATTRIBUTE_READONLY |
		      FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))){

	    // if so, try next file if normal FCB case. If extended fcb case
	    // then check if right attributes are given by client.
	    if(fExtendedFCB && ((dwAttr & (DWORD)bClientAttr) == dwAttr)){

		// Yes, right attributes are given. So if the file is read
		// only then change the modes to normal. Note NT will
		// delete hidden and system files anyway.
		if (dwAttr & FILE_ATTRIBUTE_READONLY){
		    strcpy( szPath_buffer, szDrive);
		    strcat( szPath_buffer, szDir);
		    strcat( szPath_buffer, wfBuffer.cFileName);

		    // if set attributes fail try next file
		    if(SetFileAttributesOem (szPath_buffer,
					     FILE_ATTRIBUTE_NORMAL) == -1)
			continue;
		}
	    }
	    else {
		dwErrCodeKeep = ERROR_ACCESS_DENIED;
		continue;
	    }
	}

	strcpy( szPath_buffer, szDrive);
	strcat( szPath_buffer, szDir);
	strcat( szPath_buffer, wfBuffer.cFileName);

	if(DeleteFileOem(szPath_buffer) == FALSE) {
	    dwErrCode = GetLastError();

	    SetLastError(dwErrCode);

	    if (((dwErrCode >= ERROR_WRITE_PROTECT) &&
		   (dwErrCode <= ERROR_GEN_FAILURE)) ||
		   dwErrCode == ERROR_WRONG_DISK ) {
		demClientError(INVALID_HANDLE_VALUE, szPath_buffer[0]);
		return;
	    }
	    continue;
	}

	// We have deleted at least one file, so report success
	fSuccess = TRUE;

    } while (FindNextFileOem(hFind,&wfBuffer) == TRUE);

    if(FindClose(hFind) == FALSE)
	demPrintMsg (MSG_INVALID_HFIND);

    if (fSuccess == TRUE){
	setCF(0);
	return;
    }

    setCF(1);

    if(dwErrCodeKeep)
	setAX((SHORT) dwErrCodeKeep);
    else
	setAX(ERROR_FILE_NOT_FOUND);
    return;
}


/* demRenameFCB - FCB based Rename file
 *
 * Entry - Client (DS:SI)    Sources file to be renamed
 *	   Client (ES:DI)    Destination file to be renamed to
 *
 * Exit  - SUCCESS
 *	   Client (CF)	= 0
 *
 *	   FAILURE
 *	   Client(CF)	= 1
 *	   Client(AX)	= error code
 */

VOID demRenameFCB (VOID)
{
    LPSTR  lpSrc,lpDst;
    DWORD  dw;
    HANDLE hFind;
    PCHAR pNewDstFilePart;
    PCHAR pDstFilePart;
    PCHAR pCurrSrcFilePart;
    WIN32_FIND_DATA  W32FindData;
    CHAR  NewDst[MAX_PATH];
    CHAR  CurrSrc[MAX_PATH];

    lpSrc = (LPSTR) GetVDMAddr (getDS(),getSI());
    lpDst = (LPSTR) GetVDMAddr (getES(),getDI());

      // Find the first instance of the source file
    hFind = FindFirstFileOem (lpSrc,&W32FindData);
    if (hFind == INVALID_HANDLE_VALUE) {
        dw = GetLastError();
        if (dw == ERROR_BAD_PATHNAME || dw == ERROR_DIRECTORY ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        demClientError(INVALID_HANDLE_VALUE, *lpSrc);
        return;
        }

    //
    // Source string consists of the path taken from the original
    // source specified plus the filename part retrieved from the
    // FindFile call
    //
    strcpy(CurrSrc, lpSrc);
    pCurrSrcFilePart = strrchr(CurrSrc, '\\');
    pCurrSrcFilePart++;

    //
    // Destination string is template for meta character substitution
    //
    pDstFilePart = strrchr(lpDst, '\\');
    pDstFilePart++;

    //
    //  NewDst string is constructed from template and the source string
    //  when doing meta file character substitution.
    //
    strcpy(NewDst, lpDst);
    pNewDstFilePart = strrchr(NewDst, '\\');
    pNewDstFilePart++;


    do {
       PCHAR pNew;
       PCHAR pSrc;
       PCHAR pDst;

       strcpy(pCurrSrcFilePart,
              W32FindData.cAlternateFileName[0]
                  ? W32FindData.cAlternateFileName
                  : W32FindData.cFileName  //// ??? hpfs lfns ????
              );

       pSrc = pCurrSrcFilePart; // source fname
       pNew = pNewDstFilePart;  // dest fname to be constructed
       pDst = pDstFilePart;     // raw dest fname template (with metas)

       while (*pDst) {

              //
              // If Found a '?' in Dest template, use character from src
              //
          if (*pDst == QMARK) {
              if (*pSrc != DOT && *pSrc)
                  *pNew++ = *pSrc++;
              }

              //
              // if Found a DOT in Dest template, Align DOTS between Src\Dst
              //
          else if (*pDst == DOT) {
              while (*pSrc != DOT && *pSrc) {  // mov src to one past DOT
                  pSrc++;
                  }
              if (*pSrc)
                  pSrc++;

              *pNew++ = DOT;
              }

              //
              // Nothing special found, use character from Dest template
              //
          else {
              if (*pSrc != DOT && *pSrc)
                  pSrc++;
              *pNew++ = *pDst;
              }

          pDst++;
          }

       *pNew = '\0';

       //
       // MoveFile does not return error if dst and src are the same,
       // but DOS does, so check first..
       //
       if (!_stricmp (CurrSrc, NewDst)) {
           setCF(1);
           setAX(0x5);
           FindClose(hFind);
           return;
           }

       if (!MoveFileOem(CurrSrc, NewDst)){
           demClientError(INVALID_HANDLE_VALUE, *lpSrc);
           FindClose(hFind);
           return;
           }

       } while (FindNextFileOem(hFind,&W32FindData));



   //
   // If the search on the source string for any reason besides
   // no more files, then its a genuine error.
   //
   dw = GetLastError();
   if (dw != ERROR_NO_MORE_FILES) {
       if (dw == ERROR_BAD_PATHNAME || dw == ERROR_DIRECTORY ) {
           SetLastError(ERROR_PATH_NOT_FOUND);
           }
       demClientError(INVALID_HANDLE_VALUE, *lpSrc);
       }
   else {
       setCF(0);
       }

   FindClose(hFind);
   return;
}



/* demCloseFCB - Close the NT handle associated with the FCB being closed.
 *
 * Entry - Client (AX:SI)    DWORD NT handle
 *
 * Exit  - SUCCESS
 *	   Client (CF)	= 0
 *
 *	   FAILURE
 *	   Client(CF)	= 1
 *	   Client(AX)	= error code
 */

VOID demCloseFCB (VOID)
{
HANDLE	hFile;

    hFile = GETHANDLE (getAX(),getSI());

    if(hFile == 0) {

	setCF(0);
	return;
    }

    if (CloseHandle (hFile) == FALSE){

	demClientError(hFile, (CHAR)-1);
	return;

    }
    setCF(0);
    return;
}

/* demCreateFCB - An FCB is being created get the NT handle.
 *
 * Entry - Client (AL)	  Creation Mode
 *			  00 - Normal File
 *			  01 - Read-only file
 *			  02 - Hidden File
 *			  04 - System file
 *	   Client (DS:SI) Full path filename
 *	   Client (ES:DI) SFT address
 *
 * Exit  - SUCCESS
 *	   Client (CF)	  = 0
 *	   Client (AX:BP) = NT Handle
 *	   Client (BX)	  = Time
 *	   Client (CX)	  = Date
 *	   Client (DX:SI) = Size
 *
 *	   FAILURE
 *	   Client(CF)	= 1
 *	   Client(AX)	= error code
 */

VOID demCreateFCB (VOID)
{
    demFCBCommon (CREATE_ALWAYS);
    return;
}

/* demDate16 - Get the current date/time in DOS FCB format.
 *
 * Entry - None
 *
 * Exit  - Always Success
 *	   Client (AX) has date
 *	   Client (DX) has time
 * NOTES:
 *
 * DemDate16 returns the current date in AX, current time in DX in this format
 *	   AX - YYYYYYYMMMMDDDDD	years months days
 *	   DX - HHHHHMMMMMMSSSSS	hours minutes seconds/2
 */

VOID demDate16 (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    // date is stored in a packed word: ((year-1980)*512) + (month*32) + day
    setAX ( (USHORT) (((TimeDate.wYear-1980) << 9 ) |
	    ((TimeDate.wMonth & 0xf) << 5 ) |
            (TimeDate.wDay & 0x1f))
	  );
    setDX ( (USHORT) ((TimeDate.wHour << 11) |
	    ((TimeDate.wMinute & 0x3f) << 5) |
            ((TimeDate.wSecond / 2) & 0x1f))
	  );
    return;
}

/* demFCBIO - Carry out the FCB based IO operation.
 *
 * Entry - Client (BX) = 1 if read operation, 0 if write
 *	   Client (AX:BP)  NT Handle
 *	   Client (DI:DX)  offset to start the operation with
 *	   Client (CX)	   Count of bytes
 *
 * Exit  - SUCCESS
 *	   Client (CF)	= 0
 *	   Client (CX)	= counts of bytes read/written
 *	   Client (AX:BX)  = size
 *
 *	   FAILURE
 *	   Client(CF)	= 1
 *	   Client(AX)	= error code
 */

VOID demFCBIO (VOID)
{
HANDLE	hFile;
ULONG	CurOffset;
PVOID   pBuf;
DWORD	dwBytesIO;
DWORD	dwSize,dwSizeHigh;
DWORD	dwErrCode;

    hFile = GETHANDLE (getAX(),getBP());
    CurOffset = (((ULONG)getDI()) << 16) + (ULONG)getDX();

    if (SetFilePointer (hFile,
			(LONG)CurOffset,
			NULL,
			(DWORD)FILE_BEGIN) == -1L){
        demClientError(hFile, (CHAR)-1);
        return ;
    }

    pBuf = (PVOID)GetVDMAddr(*((PUSHORT)pulDTALocation + 1),
                              *((PUSHORT)pulDTALocation));

    if(getBX()) {	// Read Operation
	if (ReadFile (hFile,
                      pBuf,
		      (DWORD)getCX(),
		      &dwBytesIO,
		      NULL) == FALSE){

            Sim32FlushVDMPointer(*pulDTALocation, getCX(), pBuf, FALSE);
            Sim32FreeVDMPointer(*pulDTALocation, getCX(), pBuf, FALSE);
            demClientError(hFile, (CHAR)-1);
            return ;
	}
        Sim32FlushVDMPointer (*pulDTALocation, getCX(),pBuf, FALSE);
        Sim32FreeVDMPointer (*pulDTALocation, getCX(), pBuf, FALSE);
    }
    else {
	if (WriteFile (hFile,
                       pBuf,
		       (DWORD)getCX(),
		       &dwBytesIO,
		       NULL) == FALSE) {

	// If disk is full then we should return number of bytes written
	// AX = 1 and CF = 1

	    dwErrCode = GetLastError();
	    if(dwErrCode == ERROR_DISK_FULL) {

		setCX( (USHORT) dwBytesIO);
		setAX(1);
		setCF(1);
		return;
	    }

	    SetLastError(dwErrCode);

	    demClientError(hFile, (CHAR)-1);
	    return ;

	}
    }

    // Get File Size
    if((dwSize = GetFileSize(hFile,&dwSizeHigh)) == -1){

	demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return;
    }

    if(dwSizeHigh) {
	demPrintMsg(MSG_FILESIZE_TOOBIG);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return;
    }

    // Setup the exit registers
    setCX((USHORT)dwBytesIO);
    setBX((USHORT)dwSize);
    setAX((USHORT)(dwSize >> 16 ));
    setCF(0);
    return;
}

/* demGetFileInfo - Get Misc. file info in FCB format.
 *
 * Entry - Client (DS:SI)    full path file name
 *
 * Exit  - SUCCESS
 *	   Client (CF)	= 0
 *	   Client (AX)	= Attribute of file
 *	   Client (CX)	= Time stamp of file
 *	   Client (DX	= Date stamp of file
 *	   Client (BX:DI)= Size of file (32 bit)
 *
 *	   FAILURE
 *	   Client(CF)	= 1
 *	   Client(AX)	= error code
 */

VOID demGetFileInfo (VOID)
{
HANDLE	hFile;
LPSTR	lpFileName;
WORD	wDate,wTime;
DWORD	dwSize,dwAttr;

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());

    if ((hFile = CreateFileOem(lpFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL)) == (HANDLE)-1){
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
    }

    // Get Misc. INfo
    if (demGetMiscInfo (hFile,&wTime, &wDate, &dwSize) == FALSE) {
        CloseHandle (hFile);
        return;
    }

    CloseHandle (hFile);

    if ((dwAttr = GetFileAttributesOem (lpFileName)) == -1) {
         demClientError(INVALID_HANDLE_VALUE, *lpFileName);
         return;
    }

    if (dwAttr == FILE_ATTRIBUTE_NORMAL)
	dwAttr = 0;

    setAX((USHORT)dwAttr);
    setCX(wTime);
    setDX(wDate);
    setDI((USHORT)dwSize);
    setBX((USHORT)(dwSize >> 16));
    return;
}


/* demOpenFCB - An FCB is being opened get the NT handle.
 *
 * Entry - Client (AL)	  Open Mode
 *	   Client (DS:SI) Full path filename
 *
 * Exit  - SUCCESS
 *	   Client (CF)	  = 0
 *	   Client (AX:BP) = NT Handle
 *	   Client (BX)	  = Time
 *	   Client (CX)	  = Date
 *	   Client (DX:SI) = Size
 *
 *	   FAILURE
 *	   Client(CF)	= 1
 *	   Client(AX)	= error code
 */

VOID demOpenFCB (VOID)
{
    demFCBCommon (OPEN_EXISTING);
    return;
}

/* demFCBCommon - FCB Open/Create.
 *
 * Entry - CreateDirective - Open/Create
 *	   Client (AL)	  Open Mode
 *	   Client (DS:SI) Full path filename
 *
 * Exit  - SUCCESS
 *	   Client (CF)	  = 0
 *	   Client (AX:BP) = NT Handle
 *	   Client (BX)	  = Time
 *	   Client (CX)	  = Date
 *	   Client (DX:SI) = Size
 *
 *	   FAILURE
 *	   Client(CF)	= 1
 *	   Client(AX)	= error code
 */
VOID demFCBCommon (ULONG CreateDirective)
{
HANDLE	hFile;
LPSTR	lpFileName;
UCHAR	uchMode,uchAccess;
DWORD	dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
DWORD	dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
WORD	wDate,wTime;
DWORD	dwSize,dwAttr=0;
USHORT	uErr;
SECURITY_ATTRIBUTES sa;

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());
    uchMode = getAL();

    /* Special case for delete volume label (INT 21 Func 13H, Attr = 8H */

    if((uchMode == ATTR_VOLUME_ID) && (CreateDirective == CREATE_ALWAYS)) {
	if((uErr = demCreateLabel(lpFileName[DRIVEBYTE],
		       lpFileName+LABELOFF))) {
	    setCF(1);
	    setAX(uErr);
	    return;
	}
	setAX(0);
	setBP(0);
	setCF(0);
	return;
    }


    // In create case AL has creation attributes. By default
    // Access is for read/write and sharing for both. In open
    // case AL has appropriate access and sharing information.
    if((CreateDirective == CREATE_ALWAYS) && ((uchMode &0xff) == 0)) {

	dwAttr = FILE_ATTRIBUTE_NORMAL;
	dwShareMode = FILE_SHARE_WRITE | FILE_SHARE_READ;
    }
    else {
	uchAccess = uchMode & (UCHAR)ACCESS_MASK;

	if (uchAccess == OPEN_FOR_READ)
	    dwDesiredAccess = GENERIC_READ;

	else if (uchAccess == OPEN_FOR_WRITE)
	    dwDesiredAccess = GENERIC_WRITE;

	uchMode = uchMode & (UCHAR)SHARING_MASK;

	switch (uchMode) {
	    case SHARING_DENY_BOTH:
		dwShareMode = 0;
		break;
	    case SHARING_DENY_WRITE:
		dwShareMode = FILE_SHARE_READ;
		break;
	    case SHARING_DENY_READ:
		dwShareMode = FILE_SHARE_WRITE;
		break;
	}
    }
    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    if ((hFile = CreateFileOem(lpFileName,
			       dwDesiredAccess,
			       dwShareMode | FILE_SHARE_DELETE,
                               &sa,
                               CreateDirective,
                               dwAttr,
                               NULL)) == (HANDLE)-1){
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
    }

    // Get Misc. INfo
    if (demGetMiscInfo (hFile,&wTime, &wDate, &dwSize) == FALSE)
        return;

    // Setup the exit registers
    setBX(wTime);
    setCX(wDate);
    setBP((USHORT)hFile);
    setAX((USHORT)((ULONG)hFile >> 16));
    setSI((USHORT)dwSize);
    setDX((USHORT)(dwSize >> 16));
    setCF(0);
    return;
}


BOOL demGetMiscInfo (hFile, lpTime, lpDate, lpSize)
HANDLE hFile;
LPWORD lpTime;
LPWORD lpDate;
LPDWORD lpSize;
{
FILETIME LastWriteTime,ftLocal;
DWORD	 dwSizeHigh=0;

    if(GetFileTime (hFile,NULL,NULL,&LastWriteTime) == -1){
	demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        CloseHandle (hFile);
        return FALSE;
    }

    FileTimeToLocalFileTime (&LastWriteTime,&ftLocal);

    if(FileTimeToDosDateTime(&ftLocal,
			     lpDate,
			     lpTime) == FALSE){
	demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return FALSE;
    }

    if((*lpSize = GetFileSize(hFile,&dwSizeHigh)) == -1){
	demPrintMsg(MSG_FILEINFO);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return FALSE;
    }

    if(dwSizeHigh) {
	demPrintMsg(MSG_FILESIZE_TOOBIG);
        ASSERT(FALSE);
        demClientError(hFile, (CHAR)-1);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demgset.c ===
/* demgset.c - Drive related SVC hanlers.
 *
 * demSetDefaultDrive
 * demGetBootDrive
 * demGetDriveFreeSpace
 * demGetDrives
 * demGSetMediaID
 * demQueryDate
 * demQueryTime
 * demSetDate
 * demSetTime
 * demSetDTALocation
 * demGSetMediaID
 * demGetDPB

 * Modification History:
 *
 * Sudeepb 02-Apr-1991 Created
 *
 */
#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <mvdm.h>
#include <winbase.h>
#include "demdasd.h"

#define BOOTDRIVE_PATH "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
#define BOOTDRIVE_VALUE "BootDir"


#define     SUCCESS 0
#define     NODISK  1
#define     FAILURE 2
BYTE demGetDpbI(BYTE Drive, DPB UNALIGNED *pDpb);


UCHAR PhysicalDriveTypes[26]={0};

extern PDOSSF pSFTHead;

USHORT  nDrives = 0;
CHAR    IsAPresent = TRUE;
CHAR    IsBPresent = TRUE;


/* demSetDefaultDrive - Set the default drive
 *
 *
 * Entry -
 *     Client (DS:SI) Current Directory on that drive
 *     Client (dl) Zero based DriveNum
 *
 * Exit  - SUCCESS
 *      Client (CY) = 0
 *      Current Drive Set
 *
 *     FAILURE
 *      Client (CY) = 1
 *      Current Drive Not Set
 *
 * Notes:
 *  The DOS keeps a current directory for each of the drives,
 *  However winnt keeps only one current Drive, Directory per
 *  process, and it is cmd.exe which associates a current
 *  directory for each of the drive.




 */

VOID demSetDefaultDrive (VOID)
{
LPSTR   lpPath;

    lpPath = (LPSTR)GetVDMAddr (getDS(),getSI());


// only in sp4
#ifdef NOVELL_NETWARE_SETERRORMODE

    //
    // For removable drives check for media\volume info to avoid triggering
    // hard errors when no media is present. There exists win32 code
    // (e.g novell netware redir vdd) which is known to clobber our error
    // mode setting.
    //
    // 16-Jul-1997 Jonle
    //

    {

    UCHAR DriveType;
    CHAR DriveNum;

    DriveNum = (CHAR)getDL();

    DriveType = demGetPhysicalDriveType(DriveNum);
    if (DriveType == DRIVE_REMOVABLE || DriveType == DRIVE_CDROM) {
        VOLINFO VolInfo;

          //
          // if No Media in drive, the drive is still valid,
          // but the win32 curdir is still the old one.
          //

        if (!GetMediaId(DriveNum, &VolInfo)) {
            if (GetLastError() == ERROR_INVALID_DRIVE) {
                setCF(1);
                }
            else {
                setCF(0);
                }
            return;
            }
        }
    }
#endif


    if (!SetCurrentDirectoryOem(lpPath) && GetLastError() == ERROR_INVALID_DRIVE) {

        //
        // Only return error if drive was invalid, the DOS doesn't check
        // for curdir when changing drives. Note that a number of old dos
        // apps will walk all of the drives, and do setdefaultdrive,
        // to determine the valid drives letters. The SetCurrentDirectoryOem
        // causes ntio to touch the drive and verify that the dir exists.
        // This is a significant performance problem for removable media
        // and network drives, but we have no choice since locking the
        // current dir for this drive is mandatory for winnt.
        //

        setCF(1);
        }
    else {
        setCF(0);
        }

    return;
}


/* demGetBootDrive - Get the boot drive
 *
 *
 * Entry - None
 *
 * Exit  - CLIENT (AL) has 1 base boot drive (i.e. C=3)
 *
 * We try to read the registry value that indicates the real boot drive. This
 * should be the location of autoexec.bat, etc. If we can't find the key,
 * or if the value indicates some drive letter that is not a fixed drive,
 * then we use a fallback plan of just saying drive C.
 *
 */

VOID demGetBootDrive (VOID)
{
#if defined(NEC_98)                                    // NTBUG #98466
    CHAR szBootDir[MAX_PATH];
    BYTE Drive = 1;     // default it to 'A:'
    UINT retCode;

    retCode = GetSystemDirectory(szBootDir,MAX_PATH);
    if (retCode == 0 || retCode > MAX_PATH){
        // error: can't get path
        goto DefaultBootDrive;
    }
    szBootDir[2] = '\\';
    szBootDir[3] = '\0';

#else  // !NEC_98
    HKEY hKey;
    DWORD retCode;
    DWORD dwType, cbData = MAX_PATH;
    CHAR szBootDir[MAX_PATH];
    BYTE Drive = 3;     // default it to 'C:'

    retCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            BOOTDRIVE_PATH,
                            0,
                            KEY_EXECUTE, // Requesting read access.
                            &hKey);


    if (retCode) {
        // error: can't find section
        goto DefaultBootDrive;
    }

    retCode = RegQueryValueEx(hKey,
                              BOOTDRIVE_VALUE,
                              NULL,
                              &dwType,
                              szBootDir,
                              &cbData);

    RegCloseKey(hKey);

    if (retCode) {
        // error: can't find key
        goto DefaultBootDrive;
    }
#endif // NEC_98

    if (GetDriveType(szBootDir) != DRIVE_FIXED) {
        // error: drive is not a valid boot drive
        goto DefaultBootDrive;
    }

    Drive = (BYTE)(tolower(szBootDir[0])-'a')+1;

DefaultBootDrive:

    setAL(Drive);
    return;

}

/* demGetDriveFreeSpace - Get free Space on the drive
 *
 *
 * Entry - Client (AL)  Drive in question
 *          0 - A: etc.
 *
 * Exit  -
 *     SUCCESS
 *      Client (CY) = 0
 *      Client (AL) = FAT ID byte
 *      Client (BX) = Number of free allocation units
 *      Client (CX) = Sector size
 *      Client (DX) = Total Number of allocation units on disk
 *      Client (SI) = Sectors per allocation unit
 *
 *     FAILURE
 *      Client (CY) = 1
 *      Client (AX) = Error code
 */


VOID demGetDriveFreeSpace (VOID)
{
WORD   SectorsPerCluster;
WORD   BytesPerSector;
WORD   FreeClusters;
WORD   TotalClusters;

BYTE	Drive;
PBDS	pbds;


    Drive = getAL();
    if (demGetDiskFreeSpace(Drive,
			    &BytesPerSector,
			    &SectorsPerCluster,
			    &TotalClusters,
			    &FreeClusters) == FALSE)
       {
	demClientError(INVALID_HANDLE_VALUE, (CHAR)(getAL() + 'A'));
        return;
        }

    if (pbds = demGetBDS(Drive)) {
	    // if the device is a floppy, reload its bpb
	    if (!(pbds->Flags & NON_REMOVABLE) && !demGetBPB(pbds))
		pbds->bpb.MediaID = 0xF8;

	    setAL(pbds->bpb.MediaID);
    }
    else
	setAL(0);

    setBX(FreeClusters);
    setCX(BytesPerSector);
    setDX(TotalClusters);
    setSI(SectorsPerCluster);
    setCF(0);
    return;
}


//
//  retrieves drive type for physical drives
//  substd, redir drives are returned as unknown
//  uses same DriveType definitions as win32 GetDriveTypeW
//
UCHAR
demGetPhysicalDriveType(
      UCHAR DriveNum)
{
    return DriveNum < 26 ? PhysicalDriveTypes[DriveNum] : DRIVE_UNKNOWN;
}




//
// worker function for DemGetDrives
//
UCHAR
DosDeviceDriveTypeToPhysicalDriveType(
      UCHAR DeviceDriveType
      )
{
   switch (DeviceDriveType) {
        case DOSDEVICE_DRIVE_REMOVABLE:
            return DRIVE_REMOVABLE;

        case DOSDEVICE_DRIVE_FIXED:
            return DRIVE_FIXED;

        case DOSDEVICE_DRIVE_CDROM:
            return DRIVE_CDROM;

        case DOSDEVICE_DRIVE_RAMDISK:
            return DRIVE_RAMDISK;

        }

   //case DOSDEVICE_DRIVE_REMOTE:
   //case DOSDEVICE_DRIVE_UNKNOWN:
   //default:


   return DRIVE_UNKNOWN;
}





/* demGetDrives - Get number of logical drives in the system
 *                called by ntdos from msinit to get numio
 *                initializes the physical drive list, which consists
 *                of drive types for true physical drives. subst
 *                and redir drives are classed as DRIVE_UNKNOWN.
 *
 * Entry - None
 *
 * Exit  -
 *     SUCCESS
 *      Client (CY) = 0
 *      Client (AL) = number of drives
 *
 *     FAILURE
 *      None
 */

VOID demGetDrives (VOID)
{
    NTSTATUS Status;
    UCHAR    DriveNum;
    UCHAR    DriveType;
    BOOL     bCounting;

    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfo.Query,
                                        sizeof(ProcessDeviceMapInfo.Query),
                                        NULL
                                      );
    if (!NT_SUCCESS(Status)) {
        RtlZeroMemory( &ProcessDeviceMapInfo, sizeof(ProcessDeviceMapInfo));
        }

    //
    // A and B are special cases.
    // if A doesn't exist means b also doesn't exist
    //

    PhysicalDriveTypes[0] = DosDeviceDriveTypeToPhysicalDriveType(
                                        ProcessDeviceMapInfo.Query.DriveType[0]
                                        );

    if (PhysicalDriveTypes[0] == DRIVE_UNKNOWN) {
        IsAPresent = FALSE;
        IsBPresent = FALSE;
        }


    PhysicalDriveTypes[1] = DosDeviceDriveTypeToPhysicalDriveType(
                                  ProcessDeviceMapInfo.Query.DriveType[1]
                                  );

    if (PhysicalDriveTypes[1] == DRIVE_UNKNOWN) {
        IsBPresent = FALSE;
        }

    DriveNum = 2;
    nDrives = 2;
    bCounting = TRUE;

    do {

        PhysicalDriveTypes[DriveNum] = DosDeviceDriveTypeToPhysicalDriveType(
                                            ProcessDeviceMapInfo.Query.DriveType[DriveNum]
                                            );

        if (bCounting) {
            if (PhysicalDriveTypes[DriveNum] == DRIVE_REMOVABLE ||
                PhysicalDriveTypes[DriveNum] == DRIVE_FIXED ||
                PhysicalDriveTypes[DriveNum] == DRIVE_CDROM ||
                PhysicalDriveTypes[DriveNum] == DRIVE_RAMDISK )
              {
                nDrives++;
                }
            else {
                bCounting = FALSE;
                }
            }

        } while (++DriveNum < 26);


    setAX(nDrives);
    setCF(0);
    return;

}


/* demQueryDate - Get The Date
 *
 *
 * Entry - None
 *
 * Exit  -
 *     SUCCESS
 *      Client (DH) - month
 *      Client (DL) - Day
 *      Client (CX) - Year
 *      Client (AL) - WeekDay
 *
 *     FAILURE
 *      Never
 */

VOID demQueryDate (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    setDH((UCHAR)TimeDate.wMonth);
    setDL((UCHAR)TimeDate.wDay);
    setCX(TimeDate.wYear);
    setAL((UCHAR)TimeDate.wDayOfWeek);
    return;
}


/* demQueryTime - Get The Time
 *
 *
 * Entry - None
 *
 * Exit  -
 *     SUCCESS
 *      Client (CH) - hour
 *      Client (CL) - minutes
 *      Client (DH) - seconds
 *      Client (DL) - hundredth of seconds
 *
 *     FAILURE
 *      Never
 */

VOID demQueryTime (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    setCH((UCHAR)TimeDate.wHour);
    setCL((UCHAR)TimeDate.wMinute);
    setDH((UCHAR)TimeDate.wSecond);
    setDL((UCHAR)(TimeDate.wMilliseconds/10));
    return;
}


/* demSetDate - Set The Date
 *
 *
 * Entry -  Client (CX) - Year
 *      Client (DH) - month
 *      Client (DL) - Day
 *
 * Exit  - SUCCESS
 *      Client (AL) - 00
 *
 *
 *     FAILURE
 *      Client (AL) - ff
 */

VOID demSetDate (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    TimeDate.wYear  = (WORD)getCX();
    TimeDate.wMonth = (WORD)getDH();
    TimeDate.wDay   = (WORD)getDL();
    if(SetLocalTime(&TimeDate) || GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        setAL(0);
    else
        setAL(0xff);
}


/* demSetTime - Set The Time
 *
 *
 * Entry -  Client (CH) - hour
 *      Client (CL) - minutes
 *      Client (DH) - seconds
 *      Client (DL) - hundredth of seconds
 *
 * Exit  -  None
 *
 */

VOID demSetTime (VOID)
{
SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    TimeDate.wHour     = (WORD)getCH();
    TimeDate.wMinute       = (WORD)getCL();
    TimeDate.wSecond       = (WORD)getDH();
    TimeDate.wMilliseconds = (WORD)getDL()*10;
    if (SetLocalTime(&TimeDate) || GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
	setAL(0);
    else
	setAL(0xff);
}


/* demSetDTALocation - Set The address of variable where Disk Transfer Address
 *             is stored in NTDOS.
 *
 *
 * Entry -  Client (DS:AX) - DTA variable Address
 *      Client (DS:DX) - CurrentPDB address
 *
 * Exit  -  None
 *
 */

VOID demSetDTALocation (VOID)
{
    PDOSWOWDATA pDosWowData;

    pulDTALocation = (PULONG)  GetVDMAddr(getDS(),getAX());
    pusCurrentPDB  = (PUSHORT) GetVDMAddr(getDS(),getDX());
    pExtendedError = (PDEMEXTERR) GetVDMAddr(getDS(),getCX());

    pDosWowData = (PDOSWOWDATA) GetVDMAddr(getDS(),getSI());
    pSFTHead    = (PDOSSF) GetVDMAddr(getDS(),(WORD)pDosWowData->lpSftAddr);
    return;
}


/* demGSetMediaID - Get or set volume serial and volume label
 *
 * Entry - Client (BL)     - Drive Number (0=A;1=B..etc)
 *     Client (AL)     - Get or Set (0=Get;1=Set)
 *     Client (DS:DX)  - Buffer to return information
 *               (see VOLINFO in dosdef.h)
 *
 * Exit  - SUCCESS
 *     Client (CF)     - 0
 *
 *     FAILURE
 *     Client (CF)     - 1
 *     Client (AX)     - Error code
 *
 * NOTES:
 *     Currently There is no way for us to set Volume info.
 */

VOID demGSetMediaID (VOID)
{
CHAR    Drive;
PVOLINFO pVolInfo;

    // Set Volume info is not currently supported
    if(getAL() != 0){
       setCF(1);
       return;
    }

    pVolInfo = (PVOLINFO) GetVDMAddr (getDS(),getDX());
    Drive = (CHAR)getBL();

    if (!GetMediaId(Drive, pVolInfo)) {
        demClientError(INVALID_HANDLE_VALUE, (CHAR)(Drive + 'A'));
        return;
        }

    setCF(0);
    return;
}

//
// GetMediaId
//
//
BOOL
GetMediaId(
    CHAR DriveNum,
    PVOLINFO pVolInfo
    )
{
CHAR    RootPathName[] = "?:\\";
CHAR    achVolumeName[NT_VOLUME_NAME_SIZE];
CHAR    achFileSystemType[MAX_PATH];
DWORD   adwVolumeSerial[2],i;



    // Form Root path
    RootPathName[0] = DriveNum + 'A';

    // Call the supreme source of information
    if(!GetVolumeInformationOem( RootPathName,
                                 achVolumeName,
                                 NT_VOLUME_NAME_SIZE,
                                 adwVolumeSerial,
                                 NULL,
                                 NULL,
                                 achFileSystemType,
                                 MAX_PATH) )
     {
       return FALSE;
    }

    // Fill in user buffer. Remember to convert the null characters
    // to spaces in different strings.

    STOREDWORD(pVolInfo->ulSerialNumber,adwVolumeSerial[0]);

    strncpy(pVolInfo->VolumeID,achVolumeName,DOS_VOLUME_NAME_SIZE);
    for(i=0;i<DOS_VOLUME_NAME_SIZE;i++)  {
        if (pVolInfo->VolumeID[i] == '\0')
            pVolInfo->VolumeID[i] = '\x020';
        }

    strncpy(pVolInfo->FileSystemType,achFileSystemType,FILESYS_NAME_SIZE);
    for(i=0;i<FILESYS_NAME_SIZE;i++) {
        if (pVolInfo->FileSystemType[i] == '\0')
            pVolInfo->VolumeID[i] = '\x020';
        }


    return TRUE;
}











/* demGetDPB - Get Devicr Parameter Block
 *
 * Entry - Client (AL)	   - Drive Number (0=A;1=B..etc)
 *     Client (DS:DI)	- Buffer to return information
 *
 * Exit  - SUCCESS
 *     Client (CF)     - 0
 *
 *     FAILURE
 *     Client (CF)     - 1
 *     Client (AX)     - Error code
 *
 */
VOID demGetDPB(VOID)
{
BYTE	Drive;
DPB UNALIGNED *pDPB;
BYTE    Result;

    Drive = getAL();
    pDPB = (PDPB) GetVDMAddr(getDS(), getDI());

    Result = demGetDpbI(Drive, pDPB);
    if (Result == FAILURE) {
	demClientError(INVALID_HANDLE_VALUE,(CHAR)(Drive + 'A'));
	return;
    }
    else if (Result == NODISK){
        setCF(1);
        return;
    }
    setAX(0);
    setCF(0);
}

/* demGetDPBI - Worker for GetDPB and GetDPBList
 *
 * Entry -
 *      Drive -- Drive Number (0=A;1=B..etc)
 *      pDPB -- pointer to the location to store the dpb
 *
 * Exit  - SUCCESS
 *              returns success, fills in DPB
 *          FAILURE
 *              returns FAILURE or NODISK
 */
BYTE demGetDpbI(BYTE Drive, DPB UNALIGNED *pDPB)
{
    WORD SectorSize, ClusterSize, FreeClusters, TotalClusters;
    PBDS pbds;
    WORD DirsPerSector;

    if (demGetDiskFreeSpace(Drive,
			    &SectorSize,
			    &ClusterSize,
			    &TotalClusters,
			    &FreeClusters
			    ))
    {
	pDPB->Next = (PDPB) 0xFFFFFFFF;
	pDPB->SectorSize = SectorSize;
	pDPB->FreeClusters = FreeClusters;
	pDPB->MaxCluster = TotalClusters + 1;
	pDPB->ClusterMask = ClusterSize - 1;
	pDPB->ClusterShift = 0;
	pDPB->DriveNum = pDPB->Unit = Drive;
	while ((ClusterSize & 1) == 0) {
	    ClusterSize >>= 1;
	    pDPB->ClusterShift++;
	}
	if (pbds = demGetBDS(Drive)) {
	    // if the device is a floppy, reload its bpb
	    if (!(pbds->Flags & NON_REMOVABLE) && !demGetBPB(pbds)) {
		return NODISK;
	    }
	    pDPB->MediaID = pbds->bpb.MediaID;
	    pDPB->FATSector = pbds->bpb.ReservedSectors;
	    pDPB->FATs = pbds->bpb.FATs;
	    pDPB->RootDirs = pbds->bpb.RootDirs;
	    pDPB->FATSize = pbds->bpb.FATSize;
	    pDPB->DirSector = pbds->bpb.FATs * pbds->bpb.FATSize +
			      pDPB->FATSector;
	    DirsPerSector = pDPB->SectorSize >> DOS_DIR_ENTRY_LENGTH_SHIFT_COUNT;
	    pDPB->FirstDataSector = pDPB->DirSector +
				    ((pDPB->RootDirs + DirsPerSector - 1) /
				     DirsPerSector);
	    pDPB->DriveAddr = 0x123456;
	    pDPB->FirstAccess = 10;
	}
	// if we don't know the drive, fake a DPB for it
	else {

	    pDPB->MediaID = 0xF8;
	    pDPB->FATSector = 1;
	    pDPB->FATs	= 2;
	    pDPB->RootDirs	= 63;
	    pDPB->FATSize	= 512;
	    pDPB->DirSector = 1;
	    pDPB->DriveAddr = 1212L * 64L * 1024L + 1212L;
	    pDPB->FirstAccess = 10;
	}
        return SUCCESS;
    }
    else {
        return FAILURE;
    }
}

/* demGetComputerName - Get computer name
 *
 * Entry -
 *     Client (DS:DX)   - 16 byte buffer
 *
 * Exit  - Always Succeeds
 *      DS:DX is filled with the computer name (NULL terminated).
 */

VOID demGetComputerName (VOID)
{
PCHAR   pDOSBuffer;
CHAR    ComputerName[MAX_COMPUTERNAME_LENGTH+1];
DWORD   BufferSize = MAX_COMPUTERNAME_LENGTH+1;
ULONG   i;

    pDOSBuffer = (PCHAR) GetVDMAddr(getDS(), getDX());

    if (GetComputerNameOem(ComputerName, &BufferSize)){
        if (BufferSize <= 15){
            for (i = BufferSize ; i < 15 ; i++)
                ComputerName [i] = ' ';
            ComputerName[15] = '\0';
            strcpy (pDOSBuffer, ComputerName);
        }
        else{
            strncpy (pDOSBuffer, ComputerName, 15);
            pDOSBuffer [15] = '\0';
        }
        setCX(0x1ff);
    }
    else {
        *pDOSBuffer = '\0';
        setCH(0);
    }
}

#define APPS_SPACE_LIMIT    999990*1024 //999990kb to be on the safe side

BOOL demGetDiskFreeSpace(
    BYTE    Drive,
    WORD   * BytesPerSector,
    WORD   * SectorsPerCluster,
    WORD   * TotalClusters,
    WORD   * FreeClusters
)
{
CHAR	chRoot[]="?:\\";
DWORD	dwBytesPerSector;
DWORD	dwSectorsPerCluster;
DWORD	dwTotalClusters;
DWORD	dwFreeClusters;
DWORD   dwLostFreeSectors;
DWORD   dwLostTotalSectors;
DWORD   dwNewSectorPerCluster;
ULONG   ulTotal,ulTemp;

    // sudeepb 22-Jun-1993;
    // Please read this routine with an empty stomach.
    // The most common mistake all the apps do when calculating total
    // disk space or free space is to neglect overflow. Excel/Winword/Ppnt
    // and lots of other apps use "mul cx mul bx" never taking care
    // of first multiplication which can overflow. Hence this routine makes
    // sure that first multiplication will never overflow by fixing
    // appropriate values. Secondly, all these above apps use signed long
    // to deal with these free spaces. This puts a limit of 2Gb-1 on
    // the final outcome of the multiplication. If its above this the setup
    // fails. So here we have to make sure that total should never exceed
    // 0x7fffffff. Another bug in above setup program's that if you return
    // anything more than 999,999KB then they try to put "999,999KB+\0", but
    // unfortunately the buffer is only 10 bytes. Hence it corrupts something
    // with the last byte. In our case that is low byte of a segment which
    // it later tries to pop and GPF. This shrinks the maximum size that
    // we can return is 999,999KB.

    chRoot[0]=(CHAR)('A'+ Drive);

    if (GetDiskFreeSpaceOem(chRoot,
                            &dwSectorsPerCluster,
                            &dwBytesPerSector,
                            &dwFreeClusters,
                            &dwTotalClusters) == FALSE)
       return FALSE;

      /*
       *  HPFS and NTFS can give num clusters over dos limit
       *  For these cases increase SectorPerCluster and lower
       *  cluster number accordingly. If the disk is very large
       *  even this isn't enuf, so pass max sizes that dos can
       *  handle.
       *
       *  The following algorithm is accurate within 1 cluster
       *  (final figure)
       *
       */
    dwLostFreeSectors  = dwLostTotalSectors = 0;
    while (dwTotalClusters + dwLostTotalSectors/dwSectorsPerCluster > 0xFFFF)
        {
         if (dwSectorsPerCluster > 0x7FFF)
            {
             dwTotalClusters     = 0xFFFF;
             if (dwFreeClusters > 0xFFFF)
                 dwFreeClusters = 0xFFFF;
             break;
             }

         if (dwFreeClusters & 1) {
             dwLostFreeSectors += dwSectorsPerCluster;
             }
         if (dwTotalClusters & 1) {
             dwLostTotalSectors += dwSectorsPerCluster;
             }
         dwSectorsPerCluster <<= 1;
         dwFreeClusters      >>= 1;
         dwTotalClusters     >>= 1;
         }

    if (dwTotalClusters < 0xFFFF) {
        dwFreeClusters   +=  dwLostFreeSectors/dwSectorsPerCluster;
        dwTotalClusters  +=  dwLostTotalSectors/dwSectorsPerCluster;
        }

    if ((dwNewSectorPerCluster = (0xffff / dwBytesPerSector)) < dwSectorsPerCluster)
        dwSectorsPerCluster = dwNewSectorPerCluster;

    // finally check for 999,999kb
    ulTemp =  (ULONG)((USHORT)dwSectorsPerCluster * (USHORT)dwBytesPerSector);

    // check that total space does'nt exceed 999,999kb
    ulTotal = ulTemp * (USHORT)dwTotalClusters;

    if (ulTotal > APPS_SPACE_LIMIT){
        if (ulTemp <= APPS_SPACE_LIMIT)
            dwTotalClusters = APPS_SPACE_LIMIT / ulTemp;
        else
            dwTotalClusters = 1;
    }

    ulTotal = ulTemp * (USHORT)dwFreeClusters;

    if (ulTotal > APPS_SPACE_LIMIT) {
        if (ulTemp <= APPS_SPACE_LIMIT)
            dwFreeClusters = APPS_SPACE_LIMIT / ulTemp;
        else
            dwFreeClusters = 1;
    }

    *BytesPerSector = (WORD) dwBytesPerSector;
    *SectorsPerCluster = (WORD) dwSectorsPerCluster;
    *TotalClusters = (WORD) dwTotalClusters;
    *FreeClusters = (WORD) dwFreeClusters;
    return TRUE;
}

/* demGetDPBList - Create the list of dpbs
 *
 * Entry -
 *      Client(ES:BP) - points to destination for the dpb list
 * Exit  - SUCCESS
 *      Client (BP) - points to first byte past dpb list
 *     FAILURE
 *      Client (BP) unchanged
 *
 * Notes:
 *      For performance reasons, only the drive and unit fields are
 *      filled in.  The only application I know of that depends on the
 *      dpb list is go.exe (a shareware app installer).  Even if we filled
 *      in the other fields they would likely be incorrect when the app
 *      looked at them, since ntdos.sys never updates the pdbs in the pdb
 *      list
 */
VOID demGetDPBList (VOID)
{
    UCHAR DriveType;
    UCHAR DriveNum;
    DPB UNALIGNED *pDpb;
    USHORT usDpbOffset, usDpbSeg;

    usDpbOffset = getBP();
    usDpbSeg = getES();
    pDpb = (PDPB)GetVDMAddr(usDpbSeg, usDpbOffset);

    //
    // Iterate over all of the drive letters.
    //
    DriveNum = 0;
    do {
        DriveType = demGetPhysicalDriveType(DriveNum);

        //
        // Only include the local non cd rom drives ?? ramdisk ???
        //
        if ((DriveType == DRIVE_REMOVABLE) || (DriveType == DRIVE_FIXED)) {

            //
            // Fake the Dpb for the drive
            //
            pDpb->DriveNum = pDpb->Unit = DriveNum;

            //
            // Link it to the next dpb
            //
            usDpbOffset += sizeof(DPB);
            pDpb->Next = (PDPB)(((ULONG)usDpbSeg) << 16 | usDpbOffset);

            //
            // Advance to the next dpb
            //
            pDpb += 1;

            ASSERT(usDpbOffset < 0xFFFF);
        }

    } while (++DriveNum < 26);

    //
    // Terminate the list if necessary
    //
    if (usDpbOffset != getBP()) {
        pDpb -= 1;
        pDpb->Next = (PDPB)-1;
    }

    //
    // Return the new free space pointer
    //
    setBP(usDpbOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demlabel.c ===
/* demlabel.c - functions for working this volume labels.
 *
 * demDeleteLabel()
 * demCreateLabel()
 *
 * Modification History:
 *
 * YST 1-Feb-1993 Created
 *
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>

#include <winbase.h>

USHORT demDeleteLabel(BYTE Drive)
{
    CHAR szStr[32];


    sprintf(szStr, "%c:\\", Drive);

    if(!SetVolumeLabelA(szStr, NULL))
	return(1);
    else
	return(0);
}


USHORT demCreateLabel(BYTE Drive, LPSTR lpszName)
{
    CHAR szStr[32];
    CHAR szAnsi[32];
    CHAR szTmp[32];
    CHAR *p, *s;
    int  i = 0;


    sprintf(szStr, "%c:\\", Drive);

    s = lpszName;
    p = szTmp;

    while(s) {
	if(*s != '.')  {
	    *p = *s;
	    i++;
	    p++;
	}
	else {
	    while(i < 8) {
		*p++ = ' ';
		i++;
	    }
	}
	s++;

	if(i > 11)
	    break;
    }

    szTmp[i] = '\0';

    OemToAnsi(szTmp, szAnsi);

    if(!SetVolumeLabelA(szStr, szAnsi))
	return(1);

    else
	return(0);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demioctl.c ===
/* demioctl.c - SVC handlers for DOS IOCTL calls
 *
 * demIOCTL
 *
 * Modification History:
 *
 * Sudeepb 23-Apr-1991 Created
 *
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <winbase.h>
#include "demdasd.h"

PFNSVC	apfnSVCIoctl [] = {
    demIoctlInvalid,		// IOCTL_GET_DEVICE_INFO    0
    demIoctlInvalid,		// IOCTL_SET_DEVICE_INFO    1
    demIoctlInvalid,		// IOCTL_READ_HANDLE	    2
    demIoctlInvalid,		// IOCTL_WRITE_HANDLE	    3
    demIoctlInvalid,		// IOCTL_READ_DRIVE	    4
    demIoctlInvalid,		// IOCTL_WRITE_DRIVE	    5
    demIoctlInvalid,		// IOCTL_GET_INPUT_STATUS   6
    demIoctlInvalid,		// IOCTL_GET_OUTPUT_STATUS  7
    demIoctlChangeable,		// IOCTL_CHANGEABLE	    8
    demIoctlChangeable,		// IOCTL_DeviceLocOrRem     9
    demIoctlInvalid,		// IOCTL_HandleLocOrRem     a
    demIoctlInvalid,		// IOCTL_SHARING_RETRY	    b
    demIoctlInvalid,		// GENERIC_IOCTL_HANDLE     c
    demIoctlDiskGeneric,	// GENERIC_IOCTL	    d
    demIoctlInvalid,            // IOCTL_GET_DRIVE_MAP      e
    demIoctlInvalid,		// IOCTL_SET_DRIVE_MAP	    f
    demIoctlInvalid,		// IOCTL_QUERY_HANDLE	    10
    demIoctlDiskQuery,		// IOCTL_QUERY_BLOCK	    11
    demIoctlInvalid

};

MEDIA_TYPE  MediaForFormat;

#define MAX_IOCTL_INDEX     (sizeof (apfnSVCIoctl) / sizeof (PFNSVC))


/* demIOCTL - DOS IOCTLS
 *
 *
 * Entry - depends on the subfunction. See dos\ioctl.asm
 *
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *	     for other registers see the corresponding function header
 *
 *	   FAILURE
 *	     Client (CY) = 1
 *	     for other registers see the corresponding function header
 */

VOID demIOCTL (VOID)
{
ULONG	iIoctl;

    iIoctl = (ULONG) getAL();

#if DBG
    if (iIoctl >= MAX_IOCTL_INDEX){
	setAX((USHORT) ERROR_INVALID_FUNCTION);
        setCF(1);
        return;
    }
#endif

    (apfnSVCIoctl [iIoctl])();

    return;
}

/* demIoctlChangeable - Is drive removeable (subfunc 8) or remote (subfunc 9)
 *
 *
 * Entry - Client (AL) - subfunc
 *	   Client (BL) - drive number (a=0,b=1 etc)
 *
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *	     if subfunc 8
 *		AX = 0	if removeable media
 *		AX = 1	otherwise
 *	     if subfunc 9
 *              DX = 0     if not remote
 *              DX = 1000  if remote
 *
 *	   FAILURE
 *	     Client (CY) = 1
 *           Client (AX) = error code
 *
 *  CDROM drives are considered remote drives with write protection
 *        by dos. (full support requires a VDD)
 */

VOID demIoctlChangeable (VOID)
{
ULONG	ulSubFunc;

CHAR	RootPathName[] = "?:\\";
DWORD   DriveType;
UCHAR   DriveNum;

    ulSubFunc = getAL();

    // Form Root path
    DriveNum = getBL();
    DriveType = demGetPhysicalDriveType(DriveNum);
    if (DriveType == DRIVE_UNKNOWN) {
        RootPathName[0] = (CHAR)('A' + DriveNum);
        DriveType = GetDriveTypeOem(RootPathName);
    }

    if (DriveType == DRIVE_UNKNOWN || DriveType == DRIVE_NO_ROOT_DIR){
	setAX (ERROR_INVALID_DRIVE);
	setCF(1);
	return;
    }

    if (ulSubFunc == IOCTL_CHANGEABLE){
#ifdef	JAPAN
	/* For MS-WORKS 2.5 */
        if (DriveType == DRIVE_REMOTE || DriveType == DRIVE_CDROM){
	    setCF(1);
	    setAX(0x000f);
	    return;
	}
#endif // JAPAN
        if(DriveType == DRIVE_REMOVABLE)
	    setAX(0);
	else
            setAX(1);  // includes CDROM drives
    }
    else {
        setAL(0);
        if (DriveType == DRIVE_REMOTE || DriveType == DRIVE_CDROM)
#ifdef	JAPAN
	/* For ICHITARO Ver.4 */
            setDH(0x10);
        else
            setDH(0);
#else // !JAPAN
            setDX(0x1000);
        else
            // We have to return 800 rather then 0 as Dos Based Quatrro pro
            // behaves very badly if this bit is not set. sudeepb 15-Jun-1994
            setDX(0x800);
#endif // !JAPAN
    }
    setCF(0);
    return;

}



/* demIoctlDiskGeneric - Block device generic ioctl
 *
 *
 * Entry - Client (BL) = drive number (a=0;b=1 etc)
 *		  (CL) = subfucntion code
 *		  (SI:DX) pointer to parameter block.
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *		    (AX) = 0
 *		    parameter block updated
 *	   FAILURE
 *	     Client (CY) = 1
 *		    (AX) = error code
 */

VOID demIoctlDiskGeneric (VOID)

{
    BYTE    Code, Drive;
    PDEVICE_PARAMETERS	pdms;
    PMID      pmid;
    PRW_BLOCK pRW;
    PFMT_BLOCK pfmt;
    PBDS    pbds;
    DWORD    Head, Cylinder;
    DWORD    TrackSize;
    DWORD    Sectors, StartSector;
    BYTE    BootSector[BYTES_PER_SECTOR];
    PBOOTSECTOR pbs;
    PBPB    pBPB;
    PACCESSCTRL pAccessCtrl;
    WORD SectorSize, ClusterSize, TotalClusters, FreeClusters;

    Code = getCL();
    Drive = getBL();

    if (Code == IOCTL_GETMEDIA) {
        pmid = (PMID) GetVDMAddr(getSI(), getDX());
        if (!GetMediaId(Drive, (PVOLINFO)pmid)) {
            setAX(demWinErrorToDosError(GetLastError()));
            setCF(1);
            }
        else {
            setAX(0);
            setCF(0);
            }

        return;
        }


#ifdef	JAPAN
    /* For Ichitaro Ver.4 */
    if (!demIsDriveFloppy(Drive) && Code==IOCTL_GETDPM){
	CHAR	RootPathName[] = "?:\\";
	DWORD	dwDriveType;
	RootPathName[0] = (CHAR)('A' + getBL());
	dwDriveType = GetDriveTypeOem(RootPathName);
	if (dwDriveType == DRIVE_FIXED){
	    pdms = (PDEVICE_PARAMETERS)GetVDMAddr(getSI(), getDX());
	    pdms->DeviceType  = 5;
	    pdms->DeviceAttrs = NON_REMOVABLE;
	}
    }
#endif // JAPAN

    // if we don't know the drive, bail out
    if((pbds = demGetBDS(Drive)) == NULL && Code != IOCTL_GETDPM) {
#if defined(NEC_98)
        setAX(DOS_FILE_NOT_FOUND);
#else  // !NEC_98
	if (!demIsDriveFloppy(Drive))
	    host_direct_access_error(NOSUPPORT_HARDDISK);
	setAX(DOS_FILE_NOT_FOUND);
#endif // !NEC_98
	setCF(1);
	return;
    }
    switch (Code) {
	case IOCTL_SETDPM:

		pdms = (PDEVICE_PARAMETERS)GetVDMAddr(getSI(), getDX());
		if (!(pdms->Functions & ONLY_SET_TRACKLAYOUT)) {
		    pbds->FormFactor = pdms->DeviceType;
		    pbds->Cylinders = pdms->Cylinders;
		    pbds->Flags = pdms->DeviceAttrs;
		    pbds->MediaType = pdms->MediaType;
		    if (pdms->Functions & INSTALL_FAKE_BPB) {
			pbds->Flags |= RETURN_FAKE_BPB;
			pbds->bpb = pdms->bpb;
			// update the total sectors, we need it
			// for verification
			pbds->TotalSectors = (pbds->bpb.Sectors) ?
					     pbds->bpb.Sectors :
					     pbds->bpb.BigSectors;
		    }
		    else {
			pbds->Flags &= ~RETURN_FAKE_BPB;
			pbds->rbpb = pdms->bpb;
		    }
		}
		MediaForFormat = Unknown;
		if (!(pbds->Flags & NON_REMOVABLE)){
		    nt_floppy_close(pbds->DrivePhys);
		}
		else {
		    nt_fdisk_close(pbds->DrivePhys);
		}
		break;

	case IOCTL_WRITETRACK:

		pRW = (PRW_BLOCK) GetVDMAddr(getSI(), getDX());
		Sectors = pRW->Sectors;
		StartSector = pRW->StartSector;
		StartSector += pbds->bpb.TrackSize *
			       (pRW->Cylinder * pbds->bpb.Heads + pRW->Head);
		Sectors = demDasdWrite(pbds,
				       StartSector,
				       Sectors,
				       pRW->BufferOff,
				       pRW->BufferSeg
				       );
		if (Sectors != pRW->Sectors) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;

	    case IOCTL_FORMATTRACK:
		pfmt = (PFMT_BLOCK)GetVDMAddr(getSI(), getDX());
		Head = pfmt->Head;
		Cylinder = pfmt->Cylinder;
		if ((pbds->Flags & NON_REMOVABLE) &&
		    pfmt->Head < pbds->bpb.Heads &&
		    pfmt->Cylinder < pbds->Cylinders)
		    {
		    if (pfmt->Functions == STATUS_FOR_FORMAT){
			pfmt->Functions = 0;
			setCF(0);
			return;
		    }
		    if (!demDasdFormat(pbds, Head, Cylinder, NULL)) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		}
		else {
		    if (MediaForFormat == Unknown) {
			demDasdFormat(pbds,
				      Head,
				      Cylinder,
				      &MediaForFormat
				      );
		    }
		    if (pfmt->Functions & STATUS_FOR_FORMAT){
			if (MediaForFormat == Unknown)
			    pfmt->Functions = 2;	// illegal combination
			else
			    pfmt->Functions = 0;
			break;
		    }
		    if (MediaForFormat == Unknown ||
			!demDasdFormat(pbds, Head, Cylinder, &MediaForFormat)) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		}
		break;

	    case IOCTL_SETMEDIA:
		pmid = (PMID) GetVDMAddr(getSI(), getDX());

		if (pbds->Flags & NON_REMOVABLE) {
		    Sectors = nt_fdisk_read(pbds->DrivePhys,
					    0,
					    BYTES_PER_SECTOR,
					    BootSector
					    );
		}
		else {
		    if (demGetBPB(pbds))
			Sectors = nt_floppy_read(pbds->DrivePhys,
						 0,
						 BYTES_PER_SECTOR,
						 BootSector
						 );
		    else
			Sectors = 0;
		}
		pbs = (PBOOTSECTOR) BootSector;
		if (Sectors != BYTES_PER_SECTOR ||
		    pbs->ExtBootSig != EXT_BOOTSECT_SIG)
		    {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		pbs->SerialNum = pmid->SerialNum;
		pbs->Label = pmid->Label;
		pbs->FileSysType = pmid->FileSysType;
		if (pbds->Flags & NON_REMOVABLE) {
		    Sectors = nt_fdisk_write(pbds->DrivePhys,
					     0,
					     BYTES_PER_SECTOR,
					     (PBYTE)pbs
					     );
		    nt_fdisk_close(pbds->DrivePhys);
		}
		else {
		    Sectors = nt_floppy_write(pbds->DrivePhys,
					      0,
					      BYTES_PER_SECTOR,
					      (PBYTE) pbs
					      );
		    nt_floppy_close(pbds->DrivePhys);
		}
		if (Sectors != BYTES_PER_SECTOR) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;


	    // ioctl get device parameters
	    case IOCTL_GETDPM:
		pdms = (PDEVICE_PARAMETERS)GetVDMAddr(getSI(), getDX());
		// if we couldn't find the bds, fake one
		if (pbds == NULL) {
		    HANDLE	  hVolume;
		    CHAR	  achRoot[]="\\\\.\\?:";
		    DISK_GEOMETRY DiskGM;
		    DWORD	  SizeReturned;

		    if (!demGetDiskFreeSpace(Drive,
					    &SectorSize,
					    &ClusterSize,
					    &TotalClusters,
					    &FreeClusters
					    )){
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }

		    achRoot[4] = Drive + 'A';

		    hVolume = CreateFileA(achRoot,
					  FILE_READ_ATTRIBUTES | SYNCHRONIZE,
					  FILE_SHARE_READ | FILE_SHARE_WRITE,
					  NULL,
					  OPEN_EXISTING,
					  0,
					  NULL);
		    if (hVolume == INVALID_HANDLE_VALUE) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		    if (!DeviceIoControl(hVolume,
					 IOCTL_DISK_GET_DRIVE_GEOMETRY,
					 NULL,
					 0,
					 &DiskGM,
					 sizeof(DISK_GEOMETRY),
					 &SizeReturned,
					 NULL
					 )) {
			CloseHandle(hVolume);
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		    CloseHandle(hVolume);
		    Sectors = DiskGM.Cylinders.LowPart *
			      DiskGM.TracksPerCylinder *
			      DiskGM.SectorsPerTrack;
		    pdms->DeviceType = FF_FDISK;
		    pdms->DeviceAttrs = NON_REMOVABLE;
		    pdms->MediaType = 0;
		    pdms->bpb.SectorSize = SectorSize;
                    pdms->bpb.ClusterSize = (BYTE) ClusterSize;
		    pdms->bpb.ReservedSectors = 1;
		    pdms->bpb.FATs = 2;
		    pdms->bpb.RootDirs = (Sectors > 32680) ? 512 : 64;
		    pdms->bpb.MediaID = 0xF8;
                    pdms->bpb.TrackSize = (WORD) DiskGM.SectorsPerTrack;
                    pdms->bpb.Heads = (WORD) DiskGM.TracksPerCylinder;
                    pdms->Cylinders = (WORD) DiskGM.Cylinders.LowPart;
		    if (Sectors >= 40000) {
			TrackSize = 256 * ClusterSize + 2;
                        pdms->bpb.FATSize = (WORD) ((Sectors - pdms->bpb.ReservedSectors
					     - pdms->bpb.RootDirs * 32 / 512 +
                                             TrackSize - 1 ) / TrackSize);
		    }
		    else {
                        pdms->bpb.FATSize = (WORD) (((Sectors / ClusterSize) * 3 / 2) /
                                            512 + 1);
		    }
		    pdms->bpb.HiddenSectors = Sectors;
		    Sectors = TotalClusters * ClusterSize;
		    if (Sectors >= 0x10000) {
			pdms->bpb.Sectors = 0;
			pdms->bpb.BigSectors = Sectors;
		    }
		    else {
                        pdms->bpb.Sectors = (WORD) Sectors;
			pdms->bpb.BigSectors = 0;
		    }
		    pdms->bpb.HiddenSectors -= Sectors;
		    break;
		}
		pdms->DeviceType = pbds->FormFactor;
		pdms->DeviceAttrs = pbds->Flags & ~(HAS_CHANGELINE);
		pdms->Cylinders = pbds->Cylinders;
		pdms->MediaType = 0;
		if (pdms->Functions & BUILD_DEVICE_BPB){
		    if (!(pbds->Flags & NON_REMOVABLE) &&
			!demGetBPB(pbds)) {
			setAX(demWinErrorToDosError(GetLastError()));
			setCF(1);
			return;
		    }
		    pBPB = &pbds->bpb;
		}
		else
		    // copy recommended bpb
		    pBPB = &pbds->rbpb;

		pdms->bpb = *pBPB;
		break;

	    case IOCTL_READTRACK:
		pRW = (PRW_BLOCK) GetVDMAddr(getSI(), getDX());
		Sectors = pRW->Sectors;
		StartSector = pRW->StartSector;
		StartSector += pbds->bpb.TrackSize *
			       (pRW->Cylinder * pbds->bpb.Heads + pRW->Head);
		Sectors = demDasdRead(pbds,
				      StartSector,
				      Sectors,
				      pRW->BufferOff,
				      pRW->BufferSeg
				      );

		if (Sectors != pRW->Sectors) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;

	    case IOCTL_VERIFYTRACK:
		pfmt = (PFMT_BLOCK) GetVDMAddr(getSI(), getDX());
		if(!demDasdVerify(pbds,  pfmt->Head, pfmt->Cylinder)) {
		    setAX(demWinErrorToDosError(GetLastError()));
		    setCF(1);
		    return;
		}
		break;

            case IOCTL_GETACCESS:
		    pAccessCtrl = (PACCESSCTRL) GetVDMAddr(getSI(), getDX());
		    pAccessCtrl->AccessFlag = (pbds->Flags & UNFORMATTED_MEDIA) ?
					       0 : 1;
		    break;
	    case IOCTL_SETACCESS:
		    pAccessCtrl = (PACCESSCTRL) GetVDMAddr(getSI(), getDX());
		    pbds->Flags &= ~(UNFORMATTED_MEDIA);
		    if (pAccessCtrl->AccessFlag == 0)
#if defined(NEC_98) 
                        pbds->Flags |= UNFORMATTED_MEDIA; 
#else  // !NEC_98
			pAccessCtrl->AccessFlag |= UNFORMATTED_MEDIA;
#endif // !NEC_98
		    break;

	    default:
		setAX(DOS_INVALID_FUNCTION);
		setCF(1);
		return;
	}
    setAX(0);
    setCF(0);
}

/* demIoctlDiskQuery - Query block device generic ioctl capability
 *
 *
 * Entry - Client (BL) = drive number (a=0;b=1 etc)
 *		  (CL) = generic ioctl subfuntion to be queried
 * Exit
 *	   SUCCESS
 *	     Client (CY) = 0
 *		   The specific ioctl is supported
 *	   FAILURE
 *	     Client (CY) = 1
 *		    The given ioctl is not supported
 */

VOID demIoctlDiskQuery (VOID)
{
    BYTE    Code, Drive;

    Code = getCL();
    Drive = getBL();
    if (demGetBDS(Drive) == NULL) {
	setAX(DOS_FILE_NOT_FOUND);
	setCF(1);
	return;
    }
    switch (Code) {

	case IOCTL_SETDPM:
	case IOCTL_WRITETRACK:
	case IOCTL_FORMATTRACK:
	case IOCTL_SETMEDIA:
	case IOCTL_GETDPM:
	case IOCTL_READTRACK:
	case IOCTL_VERIFYTRACK:
	case IOCTL_GETMEDIA:
//	case IOCTL_GETACCESS:
//	case IOCTL_SETACCESS:
		setAX(0);
		setCF(0);
		break;
	default:
		setAX(DOS_ACCESS_DENIED);
		setCF(1);
		break;
    }
}


/* demIoctlInvalid - For those subfunctions which may be implemented later
 *
 *
 * Entry -
 *
 * Exit
 *	     Client (CY) = 1
 *	     Client (AX) = error_invalid_function
 */


VOID demIoctlInvalid (VOID)
{
    setCF(1);
    setAX(ERROR_INVALID_FUNCTION);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demhndl.c ===
/* demhndl.c - SVC handlers for calls where file handle is provided.
 *
 * demClose
 * demRead
 * demWrite
 * demChgFilePtr
 * demFileTimes
 *
 * Modification History:
 *
 * Sudeepb 02-Apr-1991 Created
 * rfirth  25-Sep-1991 Added Vdm Redir stuff for named pipes
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <io.h>
#include <fcntl.h>
#include <vrnmpipe.h>
#include <exterr.h>
#include <mvdm.h>

BOOL (*VrInitialized)(VOID);  // POINTER TO FUNCTION
extern BOOL IsVdmRedirLoaded(VOID);

/* demClose - Close a file
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX:DX) File position (if -1 no seek needed before closing
 *                        the handle.
 *         (VadimB)
 *         Client (es:di) SFT ptr - this is implied in abort.asm code
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demClose (VOID)
{
HANDLE  hFile;
LONG    lLoc;
USHORT  usDX,usCX;

    hFile = GETHANDLE (getAX(),getBP());

    if (hFile == 0) {
    setCF (0);
    return;
    }

    usCX = getCX();
    usDX = getDX();

    if (!((usCX == (USHORT)-1) && (usDX == (USHORT)-1))) {
        lLoc  = (LONG)((((int)usCX) << 16) + (int)usDX);
        if (SetFilePointer (hFile,
                            lLoc,
                            NULL,
                            FILE_BEGIN) == -1L){
            demClientError(hFile, (CHAR)-1);
            return ;
        }

    }

    if (CloseHandle (hFile) == FALSE){
        demClientError(hFile, (CHAR)-1);
        return;
    }

    //
    // if the redir TSR is being run in this VDM session, check if the handle
    // being closed references a named pipe - we have to delete some info
    // that we keep for the open named pipe
    //

    if (IsVdmRedirLoaded()) {
        VrRemoveOpenNamedPipeInfo(hFile);
    }

    setCF(0);
    return;
}


/* demRead - Read a file
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX)    Count to read
 *         Client (DS:DX) Buffer Address
 *         Client (BX:SI) = current file pointer location.
 *         ZF = 1 if seek is not needed prior to read.
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Count of bytes read
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demRead (VOID)
{
HANDLE  hFile;
LPVOID  lpBuf;
DWORD   dwBytesRead;
USHORT  usDS,usDX;
DWORD   dwReadError;
BOOL    ok;
UCHAR   locus, action, class;
LONG    lLoc;

    hFile = GETHANDLE (getAX(),getBP());
    usDS = getDS();
    usDX = getDX();
    lpBuf  = (LPVOID) GetVDMAddr (usDS,usDX);

    //
    // if this handle is a named pipe then use VrReadNamedPipe since we have
    // to perform an overlapped read, and wait on the event handle for completion
    // even though we're still doing synchronous read
    //

    if (IsVdmRedirLoaded()) {
        if (VrIsNamedPipeHandle(hFile)) {

            //
            // named pipe read always sets the extended error information in the
            // DOS data segment. This is the only way we can return bytes read
            // information and a more data indication
            //

            ok = VrReadNamedPipe(hFile,
                                 lpBuf,
                                 (DWORD)getCX(),
                                 &dwBytesRead,
                                 &dwReadError
                                 );
            switch (dwReadError) {
            case NO_ERROR:
                locus = action = class = 0;
                break;

            case ERROR_NO_DATA:
            case ERROR_MORE_DATA:
                locus = errLOC_Net;
                class = errCLASS_TempSit;
                action = errACT_Retry;
                break;

            default:

                //
                // any error other than the specific ones we handle here should be
                // correctly handled by DOS
                //

                goto readFailureExit;
            }
            pExtendedError->ExtendedErrorLocus = locus;
            STOREWORD(pExtendedError->ExtendedError, (WORD)dwReadError);
            pExtendedError->ExtendedErrorAction = action;
            pExtendedError->ExtendedErrorClass = class;
            if (ok) {
                goto readSuccessExit;
            } else {
                goto readFailureExit;
            }
        }
    }

    //
    // if the redir TSR is not loaded, or the handle is not a named pipe then
    // perform normal file read
    //

    if (!getZF()) {
        ULONG   Zero = 0;
        lLoc  = (LONG)((((int)getBX()) << 16) + (int)getSI());
        if ((SetFilePointer (hFile,
                            lLoc,
                            &Zero,
                            FILE_BEGIN) == -1L) &&
            (GetLastError() != NO_ERROR)) {
            goto readFailureExit;
        }

    }

    if (ReadFile (hFile,
                  lpBuf,
                  (DWORD)getCX(),
                  &dwBytesRead,
                  NULL) == FALSE){

readFailureExit:
        Sim32FlushVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                               (PBYTE )lpBuf, FALSE);
        Sim32FreeVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                               (PBYTE )lpBuf, FALSE);

        if (GetLastError() == ERROR_BROKEN_PIPE)  {
             setAX(0);
             setCF(0);
             return;
         }
        demClientError(hFile, (CHAR)-1);
        return ;
    }

readSuccessExit:
    Sim32FlushVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                          (PBYTE )lpBuf, FALSE);
    Sim32FreeVDMPointer (((ULONG)(usDS << 16)) | usDX, getCX(),
                         (PBYTE )lpBuf, FALSE);
    setCF(0);
    setAX((USHORT)dwBytesRead);
    return;
}



/* demWrite - Write to a file
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX)    Count to write
 *         Client (DS:DX) Buffer Address
 *         Client (BX:SI) = current file pointer location.
 *         ZF = 1 if seek is not needed prior to write.
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Count of bytes written
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demWrite (VOID)
{
HANDLE  hFile;
DWORD   dwBytesWritten;
LPVOID  lpBuf;
LONG    lLoc;
DWORD   dwErrCode;

    hFile = GETHANDLE (getAX(),getBP());
    lpBuf  = (LPVOID) GetVDMAddr (getDS(),getDX());


    //
    // if this handle is a named pipe then use VrWriteNamedPipe since we have
    // to perform an overlapped write, and wait on the event handle for completion
    // even though we're still doing synchronous write
    //

    if (IsVdmRedirLoaded()) {
        if (VrIsNamedPipeHandle(hFile)) {
            if (VrWriteNamedPipe(hFile, lpBuf, (DWORD)getCX(), &dwBytesWritten)) {
                goto writeSuccessExit;
            } else {
                goto writeFailureExit;
            }
        }
    }

    //
    // if the redir TSR is not loaded, or the handle is not a named pipe then
    // perform normal file write
    //


    if (!getZF()) {
        ULONG   Zero = 0;
        lLoc  = (LONG)((((int)getBX()) << 16) + (int)getSI());
        if ((SetFilePointer (hFile,
                            lLoc,
                            &Zero,
                            FILE_BEGIN) == -1L) &&
            (GetLastError() != NO_ERROR)) {
            demClientError(hFile, (CHAR)-1);
            return ;
        }

    }

    // In DOS CX=0 truncates or extends the file to current file pointer.
    if (getCX() == 0){
        if (SetEndOfFile(hFile) == FALSE){
            demClientError(hFile, (CHAR)-1);
            return;
        }
        setCF (0);
        return;
    }

    if (WriteFile (hFile,
           lpBuf,
           (DWORD)getCX(),
           &dwBytesWritten,
           NULL) == FALSE){

        // If disk is full then we should return 0 byte written and CF is clear
        dwErrCode = GetLastError();
        if(dwErrCode == ERROR_DISK_FULL) {

            setCF(0);
            setAX(0);
            return;
        }

        SetLastError(dwErrCode);

writeFailureExit:
        demClientError(hFile, (CHAR)-1);
        return ;
    }

writeSuccessExit:
    setCF(0);
    setAX((USHORT)dwBytesWritten);
    return;
}



/* demChgFilePtr - Change File Pointer
 *
 *
 * Entry - Client (AX:BP) File Handle
 *         Client (CX:DX) New Location
 *         Client (BL)    Positioning Method
 *                        0 - File Absolute
 *                        1 - Relative to Current Position
 *                        2 - Relative to end of file
 *
 * Exit
 *         SUCCESS
 *           Client (CY)    = 0
 *           Client (DX:AX) = New Location
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = system status code
 *
 */

VOID demChgFilePtr (VOID)
{
HANDLE  hFile;
LONG    lLoc;
DWORD   dwLoc;

#if (FILE_BEGIN != 0 || FILE_CURRENT != 1 || FILE_END !=2)
    #error "Win32 values not DOS compatible"
#

#endif
    hFile =  GETHANDLE (getAX(),getBP());
    lLoc  = (LONG)((((int)getCX()) << 16) + (int)getDX());

    if ((dwLoc = SetFilePointer (hFile,
                               lLoc,
                               NULL,
                               (DWORD)getBL())) == -1L){
        demClientError(hFile, (CHAR)-1);
        return ;
    }

    setCF(0);
    setAX((USHORT)dwLoc);
    setDX((USHORT)(dwLoc >> 16));
    return;
}


#if 0

/*
 * Completely moved to demlfn.c
 *
 *
 *
 */

/* demFileTimes - Change or Get File date and times
 *
 * GET TIME (Client(BL) = 0)
 *
 *          Entry
 *              Client(AX:BP)
 *                  NT Handle
 *
 *          Exit
 *              SUCCESS
 *                  Client(CF) = 0
 *                  Client(CX) = File time
 *                  Client(DX) = File date
 *              FAILURE
 *                  Client(CF) = 1
 *                  Client(AX) = error code
 *
 * SET TIME (Client(BL) = 1)
 *
 *          Entry
 *              Client(AX:BP)
 *                  Nt Handle
 *              Client(CX)
 *                  New file time
 *              Client(DX)
 *                  New file date
 *
 *          Exit
 *              SUCCESS
 *                  Client(CF) = 0
 *              FAILURE
 *                  Client(CF) = 1
 *                  Client(AX) = error code
 *
 *          Hard Error Exit
 *              Client(CF) = 1
 *              Client(AX) = 0FFFFh
 *
 * GET TIME For device (Client(BL) = 2)
 *
 *          Entry
 *              Client(AX:BP)
 *                  NT Handle  - not in use
 *
 *          Exit
 *              SUCCESS
 *                  Client(CF) = 0
 *                  Client(CX) = Current time
 *                  Client(DX) = Curren  date
 *              FAILURE
 *                  None
 *
 */

VOID demFileTimes (VOID)
{
HANDLE  hFile;
WORD    wDate,wTime;
FILETIME LastWriteTime,ftTemp;
SYSTEMTIME stCurrentTime;
UCHAR   uchOpt = 0;

    uchOpt = getBL();
    if(uchOpt != 2)
        hFile = GETHANDLE(getAX(),getBP());

    if(uchOpt != 1){

        if(!uchOpt) {
            if(GetFileTime (hFile,NULL,NULL,&LastWriteTime) == -1){
                demClientError(hFile, (CHAR)-1);
                return;
            }
        }
        else {          // Device case. We should return current time
            GetSystemTime(&stCurrentTime);
            SystemTimeToFileTime(&stCurrentTime, &LastWriteTime);

        }

        FileTimeToLocalFileTime (&LastWriteTime,&ftTemp);
        if(FileTimeToDosDateTime(&ftTemp,
                                 (LPWORD)&wDate,
                                 (LPWORD)&wTime) == FALSE){
            demPrintMsg(MSG_TIMEDATE);
            setCF(0);
            return;
        }

        setCX(wTime);
        setDX(wDate);
        setCF(0);
        return;
    }

    wDate = getDX();
    wTime = getCX();

    if (DosDateTimeToFileTime(wDate,
                              wTime,
                              &LastWriteTime) == FALSE){
        demPrintMsg(MSG_TIMEDATE);
        setCF(0);
        return;
    }
    LocalFileTimeToFileTime (&LastWriteTime,&ftTemp);

    if(!SetFileTime(hFile,NULL,NULL,&ftTemp)){
        demClientError(hFile, (CHAR)-1);
        return;
    }

    setCF(0);
    return;
}

#endif


/* DemCommit -- Commit File(Flush file buffers)
 *
 * Entry - Client (AX:BP) File Handle
 *
 * Exit
 *         SUCCESS
 *           Client (CY)    = 0
 *           buffer flushed
 *
 *         FAILURE
 *           Client (CY) = 1
 *
 */
VOID demCommit(VOID)
{
    HANDLE  hFile;
    BOOL bRet;

    hFile = GETHANDLE(getAX(),getBP());
    bRet = FlushFileBuffers(hFile);
#if DBG
    if (!bRet) {

        //
        // FlushFileBuffers fails with access denied if the handle
        // is open for read-only access, however it's not an error
        // for DOS.
        //

        DWORD LastError;
        LastError = GetLastError();

        if (LastError != ERROR_ACCESS_DENIED) {
            sprintf(demDebugBuffer,
                    "ntvdm demCommit warning: FlushFileBuffers error %d\n",
                    LastError);
            OutputDebugStringOem(demDebugBuffer);
        }
    }
#endif

    setCF(0);

}

/* function to check if new data has been written to the file or
   if the file has been marked EOF

   Input:   Client (AX:BP) = 32bits NT file handle
   Output:  Client ZF = 1 if new data or EOF
                   CF = 1 if EOF
*/


VOID demPipeFileDataEOF(VOID)
{
    HANDLE  hFile;
    BOOL    fEOF;
    BOOL    DataEOF;
    DWORD   FileSizeLow;
    DWORD   FileSizeHigh;

    hFile = GETHANDLE(getAX(), getBP());

    DataEOF = cmdPipeFileDataEOF(hFile, &fEOF);
    if (fEOF) {
        //EOF, get file size, max size = 32bits
        FileSizeLow = GetFileSize(hFile, &FileSizeHigh);
        setAX((WORD)(FileSizeLow / 0x10000));
        setBP((WORD)FileSizeLow);
        setCF(1);                   // EOF is encountered
    }
    else
        setCF(0);
    setZF(DataEOF ? 0 : 1);
}

/* function to check if the file has been marked EOF
   Input:   Client(AX:BP) = 32bits NT file handle
   Output:  Client CY = 1 if EOF
*/

VOID demPipeFileEOF(VOID)
{
    HANDLE  hFile;
    DWORD   FileSizeLow;
    DWORD   FileSizeHigh;

    hFile = GETHANDLE(getAX(), getBP());
    if (cmdPipeFileEOF(hFile)) {
        FileSizeLow = GetFileSize(hFile, &FileSizeHigh);
        setAX((WORD)(FileSizeLow / 0x10000));   // file size in 32bits
        setBP((WORD)FileSizeLow);
        setCF(1);                   //EOF is encountered
    }
    else
        setCF(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demfile.c ===
/* demfile.c - SVC handlers for calls where file name is specified.
 *
 * demOpen
 * demCreate
 * demUnlink
 * demChMod
 * demRename
 *
 * Modification History:
 *
 * Sudeepb 02-Apr-1991 Created
 *
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>
#include <winbase.h>
#include <vrnmpipe.h>
#include <nt_vdd.h>

extern PDOSSF pSFTHead;

BOOL (*VrInitialized)(VOID);  // POINTER TO FUNCTION
extern BOOL LoadVdmRedir(VOID);
extern BOOL IsVdmRedirLoaded(VOID);

BOOL
IsNamedPipeName(
    IN LPSTR Name
    );

BOOL
IsNamedPipeName(
    IN LPSTR Name
    )

/*++

Routine Description:

    Lifted from VDMREDIR.DLL - we don't want to load the entire DLL if we
    need to check for a named pipe

    Checks if a string designates a named pipe. As criteria for the decision
    we use:

        \\computername\PIPE\...

    DOS (client-side) can only open a named pipe which is created at a server
    and must therefore be prefixed by a computername

Arguments:

    Name    - to check for (Dos) named pipe syntax

Return Value:

    BOOL
        TRUE    - Name refers to (local or remote) named pipe
        FALSE   - Name doesn't look like name of pipe

--*/

{
    int CharCount;


    if (IS_ASCII_PATH_SEPARATOR(*Name)) {
        ++Name;
        if (IS_ASCII_PATH_SEPARATOR(*Name)) {
            ++Name;
            CharCount = 0;
            while (*Name && !IS_ASCII_PATH_SEPARATOR(*Name)) {
                ++Name;
                ++CharCount;
            }
            if (!CharCount || !*Name) {

                //
                // Name is \\ or \\\ or just \\name which I don't understand,
                // so its not a named pipe - fail it
                //

                return FALSE;
            }

            //
            // bump name past next path separator. Note that we don't have to
            // check CharCount for max. length of a computername, because this
            // function is called only after the (presumed) named pipe has been
            // successfully opened, therefore we know that the name has been
            // validated
            //

            ++Name;
        } else {
            return FALSE;
        }

        //
        // We are at <something> (after \ or \\<name>\). Check if <something>
        // is [Pp][Ii][Pp][Ee][\\/]
        //

        if (!_strnicmp(Name, "PIPE", 4)) {
            Name += 4;
            if (IS_ASCII_PATH_SEPARATOR(*Name)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

/* demOpen - Open a file
 *
 *
 * Entry - Client (DS:SI) Full path of File
 *         Client (BL)    Open Mode
 *         Client (ES:DI) Address of extended attributes buffer
 *         Client (AL)    0 - No EA's ; 1 - EA's specified
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           Client (BP) = Assigned Open Handle (low word)
 *           Client (DX) = 1 if pipe was opened
 *           Client (BX) = High word of the file size
 *           Client (CX) = low word of the file size
 *
 *
 *         FAILURE
 *              CY = 1
 *              AX = system status code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 *
 * Notes : Extended Attributes is not yet taken care of.
 */

VOID demOpen (VOID)
{
HANDLE  hFile;
LPSTR   lpFileName;
UCHAR   uchMode,uchAccess;
DWORD   dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
DWORD   dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
BOOL    ItsANamedPipe = FALSE;
BOOL    IsFirst;
LPSTR   dupFileName;
DWORD   dwFileSize,dwSizeHigh;
SECURITY_ATTRIBUTES sa;

    if (getAL()){
        demPrintMsg (MSG_EAS);
        return;
    }

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Opening File <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    //
    // the DOS filename must be 'canonicalized': forward slashes (/) must be
    // converted to back slashes (\) and the filename should be upper-cased
    // using the current code page info
    //

    //
    // BUBUG: Kanji? (/other DBCS)
    //

    if (strchr(lpFileName, '/')) {
        char ch= *lpFileName;
        lpFileName = _strdup(lpFileName);
        if (lpFileName == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            demClientError(INVALID_HANDLE_VALUE, ch);
            return;
        }
        for (dupFileName = lpFileName; *dupFileName; ++dupFileName) {
            if (*dupFileName == '/') {
                *dupFileName = '\\';
            }
        }
        dupFileName = lpFileName;
    } else {
        dupFileName = NULL;
    }

    uchMode = getBL();
    uchAccess = uchMode & (UCHAR)ACCESS_MASK;

    if (uchAccess == OPEN_FOR_READ)
        dwDesiredAccess = GENERIC_READ;
    else if (uchAccess == OPEN_FOR_WRITE)
        dwDesiredAccess = GENERIC_WRITE;

    uchMode = uchMode & (UCHAR)SHARING_MASK;

    switch (uchMode) {
        case SHARING_DENY_BOTH:
            dwShareMode = 0;
            break;
        case SHARING_DENY_WRITE:
            dwShareMode = FILE_SHARE_READ;
            break;
        case SHARING_DENY_READ:
            dwShareMode = FILE_SHARE_WRITE;
            break;
    }

    //
    // slightly new scheme - the redir isn't automatically loaded anymore. We
    // may perform a named pipe operation before VDMREDIR is loaded. So now we
    // load VDMREDIR.DLL if the filespec designates a named pipe
    //

    if (IsNamedPipeName(lpFileName)) {
        if (!LoadVdmRedir()) {
            goto errorReturn;
        }
        ItsANamedPipe = TRUE;

        //
        // convert \\<this_computer>\PIPE\foo\bar\etc to \\.\PIPE\...
        // if we already allocated a buffer for the slash conversion use
        // that else this call will allocate another buffer (we don't
        // want to write over DOS memory)
        //

        lpFileName = VrConvertLocalNtPipeName(dupFileName, lpFileName);
        if (!lpFileName) {
            goto errorReturn;
        }
    }

    //
    // open the file. If we think its a named pipe then use FILE_FLAG_OVERLAPPED
    // because the client might use DosReadAsyncNmPipe or DosWriteAsyncNmPipe
    // and the only way to accomplish that is to open the named pipe handle in
    // overlapped I/O mode now
    //

    // sudeepb 26-Apr-1993 We are retrying opening the file in case
    // of failure without GENERIC_WRITE because of the incompatibility
    // of DOS and NT CD ROM driver. DOS CDROM driver ignores the write
    // bit which we have to fakeout in this way.

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    IsFirst = TRUE;

    while (TRUE) {
        if ((hFile = CreateFileOem(lpFileName,
                                   dwDesiredAccess,
                                   dwShareMode | FILE_SHARE_DELETE,
                                   &sa,
                                   OPEN_EXISTING,
                                   ItsANamedPipe ? FILE_FLAG_OVERLAPPED : 0,
                                   NULL)) == (HANDLE)-1){
            if (IsFirst && dwDesiredAccess & GENERIC_WRITE &&
                IsCdRomFile(lpFileName)) {
                dwDesiredAccess &= ~GENERIC_WRITE;
                IsFirst = FALSE;
                continue;
            }

errorReturn:

            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            if (dupFileName) {
                free(dupFileName);
            } else if (ItsANamedPipe && lpFileName) {
                LocalFree(lpFileName);
            }
            return;
        }
        else
            break;
    }

    //
    // we have to keep some info around when we open a named pipe
    //

    if (ItsANamedPipe) {
        VrAddOpenNamedPipeInfo(hFile, lpFileName);
        setDX(1);
    }
    else {
        if(((dwFileSize=GetFileSize(hFile,&dwSizeHigh)) == (DWORD)-1) ||
             dwSizeHigh) {
            CloseHandle (hFile);
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
        }
        setCX ((USHORT)dwFileSize);
        setBX ((USHORT)(dwFileSize >> 16 ));
        setDX(0);
    }

    setBP((USHORT)hFile);
    setAX((USHORT)((ULONG)hFile >> 16));
    setCF(0);
    if (dupFileName) {
        free(dupFileName);
    } else if (ItsANamedPipe) {
        LocalFree(lpFileName);
    }
    return;
}

#define DEM_CREATE     0
#define DEM_CREATE_NEW 1

/* demCreate - Create a file
 *
 *
 * Entry - Client (DS:SI) Full path of File
 *         Client (CX)    Attributes
 *                        00 - Normal File
 *                        01 - Read-only file
 *                        02 - Hidden File
 *                        04 - System file
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           VSF(BP)     = Assigned Open Handle (low word)
 *
 *         FAILURE
 *              CY = 1
 *              AX = error code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demCreate (VOID)
{
    demCreateCommon (DEM_CREATE);
    return;
}

/* demCreateNew - Create a New file
 *
 *
 * Entry - Client (DS:SI) Full path of File
 *         Client (CX)    Attributes
 *                        00 - Normal File
 *                        01 - Read-only file
 *                        02 - Hidden File
 *                        04 - System file
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           VSF(BP)     = Assigned Open Handle (low word)
 *
 *         FAILURE
 *              CY = 1
 *              AX = error code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demCreateNew (VOID)
{
    demCreateCommon (DEM_CREATE_NEW);
    return;
}


/* demFileDelete
 *
 * EXPORTED FUNCTION
 *
 * ENTRY:
 *      lpFile -> OEM file name to be deleted
 *
 * EXIT: 
 *      returns 0 on success, DOS error code on failure
 *
 * NOTES:
 * Some apps keep a file open and delete it.   Then rename another file to
 * the old name.   On NT since the orignal object is still open the second
 * rename fails.
 * To get around this problem we rename the file before deleteing it
 * this allows the second rename to work
 *
 * But since renaming the file is known to be expensive over the net, we try
 * first to open the file exclusively to see if there is really any reason to
 * rename it. If we can get a handle to it, then we should be able to skip the
 * rename and just delete it. If we can't get a handle to it, then we try
 * the rename trick. This should cut down our overhead for the normal case.
 */

DWORD demFileDelete (LPSTR lpFile)
{
    CHAR vdmtemp[MAX_PATH];
    CHAR tmpfile[MAX_PATH];
    PSZ pFileName;
    HANDLE hFile;

    //
    // First, try to access the file exclusively
    //

    hFile = CreateFileOem(lpFile,
                          DELETE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        NTSTATUS status;
        IO_STATUS_BLOCK ioStatusBlock;
        FILE_DISPOSITION_INFORMATION fileDispositionInformation;
        
        // Member name "DeleteFile" conflicts with win32 definition (it
        // becomes "DeleteFileA". 
#undef DeleteFile
        fileDispositionInformation.DeleteFile = TRUE;

        //
        // We got a handle to it, so there can't be any open
        // handles to it. Set the disposition to DELETE.
        //

        status = NtSetInformationFile(hFile,
                                      &ioStatusBlock,
                                      &fileDispositionInformation,
                                      sizeof(FILE_DISPOSITION_INFORMATION),
                                      FileDispositionInformation);

        CloseHandle(hFile);

        if NT_SUCCESS(status) {
            SetLastError(NO_ERROR);
        } else {
            SetLastError(ERROR_ACCESS_DENIED);
        }
    }

    //
    // Check to see if the delete went OK. If not, try renaming
    // the file.
    //
    switch (GetLastError()) {

    case NO_ERROR:        
    case ERROR_FILE_NOT_FOUND:        
    case ERROR_PATH_NOT_FOUND:        
        // Can't find it, forget about it
        break;
        
    case ERROR_SHARING_VIOLATION:
    case ERROR_ACCESS_DENIED:
        //
        // The file didn't really go away because there appears to
        // be an open handle to the file.
        //
        if (GetFullPathNameOem(lpFile,MAX_PATH,vdmtemp,&pFileName)) {
            if ( pFileName )
               *(pFileName) = 0;
            if (GetTempFileNameOem(vdmtemp,"VDM",0,tmpfile)) {
                if (MoveFileExOem(lpFile,tmpfile, MOVEFILE_REPLACE_EXISTING)) {
                    if(DeleteFileOem(tmpfile)) {
                        SetLastError(NO_ERROR);
                    } else {
                        MoveFileOem(tmpfile,lpFile);
                        SetLastError(ERROR_ACCESS_DENIED);
                    }
                }
            }
        }
        break;
        
    default:         
    
        //
        // We couldn't open or delete the file, and it's not because of a
        // sharing violation. Just try a last ditch effort of a
        // plain old delete, and see if it works.
        //
        if(DeleteFileOem(lpFile)) {
            SetLastError(NO_ERROR);
        }
    }

    //
    // Map win32 error code to DOS
    //
    switch(GetLastError()) {
    
    case NO_ERROR:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
    case ERROR_ACCESS_DENIED:
        break;
    default:
        // make sure demClientError can see retval
        SetLastError(ERROR_ACCESS_DENIED);
    }

    return GetLastError();
}

/* demDelete - Delete a file
 *
 *
 * Entry - Client (DS:DX) Full path of File
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *              CY = 1
 *              AX = system status code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demDelete (VOID)
{
LPSTR   lpFileName;
DWORD   retval;


    lpFileName = (LPSTR) GetVDMAddr (getDS(),getDX());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Deleting File<%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    if (retval = demFileDelete(lpFileName)){
        demClientError(INVALID_HANDLE_VALUE, *lpFileName);
        return;
    }

    setCF(0);
    return;
}


/* demChMod - Change the file modes
 *
 * Entry - Client (DS:DX) Full path of File
 *         Client (AL) = 0 Get File Modes 1 Set File Modes
 *         Client (CL) new modes
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (CL) = file attributes in get case.
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = Error Code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 * Compatibility Notes:
 *
 *      ATTR_VOLUME_ID,ATTR_DEVICE and ATTR_DIRECTORY are not supported
 *      by WIN32 call. Although these are unpublished for DOS world also
 *      but still a compatibility requirement.
 */

VOID demChMod (VOID)
{
LPSTR   lpFileName;
DWORD   dwAttr;

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getDX());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: ChMod File <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif


    if(getAL() == 0){
        if ((dwAttr = GetFileAttributesOem(lpFileName)) == -1)
            goto dcerr;


        if (dwAttr == FILE_ATTRIBUTE_NORMAL) {
            dwAttr = 0;
            }
        else {
            dwAttr &= DOS_ATTR_MASK;
            }

        // SudeepB - 28-Jul-1997
        //
        // For CDFS, Win3.1/DOS/Win95, only return FILE_ATTRIBUTE_DIRECTORY (10)
        // for directories while WinNT returns
        // FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY (11).
        // Some VB controls that app setups use, depend on getting
        // FILE_ATTRIBUTE_DIRECTORY (10) only or otherwise are broken.
        // An example of this is Cliffs StudyWare series.

        if (dwAttr == (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY)) {
            if(IsCdRomFile(lpFileName))
                dwAttr = FILE_ATTRIBUTE_DIRECTORY;
        }

        setCX((USHORT)dwAttr);
        setCF(0);
        return;
    }

    if((dwAttr = getCX()) == 0)
        dwAttr = FILE_ATTRIBUTE_NORMAL;

    dwAttr &= DOS_ATTR_MASK;
    if (!SetFileAttributesOem(lpFileName,dwAttr))
        goto dcerr;

    setCF(0);
    return;

dcerr:
    demClientError(INVALID_HANDLE_VALUE, *lpFileName);
    return;
}


/* demRename - Rename a file
 *
 * Entry - Client (DS:DX) Source File
 *         Client (ES:DI) Destination File
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1
 *           Client (AX) = Error Code
 *
 */

VOID demRename (VOID)
{
LPSTR   lpSrc,lpDst;

    lpSrc = (LPSTR) GetVDMAddr (getDS(),getDX());
    lpDst = (LPSTR) GetVDMAddr (getES(),getDI());

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Rename File <%s> to <%s>\n",lpSrc,lpDst);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    // DOS rename fails accross drives with 11h error code
    // This following check is OK even for UNC names and SUBST drives.
    // SUBST drives come to NTVDM as env variables for current directory
    // and we will treet them just like a network drive and full qualified
    // path will be sent from NTDOS.
    if(toupper(lpSrc[0]) != toupper(lpDst[0])) {
        setCF(1);
        setAX(0x11);
        return;
    }

    // Now check that SRC and DEST are not pointing to the same file.
    // if they do return error 5.
    if (!_stricmp (lpSrc, lpDst)) {
        setCF(1);
        setAX(0x5);
        return;
    }

    if(MoveFileOem(lpSrc,lpDst) == FALSE){
        demClientError(INVALID_HANDLE_VALUE, *lpSrc);
        return;
    }

    setCF(0);
    return;
}

/* demCreateCommon - Create a file or Craete a new file
 *
 *
 * Entry - flCreateType - DEM_CREATE_NEW create new
 *                        DEM_CREATE     create
 *
 * Exit
 *         SUCCESS
 *           Client (CY) = 0
 *           Client (AX) = Assigned Open Handle (high word)
 *           Client (BP)     = Assigned Open Handle (low word)
 *
 *         FAILURE
 *              CY = 1
 *              AX = error code
 *          HARD ERROR
 *              CY = 1
 *              AX = 0FFFFh
 *
 */

VOID demCreateCommon (flCreateType)
ULONG  flCreateType;
{
HANDLE  hFile;
LPSTR   lpFileName;
LPSTR   lpDot;
DWORD   dwAttr;
DWORD   dwFileSize,dwSizeHigh;
USHORT  uErr;
DWORD   dwDesiredAccess;
SECURITY_ATTRIBUTES sa;
CHAR    cFOTName[MAX_PATH];
BOOL    ttfOnce,IsFirst;
DWORD   dwLastError;


    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());
    dwAttr = (DWORD)getCX();

    // Here is some code stolen from DOS_Create (create.asm) for handling the
    // attributes

    if (flCreateType == DEM_CREATE || flCreateType == DEM_CREATE_NEW)
        dwAttr &= 0xff;

    if (dwAttr & ~(ATTR_ALL | ATTR_IGNORE | ATTR_VOLUME_ID)) {
        setCF(1);
        setAX(5);   //Attribute problem
        return;
    }

    /* Special case for set volume label (INT 21 Func 3CH, Attr = 8H */

    if((flCreateType == DEM_CREATE || flCreateType == DEM_CREATE_NEW) && (dwAttr == ATTR_VOLUME_ID)) {
        if((uErr = demCreateLabel(lpFileName[DRIVEBYTE],
                                  lpFileName+LABELOFF))) {
            setCF(1);
            setAX(uErr);
            return;
        }
        setAX(0);
        setBP(0);   // in this case handle = 0 and if we will
        setCF(0);   // close this handle CF will be 0(!)
        return;
    }


    if ((dwAttr & 0xff) == 0) {
        dwAttr = FILE_ATTRIBUTE_NORMAL;
    } else {
        dwAttr &= DOS_ATTR_MASK;
    }


#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Creating File <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif

    dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    ttfOnce = TRUE;
    IsFirst = TRUE;

    while (TRUE) {
        if ((hFile = CreateFileOem(lpFileName,
                    // create file with delete access and sharing mode
                    // so that anybody can delete it without closing
                    // the file handle returned from create file
                    dwDesiredAccess,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    &sa,
                    flCreateType == DEM_CREATE ? CREATE_ALWAYS : CREATE_NEW,
                    dwAttr,
                    NULL)) == (HANDLE)-1){

            if (IsFirst && dwDesiredAccess & GENERIC_WRITE &&
                IsCdRomFile(lpFileName)) {
                dwDesiredAccess &= ~GENERIC_WRITE;
                IsFirst = FALSE;
                continue;
            }

            // APP COMPATABILITY
            // Some WOW apps installing .TTF or .FON or Fonts fail to create
            // The file because the font is already open by GDI32 server.
            // The install/setup programs don't gracefully handle
            // this error, they bomb out of the install with retry or cancel
            // without offering the user a way to ignore the error (which
            // would be the right thing since the font already exists.
            // To work around this problem we do a RemoveFontResource here
            // which causes GDI32 to unmap the file, we then retry
            // the create.  - mattfe june 93

            // If it is a TTF file then we need to remove the font resource
            // for the .FOT file of the same name

            if (ttfOnce) {

                // Look for the file extension

                lpDot = strrchr(lpFileName,'.');

                if (lpDot) {
                    if ( (!_strcmpi(lpDot,".TTF")) ||
                         (!_strcmpi(lpDot,".FON")) ||
                         (!_strcmpi(lpDot,".FOT")) ) {

                        if ( RemoveFontResourceOem(lpFileName) ) {
                            PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
                            ttfOnce = FALSE;
                            continue;
                        }

                        // We failed to remove the .TTF file probably because
                        // the .FOT file was loaded, so try to remove it

                        if (!_strcmpi(lpDot,".TTF")) {

                            RtlZeroMemory(cFOTName,sizeof(cFOTName));
                            RtlCopyMemory(cFOTName,lpFileName,(ULONG)lpDot-(ULONG)lpFileName);
                            strcat(cFOTName,".FOT");
                            if ( RemoveFontResourceOem(cFOTName) ) {
                                PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
                                ttfOnce = FALSE;
                                continue;
                            }
                        }
                    }
                }
            }
            demClientError(INVALID_HANDLE_VALUE, *lpFileName);
            return;
        }
        else
            break;
    }

    if((dwFileSize=GetFileSize(hFile,&dwSizeHigh) == -1) || dwSizeHigh) {
        CloseHandle (hFile);
        demClientError(INVALID_HANDLE_VALUE, *lpFileName);
        return;
    }
    setCX ((USHORT)dwFileSize);
    setBX ((USHORT)(dwFileSize >> 16 ));
    setBP((USHORT)hFile);
    setAX((USHORT)((ULONG)hFile >> 16));
    setCF(0);
    return;
}

BOOL IsCdRomFile (PSTR pszPath)
{
    UCHAR   pszRootDir[MAX_PATH];
    UCHAR   file_system[MAX_PATH];
    int     i, j;

    // The given path is either a network path or has D: at the start.

    if (!pszPath[0]) {
        return FALSE;
    }

    if (pszPath[1] == ':') {
        pszRootDir[0] = pszPath[0];
        pszRootDir[1] = ':';
        pszRootDir[2] = '\\';
        pszRootDir[3] = 0;
    } else if (IS_ASCII_PATH_SEPARATOR(pszPath[0]) &&
               IS_ASCII_PATH_SEPARATOR(pszPath[1])) {
        j = 0;
        for (i = 2; pszPath[i]; i++) {
            if (IS_ASCII_PATH_SEPARATOR(pszPath[i])) {
                if (++j == 2) {
                    break;
                }
            }
        }
        memcpy(pszRootDir, pszPath, i);
        pszRootDir[i] = '\\';
        pszRootDir[i+1] = 0;
    } else {
        return FALSE;
    }

    if (GetVolumeInformationOem(pszRootDir, NULL, 0, NULL, NULL, NULL,
                                file_system, MAX_PATH) &&
        !_stricmp(file_system, "CDFS")) {

        return TRUE;
    }

    return FALSE;
}

/* demCheckPath - Check path (for device only)
 *
 *
 * Entry - Client (DS:SI) Full path (with last '\')
 *
 * Exit
 *         SUCCESS
 *       Client (CF) = 0
 *
 *         FAILURE
 *      CF = 1
 */

VOID demCheckPath (VOID)
{
HANDLE  hFile;
LPSTR   lpFileName;
CHAR    cDRV;
CHAR    szFileName[MAX_PATH];

    lpFileName = (LPSTR) GetVDMAddr (getDS(),getSI());
    cDRV = getDL()+'A'-1;

    setDX(0);

    // If we have \dev dir then return OK, DOS always has this directory for
    // devices.

    if(!lstrcmpi(lpFileName, "\\DEV\\")) {
    setCF(0);
    return;
    }

    sprintf(szFileName, "%c:%sNUL", cDRV, lpFileName);

#if DBG
    if(fShowSVCMsg & DEMFILIO){
       sprintf(demDebugBuffer,"demfile: Check Pathe <%s>\n",lpFileName);
       OutputDebugStringOem(demDebugBuffer);
    }
#endif


    // If path exists then we always can open NUL file in this directory,
    // if path doesn't exists then CreateFile returns INVALID_HANDLE_VALUE
    //

    if ((hFile = CreateFileOem((LPSTR) szFileName,
                   GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   CREATE_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL)) == INVALID_HANDLE_VALUE) {

    demClientError(INVALID_HANDLE_VALUE, *lpFileName);

    setCF(1);
        return;
    }

    CloseHandle (hFile);
    setCF(0);

    return;
}


PDOSSFT GetFreeSftEntry(PDOSSF pSfHead, PWORD usSFN)
{
    WORD    i;
    PDOSSFT pSft;
    DWORD   ulSFLink;

    *usSFN = 0;
    for (;;) {

        pSft = (PDOSSFT) &(pSfHead->SFTable);
        for (i = 0; i < pSfHead->SFCount; i++) {
            if (pSft[i].SFT_Ref_Count == 0) {
                *usSFN += i;
                return (pSft + i);
            }
        }
        *usSFN += pSfHead->SFCount;

        ulSFLink = pSfHead->SFLink;
        if (LOWORD(ulSFLink) == 0xFFFF) {
            break;
        }

        pSfHead = (PDOSSF) Sim32GetVDMPointer (ulSFLink, 0, 0);
    }

    return NULL;
}


/** VDDAllocateDosHandle - Allocates an unused DOS file handle.
 *
 *  ENTRY -
 *      IN  pPDB  - OPTIONAL: (16:16) address of the PDB for the task
 *      OUT ppSFT - OPTIONAL: Returns a 32-bit flat pointer to the SFT
 *                            associated with the allocated file handle.
 *      OUT ppJFT - OPTIONAL: Returns a 32-bit flat pointer to the JFT
 *                            associated with the given PDB.
 *
 *
 *  EXIT
 *      SUCCESS - Returns the value of the DOS file handle and associated
 *                pointers.
 *      FAILURE - Returns a negative value. The absolute value of this number
 *                is the DOS error code.
 *
 * Comments:
 *  This routine searches for an unused DOS file handle and SFT and "opens"
 *  a file. After the successful completion of this call, the returned file
 *  handle and the corresponding SFT will be reserved for the caller's use, and
 *  will be unavailable to other callers trying to issue DOS Open or Create api
 *  calls. It is the caller's responsibility to release this file handle (with
 *  a call to VDDReleaseDosHandle).
 *  
 *  If the pPDB pointer is not supplied (e.g., is NULL), then the current
 *  PDB as reported by DOS will be used.
 *
 *  Although the ppSFT parameter is technically optional, it is a required
 *  parameter of the VDDAssociateNtHandle call. This was done to avoid a
 *  second handle lookup in the Associate call.
 *  
 */

SHORT VDDAllocateDosHandle (pPDB,ppSFT,ppJFT)
ULONG       pPDB;
PDOSSFT*    ppSFT;
PBYTE*      ppJFT;
{
PDOSPDB pPDBFlat;
PBYTE   pJFT;
PDOSSFT pSFT;
USHORT  usSFN;
WORD    JFTLength;
SHORT   hDosHandle;

    if (!pPDB) {
        pPDB = (ULONG) (*pusCurrentPDB) << 16;
    }

    //
    // Get the JFT.
    //

    pPDBFlat = (PDOSPDB) Sim32GetVDMPointer (pPDB, 0, 0);
    
    if ( NULL == pPDBFlat ) {
      return (- ERROR_INVALID_HANDLE);
    }

    pJFT     = (PBYTE)   Sim32GetVDMPointer (pPDBFlat->PDB_JFN_Pointer, 0, 0);

    if ( NULL == pJFT ) {
      return (- ERROR_INVALID_HANDLE);
    }
    
    //
    // Check to see if there's a free entry in the JFT.
    //

    JFTLength = pPDBFlat->PDB_JFN_Length;
    for (hDosHandle = 0; hDosHandle < JFTLength; hDosHandle++) {
        if (pJFT[hDosHandle] == 0xFF) {
            break;
        }
    }

    // If no room in the JFT then return ERROR_TOO_MANY_OPEN_FILES

    if (hDosHandle == JFTLength) {
        return (- ERROR_TOO_MANY_OPEN_FILES);
    }

    //
    // Check the SF for a free SFT.
    //

    if (!(pSFT = GetFreeSftEntry(pSFTHead, &usSFN))) {
        return (- ERROR_TOO_MANY_OPEN_FILES);
    }

    pJFT[hDosHandle] = (BYTE)usSFN;
    RtlZeroMemory((PVOID)pSFT, sizeof(DOSSFT));
    pSFT->SFT_Ref_Count = 1;

    if (ppSFT) {
        *ppSFT = (pSFT);
    }

    if (ppJFT) {
        *ppJFT = pJFT;
    }

    return(hDosHandle);

}

/** VDDAssociateNtHandle - Associates the passed NT handle and access flags
 *                          the given DOS handle.
 *
 * ENTRY -
 *      IN pSFT    - flat address of the SFT to be updated
 *      IN hFile32 - NT handle to be stored
 *      IN wAccess - access flags to set in the SFT
 *
 * EXIT -
 *      This routine has no return value.
 *
 * Comments:
 *  This routine takes the passed NT handle value and stores it in a DOS SFT
 *  so that it can later be retrieved by the VDDRetrieveNtHandle api. The
 *  pointer to the SFT is returned by the VDDAllocateDosHandle api.
 *
 *  The format of the third parameter is the same as the file access flags
 *  defined for DOS Open File with Handle call (Int 21h, func 3dh), documented
 *  in Microsoft MS-DOS Programmer's Reference. Only the low order byte of
 *  this parameter is used, the upper byte is reserved and must be zero.
 *  The value of this parameter is placed into the passed SFT. This is provided
 *  to allow the caller to define the access rights for the corresponding
 *  DOS file handle.
 *
 */

VOID VDDAssociateNtHandle (pSFT,hFile,wAccess)
PDOSSFT     pSFT;
HANDLE      hFile;
WORD        wAccess;
{

    pSFT->SFT_Mode = wAccess&0x7f; // take out no_inherit bit
    pSFT->SFT_Attr = 0;                     // Not used.
    pSFT->SFT_Flags = (wAccess&0x80) ? 0x1000 : 0; // copy no_inherit bit.
    pSFT->SFT_Devptr = (ULONG) -1;
    pSFT->SFT_NTHandle = (ULONG) hFile;

}


/** VDDReleaseDosHandle - Release the given DOS file handle.
 *
 * ENTRY -
 *      IN pPDB  - OPTIONAL: (16:16) address of the PDB for the task
 *      IN hFile - DOS handle (in low byte)
 *
 * EXIT -
 *      TRUE  - the file handle was released
 *      FALSE - The file handle was not valid or open
 * 
 * Comments:
 *  This routine updates the DOS file system data areas to free the passed
 *  file handle. No effort is made to determine if this handle was previously
 *  opened by the VDDAllocateDosHandle call. It is the responsibility of the
 *  caller to insure that the given file handle in the specified PDB should
 *  be closed.
 *
 *  If the pPDB pointer is not supplied (e.g., is NULL), then the current
 *  PDB as reported by DOS will be used.
 *
 */

BOOL VDDReleaseDosHandle (pPDB,hFile)
ULONG       pPDB;
SHORT       hFile;
{
PBYTE   pJFT;
PDOSSFT pSFT;
HANDLE  ntHandle;


    if (!pPDB) {
        pPDB = (ULONG) (*pusCurrentPDB) << 16;
    }

    ntHandle = VDDRetrieveNtHandle(pPDB,hFile,(PVOID *)&pSFT,&pJFT);
    if (!ntHandle) {
        return(FALSE);
    }

    pJFT[hFile] = 0xFF;

    // Decrement reference count.

    pSFT->SFT_Ref_Count--;

    return(TRUE);

}


/** VDDRetrieveNtHandle - Given a DOS file handle get the associated
 *                         NT handle.
 *
 * ENTRY -
 *      IN  pPDB  - OPTIONAL: (16:16) address of the PDB for the task
 *      IN  hFile - DOS handle (in low byte)
 *      OUT ppSFT - OPTIONAL: Returns a 32-bit flat pointer to the SFT
 *                            associated with the given file.
 *      OUT ppJFT - OPTIONAL: Returns a 32-bit flat pointer to the JFT
 *                            associated with the given PDB.
 *
 *
 * EXIT - 
 *      SUCCESS - returns 4byte NT handle
 *      FAILURE - returns 0
 *
 * Comments:
 *  The value returned by this function will be the NT handle passed in a
 *  previous VDDAssociateNtHandle call. If no previous call is made to the
 *  the Associate api, then the value returned by this function is undefined.
 *  
 *  If the pPDB pointer is not supplied (e.g., is NULL), then the current
 *  PDB as reported by DOS will be used.
 *
 *  Although the ppSFT parameter is technically optional, it is a required
 *  parameter of the VDDAssociateNtHandle call. This was done to avoid a
 *  second handle lookup in the Associate call.
 *  
 *  The third and fourth parameters are provided to provide the caller the
 *  ability to update the DOS system data areas directly. This may be useful
 *  for performance reasons, or necessary depending on the application. In 
 *  general, care must be taken when using these pointers to avoid causing
 *  system integrity problems.
 *
 */

HANDLE VDDRetrieveNtHandle (pPDB,hFile,ppSFT,ppJFT)
ULONG       pPDB;
SHORT       hFile;
PDOSSFT*    ppSFT;
PBYTE*      ppJFT;
{
PDOSPDB pPDBFlat;
PDOSSF  pSfFlat;
PDOSSFT pSftFlat;
PBYTE   pJFT;
USHORT  usSFN;
USHORT  usSFTCount;
ULONG   ulSFLink;

    if (!pPDB) {
        pPDB = (ULONG) (*pusCurrentPDB) << 16;
    }

    // Get flat pointer to PDB
    pPDBFlat = (PDOSPDB) Sim32GetVDMPointer(pPDB, 0, 0);

    // Check that handle is within JFT
    if (hFile >= pPDBFlat->PDB_JFN_Length) {
        return 0;
    }

    // Get the pointer to JFT
    pJFT = (PBYTE) Sim32GetVDMPointer (pPDBFlat->PDB_JFN_Pointer, 0, 0);

    // Get the SFN, remember -1 indicates unused JFT
    usSFN = (USHORT) pJFT[hFile];
    if (usSFN == 0xff) {
        return 0;
    }

    // Get flat pointer to SF
    pSfFlat =  pSFTHead;

    // Find the right SFT group
    while (usSFN >= (usSFTCount = pSfFlat->SFCount)){
        usSFN = usSFN - usSFTCount;
        ulSFLink = pSfFlat->SFLink;
        if (LOWORD(ulSFLink) == 0xffff)
            return 0;
        pSfFlat = (PDOSSF) Sim32GetVDMPointer (ulSFLink, 0, 0);
    }

    // Get the begining of SFT

    pSftFlat = (PDOSSFT)&(pSfFlat->SFTable);

    // Get the SFN, Finally
    if(pSftFlat[usSFN].SFT_Ref_Count == 0) {
        return 0;
    }

    if (ppSFT) {
        *ppSFT = (pSftFlat + usSFN);
    }

    if (ppJFT) {
        *ppJFT = pJFT;
    }

    return (HANDLE) pSftFlat[usSFN].SFT_NTHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demlfn.c ===
/* demlfn.c - SVC handler for calls that use lfns
 *
 *
 * Modification History:
 *
 * VadimB 10-Sep-1996 Created
 * VadimB Sep-Oct 1996 Functionality added
 *
 */

#include "dem.h"
#include "demmsg.h"
#include "winbasep.h"
#include <vdm.h>
#include <softpc.h>
#include <mvdm.h>
#include <memory.h>
#include <nt_vdd.h>
#include "demlfn.h"

//
// locally used function
//
DWORD dempLFNCheckDirectory(PUNICODE_STRING pPath);

//
// Global Variables
// (initialized in dempInitLFNSupport)
//
//

UNICODE_STRING DosDevicePrefix;
UNICODE_STRING DosDeviceUNCPrefix;
UNICODE_STRING SlashSlashDotSlash;
UNICODE_STRING ColonSlashSlash;


// this is zero-time for dos in terms of convertability

FILETIME gFileTimeDos0;

//
// Search handle table (see demlfn.h for definitions)
//

DemSearchHandleTable gSearchHandleTable;

//
// Dos/WOW variables (curdir&drive mostly)
//
DOSWOWDATA DosWowData; // this is same exactly as used by wow in wdos.c


#ifdef DBG

/* Function:
 *    dempLFNLog
 *
 *
 */

DWORD gdwLog;

VOID __cdecl dempLFNLog(
   PCHAR pFormat,
   ...)
{
   va_list va;
   CHAR LogStr[512];

   if (gdwLog) {
      va_start(va, pFormat);
      wvsprintf(LogStr, pFormat, va);
      OutputDebugStringOem(LogStr);
   }
}

#else
#define dempLFNLog //
#endif


//
// String Convertion
//
// Define OEM/Ansi->Unicode and Unicode->OEM/Ansi translation functions
//
//

PFNUNICODESTRINGTODESTSTRING pfnUnicodeStringToDestString;
PFNSRCSTRINGTOUNICODESTRING  pfnSrcStringToUnicodeString;

#define ENABLE_CONDITIONAL_TRANSLATION

/*
 * These two macros establish a dependency on oem/ansi api translation
 * WOW32 calls into us and tells us to be ansi. all support is totally
 * transparent.
 *
 */

#define DemSourceStringToUnicodeString(pUnicodeString, pSourceString, fAllocate) \
(*pfnSrcStringToUnicodeString)(pUnicodeString, pSourceString, fAllocate)

#define DemUnicodeStringToDestinationString(pDestString, pUnicodeString, fAllocate, fVerify) \
(*pfnUnicodeStringToDestString)(pDestString, pUnicodeString, fAllocate, fVerify)


/* Function:
 *    DemUnicodeStringToOemString
 *    Convert Unicode counted string to Oem counted string with verification for
 *    bad characters. Verification is provided by RtlUnicodeStringToCountedOemString.
 *    At the same time the aforementioned api does not 0-terminate the dest string.
 *    This function does 0-termination (given the dest string has enough space).
 *
 *    If Translation does not need to be verified then speedier version of the
 *    convertion api is called
 *
 * Parameters
 *    pOemString         - points to a destination oem counted string structure
 *    pUnicodeString     - points to a source unicode counted string
 *    fAllocateResult    - if TRUE, then storage for the resulting string will
 *                         be allocated
 *    fVerifyTranslation - if TRUE, then converted string will be verified for
 *                         correctness (and appropriate status will be returned)
 */


NTSTATUS
DemUnicodeStringToOemString(
   POEM_STRING pOemString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation)
{
   NTSTATUS dwStatus;

   if (fVerifyTranslation) {
      PUCHAR pchBuffer = NULL;

      if (!fAllocateResult && pOemString->MaximumLength > 0) {
         pchBuffer = pOemString->Buffer;
      }

      dwStatus = RtlUnicodeStringToCountedOemString(pOemString, pUnicodeString, fAllocateResult);
      if (NT_SUCCESS(dwStatus)) {
         if (pOemString->Length < pOemString->MaximumLength) {
            pOemString->Buffer[pOemString->Length] = '\0';
         }
         else {
            if (NULL == pOemString->Buffer) { // source string was empty
               if (NULL != pchBuffer) {
                  *pchBuffer = '\0'; // terminate if there was a buffer
               }
            }
            else {
               return(STATUS_BUFFER_OVERFLOW);
            }
         }
      }
   }
   else {
      dwStatus = RtlUnicodeStringToOemString(pOemString, pUnicodeString, fAllocateResult);
   }

   return(dwStatus);
}

/* Function:
 *    DemUnicodeStringToAnsiString
 *    Convert Unicode counted string to Ansi counted string with verification for
 *    bad characters. Note, that verification IS NOT provided by the corresponding
 *    Rtl* api, thus is it never performed(!!!)
 *
 * Parameters
 *    pOemString         - points to a destination oem counted string structure
 *    pUnicodeString     - points to a source unicode counted string
 *    fAllocateResult    - if TRUE, then storage for the resulting string will
 *                         be allocated
 *    fVerifyTranslation - if TRUE, then converted string will be verified for
 *                         correctness (and appropriate status will be returned)
 *
 * Note
 *    This function does not provide verification.
 */


NTSTATUS
DemUnicodeStringToAnsiString(
   PANSI_STRING pAnsiString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation)
{
   return(RtlUnicodeStringToAnsiString(pAnsiString, pUnicodeString, fAllocateResult));
}


/* Function:
 *    demSetLFNApiTranslation
 *    Sets api translation to be Oem or Ansi. Windows seems to want apis to be
 *    Ansi while dos apps require Oem translation. This function allows WOW to
 *    set the appropriate translation at startup
 *
 * Parameters
 *    fIsAnsi - if TRUE, all LFN apis will provide Ansi translation
 *
 *
 *
 */


VOID
demSetLFNApiTranslation(BOOL fIsAnsi)
{
   if (fIsAnsi) {
      pfnUnicodeStringToDestString = (PFNUNICODESTRINGTODESTSTRING) DemUnicodeStringToAnsiString;
      pfnSrcStringToUnicodeString  = (PFNSRCSTRINGTOUNICODESTRING)  DemAnsiStringToUnicodeString;
   }
   else {
      pfnUnicodeStringToDestString = (PFNUNICODESTRINGTODESTSTRING) DemUnicodeStringToOemString;
      pfnSrcStringToUnicodeString  = (PFNSRCSTRINGTOUNICODESTRING)  DemOemStringToUnicodeString;
   }
}

/*
 * Function:
 *    dempGetDosUserEnvironment
 *    Retrieves user stack top from the current process's pdb
 *    see msdisp.asm for details,
 *    ss is at psp:0x30 and sp is at psp:0x2e
 *    Registers are at offsets represented by enumDemUserRegisterOffset
 *
 * Parameters:
 *    fProtectedMode - TRUE if emulator is in 386 protected mode
 *    Uses pusCurrentPDB
 *
 * Return:
 *    Flat pointer to the user stack top
 *
 *
 */

PVOID
dempGetDosUserEnvironment(VOID)
{
   USHORT wPSP;
   PBYTE  pPDB;

   wPSP = *pusCurrentPDB;
   pPDB = (PBYTE)GetVDMAddr(wPSP, 0);
   return((PVOID)GetVDMAddr(*(PUSHORT)(pPDB+0x30), *(PUSHORT)(pPDB+0x2e)));
}


/* NOTES:
 *
 * - On caution when using UNICODE_STRING
 *     A lot of the functions here rely upon Rtl* functions including some
 *     that provide UNICODE_STRING functionality. These functions, unlike one
 *     would have to expect use notion of Length - it is measured in
 *     BYTES not characters.
 *
 * - On return values from worker fns
 *     Throughout this code we use Win32 error codes and nt status codes
 *     Having both aroung can be fun, thus we generally return error codes in
 *     a status code format, making all the return values consistent
 *
 * - On naming convention:
 *     All functions that are internal and are not called directly from within
 *     api dispatching code (such as real working functions for all the apis)
 *     have prefix 'demp' (dem private), other functions that are callable from
 *     within fast thunks (such as for wow32.dll - protected mode windows app)
 *     have the usual prefix 'dem'
 */


/*

   Functions:

   Dos Extentions

   i21h 4302    - GetCompressedFileSize
   i21h 440d 48 - LockUnlockRemovableMedia
   i21h 440d 49 - EjectRemovableMedia
   i21h 440d 6f - GetDriveMapInformation
   i21h 440d 71 - GetFirstCluster - should not be implemented

   LFN

   i21h *5704    - GetFileTimeLastAccess
        *5705    - SetFileTimeLastAccess
        *5706    - GetFileTimeCreation
        *5707    - SetFileTimeCreation
        *7139    - CreateDirectory
        *713a    - RemoveDirectory
        *713b    - SetCurrentDirectory
        *7141    - DeleteFile
        *7143    - SetGetFileAttributes
        *7147    - GetCurrentDirectory
        *714e    - FindFirstFile
        *714f    - FindNextFile
        *7156    - MoveFile
        *7160 0  - GetFullPathName
        *7160 1  - GetShortPathName
        *7160 2  - GetLongPathName
        *716c    - CreateOpenFile
        *71a0    - GetVolumeInformation
        *71a1    - FindClose
        *71a6    - GetFileInformationByHandle
        *71a7 0  - FileTimeToDosDateTime
        *71a7 1  - DOSDateTimeToFileTime
        71a8    - GenerateShortFileName *** no impl
        71a9    - ServerCreateOpenFile
        *71aa 0  - CreateSubst
        *71aa 1  - TerminateSubst
        *71aa 2  - QuerySubst

*/

#if 0

typedef struct tagCLOSEAPPSTATE {
   DWORD dwFlags;
   FILETIME CloseCmdTime;
}  CLOSEAPPSTATE;

#define CLOSESTATE_QUERYCALLED    0x00000001UL // app has called QueryClose at least once
#define CLOSESTATE_CLOSECMD       0x00010000UL // close command was chosen
#define CLOSESTATE_APPGOTCLOSE    0x00020000UL // app received close notify
#define CLOSESTATE_CLOSEACK       0x01000000UL // close cmd


CLOSEAPPSTATE GlobalCloseState;

// handle variour close apis

VOID dempLFNHandleClose(
   VOID)
{
   switch(getDX()) {
   case 1: // query close
      GlobalCloseState.dwFlags |= CLOSESTATE_QUERYCALLED;
      if (GlobalCloseState.dwFlags & CLOSESTATE_CLOSECMD) {
         // bummer
      }
      break;

   case 2: // ack close
      GlobalCloseState.dwFlags |= CLOSESTATE_CLOSEACK;
      break;

   case 3: // cancel close
      GlobalCloseState.dwFlags |= CLOSESTATE_CLOSECANCEL;
      break;
}



BOOL dempCompareTimeInterval(
   FILETIME* pTimeStart,
   FILETIME* pTimeEnd,
   DWORD dwIntervalMilliseconds)
{
   LARGE_INTEGER TimeStart;
   LARGE_INTEGER TimeEnd;

   TimeStart.LowPart  = pTimeStart->dwLowDateTime;
   TimeStart.HighPart = pTimeStart->dwHighDateTime;

   TimeEnd.LowPart  = pTimeEnd->dwLowDateTime;
   TimeEnd.HighPart = pTimeEnd->dwHighDateTime;

   return(((TimeEnd.QuadPart - TimeStart.QuadPart) * 1000 * 10) <
          (LONGLONG)dwIntervalMilliseconds);
}

#define DOS_APP_CLOSE_TIMEOUT 5000 // 5s

//
// This is how  we handle query close calls
//
//    Upon receiving a ctrl_close_event we set the global flag and wait
//    when pinged by app with query close
//
//


BOOL dempLFNConsoleCtrlHandler(
   DWORD dwCtrlType)
{
   FILETIME SysTime;

   switch(dwCtrlType) {
   case CTRL_CLOSE_EVENT:


      // -- set the flag
      // -- return true



      // this is the only event we are interested in

      if (GlobalCloseState.dwFlags & CLOSESTATE_CLOSECMD) {

         if (GlobalCloseState.dwFlags & CLOSESTATE_CLOSEACK) {
            // allow 1 sec from close ack to either close or die


         }

          !(GlobalCloseState.dwFlags & CLOSESTATE_APPRECEIVEDCLOSE))

         // another close event - after the first one -
         // and in these 5sec app has not called queryclose -
         // then handle by default

         GetSystemTimeAsFileTime(&SysTime);
         if (dempCompareTimeInterval(&GlobalCloseState.CloseCmdTime,
                                     &SysTime,
                                     DOS_APP_CLOSE_TIMEOUT))
            return(


         }





      }


      // set the flag so we can signal the app
      if (GlobalCloseState.dwFlags & CLOSESTATE_QUERYCALLED) {
         GlobalCloseState.dwFlags |= CLOSESTATE_CLOSECMD


      }




   }




}

// if the handler is not installed, then we don't care ...

VOID
demLFNInstallCtrlHandler(VOID)
{
   if (!VDMForWOW) {
      SetConsoleCtrlHandler(dempLFNConsoleCtrlHandler, TRUE);
   }
}

#endif

/*
 * Function:
 *    dempInitLFNSupport
 *    Initializes LFN (Long File Names) support for NT DOS emulation
 *    (global vars). Called from demInit in dem.c
 *
 *    This function sets api translation to OEM.
 *
 */


VOID
dempInitLFNSupport(
   VOID)
{
   TIME_FIELDS TimeFields;
   LARGE_INTEGER ft0;

   RtlInitUnicodeString(&DosDevicePrefix,    L"\\??\\");
   RtlInitUnicodeString(&DosDeviceUNCPrefix, L"\\??\\UNC\\");
   RtlInitUnicodeString(&SlashSlashDotSlash, L"\\\\.\\");
   RtlInitUnicodeString(&ColonSlashSlash,    L":\\\\");


   demSetLFNApiTranslation(FALSE); // set api to oem mode

   // init important time conversion constants
   RtlZeroMemory(&TimeFields, sizeof(TimeFields));
   TimeFields.Year  = (USHORT)1980;
   TimeFields.Month = 1;
   TimeFields.Day   = 1;
   RtlTimeFieldsToTime(&TimeFields, &ft0);
   gFileTimeDos0.dwLowDateTime = ft0.LowPart;
   gFileTimeDos0.dwHighDateTime = ft0.HighPart;

   // now initialize our control handler api
   // we are watching for a 'close' call with an assumption
   // app will be doing QueryClose calls

#if 0
   demLFNInstallCtrlHandler();
#endif
}

/*
 * Function:
 *    dempStringInitZeroUnicode
 *    Initializes an empty Unicode counted string given the pointer
 *    to the character buffer
 *
 * Parameters:
 *    IN OUT pStr       - unicode counted string
 *    IN pwsz           - pointer to the string buffer
 *    IN nMaximumLength - size (in BYTES) of the buffer pointed to by pwsz
 *
 * Returns:
 *    NOTHING
 *
 */

VOID
dempStringInitZeroUnicode(
   PUNICODE_STRING pStr,
   PWSTR pwsz,
   USHORT nMaximumLength)
{
   pStr->Length = 0;
   pStr->MaximumLength = nMaximumLength;
   pStr->Buffer = pwsz;
   if (NULL != pwsz) {
      pwsz[0] = UNICODE_NULL;
   }
}


/*
 * Function:
 *    dempStringPrefixUnicode
 *    Verifies if a string is a prefix in another unicode counted string
 *    Equivalent to RtlStringPrefix
 *
 * Parameters:
 *    IN StrPrefix - unicode counted string - prefix
 *    IN String    - unicode counted string to check for prefix
 *    IN CaseInSensitive - whether the comparison should be case insensitive
 *       TRUE - case insensitive
 *       FALSE- case sensitive
 *
 * Returns:
 *    TRUE - String contains StrPrefix at it's start
 *
 */

BOOL
dempStringPrefixUnicode(
   PUNICODE_STRING pStrPrefix,
   PUNICODE_STRING pString,
   BOOL CaseInSensitive)
{
   PWSTR ps1, ps2;
   UINT n;
   WCHAR c1, c2;

   n = pStrPrefix->Length;
   if (pString->Length < n) {
      return(FALSE);
   }

   n /= sizeof(WCHAR); // convert to char count

   ps1 = pStrPrefix->Buffer;
   ps2 = pString->Buffer;

   if (CaseInSensitive) {
      while (n--) {
         c1 = *ps1++;
         c2 = *ps2++;

         if (c1 != c2) {
            c1 = RtlUpcaseUnicodeChar(c1);
            c2 = RtlUpcaseUnicodeChar(c2);
            if (c1 != c2) {
               return(FALSE);
            }
         }
      }
   }
   else {
      while (n--) {
         if (*ps1++ != *ps2++) {
            return(FALSE);
         }
      }

   }

   return(TRUE);
}

/*
 * Function:
 *    dempStringDeleteCharsUnicode
 *    Removes specified number of characters from a unicode counted string
 *    starting at specified position (including starting character)
 *
 * Parameters:
 *    IN OUT pStringDest - unicode counted string to operate on
 *    IN nIndexStart     - starting byte for deletion
 *    IN nLength         - number of bytes to be removed
 *
 * Returns:
 *    TRUE - characters were removed
 *    FALSE- starting position exceeds string length
 *
 */


BOOL
dempStringDeleteCharsUnicode(
   PUNICODE_STRING pStringDest,
   USHORT nIndexStart,
   USHORT nLength)
{
   if (nIndexStart > pStringDest->Length) { // start past length
      return(FALSE);
   }

   if (nLength >= (pStringDest->Length - nIndexStart)) {
      pStringDest->Length = nIndexStart;
      *(PWCHAR)((PUCHAR)pStringDest->Buffer + nIndexStart) = UNICODE_NULL;
   }
   else
   {
      USHORT nNewLength;

      nNewLength = pStringDest->Length - nLength;

      RtlMoveMemory((PUCHAR)pStringDest->Buffer + nIndexStart,
                    (PUCHAR)pStringDest->Buffer + nIndexStart + nLength,
                    nNewLength - nIndexStart);

      pStringDest->Length = nNewLength;
      *(PWCHAR)((PUCHAR)pStringDest->Buffer + nNewLength) = UNICODE_NULL;
   }

   return(TRUE);
}

/*
 * Function:
 *    dempStringFindLastChar
 *    implements strrchr - finds the last occurence of a character in
 *    unicode counted string
 *
 * Parameters
 *    pString - target string to search
 *    wch     - Unicode character to look for
 *    CaseInSensitive - if TRUE, search is case insensitive
 *
 * Returns
 *    Index of the character in the string or -1 if char
 *    could not be found. Index is (as always with counted strings) is bytes,
 *    not characters
 *
 */

LONG
dempStringFindLastChar(
   PUNICODE_STRING pString,
   WCHAR wch,
   BOOL CaseInSensitive)
{
   INT Index = (INT)UNICODESTRLENGTH(pString);
   PWCHAR pBuffer = (PWCHAR)((PUCHAR)pString->Buffer + pString->Length);
   WCHAR c2;

   if (CaseInSensitive) {
      wch = RtlUpcaseUnicodeChar(wch);

      while (--Index >= 0) {
         c2 = *--pBuffer;

         c2 = RtlUpcaseUnicodeChar(c2);
         if (wch == c2) {
            return((LONG)(Index << 1));
         }
      }
   }
   else {
      while (--Index >= 0) {
          if (wch == (*--pBuffer)) {
             return((LONG)(Index << 1));
          }
      }
   }

   return(-1);
}

/*
 * Function:
 *    This function checks LFN path for abnormalities, such as a presence of
 *    a drive letter followed by a :\\ such as in d:\\mycomputer\myshare\foo.txt
 *    subsequently d: is removed
 *
 * Parameters:
 *    IN OUT pPath      - unicode path
 *
 * Returns:
 *    NOTHING
 *
 */
VOID dempLFNNormalizePath(
   PUNICODE_STRING pPath)
{
   UNICODE_STRING PathNormal;

   if (pPath->Length > 8) { // 8 as in "d:\\"

      RtlInitUnicodeString(&PathNormal, pPath->Buffer + 1);
      if (dempStringPrefixUnicode(&ColonSlashSlash, &PathNormal, TRUE)) {
         dempStringDeleteCharsUnicode(pPath, 0, 2 * sizeof(WCHAR));
      }

   }

}


/*
 * Function:
 *    dempQuerySubst
 *    Verify if drive is a subst (sym link) and return the base path
 *    for this drive.
 *    Uses QueryDosDeviceW api which does exactly what we need
 *    Checks against substed UNC devices and forms correct unc path
 *    Function works on Unicode counted strings
 *
 * Parameters:
 *    IN  wcDrive    - Drive Letter to be checked
 *    OUT pSubstPath - Buffer that will receive mapping if the drive is substed
 *                     should contain sufficient buffer
 *
 * Returns:
 *    The status value (maybe Win32 error wrapped in)
 *    STATUS_SUCCESS     - Drive is substed and mapping was put into SubstPath
 *    ERROR_NOT_SUBSTED - Drive is not substed
 *    or the error code
 *
 */

NTSTATUS
dempQuerySubst(
   WCHAR wcDrive, // dos drive letter to inquire
   PUNICODE_STRING pSubstPath)
{
   WCHAR wszDriveStr[3];
   DWORD dwStatus;

   wszDriveStr[0] = wcDrive;
   wszDriveStr[1] = L':';
   wszDriveStr[2] = UNICODE_NULL;

   dwStatus = QueryDosDeviceW(wszDriveStr,
                              pSubstPath->Buffer,
                              pSubstPath->MaximumLength/sizeof(WCHAR));
   if (dwStatus) {

      // fix the length (in BYTES) - QueryDosDeviceW returns 2 chars more then
      // the length of the string

      pSubstPath->Length = (USHORT)(dwStatus - 2) * sizeof(WCHAR);

      // see if we hit a unc string there

      if (dempStringPrefixUnicode(&DosDeviceUNCPrefix, pSubstPath, TRUE)) {


         // This is a unc name - convert to \\<uncname>
         // if we hit this code - potential trouble, as win95
         // does not allow for subst'ing unc names
         dempStringDeleteCharsUnicode(pSubstPath,
                                      (USHORT)0,
                                      (USHORT)(DosDeviceUNCPrefix.Length - 2 * sizeof(WCHAR)));

         pSubstPath->Buffer[0] = L'\\';
         dwStatus = STATUS_SUCCESS;

      }  //  string is not prefixed by <UNC\>
      else
      if (dempStringPrefixUnicode(&DosDevicePrefix, pSubstPath, TRUE)) {

         dempStringDeleteCharsUnicode(pSubstPath,
                                      0,
                                      DosDevicePrefix.Length);
         dwStatus = STATUS_SUCCESS;

      }  // string is not prefixed by <\??\>
      else {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_NOT_SUBSTED);
      }

   }
   else {
      dwStatus = GET_LAST_STATUS();
   }

   return(dwStatus);
}

/*
 * Function:
 *    dempExpandSubst
 *    Verify if the full path that is passed in relates to a substed drive
 *    and expands the substed drive mapping
 *    Optionally converts subst mapping to a short form
 *    Win95 always removes the terminating backslash from the resulting path
 *    after the expansion hence this function should do it as well
 *
 * Parameters:
 *    IN OUT pPath      - Full path to be verified/expanded
 *    IN fShortPathName - expand path in a short form
 *
 * Returns:
 *    ERROR_SUCCESS         - Drive is substed and mapping was put into SubstPath
 *    ERROR_NOT_SUBSTED     - Drive is not substed
 *    ERROR_BUFFER_OVERFLOW - Either subst mapping or the resulting path is too long
 *    or the error code if invalid path/etc
 *
 */

NTSTATUS
dempExpandSubst(
   PUNICODE_STRING pPath,
   BOOL fShortPathName)
{
   UNICODE_STRING SubstPath;
   DWORD dwStatus;
   WCHAR wszSubstPath[MAX_PATH];
   WORD  wCharType;

   PWSTR pwszPath = pPath->Buffer;

   // check if we have a canonical dos path in Path
   // to do so we
   // - check that the first char is alpha
   // - check that the second char is ':'
   if ( !GetStringTypeW(CT_CTYPE1,
                             pwszPath,
                             1,
                             &wCharType)) {
       // Couldn't get string type
       // assuming Drive is not substed

       return(NT_STATUS_FROM_WIN32(GetLastError()));
   }

   if (!(C1_ALPHA & wCharType) || L':' != pwszPath[1]) {
      // this could have been a unc name
      // or something weird
      return(NT_STATUS_FROM_WIN32(ERROR_NOT_SUBSTED));
   }

   dempStringInitZeroUnicode(&SubstPath,
                             wszSubstPath,
                             sizeof(wszSubstPath));

   dwStatus = dempQuerySubst(*pwszPath, &SubstPath);
   if (NT_SUCCESS(dwStatus)) {
      USHORT nSubstLength = SubstPath.Length;

      // see if we need a short path
      if (fShortPathName) {
         dwStatus = GetShortPathNameW(wszSubstPath, // this is SubstPath counted string
                                      wszSubstPath,
                                      ARRAYCOUNT(wszSubstPath));

         CHECK_LENGTH_RESULT(dwStatus, ARRAYCOUNT(wszSubstPath), nSubstLength);

         if (!NT_SUCCESS(dwStatus)) {
            return(dwStatus);
         }

         // nSubstLength is set to the length of a string
      }


      // okay - we have a subst there
      // replace now a <devletter><:> with a subst
      if (L'\\' == *(PWCHAR)((PUCHAR)wszSubstPath + nSubstLength - sizeof(WCHAR))) {
         nSubstLength -= sizeof(WCHAR);
      }

      // see if we might overflow the destination string
      if (pPath->Length + nSubstLength - 2 * sizeof(WCHAR) > pPath->MaximumLength) {
         return(NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW));
      }


      // now we have to insert the right subst path in
      // move stuff to the right in the path department
      RtlMoveMemory((PUCHAR)pwszPath + nSubstLength - 2 * sizeof(WCHAR),  // to the right, less 2 chars
                    (PUCHAR)pwszPath,  // from the beginning
                    pPath->Length);

      // after this is done we will insert the chars from subst expansion
      // at the starting position of the path
      RtlCopyMemory(pwszPath,
                    wszSubstPath,
                    nSubstLength);

      // at this point we fix the length of the path
      pPath->Length += nSubstLength - 2 * sizeof(WCHAR);

      dwStatus = STATUS_SUCCESS;
   }

   return(dwStatus);
}




/* Function 7160
 *
 *
 * Implements fn 0 - GetFullPathName
 *
 * Parameters
 *    ax = 0x7160 - fn major code
 *    cl = 0      - minor code
 *    ch = SubstExpand
 *          0x00 - expand subst drive
 *          0x80 - do not expand subst drive
 *    ds:si = Source Path
 *    es:di = Destination Path
 *
 * The base path as in GetFullPathName will be given in a short form and
 * in a long form sometimes
 *
 *    c:\foo bar\john dow\
 * will return
 *    c:\foobar~1\john dow
 *    from GetFullPathName "john dow", c:\foo bar being the current dir
 * and
 *    c:\foobar~1\johndo~1
 *    from GetFullPathName "johndo~1"
 *
 * Return
 *    Success -
 *              carry not set, ax modified(?)
 *    Failure -
 *              carry set, ax = error value
 *
 */

NTSTATUS
dempGetFullPathName(
   PUNICODE_STRING pSourcePath,
   PUNICODE_STRING pDestinationPath,
   BOOL  fExpandSubst)

{
   DWORD dwStatus;

   // maps to GetFullPathName
   dwStatus = RtlGetFullPathName_U(pSourcePath->Buffer,
                                   pDestinationPath->MaximumLength,
                                   pDestinationPath->Buffer,
                                   NULL);

   // check result, fix string length
   // dwStatus will be set to error if buffer overflow

   CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, pDestinationPath);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   // now check for dos device names being passed in
   if (dempStringPrefixUnicode(&SlashSlashDotSlash, pDestinationPath, TRUE)) {

      // this is a bit strange though this is what Win95 returns

      return(NT_STATUS_FROM_WIN32(ERROR_FILE_NOT_FOUND));
   }


   // now see if we need to expand the subst
   // note that this implementation is exactly what win95 does - the subst
   // path is always expanded as short unless the long filename is being
   // requested

   if (fExpandSubst) {
      dwStatus = dempExpandSubst(pDestinationPath, FALSE);
      if (!NT_SUCCESS(dwStatus)) {
         if (WIN32_ERROR_FROM_NT_STATUS(dwStatus) != ERROR_NOT_SUBSTED) {
            return(dwStatus);
         }
      }
   }

   return(STATUS_SUCCESS);
}

/* Function
 *    dempGetShortPathName
 *    Retrieves short path name for the given path
 *
 * Parameters
 *    ax = 0x7160 - fn major code
 *    cl = 1      - minor code
 *    ch = SubstExpand
 *          0x00 - expand subst drive
 *          0x80 - do not expand subst drive
 *    ds:si = Source Path
 *    es:di = Destination Path
 *
 * The base path as in GetFullPathName will be given in a short form and
 * in a long form sometimes
 *
 *    c:\foo bar\john dow\
 * will return
 *    c:\foobar~1\john dow
 *    from GetFullPathName "john dow", c:\foo bar being the current dir
 * and
 *    c:\foobar~1\johndo~1
 *    from GetFullPathName "johndo~1"
 *
 * Return
 *    Success -
 *              carry not set, ax modified(?)
 *    Failure -
 *              carry set, ax = error value
 *
 */




NTSTATUS
dempGetShortPathName(
   PUNICODE_STRING pSourcePath,
   PUNICODE_STRING pDestinationPath,
   BOOL  fExpandSubst)
{
   DWORD dwStatus;

   dwStatus = dempGetFullPathName(pSourcePath,
                                  pDestinationPath,
                                  fExpandSubst);
   if (NT_SUCCESS(dwStatus)) {
      dwStatus = GetShortPathNameW(pDestinationPath->Buffer,
                                   pDestinationPath->Buffer,
                                   pDestinationPath->MaximumLength / sizeof(WCHAR));

      CHECK_LENGTH_RESULT_USTR(dwStatus, pDestinationPath);
   }

   return(dwStatus);
}

// the code below was mostly partially ripped from base/client/vdm.c

DWORD   rgdwIllegalMask[] =
{
    // code 0x00 - 0x1F --> all illegal
    0xFFFFFFFF,
    // code 0x20 - 0x3f --> 0x20,0x22,0x2A-0x2C,0x2F and 0x3A-0x3F are illegal
    0xFC009C05,
    // code 0x40 - 0x5F --> 0x5B-0x5D are illegal
    0x38000000,
    // code 0x60 - 0x7F --> 0x7C is illegal
    0x10000000
};


BOOL
dempIsShortNameW(
    LPCWSTR Name,
    int     Length,
    BOOL    fAllowWildCard
    )
{
    int Index;
    BOOL ExtensionFound;
    DWORD      dwStatus;
    UNICODE_STRING unicodeName;
    OEM_STRING oemString;
    UCHAR      oemBuffer[MAX_PATH];
    UCHAR      Char;

    ASSERT(Name);

    // total length must less than 13(8.3 = 8 + 1 + 3 = 12)
    if (Length > 12)
        return FALSE;
    //  "" or "." or ".."
    if (!Length)
        return TRUE;
    if (L'.' == *Name)
    {
        // "." or ".."
        if (1 == Length || (2 == Length && L'.' == Name[1]))
            return TRUE;
        else
            // '.' can not be the first char(base name length is 0)
            return FALSE;
    }

    unicodeName.Buffer = (LPWSTR)Name;
    unicodeName.Length =
    unicodeName.MaximumLength = Length * sizeof(WCHAR);

    oemString.Buffer = oemBuffer;
    oemString.Length = 0;
    oemString.MaximumLength = MAX_PATH; // make a dangerous assumption

#ifdef ENABLE_CONDITIONAL_TRANSLATION
    dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                   &unicodeName,
                                                   FALSE,
                                                   FALSE);
#else
    dwStatus = RtlUnicodeStringToOemString(&oemString,
                                           &unicodeName,
                                           FALSE);
#endif
    if (! NT_SUCCESS(dwStatus)) {
         return(FALSE);
    }

    // all trivial cases are tested, now we have to walk through the name
    ExtensionFound = FALSE;
    for (Index = 0; Index < oemString.Length; Index++)
    {
        Char = oemString.Buffer[Index];

        // Skip over and Dbcs characters
        if (IsDBCSLeadByte(Char)) {
            //
            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte
            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the
            //     length of base part is more than 8 ( Index > 7 ), it's definitely error.
            //
            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading
            //     byte range, it's error
            //
            if ((!ExtensionFound && (Index >= 7)) ||
                (Index == oemString.Length - 1)) {
                return FALSE;
            }
            Index += 1;
            continue;
        }

        // make sure the char is legal
        if ((Char < 0x80) &&
            (rgdwIllegalMask[Char / 32] & (1 << (Char % 32)))) {
           if (!fAllowWildCard || ('?' != Char && '*' != Char)) {
              return(FALSE);
           }
        }
        if ('.' == Char)
        {
            // (1) can have only one '.'
            // (2) can not have more than 3 chars following.
            if (ExtensionFound || Length - (Index + 1) > 3)
            {
                return FALSE;
            }
            ExtensionFound = TRUE;
        }
        // base length > 8 chars
        if (Index >= 8 && !ExtensionFound)
            return FALSE;
    }
    return TRUE;

}



/* Function:
 *    demIsShortPathName
 *    Returns true is the path name passed in is a short path name
 *
 *
 *
 *
 */


 // this function was ripped from windows\base\client\vdm.c

LPCWSTR
dempSkipPathTypeIndicatorW(
    LPCWSTR Path
    )
{
    RTL_PATH_TYPE   RtlPathType;
    LPCWSTR         pFirst;
    DWORD           Count;

    RtlPathType = RtlDetermineDosPathNameType_U(Path);
    switch (RtlPathType) {
        // form: "\\server_name\share_name\rest_of_the_path"
        case RtlPathTypeUncAbsolute:
            pFirst = Path + 2;
            Count = 2;
            // guard for UNICODE_NULL is necessary because
            // RtlDetermineDosPathNameType_U doesn't really
            // verify an UNC name.
            while (Count && *pFirst != UNICODE_NULL) {
                if (*pFirst == L'\\' || *pFirst == L'/')
                    Count--;
                pFirst++;
                }
            break;

        // form: "\\.\rest_of_the_path"
        case RtlPathTypeLocalDevice:
            pFirst = Path + 4;
            break;

        // form: "\\."
        case RtlPathTypeRootLocalDevice:
            pFirst = NULL;
            break;

        // form: "D:\rest_of_the_path"
        case RtlPathTypeDriveAbsolute:
            pFirst = Path + 3;
            break;

        // form: "D:rest_of_the_path"
        case RtlPathTypeDriveRelative:
            pFirst = Path + 2;
            break;

        // form: "\rest_of_the_path"
        case RtlPathTypeRooted:
            pFirst = Path + 1;
            break;

        // form: "rest_of_the_path"
        case RtlPathTypeRelative:
            pFirst = Path;
            break;

        default:
            pFirst = NULL;
            break;
        }
    return pFirst;
}

// this function is rather "permissive" if it errs and can't find
// out for sure -- we then hope that the failure will occur later...

BOOL
demIsShortPathName(
   LPSTR pszPath,
   BOOL fAllowWildCardName)
{
   NTSTATUS dwStatus;
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING oemFileName;
   LPWSTR lpwszPath;
   LPWSTR pFirst, pLast;
   BOOL   fWild = FALSE;

   //
   // convert parameters to unicode - we use a static string here
   //

   RtlInitOemString(&oemFileName, pszPath);

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &oemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &oemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(TRUE);
   }

   // now we have a unicode string to mess with
   lpwszPath = pUnicodeStaticFileName->Buffer;

   // chop off the intro part first
   lpwszPath = (LPWSTR)dempSkipPathTypeIndicatorW((LPCWSTR)pUnicodeStaticFileName->Buffer);
   if (NULL == lpwszPath) {
      // some weird path type ? just let it go
      return(TRUE); // we assume findfirst will hopefully choke on it too
   }

   pFirst = lpwszPath;

   // we go through the name now
   while (TRUE) {
      while (UNICODE_NULL != *pFirst && (L'\\' == *pFirst || L'/' == *pFirst)) {
         ++pFirst; // this is legal -- to have multiple separators!
      }

      if (UNICODE_NULL == *pFirst) {
         // meaning -- just separators found or end of string
         break;
      }


      // now see that we find the end of this name
      pLast = pFirst + 1;
      while (UNICODE_NULL != *pLast && (L'\\' != *pLast && L'/' != *pLast)) {
         ++pLast;
      }

      fWild = fAllowWildCardName && UNICODE_NULL == *pLast;

      // now pLast points to the UNICODE_NULL or the very next backslash
      if (!dempIsShortNameW(pFirst, (int)(pLast-pFirst), fWild)) {
         return(FALSE); // this means long path name found in the middle
      }

      // now we continue
      if (UNICODE_NULL == *pLast) {
         break;
      }
      pFirst = pLast + 1;
   }

   return(TRUE);
}




/* Function:
 *    dempGetLongPathName
 *    Retrieves long version of a path name given it's short form
 *
 *
 * Parameters
 *    IN pSourcePath       - unicode counted string representing short path
 *    OUT pDestinationPath - unicode counted string - output long path
 *    IN fExpandSubst      - flag indicating whether to perform subst expansion
 *
 * Return
 *    NT Error code
 *
 *
 *
 *
 */


NTSTATUS
dempGetLongPathName(
   PUNICODE_STRING pSourcePath,
   PUNICODE_STRING pDestinationPath,
   BOOL fExpandSubst)
{
   UNICODE_STRING NtPathName;
   RTL_PATH_TYPE  RtlPathType; // path type
   PWCHAR pchStart, pchEnd;
   PWCHAR pchDest, pchLast;
   UINT nCount,  // temp counter
        nLength = 0; // final string length
   WCHAR wchSave; // save char during path parsing
   DWORD dwStatus;

   UNICODE_STRING FullPathName;
   UNICODE_STRING FileName;
   BOOL fVerify = FALSE;            // flag indicating that only verification
                                    // is performed on a path and no long path
                                    // retrieval is necessary

   struct tagDirectoryInformationBuffer { // directory information (see ntioapi.h)
      FILE_DIRECTORY_INFORMATION DirInfo;
      WCHAR name[MAX_PATH];
   } DirectoryInformationBuf;
   PFILE_DIRECTORY_INFORMATION pDirInfo = &DirectoryInformationBuf.DirInfo;

   OBJECT_ATTRIBUTES FileObjectAttributes; // used for querying name info
   HANDLE FileHandle;
   IO_STATUS_BLOCK IoStatusBlock;

// algorithm here:
// 1. call getfullpathname
// 2. verify(on each part of the name) and retrieve lfn version of the name

// first we need a buffer for our full expanded path
// allocate this buffer from the heap -- * local ? *

   RtlInitUnicodeString(&NtPathName, NULL);

   pchStart = RtlAllocateHeap(RtlProcessHeap(),
                              0,
                              MAX_PATH * sizeof(WCHAR));
   if (NULL == pchStart) {
      return(NT_STATUS_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
   }

   dempStringInitZeroUnicode(&FullPathName,
                              pchStart,
                              MAX_PATH * sizeof(WCHAR));


   dwStatus = RtlGetFullPathName_U(pSourcePath->Buffer,
                                   FullPathName.MaximumLength,
                                   FullPathName.Buffer,
                                   NULL);

   CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, &FullPathName);

   if (!NT_SUCCESS(dwStatus)) {
      goto glpExit;
   }

   // optionally expand the subst
   // to whatever it should have been

   if (fExpandSubst) {
      dwStatus = dempExpandSubst(&FullPathName, FALSE);
      if (!NT_SUCCESS(dwStatus)) {
         if (WIN32_ERROR_FROM_NT_STATUS(dwStatus) != ERROR_NOT_SUBSTED) {
            goto glpExit;
         }
      }
   }


   // at this point recycle the input source path -- we will know that
   // this modification took place

   RtlPathType = RtlDetermineDosPathNameType_U(FullPathName.Buffer);

   switch(RtlPathType) {

   case RtlPathTypeUncAbsolute:

      // this is a unc name

      pchStart = FullPathName.Buffer + 2; // beyond initial "\\"

      // drive ahead looking past second backslash -- this is really
      // bogus approach as unc name should be cared for by redirector
      // yet I do same as base

      nCount = 2;
      while (UNICODE_NULL != *pchStart && nCount > 0) {
         if (L'\\' == *pchStart || L'/' == *pchStart) {
            --nCount;
         }
         ++pchStart;
      }
      break;

   case RtlPathTypeDriveAbsolute:
      pchStart = FullPathName.Buffer + 3; // includes <drive><:><\\>
      break;

   default:
      // this error will never occur, yet to be safe we are aware of this...
      // case ... we will keep it here as a safeguard
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_BAD_PATHNAME);
      goto glpExit;
   }

   // prepare destination

   pchDest = pDestinationPath->Buffer; // current pointer to destination buffer
   pchLast = FullPathName.Buffer;      // last piece of the source path
   pchEnd  = pchStart;                 // current end-of-scan portion

   // we are going to walk the filename assembling it's various pieces
   //
   while (TRUE) {
      // copy the already-assembled part into the dest buffer
      // this is rather dubious part as all it copies are prefix and backslashes
      nCount = (PUCHAR)pchEnd - (PUCHAR)pchLast;
      if (nCount > 0) {
         // copy this portion
         nLength += nCount; // dest length-to-be
         if (nLength >= pDestinationPath->MaximumLength) {
            dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            break;
         }

         // copy the memory
         RtlMoveMemory(pchDest, pchLast, nCount);
         pchDest += nCount / sizeof(WCHAR);
      }

      // if we are at the end here, then there is nothing left
      // we should be running a verification pass only
      if (UNICODE_NULL == *pchEnd) {
         fVerify = TRUE;
      }
      else {
      // look for the next backslash
         while (UNICODE_NULL != *pchEnd &&
                L'\\' != *pchEnd &&
                L'/' != *pchEnd) {
               ++pchEnd;
         }
      }

      // found backslash or end here
      // temporary null-terminate the string and research it's full name

      wchSave = *pchEnd;
      *pchEnd = UNICODE_NULL;

      dwStatus = RtlDosPathNameToNtPathName_U(FullPathName.Buffer,
                                              &NtPathName,
                                              &FileName.Buffer,
                                              NULL);
      if (!dwStatus) {
         // could also be a memory problem here
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_FILE_NOT_FOUND);
         break;
      }

      if (fVerify || NULL == FileName.Buffer) {
         // no filename portion there - panic ? or this is just a
         // directory (root)
         // this also may signal that our job is done as there is nothing
         // to query about - we are at the root of things

         // let us open this stuff then and if it exists - just exit,
         // else return error
         fVerify = TRUE;
         FileName.Length = 0;
      }
      else {

         USHORT nPathLength;

         nPathLength = (USHORT)((ULONG)FileName.Buffer - (ULONG)NtPathName.Buffer);

         FileName.Length = NtPathName.Length - nPathLength;

         // chop the backslash off if this is not the last one only
         NtPathName.Length = nPathLength;
         if (L':' != *(PWCHAR)((PUCHAR)NtPathName.Buffer+nPathLength-2*sizeof(WCHAR))) {
            NtPathName.Length -= sizeof(WCHAR);
         }
      }

      FileName.MaximumLength = FileName.Length;
      NtPathName.MaximumLength = NtPathName.Length;



      // now we should have a full nt path sitting right in NtPathName
      // restore saved char

      *pchEnd = wchSave;

      // initialize info obj
      InitializeObjectAttributes(&FileObjectAttributes,
                                 &NtPathName,
                                 OBJ_CASE_INSENSITIVE,
                                 NULL,
                                 NULL);

      dwStatus = NtOpenFile(&FileHandle,
                            FILE_LIST_DIRECTORY | SYNCHRONIZE,
                            &FileObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_DIRECTORY_FILE |
                              FILE_SYNCHRONOUS_IO_NONALERT |
                              FILE_OPEN_FOR_BACKUP_INTENT);

      if (!NT_SUCCESS(dwStatus)) {
         break;
      }

      dwStatus = NtQueryDirectoryFile(FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      pDirInfo,
                                      sizeof(DirectoryInformationBuf),
                                      FileDirectoryInformation,
                                      TRUE,
                                      &FileName,
                                      FALSE);

      NtClose(FileHandle);

      // we need NtPathName no more - release it here
      RtlFreeUnicodeString(&NtPathName);
      NtPathName.Buffer = NULL;

      if (!NT_SUCCESS(dwStatus)) {
         break;
      }

      if (fVerify) {
         dwStatus = STATUS_SUCCESS;
         break;
      }

      nLength += pDirInfo->FileNameLength;
      if (nLength >= pDestinationPath->MaximumLength) {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
         break;
      }

      RtlMoveMemory(pchDest,
                    pDirInfo->FileName,
                    pDirInfo->FileNameLength);

       // update dest pointer
      pchDest += pDirInfo->FileNameLength / sizeof(WCHAR);

      if (UNICODE_NULL == *pchEnd) {
         dwStatus = STATUS_SUCCESS;
         break;
      }

      pchLast = pchEnd++; // this is set to copy backslash

   } // end while

   // only on success condition we touch dest buffer here

   if (NT_SUCCESS(dwStatus)) {
      *pchDest = UNICODE_NULL;
      pDestinationPath->Length = (USHORT)nLength;
   }

glpExit:

   if (NULL != FullPathName.Buffer) {
      RtlFreeHeap(RtlProcessHeap(), 0, FullPathName.Buffer);
   }
   if (NULL != NtPathName.Buffer) {
      RtlFreeUnicodeString(&NtPathName);
   }

   return(dwStatus);
}


/* Function:
 *    demGetPathName
 *    completely handles function 7160 with three minor subfunctions
 *    exported function that could be called from wow32 for fast handling
 *    of a 0x7160 thunk
 *
 * Parameters
 *    IN  lpSourcePath      - source path to query for full/long/short path name
 *    OUT lpDestinationPath - result produced by this function
 *    IN  uiMinorCode       - minor code see enumFullPathNameMinorCode - which
 *                            function to execute -
 *                            fullpathname/shortpathname/longpathname
 *    IN  fExpandSubst      - flag whether to expand substituted drive letter
 *
 * Return
 *    NT Error code
 *
 * Known implementation differences [with Win95]
 *
 *    All these apis will return error on win95 if path does not exist
 *    only GetLongPathName currently returns error in such a case
 *
 *    if a local path does not exist win95 fn0 returns fine while
 *    fns 1 and 2 return error 3 (path not found)
 *
 *    we return the name with a terminating backslash when expanding the
 *    subst e.g.:
 *      z:\ -> substed for c:\foo\bar
 *    we return "c:\foo\bar\" while win95 returns "c:\foo\bar"
 *
 *    if win95 running on \\vadimb9  any of these calls with \\vadimb9\foo
 *    where share foo does not exist - we get a doserror generated with
 *    abort/retry/fail - and code is 46 (bogus)
 *
 *    error codes may differ a bit
 *
 *    win95 does not allow for subst on a unc name, win nt does and fns correctly
 *    process these cases(with long or short filenames)
 *
 */


NTSTATUS
demLFNGetPathName(
   LPSTR lpSourcePath,
   LPSTR lpDestinationPath,
   UINT  uiMinorCode,
   BOOL  fExpandSubst
   )

{
   // convert input parameter to unicode
   //
   UNICODE_STRING unicodeSourcePath;
   UNICODE_STRING unicodeDestinationPath;
   OEM_STRING oemString;
   WCHAR wszDestinationPath[MAX_PATH];
   DWORD dwStatus;

   // Validate input parameters

   if (NULL == lpSourcePath || NULL == lpDestinationPath) {
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
   }


   RtlInitOemString(&oemString, lpSourcePath);

   // convert source path from ansi to unicode and allocate result
   // this rtl function returns status code, not the winerror code
   //

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(&unicodeSourcePath, &oemString, TRUE);

#else

   dwStatus = RtlOemStringToUnicodeString(&unicodeSourcePath, &oemString, TRUE);

#endif


   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   dempStringInitZeroUnicode(&unicodeDestinationPath,
                             wszDestinationPath,
                             sizeof(wszDestinationPath));


   // now call api and get appropriate result back

   switch(uiMinorCode) {
   case fnGetFullPathName:

      dwStatus = dempGetFullPathName(&unicodeSourcePath,
                                     &unicodeDestinationPath,
                                     fExpandSubst);

      break;

   case fnGetShortPathName:
      dwStatus = dempGetShortPathName(&unicodeSourcePath,
                                      &unicodeDestinationPath,
                                      fExpandSubst);
      break;

   case fnGetLongPathName:
      dwStatus = dempGetLongPathName(&unicodeSourcePath,
                                     &unicodeDestinationPath,
                                     fExpandSubst);
      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
   }

   if (NT_SUCCESS(dwStatus)) {
      // convert to ansi and we are done
      oemString.Buffer = lpDestinationPath;
      oemString.Length = 0;
      oemString.MaximumLength = MAX_PATH; // make a dangerous assumption


#ifdef ENABLE_CONDITIONAL_TRANSLATION
      dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                     &unicodeDestinationPath,
                                                     FALSE,
                                                     FALSE);
#else
      dwStatus = RtlUnicodeStringToOemString(&oemString,
                                             &unicodeDestinationPath,
                                             FALSE);
#endif
   }

   RtlFreeUnicodeString(&unicodeSourcePath);

   return(dwStatus);
}


// Create a subst for this particular drive
// using path name
//
// same as used by subst command

// check to see if specified path exists


/* Function:
 *    dempLFNCheckDirectory
 *    Verifies that a supplied path is indeed an existing directory
 *
 * Parameters
 *    IN pPath - pointer to unicode Path String
 *
 * Return
 *    NT Error code
 *
 *
 */

DWORD
dempLFNCheckDirectory(
   PUNICODE_STRING pPath)
{
   // we just read file's attributes
   DWORD dwAttributes;

   dwAttributes = GetFileAttributesW(pPath->Buffer);

   if ((DWORD)-1 == dwAttributes) {
      return(GET_LAST_STATUS());
   }

   // now see if this is a directory
   if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
      return(STATUS_SUCCESS);
   }

   return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));

}


/* Function:
 *    dempLFNCreateSubst
 *    Creates, if possible, new mapping for the supplied dos drive number,
 *    mapping it to the supplied path
 *
 * Parameters
 *    IN uDriveNum - dos drive number (current-0, a-1, b-2, etc)
 *    IN pPathName - pointer to unicode Path String
 *
 * Return
 *    NT Error code
 *
 * Note:
 *    Win95 never works properly with the current drive, we essentially
 *    ignore this case
 *
 */


DWORD
dempLFNCreateSubst(
   UINT uiDriveNum,
   PUNICODE_STRING pPathName)
{
   // first, make a dos drive name
   WCHAR wszDriveStr[3];
   DWORD dwStatus;
   WCHAR wszSubstPath[MAX_PATH];

   wszDriveStr[0] = L'@' + uiDriveNum;
   wszDriveStr[1] = L':';
   wszDriveStr[2] = UNICODE_NULL;

   if (!QueryDosDeviceW(wszDriveStr, wszSubstPath, ARRAYCOUNT(wszSubstPath))) {
      dwStatus = GetLastError();

      if (ERROR_FILE_NOT_FOUND == dwStatus) {

         // check for the input path validity - it better be valid
         // or else...
         dwStatus = dempLFNCheckDirectory(pPathName);
         if (!NT_SUCCESS(dwStatus)) {
            return(dwStatus);
         }


         if (DefineDosDeviceW(0, wszDriveStr, pPathName->Buffer)) {
            // patch in cds for this device
            // BUGBUG

            return(STATUS_SUCCESS);
         }

         dwStatus = GetLastError();
      }

   }

   return (NT_STATUS_FROM_WIN32(dwStatus));
}

/* Function:
 *    dempLFNRemoveSubst
 *    Removes mapping for the supplied dos drive number
 *
 * Parameters
 *    IN uDriveNum - dos drive number (current-0, a-1, b-2, etc)
 *
 * Return
 *    NT Error code
 *
 * Note:
 *    Win95 never works properly with the current drive, we essentially
 *    ignore this case
 *
 */


DWORD
dempLFNRemoveSubst(
   UINT uiDriveNum)
{
   // for this one query for real subst

   WCHAR wszDriveStr[3];
   PUNICODE_STRING pUnicodeStatic;
   DWORD dwStatus;

   wszDriveStr[0] = L'@' + uiDriveNum;
   wszDriveStr[1] = L':';
   wszDriveStr[2] = UNICODE_NULL;

   pUnicodeStatic = &NtCurrentTeb()->StaticUnicodeString;
   // query

   dwStatus = dempQuerySubst(wszDriveStr[0],
                             pUnicodeStatic);

   if (NT_SUCCESS(dwStatus)) {
      if (DefineDosDeviceW(DDD_REMOVE_DEFINITION,
                           wszDriveStr,
                           pUnicodeStatic->Buffer)) {
         // BUGBUG -- patch in cds for this device


         return(STATUS_SUCCESS);
      }


      dwStatus = GET_LAST_STATUS();
   }

   return(dwStatus);
}

/* Function:
 *    dempLFNQuerySubst
 *    Queries the supplied dos drive number for being a substitute drive,
 *    retrieves dos drive mapping if so
 *
 * Parameters
 *    IN uDriveNum   - dos drive number (current-0, a-1, b-2, etc)
 *    OUT pSubstPath - receives drive mapping if drive is a subst
 *
 * Return
 *    NT Error code
 *
 * Note:
 *    Win95 never works properly with the current drive, we essentially
 *    ignore this case -- This is BUGBUG for this api
 *
 */



DWORD
dempLFNQuerySubst(
   UINT uiDriveNum,
   PUNICODE_STRING pSubstPath)
{
   DWORD dwStatus;

   dwStatus = dempQuerySubst((WCHAR)(L'@' + uiDriveNum),
                             pSubstPath);
   return(dwStatus);
}



/* Function:
 *    demLFNSubstControl
 *    Implements Subst APIs for any valid minor code
 *
 * Parameters
 *    IN uiMinorCode    - function to perform (see enumSubstMinorCode below)
 *    IN uDriveNum      - dos drive number (current-0, a-1, b-2, etc)
 *    IN OUT pSubstPath - receives/supplies drive mapping if drive is a subst
 *
 * Return
 *    NT Error code
 *
 * Note:
 *
 */


DWORD
demLFNSubstControl(
   UINT uiMinorCode,
   UINT uiDriveNum,
   LPSTR lpPathName)
{
   DWORD dwStatus;
   OEM_STRING oemPathName;
   PUNICODE_STRING pUnicodeStatic = NULL;

   switch(uiMinorCode) {
   case fnCreateSubst:

      RtlInitOemString(&oemPathName, lpPathName);
      pUnicodeStatic = GET_STATIC_UNICODE_STRING_PTR();

#ifdef ENABLE_CONDITIONAL_TRANSLATION

      dwStatus = DemSourceStringToUnicodeString(pUnicodeStatic,
                                                &oemPathName,
                                                FALSE);
#else

      dwStatus = RtlOemStringToUnicodeString(pUnicodeStatic,
                                             &oemPathName,
                                             FALSE); // allocate result
#endif

      if (NT_SUCCESS(dwStatus)) {
         dwStatus = dempLFNCreateSubst(uiDriveNum, pUnicodeStatic);
      }
      break;

   case fnRemoveSubst:
      dwStatus = dempLFNRemoveSubst(uiDriveNum);
      break;

   case fnQuerySubst:
      // query lfn stuff
      pUnicodeStatic = GET_STATIC_UNICODE_STRING_PTR();

      dwStatus = dempLFNQuerySubst(uiDriveNum, pUnicodeStatic);
      if (NT_SUCCESS(dwStatus)) {
         oemPathName.Length = 0;
         oemPathName.MaximumLength = MAX_PATH;
         oemPathName.Buffer = lpPathName;

#ifdef ENABLE_CONDITIONAL_TRANSLATION
         dwStatus = DemUnicodeStringToDestinationString(&oemPathName,
                                                        pUnicodeStatic,
                                                        FALSE,
                                                        FALSE);
#else
         dwStatus = RtlUnicodeStringToOemString(&oemPathName,
                                                pUnicodeStatic,
                                                FALSE);
#endif
      }
      break;
   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
   }


   //
   // the only thing this ever returns on Win95 is
   // 0x1 - error/invalid function
   // 0xf - error/invalid drive (invalid drive)
   // 0x3 - error/path not found (if bad path is given)

   return(dwStatus);
}




/* Function
 *    dempLFNMatchFile
 *    Matches the given search hit with attributes provided by a search call
 *
 * Parameters
 *    pFindDataW - Unicode WIN32_FIND_DATA structure as returned by FindFirstFile
 *                 or FindNextFile apis
 *
 *    wMustMatchAttributes - attribs that given file must match
 *    wSearchAttributes    - search attribs for the file
 *
 * Returns
 *    TRUE if the file matches the search criteria
 *
 *
 */

BOOL
dempLFNMatchFile(
   PWIN32_FIND_DATAW pFindDataW,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes)
{
   DWORD dwAttributes = pFindDataW->dwFileAttributes;

   // now clear out a volume id flag - it is not matched here
   dwAttributes &= ~DEM_FILE_ATTRIBUTE_VOLUME_ID;

   return (
     ((dwAttributes & (DWORD)wMustMatchAttributes) == (DWORD)wMustMatchAttributes) &&
     (((dwAttributes & (~(DWORD)wSearchAttributes)) & 0x1e) == 0));
}


DWORD
dempLFNFindFirstFile(
   HANDLE* pFindHandle,
   PUNICODE_STRING pFileName,
   PWIN32_FIND_DATAW pFindDataW,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes)
{
   HANDLE hFindFile;
   DWORD dwStatus;


   // match the volume file name first

   hFindFile = FindFirstFileW(pFileName->Buffer, pFindDataW);
   if (INVALID_HANDLE_VALUE != hFindFile) {
      BOOL fContinue = TRUE;

      while (!dempLFNMatchFile(pFindDataW, wMustMatchAttributes, wSearchAttributes) &&
             fContinue) {
         fContinue = FindNextFileW(hFindFile, pFindDataW);
      }

      if (fContinue) {
         // we found some
         *pFindHandle = hFindFile;
         return(STATUS_SUCCESS);
      }
      else {
         // ; return file not found error
         SetLastError(ERROR_FILE_NOT_FOUND);
      }

   }

   dwStatus =  GET_LAST_STATUS();
   if (INVALID_HANDLE_VALUE != hFindFile) {
      FindClose(hFindFile);
   }

   return(dwStatus);
}


DWORD
dempLFNFindNextFile(
   HANDLE hFindFile,
   PWIN32_FIND_DATAW pFindDataW,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes)
{
   BOOL fFindNext;

   do {

      fFindNext = FindNextFileW(hFindFile, pFindDataW);
      if (fFindNext &&
          dempLFNMatchFile(pFindDataW, wMustMatchAttributes, wSearchAttributes)) {
         // found a match!
         return(STATUS_SUCCESS);
      }
   } while (fFindNext);

   return(GET_LAST_STATUS());
}

// the handle we return is a number of the entry into this table below
// with high bit turned on (to be different then any other handle in dos)


DWORD
dempLFNAllocateHandleEntry(
   PUSHORT pDosHandle,
   PLFN_SEARCH_HANDLE_ENTRY* ppHandleEntry)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry = gSearchHandleTable.pHandleTable;

   if (NULL == pHandleEntry) {
      pHandleEntry = RtlAllocateHeap(RtlProcessHeap(),
                                     0,
                                     LFN_SEARCH_HANDLE_INITIAL_SIZE *
                                         sizeof(LFN_SEARCH_HANDLE_ENTRY));
      if (NULL == pHandleEntry) {
         return(NT_STATUS_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY)); // not enough memory
      }
      gSearchHandleTable.pHandleTable = pHandleEntry;
      gSearchHandleTable.nTableSize   = LFN_SEARCH_HANDLE_INITIAL_SIZE;
      gSearchHandleTable.nHandleCount = 0;
      gSearchHandleTable.nFreeEntry   = LFN_SEARCH_HANDLE_LIST_END;
   }

   // walk the free list if available....
   if (LFN_SEARCH_HANDLE_LIST_END != gSearchHandleTable.nFreeEntry) {
      pHandleEntry += gSearchHandleTable.nFreeEntry;
      gSearchHandleTable.nFreeEntry = pHandleEntry->nNextFreeEntry;
   }
   else { // no free entries, should we grow ?
      UINT nHandleCount = gSearchHandleTable.nHandleCount;
      if (nHandleCount >= gSearchHandleTable.nTableSize) {
         // oops - need to grow.

         UINT nTableSize = gSearchHandleTable.nTableSize + LFN_SEARCH_HANDLE_INCREMENT;

         if (nTableSize >= LFN_DOS_HANDLE_LIMIT) {
            // handle as error - we cannot have that many handles

         }


         pHandleEntry = RtlReAllocateHeap(RtlProcessHeap(),
                                          0,
                                          pHandleEntry,
                                          nTableSize * sizeof(LFN_SEARCH_HANDLE_ENTRY));
         if (NULL != pHandleEntry) {
            gSearchHandleTable.pHandleTable = pHandleEntry;
            gSearchHandleTable.nTableSize = nTableSize;
         }
         else {
            // error - out of memory
            return(NT_STATUS_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
         }

      }

      // now set the new entry
      pHandleEntry += nHandleCount;
      gSearchHandleTable.nHandleCount = nHandleCount + 1;
   }

   *pDosHandle = (USHORT)(pHandleEntry - gSearchHandleTable.pHandleTable) | LFN_DOS_HANDLE_MASK;
   *ppHandleEntry = pHandleEntry;
   return(STATUS_SUCCESS);

}

/*
 * The list of free entries is sorted in the last-to-first order
 *
 *
 */

VOID
dempLFNFreeHandleEntry(
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry)
{
   UINT nHandleCount = gSearchHandleTable.nHandleCount - 1;
   UINT DosHandle = (UINT)(pHandleEntry - gSearchHandleTable.pHandleTable);

   // this is the entry - is this the last one ?
   if (DosHandle == nHandleCount) { // if so, chop it off

      UINT nCurHandle = gSearchHandleTable.nFreeEntry;

      // if this handle was the last one and is gone, maybe
      // shrink the list by checking free entry list
      // this is rather simple as the list is sorted in high-to-low
      // numerical order
      while (LFN_SEARCH_HANDLE_LIST_END != nCurHandle &&
             nCurHandle == (nHandleCount-1)) {
         --nHandleCount;
         nCurHandle = gSearchHandleTable.pHandleTable[nCurHandle].nNextFreeEntry;
      }

      // now update free list entry and handle count

      gSearchHandleTable.nFreeEntry   = nCurHandle;
      gSearchHandleTable.nHandleCount = nHandleCount;

   }
   else { //  mark as free and include in the free list
      // find an in-order spot for it
      // this means that the first free handle in the list has the biggest
      // numerical value, thus facilitating shrinking of the table if needed

      UINT nCurHandle  = gSearchHandleTable.nFreeEntry;
      UINT nPrevHandle = LFN_SEARCH_HANDLE_LIST_END;
      PLFN_SEARCH_HANDLE_ENTRY pHandlePrev;

      while (LFN_SEARCH_HANDLE_LIST_END != nCurHandle && nCurHandle > DosHandle) {
         nPrevHandle = nCurHandle;
         nCurHandle = gSearchHandleTable.pHandleTable[nCurHandle].nNextFreeEntry;
      }

      // at this point nCurHandle == -1 or nCurHandle < DosHandle
      // insert DosHandle in between nPrevHandle and nCurHandle

      if (LFN_SEARCH_HANDLE_LIST_END == nPrevHandle) {
         // becomes the first item
         pHandleEntry->nNextFreeEntry  = gSearchHandleTable.nFreeEntry;
         gSearchHandleTable.nFreeEntry = DosHandle;
      }
      else {
         pHandlePrev = gSearchHandleTable.pHandleTable + nPrevHandle;

         pHandleEntry->nNextFreeEntry = pHandlePrev->nNextFreeEntry;
         pHandlePrev->nNextFreeEntry  = DosHandle;
      }

      pHandleEntry->wProcessPDB     = 0; // no pdb there
   }
}

PLFN_SEARCH_HANDLE_ENTRY
dempLFNGetHandleEntry(
   USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry = NULL;

   if (DosHandle & LFN_DOS_HANDLE_MASK) {

      DosHandle &= ~LFN_DOS_HANDLE_MASK; // this is to filter real offset

      if (NULL != gSearchHandleTable.pHandleTable) {
         UINT nHandleCount = gSearchHandleTable.nHandleCount;
         if (DosHandle < nHandleCount) {
            pHandleEntry = gSearchHandleTable.pHandleTable + DosHandle;
            if (pHandleEntry->wProcessPDB != FETCHWORD(*pusCurrentPDB)) {
               return(NULL);
            }
         }
      }
   }

   return(pHandleEntry);
}

VOID
dempLFNCloseSearchHandles(
   VOID)
{
   INT DosHandle;

   for (DosHandle = (int)gSearchHandleTable.nHandleCount-1;
        DosHandle >= 0;
        --DosHandle) {
      PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;

      pHandleEntry = dempLFNGetHandleEntry((USHORT)(DosHandle|LFN_DOS_HANDLE_MASK));
      if (NULL != pHandleEntry) {
         if (INVALID_HANDLE_VALUE != pHandleEntry->hFindHandle) {
            FindClose(pHandleEntry->hFindHandle);
         }
         dempLFNFreeHandleEntry(pHandleEntry);
      }
   }
}


DWORD dempLFNConvertFileTime(
   FILETIME* pDosFileTime,
   FILETIME* pNTFileTime,
   UINT      uDateTimeFormat)
{
   DWORD dwStatus = STATUS_SUCCESS;

   // before we do that assume pNTFileTime is a UTC time
   switch (uDateTimeFormat) {
   case dtfDos:
      {
         WORD wDosDate, wDosTime;
         BOOL fResult;
         LARGE_INTEGER ftNT   = { pNTFileTime->dwLowDateTime,  pNTFileTime->dwHighDateTime };
         LARGE_INTEGER ftDos0 = { gFileTimeDos0.dwLowDateTime, gFileTimeDos0.dwHighDateTime };

         //
         // before we start frolicking with local file time, check to see
         // if the nt filetime refers to 01-01-80 and if so, keep it this way
         //
         if (ftNT.QuadPart <= ftDos0.QuadPart) {
            *pDosFileTime = gFileTimeDos0;
            fResult = TRUE;
         }
         else {
            fResult = FileTimeToLocalFileTime(pNTFileTime, pDosFileTime);
         }

         if (fResult) {
            fResult = FileTimeToDosDateTime(pDosFileTime, &wDosDate, &wDosTime);
         }

         if (fResult) {
            // date is in high-order word low dword
            // time is in low-order word of a low dword

            pDosFileTime->dwLowDateTime  = (DWORD)MAKELONG(wDosTime, wDosDate);
            pDosFileTime->dwHighDateTime = 0;
         }
         else {
            dwStatus = GET_LAST_STATUS();
         }
      }
      break;

   case dtfWin32:
      *pDosFileTime = *pNTFileTime;
      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      break;
   }

   return(dwStatus);
}

// please note that the date time format in case of 32-bit is not returned
// local but the original 32-bit

//
// Note that if we pass lpFileName
// and                  lpAltFileName
// than this is what will be used for these fields...
//


NTSTATUS
dempLFNConvertFindDataUnicodeToOem(
   LPWIN32_FIND_DATA  lpFindDataOem,
   LPWIN32_FIND_DATAW lpFindDataW,
   UINT    uDateTimeFormat,
   PUSHORT pConversionCode,
   LPSTR   lpFileName,
   LPSTR   lpAltFileName
   )

{
   OEM_STRING oemString;
   UNICODE_STRING unicodeString;
   NTSTATUS dwStatus;
   WORD     wConversionCode = 0;

   dwStatus = dempLFNConvertFileTime(&lpFindDataOem->ftLastWriteTime,
                                     &lpFindDataW->ftLastWriteTime,
                                     uDateTimeFormat);
   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   if (0 == lpFindDataW->ftCreationTime.dwLowDateTime &&
       0 == lpFindDataW->ftCreationTime.dwHighDateTime) {
       lpFindDataW->ftCreationTime = lpFindDataW->ftLastWriteTime;
   }


   dwStatus = dempLFNConvertFileTime(&lpFindDataOem->ftCreationTime,
                                     &lpFindDataW->ftCreationTime,
                                     uDateTimeFormat);
   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   if (0 == lpFindDataW->ftLastAccessTime.dwLowDateTime &&
       0 == lpFindDataW->ftLastAccessTime.dwHighDateTime) {
      lpFindDataW->ftLastAccessTime = lpFindDataW->ftLastWriteTime;
   }

   dwStatus = dempLFNConvertFileTime(&lpFindDataOem->ftLastAccessTime,
                                     &lpFindDataW->ftLastAccessTime,
                                     uDateTimeFormat);
   if (!NT_SUCCESS(dwStatus)) {
      // could be a bogus last access date time as provided to us by win32
      // don't bail out! Just give same as creation time
      return(dwStatus);
   }



   // convert both the name and the alternative name

   oemString.Buffer = (NULL == lpFileName) ? lpFindDataOem->cFileName : lpFileName;
   oemString.MaximumLength = ARRAYCOUNT(lpFindDataOem->cFileName);
   oemString.Length = 0;

   RtlInitUnicodeString(&unicodeString, lpFindDataW->cFileName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                  &unicodeString,
                                                  FALSE,
                                                  TRUE); // verify result
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x01; // mask we have unmappable chars in file name
      }
      else {
         return(dwStatus); // failed
      }
   }

#else

   dwStatus = RtlUnicodeStringToCountedOemString(&oemString, &unicodeString, FALSE);
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x01;
      }
      else {
         return(dwStatus);
      }
   }

   if (oemString.Length < oemString.MaximumLength) {
      oemString.Buffer[oemString.Length] = '\0';
   }
   else {
      if (NULL == oemString.Buffer) { // string is empty
         *lpFindDataOem->cFileName = '\0';
      }
      else {
         return(STATUS_BUFFER_OVERFLOW);
      }
   }

#endif


   oemString.Buffer = (NULL == lpAltFileName) ? lpFindDataOem->cAlternateFileName :
                                                lpAltFileName;
   oemString.MaximumLength = ARRAYCOUNT(lpFindDataOem->cAlternateFileName);
   oemString.Length = 0;

   RtlInitUnicodeString(&unicodeString, lpFindDataW->cAlternateFileName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemUnicodeStringToDestinationString(&oemString,
                                                  &unicodeString,
                                                  FALSE,
                                                  TRUE); // verify result
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x02; // mask we have unmappable chars in file name
      }
      else {
         return(dwStatus); // failed
      }
   }

#else

   dwStatus = RtlUnicodeStringToCountedOemString(&oemString, &unicodeString, FALSE);
   if (!NT_SUCCESS(dwStatus)) {
      if (STATUS_UNMAPPABLE_CHARACTER == dwStatus) {
         wConversionCode |= 0x02;
      }
      else {
         return(dwStatus);
      }
   }

   if (oemString.Length < oemString.MaximumLength) {
      oemString.Buffer[oemString.Length] = '\0';
   }
   else {
      if (NULL == oemString.Buffer) { // 0-length string
         *lpFindDataOem->cAlternateFileName = '\0';
      }
      else {
         return(STATUS_BUFFER_OVERFLOW);
      }
   }

#endif

   // attributes - these are not touched at the moment

   lpFindDataOem->dwFileAttributes = lpFindDataW->dwFileAttributes;

   // file size

   lpFindDataOem->nFileSizeHigh = lpFindDataW->nFileSizeHigh;
   lpFindDataOem->nFileSizeLow  = lpFindDataW->nFileSizeLow;


   // set the conversion code here
   *pConversionCode = wConversionCode;

   return(STATUS_SUCCESS);
}


NTSTATUS
demLFNFindFirstFile(
   LPSTR lpFileName,    // file name to look for
   LPWIN32_FIND_DATA lpFindData,
   USHORT wDateTimeFormat,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes,
   PUSHORT pConversionCode, // points to conversion code -- out
   PUSHORT pDosHandle,      // points to dos handle      -- out
   LPSTR  lpDstFileName,    // points to a destination for a file name
   LPSTR  lpAltFileName     // points to a destination for a short name
   ) // hibyte == MustMatchAttrs, lobyte == SearchAttrs
{
   HANDLE hFindFile;
   WIN32_FIND_DATAW FindDataW;
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   NTSTATUS dwStatus;
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING oemFileName;

   //
   // convert parameters to unicode - we use a static string here
   //

   RtlInitOemString(&oemFileName, lpFileName);

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &oemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &oemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   // match volume label here
   if (DEM_FILE_ATTRIBUTE_VOLUME_ID == wMustMatchAttributes &&
       DEM_FILE_ATTRIBUTE_VOLUME_ID == wSearchAttributes) {

      // this is a query for the volume information file
      // actually this is what documented, yet ifsmgr source tells a different
      // story. We adhere to documentation here as it is much simpler to do it
      // this  way, see fastfat source in Win95 for more fun with matching
      // attrs and files

      // match the volume label and if we do have a match then

      // call RtlCreateDestinationString( ); to create a string that is stored
      // inside the HandleEntry

      return(0);
   }

   // normalize path
   dempLFNNormalizePath(pUnicodeStaticFileName);

   // call worker api

   dwStatus = dempLFNFindFirstFile(&hFindFile,
                                   pUnicodeStaticFileName,
                                   &FindDataW,
                                   wMustMatchAttributes,
                                   wSearchAttributes);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   //
   // convert from unicode to oem
   //

   dwStatus = dempLFNConvertFindDataUnicodeToOem(lpFindData,
                                                 &FindDataW,
                                                 (UINT)wDateTimeFormat,
                                                 pConversionCode,
                                                 lpDstFileName,
                                                 lpAltFileName);
   if (!NT_SUCCESS(dwStatus)) {
      if (INVALID_HANDLE_VALUE != hFindFile) {
         FindClose(hFindFile);
      }
      return(dwStatus);
   }

   // allocate dos handle if needed
   dwStatus = dempLFNAllocateHandleEntry(pDosHandle,
                                         &pHandleEntry);
   if (NT_SUCCESS(dwStatus)) {
      pHandleEntry->hFindHandle = hFindFile;
      pHandleEntry->wMustMatchAttributes = wMustMatchAttributes;
      pHandleEntry->wSearchAttributes = wSearchAttributes;
      pHandleEntry->wProcessPDB = *pusCurrentPDB;
   }
   else { // could not allocate dos handle
      if (NULL != hFindFile) {
         FindClose(hFindFile);
      }

   }

   return(dwStatus);
}

VOID
demLFNCleanup(
   VOID)
{
   // this fn will cleanup after unclosed lfn searches

   dempLFNCloseSearchHandles();

   // also -- close the clipboard if this api has been used by the application
   // in question. How do we know ???

}


DWORD
demLFNFindNextFile(
   USHORT DosHandle,
   LPWIN32_FIND_DATAA lpFindData,
   USHORT wDateTimeFormat,
   PUSHORT pConversionCode,
   LPSTR  lpFileName,
   LPSTR  lpAltFileName)

{
   // unpack parameters
   WIN32_FIND_DATAW FindDataW;
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   DWORD dwStatus;
   USHORT ConversionStatus;


   // this call never has to deal with volume labels
   //

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);
   if (NULL != pHandleEntry) {

      // possible we had a volume-label match the last time around
      // so we should then deploy dempLFNFindFirstFile if this the case
      //
      if (INVALID_HANDLE_VALUE == pHandleEntry->hFindHandle) {
         dwStatus = dempLFNFindFirstFile(&pHandleEntry->hFindHandle,
                                         &pHandleEntry->unicodeFileName,
                                         &FindDataW,
                                         pHandleEntry->wMustMatchAttributes,
                                         pHandleEntry->wSearchAttributes);

         RtlFreeUnicodeString(&pHandleEntry->unicodeFileName);
      }
      else {
         dwStatus = dempLFNFindNextFile(pHandleEntry->hFindHandle,
                                        &FindDataW,
                                        pHandleEntry->wMustMatchAttributes,
                                        pHandleEntry->wSearchAttributes);
      }
      if (NT_SUCCESS(dwStatus)) {
         // this is ok

         dwStatus = dempLFNConvertFindDataUnicodeToOem(lpFindData,
                                                       &FindDataW,
                                                       wDateTimeFormat,
                                                       pConversionCode,
                                                       lpFileName,
                                                       lpAltFileName);
      }

   }
   else {
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_HANDLE);
   }

   return(dwStatus);
}

DWORD
demLFNFindClose(
   USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   DWORD dwStatus = STATUS_SUCCESS;

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);
   if (NULL != pHandleEntry) {
      if (INVALID_HANDLE_VALUE != pHandleEntry->hFindHandle) {
         dwStatus = FindClose(pHandleEntry->hFindHandle);
      }

      dempLFNFreeHandleEntry(pHandleEntry);
   }
   else {
      // invalid handle
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_HANDLE);
   }

   return(dwStatus);

}

////////////////////////////////////////////////////////////////////////////
//
// The current directory wrath
//
//
//
// Rules:
// - we keep the directory in question in SHORT form
// - if the length of it exceeds what's in CDS -- then we
//   keep it in LCDS

// current directory is stored:
// TDB -- \foo\blah
// cds -- c:\foo\blah
// getcurrentdirectory apis return foo\blah
//

#define MAX_DOS_DRIVES 26


// we need flags to mark when our current directory is out of sync
// so that we could provide for it's long version when necessary
//
#define LCDS_VALID   0x00000001  // curdir on the drive is valid
#define LCDS_SYNC    0x00000002  // curdir on the drive has to be synced

typedef struct tagLCDSEntry {
   CHAR szCurDir[MAX_PATH];
   DWORD dwFlags;
}  LCDSENTRY, *PLCDSENTRY;

// this is stored here, so we can have our current directories per
// drive in their long form

PLCDSENTRY rgCurDirs[MAX_DOS_DRIVES] = {NULL};

#define CD_NOTDB         0x00010000 // ignore tdb
#define CD_NOCDS         0x00020000 // ignore cds
#define CD_DIRNAMEMASK   0x0000FFFF
#define CD_SHORTDIRNAME  0x00000001
#define CD_LONGDIRNAME   0x00000002
#define CD_CDSDIRNAME    0x00000003


typedef enum tagDirType {
   dtLFNDirName = CD_LONGDIRNAME,
   dtShortDirName = CD_SHORTDIRNAME,
   dtCDSDirName = CD_CDSDIRNAME
}  enumDirType;

// drive here is 0-25

// check whether we received this ptr from wow

BOOL (*DosWowGetTDBDir)(UCHAR Drive, LPSTR pCurrentDirectory);
VOID (*DosWowUpdateTDBDir)(UCHAR Drive, LPSTR pCurrentDirectory);
BOOL (*DosWowDoDirectHDPopup)(VOID);

// makes sure cds directory is valid

BOOL dempValidateDirectory (PCDS pcds, UCHAR Drive)
{
    DWORD dw;
    CHAR  chDrive;
    static CHAR  pPath[]="?:\\";
    static CHAR  EnvVar[] = "=?:";

    // validate media
    chDrive = Drive + 'A';
    pPath[0] = chDrive;
    dw = GetFileAttributesOem(pPath);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY)) {
       return (FALSE);
    }

    // if invalid path, set path to the root
    // reset CDS, and win32 env for win32
    dw = GetFileAttributesOem(pcds->CurDir_Text);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY)) {
       strcpy(pcds->CurDir_Text, pPath);
       pcds->CurDir_End = 2;
       EnvVar[1] = chDrive;
       SetEnvironmentVariableOem(EnvVar,pPath);
    }

    return (TRUE);
}


// drive here is 0-25
// returns: pointer to cds entry

PCDS dempGetCDSPtr(USHORT Drive)
{
   PCDS pCDS = NULL;
   static CHAR Path[] = "?:\\";

   if (Drive >= (USHORT)*(PUCHAR)DosWowData.lpCDSCount) {
      // so it's more than fixed
      if (Drive <= (MAX_DOS_DRIVES-1)) {
         Path[0] = 'A' + Drive;
         if ((USHORT)*(PUCHAR)DosWowData.lpCurDrv == Drive || GetDriveType(Path) > DRIVE_NO_ROOT_DIR) {
            pCDS = (PCDS)DosWowData.lpCDSBuffer;
         }
      }
   }
   else {
      Path[0] = 'A' + Drive;
      if (1 != Drive || (DRIVE_REMOVABLE == GetDriveType(Path))) {
         pCDS = (PCDS)DosWowData.lpCDSFixedTable;
#ifdef FE_SB
         if (GetSystemDefaultLangID() == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
             pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS_JPN)));
         }
         else
             pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS)));
#else
         pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS)));
#endif
      }
   }
   return pCDS;
}

#define MAXIMUM_VDM_CURRENT_DIR 64

BOOL
dempUpdateCDS(USHORT Drive, PCDS pcds)
{
   // update cds with the current directory as specified in env variable
   // please note that it only happens upon a flag being reset in cds

   static CHAR  EnvVar[] = "=?:";
   DWORD EnvVarLen;
   BOOL bStatus = TRUE;
   UCHAR FixedCount;
   int i;
   PCDS pcdstemp;

   FixedCount = *(PUCHAR) DosWowData.lpCDSCount;
   //
   // from Macro.Asm in DOS:
   // ; Sudeepb 20-Dec-1991 ; Added for redirected drives
   // ; We always sync the redirected drives. Local drives are sync
   // ; as per the curdir_tosync flag and SCS_ToSync
   //

   if (*(PUCHAR)DosWowData.lpSCS_ToSync) {

#ifdef FE_SB
       if (GetSystemDefaultLangID() == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
           PCDS_JPN pcdstemp_jpn;

           pcdstemp_jpn = (PCDS_JPN) DosWowData.lpCDSFixedTable;
           for (i=0;i < (int)FixedCount; i++, pcdstemp_jpn++)
               pcdstemp_jpn->CurDirJPN_Flags |= CURDIR_TOSYNC;
       }
       else {
           pcdstemp = (PCDS) DosWowData.lpCDSFixedTable;
           for (i=0;i < (int)FixedCount; i++, pcdstemp++)
               pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;
       }
#else
       pcdstemp = (PCDS) DosWowData.lpCDSFixedTable;
       for (i=0;i < (int)FixedCount; i++, pcdstemp++)
           pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;
#endif

       // Mark tosync in network drive as well
       pcdstemp = (PCDS)DosWowData.lpCDSBuffer;
       pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;

       *(PUCHAR)DosWowData.lpSCS_ToSync = 0;
   }

   // If CDS needs to be synched or if the requested drive is different
   // then the the drive being used by NetCDS go refresh the CDS.
   if ((pcds->CurDir_Flags & CURDIR_TOSYNC) ||
       ((Drive >= FixedCount) && (pcds->CurDir_Text[0] != (Drive + 'A') &&
                                  pcds->CurDir_Text[0] != (Drive + 'a')))) {
       // validate media
       EnvVar[1] = Drive + 'A';
       if((EnvVarLen = GetEnvironmentVariableOem (EnvVar, (LPSTR)pcds,
                                               MAXIMUM_VDM_CURRENT_DIR+3)) == 0){

       // if its not in env then and drive exist then we have'nt
       // yet touched it.

           pcds->CurDir_Text[0] = EnvVar[1];
           pcds->CurDir_Text[1] = ':';
           pcds->CurDir_Text[2] = '\\';
           pcds->CurDir_Text[3] = 0;
           SetEnvironmentVariableOem ((LPSTR)EnvVar,(LPSTR)pcds);
       }

       if (EnvVarLen > MAXIMUM_VDM_CURRENT_DIR+3) {
           //
           // The current directory on this drive is too long to fit in the
           // cds. That's ok for a win16 app in general, since it won't be
           // using the cds in this case. But just to be more robust, put
           // a valid directory in the cds instead of just truncating it on
           // the off chance that it gets used.
           //
           pcds->CurDir_Text[0] = EnvVar[1];
           pcds->CurDir_Text[1] = ':';
           pcds->CurDir_Text[2] = '\\';
           pcds->CurDir_Text[3] = 0;
       }

       pcds->CurDir_Flags &= 0xFFFF - CURDIR_TOSYNC;
       pcds->CurDir_End = 2;

   }

   if (!bStatus) {

       *(PUCHAR)DosWowData.lpDrvErr = ERROR_INVALID_DRIVE;
   }

   return (bStatus);
}


// takes:
//           Drive 0-25
// returns:
//           fully-qualified current directory if success
//

NTSTATUS
dempGetCurrentDirectoryTDB(UCHAR Drive, LPSTR pCurDir)
{
   NTSTATUS Status;

   // see if we're wow-bound
   if (NULL != DosWowGetTDBDir) {
      if (DosWowGetTDBDir(Drive, &pCurDir[3])) {
         pCurDir[0] = 'A' + Drive;
         pCurDir[1] = ':';
         pCurDir[2] = '\\';
         return(STATUS_SUCCESS);
      }
   }

   return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
}

VOID
dempSetCurrentDirectoryTDB(UCHAR Drive, LPSTR pCurDir)
{
   if (NULL != DosWowUpdateTDBDir) {
      DosWowUpdateTDBDir(Drive, pCurDir);
   }
}

NTSTATUS
dempGetCurrentDirectoryCDS(UCHAR Drive, LPSTR pCurDir)
{
   PCDS pCDS;
   NTSTATUS Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);

   if (NULL != (pCDS = dempGetCDSPtr(Drive))) {
      if (dempUpdateCDS(Drive, pCDS)) {
         // now we can get cds data
         // DOS. sudeepb 30-Dec-1993
         if (!(pCDS->CurDir_Flags & CURDIR_NT_FIX)) {
            // that means -- re-query the drive
            if (!dempValidateDirectory(pCDS, Drive)) {
               return(Status);
            }
         }

         strcpy(pCurDir, &pCDS->CurDir_Text[0]);
         Status = STATUS_SUCCESS;
      }

   }
   return(Status);
}

BOOL
dempValidateDirectoryCDS(PCDS pCDS, UCHAR Drive)
{
   BOOL fValid = TRUE;

   if (NULL == pCDS) {
      pCDS = dempGetCDSPtr(Drive);
   }
   if (NULL != pCDS) {
      if (!(pCDS->CurDir_Flags & CURDIR_NT_FIX)) {
         fValid = dempValidateDirectory(pCDS, Drive);
      }
   }
   return(fValid);
}


// we assume that drive here is 0-based drive number and
// pszDir is a full-formed path

NTSTATUS
dempSetCurrentDirectoryCDS(UCHAR Drive, LPSTR pszDir)
{
   PCDS pCDS;
   NTSTATUS Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);

   if (NULL != (pCDS = dempGetCDSPtr(Drive))) {
      // cds retrieved successfully

      // now for this drive -- validate

      if (strlen(pszDir) > MAXIMUM_VDM_CURRENT_DIR+3) {
         // put a valid directory in cds just for robustness' sake
         strncpy(&pCDS->CurDir_Text[0], pszDir, 3);
         pCDS->CurDir_Text[3] = '\0';
         Status = STATUS_SUCCESS;
      } else {
         strcpy(&pCDS->CurDir_Text[0], pszDir);
         Status = STATUS_SUCCESS;
      }
   }
   return(Status);
}

// just manipulate curdir caches

NTSTATUS
demSetCurrentDirectoryLCDS(UCHAR Drive, LPSTR pCurDir)
{
   PLCDSENTRY pCurDirCache;

   pCurDirCache = rgCurDirs[Drive];
   if (NULL == pCurDir) {
      if (NULL != pCurDirCache) {
         RtlFreeHeap(RtlProcessHeap(), 0, pCurDirCache);
         rgCurDirs[Drive] = NULL;
         return(STATUS_SUCCESS);
      }
   }
   else {
      if (NULL == pCurDirCache) {
         pCurDirCache = RtlAllocateHeap(RtlProcessHeap(),
                                        0,
                                        sizeof(LCDSENTRY));

         if (NULL == pCurDirCache) {
            return(NT_STATUS_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
         }
      }
   }

   strcpy(pCurDirCache->szCurDir, pCurDir);

   return(STATUS_SUCCESS);
}

// pCurDir is valid to be NULL -- meaning -- just checking if the dir
// for this drive is cached

NTSTATUS
demGetCurrentDirectoryLCDS(UCHAR Drive, LPSTR pCurDir)
{
   PLCDSENTRY pCurDirCache;
   NTSTATUS Status = STATUS_SUCCESS;

   pCurDirCache = rgCurDirs[Drive];
   if (NULL != pCurDirCache) {
      if (NULL != pCurDir) {
         strcpy(pCurDir, pCurDirCache->szCurDir);
      }
   }
   else {
      Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
   }

   return(Status);
}

NTSTATUS
dempGetCurrentDirectoryWin32(UCHAR Drive, LPSTR pCurDir)
{
   // we do a getenvironment blah instead
   static CHAR EnvVar[] = "=?:\\";
   DWORD EnvVarLen;
   DWORD dwAttributes;
   NTSTATUS Status = STATUS_SUCCESS;

   EnvVar[1] = 'A' + Drive;
   EnvVarLen = GetEnvironmentVariableOem (EnvVar, pCurDir, MAX_PATH);
   if (0 == EnvVarLen) {
      // that was not touched before
      pCurDir[0] = EnvVar[1];
      pCurDir[1] = ':';
      pCurDir[2] = '\\';
      pCurDir[3] = '\0';
      SetEnvironmentVariableOem ((LPSTR)EnvVar,(LPSTR)pCurDir);
   }
   else {
      if (EnvVarLen > MAX_PATH) {
         Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
         return(Status);
      }
      // if we're doing it here -- validate dir

      dwAttributes = GetFileAttributesOem(pCurDir);
      if (0xffffffff == dwAttributes) {
         Status = GET_LAST_STATUS();
      }
      else {
         // now see if this is a directory
         if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
         }
      }
   }

   return(Status);
}

// lifted from wdos.c

NTSTATUS
dempSetCurrentDirectoryWin32(UCHAR Drive, LPSTR pCurDir)
{
    static CHAR EnvVar[] = "=?:";
    CHAR chDrive = Drive + 'A';
    BOOL bRet;
    NTSTATUS Status = STATUS_SUCCESS;

    // ok -- we are setting the current directory ONLY if the drive
    // is the current drive for the app

    if (*(PUCHAR)DosWowData.lpCurDrv == Drive) { // if on the current drive--go win32
       bRet = SetCurrentDirectoryOem(pCurDir);
       if (!bRet) {
          Status = GET_LAST_STATUS();
       }
    }
    else {  // verify it's a valid dir
       DWORD dwAttributes;

       dwAttributes = GetFileAttributesOem(pCurDir);
       bRet = (0xffffffff != dwAttributes) && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY);
       if (!bRet) {
          Status = STATUS_INVALID_HANDLE;
       }
    }

    if (!bRet) {
       return(Status);
    }

    EnvVar[1] = chDrive;
    bRet = SetEnvironmentVariableOem((LPSTR)EnvVar, pCurDir);
    if (!bRet) {
       Status = GET_LAST_STATUS();
    }

    return (Status);
}

NTSTATUS
demGetCurrentDirectoryLong(UCHAR Drive, LPSTR pCurDir, DWORD LongDir)
{
   PLCDSENTRY pCurDirCache = NULL;
   NTSTATUS Status = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
   CHAR szCurrentDirectory[MAX_PATH];

   // first -- attempt to get the dir from tdb in WOW (if this is wow)
   // unless off course it's been blocked

   if (!(LongDir & CD_NOTDB)) {
      Status = dempGetCurrentDirectoryTDB(Drive, szCurrentDirectory);
   }

   // now try to get the dir off our cache
   if (!NT_SUCCESS(Status)) { // we don't have the dir from TDB
      Status = demGetCurrentDirectoryLCDS(Drive, szCurrentDirectory);
   }

   if (!NT_SUCCESS(Status) && !(LongDir & CD_NOCDS)) { // so neither TDB nor LCDS -- try CDS
      Status = dempGetCurrentDirectoryCDS(Drive, szCurrentDirectory);
   }

   // so at this point if we've failed -- that means our directory is not
   // good at all. Hence return error -- all means have failed
   // we do the very last in all the things
   if (!NT_SUCCESS(Status)) {
      // this one could be lfn !
      Status = dempGetCurrentDirectoryWin32(Drive, szCurrentDirectory);
   }

   // so we have gone through all the stages --

   if (!NT_SUCCESS(Status)) {
      return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
   }

   // now see that we convert the dir we have in a proper manner

   switch(LongDir & CD_DIRNAMEMASK) {
   case dtLFNDirName:
      Status = demLFNGetPathName(szCurrentDirectory, pCurDir, fnGetLongPathName, FALSE);
      break;
   case dtCDSDirName:
      if (strlen(szCurrentDirectory) > MAXIMUM_VDM_CURRENT_DIR+3) {
         Status = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
         break;
      }
      // intentional fall-through

   case dtShortDirName:
      strcpy(pCurDir, szCurrentDirectory);
      break;
   }

   return Status;
}

// remember -- this should be called with a full-formed path -- short or long

NTSTATUS
demSetCurrentDirectoryLong(UCHAR Drive, LPSTR pCurDir, DWORD LongDir)
{
   NTSTATUS Status;
   CHAR szCurrentDirectory[MAX_PATH];

   // first convert to a short path
   Status = demLFNGetPathName(pCurDir, szCurrentDirectory, fnGetShortPathName, FALSE);
   if (!NT_SUCCESS(Status)) {
      return(Status);
   }

   Status = dempSetCurrentDirectoryWin32(Drive, szCurrentDirectory);
   if (!NT_SUCCESS(Status)) {
      return(Status);
   }

   Status = demSetCurrentDirectoryLCDS(Drive, szCurrentDirectory);
   if (!NT_SUCCESS(Status)) {
      return(Status); // memory ?
   }

   // first we have to see if we have to poke through
   if (!(LongDir & CD_NOCDS)) {
      // set it in cds
      Status = dempSetCurrentDirectoryCDS(Drive, szCurrentDirectory);
      if (!NT_SUCCESS(Status)) {
         return(Status);
      }
   }

   if (!(LongDir & CD_NOTDB)) {
      dempSetCurrentDirectoryTDB(Drive, szCurrentDirectory);
   }

   return(Status);
}

/* Rules of engagement:
 *
 *    - the env variable -- which ?:= is not useful as it's max length is
 *      limited to 64+3 chars.
 *    - the cds entry is also limited in length
 *    - we have our own entry in the
 *
 *    - jarbats bug 207913
 *      demLFNGetCurrentDirectory, returns an empty string, if the current directory is the root
 *      RtlGetFullPathName_U fails when the first parameter (CurrentDirectory) is an empty string
 *      dempLFNSetCurrentDirectory fails
 *      fix by changing empty string to \
 *
 */


NTSTATUS
dempLFNSetCurrentDirectory(
   PUNICODE_STRING pCurrentDirectory,
   PUINT pDriveNum // optional
)
{
   UNICODE_STRING FullPathName;
   DWORD dwStatus;
   RTL_PATH_TYPE RtlPathType;
   UCHAR Drive;
   BOOL  fCurrentDrive;
   OEM_STRING OemDirectoryName;
   CHAR szFullPathOem[MAX_PATH];
   WCHAR szFullPathUnicode[MAX_PATH];
   LPWSTR lpCurrentDir=L"\\";

   if ( pCurrentDirectory->Buffer && pCurrentDirectory->Buffer[0] != L'\0' ) {
        lpCurrentDir = pCurrentDirectory->Buffer;
   }

   RtlPathType = RtlDetermineDosPathNameType_U(lpCurrentDir);
   // now --

   switch(RtlPathType) {
   case RtlPathTypeDriveAbsolute:

      // this is a chdir on a specific drive  -- is this a current drive ?
      CharUpperBuffW(lpCurrentDir, 1);
      Drive = (UCHAR)(lpCurrentDir[0] - L'A');
      fCurrentDrive = (Drive == *(PUCHAR)DosWowData.lpCurDrv);
      break;

   case RtlPathTypeDriveRelative:
   case RtlPathTypeRelative:
   case RtlPathTypeRooted:

      // this is a chdir on a current drive
      Drive = *(PUCHAR)DosWowData.lpCurDrv;
      fCurrentDrive = TRUE;
      break;

   default:
      // invalid call -- goodbye
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
      goto scdExit;
      break;
   }

   // please remember that we should have set the current dir
   // when curdrive gets selected -- hence we can rely upon win32
   // for path expansion...
   // actually this is only true for the current drives. In case of this
   // particular api it may not be true.
   // so -- uncash the current setting here -- bugbug ??


   // now get the full path name

   FullPathName.Buffer = szFullPathUnicode;
   FullPathName.MaximumLength = sizeof(szFullPathUnicode);

   dwStatus = RtlGetFullPathName_U(lpCurrentDir,
                                   FullPathName.MaximumLength,
                                   FullPathName.Buffer,
                                   NULL);
   // check length and set status
   CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, &FullPathName);

   if (!NT_SUCCESS(dwStatus)) {
      goto scdExit; // exit with status code
   }

   OemDirectoryName.Buffer = szFullPathOem;
   OemDirectoryName.MaximumLength = sizeof(szFullPathOem);

   // convert this stuff (fullpath) to oem

   dwStatus = DemUnicodeStringToDestinationString(&OemDirectoryName,
                                                  &FullPathName,
                                                  FALSE,
                                                  FALSE);
   if (!NT_SUCCESS(dwStatus)) {
      goto scdExit;
   }

   dwStatus = demSetCurrentDirectoryLong(Drive, OemDirectoryName.Buffer, 0);
   if (NULL != pDriveNum) {
      *pDriveNum = Drive;
   }

scdExit:

   return(dwStatus);
}

// this is a compound api that sets both current drive and current directory
// according to what has been specified in a parameter
// the return value is also for the drive number

DWORD
demSetCurrentDirectoryGetDrive(LPSTR lpDirectoryName, PUINT pDriveNum)
{
   PUNICODE_STRING pUnicodeStaticDirectoryName;
   OEM_STRING OemDirectoryName;
   DWORD dwStatus;
   UINT Drive;

   // this is external api callable from wow ONLY -- it depends on
   // deminitcdsptr having been initialized!!! which happens if:
   // -- call has been made through lfn api
   // -- app running on wow (windows app)


   // convert to uni
   pUnicodeStaticDirectoryName = GET_STATIC_UNICODE_STRING_PTR();

   // preamble - convert input parameter/validate

   // init oem counted string
   RtlInitOemString(&OemDirectoryName, lpDirectoryName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticDirectoryName,
                                             &OemDirectoryName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticDirectoryName,
                                          &OemDirectoryName,
                                          FALSE);
#endif


   // first we extract the drive
   dwStatus = dempLFNSetCurrentDirectory(pUnicodeStaticDirectoryName, pDriveNum);

   return(dwStatus);
}

// each of these functions could have used OEM thunk in oemuni
// for efficiency purpose we basically do what they did

#if 1

DWORD
demLFNDirectoryControl(
   UINT  uiFunctionCode,
   LPSTR lpDirectoryName)
{
   DWORD dwStatus = STATUS_SUCCESS;
   PUNICODE_STRING pUnicodeStaticDirectoryName;
   OEM_STRING OemDirectoryName;
   BOOL fResult;


   // we use a temp static unicode string
   pUnicodeStaticDirectoryName = GET_STATIC_UNICODE_STRING_PTR();

   // preamble - convert input parameter/validate

   // init oem counted string
   RtlInitOemString(&OemDirectoryName, lpDirectoryName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticDirectoryName,
                                             &OemDirectoryName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticDirectoryName,
                                          &OemDirectoryName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      //
      // fix bizarre behavior of win95 apis
      //
      if (dwStatus == STATUS_BUFFER_OVERFLOW) {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND);
      }

      return(dwStatus);
   }


   switch (uiFunctionCode) {
   case fnLFNCreateDirectory:

      fResult = CreateDirectoryW(pUnicodeStaticDirectoryName->Buffer,NULL);
      if (!fResult) {
         dwStatus = GET_LAST_STATUS();
         if (NT_STATUS_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) == dwStatus ||
             NT_STATUS_FROM_WIN32(ERROR_ALREADY_EXISTS) == dwStatus) {
            dwStatus = NT_STATUS_FROM_WIN32(ERROR_ACCESS_DENIED);
         }
      }
      break;

   case fnLFNRemoveDirectory:

      fResult = RemoveDirectoryW(pUnicodeStaticDirectoryName->Buffer);
      if (!fResult) {
         dwStatus = GET_LAST_STATUS();
      }
      break;

   case fnLFNSetCurrentDirectory:

      // as it appears, this implementation is not good enough
      // dos does a lot more fun things than just call to an api
      dwStatus = dempLFNSetCurrentDirectory(pUnicodeStaticDirectoryName, NULL);
      break;
   }

   return(dwStatus);
}

#else

DWORD
demLFNDirectoryControl(
   UINT uiFunctionCode,
   LPSTR lpDirectoryName)
{
   BOOL fResult;

   switch(uiFunctionCode) {
   case fnLFNCreateDirectory:
      fResult = CreateDirectoryOem(lpDirectoryName, NULL);
      break;

   case fnLFNRemoveDirectory:
      fResult = RemoveDirectoryOem(lpDirectoryName);
      break;

   case fnLFNSetCurrentDirectory:
      fResult = SetCurrentDirectoryOem(lpDirectoryName);
      break;

   default:
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION));
   }

   return(fResult ? STATUS_SUCCESS :
                    GET_LAST_STATUS());

}

#endif

/*
 * With this api win95 returns :
 * - int24's are generated
 * - 0x0f if drive is invalid
 * - 0x03 on set to invalid
 *
 *
 *
 *
 */


DWORD
demLFNGetCurrentDirectory(
   UINT  DriveNum,
   LPSTR lpDirectoryName)
{
   // unfortunately, this fn is not present in win nt so we emulate
   DWORD dwStatus;
   CHAR  szCurrentDirectory[MAX_PATH];

   if (0 == DriveNum) {
      DriveNum = (UINT)*(PUCHAR)DosWowData.lpCurDrv;
   }
   else {
      --DriveNum;
   }


   dwStatus = demGetCurrentDirectoryLong((UCHAR)DriveNum, szCurrentDirectory, dtLFNDirName);
   if (NT_SUCCESS(dwStatus)) {
      strcpy(lpDirectoryName, &szCurrentDirectory[3]);
   }
   // done
   return(dwStatus);
}



DWORD
demLFNMoveFile(
   LPSTR lpOldName,
   LPSTR lpNewName)
{
   DWORD dwStatus = STATUS_SUCCESS;
   UNICODE_STRING unicodeOldName;
   UNICODE_STRING unicodeNewName;
   OEM_STRING oemString;

   RtlInitOemString(&oemString, lpOldName);

   // convert source path from ansi to unicode and allocate result
   // this rtl function returns status code, not the winerror code
   //

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(&unicodeOldName, &oemString, TRUE);

#else

   dwStatus = RtlOemStringToUnicodeString(&unicodeOldName, &oemString, TRUE);

#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   dempLFNNormalizePath(&unicodeOldName);


   RtlInitOemString(&oemString, lpNewName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(&unicodeNewName, &oemString, TRUE);

#else

   dwStatus = RtlOemStringToUnicodeString(&unicodeNewName, &oemString, TRUE);

#endif


   if (!NT_SUCCESS(dwStatus)) {
      RtlFreeUnicodeString(&unicodeOldName);
      return(dwStatus);
   }

   dempLFNNormalizePath(&unicodeNewName);


   if (!MoveFileW(unicodeOldName.Buffer, unicodeNewName.Buffer)) {
      dwStatus = GET_LAST_STATUS();
   }

   RtlFreeUnicodeString(&unicodeOldName);
   RtlFreeUnicodeString(&unicodeNewName);
   return(dwStatus);
}




DWORD
demLFNGetVolumeInformation(
   LPSTR  lpRootName,
   LPLFNVOLUMEINFO lpVolumeInfo)
{
   DWORD dwStatus = STATUS_SUCCESS;
   DWORD dwFSFlags;

#if 0

   if (_stricmp(lpRootName, "\\:\\")) {
      // special case of edit.com calling us to see if we support LFN when
      // started from a unc path


   }

#endif


   if (!GetVolumeInformationOem(lpRootName,
                                NULL, // name buffer
                                0,
                                NULL, // volume serial num
                                &lpVolumeInfo->dwMaximumFileNameLength,
                                &dwFSFlags,
                                lpVolumeInfo->lpFSNameBuffer,
                                lpVolumeInfo->dwFSNameBufferSize)) {
      dwStatus = GET_LAST_STATUS();
   }
   else {

      dwFSFlags &= LFN_FS_ALLOWED_FLAGS; // clear out anything that is not Win95
      dwFSFlags |= FS_LFN_APIS;          // say we support lfn apis always
      lpVolumeInfo->dwFSFlags = dwFSFlags;

      // this is shaky yet who'd really use it ?
      // 4 = <driveletter><:><\><FileName><\0>
      lpVolumeInfo->dwMaximumPathNameLength = lpVolumeInfo->dwMaximumFileNameLength + 5;
   }

   return(dwStatus);
}



// assume the pFileTime being a UTC format always
// uiMinorCode is enumFileTimeControlMinorCode type

#define AlmostTwoSeconds (2*1000*1000*10 - 1)

DWORD
demLFNFileTimeControl(
   UINT uiMinorCode,
   FILETIME* pFileTime,
   PLFNFILETIMEINFO pFileTimeInfo)
{
   DWORD dwStatus = STATUS_SUCCESS;
   TIME_FIELDS TimeFields;
   LARGE_INTEGER Time;
   USHORT u;
   FILETIME ftLocal;
   BOOL fResult;


   switch(uiMinorCode & FTCTL_CODEMASK) {
   case fnFileTimeToDosDateTime:

      if (!(uiMinorCode & FTCTL_UTCTIME)) {
         if (!FileTimeToLocalFileTime(pFileTime, &ftLocal)) {
            dwStatus = GET_LAST_STATUS();
            break; // break out as the conv error occured
         }
      }
      else {
         ftLocal = *pFileTime;   // just utc file time
      }

      Time.LowPart  = ftLocal.dwLowDateTime;
      Time.HighPart = ftLocal.dwHighDateTime;
      Time.QuadPart += (LONGLONG)AlmostTwoSeconds;

      RtlTimeToTimeFields(&Time, &TimeFields);

      if (TimeFields.Year < (USHORT)1980 || TimeFields.Year > (USHORT)2107) {
         pFileTimeInfo->uDosDate = (1 << 5) | 1; // January, 1st, 1980
         pFileTimeInfo->uDosTime = 0;
         pFileTimeInfo->uMilliseconds = 0;
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA);
      }
      else {
         pFileTimeInfo->uDosDate = (USHORT)(
                           ((USHORT)(TimeFields.Year-(USHORT)1980) << 9) |
                           ((USHORT)TimeFields.Month << 5) |
                           (USHORT)TimeFields.Day
                           );

         pFileTimeInfo->uDosTime = (USHORT)(
                           ((USHORT)TimeFields.Hour << 11) |
                           ((USHORT)TimeFields.Minute << 5) |
                           ((USHORT)TimeFields.Second >> 1)
                           );

         // set the spillover so we can correctly retrieve the seconds
         // we are talking of milliseconds in units of 10
         // so the max value here is 199

         pFileTimeInfo->uMilliseconds = ((TimeFields.Second & 0x1) * 1000 +
                                          TimeFields.Milliseconds) / 10;
      }
      break;

   case fnDosDateTimeToFileTime:
      // here the process is backwards
      u = pFileTimeInfo->uDosDate;

      TimeFields.Year  = ((u & 0xFE00) >> 9) + (USHORT)1980;
      TimeFields.Month = ((u & 0x01E0) >> 5);
      TimeFields.Day   =  (u & 0x001F);

      u = pFileTimeInfo->uDosTime;

      TimeFields.Hour   = (u  & 0xF800) >> 11;
      TimeFields.Minute = (u  & 0x07E0) >> 5;
      TimeFields.Second = (u  & 0x001F) << 1; // seconds as multiplied...

      // correction
      u = pFileTimeInfo->uMilliseconds * 10; // approx millisecs
      TimeFields.Second += u / 1000;
      TimeFields.Milliseconds = u % 1000;

      if (RtlTimeFieldsToTime(&TimeFields, &Time)) {

         // now convert to global time
         ftLocal.dwLowDateTime  = Time.LowPart;
         ftLocal.dwHighDateTime = Time.HighPart;
         if (!LocalFileTimeToFileTime(&ftLocal, pFileTime)) {
            dwStatus = GET_LAST_STATUS();
         }
      }
      else {
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA);
      }

      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
      break;
   }

   return(dwStatus);

}



NTSTATUS
dempLFNSetFileTime(
   UINT uMinorCode,
   PUNICODE_STRING pFileName,
   PLFNFILETIMEINFO pTimeInfo)
{
   OBJECT_ATTRIBUTES ObjAttributes;
   HANDLE hFile;
   UNICODE_STRING FileName;
   RTL_RELATIVE_NAME RelativeName;
   BOOL TranslationStatus;
   PVOID FreeBuffer;
   FILE_BASIC_INFORMATION FileBasicInfo;
   IO_STATUS_BLOCK IoStatusBlock;
   LPFILETIME pFileTime;
   NTSTATUS dwStatus;


   //
   // Prepare info
   //

   RtlZeroMemory(&FileBasicInfo, sizeof(FileBasicInfo));
   switch(uMinorCode) {
   case fnSetCreationDateTime:
      pFileTime = (LPFILETIME)&FileBasicInfo.CreationTime;
      break;

   case fnSetLastAccessDateTime:
      pFileTime = (LPFILETIME)&FileBasicInfo.LastAccessTime;
      break;

   case fnSetLastWriteDateTime:
      pFileTime = (LPFILETIME)&FileBasicInfo.LastWriteTime;
      break;
   }

   dwStatus = demLFNFileTimeControl(fnDosDateTimeToFileTime,
                                    pFileTime,
                                    pTimeInfo);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   TranslationStatus = RtlDosPathNameToNtPathName_U(pFileName->Buffer,
                                                    &FileName,
                                                    NULL,
                                                    &RelativeName);

   if (!TranslationStatus) {
      return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
   }

   FreeBuffer = FileName.Buffer;

   // this is relative-path optimization stolen from filehops.c in base/client

   if (0 != RelativeName.RelativeName.Length) {
      FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
   }
   else {
      RelativeName.ContainingDirectory = NULL;
   }

   InitializeObjectAttributes(
       &ObjAttributes,
       &FileName,
       OBJ_CASE_INSENSITIVE,
       RelativeName.ContainingDirectory,
       NULL
       );

   //
   // Open the file
   //

   dwStatus = NtOpenFile(
               &hFile,
               FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
               &ObjAttributes,
               &IoStatusBlock,
               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
               FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
               );

   RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   //
   // Set file basic info.
   //

   dwStatus = NtSetInformationFile(
               hFile,
               &IoStatusBlock,
               &FileBasicInfo,
               sizeof(FileBasicInfo),
               FileBasicInformation
               );

   NtClose(hFile);

   return(dwStatus);
}



NTSTATUS
dempLFNGetFileTime(
   UINT uMinorCode,
   PUNICODE_STRING pFileName,
   PLFNFILETIMEINFO pTimeInfo)
{

   OBJECT_ATTRIBUTES ObjAttributes;
   UNICODE_STRING FileName;
   RTL_RELATIVE_NAME RelativeName;
   BOOL TranslationStatus;
   PVOID FreeBuffer;
   LPFILETIME pFileTime;
   NTSTATUS dwStatus;
   FILE_NETWORK_OPEN_INFORMATION NetworkInfo;


   TranslationStatus = RtlDosPathNameToNtPathName_U(pFileName->Buffer,
                                                    &FileName,
                                                    NULL,
                                                    &RelativeName);

   if (!TranslationStatus) {
      return(NT_STATUS_FROM_WIN32(ERROR_PATH_NOT_FOUND));
   }

   FreeBuffer = FileName.Buffer;

   // this is relative-path optimization stolen from filehops.c in base/client

   if (0 != RelativeName.RelativeName.Length) {
      FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
   }
   else {
      RelativeName.ContainingDirectory = NULL;
   }

   InitializeObjectAttributes(
       &ObjAttributes,
       &FileName,
       OBJ_CASE_INSENSITIVE,
       RelativeName.ContainingDirectory,
       NULL
       );


   dwStatus = NtQueryFullAttributesFile( &ObjAttributes, &NetworkInfo);
   RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   switch (uMinorCode) {
   case fnGetCreationDateTime:
      pFileTime = (LPFILETIME)&NetworkInfo.CreationTime;
      break;

   case fnGetLastAccessDateTime:
      pFileTime = (LPFILETIME)&NetworkInfo.LastAccessTime;
      break;

   case fnGetLastWriteDateTime:
      pFileTime = (LPFILETIME)&NetworkInfo.LastWriteTime;
      break;
   }

   // assert here against pFileTime

   // convert to dos style
   dwStatus = demLFNFileTimeControl(fnFileTimeToDosDateTime |
                                       (dempUseUTCTimeByName(pFileName) ? FTCTL_UTCTIME : 0),
                                    pFileTime,
                                    pTimeInfo);
   if (!NT_SUCCESS(dwStatus) &&
       NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA) == dwStatus &&
       fnGetLastWriteDateTime == uMinorCode) {
      dwStatus = STATUS_SUCCESS;
   }

   return(dwStatus);
}


NTSTATUS
demLFNGetSetFileAttributes(
   UINT uMinorCode,
   LPSTR lpFileName,
   PLFNFILEATTRIBUTES pLFNFileAttributes)
{
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING oemFileName;
   NTSTATUS dwStatus = STATUS_SUCCESS;


   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

   RtlInitOemString(&oemFileName, lpFileName);

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &oemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &oemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }

   dempLFNNormalizePath(pUnicodeStaticFileName);

   switch(uMinorCode) {
   case fnGetFileAttributes:
      {
         DWORD dwAttributes;

         // attention! BUGBUG
         // need to check for volume id here - if the name actually matches...

         dwAttributes = GetFileAttributesW(pUnicodeStaticFileName->Buffer);
         if ((DWORD)-1 == dwAttributes) {
            dwStatus = GET_LAST_STATUS();
         }
         else {
            pLFNFileAttributes->wFileAttributes = (WORD)(dwAttributes & DEM_FILE_ATTRIBUTE_VALID);
         }
      }
      break;

   case fnSetFileAttributes:
      {
         DWORD dwAttributes;

         // this is how win95 handles this api:
         // the volume bit is valid but ignored, setting everything else but
         // DEM_FILE_ATTRIBUTE_SET_VALID is causing error 0x5 (access denied)
         //

         dwAttributes = (DWORD)pLFNFileAttributes->wFileAttributes;

         if (dwAttributes & (~(DEM_FILE_ATTRIBUTE_SET_VALID |
                               DEM_FILE_ATTRIBUTE_VOLUME_ID))) {
            dwStatus = NT_STATUS_FROM_WIN32(ERROR_ACCESS_DENIED);
         }
         else {

            dwAttributes &= DEM_FILE_ATTRIBUTE_SET_VALID; // clear possible volume id

            if (!SetFileAttributesW(pUnicodeStaticFileName->Buffer, dwAttributes)) {
               dwStatus = GET_LAST_STATUS();
            }
         }
      }
      break;

   case fnGetCompressedFileSize:
      {
         DWORD dwFileSize;


         dwFileSize = GetCompressedFileSizeW(pUnicodeStaticFileName->Buffer,
                                             NULL); // for dos we have no high part
         if ((DWORD)-1 == dwFileSize) {
            dwStatus = GET_LAST_STATUS();
         }
         else {
            pLFNFileAttributes->dwFileSize = dwFileSize;
         }
      }
      break;

   case fnSetLastWriteDateTime:
   case fnSetCreationDateTime:
   case fnSetLastAccessDateTime:
      dwStatus = dempLFNSetFileTime(uMinorCode,
                                    pUnicodeStaticFileName,
                                    &pLFNFileAttributes->TimeInfo);
      break;


   case fnGetLastAccessDateTime:
   case fnGetCreationDateTime:
   case fnGetLastWriteDateTime:
      dwStatus = dempLFNGetFileTime(uMinorCode,
                                    pUnicodeStaticFileName,
                                    &pLFNFileAttributes->TimeInfo);
      break;


   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
      break;
   }

   return(dwStatus);
}


BOOL
dempUseUTCTimeByHandle(
   HANDLE hFile)
{
   // if file is on a cdrom -- then we use utc time as opposed to other
   // local time
   NTSTATUS Status;
   IO_STATUS_BLOCK IoStatusBlock;
   FILE_FS_DEVICE_INFORMATION DeviceInfo;
   BOOL fUseUTCTime = FALSE;

   Status = NtQueryVolumeInformationFile(hFile,
                                         &IoStatusBlock,
                                         &DeviceInfo,
                                         sizeof(DeviceInfo),
                                         FileFsDeviceInformation);
   if (NT_SUCCESS(Status)) {
      // we look at the characteristics of this particular device --
      // if the media is cdrom -- then we DO NOT need to convert to local time
      fUseUTCTime = (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA) &&
                        (DeviceInfo.DeviceType == FILE_DEVICE_CD_ROM ||
                         DeviceInfo.DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM);
   }

   return(fUseUTCTime);
}

BOOL
dempUseUTCTimeByName(
   PUNICODE_STRING pFileName)
{
   DWORD Status;
   UNICODE_STRING UnicodeFullPath;
   WCHAR wszFullPath[MAX_PATH];
   RTL_PATH_TYPE RtlPathType;
   BOOL fUseUTCTime = FALSE;

   dempStringInitZeroUnicode(&UnicodeFullPath,
                             wszFullPath,
                             sizeof(wszFullPath)/sizeof(wszFullPath[0]));

   Status = RtlGetFullPathName_U(pFileName->Buffer,
                                 UnicodeFullPath.MaximumLength,
                                 UnicodeFullPath.Buffer,
                                 NULL);

   CHECK_LENGTH_RESULT_RTL_USTR(Status, &UnicodeFullPath);
   if (NT_SUCCESS(Status)) {
      RtlPathType = RtlDetermineDosPathNameType_U(UnicodeFullPath.Buffer);
      if (RtlPathTypeDriveAbsolute == RtlPathType) { // see that we have a valid root dir
         wszFullPath[3] = L'\0';
         fUseUTCTime = (DRIVE_CDROM == GetDriveTypeW(wszFullPath));
      }

   }
   return(fUseUTCTime);
}



/*
 * Handle a file handle - based time apis
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

NTSTATUS
dempGetFileTimeByHandle(
   UINT uFunctionCode,
   HANDLE hFile,
   PLFNFILETIMEINFO pTimeInfo)
{
   NTSTATUS dwStatus;
   FILETIME* pCreationTime   = NULL;
   FILETIME* pLastAccessTime = NULL;
   FILETIME* pLastWriteTime  = NULL;
   FILETIME FileTime;

   switch (uFunctionCode) {
   case fnFTGetLastWriteDateTime:
      pLastWriteTime = &FileTime;
      break;

   case fnFTGetLastAccessDateTime:
      pLastAccessTime = &FileTime;
      break;

   case fnFTGetCreationDateTime:
      pCreationTime = &FileTime;
      break;
   }

   if (GetFileTime(hFile, pCreationTime, pLastAccessTime, pLastWriteTime)) {
      // now convert the result
      dwStatus = demLFNFileTimeControl(fnFileTimeToDosDateTime |
                                          (dempUseUTCTimeByHandle(hFile) ? FTCTL_UTCTIME : 0),
                                       &FileTime,
                                       pTimeInfo);
       if (!NT_SUCCESS(dwStatus) &&
           NT_STATUS_FROM_WIN32(ERROR_INVALID_DATA) == dwStatus &&
           fnFTGetLastWriteDateTime == uFunctionCode) {
          dwStatus = STATUS_SUCCESS;
       }

   }
   else {
      dwStatus = GET_LAST_STATUS();
   }

   return(dwStatus);
}


/*
 *  This is a special wow32 - callable function for getting file time by handle
 *  from wow. We have not done any extensive checking (like in demFileTimes
 *  but rather provided for the behavior consistent with wow
 *
 *
 *
 */

ULONG demGetFileTimeByHandle_WOW(
   HANDLE hFile)
{
   LFNFILETIMEINFO fti;
   NTSTATUS Status;

   Status = dempGetFileTimeByHandle(fnFTGetLastWriteDateTime,
                                    hFile,
                                    &fti);
   if (NT_SUCCESS(Status)) {
       return (fti.uDosTime | ((ULONG)fti.uDosDate << 16));
   }

   return(0xFFFF);
}



NTSTATUS
dempSetFileTimeByHandle(
   UINT uFunctionCode,
   HANDLE hFile,
   PLFNFILETIMEINFO pTimeInfo)
{

   NTSTATUS dwStatus;
   FILETIME* pCreationTime   = NULL;
   FILETIME* pLastAccessTime = NULL;
   FILETIME* pLastWriteTime  = NULL;
   FILETIME FileTime;

   //
   // see which time we are setting and fixup parameters
   //

   switch (uFunctionCode) {
   case fnFTSetLastWriteDateTime:
      pLastWriteTime = &FileTime;
      pTimeInfo->uMilliseconds = 0; // not supported
      break;

   case fnFTSetLastAccessDateTime:
      pLastAccessTime = &FileTime;
      pTimeInfo->uMilliseconds = 0; // not supported

      // time is also not supported in this function and should be somehow
      // ignored, but Win95 resets the time to 0 every time this fn is
      // executed - we monkey
      //

      pTimeInfo->uDosTime = 0;

      break;

   case fnFTSetCreationDateTime:
      pCreationTime = &FileTime;
      break;
   }

   dwStatus = demLFNFileTimeControl(fnDosDateTimeToFileTime,
                                    &FileTime,
                                    pTimeInfo);
   if (NT_SUCCESS(dwStatus)) {
      // set the file time
      if (!SetFileTime(hFile, pCreationTime, pLastAccessTime, pLastWriteTime)) {
         dwStatus = GET_LAST_STATUS();
      }
   }

   return(dwStatus);
}


/* Function
 *    demFileTimes
 *    works for all handle-based file time apis
 *
 * Parameters
 *    None
 *
 * Returns
 *    Nothing
 *
 * Note
 *    This function is for handling real-mode cases only
 *    reason: using getXX macros instead of frame-based getUserXX macros
 *
 *
 */


VOID
demFileTimes(VOID)
{
   UINT uFunctionCode;
   LFNFILETIMEINFO TimeInfo;
   NTSTATUS dwStatus = STATUS_SUCCESS;
   PVOID pUserEnvironment;
   PDOSSFT pSFT = NULL;
   HANDLE hFile;

   uFunctionCode = (UINT)getAL();

   hFile = VDDRetrieveNtHandle((ULONG)NULL,    // uses current pdb
                               getBX(), // dos handle
                               (PVOID*)&pSFT,   // retrieve sft ptr
                               NULL);   // no jft pleast

   //
   // it is possible to have NULL nt handle for the particular file -
   // e.g. stdaux, stdprn devices
   //
   // We are catching only the case of bad dos handle here
   //

   if (NULL == pSFT && NULL == hFile) {
      //
      // invalid handle value here
      //
      // We know that dos handles it in the same way, so we just
      // put error code in, set carry and return
      //
      setAX((USHORT)ERROR_INVALID_HANDLE);
      setCF(1);
      return;
   }


   switch(uFunctionCode) {
   case fnFTGetCreationDateTime:
   case fnFTGetLastWriteDateTime:
   case fnFTGetLastAccessDateTime:
      if (pSFT->SFT_Flags & SFTFLAG_DEVICE_ID) {

         SYSTEMTIME stCurrentTime;
         FILETIME FileTime;

         //
         // for a local device return current time
         //

         GetSystemTime(&stCurrentTime);
         SystemTimeToFileTime(&stCurrentTime, &FileTime);
         // now make a dos file time
         dwStatus = demLFNFileTimeControl(fnFileTimeToDosDateTime,
                                          &FileTime,
                                          &TimeInfo);
      }
      else {
         dwStatus = dempGetFileTimeByHandle(uFunctionCode,
                                            hFile,
                                            &TimeInfo);
      }

      if (NT_SUCCESS(dwStatus)) {
         // set the regs
         pUserEnvironment = dempGetDosUserEnvironment();

         setUserDX(TimeInfo.uDosDate, pUserEnvironment);
         setUserCX(TimeInfo.uDosTime, pUserEnvironment);

         // if this was a creation date/time then set msecs
         if (fnGetCreationDateTime != uFunctionCode) {
            TimeInfo.uMilliseconds = 0;
         }

         // Note that this is valid only for new (LFN) functions
         // and not for the old functionality (get/set last write)
         // -- BUGBUG (what do other cases amount to on Win95)

         if (fnFTGetLastWriteDateTime != uFunctionCode) {
            setUserSI(TimeInfo.uMilliseconds, pUserEnvironment);
         }

      }
      break;

   case fnFTSetCreationDateTime:
   case fnFTSetLastWriteDateTime:
   case fnFTSetLastAccessDateTime:
      if (!(pSFT->SFT_Flags & SFTFLAG_DEVICE_ID)) {

         // if this is a local device and a request to set time
         // then as dos code does it, we just return ok
         // we set times here for all other stuff

         TimeInfo.uDosDate = getDX();
         TimeInfo.uDosTime = getCX(); // for one of those it is 0 (!!!)

         //
         // we just retrieve value that will be ignored later
         // for some of the functions
         //


         TimeInfo.uMilliseconds = getSI();

         dwStatus = dempSetFileTimeByHandle(uFunctionCode,
                                            hFile,
                                            &TimeInfo);
      }


      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
      break;
   }

   if (NT_SUCCESS(dwStatus)) {
      setCF(0);
   }
   else {

      //
      // demClientError sets cf and appropriate registers
      //

      SetLastError(WIN32_ERROR_FROM_NT_STATUS(dwStatus));
      demClientError(hFile, (CHAR)-1);
   }
}


/*
 * Open file (analogous to 6c)
 * This actually calls into CreateFile and is quite similar in
 * behaviour (with appropriate restrictions)
 *
 * uModeAndFlags
 * Combination of OPEN_* stuff
 *
 * uAttributes
 * See DEM_FILE_ATTRIBUTES_VALID
 *
 *
 *
 *
 *
 */



NTSTATUS
demLFNOpenFile(
   LPSTR  lpFileName,
   USHORT uModeAndFlags,
   USHORT uAttributes,
   USHORT uAction,
   USHORT uAliasHint, // ignored
   PUSHORT puDosHandle,
   PUSHORT puActionTaken)
{

   // convert the filename please
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING OemFileName;
   NTSTATUS dwStatus;
   DWORD dwCreateDistribution;
   DWORD dwDesiredAccess;
   DWORD dwShareMode;
   DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
   HANDLE hFile;
   USHORT uDosHandle;
   PDOSSFT   pSFT;
   BOOL   fFileExists;
   USHORT uActionTaken = ACTION_OPENED;



   // convert the filename in question

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

   RtlInitOemString(&OemFileName, lpFileName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &OemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &OemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   if (uModeAndFlags & DEM_FILE_ATTRIBUTE_VOLUME_ID) {
      // process this completely separately
      ;
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION));
   }


   // we are calling into CreateFile with it's flags
   // so find out what we are set to do first
   // as determined by MSDN
   //   FILE_CREATE   (0010h)  Creates a new file if it does not
   //                           already exist. The function fails if
   //                           the file already exists.
   //   FILE_OPEN     (0001h)  Opens the file. The function fails if
   //                           the file does not exist.
   //   FILE_TRUNCATE (0002h)  Opens the file and truncates it to zero
   //                           length (replaces the existing file).
   //                           The function fails if the file does not exist.
   //
   //   The only valid combinations are FILE_CREATE combined with FILE_OPEN
   //   or FILE_CREATE combined with FILE_TRUNCATE.

   switch(uAction & 0x0f) {
   case DEM_OPEN_ACTION_FILE_OPEN:
      if (uAction & DEM_OPEN_ACTION_FILE_CREATE) {
         dwCreateDistribution = OPEN_ALWAYS;
      }
      else {
         dwCreateDistribution = OPEN_EXISTING;
      }
      break;

   case DEM_OPEN_ACTION_FILE_TRUNCATE:
      if (uAction & DEM_OPEN_ACTION_FILE_CREATE) {
         // this is an unmappable situation
         //
         dwCreateDistribution = OPEN_ALWAYS;
         // we truncate ourselves
         // note that we need access mode to permit this !!!

      }
      else {
         dwCreateDistribution = TRUNCATE_EXISTING;
      }
      break;


   case 0:   // this is the case that could only be file_create call
      if (uAction == DEM_OPEN_ACTION_FILE_CREATE) {
         dwCreateDistribution = CREATE_NEW;
         break;
      }
      // else we fall through to the bad param return

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
      break;
   }

   // now see what sort of sharing mode we can inflict upon ourselves


   switch(uModeAndFlags & DEM_OPEN_SHARE_MASK) {
   case DEM_OPEN_SHARE_COMPATIBLE:
      // the reason we see share_delete here is to emulate compat mode
      // behaviour requiring to fail if any other (than compat) mode was
      // used to open the file

      dwShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE;
      break;

   case DEM_OPEN_SHARE_DENYREADWRITE:
      dwShareMode = 0;
      break;

   case DEM_OPEN_SHARE_DENYWRITE:
      dwShareMode = FILE_SHARE_READ;
      break;

   case DEM_OPEN_SHARE_DENYREAD:
      dwShareMode = FILE_SHARE_WRITE;
      break;

   case DEM_OPEN_SHARE_DENYNONE:
      dwShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;
      break;

   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
      break;
   }

   // now crack the access mode to fill in dwDesiredAccess

   switch(uModeAndFlags & DEM_OPEN_ACCESS_MASK) {

   case DEM_OPEN_ACCESS_READONLY:
      dwDesiredAccess = GENERIC_READ;
      break;

   case DEM_OPEN_ACCESS_WRITEONLY:
      dwDesiredAccess = GENERIC_WRITE;
      break;

   case DEM_OPEN_ACCESS_READWRITE:
      dwDesiredAccess = GENERIC_READ|GENERIC_WRITE;
      break;

   case DEM_OPEN_ACCESS_RO_NOMODLASTACCESS:
      // although this is a weird mode - we care not for the last
      // access time - proper implementation would have been to
      // provide for a last access time retrieval and reset upon
      // closing the file
      // Put a message up here and a breakpoint

      dwDesiredAccess = GENERIC_READ;
      break;


   case DEM_OPEN_ACCESS_RESERVED:
   default:
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
      break;

   }

   // and now crack the flags used -
   // fill in the flags portion of dwFlagsAndAttributes

   if ((uModeAndFlags & DEM_OPEN_FLAGS_MASK) & (~DEM_OPEN_FLAGS_VALID)) {
      dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER);
      return(dwStatus);
   }

   if (uModeAndFlags & DEM_OPEN_FLAGS_NO_BUFFERING) {
      // if unbuffered mode is used then the buffer is to be aligned on
      // a volume sector size boundary. This is not necessarily true for
      // win95 or is it ?
      dwFlagsAndAttributes |= FILE_FLAG_NO_BUFFERING;
   }

   if (uModeAndFlags & DEM_OPEN_FLAGS_COMMIT) {
      dwFlagsAndAttributes |= FILE_FLAG_WRITE_THROUGH;
   }

   if (uModeAndFlags & DEM_OPEN_FLAGS_ALIAS_HINT) {
      // print a message, ignore the hint
      ;
   }


   if (uModeAndFlags & DEM_OPEN_FLAGS_NO_COMPRESS) {
      // what the heck we do with this one ?
      ;
   }

   // set the attributes

   dwFlagsAndAttributes |= ((DWORD)uAttributes & DEM_FILE_ATTRIBUTE_SET_VALID);

   dempLFNNormalizePath(pUnicodeStaticFileName);

   // out we go
   {
       //
       // Need to create this because if we don't, any process we cause to be launched will not
       // be able to inherit handles (ie: launch FINDSTR.EXE via 21h/4bh to pipe to a file
       // ala NT Bug 199416 - bjm)
       //
       SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE  };

       hFile = CreateFileW(pUnicodeStaticFileName->Buffer,
                       dwDesiredAccess,
                       dwShareMode,
                       &sa,   /// NULL, // no security attr here
                       dwCreateDistribution,
                       dwFlagsAndAttributes,
                       NULL);
   }

   // now see what the return should be

   dwStatus = GetLastError();

   fFileExists = ERROR_ALREADY_EXISTS == dwStatus;

   if (INVALID_HANDLE_VALUE == hFile) {
      return(NT_STATUS_FROM_WIN32(dwStatus));
   }


   if (fFileExists) {
      if ((DEM_OPEN_ACTION_FILE_TRUNCATE|DEM_OPEN_ACTION_FILE_CREATE) == uAction) {
         if (FILE_TYPE_DISK == GetFileType(hFile) ) {
            // truncate the file here please
            if (!SetEndOfFile(hFile)) {
               dwStatus = GET_LAST_STATUS();
               CloseHandle(hFile);
               return (dwStatus);
            }

            uActionTaken = ACTION_REPLACED_OPENED;
         }
         else {
            uActionTaken = ACTION_CREATED_OPENED;
         }
      }
   }
   else {
      if (DEM_OPEN_ACTION_FILE_CREATE & uAction) {
         uActionTaken = ACTION_CREATED_OPENED;
      }
   }


   // now we insert the handle and allocate a dos handle
   uDosHandle = VDDAllocateDosHandle(0L, (PVOID*)&pSFT, NULL);

   if ((SHORT)uDosHandle < 0) {
      CloseHandle(hFile);
      return(NT_STATUS_FROM_WIN32((DWORD)(-(SHORT)uDosHandle)));
   }
   else {

      // we have obtained a good handle here
      // so place the nt handle into sft
      pSFT->SFT_Mode     = uModeAndFlags & 0x7f;  // up to no_inherit bit
      pSFT->SFT_Attr     = 0;                     // Not used.
      pSFT->SFT_Flags    = (uModeAndFlags & DEM_OPEN_FLAGS_NOINHERIT) ? 0x1000 : 0; // copy no_inherit bit.
      pSFT->SFT_Devptr   = (ULONG) -1;
      pSFT->SFT_NTHandle = (ULONG) hFile;

      *puActionTaken = uActionTaken;
      *puDosHandle = uDosHandle;
   }


   return(STATUS_SUCCESS);
}


NTSTATUS
demLFNDeleteFile(
   LPSTR lpFileName,
   USHORT wMustMatchAttributes,
   USHORT wSearchAttributes,
   BOOL   fUseWildCard)
{
   // this is how we deal with this rather harsh function:
   //
   HANDLE hFind;
   NTSTATUS dwStatus;
   WIN32_FIND_DATAW FindData;
   PUNICODE_STRING pUnicodeStaticFileName;
   OEM_STRING OemFileName;
   UNICODE_STRING UnicodeFileName; // for deletion

   // convert file name / pattern to uni

   pUnicodeStaticFileName = GET_STATIC_UNICODE_STRING_PTR();

   RtlInitOemString(&OemFileName, lpFileName);

   // convert oem->unicode

#ifdef ENABLE_CONDITIONAL_TRANSLATION

   dwStatus = DemSourceStringToUnicodeString(pUnicodeStaticFileName,
                                             &OemFileName,
                                             FALSE);
#else

   dwStatus = RtlOemStringToUnicodeString(pUnicodeStaticFileName,
                                          &OemFileName,
                                          FALSE);
#endif

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   // check for the deletion of a volume label - this hurts
   // BUGBUG
   dempLFNNormalizePath(pUnicodeStaticFileName);

   if (fUseWildCard) {

      // make a template for a file name by backtracking the last backslash
      LONG Index;
      BOOL fSuccess = FALSE;

      dwStatus = dempLFNFindFirstFile(&hFind,
                                      pUnicodeStaticFileName,
                                      &FindData,
                                      wMustMatchAttributes,
                                      wSearchAttributes);

      if (!NT_SUCCESS(dwStatus)) {
         return(dwStatus); // this is safe as dempLFNFindFirstFile closed the handle
      }

      // cut the filename part off
      // index is (-1) if not found or 0-based index of a char

      Index = dempStringFindLastChar(pUnicodeStaticFileName,
                                     L'\\',
                                     FALSE) + 1;


      while (NT_SUCCESS(dwStatus)) {
         // construct a filename

         RtlInitUnicodeString(&UnicodeFileName, FindData.cFileName);
         if (UnicodeFileName.Length < 3 &&
               (L'.' == UnicodeFileName.Buffer[0] &&
                   (UnicodeFileName.Length < 2 ||
                      L'.' == UnicodeFileName.Buffer[1]))) {

            // this is deletion of '.' or '..'
            ; // assert ?

         }

         pUnicodeStaticFileName->Length = (USHORT)Index;

         dwStatus = RtlAppendUnicodeStringToString(pUnicodeStaticFileName,
                                                   &UnicodeFileName);

         if (!NT_SUCCESS(dwStatus)) {
            break;
         }

         // now delete the file in question given it's not '.' or '..'
         // (although I have no idea what '95 would have done)

         if (!DeleteFileW(pUnicodeStaticFileName->Buffer)) {

            dwStatus = GET_LAST_STATUS();
            break;

         }
         else {

            fSuccess = TRUE;

         }


         dwStatus = dempLFNFindNextFile(hFind,
                                        &FindData,
                                        wMustMatchAttributes,
                                        wSearchAttributes);

      }

      FindClose(hFind);

      // note success if at least one file nuked
      if (fSuccess) {
         dwStatus = STATUS_SUCCESS;
      }
   }
   else { // wilds are not used here

      // scan for wild card chars using our fn
      LONG Index;

      Index = dempStringFindLastChar(pUnicodeStaticFileName,
                                     L'*',
                                     FALSE);
      if (Index >= 0) {
         return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
      }

      Index = dempStringFindLastChar(pUnicodeStaticFileName,
                                     L'?',
                                     FALSE);
      if (Index >= 0) {
         return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
      }

      if (DeleteFileW(pUnicodeStaticFileName->Buffer)) {
         dwStatus = STATUS_SUCCESS;
      }
      else {

         dwStatus = GET_LAST_STATUS();
      }
   }

   return(dwStatus);
}

NTSTATUS
demLFNGetFileInformationByHandle(
   USHORT wDosHandle,
   LPBY_HANDLE_FILE_INFORMATION pFileInformation)
{
   HANDLE hFile;

   hFile = VDDRetrieveNtHandle((ULONG)NULL,    // uses current pdb
                               wDosHandle,
                               NULL,    // no sft
                               NULL);   // no jft

   if (NULL == hFile) {
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_HANDLE));
   }


   if (!GetFileInformationByHandle(hFile, pFileInformation)) {
      return(GET_LAST_STATUS());
   }

   return(STATUS_SUCCESS);
}


#define BCS_SRC_WANSI   0x0
#define BCS_SRC_OEM     0x01
#define BCS_SRC_UNICODE 0x02
#define BCS_DST_WANSI   0x00
#define BCS_DST_OEM     0x10
#define BCS_DST_UNICODE 0x20



/* Function:
 *    demLFNGenerateShortFileName
 *    Produces surrogate short file name given the long file name
 *    Note, that win'95 implementation seems to be quite bogus.
 *    They do not bother to adhere to docs, and return whatever
 *    is on their mind.
 *
 *    This implementation corresponds to name-generating habits of NT
 *    thus allowing 16-bit apps seemless interaction with lfn apis
 *
 *
 */

NTSTATUS
demLFNGenerateShortFileName(
   LPSTR lpShortFileName,
   LPSTR lpLongFileName,
   USHORT wShortNameFormat,
   USHORT wCharSet)
{

   UNICODE_STRING UnicodeShortName;
   WCHAR szShortNameBuffer[13];
   OEM_STRING OemFileName;
   GENERATE_NAME_CONTEXT GenNameContext;
   LONG Index;
   DWORD dwStatus;

   PUNICODE_STRING pUnicodeLongName = GET_STATIC_UNICODE_STRING_PTR();

   // convert to unicode
   switch(wCharSet & 0x0f) {
   case BCS_SRC_WANSI: // BCS_WANSI - windows ansi
      RtlInitAnsiString(&OemFileName, lpLongFileName);
      dwStatus = RtlAnsiStringToUnicodeString(pUnicodeLongName, &OemFileName, FALSE);
      break;

   case BCS_SRC_OEM: // oem
      RtlInitOemString(&OemFileName, lpLongFileName);
      dwStatus = RtlOemStringToUnicodeString(pUnicodeLongName, &OemFileName, FALSE);
      break;

   case BCS_SRC_UNICODE: // unicode (what ?)
      // copy unicode str into our buf
      RtlInitUnicodeString(pUnicodeLongName, (PWCHAR)lpLongFileName);
      dwStatus = STATUS_SUCCESS;
      break;

   default:
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
   }

   if (!NT_SUCCESS(dwStatus)) {
      return(dwStatus);
   }


   wCharSet &= 0xf0; // filter out the dest

   dempStringInitZeroUnicode(&UnicodeShortName,
                             (BCS_DST_UNICODE == wCharSet) ?
                                 (LPWSTR)lpShortFileName :
                                 (LPWSTR)szShortNameBuffer,
                             13 * sizeof(WCHAR));

   RtlZeroMemory(&GenNameContext, sizeof(GenNameContext));

   // generate name
   RtlGenerate8dot3Name(pUnicodeLongName,
                        FALSE, // allowed ext chars ? and why not ?
                        &GenNameContext,
                        &UnicodeShortName);

   // chop off the part starting with ~

   Index = dempStringFindLastChar(&UnicodeShortName,
                                  L'~',
                                  FALSE);
   if (Index >= 0) {
      // remove ~<Number>
      //
      dempStringDeleteCharsUnicode(&UnicodeShortName,
                                   (USHORT)Index,
                                   2 * sizeof(WCHAR));
   }

   if (0 == wShortNameFormat) {
      // directory entry - 11 chars format
      // just remove the darn '.' from the name

      Index = dempStringFindLastChar(&UnicodeShortName,
                                     L'.',
                                     TRUE);
      if (Index >= 0) {
         dempStringDeleteCharsUnicode(&UnicodeShortName,
                                      (USHORT)Index,
                                      1 * sizeof(WCHAR));
      }
   }

   if (BCS_DST_UNICODE == wCharSet) { // if result is uni, we are done
      return(STATUS_SUCCESS);
   }


   OemFileName.Buffer = lpShortFileName;
   OemFileName.Length = 0;
   OemFileName.MaximumLength = 13 * sizeof(WCHAR);


   switch(wCharSet) {
   case BCS_DST_WANSI: // windows ansi
      dwStatus = RtlUnicodeStringToAnsiString(&OemFileName,
                                              &UnicodeShortName,
                                              FALSE);
      break;

   case BCS_DST_OEM: // oem
      dwStatus = RtlUnicodeStringToOemString(&OemFileName,
                                             &UnicodeShortName,
                                             FALSE);
      break;

   default:
      return(NT_STATUS_FROM_WIN32(ERROR_INVALID_PARAMETER));
   }


   return(dwStatus);
}


/*
 *    This function dispatches lfn calls
 *
 *    ATTN: All the pointers coming from 16-bit code could be unaligned!!!
 *
 *    danger: dependency on relative location of things in pdb
 *
 *
 *
 */



BOOL gfInitCDSPtr = FALSE;
VOID demInitCDSPtr(VOID);

NTSTATUS
demLFNDispatch(
   PVOID pUserEnvironment,
   BOOL  fProtectedMode,
   PUSHORT pUserAX)
{
   DWORD dwStatus;
   USHORT wUserAX;

   if (!gfInitCDSPtr) {
      demInitCDSPtr();
   }

   if (NULL == pUserEnvironment) {
      pUserEnvironment = dempGetDosUserEnvironment();
   }

   wUserAX = getUserAX(pUserEnvironment);
   *pUserAX = wUserAX; // initialize to initial value

   if (fnLFNMajorFunction == HIB(wUserAX)) {
      dempLFNLog("LFN Function: 0x%x \r\n", (DWORD)wUserAX);

      switch(LOB(wUserAX)) {
      case fnLFNFileTime:
         {
            LFNFILETIMEINFO TimeInfo;
            UINT uMinorFunction = (UINT)getUserBL(pUserEnvironment);

            switch(uMinorFunction) {
            case fnFileTimeToDosDateTime:
               dwStatus = demLFNFileTimeControl(uMinorFunction,
                                                (FILETIME*)getUserDSSI(pUserEnvironment, fProtectedMode),
                                                &TimeInfo);
               if (NT_SUCCESS(dwStatus)) {

                  // set registers
                  setUserDX(TimeInfo.uDosDate, pUserEnvironment);
                  setUserCX(TimeInfo.uDosTime, pUserEnvironment);
                  setUserBH((BYTE)TimeInfo.uMilliseconds, pUserEnvironment);
               }
               break;

            case fnDosDateTimeToFileTime:
               TimeInfo.uDosDate = (USHORT)getUserDX(pUserEnvironment);
               TimeInfo.uDosTime = (USHORT)getUserCX(pUserEnvironment);
               TimeInfo.uMilliseconds = (USHORT)getUserBH(pUserEnvironment);

               dwStatus = demLFNFileTimeControl((UINT)getBL(),
                                                (FILETIME*)getUserESDI(pUserEnvironment, fProtectedMode),
                                                &TimeInfo);
               break;
            default:
               dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
               break;
            }
         }
         break;

      case fnLFNGetVolumeInformation:
         {
            LFNVOLUMEINFO vi;

            vi.dwFSNameBufferSize = (DWORD)getUserCX(pUserEnvironment);
            vi.lpFSNameBuffer = (LPSTR)getUserESDI(pUserEnvironment, fProtectedMode);

            dwStatus = demLFNGetVolumeInformation((LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                                  &vi);
            if (NT_SUCCESS(dwStatus)) {

               setUserBX((USHORT)vi.dwFSFlags, pUserEnvironment);
               setUserCX((USHORT)vi.dwMaximumFileNameLength, pUserEnvironment);
               setUserDX((USHORT)vi.dwMaximumPathNameLength, pUserEnvironment);
            }
         }
         break;

      case fnLFNMoveFile:
         dwStatus = demLFNMoveFile((LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                   (LPSTR)getUserESDI(pUserEnvironment, fProtectedMode));
         break;

      case fnLFNGetCurrentDirectory:
         dwStatus = demLFNGetCurrentDirectory((UINT)getUserDL(pUserEnvironment), // drive no
                                              (LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode)); // ptr to buf
         break;

      case fnLFNSetCurrentDirectory:
      case fnLFNRemoveDirectory:
      case fnLFNCreateDirectory:
         dwStatus = demLFNDirectoryControl((UINT)getUserAL(pUserEnvironment),
                                           (LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode));
         break;

      case fnLFNGetPathName:

         dwStatus = demLFNGetPathName((LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode), // SourcePath
                                      (LPSTR)getUserESDI(pUserEnvironment, fProtectedMode), // Destination Path
                                      (UINT)getUserCL(pUserEnvironment),                    // minor code
                                      (BOOL)!(getUserCH(pUserEnvironment) & 0x80));            // expand subst flag

         if (NT_SUCCESS(dwStatus)) { // doc says modify ax
            *pUserAX = 0;
         }
         break;

      case fnLFNSubst:
         dwStatus = demLFNSubstControl((UINT)getUserBH(pUserEnvironment),
                                       (UINT)getUserBL(pUserEnvironment),
                                       (LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode));
         break;
      case fnLFNFindFirstFile:
         {
            USHORT wConversionCode;
            USHORT wDosHandle;
            WIN32_FIND_DATAA FindData; // used to enforce alignment
            LPWIN32_FIND_DATAA lpFindDataDest; // resulting ptr

            lpFindDataDest = (LPWIN32_FIND_DATAA)getUserESDI(pUserEnvironment,
                                                             fProtectedMode);
            ASSERT(NULL != lpFindDataDest);

            dwStatus = demLFNFindFirstFile((LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                           &FindData,
                                           (USHORT)getUserSI(pUserEnvironment), // date/time format
                                           (USHORT)getUserCH(pUserEnvironment), // must match attrs
                                           (USHORT)getUserCL(pUserEnvironment), // search attrs
                                           &wConversionCode,
                                           &wDosHandle,
                                           lpFindDataDest->cFileName,
                                           lpFindDataDest->cAlternateFileName
                                           );
            if (NT_SUCCESS(dwStatus)) {
               // now copy the data

               //
               // WARNING: THIS CODE DEPENDS ON THE LAYOUT OF THE WIN32_FIND_DATA
               // STRUCTURE IN THE ASSUMPTION THAT cFileName and CAlternateFileName
               // ARE THE VERY LAST MEMBERS OF IT!!!
               //

               RtlMoveMemory((PUCHAR)lpFindDataDest,
                             (PUCHAR)&FindData,

                             // warning -- this will move more data
                             // than we ever wanted to -- so break into pieces
                             sizeof(FindData.dwFileAttributes)+
                             sizeof(FindData.ftCreationTime)+
                             sizeof(FindData.ftLastAccessTime)+
                             sizeof(FindData.ftLastWriteTime)+
                             sizeof(FindData.nFileSizeHigh)+
                             sizeof(FindData.nFileSizeLow)+
                             sizeof(FindData.dwReserved0)+
                             sizeof(FindData.dwReserved1));

               *pUserAX = wDosHandle;
               setUserCX(wConversionCode, pUserEnvironment);
            }
         }
         break;

      case fnLFNFindNextFile:
         {
            USHORT wConversionCode;
            WIN32_FIND_DATAA FindData;
            LPWIN32_FIND_DATAA lpFindDataDest;

            lpFindDataDest = (LPWIN32_FIND_DATAA)getUserESDI(pUserEnvironment, fProtectedMode);
            ASSERT(NULL != lpFindDataDest);

            dwStatus = demLFNFindNextFile((USHORT)getUserBX(pUserEnvironment), // handle
                                          &FindData,
                                          (USHORT)getUserSI(pUserEnvironment),   // date/time format
                                          &wConversionCode,
                                          lpFindDataDest->cFileName,
                                          lpFindDataDest->cAlternateFileName
                                          );

            if (NT_SUCCESS(dwStatus)) {
               RtlMoveMemory((PUCHAR)lpFindDataDest,
                             (PUCHAR)&FindData,

                             sizeof(FindData.dwFileAttributes)+
                             sizeof(FindData.ftCreationTime)+
                             sizeof(FindData.ftLastAccessTime)+
                             sizeof(FindData.ftLastWriteTime)+
                             sizeof(FindData.nFileSizeHigh)+
                             sizeof(FindData.nFileSizeLow)+
                             sizeof(FindData.dwReserved0)+
                             sizeof(FindData.dwReserved1));

               setUserCX(wConversionCode, pUserEnvironment);
            }
         }
         break;

      case fnLFNFindClose:
         {
            dwStatus = demLFNFindClose((USHORT)getUserBX(pUserEnvironment));
         }
         break;

      case fnLFNDeleteFile:
         {
            dwStatus = demLFNDeleteFile((LPSTR) getUserDSDX(pUserEnvironment, fProtectedMode),
                                        (USHORT)getUserCH(pUserEnvironment), // must match
                                        (USHORT)getUserCL(pUserEnvironment), // search
                                        (BOOL)  getUserSI(pUserEnvironment));
         }
         break;

      case fnLFNGetSetFileAttributes:
         {
            USHORT wAction = (USHORT)getUserBL(pUserEnvironment);

            LFNFILEATTRIBUTES FileAttributes;

            RtlZeroMemory(&FileAttributes, sizeof(FileAttributes));

            switch (wAction) {
            case fnSetFileAttributes:
               FileAttributes.wFileAttributes = getUserCX(pUserEnvironment);
               break;

            case fnSetCreationDateTime:
               FileAttributes.TimeInfo.uMilliseconds = (USHORT)getUserSI(pUserEnvironment);
               // fall through

            case fnSetLastAccessDateTime:
            case fnSetLastWriteDateTime:
               FileAttributes.TimeInfo.uDosDate = (USHORT)getUserDI(pUserEnvironment);
               FileAttributes.TimeInfo.uDosTime = (USHORT)getUserCX(pUserEnvironment);
               break;
            }


            dwStatus = demLFNGetSetFileAttributes(wAction, // action
                                                  (LPSTR)getUserDSDX(pUserEnvironment, fProtectedMode),
                                                  &FileAttributes); // filename
            if (NT_SUCCESS(dwStatus)) {

               // return stuff
               switch (wAction) {
               case fnGetFileAttributes:
                  setUserCX(FileAttributes.wFileAttributes, pUserEnvironment);
                  *pUserAX = FileAttributes.wFileAttributes;
                  break;

               case fnGetCreationDateTime:
               case fnGetLastAccessDateTime:
               case fnGetLastWriteDateTime:
                  setUserSI(FileAttributes.TimeInfo.uMilliseconds, pUserEnvironment);
                  setUserCX(FileAttributes.TimeInfo.uDosTime, pUserEnvironment);
                  setUserDI(FileAttributes.TimeInfo.uDosDate, pUserEnvironment);
                  break;

               case fnGetCompressedFileSize:
                  setUserDX(HIWORD(FileAttributes.dwFileSize), pUserEnvironment);
                  *pUserAX = LOWORD(FileAttributes.dwFileSize);
                  break;
               }


            }
         }
         break;

      case fnLFNOpenFile:
         {
            USHORT uDosHandle;
            USHORT uActionTaken;


            dwStatus = demLFNOpenFile((LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode), // filename
                                      getUserBX(pUserEnvironment), // mode and flags
                                      getUserCX(pUserEnvironment), // attribs
                                      getUserDX(pUserEnvironment), // action
                                      getUserDI(pUserEnvironment), // alias hint - unused
                                      &uDosHandle,
                                      &uActionTaken);

            if (NT_SUCCESS(dwStatus)) {
               *pUserAX = uDosHandle;
               setUserCX(uActionTaken, pUserEnvironment);
            }
         }
         break;

      case fnLFNGetFileInformationByHandle:
         {
            BY_HANDLE_FILE_INFORMATION FileInfo;

            dwStatus = demLFNGetFileInformationByHandle(getUserBX(pUserEnvironment), // handle
                                                        &FileInfo);
            if (NT_SUCCESS(dwStatus)) {
               RtlMoveMemory((PUCHAR)getUserDSDX(pUserEnvironment, fProtectedMode),
                             (PUCHAR)&FileInfo,
                             sizeof(FileInfo));
            }
         }


         break;


      case fnLFNGenerateShortFileName:

         // using rtl function, off course
         dwStatus = demLFNGenerateShortFileName((LPSTR)getUserESDI(pUserEnvironment, fProtectedMode),
                                                (LPSTR)getUserDSSI(pUserEnvironment, fProtectedMode),
                                                (USHORT)getUserDH(pUserEnvironment),
                                                (USHORT)getUserDL(pUserEnvironment));
         break;


      default:
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_INVALID_FUNCTION);
         break;
      }

      // we handle here any case that sets ax to error and cf to 1 if error
      if (!NT_SUCCESS(dwStatus)) {
         *pUserAX = (USHORT)WIN32_ERROR_FROM_NT_STATUS(dwStatus);
      }
   }
   else { // this is a service call such as cleanup
      demLFNCleanup();
      dwStatus = STATUS_SUCCESS;
   }

   dempLFNLog("LFN returns: 0x%x\r\n", dwStatus);
   return(dwStatus);
}

ULONG
dempWOWLFNReturn(
   NTSTATUS dwStatus)
{
   DWORD  dwError = WIN32_ERROR_FROM_NT_STATUS(dwStatus);
   USHORT wErrorCode = (USHORT)ERROR_CODE_FROM_NT_STATUS(dwError);

   if (wErrorCode  < ERROR_WRITE_PROTECT || wErrorCode > ERROR_GEN_FAILURE &&
       wErrorCode != ERROR_WRONG_DISK) {

      // this is not hard error
      return((ULONG)wErrorCode);
   }

   return((ULONG)MAKELONG(wErrorCode, 0xFFFF));
}

VOID
demLFNEntry(VOID)
{
   NTSTATUS dwStatus;
   USHORT UserAX;

   // second parm is a ptr to the value of an ax register

   dwStatus = demLFNDispatch(NULL, FALSE, &UserAX);


   // in any case set ax
   setAX(UserAX);


   //
   // in case of a failure we do not necessarily mess with user registers
   //
   // as ax set on the user side will be over-written by dos
   if (NT_SUCCESS(dwStatus)) {
      // ok, we are ok
      setCF(0); // not the user cf
   }
   else {
      // we are in error

      setCF(1);


      // see if we need to fire int24....

      // set error code

      // set error flag
   }




}

/* Function
 *    demWOWLFNEntry
 *    The main entry point for protected-mode calls (e.g. from kernel31)
 *    It provides all the dispatching and, unlike the dos entry point,
 *    does not modify any x86 processor registers, instead, it operates
 *    on "User" Registers on the stack.
 *
 *
 * Parameters
 *    pUserEnvironment - pointer to user stack frame. Registers should be
 *                       pushed on stack according to dos (see DEMUSERFRAME)
 *
 * Returns
 *    ULONG containing error code in the low word and 0xffff in the high word
 *    if the error is "hard error" and int24 should have been generated
 *
 *    It also modifies (in case of success) registers on the user's stack
 *    and patches flags into the processor flags word on the stack
 *    No flags - no error
 *    Carry Set - error
 *    Carry & Zero set - hard error
 */



ULONG
demWOWLFNEntry(
   PVOID pUserEnvironment)
{
   NTSTATUS dwStatus;
   USHORT UserAX;
   USHORT Flags;

   // protected-mode entry

   dwStatus = demLFNDispatch(pUserEnvironment, TRUE, &UserAX);


   // now set up for return

   Flags = getUserPModeFlags(pUserEnvironment) & ~(FLG_ZERO|FLG_CARRY);

   if (NT_SUCCESS(dwStatus)) {
      //
      // this is set only when we succeed!!!
      //

      setUserAX(UserAX, pUserEnvironment);
      // success  - no flags necessary

   }
   else {
      // set carry flag ... meaning error
      Flags |= FLG_CARRY;

      // possibly set zero flag indicating hard error
      dwStatus = (NTSTATUS)dempWOWLFNReturn(dwStatus);

      if (dwStatus & 0xFFFF0000UL) { // we are harderr
         Flags |= FLG_ZERO;
      }
   }

   //
   // in any event set user flags
   //
   setUserPModeFlags(Flags, pUserEnvironment);

   return(dwStatus);
}


/////////////////////////////////////////////////////////////////////////
//
// Retrieve important dos/wow variables
//
//

#define FETCHVDMADDR(varTo, varFrom) \
{ DWORD __dwTemp; \
  __dwTemp = FETCHDWORD(varFrom); \
  varTo = (DWORD)GetVDMAddr(HIWORD(__dwTemp), LOWORD(__dwTemp)); \
}


VOID
demInitCDSPtr(VOID)
{

   DWORD dwTemp;
   PULONG pTemp;

   if (!gfInitCDSPtr) {
      gfInitCDSPtr = TRUE;
      pTemp = (PULONG)DosWowData.lpCDSFixedTable;
      dwTemp = FETCHDWORD(*pTemp);
      DosWowData.lpCDSFixedTable = (DWORD)GetVDMAddr(HIWORD(dwTemp), LOWORD(dwTemp));
   }
}

VOID
demSetDosVarLocation(VOID)
{
   PDOSWOWDATA pDosWowData;
   DWORD dwTemp;
   PULONG pTemp;

   pDosWowData = (PDOSWOWDATA)GetVDMAddr (getDS(),getSI());

   FETCHVDMADDR(DosWowData.lpCDSCount, pDosWowData->lpCDSCount);

   // the real pointer should be obtained through double-indirection
   // but we opt to do it later through deminitcdsptr
   dwTemp = FETCHDWORD(pDosWowData->lpCDSFixedTable);
   pTemp = (PULONG)GetVDMAddr(HIWORD(dwTemp), LOWORD(dwTemp));
   DosWowData.lpCDSFixedTable = (DWORD)pTemp;

   FETCHVDMADDR(DosWowData.lpCDSBuffer, pDosWowData->lpCDSBuffer);
   FETCHVDMADDR(DosWowData.lpCurDrv, pDosWowData->lpCurDrv);
   FETCHVDMADDR(DosWowData.lpCurPDB, pDosWowData->lpCurPDB);
   FETCHVDMADDR(DosWowData.lpDrvErr, pDosWowData->lpDrvErr);
   FETCHVDMADDR(DosWowData.lpExterrLocus, pDosWowData->lpExterrLocus);
   FETCHVDMADDR(DosWowData.lpSCS_ToSync, pDosWowData->lpSCS_ToSync);
   FETCHVDMADDR(DosWowData.lpSftAddr, pDosWowData->lpSftAddr);
}

///////////////////////////////////////////////////////////////////////////
//
// Initialization for this module and temp environment variables
//
//
///////////////////////////////////////////////////////////////////////////

//
// these functions could be found in cmd
//
extern VOID cmdCheckTempInit(VOID);
extern LPSTR cmdCheckTemp(LPSTR lpszzEnv);

VOID
dempCheckTempEnvironmentVariables(
VOID
)
{
   LPSTR rgszTempVars[] = { "TEMP", "TMP" };
   int i;
   DWORD len;
   DWORD EnvVarLen;
   CHAR szBuf[MAX_PATH+6];
   LPSTR pszVar;

   cmdCheckTempInit();

   // this code below depends on the fact that none of the vars listed in
   // rgszTempVars are longer than 5 chars!

   for (i = 0; i < sizeof(rgszTempVars)/sizeof(rgszTempVars[0]); ++i) {
      strcpy(szBuf, rgszTempVars[i]);
      len = strlen(szBuf);
      EnvVarLen = GetEnvironmentVariable(szBuf, szBuf+len+1, sizeof(szBuf)-6);
      if (EnvVarLen > 0 && EnvVarLen < sizeof(szBuf)-6) {
         *(szBuf+len) = '=';
         pszVar = cmdCheckTemp(szBuf);
         if (NULL != pszVar) {
            *(pszVar+len) = '\0';
            dempLFNLog("%s: substituted for %s\r\n", pszVar, pszVar+len+1);
            SetEnvironmentVariable(pszVar, pszVar+len+1);
         }
      }
   }

}


VOID
demWOWLFNInit(
   PWOWLFNINIT pLFNInit
   )
{
   DosWowUpdateTDBDir    = pLFNInit->pDosWowUpdateTDBDir;
   DosWowGetTDBDir       = pLFNInit->pDosWowGetTDBDir;
   DosWowDoDirectHDPopup = pLFNInit->pDosWowDoDirectHDPopup;


   // this api also sets temp variables to their needded values -- for ntvdm
   // process itself that is. These environment variables come to us from
   // cmd

   dempCheckTempEnvironmentVariables();
   demInitCDSPtr();
}


ULONG demWOWLFNAllocateSearchHandle(HANDLE hFind)
{
   DWORD dwStatus;
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   USHORT DosHandle = 0;

   dwStatus = dempLFNAllocateHandleEntry(&DosHandle, &pHandleEntry);
   if (NT_SUCCESS(dwStatus)) {
      pHandleEntry->hFindHandle = hFind;
      pHandleEntry->wMustMatchAttributes = 0;
      pHandleEntry->wSearchAttributes = 0;
      pHandleEntry->wProcessPDB = *pusCurrentPDB;
      return((ULONG)MAKELONG(DosHandle, 0));
   }

   // we have an error
   return((ULONG)INVALID_HANDLE_VALUE);
}

HANDLE demWOWLFNGetSearchHandle(USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);

   return(NULL == pHandleEntry ? INVALID_HANDLE_VALUE :
                                 pHandleEntry->hFindHandle);
}

BOOL demWOWLFNCloseSearchHandle(USHORT DosHandle)
{
   PLFN_SEARCH_HANDLE_ENTRY pHandleEntry;
   HANDLE hFind = INVALID_HANDLE_VALUE;

   pHandleEntry = dempLFNGetHandleEntry(DosHandle);
   if (NULL != pHandleEntry) {
      hFind = pHandleEntry->hFindHandle;
      dempLFNFreeHandleEntry(pHandleEntry);
   }

   return(FindClose(hFind));
}


#if 0

///////////////////////////////////////////////////////
//
//
// Clipboard dispatch api

typedef enum tagClipbrdFunctionNumber {
   fnIdentifyClipboard = 0x00,
   fnOpenClipboard = 0x01,
   fnEmptyClipboard = 0x02,
   fnSetClipboardData = 0x03,
   fnGetClipboardDataSize = 0x04,
   fnGetClipboardData = 0x05,
   fnInvalidFunction6 = 0x06,
   fnInvalidFunction7 = 0x07,
   fnCloseClipboard = 0x08,
   fnCompactClipboard = 0x09,
   fnGetDeviceCaps = 0x0a
}  enumClipbrdFunctionNumber;

#define CLIPBOARD_VERSION 0x0200
#define SWAPBYTES(w) \
((((USHORT)w & 0x0ff) << 8) | ((USHORT)w >> 8))

#pragma pack(1)

typedef struct tagBITMAPDOS {
   WORD  bmdType;
   WORD  bmdWidth;
   WORD  bmdHeight;
   WORD  bmdWidthBytes;
   BYTE  bmdPlanes;
   BYTE  bmdBitsPixel;
   DWORD bmdBits;
   DWORD bmdJunk;
   WORD  bmdWidthUm;
   WORD  bmdHeightUm;
}  BITMAPDOS, UNALIGNED*PBITMAPDOS;

typedef struct tagMETAFILEPICTDOS {
   WORD mfpd_mm;
   WORD mfpd_xExt;
   WORD mfpd_yExt;
}  METAFILEPICTDOS, UNALIGNED* PMETAFILEPICTDOS;

#pragma pack()


BOOL
demSetClipboardData(
   VOID
   )
{
   WORD wType = getDX();
   LONG lSize = ((ULONG)getSI() << 16) | getCX();

   if (wType == CF_METAFILEPICT || wType == CF_DSPMETAFILEPICT) {
      if (lSize < sizeof(METAFILEPICTDOS)) {
         return(FALSE);
      }


      hMeta = GlobalAlloc();
      if (NULL == hMeta) {
         return(FALSE);
      }





   }






}

BOOL dempGetClipboardDataSize(
   WORD wFormat,
   LPDWORD lpdwSize;
   )
{
   HANDLE hData;
   DWORD  dwSize = 0;

   hData = GetClipboardData(wFormat);
   if (NULL != hData) {
      switch(wFormat) {
      case CF_BITMAP:
      case CF_DSPBITMAP:
         {
            BITMAP bm;
            int sizeBM;

            sizeBM = GetObject((HGDIOBJ)hData, sizeof(bm), &bm);
            if (sizeBM > 0) {
               dwSize = bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;
               dwSize += sizeof(BITMAPDOS);
            }
         }
         break;

      case CF_METAFILEPICT:
      case CF_DSPMETAFILEPICT:
         dwSize = GlobalSize(hData);
         if (dwSize) {
            dwSize += sizeof(METAFILEPICTDOS);
         }
         break;

      default:
         dwSize = GlobalSize(hData);
         break;
      }
   }


   *lpdwSize = dwSize;
   return(0 != dwSize);
}


extern HANDLE GetConsoleWindow(VOID);

BOOL demClipbrdDispatch(
   VOID
)
{
   BOOL fHandled = TRUE;
   HWND hWndConsole;

   switch(getAL()) {
   case fnIdentifyClipboard:
      // identify call just checks for installation
      setAX(SWAPBYTES(CLIPBOARD_VERSION));
      setDX(0);
      break;

   case fnOpenClipboard:
      // open clipboard -- opens a clipboard on behalf of console app
      //
      hWndConsole = GetConsoleWindow();
      if (OpenClipboard(hWndConsole)) {
         setDX(0);
         setAX(1);
      }
      else {
         setDX(0);
         setAX(0);
      }
      break;

   case fnEmptyClipboard:
      if (EmptyClipboard()) {
         setDX(0);
         setAX(1);
      }
      else {
         setDX(0);
         setAX(0);
      }
      break;

   case fnSetClipboardData:
//      if (dempSetClipboardData()) {
//
//      }
      break;
   case fnGetClipboardDataSize:
//      if (dempGetClipboardDataSize(getDX())) {
// then we have it
//
//      }
      break;
   case fnGetClipboardData:
//      if (dempGetClipboardData( )) {
//      }
      break;
   case fnCloseClipboard:
      if (CloseClipboard()) {
         setDX(0);
         setAX(1);
      }
      else {
         setDX(0);
         setAX(0);
      }
      break;

   case fnCompactClipboard:
      // this should really mess with GlobalCompact but we don't have any
      // idea of how to handle these things. The only valid case could be
      // made for Windows apps that call this api for some reason
      // while they have a "real" GlobalCompact avaliable...

      break;
   case fnGetDeviceCaps:
      {
         HWND hWndConsole;
         HDC  hDC;
         DWORD  dwCaps = 0;
         hWndConsole = GetConsoleWindow();
         hDC = GetDC(hWndConsole);
         dwCaps = (DWORD)GetDeviceCaps(hDC, getDX());
         if (NULL != hDC) {
            ReleaseDC(hWndConsole, hDC);
         }
         setDX(HIWORD(dwCaps));
         setAX(LOWORD(dwCaps));
      }
      break;
   default:
      fHandled = FALSE;
      break;
   }


   return(fHandled);
}


#endif


BOOL demClipbrdDispatch(
   VOID
)
{
   return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demlfn.h ===
/*
 * DemLFN.H
 *
 * Include file for all the things that lfn implementation is using
 *
 * VadimB   Created  09-12-96
 *
 */


/* --------------------------------------------------------------------------

   LFN function numbers defined as enum

   -------------------------------------------------------------------------- */

typedef enum tagLFNFunctionNumber {
   fnLFNCreateDirectory = 0x39,
   fnLFNRemoveDirectory = 0x3A,
   fnLFNSetCurrentDirectory = 0x3B,
   fnLFNDeleteFile = 0x41,
   fnLFNGetSetFileAttributes= 0x43,
   fnLFNGetCurrentDirectory = 0x47,
   fnLFNFindFirstFile = 0x4e,
   fnLFNFindNextFile = 0x4f,
   fnLFNMoveFile = 0x56,
   fnLFNGetPathName = 0x60,
   fnLFNOpenFile = 0x6c,
   fnLFNGetVolumeInformation = 0xa0,
   fnLFNFindClose = 0xa1,
   fnLFNGetFileInformationByHandle = 0xa6,
   fnLFNFileTime = 0xa7,
   fnLFNGenerateShortFileName = 0xa8,
   fnLFNSubst = 0xaa
}  enumLFNFunctionNumber;

#define fnLFNMajorFunction 0x71


/* --------------------------------------------------------------------------

   Useful Macros

   -------------------------------------------------------------------------- */

// returns : count of elements in an array
#define ARRAYCOUNT(rgX) (sizeof(rgX)/sizeof(rgX[0]))

// returns : length (in characters) of a counted Unicode string
#define UNICODESTRLENGTH(pStr) ((pStr)->Length >> 1)


// returns : whether an api (like GetShortPathName) has returned count of
// characters required and failed to succeed (due to buffer being too short)
// Note that api here means win32 api, not rtl api (as return value is assumed
// be count of chars, not bytes
#define CHECK_LENGTH_RESULT_USTR(dwStatus, pUnicodeString) \
CHECK_LENGTH_RESULT(dwStatus,                              \
                    (pUnicodeString)->MaximumLength,       \
                    (pUnicodeString)->Length)


// returns : dwStatus - whether an api that returns char count
// succeeded on a call, takes string count variables instead of
// unicode string structure (see prev call)
#define CHECK_LENGTH_RESULT(dwStatus, MaximumLength, Length) \
{                                                                         \
   if (0 == dwStatus) {                                                   \
      dwStatus = GET_LAST_STATUS();                                       \
   }                                                                      \
   else {                                                                 \
      Length = (USHORT)dwStatus * sizeof(WCHAR);                          \
      if ((MaximumLength) > (Length)) {                                   \
         dwStatus = STATUS_SUCCESS;                                       \
      }                                                                   \
      else {                                                              \
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);          \
         Length = 0;                                                      \
      }                                                                   \
   }                                                                      \
}

// these 2 macros are identical to the ones above but dwStatus is assumed
// to represent a byte count rather than the char count (as in rtl apis)
#define CHECK_LENGTH_RESULT_RTL(dwStatus, MaximumLength, Length) \
{                                                                         \
   if (0 == dwStatus) {                                                   \
      dwStatus = GET_LAST_STATUS();                                       \
   }                                                                      \
   else {                                                                 \
      Length = (USHORT)dwStatus;                                          \
      if ((MaximumLength) > (Length)) {                                   \
         dwStatus = STATUS_SUCCESS;                                       \
      }                                                                   \
      else {                                                              \
         dwStatus = NT_STATUS_FROM_WIN32(ERROR_BUFFER_OVERFLOW);          \
         Length = 0;                                                      \
      }                                                                   \
   }                                                                      \
}

#define CHECK_LENGTH_RESULT_RTL_USTR(dwStatus, pUnicodeString) \
CHECK_LENGTH_RESULT_RTL(dwStatus,                              \
                        (pUnicodeString)->MaximumLength,       \
                        (pUnicodeString)->Length)



/* --------------------------------------------------------------------------

   STATUS and ERROR code macros

   -------------------------------------------------------------------------- */

// returns nt status code assembled from separate parts
// see ntstatus.h for details
#define MAKE_STATUS_CODE(Severity,Facility,ErrorCode) \
(((ULONG)Severity << 30) | ((ULONG)Facility << 16) | ((ULONG)ErrorCode))

#define ERROR_CODE_FROM_NT_STATUS(Status) \
((ULONG)Status & 0xffff)

#define FACILITY_FROM_NT_STATUS(Status) \
(((ULONG)Status >> 16) & 0x0fff)

// returns TRUE if nt status signifies error
#define IS_NT_STATUS_ERROR(Status) \
(((ULONG)Status >> 30) == STATUS_SEVERITY_ERROR)

// converts win32 error code to nt status code
#define NT_STATUS_FROM_WIN32(dwErrorCode) \
MAKE_STATUS_CODE(STATUS_SEVERITY_WARNING,FACILITY_WIN32,dwErrorCode)

// converts nt status to win32 error code
#define WIN32_ERROR_FROM_NT_STATUS(Status) \
RtlNtStatusToDosError(Status)

// returns last win32 error in nt status format
#define GET_LAST_STATUS() NT_STATUS_FROM_WIN32(GetLastError())


/* --------------------------------------------------------------------------

   String Conversion macros and functions

   -------------------------------------------------------------------------- */

//
// Macro to provide init fn for oem counted strings
//

#define RtlInitOemString(lpOemStr,lpBuf) \
RtlInitString(lpOemStr, lpBuf)

//
// defines a conversion fn from Unicode to Destination type (as accepted by the
// application (oem or ansi)
//
//

typedef NTSTATUS (*PFNUNICODESTRINGTODESTSTRING)(
   PVOID pDestString,               // counted oem/ansi string -- returned
   PUNICODE_STRING pUnicodeString,  // unicode string to convert
   BOOLEAN fAllocateDestination,    // allocate destination dynamically ?
   BOOLEAN fVerifyTranslation);     // should the translation unicode->oem/ansi be verified ?


//
// defines a conversion fn from Oem/Ansi to Unicode type (as needed by dem)
//
//

typedef NTSTATUS (*PFNSRCSTRINGTOUNICODESTRING)(
   PUNICODE_STRING pUnicodeString,  // counted unicode string -- returned
   PVOID pSrcString,                // oem or ansi string to convert
   BOOLEAN fAllocateDestination);   // allocate destination dynamically ?


//
// these two macros define apis we use for consistency across lfn support land
//

#define DemAnsiStringToUnicodeString RtlAnsiStringToUnicodeString
#define DemOemStringToUnicodeString  RtlOemStringToUnicodeString

//
// these two functions provide actual translations
// oem/ansi to unicode
//

NTSTATUS
DemUnicodeStringToAnsiString(
   PANSI_STRING pAnsiString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation);

NTSTATUS
DemUnicodeStringToOemString(
   POEM_STRING pOemString,
   PUNICODE_STRING pUnicodeString,
   BOOLEAN fAllocateResult,
   BOOLEAN fVerifyTranslation);



//
// This macro returns a pointer (in the current teb) to a unicode string,
// we are using this buffer for unicode/ansi/oem translations
// be careful with inter-function passing of this buffer
// Many Win32's Ansi apis use this buffer as a translation buffer
//
#define GET_STATIC_UNICODE_STRING_PTR() \
(&NtCurrentTeb()->StaticUnicodeString)


/* --------------------------------------------------------------------------

   DOS and Windows call frame definition
   These macros allow for access to the User's registers, that is
   registers which the calling application receives after dos returns

   -------------------------------------------------------------------------- */



/*
 *  See dossym.inc for more details (if any)
 *  These values represent offsets from user stack top
 *  during the system call (again, as defined in dossym.inc)
 *
 *  The stack layout is formed by dos and mimicked by kernel in windows
 *
 */


#pragma pack(1)

// macro: used to declare a named word size register
//

#define DECLARE_WORDREG(Name) \
union { \
   USHORT User_ ## Name ## X; \
   struct { \
      UCHAR User_ ## Name ## L; \
      UCHAR User_ ## Name ## H; \
   }; \
}

typedef struct tagUserFrame {

   DECLARE_WORDREG(A); // ax 0x00
   DECLARE_WORDREG(B); // bx 0x02
   DECLARE_WORDREG(C); // cx 0x04
   DECLARE_WORDREG(D); // dx 0x06

   USHORT User_SI; // si 0x8
   USHORT User_DI; // di 0xa
   USHORT User_BP; // bp 0xc
   USHORT User_DS; // ds 0xe
   USHORT User_ES; // es 0x10
   union {
      USHORT User_IP; // ip 0x12 -- Real Mode IP
      USHORT User_ProtMode_F; // prot-mode Flags (see i21entry.asm)
   };

   USHORT User_CS; // cs 0x14 -- this is Real Mode CS!
   USHORT User_F;  // f  0x16 -- this is Real Mode Flags!!!

} DEMUSERFRAME;

typedef DEMUSERFRAME UNALIGNED *PDEMUSERFRAME;

#pragma pack()


// macro: retrieve flat ptr given separate segment/offset and prot mode
//        flag
//

#define dempGetVDMPtr(Segment, Offset, fProtMode) \
Sim32GetVDMPointer((ULONG)MAKELONG(Offset, Segment), 0, (UCHAR)fProtMode)


/*
 * Macros to set misc registers on user's stack -
 * this is equivalent to what dos kernel does with regular calls
 *
 * remember that ax is set according to the call result
 * (and then dos takes care of it)
 *
 */


#define getUserDSSI(pUserEnv, fProtMode) \
dempGetVDMPtr(getUserDS(pUserEnv), getUserSI(pUserEnv), fProtMode)

#define getUserDSDX(pUserEnv, fProtMode) \
dempGetVDMPtr(getUserDS(pUserEnv), getUserDX(pUserEnv), fProtMode)

#define getUserESDI(pUserEnv, fProtMode) \
dempGetVDMPtr(getUserES(pUserEnv), getUserDI(pUserEnv), fProtMode)

#define setUserReg(pUserEnv, Reg, Value) \
( ((PDEMUSERFRAME)pUserEnv)->User_ ## Reg = Value )

#define getUserReg(pUserEnv, Reg) \
(((PDEMUSERFRAME)pUserEnv)->User_ ## Reg)

#define getUserAX(pUserEnv) getUserReg(pUserEnv,AX)
#define getUserBX(pUserEnv) getUserReg(pUserEnv,BX)
#define getUserCX(pUserEnv) getUserReg(pUserEnv,CX)
#define getUserDX(pUserEnv) getUserReg(pUserEnv,DX)
#define getUserSI(pUserEnv) getUserReg(pUserEnv,SI)
#define getUserDI(pUserEnv) getUserReg(pUserEnv,DI)
#define getUserES(pUserEnv) getUserReg(pUserEnv,ES)
#define getUserDS(pUserEnv) getUserReg(pUserEnv,DS)

#define getUserAL(pUserEnv) getUserReg(pUserEnv,AL)
#define getUserAH(pUserEnv) getUserReg(pUserEnv,AH)
#define getUserBL(pUserEnv) getUserReg(pUserEnv,BL)
#define getUserBH(pUserEnv) getUserReg(pUserEnv,BH)
#define getUserCL(pUserEnv) getUserReg(pUserEnv,CL)
#define getUserCH(pUserEnv) getUserReg(pUserEnv,CH)
#define getUserDL(pUserEnv) getUserReg(pUserEnv,DL)
#define getUserDH(pUserEnv) getUserReg(pUserEnv,DH)

#define setUserAX(Value, pUserEnv) setUserReg(pUserEnv, AX, Value)
#define setUserBX(Value, pUserEnv) setUserReg(pUserEnv, BX, Value)
#define setUserCX(Value, pUserEnv) setUserReg(pUserEnv, CX, Value)
#define setUserDX(Value, pUserEnv) setUserReg(pUserEnv, DX, Value)
#define setUserSI(Value, pUserEnv) setUserReg(pUserEnv, SI, Value)
#define setUserDI(Value, pUserEnv) setUserReg(pUserEnv, DI, Value)

#define setUserAL(Value, pUserEnv) setUserReg(pUserEnv, AL, Value)
#define setUserAH(Value, pUserEnv) setUserReg(pUserEnv, AH, Value)
#define setUserBL(Value, pUserEnv) setUserReg(pUserEnv, BL, Value)
#define setUserBH(Value, pUserEnv) setUserReg(pUserEnv, BH, Value)
#define setUserCL(Value, pUserEnv) setUserReg(pUserEnv, CL, Value)
#define setUserCH(Value, pUserEnv) setUserReg(pUserEnv, CH, Value)
#define setUserDL(Value, pUserEnv) setUserReg(pUserEnv, DL, Value)
#define setUserDH(Value, pUserEnv) setUserReg(pUserEnv, DH, Value)


//
// These macros are supposed to be used ONLY when being called from
// protected mode Windows (i.e. krnl386 supplies proper stack)
//

#define getUserPModeFlags(pUserEnv) getUserReg(pUserEnv, ProtMode_F)
#define setUserPModeFlags(Value, pUserEnv) setUserReg(pUserEnv, ProtMode_F, Value)


/* --------------------------------------------------------------------------

   Volume information definitions
   as they apply to a GetVolumeInformation api

   -------------------------------------------------------------------------- */

typedef struct tagLFNVolumeInformation {
   DWORD dwFSNameBufferSize;
   LPSTR lpFSNameBuffer;
   DWORD dwMaximumFileNameLength;
   DWORD dwMaximumPathNameLength;
   DWORD dwFSFlags;
}  LFNVOLUMEINFO, *PLFNVOLUMEINFO, *LPLFNVOLUMEINFO;


//
// defines a flag that indicates LFN api support on a volume
//
#define FS_LFN_APIS 0x00004000UL

//
// allowed lfn volume flags
//

#define LFN_FS_ALLOWED_FLAGS \
(FS_CASE_IS_PRESERVED | FS_CASE_SENSITIVE | \
 FS_UNICODE_STORED_ON_DISK | FS_VOL_IS_COMPRESSED | \
 FS_LFN_APIS)


/* --------------------------------------------------------------------------

   File Time /Dos time conversion definitions

   -------------------------------------------------------------------------- */

//
// minor code to use in demLFNFileTimeControl
//

typedef enum tagFileTimeControlMinorCode {

   fnFileTimeToDosDateTime = 0,
   fnDosDateTimeToFileTime = 1

}  enumFileTimeControlMinorCode;

// this constant masks enumFileTimeControlMinorCode values
//
#define FTCTL_CODEMASK (UINT)0x000F

// this flag tells file time control to use UTC time in conversion
//
#define FTCTL_UTCTIME  (UINT)0x0010

//
// structure that is used in time conversion calls in demlfn.c
//

typedef struct tagLFNFileTimeInfo {
   USHORT uDosDate;
   USHORT uDosTime;
   USHORT uMilliseconds; // spill-over

}  LFNFILETIMEINFO, *PLFNFILETIMEINFO, *LPLFNFILETIMEINFO;


//
// These functions determine whether the target file's time should not be
// converted to local time -- such as files from the cdrom
//
BOOL dempUseUTCTimeByHandle(HANDLE hFile);
BOOL dempUseUTCTimeByName(PUNICODE_STRING pFileName);


/* --------------------------------------------------------------------------

   Get/Set File attributes definitions

   -------------------------------------------------------------------------- */


typedef enum tagGetSetFileAttributesMinorCode {
   fnGetFileAttributes     = 0,
   fnSetFileAttributes     = 1,
   fnGetCompressedFileSize = 2,
   fnSetLastWriteDateTime  = 3,
   fnGetLastWriteDateTime  = 4,
   fnSetLastAccessDateTime = 5,
   fnGetLastAccessDateTime = 6,
   fnSetCreationDateTime   = 7,
   fnGetCreationDateTime   = 8
}  enumGetSetFileAttributesMinorCode;

typedef union tagLFNFileAttributes {

   USHORT wFileAttributes;   // file attrs
   LFNFILETIMEINFO TimeInfo; // for date/time
   DWORD  dwFileSize;        // for compressed file size

}  LFNFILEATTRIBUTES, *PLFNFILEATTRIBUTES;

/* --------------------------------------------------------------------------

   Get/Set File Time (by handle) definitions - fn 57h
   handled by demFileTimes

   -------------------------------------------------------------------------- */

//
// flag in SFT indicating that entry references a device (com1:, lpt1:, etc)
//

#define SFTFLAG_DEVICE_ID 0x0080

//
// Minor code for file time requests
//

typedef enum tagFileTimeMinorCode {
   fnFTGetLastWriteDateTime  = 0x00,
   fnFTSetLastWriteDateTime  = 0x01,
   fnFTGetLastAccessDateTime = 0x04,
   fnFTSetLastAccessDateTime = 0x05,
   fnFTGetCreationDateTime   = 0x06,
   fnFTSetCreationDateTime   = 0x07
}  enumFileTimeMinorCode;


/* --------------------------------------------------------------------------

   Open File (function 716ch) definitions
   largely equivalent to handling fn 6ch

   -------------------------------------------------------------------------- */

//
// Access flags
//

#define DEM_OPEN_ACCESS_READONLY  0x0000
#define DEM_OPEN_ACCESS_WRITEONLY 0x0001
#define DEM_OPEN_ACCESS_READWRITE 0x0002
#define DEM_OPEN_ACCESS_RESERVED  0x0003

// Not supported
#define DEM_OPEN_ACCESS_RO_NOMODLASTACCESS 0x0004

#define DEM_OPEN_ACCESS_MASK      0x000F

//
// Share flags
//

#define DEM_OPEN_SHARE_COMPATIBLE    0x0000
#define DEM_OPEN_SHARE_DENYREADWRITE 0x0010
#define DEM_OPEN_SHARE_DENYWRITE     0x0020
#define DEM_OPEN_SHARE_DENYREAD      0x0030
#define DEM_OPEN_SHARE_DENYNONE      0x0040
#define DEM_OPEN_SHARE_MASK          0x0070

//
// Open flags
//

#define DEM_OPEN_FLAGS_NOINHERIT     0x0080
#define DEM_OPEN_FLAGS_NO_BUFFERING  0x0100
#define DEM_OPEN_FLAGS_NO_COMPRESS   0x0200

// Not supported
#define DEM_OPEN_FLAGS_ALIAS_HINT    0x0400

#define DEM_OPEN_FLAGS_NOCRITERR     0x2000
#define DEM_OPEN_FLAGS_COMMIT        0x4000
#define DEM_OPEN_FLAGS_VALID         \
(DEM_OPEN_FLAGS_NOINHERIT    | DEM_OPEN_FLAGS_NO_BUFFERING | \
 DEM_OPEN_FLAGS_NO_COMPRESS  | DEM_OPEN_FLAGS_ALIAS_HINT   | \
 DEM_OPEN_FLAGS_NOCRITERR    | DEM_OPEN_FLAGS_COMMIT)
#define DEM_OPEN_FLAGS_MASK          0xFF00

//
// Action flags
//

// DEM_OPEN_FUNCTION_FILE_CREATE combines with action_file_open or
// action_file_truncate flags

#define DEM_OPEN_ACTION_FILE_CREATE       0x0010
#define DEM_OPEN_ACTION_FILE_OPEN         0x0001
#define DEM_OPEN_ACTION_FILE_TRUNCATE     0x0002

//
// resulting action (returned to the app)
//

#define ACTION_OPENED            0x0001
#define ACTION_CREATED_OPENED    0x0002
#define ACTION_REPLACED_OPENED   0x0003


/* --------------------------------------------------------------------------

   Additional file attribute definitions

   -------------------------------------------------------------------------- */

// Volume id attribute

#define DEM_FILE_ATTRIBUTE_VOLUME_ID 0x00000008L

//
// Valid file attributes mask as understood by dos
//

#define DEM_FILE_ATTRIBUTE_VALID  \
(FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN| \
 FILE_ATTRIBUTE_SYSTEM  | FILE_ATTRIBUTE_DIRECTORY | \
 FILE_ATTRIBUTE_ARCHIVE | DEM_FILE_ATTRIBUTE_VOLUME_ID)

//
// Valid to set attributes
//

#define DEM_FILE_ATTRIBUTE_SET_VALID  \
(FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN| \
 FILE_ATTRIBUTE_SYSTEM  | FILE_ATTRIBUTE_ARCHIVE)

/* --------------------------------------------------------------------------

   FindFirst/FindNext definitions

   -------------------------------------------------------------------------- */

//
// Definition for the handle table entries
// Handle (which is returned to the app) references this entry
// providing all the relevant info for FindFirst/FindNext
//

typedef struct tagLFNFindHandleTableEntry {
   union {
      HANDLE hFindHandle; // handle for searching
      UINT   nNextFreeEntry;
   };

   USHORT wMustMatchAttributes;
   USHORT wSearchAttributes;

   UNICODE_STRING unicodeFileName; // counted file name string,
                                   // only used if matched a vol label

   // process id, aka pdb requesting this handle
   // or 0xffff if the entry is empty
   USHORT wProcessPDB;

}  LFN_SEARCH_HANDLE_ENTRY, *PLFN_SEARCH_HANDLE_ENTRY;

//
// Definition of a handle table
// Table is dynamic and it expands/shrinks as necessary
//

typedef struct tagFindHandleTable {

   PLFN_SEARCH_HANDLE_ENTRY pHandleTable;
   UINT nTableSize;           // total size in entries
   UINT nFreeEntry;           // free list head
   UINT nHandleCount;         // handles stored (bottom)
}  DemSearchHandleTable;

//
// Definitions of a constants used in managing handle table
//

// initial table size
#define LFN_SEARCH_HANDLE_INITIAL_SIZE 0x20

// handle table growth increment
#define LFN_SEARCH_HANDLE_INCREMENT    0x10

// used to mark a last free list entry
#define LFN_SEARCH_HANDLE_LIST_END     ((UINT)-1)

//
// Application receives handles in format
// LFN_DOS_HANDLE_MASK + (index to the handle table)
// so that it looks legit to the app
//

#define LFN_DOS_HANDLE_MASK ((USHORT)0x4000)

// max number of search handles we can support

#define LFN_DOS_HANDLE_LIMIT ((USHORT)0x3FFF)

//
// Date/Time format as returned in WIN32_FIND_DATAA structure
//

typedef enum tagLFNDateTimeFormat {
   dtfWin32 = 0, // win32 file time/date format
   dtfDos   = 1  // dos date time format
}  enumLFNDateTimeFormat;



/* --------------------------------------------------------------------------

   GetPathName definitions

   -------------------------------------------------------------------------- */

//
// minor code for the fn 7160h
//

typedef enum tagFullPathNameMinorCode {
   fnGetFullPathName  = 0,
   fnGetShortPathName = 1,
   fnGetLongPathName  = 2
} enumFullPathNameMinorCode;


/* --------------------------------------------------------------------------

   Subst function definitions

   -------------------------------------------------------------------------- */


//
// minor code for the fn 71aah
// used in demLFNSubstControl
//

typedef enum tagSubstMinorCode {
   fnCreateSubst = 0,
   fnRemoveSubst = 1,
   fnQuerySubst  = 2
}  enumSubstMinorCode;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demmsg.h ===
/* demmsg.h - debug message numbers for DEM
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 */


#define MSG_DEFAULTDOS		0
#define MSG_PARTIALREAD 	1
#define MSG_OPENFAILED		2
#define MSG_EAS 		3
#define MSG_DEFAULT_DRIVE	4
#define MSG_VOLID		5
#define MSG_TIMEDATE		6
#define MSG_INVALID_HFIND	7
#define MSG_FILEINFO		8
#define MSG_FILESIZE_TOOBIG	9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demmisc.c ===
/*  demmisc.c - Misc. SVC routines
 *
 *  demLoadDos
 *
 *  Modification History:
 *
 *  Sudeepb 31-Mar-1991 Created
 */

#include "dem.h"
#include "demmsg.h"
// #include "demdasd.h"

#include <stdio.h>
#include <string.h>
#include <softpc.h>
#include <mvdm.h>
#include <dbgsvc.h>
#include <nt_vdd.h>


#if DEVL
// int 21h func names
// index off of function number in ah
char *scname[] = {
     "Terminate Program",
     "Read Kbd with Echo",
     "Display Character",
     "Auxillary Input",
     "Auxillary Output",
     "Print Character",
     "Direct Con Output",
     "Direct Con Input",
     "Read Kbd without Echo",
     "Display String",
     "Read String",
     "Check Keyboard Status",
     "Flush Buffer,Read Kbd",
     "Reset Drive",
     "Set Default Drive",
     "FCB Open",
     "FCB Close",
     "FCB Find First",
     "FCB Find Next",
     "FCB Delete",
     "FCB Seq Read",
     "FCB Seq Write",
     "FCB Create",
     "FCB Rename",
     "18h??",
     "Get Default Drive",
     "Set Disk Transfer Addr",
     "Get Default Drive Data",
     "Get Drive Data",
     "1Dh??",
     "1Eh??",
     "Get Default DPB",
     "20h??",
     "FCB Random Read",
     "FCB Random Write",
     "FCB Get File Size",
     "FCB Set Random Record",
     "Set Interrupt Vector",
     "Create Process Data Block",
     "FCB Random Read Block",
     "FCB Random Write Block",
     "FCB Parse File Name",
     "Get Date",
     "Set Date",
     "Get Time",
     "Set Time",
     "SetReset Write Verify",
     "Get Disk Transefr Addr",
     "Get Version Number",
     "Keep Process",
     "Get Drive Parameters",
     "GetSet CTRL C",
     "Get InDOS Flag",
     "Get Interrupt Vector",
     "Get Disk Free Space",
     "Char Oper",
     "GetSet Country Info",
     "Make Dir",
     "Remove Dir",
     "Change DirDir",
     "Create File",
     "Open File",
     "Close File",
     "Read File",
     "Write File",
     "Delete File",
     "Move File Ptr",
     "GetSet File Attr",
     "IOCTL",
     "Dup File Handle",
     "Force Dup Handle",
     "Get Current Dir",
     "Alloc Mem",
     "Free Mem",
     "Realloc Mem",
     "Exec Process",
     "Exit Process",
     "Get Child Process Exit Code",
     "Find First",
     "Find Next",
     "Set Current PSP",
     "Get Current PSP",
     "Get In Vars",
     "Set DPB",
     "Get Verify On Write",
     "Dup PDB",
     "Rename File",
     "GetSet File Date and Time",
     "Allocation Strategy",
     "Get Extended Error",
     "Create Temp File",
     "Create New File",
     "LockUnlock File",
     "SetExtendedErrorNetwork-ServerCall",
     "Network-UserOper",
     "Network-AssignOper",
     "xNameTrans",
     "PathParse",
     "GetCurrentPSP",
     "ECS CALL",
     "Set Printer Flag",
     "Extended Country Info",
     "GetSet CodePage",
     "Set Max Handle",
     "Commit File",
     "GetSetMediaID",
     "6ah??",
     "IFS IOCTL",
     "Extended OpenCreate",
     "6d??",
     "6e??",
     "6f??",
     "70??",
     "LFN API"
     };
#endif

extern BOOL IsFirstCall;

extern void nt_floppy_release_lock(void);

LPSTR pszBIOSDirectory;

// internal func prototype
BOOL IsDebuggee(void);
void SignalSegmentNotice(WORD  wType,
                         WORD  wModuleSeg,
                         WORD  wLoadSeg,
                         WORD  wNewSeg,
                         LPSTR lpName,
                         DWORD dwImageLen );

#if defined(NEC_98)
BYTE DemBreakFunc = 0xff;
#endif // NEC_98

/* demLoadDos - Load NTDOS.SYS.
 *
 * This SVC is made by NTIO.SYS to load NTDOS.SYS.
 *
 * Entry - Client (DI) - Load Segment
 *
 * Exit  - SUCCESS returns
 *         FAILURE Kills the VDM
 */
VOID demLoadDos (VOID)
{
PBYTE   pbLoadAddr;
HANDLE  hfile;
DWORD   BytesRead;
#ifdef FE_SB
LANGID  LcId = GetSystemDefaultLangID();
#endif //FE_SB

    // get linear address where ntdos.sys will be loaded
    pbLoadAddr = (PBYTE) GetVDMAddr(getDI(),0);

    // set up BIOS path string
    if(DbgIsDebuggee() &&
       ((pszBIOSDirectory = (PCHAR)malloc (strlen (pszDefaultDOSDirectory) +
                                  1 + sizeof(NTIO_409) + sizeof(NTIO_411) + 1 )) != NULL)) {
        strcpy (pszBIOSDirectory, pszDefaultDOSDirectory);
#ifdef FE_SB
        switch (LcId) {
            case MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT):
                strcat (pszBIOSDirectory,NTIO_411);
                break;
            case MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT):
                strcat (pszBIOSDirectory,NTIO_412);
                break;
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL):
                strcat (pszBIOSDirectory,NTIO_404);
                break;
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED):
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_HONGKONG):
                strcat (pszBIOSDirectory,NTIO_804);
                break;
            default:
                strcat (pszBIOSDirectory,NTIO_409);
                break;
        }
#else
        strcat (pszBIOSDirectory,"\\ntio.sys");
#endif
    }

    // prepare the dos file name
#ifdef FE_SB
    switch (LcId)
    {
    case MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT):
        strcat (pszDefaultDOSDirectory,NTDOS_411);
        break;
    case MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT):
        strcat (pszDefaultDOSDirectory,NTDOS_412);
        break;
    case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL):
        strcat (pszDefaultDOSDirectory,NTDOS_404);
        break;
    case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED):
    case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_HONGKONG):
        strcat (pszDefaultDOSDirectory,NTDOS_804);
        break;
    default:
        strcat (pszDefaultDOSDirectory,NTDOS_409);
        break;
    }
#else
    strcat (pszDefaultDOSDirectory,"\\ntdos.sys");
#endif

    hfile = CreateFileOem(pszDefaultDOSDirectory,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );

    if (hfile == (HANDLE)0xffffffff) {
        TerminateVDM();
    }

    BytesRead = 1;
    while (BytesRead) {
        if (!ReadFile(hfile, pbLoadAddr, 16384, &BytesRead, NULL)) {
            TerminateVDM();
        }
        pbLoadAddr = (PBYTE)((ULONG)pbLoadAddr + BytesRead);

    }

    CloseHandle (hfile);

    if (!DbgIsDebuggee()) {
        free(pszDefaultDOSDirectory);
    }
    return;
}


/* demDOSDispCall
 *
 * This SVC is made by System_Call upon entering the dos
 *
 *
 * Entry: Client registers as per user app upon entry to dos
 *
 * Exit  - SUCCESS returns, if being debugged and DEMDOSDISP&fShowSvcMsg
 *                          dumps user app's registers and service name
 */
VOID demDOSDispCall(VOID)
{
#if DEVL
   WORD ax;

    if (!DbgIsDebuggee()) {
         return;
         }
    if (fShowSVCMsg & DEMDOSDISP) {
        ax = getAX();
        sprintf(demDebugBuffer,"demDosDispCall %s\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
                 scname[HIBYTE(ax)],
                 ax,getBX(),getCX(),getDX(),getDI(), getSI());

        OutputDebugStringOem(demDebugBuffer);

        sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x\n",
                 getCS(),getIP(), getDS(),getES(),getSS(),getSP()+2,getBP());

        OutputDebugStringOem(demDebugBuffer);
        }
#if defined(NEC_98)
    if ((fShowSVCMsg & DEMDOSAPPBREAK) && (DemBreakFunc != 0xff))
        if (getAH() == DemBreakFunc)
            DebugBreak();

    if (fShowSVCMsg & 0x01) {
        sprintf(demDebugBuffer,"Int 21 AX=%04x BX=%04x CX=%04x DX=%04x SP=%04x BP=%04x SI=%04x DI=%04x\n",getAX(),getBX(),getCX(),getDX(),getSP(),getBP(),getSI(),getDI());        // NEC
        OutputDebugStringOem(demDebugBuffer);
    }
#endif // NEC_98
#endif
}




/* demDOSDispRet
 *
 * This SVC is made by System_Call upon exiting from the dos
 *
 * Entry: Client registers as per user app upon exit to dos
 *
 * Exit  - SUCCESS returns, if being debugged and DEMDOSDISP&fShowSvcMsg
 *                          dumps user app's registers
 */
VOID demDOSDispRet(VOID)
{
#if DEVL
   PWORD16 pStk;

   if (!DbgIsDebuggee()) {
        return;
        }

   if (fShowSVCMsg & DEMDOSDISP) {

         // get ptr to flag word on stack
       pStk = (WORD *)GetVDMAddr(getSS(), getSP());
       pStk += 2;

       sprintf (demDebugBuffer,"demDosDispRet\n\tAX=%.4x BX=%.4x CX=%.4x DX=%.4x DI=%.4x SI=%.4x\n",
                getAX(),getBX(),getCX(),getDX(),getDI(),getSI());

       OutputDebugStringOem(demDebugBuffer);

       sprintf(demDebugBuffer,"\tCS=%.4x IP=%.4x DS=%.4x ES=%.4x SS=%.4x SP=%.4x BP=%.4x CF=%.1x\n",
               getCS(),getIP(), getDS(),getES(),getSS(),getSP(),getBP(), (*pStk) & 1);

       OutputDebugStringOem(demDebugBuffer);
       }
#endif
}


/* demEntryDosApp - Dump Entry Point Dos Apps
 *
 * This SVC is made by NTDOS.SYS,$exec just prior to entering dos app
 *
 * Entry - Client DS:SI points to entry point
 *         Client AX:DI points to initial stack
 *         Client DX has PDB pointer
 *
 * Exit  - SUCCESS returns, if being debugged and DEMDOSAPPBREAK&fShowSvcMsg
 *                          breaks to debugger
 */
VOID demEntryDosApp(VOID)
{
USHORT  PDB;

    PDB = getDX();
    if(!IsFirstCall)
       VDDCreateUserHook(PDB);

    if (!DbgIsDebuggee()) {
         return;
         }

    DbgDosAppStart(getDS(), getSI());

#if DEVL
    if (fShowSVCMsg & DEMDOSAPPBREAK) {
        sprintf(demDebugBuffer,"demEntryDosApp: Entry=%.4x:%.4x, Stk=%.4x:%.4x PDB=%.4x\n",
                  getCS(),getIP(),getAX(),getDI(),PDB);
        OutputDebugStringOem(demDebugBuffer);
        DebugBreak();
        }
#endif

}

/* demLoadDosAppSym - Load Dos Apps Symbols
 *
 * This SVC is made by NTDOS.SYS,$exec to load Dos App symbols
 *
 * Entry - Client ES:DI  -Fully Qualified Path Name of executable
 *         Client BX     -Load Segment\Reloc Factor
 *         Client DX:AX  -HIWORD:LOWORD exe size
 *
 * Exit  - SUCCESS returns, raises debug exception, if being debugged
 *
 */
VOID demLoadDosAppSym(VOID)
{

    SignalSegmentNotice(DBG_MODLOAD,
                        0, getBX(), 0,
                        (LPSTR)GetVDMAddr(getES(),getDI()),
                        MAKELONG(getAX(), getDX()) );

}



/* demFreeDosAppSym - Free Dos Apps Symbols
 *
 * This SVC is made by NTDOS.SYS,$exec to Free Dos App symbols
 *
 * Entry - Client ES:DI  -Fully Qualified Path Name of executable
 *
 * Exit  - SUCCESS returns, raises debug exception, if being debugged
 *
 */
VOID demFreeDosAppSym(VOID)
{

    SignalSegmentNotice(DBG_MODFREE,
                        0, 0, 0,
                        (LPSTR)GetVDMAddr(getES(), getDI()),
                        0);
}


/* demSystemSymbolOp - Manipulate Symbols for special modules
 *
 * This SVC is made by NTDOS.SYS,NTIO.SYS
 *
 *         Client AH     -Operation
 *         Client AL     -module identifier
 *         Client BX     -Load Segment\Reloc Factor
 *         Client CX:DX  -HIWORD:LOWORD exe size
 *
 * Exit  - SUCCESS returns, raises debug exception, if being debugged
 *
 */
VOID demSystemSymbolOp(VOID)
{

    LPSTR pszPathName;

    if (!DbgIsDebuggee()) {
         return;
         }
    switch(getAL()) {

        case ID_NTIO:
            pszPathName = pszBIOSDirectory;
            break;
        case ID_NTDOS:
            pszPathName = pszDefaultDOSDirectory;
            break;
        default:
            pszPathName = NULL;

    }

    // check this again for the case where the static strings have been freed
    if (pszPathName != NULL) {

        switch(getAH() & (255-SYMOP_CLEANUP)) {

            case SYMOP_LOAD:
                SignalSegmentNotice(DBG_MODLOAD,
                    0, getBX(), 0,
                    pszPathName,
                    MAKELONG(getDX(), getCX()) );
                break;

            case SYMOP_FREE:
                //bugbug not implemented yet
                break;

            case SYMOP_MOVE:
                SignalSegmentNotice(DBG_SEGMOVE,
                    getDI(), getBX(), getES(),
                    pszPathName,
                    MAKELONG(getDX(), getCX()) );
                break;
        }
    }

    if (getAH() & SYMOP_CLEANUP) {

        if (pszBIOSDirectory != NULL) {
            free (pszBIOSDirectory);
        }

        if (pszDefaultDOSDirectory != NULL) {
            free(pszDefaultDOSDirectory);
        }

    }

}

VOID demOutputString(VOID)
{
    LPSTR   lpText;
    UCHAR   fPE;

    if ( !DbgIsDebuggee() ) {
        return;
    }

    fPE = ISPESET;

    lpText = (LPSTR)Sim32GetVDMPointer(
                        ((ULONG)getDS() << 16) + (ULONG)getSI(),
                        (ULONG)getBX(), fPE );

    OutputDebugStringOem( lpText );
}

VOID demInputString(VOID)
{
    LPSTR   lpText;
    UCHAR   fPE;

    if ( !DbgIsDebuggee() ) {
        return;
    }

    fPE = ISPESET;

    lpText = (LPSTR)Sim32GetVDMPointer(
                        ((ULONG)getDS() << 16) + (ULONG)getDI(),
                        (ULONG)getBX(), fPE );

    DbgPrompt( "", lpText, 0x80 );
}

/* SignalSegmentNotice
 *
 * packs up the data and raises STATUS_SEGMENT_NOTIFICATION
 *
 * Entry - WORD  wType     - DBG_MODLOAD, DBG_MODFREE
 *         WORD  wModuleSeg- segment number within module (1 based)
 *         WORD  wLoadSeg  - Starting Segment (reloc factor)
 *         LPSTR lpName    - ptr to Name of Image
 *         DWORD dwModLen  - Length of module
 *
 *
 *         if wType ==DBG_MODLOAD wOldLoadSeg is unused
 *         if wType ==DBG_MODFREE wLoadSeg,dwImageLen,wOldLoadSeg are unused
 *
 *         Use 0 or NULL for unused parameters
 *
 * Exit  - void
 *
 */
void SignalSegmentNotice(WORD  wType,
                         WORD  wModuleSeg,
                         WORD  wLoadSeg,
                         WORD  wNewSeg,
                         LPSTR lpName,
                         DWORD dwImageLen )
{
    int         i;
    DWORD       dw;
    LPSTR       lpstr;
    LPSTR       lpModuleName;
    char        ach[MAX_PATH+9];   // 9 for module name

    if (!DbgIsDebuggee()) {
         return;
         }

       // create file name
    dw = GetFullPathNameOem(lpName,
                         sizeof(ach)-9, // 9 for module name
                         ach,
                         &lpstr);

    if (!dw || dw >= sizeof(ach))  {
        lpName = " ";
        strcpy(ach, lpName);
        }
    else {
        lpName = lpstr;
        }

       // copy in module name
    i  = 8;   // limit len of module name
    dw = strlen(ach);
    lpModuleName = lpstr = ach+dw+1;
    while (*lpName && *lpName != '.' && i--)
         {
          *lpstr++ = *lpName++;
          dw++;
          }
    *lpstr = '\0';
    dw += 2;

#if DBG
    if (fShowSVCMsg)  {
        sprintf(demDebugBuffer,"dem Segment Notify: <%s> Seg=%lxh, ImageLen=%ld\n",
                  ach, (DWORD)wLoadSeg, dwImageLen);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    // Send it to the debugger
    DbgSegmentNotice(wType, wModuleSeg, wLoadSeg, wNewSeg, lpModuleName, ach, dwImageLen);
}


/* demIsDebug - Determine if 16bit DOS should make entry/exit calls at int21
 *
 * Entry: void
 *
 * Exit:  Client AL = 0 if not
 *        Client AL = 1 if yes
 *
 */
VOID demIsDebug(void)
{
    BYTE dbgflags = 0;

    if (DbgIsDebuggee()) {
        dbgflags |= ISDBG_DEBUGGEE;
        if (fShowSVCMsg)
            dbgflags |= ISDBG_SHOWSVC;
    }

    setAL (dbgflags);
    return;
}

/* demDiskReset - Reset floppy disks.
 *
 * Entry - None
 *
 * Exit  - FDAccess in DOSDATA (NTDOS.SYS) is 0.
 */

VOID demDiskReset (VOID)
{
    extern WORD * pFDAccess;        // defined in SoftPC.

    HostFloppyReset();
    HostFdiskReset();
    *pFDAccess = 0;

    return;
}

/* demExitVDM - Kill the VDM From 16Bit side with a proper message
 *              in case something goes wrong.
 *
 * Entry - DS:SI - Message String
 *
 * Exit  - None (VDM Is killed)
 */

VOID demExitVDM ( VOID )
{
    RcErrorDialogBox(ED_BADSYSFILE,"config.nt",NULL);
    TerminateVDM ();
}

/* demWOWFiles - Return what should be the value of files= for WOW VDM.
 *
 * Entry - AL - files= specified in config.sys
 *
 * Exit  - client AL is set to max if WOW VDM else unmodified
 */

VOID demWOWFiles ( VOID )
{
    if(VDMForWOW)
        setAL (255);
    return;
}

/** GetDOSAppName - Return the name of the current DOS executable
 *
 *  ENTRY -
 *      OUT ppszApp Name: address of the app
 *
 *  EXIT
 *      SUCCESS - Returns SUCCESS
 *      FAILURE - Returns FAILURE
 *
 * Comments:
 *  This routine uses the current PDB to figure out the name of the currently
 *  executing DOS application.
 */

VOID GetDOSAppName(LPSTR pszAppName)
{
    PCHAR pch = NULL;
    PUSHORT pusEnvSeg;

#define PDB_ENV_OFFSET 0x2c
    if (pusCurrentPDB) {
        pusEnvSeg = (PUSHORT)Sim32GetVDMPointer((*pusCurrentPDB) << 16, 0, 0);

        pusEnvSeg = (PUSHORT)((PCHAR)pusEnvSeg + PDB_ENV_OFFSET);

        // Get a pointer to the environment
        if (VDMForWOW || (getMSW() & MSW_PE)) {
            pch = (PCHAR)Sim32GetVDMPointer(*pusEnvSeg << 16, 1, TRUE);
        } else {
            pch = (PCHAR)Sim32GetVDMPointer(*pusEnvSeg << 16, 0, 0);
        }
    }

    if (NULL == pch) {
       *pszAppName = '\0';
    }
    else {
        // Walk through the environment strings until we get to the command line
       while (*pch) {
           pch += strlen(pch) + 1;
       }

       pch += 3;          // skip past the double null and string count
       strcpy(pszAppName, pch);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demlock.c ===
/* demlock.c - SVC handler for file file locking calls
 *
 * demLockOper
 *
 * Modification History:
 *
 * Sudeepb 07-Aug-1992 Created
 */

#include "dem.h"
#include "demmsg.h"

#include <softpc.h>

/* demLockOper - Lock or Unlock the file data
 *
 * Entry    Client(AX) : Lock = 0 Unlock = 1
 *	    Client(BX:BP) : NT Handle
 *	    Client(CX:DX) : offset in the file
 *	    Client(SI:DI) : Data Length to be locked
 * Exit
 *	    SUCCESS: Client CF = 0
 *	    FAILURE: Client CF = 1
 */

VOID demLockOper (VOID)
{
HANDLE	hFile;
DWORD	dwFileOffset,cbLock;

    // Collect all the parameters
    hFile = GETHANDLE(getBX(),getBP());
    dwFileOffset = GETULONG (getCX(),getDX());
    cbLock = GETULONG (getSI(),getDI());

    if(getAL() == 0){  // Locking case
	if (LockFile (hFile,
		      dwFileOffset,
		      0,
		      cbLock,
		      0
		     ) == TRUE) {
	    setCF (0);
	    return;
	}
    }
    else {
	if (UnlockFile (hFile,
			dwFileOffset,
			0,
			cbLock,
			0
		       ) == TRUE) {
	    setCF (0);
	    return;
	}
    }

    // Operation failed
    demClientError(hFile, (CHAR)-1);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demsrch.c ===
/* demsrch.c - SVC handlers for calls to search files
 *
 * demFindFirst
 * demFindNext
 * demFindFirstFCB
 * demFindNextFCB
 *
 * Modification History:
 *
 * Sudeepb 06-Apr-1991 Created
 *
 */

#include "dem.h"
#include "demmsg.h"
#include "winbasep.h"
#include <vdm.h>
#include <softpc.h>
#include <mvdm.h>
#include <memory.h>
#include <nt_vdd.h>

extern BOOL IsFirstCall;



/*
 *  Internal globals, function prototypes
 */

#define FINDFILE_DEVICE (HANDLE)0xffffffff

typedef struct _PSP_FILEFINDLIST {
    LIST_ENTRY PspFFindEntry;      // Next psp
    LIST_ENTRY FFindHeadList;      // File Find list for this psp
    ULONG      usPsp;              // PSP id
} PSP_FFINDLIST, *PPSP_FFINDLIST;

typedef struct _FFINDDOSDATA {
    ULONG    FileIndex;
    ULONG    FileNameLength;
    WCHAR    FileName[MAXIMUM_FILENAME_LENGTH + 1];
    FILETIME ftLastWriteTime;
    DWORD    dwFileSizeLow;
    UCHAR    uchFileAttributes;
    CHAR     cFileName[14];
} FFINDDOSDATA, *PFFINDDOSDATA;

typedef struct _FILEFINDLIST {
    LIST_ENTRY     FFindEntry;
    ULONG          FFindId;
    NTSTATUS       LastQueryStatus;
    LARGE_INTEGER  FindFileTics;
    HANDLE         DirectoryHandle;
    PVOID          FindBufferBase;
    PVOID          FindBufferNext;
    ULONG          FindBufferLength;
    FFINDDOSDATA   DosData;
    USHORT         usSrchAttr;
    BOOLEAN        SupportReset;
    UNICODE_STRING PathName;
    UNICODE_STRING FileName;
    BOOL           SearchOnCD;
}FFINDLIST, *PFFINDLIST;

LIST_ENTRY PspFFindHeadList= {&PspFFindHeadList, &PspFFindHeadList};


#define FFINDID_BASE 0x80000000
ULONG NextFFindId = FFINDID_BASE;
BOOLEAN FFindIdWrap = FALSE;
#define MAX_DIRECTORYHANDLE 64
#define MAX_FINDBUFFER 128
ULONG NumDirectoryHandle = 0;
ULONG NumFindBuffer=0;
LARGE_INTEGER FindFileTics = {0,0};
LARGE_INTEGER NextFindFileTics = {0,0};

char szStartDotStar[]="????????.???";


PFFINDLIST
SearchFile(
    PWCHAR pwcFile,
    USHORT SearchAttr,
    PFFINDLIST pFFindEntry,
    PFFINDDOSDATA pFFindDDOut
    );


NTSTATUS
FileFindNext(
    PFFINDDOSDATA pFFindDD,
    PFFINDLIST pFFindEntry
    );

NTSTATUS
FileFindLast(
    PFFINDLIST pFFindEntry
    );

VOID
FileFindClose(
    PFFINDLIST pFFindEntry
    );


NTSTATUS
FileFindOpen(
    PWCHAR pwcFile,
    PFFINDLIST pFFindEntry,
    ULONG BufferSize
    );

NTSTATUS
FileFindReset(
   PFFINDLIST pFFindEntry
   );


HANDLE
FileFindFirstDevice(
    PWCHAR FileName,
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo
    );

void
CloseOldestFileFindBuffer(
   void
   );


BOOL
CopyDirInfoToDosData(
    HANDLE DirectoryHandle,
    PFFINDDOSDATA pFFindDD,
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo,
    USHORT SearchAttr
    );

BOOL
DemOemToUni(
    PUNICODE_STRING pUnicode,
    LPSTR lpstr
    );

VOID
FillFcbVolume(
    PSRCHBUF pSrchBuf,
    CHAR *pFileName,
    USHORT SearchAttr
    );

BOOL
FillDtaVolume(
    CHAR *pFileName,
    PSRCHDTA  pDta,
    USHORT SearchAttr
    );

BOOL
MatchVolLabel(
    CHAR * pVolLabel,
    CHAR * pBaseName
    );

VOID
NtVolumeNameToDosVolumeName(
    CHAR * pDosName,
    CHAR * pNtName
    );

VOID
FillFCBSrchBuf(
     PFFINDDOSDATA pFFindDD,
     PSRCHBUF pSrchBuf,
     BOOL     IsOnCD
     );

VOID
FillSrchDta(
     PFFINDDOSDATA pFFindDD,
     PSRCHDTA pDta,
     BOOL     IsOnCD
     );

PFFINDLIST
AddFFindEntry(
     PWCHAR     pwcFile,
     PFFINDLIST pFFindEntrySrc
     );

PPSP_FFINDLIST
GetPspFFindList(
     USHORT CurrPsp
     );

PFFINDLIST
GetFFindEntryByFindId(
     ULONG NextFFindId
     );

VOID
FreeFFindEntry(
     PFFINDLIST pFFindEntry
     );

VOID
FreeFFindList(
     PLIST_ENTRY pFFindHeadList
     );

#if defined(NEC_98)
// BUG fix for DBCS small alphabet converted to large it.
void demCharUpper(char *);
#endif // NEC_98

/* demFindFirst - Path-Style Find First File
 *
 * Entry -  Client (DS:DX) - File Path with wildcard
 *      Client (CX)    - Search Attributes
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      DTA updated
 *
 *     Failure
 *      Client (CF) = 1
 *      Client (AX) = Error Code
 *
 * NOTES
 *    Search Rules: Ignore Read_only and Archive bits.
 *          If CX == ATTR_NORMAL Search only for normal files
 *          If CX == ATTR_HIDDEN Search Hidden or normal files
 *          If CX == ATTR_SYSTEM Search System or normal files
 *          If CX == ATTR_DIRECTORY Search directory or normal files
 *                  If CX == ATTR_VOLUME_ID Search Volume_ID
 *                  if CX == -1 return everytiing you find
 *
 *   Limitations - 21-Sep-1992 Jonle
 *     cannot return label from a UNC name,just like dos.
 *     Apps which keep many find handles open can cause
 *     serious trouble, we must rewrite so that we can
 *     close the handles
 *
 */

VOID demFindFirst (VOID)
{
    DWORD dwRet;
    PVOID pDta;
#ifdef DBCS /* demFindFirst() for CSNW */
    CHAR  achPath[MAX_PATH];
#endif /* DBCS */


    LPSTR lpFile = (LPSTR) GetVDMAddr (getDS(),getDX());

    pDta = (PVOID) GetVDMAddr (*((PUSHORT)pulDTALocation + 1),
                               *((PUSHORT)pulDTALocation));
#ifdef DBCS /* demFindFirst() for CSNW */
    /*
     * convert Netware path to Dos path
     */
    ConvNwPathToDosPath(achPath,lpFile);
    lpFile = achPath;
#endif /* DBCS */
    dwRet = demFileFindFirst (pDta, lpFile, getCX());

    if (dwRet == -1) {
        dwRet = GetLastError();
        demClientError(INVALID_HANDLE_VALUE, *lpFile);
        return;
    }

    if (dwRet != 0) {
        setAX((USHORT) dwRet);
        setCF (1);
    } else {
        setCF (0);
    }
    return;

}


DWORD demFileFindFirst (
    PVOID pvDTA,
    LPSTR lpFile,
    USHORT SearchAttr)
{
    PSRCHDTA       pDta = (PSRCHDTA)pvDTA;
    PFFINDLIST     pFFindEntry;
    FFINDDOSDATA   FFindDD;
    UNICODE_STRING FileUni;
    WCHAR          wcFile[MAX_PATH + sizeof(WCHAR)];
    BOOL           IsOnCD;


#if DBG
    if (SIZEOF_DOSSRCHDTA != sizeof(SRCHDTA)) {
        sprintf(demDebugBuffer,
                "demsrch: FFirst SIZEOF_DOSSRCHDTA %ld != sizeof(SRCHDTA) %ld\n",
                SIZEOF_DOSSRCHDTA,
                sizeof(SRCHDTA));
        OutputDebugStringOem(demDebugBuffer);
        }

    if (fShowSVCMsg & DEMFILIO){
        sprintf(demDebugBuffer,"demsrch: FindFirst<%s>\n", lpFile);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    STOREDWORD(pDta->FFindId,0);
    STOREDWORD(pDta->pFFindEntry,0);

    FileUni.Buffer = wcFile;
    FileUni.MaximumLength = sizeof(wcFile);
    DemOemToUni(&FileUni, lpFile);

    IsOnCD = IsCdRomFile(lpFile);

    //
    //  Do volume label first.
    //
    if (SearchAttr & ATTR_VOLUME_ID) {
        if (FillDtaVolume(lpFile, pDta, SearchAttr)) {

            // got vol label match
            // do look ahead before returning
            if (SearchAttr != ATTR_VOLUME_ID) {
                pFFindEntry = SearchFile(wcFile, SearchAttr, NULL, NULL);
                if (pFFindEntry) {
                    pFFindEntry->SearchOnCD = IsOnCD;
                    STOREDWORD(pDta->pFFindEntry,pFFindEntry);
                    STOREDWORD(pDta->FFindId,pFFindEntry->FFindId);
                    }
                }
            return 0;
            }

           // no vol match, if asking for more than vol label
           // fall thru to file search code, otherwise ret error
        else if (SearchAttr == ATTR_VOLUME_ID) {
            return GetLastError();
            }
        }

    //
    // Search the dir
    //
    pFFindEntry = SearchFile(wcFile, SearchAttr, NULL, &FFindDD);

    if (!FFindDD.cFileName[0]) {

        // search.asm in doskrnl never returns ERROR_FILE_NOT_FOUND
        // only ERROR_PATH_NOT_FOUND, ERROR_NO_MORE_FILES
        DWORD dw;

        dw = GetLastError();
        if (dw == ERROR_FILE_NOT_FOUND) {
            SetLastError(ERROR_NO_MORE_FILES);
            }
        else if (dw == ERROR_BAD_PATHNAME || dw == ERROR_DIRECTORY ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return (DWORD)-1;
        }


    FillSrchDta(&FFindDD, pDta, IsOnCD);

    if (pFFindEntry) {
        pFFindEntry->SearchOnCD = IsOnCD;
        STOREDWORD(pDta->pFFindEntry,pFFindEntry);
        STOREDWORD(pDta->FFindId,pFFindEntry->FFindId);
        }

    return 0;
}


/*
 * DemOemToUni
 *
 * returns TRUE\FALSE for success, sets last error if fail
 *
 */
BOOL DemOemToUni(PUNICODE_STRING pUnicode, LPSTR lpstr)
{
    NTSTATUS   Status;
    OEM_STRING OemString;

    RtlInitString(&OemString,lpstr);
    Status = RtlOemStringToUnicodeString(pUnicode,&OemString,FALSE);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            SetLastError(RtlNtStatusToDosError(Status));
            }
        return FALSE;
        }

    *(PWCHAR)((PUCHAR)pUnicode->Buffer + pUnicode->Length) = UNICODE_NULL;

    return TRUE;
}





/* demFindNext - Path-Style Find Next File
 *
 * Entry -  None
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      DTA updated
 *
 *     Failure
 *      Client (CF) = 1
 *      Client (AX) = Error Code
 */
VOID demFindNext (VOID)
{
    DWORD dwRet;
    PVOID pDta;

    pDta = (PVOID) GetVDMAddr(*((PUSHORT)pulDTALocation + 1),
                              *((PUSHORT)pulDTALocation));

    dwRet = demFileFindNext (pDta);

    if (dwRet != 0) {
        setAX((USHORT) dwRet);
        setCF (1);
        return;
        }

    setCF (0);
    return;

}


DWORD demFileFindNext (
    PVOID pvDta)
{
    PSRCHDTA pDta = (PSRCHDTA)pvDta;
    USHORT   SearchAttr;
    PFFINDLIST   pFFindEntry;
    FFINDDOSDATA FFindDD;
    BOOL    IsOnCD;

    pFFindEntry = GetFFindEntryByFindId(FETCHDWORD(pDta->FFindId));
    if (!pFFindEntry ||
        FETCHDWORD(pDta->pFFindEntry) != (DWORD)pFFindEntry )
      {
        STOREDWORD(pDta->FFindId,0);
        STOREDWORD(pDta->pFFindEntry,0);

        // DOS has only one error (no_more_files) for all causes.
        return(ERROR_NO_MORE_FILES);
        }

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "demFileFindNext<%ws>\n", pFFindEntry->PathName.Buffer);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    SearchAttr = pFFindEntry->usSrchAttr;

    IsOnCD = pFFindEntry->SearchOnCD;
    //
    // Search the dir
    //
    pFFindEntry = SearchFile(NULL,
                             SearchAttr,
                             pFFindEntry,
                             &FFindDD
                             );

    if (!FFindDD.cFileName[0]) {
        STOREDWORD(pDta->FFindId,0);
        STOREDWORD(pDta->pFFindEntry,0);
        return GetLastError();
        }

    FillSrchDta(&FFindDD, pDta, IsOnCD);

    if (!pFFindEntry) {
        STOREDWORD(pDta->FFindId,0);
        STOREDWORD(pDta->pFFindEntry,0);
        }
     return 0;
}



/* demFindFirstFCB - FCB based Find First file
 *
 * Entry -  Client (DS:SI) - SRCHBUF where the information will be returned
 *      Client (ES:DI) - Full path file name with possibly wild cards
 *      Client (Al)    - 0 if not an extended FCB
 *      Client (DL)    - Search Attributes
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      SRCHBUF is filled in
 *
 *     Failure
 *      Client (AL) = -1
 *
 * NOTES
 *    Search Rules: Ignore Read_only and Archive bits.
 *          If DL == ATTR_NORMAL Search only for normal files
 *          If DL == ATTR_HIDDEN Search Hidden or normal files
 *          If DL == ATTR_SYSTEM Search System or normal files
 *          If DL == ATTR_DIRECTORY Search directory or normal files
 *          If DL == ATTR_VOLUME_ID Search only Volume_ID
 *          if DL == -1 return everytiing you find
 */

VOID demFindFirstFCB (VOID)
{
    LPSTR   lpFile;
    USHORT  SearchAttr;
    PSRCHBUF        pFCBSrchBuf;
    PDIRENT         pDirEnt;
    PFFINDLIST      pFFindEntry;
    FFINDDOSDATA    FFindDD;
    UNICODE_STRING  FileUni;
    WCHAR           wcFile[MAX_PATH];
    BOOL            IsOnCD;


    lpFile = (LPSTR) GetVDMAddr (getES(),getDI());

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "demFindFirstFCB<%s>\n", lpFile);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    pFCBSrchBuf = (PSRCHBUF) GetVDMAddr (getDS(),getSI());
    pDirEnt = &pFCBSrchBuf->DirEnt;

    STOREDWORD(pDirEnt->pFFindEntry,0);
    STOREDWORD(pDirEnt->FFindId,0);


    if (getDL() == ATTR_VOLUME_ID) {
        FillFcbVolume(pFCBSrchBuf,lpFile, ATTR_VOLUME_ID);
        return;
        }


    FileUni.Buffer = wcFile;
    FileUni.MaximumLength = sizeof(wcFile);
    if (!DemOemToUni(&FileUni ,lpFile)) {
         setCF(1);
         return;
         }

    SearchAttr = getAL() ? getDL() : 0;
    pFFindEntry = SearchFile(wcFile, SearchAttr, NULL, &FFindDD);
    if (!FFindDD.cFileName[0]){
        demClientError(INVALID_HANDLE_VALUE, *lpFile);
        return;
        }

    IsOnCD = IsCdRomFile(lpFile);
    FillFCBSrchBuf(&FFindDD, pFCBSrchBuf, IsOnCD);

    if (pFFindEntry) {
        pFFindEntry->SearchOnCD = IsOnCD;
        STOREDWORD(pDirEnt->pFFindEntry,pFFindEntry);
        STOREDWORD(pDirEnt->FFindId,pFFindEntry->FFindId);
        }

    setCF(0);
    return;
}



/* demFindNextFCB - FCB based Find Next file
 *
 * Entry -  Client (DS:SI) - SRCHBUF where the information will be returned
 *      Client (Al)    - 0 if not an extended FCB
 *      Client (DL)    - Search Attributes
 *
 * Exit  - Success
 *      Client (CF) = 0
 *      SRCHBUF is filled in
 *
 *     Failure
 *      Client (AL) = -1
 *
 * NOTES
 *    Search Rules: Ignore Read_only and Archive bits.
 *          If DL == ATTR_NORMAL Search only for normal files
 *          If DL == ATTR_HIDDEN Search Hidden or normal files
 *          If DL == ATTR_SYSTEM Search System or normal files
 *          If DL == ATTR_DIRECTORY Search directory or normal files
 *          If DL == ATTR_VOLUME_ID Search only Volume_ID
 */

VOID demFindNextFCB (VOID)
{
    USHORT          SearchAttr;
    PSRCHBUF        pSrchBuf;
    PDIRENT         pDirEnt;
    PFFINDLIST      pFFindEntry;
    FFINDDOSDATA    FFindDD;
    BOOL         IsOnCD;


    pSrchBuf = (PSRCHBUF) GetVDMAddr (getDS(),getSI());
    pDirEnt  = &pSrchBuf->DirEnt;

    pFFindEntry = GetFFindEntryByFindId(FETCHDWORD(pDirEnt->FFindId));
    if (!pFFindEntry ||
        FETCHDWORD(pDirEnt->pFFindEntry) != (DWORD)pFFindEntry ||
        getDL() == ATTR_VOLUME_ID )
      {
        if (pFFindEntry &&
            FETCHDWORD(pDirEnt->pFFindEntry) != (DWORD)pFFindEntry)
          {
            FreeFFindEntry(pFFindEntry);
            }

        STOREDWORD(pDirEnt->pFFindEntry,0);
        STOREDWORD(pDirEnt->FFindId,0);

        // DOS has only one error (no_more_files) for all causes.
        setAX(ERROR_NO_MORE_FILES);
        setCF(1);
        return;
        }

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "demFindNextFCB<%ws>\n", pFFindEntry->PathName.Buffer);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    SearchAttr = getAL() ? getDL() : 0;

    IsOnCD = pFFindEntry->SearchOnCD;
    //
    // Search the dir
    //
    pFFindEntry = SearchFile(NULL,
                             SearchAttr,
                             pFFindEntry,
                             &FFindDD
                             );

    if (!FFindDD.cFileName[0]) {
        STOREDWORD(pDirEnt->pFFindEntry,0);
        STOREDWORD(pDirEnt->FFindId,0);
        setAX((USHORT) GetLastError());
        setCF(1);
        return;
        }

    FillFCBSrchBuf(&FFindDD, pSrchBuf,IsOnCD);

    if (!pFFindEntry) {
        STOREDWORD(pDirEnt->FFindId,0);
        STOREDWORD(pDirEnt->pFFindEntry,0);
        }

    setCF(0);
    return;
}



/* demTerminatePDB - PDB Terminate Notification
 *
 * Entry -  Client (BX) - Terminating PDB
 *
 * Exit  -  None
 *
 */

VOID demTerminatePDB (VOID)
{
    PPSP_FFINDLIST pPspFFindEntry;
    USHORT     PSP;

    PSP = getBX ();

    if(!IsFirstCall)
        VDDTerminateUserHook(PSP);
    /* let host knows a process is terminating */

    HostTerminatePDB(PSP);

    pPspFFindEntry = GetPspFFindList(PSP);
    if (!pPspFFindEntry)
         return;

    if (!IsListEmpty(&pPspFFindEntry->FFindHeadList)) {
        FreeFFindList( &pPspFFindEntry->FFindHeadList);
        }

    RemoveEntryList(&pPspFFindEntry->PspFFindEntry);
    free(pPspFFindEntry);

    return;
}


/* SearchFile - Common routine for FIND_FRST and FIND_NEXT
 *
 * Entry -
 * PCHAR  pwcFile              file name to search for
 * USHORT SearchAttr           file attributes to match
 * PFFINDLIST pFFindEntry,     current list entry
 *                             if new search FFindId is expected to be zero
 * PFFINDDOSDATA pFFindDDOut,  filled with the next file in search
 *
 * Exit - if no more files pFFindDDOut is filled with zeros
 *        returns PFFINDLIST if buffered entries exist, else NULL
 */
PFFINDLIST
SearchFile(
    PWCHAR pwcFile,
    USHORT SearchAttr,
    PFFINDLIST pFFindEntry,
    PFFINDDOSDATA pFFindDDOut)
{
    NTSTATUS Status;
    ULONG    BufferSize;
    FFINDLIST  FFindEntry;
    PFFINDLIST pFFEntry = NULL;


    SearchAttr &= ~(ATTR_READ_ONLY | ATTR_ARCHIVE | ATTR_DEVICE);
    Status = STATUS_NO_MORE_FILES;

    if (pFFindDDOut) {
        memset(pFFindDDOut, 0, sizeof(FFINDDOSDATA));
        }

    try {
       if (pFFindEntry) {
           pFFEntry = pFFindEntry;
           Status = pFFindEntry->LastQueryStatus;

           if (pFFindDDOut) {
               *pFFindDDOut = pFFEntry->DosData;
               pFFEntry->DosData.cFileName[0] = '\0';
               }
           else {
               return pFFEntry;
               }

           if (pFFEntry->FindBufferNext || pFFEntry->DirectoryHandle) {
               NTSTATUS st;

               st = FileFindNext(&pFFEntry->DosData,
                                 pFFEntry
                                 );

               if (NT_SUCCESS(st)) {
                   return pFFEntry;
                   }

               if (pFFEntry->DirectoryHandle) {
                   Status = st;
                   }
               }

              //
              // Check Last Known Status before retrying
              //
           if (!NT_SUCCESS(Status)) {
               return NULL;
               }


              //
              // Reopen the FileFind Handle with a large buffer size
              //
           Status = FileFindOpen(NULL,
                                 pFFEntry,
                                 4096
                                 );
           if (!NT_SUCCESS(Status)) {
               return NULL;
               }

              //
              // reset the search to the last known search pos
              //
           Status = FileFindReset(pFFEntry);
           if (!NT_SUCCESS(Status)) {
               return NULL;
               }
           }
       else {
           pFFEntry = &FFindEntry;
           memset(pFFEntry, 0, sizeof(FFINDLIST));
           pFFEntry->SupportReset = TRUE;
           pFFEntry->usSrchAttr = SearchAttr;


           Status = FileFindOpen(pwcFile,
                                 pFFEntry,
                                 1024
                                 );

           if (!NT_SUCCESS(Status)) {
               return NULL;
               }

           //
           // Fill up pFFindDDOut
           //
           if (pFFindDDOut) {
               Status = FileFindNext(pFFindDDOut, pFFEntry);
               if (!NT_SUCCESS(Status)) {
                   return NULL;
                   }
               }
           }

        //
        // Fill up pFFEntry->DosData
        //
        Status = FileFindNext(&pFFEntry->DosData, pFFEntry);
        if (!NT_SUCCESS(Status)) {
            return NULL;
            }


       //
       // if findfirst, fill in the static entries, and add the find entry
       //
       if (!pFFindEntry) {
           pFFEntry->FFindId = NextFFindId++;
           if (NextFFindId == 0xffffffff) {
               NextFFindId = FFINDID_BASE;
               FFindIdWrap = TRUE;
               }

           if (FFindIdWrap) {
               pFFindEntry = GetFFindEntryByFindId(NextFFindId);
               if (pFFindEntry) {
                   FreeFFindEntry(pFFindEntry);
                   pFFindEntry = NULL;
                   }
               }

           pFFEntry = AddFFindEntry(pwcFile, pFFEntry);
           if (!pFFEntry) {
               pFFEntry = &FFindEntry;
               pFFEntry->DosData.cFileName[0] = '\0';
               Status = STATUS_NO_MEMORY;
               return NULL;
               }
           }


       //
       // Try to fill one more entry. If the NtQuery for this search
       // is complete we can set the LastQueryStatus, and close dir handles.
       //
       Status = FileFindLast(pFFEntry);


       }
    finally {

       if (pFFEntry) {

           pFFEntry->LastQueryStatus = Status;

               //
               // if nothing is buffered, cleanup look aheads
               //
           if (!pFFEntry->DosData.cFileName[0] ||
                pFFEntry->DirectoryHandle == FINDFILE_DEVICE)
              {
               if (pFFEntry == &FFindEntry) {
                   FileFindClose(pFFEntry);
                   RtlFreeUnicodeString(&pFFEntry->FileName);
                   RtlFreeUnicodeString(&pFFEntry->PathName);
                   }
               else {
                   FreeFFindEntry(pFFEntry);
                   }
               SetLastError(RtlNtStatusToDosError(Status));
               pFFEntry = NULL;
               }
           }



       if (pFFEntry) {

           if (pFFEntry->DirectoryHandle) {
               if (!pFFindEntry || !NT_SUCCESS(pFFEntry->LastQueryStatus)) {
                   NumDirectoryHandle--;
                   NtClose(pFFEntry->DirectoryHandle);
                   pFFEntry->DirectoryHandle = 0;
                   }
               }

           if (NumFindBuffer > MAX_FINDBUFFER ||
               NumDirectoryHandle > MAX_DIRECTORYHANDLE)
             {
               CloseOldestFileFindBuffer();
               }

           //
           // Set HeartBeat timer to close find buffers, directory handle
           //   Tics  = 8(min) * 60(sec/min) * 18(tic/sec)
           //
           pFFEntry->FindFileTics.QuadPart = 8640 + FindFileTics.QuadPart;
           if (!FindFileTics.QuadPart) {
                NextFindFileTics.QuadPart = pFFEntry->FindFileTics.QuadPart;
                }
           }


       }

     return pFFEntry;
}



NTSTATUS
FileFindOpen(
    PWCHAR pwcFile,
    PFFINDLIST pFFindEntry,
    ULONG BufferSize
    )
{
    NTSTATUS Status;
    BOOLEAN bStatus;
    BOOLEAN bReturnSingleEntry;
    PWCHAR  pwc;
    OBJECT_ATTRIBUTES Obja;
    PUNICODE_STRING FileName;
    PUNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;


    Status = STATUS_SUCCESS;
    PathName = &pFFindEntry->PathName;
    FileName = &pFFindEntry->FileName;

    try {

         if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
             Status = STATUS_NO_MORE_FILES;
             goto FFOFinallyExit;
             }


         if (BufferSize <=  sizeof(FILE_BOTH_DIR_INFORMATION) +
                            MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR))
           {
             Status = STATUS_BUFFER_TOO_SMALL;
             goto FFOFinallyExit;
             }



         if (pwcFile) {
             bStatus = RtlDosPathNameToNtPathName_U(pwcFile,
                                                    PathName,
                                                    &pwc,
                                                    NULL
                                                    );

             if (!bStatus ) {
                 Status = STATUS_OBJECT_PATH_NOT_FOUND;
                 goto FFOFinallyExit;
                 }

             //
             // Copy out the PathName, FileName
             //
             if (pwc) {
                 bStatus = RtlCreateUnicodeString(FileName,
                                                  pwc
                                                  );
                 if (!bStatus) {
                     Status = STATUS_NO_MEMORY;
                     goto FFOFinallyExit;
                     }

                 PathName->Length = (USHORT)((ULONG)pwc - (ULONG)PathName->Buffer);
                 if (PathName->Buffer[(PathName->Length>>1)-2] != (WCHAR)':' ) {
                     PathName->Length -= sizeof(UNICODE_NULL);
                     }
                 }
             else {
                 FileName->Length = 0;
                 FileName->MaximumLength = 0;
                 }

             bReturnSingleEntry = FALSE;
             }
         else {
             bReturnSingleEntry = pFFindEntry->SupportReset;
             }



         //
         // Prepare Find Buffer for NtQueryDirectory
         //
         if (BufferSize != pFFindEntry->FindBufferLength) {
             if (pFFindEntry->FindBufferBase) {
                 RtlFreeHeap(RtlProcessHeap(), 0, pFFindEntry->FindBufferBase);
                 }
             else {
                 NumFindBuffer++;
                 }

             pFFindEntry->FindBufferBase = RtlAllocateHeap(RtlProcessHeap(),
                                                           0,
                                                           BufferSize
                                                           );
             if (!pFFindEntry->FindBufferBase) {
                 Status = STATUS_NO_MEMORY;
                 goto FFOFinallyExit;
                 }
             }

         pFFindEntry->FindBufferNext = NULL;
         pFFindEntry->FindBufferLength = BufferSize;
         DirectoryInfo = pFFindEntry->FindBufferBase;

         //
         // Open the directory for list access
         //
         if (!pFFindEntry->DirectoryHandle) {

             InitializeObjectAttributes(
                 &Obja,
                 PathName,
                 OBJ_CASE_INSENSITIVE,
                 NULL,
                 NULL
                 );

             Status = NtOpenFile(
                         &pFFindEntry->DirectoryHandle,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

             if (!NT_SUCCESS(Status)) {

                 if (pwcFile) {
                     pFFindEntry->DirectoryHandle = FileFindFirstDevice(pwcFile,
                                                                        DirectoryInfo
                                                                        );
                     }
                 else {
                     pFFindEntry->DirectoryHandle = NULL;
                     }

                 if (pFFindEntry->DirectoryHandle) {
                     Status = STATUS_SUCCESS;
                     goto FFOFinallyExit;
                     }

                 if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
                     Status == STATUS_OBJECT_TYPE_MISMATCH )
                    {
                     Status = STATUS_OBJECT_PATH_NOT_FOUND;
                     }
                 goto FFOFinallyExit;
                 }

             NumDirectoryHandle++;
             }


         //
         // Prepare the filename for NtQueryDirectory
         //

         if (pwcFile) {
             WCHAR wchCurr, wchPrev;

             int Len = FileName->Length/sizeof(WCHAR);

             //
             // If there is no file part, but we are not looking at a device exit
             //
             if (!Len) {

                 //
                 // At this point, pwcFile has been parsed to PathName and FileName.  If PathName
                 // does not exist, the NtOpen() above will have failed and we will not be here.
                 // PathName is formatted to  \??\c:\xxx\yyy\zzz
                 // DOS had this "feature" that if you looked for something like c:\foobar\, you'd
                 // get PATH_NOT_FOUND, but if you looked for c:\  or  \   you'd get NO_MORE_FILES,
                 // so we special case this here.  If the caller is only looking for  c:\  or   \
                 // PathName will be  \??\c:\   If the caller is looking for ANY other string,
                 // the PathName string will be longer than strlen("\??\c:\") because the text of
                 // any dir will be added to the end.  That's why a simple check of the string len
                 // works at this time.
                 //
                 if ( PathName->Length > (sizeof( L"\\??\\c:\\")-sizeof(WCHAR))  ) {
                     Status = STATUS_OBJECT_PATH_NOT_FOUND;
                 }
                 else {
                     Status = STATUS_NO_MORE_FILES;
                 }

                 goto FFOFinallyExit;
                 }


             //
             //  ntio expects the following transmogrifications:
             //
             //  - Change all ? to DOS_QM
             //  - Change all . followed by ? or * to DOS_DOT
             //  - Change all * followed by a . into DOS_STAR
             //
             //  However, the doskrnl and wow32 have expanded '*'s to '?'s
             //  so the * rules can be ignored.
             //
             pwc = FileName->Buffer;
             wchPrev = 0;
             while (Len--) {
                wchCurr = *pwc;

                if (wchCurr == L'?') {
                    if (wchPrev == L'.') {
                        *(pwc - 1) = DOS_DOT;
                        }

                    *pwc = DOS_QM;
                    }

                wchPrev = wchCurr;
                pwc++;
                }

             }

#if DBG
         if (fShowSVCMsg & DEMFILIO) {
             sprintf(demDebugBuffer,
                     "FFOpen %x %ws (%ws)\n",
                     pFFindEntry->DirectoryHandle,
                     FileName->Buffer,
                     pwcFile
                     );
             OutputDebugStringOem(demDebugBuffer);
             }
#endif


         //
         // Do an initial query to fill the buffers, and verify everything is ok
         //

         Status = NtQueryDirectoryFile(
                         pFFindEntry->DirectoryHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         DirectoryInfo,
                         BufferSize,
                         FileBothDirectoryInformation,
                         bReturnSingleEntry,
                         FileName,
                         FALSE
                         );

FFOFinallyExit:;

         }
    finally {
         if (!NT_SUCCESS(Status)) {
#if DBG
             if ((fShowSVCMsg & DEMFILIO) && !NT_SUCCESS(Status)) {
                 sprintf(demDebugBuffer, "FFOpen Status %x\n", Status);
                 OutputDebugStringOem(demDebugBuffer);
                 }
#endif

             FileFindClose(pFFindEntry);
             RtlFreeUnicodeString(PathName);
             PathName->Buffer = NULL;
             RtlFreeUnicodeString(FileName);
             FileName->Buffer = NULL;
             }
          else {
             pFFindEntry->FindBufferNext = pFFindEntry->FindBufferBase;
             }
         }

    return Status;
}



/*
 *  Closes a FileFindHandle
 */
VOID
FileFindClose(
    PFFINDLIST pFFindEntry
    )
{
    NTSTATUS Status;
    HANDLE DirectoryHandle;

    DirectoryHandle = pFFindEntry->DirectoryHandle;
    if (DirectoryHandle &&
        DirectoryHandle != FINDFILE_DEVICE)
      {
        NtClose(DirectoryHandle);
        --NumDirectoryHandle;
        }

    pFFindEntry->DirectoryHandle = 0;

    if (pFFindEntry->FindBufferBase) {
        RtlFreeHeap(RtlProcessHeap(), 0, pFFindEntry->FindBufferBase);
        --NumFindBuffer;
        }

    pFFindEntry->FindBufferBase = NULL;
    pFFindEntry->FindBufferNext = NULL;
    pFFindEntry->FindBufferLength = 0;
    pFFindEntry->FindFileTics.QuadPart = 0;

    if (!NumDirectoryHandle && !NumFindBuffer) {
        FindFileTics.QuadPart = 0;
        NextFindFileTics.QuadPart = 0;
        }
}



/*
 *  FileFindReset
 *
 *   Resets search pos according to FileName, FileIndex.
 *   The FindBuffers will point to the next file in the search
 *   order. Assumes that the remembered search pos, has not been
 *   reached yet for the current search.
 *
 */
NTSTATUS
FileFindReset(
   PFFINDLIST pFFindEntry
   )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    UNICODE_STRING LastFileName;
    UNICODE_STRING CurrFileName;
    BOOLEAN bSlowReset;


    if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
        return STATUS_NO_MORE_FILES;
        }

    Status = STATUS_UNSUCCESSFUL;

    LastFileName.Length = (USHORT)pFFindEntry->DosData.FileNameLength;
    LastFileName.MaximumLength = (USHORT)pFFindEntry->DosData.FileNameLength;
    LastFileName.Buffer = pFFindEntry->DosData.FileName;

    RtlInitUnicodeString(&CurrFileName, L".");
    if (!RtlCompareUnicodeString(&LastFileName, &CurrFileName, TRUE)) {
        bSlowReset = TRUE;
        }
    else {
        RtlInitUnicodeString(&CurrFileName, L"..");
        if (!RtlCompareUnicodeString(&LastFileName, &CurrFileName, TRUE)) {
            bSlowReset = TRUE;
            }
        else {
            bSlowReset = FALSE;
            }
        }

    //
    // if the last file name, wasn't Dots and the volume supports reset
    // functionality call nt file sysetm to do the reset.
    //
    if (!bSlowReset && pFFindEntry->SupportReset) {
        VDMQUERYDIRINFO VdmQueryDirInfo;
        UNICODE_STRING  UnicodeString;

        DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION) pFFindEntry->FindBufferBase;

        VdmQueryDirInfo.FileHandle = pFFindEntry->DirectoryHandle;
        VdmQueryDirInfo.FileInformation = DirectoryInfo;
        VdmQueryDirInfo.Length = pFFindEntry->FindBufferLength;
        VdmQueryDirInfo.FileIndex = pFFindEntry->DosData.FileIndex;

        UnicodeString.Length = (USHORT)pFFindEntry->DosData.FileNameLength;
        UnicodeString.MaximumLength = UnicodeString.Length;
        UnicodeString.Buffer = pFFindEntry->DosData.FileName;
        VdmQueryDirInfo.FileName = &UnicodeString;

        Status = NtVdmControl(VdmQueryDir, &VdmQueryDirInfo);
        if (NT_SUCCESS(Status) ||
            Status == STATUS_NO_MORE_FILES || Status == STATUS_NO_SUCH_FILE)
           {
            return Status;
            }

        pFFindEntry->SupportReset = TRUE;

        }

   //
   // Reset the slow way by comparing FileName directly.
   //
   // WARNING: if the "remembered" File has been deleted we will
   //          fail, is there something else we can do ?
   //

    Status = STATUS_NO_MORE_FILES;
    while (TRUE) {

       //
       // If there is no data in the find file buffer, call NtQueryDir
       //

       DirectoryInfo = pFFindEntry->FindBufferNext;
       if (!DirectoryInfo) {
            DirectoryInfo = pFFindEntry->FindBufferBase;

            Status = NtQueryDirectoryFile(
                            pFFindEntry->DirectoryHandle,
                            NULL,                          // no event
                            NULL,                          // no apcRoutine
                            NULL,                          // no apcContext
                            &IoStatusBlock,
                            DirectoryInfo,
                            pFFindEntry->FindBufferLength,
                            FileBothDirectoryInformation,
                            FALSE,                         // single entry
                            NULL,                          // no file name
                            FALSE
                            );

           if (!NT_SUCCESS(Status)) {
#if DBG
               if (fShowSVCMsg & DEMFILIO) {
                   sprintf(demDebugBuffer, "FFReset Status %x\n", Status);
                   OutputDebugStringOem(demDebugBuffer);
                   }
#endif
               return Status;
               }
           }

       if ( DirectoryInfo->NextEntryOffset ) {
           pFFindEntry->FindBufferNext = (PVOID)((ULONG)DirectoryInfo +
                                                DirectoryInfo->NextEntryOffset);
           }
       else {
           pFFindEntry->FindBufferNext = NULL;
           }


       if (DirectoryInfo->FileIndex == pFFindEntry->DosData.FileIndex) {
           CurrFileName.Length = (USHORT)DirectoryInfo->FileNameLength;
           CurrFileName.MaximumLength = (USHORT)DirectoryInfo->FileNameLength;
           CurrFileName.Buffer = DirectoryInfo->FileName;

           if (!RtlCompareUnicodeString(&LastFileName, &CurrFileName, TRUE)) {
               return STATUS_SUCCESS;
               }
           }

       }

    return Status;

}




/*
 * FileFindLast - Attempts to fill the FindFile buffer completely.
 *
 *
 * PFFINDLIST pFFindEntry -
 *
 * Returns - Status of NtQueryDir operation if invoked, otherwise
 *           STATUS_SUCCESS.
 *
 */
NTSTATUS
FileFindLast(
    PFFINDLIST pFFindEntry
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirInfo, LastDirInfo;
    LONG BytesLeft;

    if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
        return STATUS_NO_MORE_FILES;
        }

    if (pFFindEntry->FindBufferNext) {
        ULONG BytesOffset;

        BytesOffset = (ULONG)pFFindEntry->FindBufferNext -
                      (ULONG)pFFindEntry->FindBufferBase;

        if (BytesOffset) {
            RtlMoveMemory(pFFindEntry->FindBufferBase,
                          pFFindEntry->FindBufferNext,
                          pFFindEntry->FindBufferLength - BytesOffset
                          );
            }

        pFFindEntry->FindBufferNext = pFFindEntry->FindBufferBase;
        DirInfo = pFFindEntry->FindBufferBase;

        while (DirInfo->NextEntryOffset) {
            DirInfo = (PVOID)((ULONG)DirInfo + DirInfo->NextEntryOffset);
            }
        LastDirInfo = DirInfo;

        DirInfo = (PVOID)&DirInfo->FileName[DirInfo->FileNameLength>>1];

        DirInfo = (PVOID) (((ULONG) DirInfo + sizeof(LONGLONG) - 1) &
            ~(sizeof(LONGLONG) - 1));

        BytesLeft = pFFindEntry->FindBufferLength -
                     ((ULONG)DirInfo - (ULONG)pFFindEntry->FindBufferBase);
        }
    else {
        DirInfo = pFFindEntry->FindBufferBase;
        LastDirInfo = NULL;
        BytesLeft = pFFindEntry->FindBufferLength;
        }


    // the size of the dirinfo structure including the name must be a longlong.
    while (BytesLeft > sizeof(FILE_BOTH_DIR_INFORMATION) + sizeof(LONGLONG) + MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR)) {


       Status = NtQueryDirectoryFile(
                       pFFindEntry->DirectoryHandle,
                       NULL,                          // no event
                       NULL,                          // no apcRoutine
                       NULL,                          // no apcContext
                       &IoStatusBlock,
                       DirInfo,
                       BytesLeft,
                       FileBothDirectoryInformation,
                       FALSE,                          // single entry ?
                       NULL,                          // no file name
                       FALSE
                       );

       if (Status == STATUS_NO_MORE_FILES || Status == STATUS_NO_SUCH_FILE) {
#if DBG
           if ((fShowSVCMsg & DEMFILIO)) {
               sprintf(demDebugBuffer, "FFLast Status %x\n", Status);
               OutputDebugStringOem(demDebugBuffer);
               }
#endif
           return Status;
           }


       if (!NT_SUCCESS(Status)) {
           break;
           }

       if (LastDirInfo) {
           LastDirInfo->NextEntryOffset =(ULONG)DirInfo - (ULONG)LastDirInfo;
           }
       else {
           pFFindEntry->FindBufferNext = pFFindEntry->FindBufferBase;
           }

       while (DirInfo->NextEntryOffset) {
           DirInfo = (PVOID)((ULONG)DirInfo + DirInfo->NextEntryOffset);
           }
       LastDirInfo = DirInfo;
       DirInfo = (PVOID)&DirInfo->FileName[DirInfo->FileNameLength>>1];

        DirInfo = (PVOID) (((ULONG) DirInfo + sizeof(LONGLONG) - 1) &
            ~(sizeof(LONGLONG) - 1));

       BytesLeft = pFFindEntry->FindBufferLength -
                    ((ULONG)DirInfo - (ULONG)pFFindEntry->FindBufferBase);
       }

   return STATUS_SUCCESS;
}






/*
 * FileFindNext - retrieves the next file in the current search order,
 *
 * PFFINDDOSDATA pFFindDD
 *    Receives File info returned by the nt FileSystem
 *
 * PFFINDLIST pFFindEntry -
 *    Contains the DirectoryInfo (FileName,FileIndex) necessary to reset a
 *    search pos. For operations other than QDIR_RESET_SCAN, this is ignored.
 *
 * Returns -
 *    If Got a DirectoryInformation Entry, STATUS_SUCCESS
 *    If no Open Directory handle and is unknown if there are more files
 *    returns STATUS_IN`VALID_HANDLE
 *
 */
NTSTATUS
FileFindNext(
    PFFINDDOSDATA pFFindDD,
    PFFINDLIST pFFindEntry
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;

    if (pFFindEntry->DirectoryHandle == FINDFILE_DEVICE) {
        return STATUS_NO_MORE_FILES;
        }

    Status = STATUS_UNSUCCESSFUL;

    do {

       //
       // If there is no data in the find file buffer, call NtQueryDir
       //

       DirectoryInfo = pFFindEntry->FindBufferNext;
       if (!DirectoryInfo) {
           if (!pFFindEntry->DirectoryHandle) {
               return STATUS_INVALID_HANDLE;
               }

           DirectoryInfo = pFFindEntry->FindBufferBase;

           Status = NtQueryDirectoryFile(
                            pFFindEntry->DirectoryHandle,
                            NULL,                          // no event
                            NULL,                          // no apcRoutine
                            NULL,                          // no apcContext
                            &IoStatusBlock,
                            DirectoryInfo,
                            pFFindEntry->FindBufferLength,
                            FileBothDirectoryInformation,
                            FALSE,                         // single entry ?
                            NULL,                          // no file name
                            FALSE
                            );

           if (!NT_SUCCESS(Status)) {
#if DBG
               if (fShowSVCMsg & DEMFILIO) {
                   sprintf(demDebugBuffer, "FFNext Status %x\n", Status);
                   OutputDebugStringOem(demDebugBuffer);
                   }
#endif
               return Status;
               }
           }


       if ( DirectoryInfo->NextEntryOffset ) {
           pFFindEntry->FindBufferNext = (PVOID)((ULONG)DirectoryInfo +
                                                DirectoryInfo->NextEntryOffset);
           }
       else {
           pFFindEntry->FindBufferNext = NULL;
           }

       } while (!CopyDirInfoToDosData(pFFindEntry->DirectoryHandle,
                                      pFFindDD,
                                      DirectoryInfo,
                                      pFFindEntry->usSrchAttr
                                      ));

    return STATUS_SUCCESS;
}

BOOL IsVolumeNtfs(
   HANDLE DirectoryHandle)
{
   union {
      FILE_FS_ATTRIBUTE_INFORMATION AttributeInfo;
      BYTE rgBuffer[sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + MAX_PATH*sizeof(WCHAR)];
   }  Attrib;
   IO_STATUS_BLOCK IoStatusBlock;
   NTSTATUS Status;
   BOOL fNtfsVolume = TRUE;

   Status = NtQueryVolumeInformationFile(DirectoryHandle,
                                         &IoStatusBlock,
                                         &Attrib,
                                         sizeof(Attrib),
                                         FileFsAttributeInformation);

   if (NT_SUCCESS(Status)) {
      fNtfsVolume = !_wcsicmp(Attrib.AttributeInfo.FileSystemName, L"Ntfs");
   }

   return(fNtfsVolume);
}



/*
 *  CopyDirInfoToDosData
 *
 */
BOOL
CopyDirInfoToDosData(
    HANDLE DirectoryHandle,
    PFFINDDOSDATA pFFindDD,
    PFILE_BOTH_DIR_INFORMATION DirInfo,
    USHORT SearchAttr
    )
{
    NTSTATUS Status;
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;
    DWORD   dwAttr;
    BOOLEAN SpacesInName = FALSE;
    BOOLEAN NameValid8Dot3;

    //
    // match the attributes
    // See DOS5.0 sources (dir2.asm, MatchAttributes)
    // ignores READONLY and ARCHIVE bits
    //
    if (FILE_ATTRIBUTE_NORMAL == DirInfo->FileAttributes) {
        DirInfo->FileAttributes = 0;
        }
    else {
        DirInfo->FileAttributes &= DOS_ATTR_MASK;
        }


    dwAttr = DirInfo->FileAttributes;
    dwAttr &= ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY);
    if (((~(ULONG)SearchAttr) & dwAttr) & ATTR_ALL)
        return FALSE;


    //
    // set up the destination oem string buffer
    //
    OemString.Buffer        = pFFindDD->cFileName;
    OemString.MaximumLength = 14;

    //
    // see if the name is legal fat
    //

    UnicodeString.Buffer = DirInfo->FileName;
    UnicodeString.Length = (USHORT)DirInfo->FileNameLength;
    UnicodeString.MaximumLength = (USHORT)DirInfo->FileNameLength;

    NameValid8Dot3 = RtlIsNameLegalDOS8Dot3( &UnicodeString,
                                             &OemString,
                                             &SpacesInName );

    //
    // if failed (incompatible codepage or illegal FAT name),
    //    use the short name
    //
    if (!NameValid8Dot3 ||
        (SpacesInName && (DirInfo->ShortName[0] != UNICODE_NULL))) {

        if (DirInfo->ShortName[0] == UNICODE_NULL) {
            pFFindDD->cFileName[0] = '\0';
            return FALSE;
            }

        UnicodeString.Buffer = DirInfo->ShortName;
        UnicodeString.Length = (USHORT)DirInfo->ShortNameLength;
        UnicodeString.MaximumLength = (USHORT)DirInfo->ShortNameLength;

        if (!NT_SUCCESS(RtlUpcaseUnicodeStringToCountedOemString(&OemString, &UnicodeString, FALSE))) {
            pFFindDD->cFileName[0] = '\0';
            return FALSE;
            }
        }

    OemString.Buffer[OemString.Length] = '\0';

    // fill in time, size and attributes

    //
    // bjm-11/10/97 - for directories, FAT does not update lastwritten time
    // when things actually happen in the directory.  NTFS does.  This causes
    // a problem for Encore 3.0 (when running on NTFS) which, at install time,
    // gets the lastwritten time for it's directory, then compares it, at app
    // run time, to the "current" last written time and will bail (with a "Not
    // correctly installed" message) if they're different.  So, 16 bit apps
    // (which can only reasonably expect FAT info), should only get creation
    // time for this file if it's a directory.
    //
    // VadimB: 11/20/98 -- this hold true ONLY for apps running on NTFS and
    // not FAT -- since older FAT partitions are then given an incorrect
    // creation time

    if ((FILE_ATTRIBUTE_DIRECTORY & DirInfo->FileAttributes) && IsVolumeNtfs(DirectoryHandle))  {
        pFFindDD->ftLastWriteTime   = *(LPFILETIME)&DirInfo->CreationTime;
    }
    else {
        pFFindDD->ftLastWriteTime   = *(LPFILETIME)&DirInfo->LastWriteTime;
    }
    pFFindDD->dwFileSizeLow     = DirInfo->EndOfFile.LowPart;
    pFFindDD->uchFileAttributes = (UCHAR)DirInfo->FileAttributes;

    // Save File Name, Index for restarting searches
    pFFindDD->FileIndex = DirInfo->FileIndex;
    pFFindDD->FileNameLength = DirInfo->FileNameLength;

    RtlCopyMemory(pFFindDD->FileName,
                  DirInfo->FileName,
                  DirInfo->FileNameLength
                  );

    pFFindDD->FileName[DirInfo->FileNameLength >> 1] = UNICODE_NULL;

    return TRUE;
}




HANDLE
FileFindFirstDevice(
    PWCHAR FileName,
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo
    )

/*++

Routine Description:

    Determines if the FileName is a device, and copies out the
    device name found if it is.

Arguments:

    FileName - Supplies the device name of the file to find.

    pQueryDirInfo - On a successful find, this parameter returns information
                    about the located file.

Return Value:


--*/

{
    ULONG DeviceNameData;
    PWSTR DeviceName;

    DeviceNameData = RtlIsDosDeviceName_U(FileName);
    if (DeviceNameData) {
        RtlZeroMemory(DirectoryInfo, sizeof(FILE_BOTH_DIR_INFORMATION));

        DirectoryInfo->FileAttributes = FILE_ATTRIBUTE_ARCHIVE;
        DeviceName = (PWSTR)((ULONG)FileName + (DeviceNameData >> 16));

        DeviceNameData &= 0xffff;

        DirectoryInfo->FileNameLength = DeviceNameData;
        DirectoryInfo->ShortNameLength = (CCHAR)DeviceNameData;


        RtlCopyMemory(DirectoryInfo->FileName,
                      DeviceName,
                      DeviceNameData
                      );

        RtlCopyMemory(DirectoryInfo->ShortName,
                      DeviceName,
                      DeviceNameData
                      );

        return FINDFILE_DEVICE;
        }

    return NULL;
}




/* FillFcbVolume - fill Volume info in the FCB
 *
 * Entry -  pSrchBuf    FCB Search buffer to be filled in
 *          FileName  File Name (interesting part is the drive letter)
 *
 * Exit -  SUCCESS
 *      Client (CF) - 0
 *      pSrchBuf is filled with volume info
 *
 *     FAILURE
 *      Client (CF) - 1
 *      Client (AX) = Error Code
 */
VOID
FillFcbVolume(
     PSRCHBUF pSrchBuf,
     CHAR *pFileName,
     USHORT SearchAttr
     )
{
    CHAR    *pch;
    PDIRENT pDirEnt = &pSrchBuf->DirEnt;
    CHAR    FullPathBuffer[MAX_PATH];
    CHAR    achBaseName[DOS_VOLUME_NAME_SIZE + 2];  // 11 chars, '.', and null
    CHAR    achVolumeName[NT_VOLUME_NAME_SIZE];

    //
    // form a path without base name
    // this makes sure only on root directory will get the
    // volume label(the GetVolumeInformationOem will fail
    // if the given path is not root directory)
    //

    strcpy(FullPathBuffer, pFileName);
    pch = strrchr(FullPathBuffer, '\\');
    if (pch)  {
        pch++;
        // truncate to dos file name length (including period)
        pch[DOS_VOLUME_NAME_SIZE + 1] = '\0';
        strcpy(achBaseName, pch);
#ifdef DBCS
#if defined(NEC_98)
// BUG fix for DBCS small alphabet converted to large it.
        demCharUpper(achBaseName);
#else  // !NEC_98
        CharUpper(achBaseName);
#endif // !NEC_98
#else // !DBCS
        _strupr(achBaseName);
#endif // !DBCS
        *pch = '\0';
        }
    else {
        achBaseName[0] = '\0';
        }


    //
    // if searching for volume only the DOS uses first 3 letters for
    // root drive path ignoring the rest of the path
    // as long as the full pathname is valid.
    //
    if (SearchAttr == ATTR_VOLUME_ID &&
        (pch = strchr(FullPathBuffer, '\\')) &&
        GetFileAttributes(FullPathBuffer) != 0xffffffff )
      {
        pch++;
        *pch = '\0';
        strcpy(achBaseName, szStartDotStar);
        }


    if (GetVolumeInformationOem(FullPathBuffer,
                                achVolumeName,
                                NT_VOLUME_NAME_SIZE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                0) == FALSE)
       {

        demClientError(INVALID_HANDLE_VALUE, *pFileName);
        return;
        }

    // truncate to dos volumen max size (no period)
    achVolumeName[DOS_VOLUME_NAME_SIZE] = '\0';

    if (!achVolumeName[0] || !MatchVolLabel(achVolumeName, achBaseName)) {
        SetLastError(ERROR_NO_MORE_FILES);
        demClientError(INVALID_HANDLE_VALUE, *pFileName);
        return;
        }

    // warning !!! this assumes the FileExt follows FileName immediately
    memset(pSrchBuf->FileName, ' ', DOS_VOLUME_NAME_SIZE);
    strncpy(pSrchBuf->FileName, achVolumeName, strlen(achVolumeName));

    // Now copy the directory entry
    strncpy(pDirEnt->FileName,pSrchBuf->FileName,8);
    strncpy(pDirEnt->FileExt,pSrchBuf->FileExt,3);
    setCF (0);
    return;
}


/* FillDtaVolume - fill Volume info in the DTA
 *
 * Entry - CHAR lpSearchName - name to match with volume name
 *
 *
 * Exit -  SUCCESS
 *      Returns - TRUE
 *      pSrchBuf is filled with volume info
 *
 *     FAILURE
 *      Returns - FALSE
 *      sets last error code
 */

BOOL FillDtaVolume(
     CHAR *pFileName,
     PSRCHDTA  pDta,
     USHORT SearchAttr
     )
{
    CHAR    *pch;
    CHAR    FullPathBuffer[MAX_PATH];
    CHAR    achBaseName[DOS_VOLUME_NAME_SIZE + 2];  // 11 chars, '.' and null
    CHAR    achVolumeName[NT_VOLUME_NAME_SIZE];

    //
    // form a path without base name
    // this makes sure only on root directory will get the
    // volume label(the GetVolumeInformationOem will fail
    // if the given path is not root directory)
    //
    strcpy(FullPathBuffer, pFileName);
    pch = strrchr(FullPathBuffer, '\\');
    if (pch)  {
        pch++;
        pch[DOS_VOLUME_NAME_SIZE + 1] = '\0'; // max len (including period)
        strcpy(achBaseName, pch);
#ifdef DBCS
#if defined(NEC_98)
// BUG fix for DBCS small alphabet converted to large it.
        demCharUpper(achBaseName);
#else  // !NEC_98
        CharUpper(achBaseName);
#endif // !NEC_98
#else // !DBCS
        _strupr(achBaseName);
#endif // !DBCS
        *pch = '\0';
        }
    else {
        achBaseName[0] = '\0';
        }


    //
    // if searching for volume only the DOS uses first 3 letters for
    // root drive path ignoring the rest of the path, if there is no basename assume *.*
    //
    if (SearchAttr == ATTR_VOLUME_ID &&
        (pch = strchr(FullPathBuffer, '\\')) &&
        GetFileAttributes(FullPathBuffer) != 0xffffffff )
      {
        pch++;
        if(!*pch) {
          strcpy(achBaseName, szStartDotStar);
          }                
        *pch = '\0';

      }

    if (GetVolumeInformationOem(FullPathBuffer,
                                achVolumeName,
                                NT_VOLUME_NAME_SIZE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                0) == FALSE)
       {
        return FALSE;
        }

    // truncate to dos file name length (no period)
    achVolumeName[DOS_VOLUME_NAME_SIZE] = '\0';

    if  (!achVolumeName[0] || !MatchVolLabel(achVolumeName, achBaseName)) {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
        }

    //
    // DOS Dta search returns volume label in 8.3 format. But if label is
    // more than 8 characters long than NT just returns that as it is
    // without adding a ".". So here we have to add a "." in volume
    // labels, if needed. But note that FCB based volume search does'nt
    // add the "." So nothing need to be done there.
    //
    NtVolumeNameToDosVolumeName(pDta->achFileName, achVolumeName);
    pDta->uchFileAttr =  ATTR_VOLUME_ID;
    STOREWORD(pDta->usLowSize,0);
    STOREWORD(pDta->usHighSize,0);

    // Zero out dates as we can not fetch dates for volume labels.
    STOREWORD(pDta->usTimeLastWrite,0);
    STOREWORD(pDta->usDateLastWrite,0);

    return TRUE;
}



/*
 *  MatchVolLabel
 *  Does a string compare to see if the vol label matches
 *  a FAT search string. The search string is expected to
 *  have the '*' character already expanded into '?' characters.
 *
 *  WARNING: maintanes dos5.0 quirk of not caring about characters past
 *  the defined len of each part of the vol label.
 *  12345678.123
 *  ^       ^
 *
 *        foovol      foovol1  (srch string)
 *        foo.vol     foo.vol1 (srch string)
 *
 *  entry: CHAR *pVol   -- NT volume name
 *     CHAR *pSrch  -- dos volume name
 *
 *  exit: TRUE for a match
 */
BOOL MatchVolLabel(CHAR *pVol, CHAR *pSrch )
{
    WORD w;
    CHAR  achDosVolumeName[DOS_VOLUME_NAME_SIZE + 2]; // 11 chars, '.' and null

    NtVolumeNameToDosVolumeName(achDosVolumeName, pVol);
    pVol = achDosVolumeName;

    w = 8;
    while (w--) {
        if (*pVol == *pSrch)  {
            if (!*pVol && !*pSrch)
                return TRUE;
            }
        else if (*pSrch == '.') {
            if (*pVol)
                return FALSE;
            }
        else if (*pSrch != '?') {
            return FALSE;
            }

           // move on to the next character
           // but not past second component part
        if (*pVol && *pVol != '.')
            pVol++;
        if (*pSrch && *pSrch != '.')
            pSrch++;
        }

      // skip trailing part of search string, in the first comp
    while (*pSrch && *pSrch != '.')
         pSrch++;


    w = 4;
    while (w--) {
        if (*pVol == *pSrch)  {
            if (!*pVol && !*pSrch)
                return TRUE;
            }
        else if (*pSrch == '.') {
            if (*pVol)
                return FALSE;
            }
        else if (*pSrch != '?') {
            return FALSE;
            }

           // move on to the next character
        if (*pVol)
            pVol++;
        if (*pSrch)
            pSrch++;
        }

     return TRUE;
}


VOID NtVolumeNameToDosVolumeName(CHAR * pDosName, CHAR * pNtName)
{

    char    NtNameBuffer[NT_VOLUME_NAME_SIZE];
    int     i;
    char    char8, char9, char10;

    // make a local copy so that the caller can use the same
    // buffer
    strcpy(NtNameBuffer, pNtName);

    if (strlen(NtNameBuffer) > 8) {
    char8 = NtNameBuffer[8];
    char9 = NtNameBuffer[9];
    char10 = NtNameBuffer[10];
        // eat spaces from first 8 characters
        i = 7;
    while (NtNameBuffer[i] == ' ')
            i--;
    NtNameBuffer[i+1] = '.';
    NtNameBuffer[i+2] = char8;
    NtNameBuffer[i+3] = char9;
    NtNameBuffer[i+4] = char10;
    NtNameBuffer[i+5] = '\0';
    }
    strcpy(pDosName, NtNameBuffer);
}





/* FillFCBSrchBuf - Fill the FCB Search buffer.
 *
 * Entry -  pSrchBuf FCB Search buffer to be filled in
 *      hFind Search Handle
 *      fFirst TRUE if call from FindFirstFCB
 *
 * Exit  - None (pSrchBuf filled in)
 *
 */

VOID FillFCBSrchBuf(
     PFFINDDOSDATA pFFindDD,
     PSRCHBUF pSrchBuf,
     BOOL IsOnCD)
{
    PDIRENT     pDirEnt = &pSrchBuf->DirEnt;
    PCHAR       pDot;
    USHORT      usDate,usTime,i;
    FILETIME    ftLocal;

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "FillFCBSrchBuf<%s>\n", pFFindDD->cFileName);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    // Copy file name (Max Name = 8 and Max ext = 3)
    if ((pDot = strchr(pFFindDD->cFileName,'.')) == NULL) {
        strncpy(pSrchBuf->FileName,pFFindDD->cFileName,8);
        _strnset(pSrchBuf->FileExt,'\x020',3);
        }
    else if (pDot == pFFindDD->cFileName) {
        strncpy(pSrchBuf->FileName,pFFindDD->cFileName,8);
        _strnset(pSrchBuf->FileExt,'\x020',3);
        }
    else {
        *pDot = '\0';
        strncpy(pSrchBuf->FileName,pFFindDD->cFileName,8);
        *pDot++ = '\0';
        strncpy(pSrchBuf->FileExt,pDot,3);
        }


    for (i=0;i<8;i++) {
      if (pSrchBuf->FileName[i] == '\0')
          pSrchBuf->FileName[i]='\x020';
      }

    for (i=0;i<3;i++) {
      if (pSrchBuf->FileExt[i] == '\0')
          pSrchBuf->FileExt[i]='\x020';
      }

    STOREWORD(pSrchBuf->usCurBlkNumber,0);
    STOREWORD(pSrchBuf->usRecordSize,0);
    STOREDWORD(pSrchBuf->ulFileSize, pFFindDD->dwFileSizeLow);

    // Convert NT File time/date to DOS time/date
    FileTimeToLocalFileTime (&pFFindDD->ftLastWriteTime,&ftLocal);
    FileTimeToDosDateTime (&ftLocal,
                           &usDate,
                           &usTime);

    // Now copy the directory entry
    strncpy(pDirEnt->FileName,pSrchBuf->FileName,8);
    strncpy(pDirEnt->FileExt,pSrchBuf->FileExt,3);

    // SudeepB - 28-Jul-1997
    //
    // For CDFS, Win3.1/DOS/Win95, only return FILE_ATTRIBUTE_DIRECTORY (10)
    // for directories while WinNT returns
    // FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY (11).
    // Some VB controls that app setups use, depend on getting
    // FILE_ATTRIBUTE_DIRECTORY (10) only or otherwise are broken.
    // An example of this is Cliffs StudyWare series.
    //

    if (IsOnCD && pFFindDD->uchFileAttributes == (ATTR_DIRECTORY | ATTR_READ_ONLY))
        pDirEnt->uchAttributes = ATTR_DIRECTORY;
    else
        pDirEnt->uchAttributes  = pFFindDD->uchFileAttributes;

    STOREWORD(pDirEnt->usTime,usTime);
    STOREWORD(pDirEnt->usDate,usDate);
    STOREDWORD(pDirEnt->ulFileSize,pFFindDD->dwFileSizeLow);

    return;
}



/* FillSrchDta - Fill DTA for FIND_FIRST,FIND_NEXT operations.
 *
 * Entry - pW32FindData Buffer containing file data
 *         hFind - Handle returned by FindFirstFile
 *         PSRCHDTA pDta
 *
 * Exit  - None
 *
 * Note : It is guranteed that file name adhers to 8:3 convention.
 *    demSrchFile makes sure of that condition.
 *
 */
VOID
FillSrchDta(
     PFFINDDOSDATA pFFindDD,
     PSRCHDTA pDta,
     BOOL IsOnCD)
{
    USHORT   usDate,usTime;
    FILETIME ftLocal;

    // SudeepB - 28-Jul-1997
    //
    // For CDFS, Win3.1/DOS/Win95, only return FILE_ATTRIBUTE_DIRECTORY (10)
    // for directories while WinNT returns
    // FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY (11).
    // Some VB controls that app setups use, depend on getting
    // FILE_ATTRIBUTE_DIRECTORY (10) only or otherwise are broken.
    // An example of this is Cliffs StudyWare series.
    //
    if (IsOnCD && pFFindDD->uchFileAttributes == (ATTR_DIRECTORY | ATTR_READ_ONLY))
        pDta->uchFileAttr = ATTR_DIRECTORY;
    else
        pDta->uchFileAttr = pFFindDD->uchFileAttributes;

    // Convert NT File time/date to DOS time/date
    FileTimeToLocalFileTime (&pFFindDD->ftLastWriteTime,&ftLocal);
    FileTimeToDosDateTime (&ftLocal,
                           &usDate,
                           &usTime);

    STOREWORD(pDta->usTimeLastWrite,usTime);
    STOREWORD(pDta->usDateLastWrite,usDate);
    STOREWORD(pDta->usLowSize,(USHORT)pFFindDD->dwFileSizeLow);
    STOREWORD(pDta->usHighSize,(USHORT)(pFFindDD->dwFileSizeLow >> 16));

#if DBG
    if (fShowSVCMsg & DEMFILIO) {
        sprintf(demDebugBuffer, "FillSrchDta<%s>\n", pFFindDD->cFileName);
        OutputDebugStringOem(demDebugBuffer);
        }
#endif

    strncpy(pDta->achFileName,pFFindDD->cFileName, 13);

    return;
}





VOID demCloseAllPSPRecords (VOID)
{
   PLIST_ENTRY Next;
   PPSP_FFINDLIST pPspFFindEntry;

   Next = PspFFindHeadList.Flink;
   while (Next != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(Next,PSP_FFINDLIST,PspFFindEntry);
       FreeFFindList( &pPspFFindEntry->FFindHeadList);
       Next= Next->Flink;
       RemoveEntryList(&pPspFFindEntry->PspFFindEntry);
       free(pPspFFindEntry);
       }
}


void
DemHeartBeat(void)
{

   PLIST_ENTRY    Next;
   PLIST_ENTRY    pFFindHeadList;
   PPSP_FFINDLIST pPspFFindEntry;
   PFFINDLIST  pFFindEntry;

   if (!NumFindBuffer ||
       NextFindFileTics.QuadPart > ++FindFileTics.QuadPart)
     {
       return;
       }

   pPspFFindEntry = GetPspFFindList(FETCHWORD(pusCurrentPDB[0]));
   if (!pPspFFindEntry) {
       return;
       }
   pFFindHeadList = &pPspFFindEntry->FFindHeadList;
   Next = pFFindHeadList->Blink;
   while (Next != pFFindHeadList) {
        pFFindEntry = CONTAINING_RECORD(Next,FFINDLIST, FFindEntry);

        if (pFFindEntry->FindFileTics.QuadPart) {
            if (pFFindEntry->FindFileTics.QuadPart <= FindFileTics.QuadPart) {
                FileFindClose(pFFindEntry);
                }
            else {
                NextFindFileTics.QuadPart = pFFindEntry->FindFileTics.QuadPart;
                return;
                }
            }

        Next = Next->Blink;
        }

   NextFindFileTics.QuadPart = 0;
   FindFileTics.QuadPart = 0;
}





//
// CloseOldestFileFindBuffer
// walks the psp file find list backwards to find the oldest
// entry with FindBuffers, directory handles and closes it.
//
void
CloseOldestFileFindBuffer(
   void
   )
{
   PLIST_ENTRY    Next, NextPsp;
   PLIST_ENTRY    pFFindHeadList;
   PPSP_FFINDLIST pPspFFindEntry;
   PFFINDLIST     pFFEntry;

   NextPsp = PspFFindHeadList.Blink;
   while (NextPsp != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(NextPsp,PSP_FFINDLIST,PspFFindEntry);

       pFFindHeadList = &pPspFFindEntry->FFindHeadList;
       Next = pFFindHeadList->Blink;
       while (Next != pFFindHeadList) {
            pFFEntry = CONTAINING_RECORD(Next,FFINDLIST, FFindEntry);
            if (NumFindBuffer >= MAX_FINDBUFFER) {
                FileFindClose(pFFEntry);
                }
            else if (pFFEntry->DirectoryHandle &&
                     NumDirectoryHandle >= MAX_DIRECTORYHANDLE)
               {
                NumDirectoryHandle--;
                NtClose(pFFEntry->DirectoryHandle);
                pFFEntry->DirectoryHandle = 0;
                }

            if (NumFindBuffer < MAX_FINDBUFFER &&
                NumDirectoryHandle < MAX_DIRECTORYHANDLE)
               {
                return;
                }
            Next = Next->Blink;
            }

       NextPsp= NextPsp->Blink;
       }
}





/*
 * GetFFindEntryByFindId
 */
PFFINDLIST GetFFindEntryByFindId(ULONG NextFFindId)
{
   PLIST_ENTRY NextPsp;
   PLIST_ENTRY Next;
   PPSP_FFINDLIST pPspFFindEntry;
   PFFINDLIST     pFFindEntry;
   PLIST_ENTRY    pFFindHeadList;

   NextPsp = PspFFindHeadList.Flink;
   while (NextPsp != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(NextPsp,PSP_FFINDLIST,PspFFindEntry);

       pFFindHeadList = &pPspFFindEntry->FFindHeadList;
       Next = pFFindHeadList->Flink;
       while (Next != pFFindHeadList) {
            pFFindEntry = CONTAINING_RECORD(Next, FFINDLIST, FFindEntry);
            if (pFFindEntry->FFindId == NextFFindId) {
                return pFFindEntry;
                }
            Next= Next->Flink;
            }

       NextPsp= NextPsp->Flink;
       }

   return NULL;
}



/* AddFFindEntry - Adds a new File Find entry to the current
 *                    PSP's PspFileFindList
 *
 * Entry -
 *
 * Exit  -  PFFINDLIST  pFFindList;
 */
PFFINDLIST
AddFFindEntry(
        PWCHAR pwcFile,
        PFFINDLIST pFFindEntrySrc
        )

{
    PPSP_FFINDLIST pPspFFindEntry;
    PFFINDLIST     pFFindEntry;
    ULONG          Len;

    pPspFFindEntry = GetPspFFindList(FETCHWORD(pusCurrentPDB[0]));

        //
        // if a Psp entry doesn't exist
        //    Allocate one, initialize it and insert it into the list
        //
    if (!pPspFFindEntry) {
        pPspFFindEntry = (PPSP_FFINDLIST) malloc(sizeof(PSP_FFINDLIST));
        if (!pPspFFindEntry)
            return NULL;

        pPspFFindEntry->usPsp = FETCHWORD(pusCurrentPDB[0]);
        InitializeListHead(&pPspFFindEntry->FFindHeadList);
        InsertHeadList(&PspFFindHeadList, &pPspFFindEntry->PspFFindEntry);
        }

    //
    // Create the FileFindEntry and add to the FileFind list
    //
    pFFindEntry = (PFFINDLIST) malloc(sizeof(FFINDLIST));
    if (!pFFindEntry) {
        return pFFindEntry;
        }

    //
    // Fill in FFindList
    //
    *pFFindEntry = *pFFindEntrySrc;

    //
    //  Insert at  the head of this psp list
    //
    InsertHeadList(&pPspFFindEntry->FFindHeadList, &pFFindEntry->FFindEntry);

    return pFFindEntry;
}





/* FreeFFindEntry
 *
 * Entry -  PFFINDLIST pFFindEntry
 *
 * Exit  -  None
 *
 */
VOID FreeFFindEntry(PFFINDLIST pFFindEntry)
{
    RemoveEntryList(&pFFindEntry->FFindEntry);
    FileFindClose(pFFindEntry);
    RtlFreeUnicodeString(&pFFindEntry->FileName);
    RtlFreeUnicodeString(&pFFindEntry->PathName);
    free(pFFindEntry);
    return;
}



/* FreeFFindList
 *
 * Entry -  Frees the entire list
 *
 * Exit  -  None
 *
 */
VOID FreeFFindList(PLIST_ENTRY pFFindHeadList)
{
    PLIST_ENTRY  Next;
    PFFINDLIST  pFFindEntry;

    Next = pFFindHeadList->Flink;
    while (Next != pFFindHeadList) {
         pFFindEntry = CONTAINING_RECORD(Next,FFINDLIST, FFindEntry);
         Next= Next->Flink;
         FreeFFindEntry(pFFindEntry);
         }

    return;
}


/* GetPspFFindList
 *
 * Entry -  USHORT CurrPsp
 *
 * Exit  -  Success - PPSP_FFINDLIST
 *      Failure - NULL
 *
 */
PPSP_FFINDLIST GetPspFFindList(USHORT CurrPsp)
{
   PLIST_ENTRY    Next;
   PPSP_FFINDLIST pPspFFindEntry;

   Next = PspFFindHeadList.Flink;
   while (Next != &PspFFindHeadList) {
       pPspFFindEntry = CONTAINING_RECORD(Next,PSP_FFINDLIST,PspFFindEntry);
       if (CurrPsp == pPspFFindEntry->usPsp) {
           return pPspFFindEntry;
           }
       Next= Next->Flink;
       }

   return NULL;
}

#if defined(NEC_98)
// BUG fix for DBCS small alphabet in file name converted to large it.
extern int dbcs_first[];

void demCharUpper(char * pszStr)
{
        for(;*pszStr;)
        {
                if(dbcs_first[*pszStr&0xFF])
                {
                        pszStr++;
                        if(*pszStr == '\0')
                                break;
                }
                else
                {
                        if(*pszStr >= 'a' && *pszStr <= 'z')
                                *pszStr -= 0x20;
                }
                pszStr++;
        }
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\dosdef.h ===
/* dosdef.h - This file duplicates few important dos defines of use to
 *	      DEM.
 *
 * As these defines are not going to change at all, its better to give
 * DEM a separate copy and not share h and inc files between DOSKRNL and
 * DEM.
 *
 * Sudeepb 05-Apr-1991 Created
 */

#include <doswow.h>
#include <curdir.h>

/**	DEFINES 	**/

/**	File Attributes **/

#define ATTR_NORMAL          0x0
#define ATTR_READ_ONLY       0x1
#define ATTR_HIDDEN          0x2
#define ATTR_SYSTEM          0x4
#define ATTR_VOLUME_ID       0x8
#define ATTR_DIRECTORY       0x10
#define ATTR_ARCHIVE         0x20
#define ATTR_DEVICE          0x40

#define ATTR_ALL             (ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY)
#define ATTR_IGNORE          (ATTR_READ_ONLY | ATTR_ARCHIVE | ATTR_DEVICE)
#define DOS_ATTR_MASK        0x0037  // ATTR_DEVICE isn't used on 32 bit side.
                                     // ATTR_VOL maps to FILE_ATTRIBUTES_NORMAL.

/**	File Modes  **/

#define ACCESS_MASK	     0x0F
#define OPEN_FOR_READ	     0x00
#define OPEN_FOR_WRITE	     0x01
#define OPEN_FOR_BOTH	     0x02
#define EXEC_OPEN	     0x03  /* access code of 3 indicates that
				      open was made from exec */

#define SHARING_MASK         0x70
#define SHARING_COMPAT	     0x00
#define SHARING_DENY_BOTH    0x10
#define SHARING_DENY_WRITE   0x20
#define SHARING_DENY_READ    0x30
#define SHARING_DENY_NONE    0x40
#define SHARING_NET_FCB      0x70
#define SHARING_NO_INHERIT   0x80


/*	Volume Info **/

#define DOS_VOLUME_NAME_SIZE	11
#define NT_VOLUME_NAME_SIZE	255
#define FILESYS_NAME_SIZE    8

/*	IOCTLs	   **/

#define IOCTL_CHANGEABLE	8
#define IOCTL_DeviceLocOrRem	9
#define IOCTL_GET_DRIVE_MAP	0xE

/**     TYPEDEFS        **/

/** SRCHDTA defines the DTA format for FIND_FIRST/NEXT operations **/
#pragma pack(1)

typedef struct _SRCHDTA {               /* DTA */
    PVOID       pFFindEntry;          // 21 bytes reserved area begins
    ULONG       FFindId;
    BYTE        bReserved[13];        // 21 bytes reserved area ends
    UCHAR       uchFileAttr;
    USHORT      usTimeLastWrite;
    USHORT      usDateLastWrite;
    USHORT      usLowSize;
    USHORT      usHighSize;
    CHAR        achFileName[13];
} SRCHDTA;

#pragma pack()

typedef SRCHDTA UNALIGNED *PSRCHDTA;


/** SRCHBUF - defines DOS SEARCHBUF data structure which is used in
 *	      FCBFINDFIRST/NEXT operations.
 */

#pragma pack(1)

typedef struct _DIRENT {
    CHAR	FileName[8];
    CHAR	FileExt[3];
    UCHAR       uchAttributes;
    PVOID       pFFindEntry;         // DOS Reserved Area
    ULONG       FFindId;             // DOS Reserved Area
    USHORT      usDummy;             // DOS Reserved Area
    USHORT	usTime;
    USHORT	usDate;
    USHORT	usReserved2;		// Cluster Number in actual DOS
    ULONG	ulFileSize;
} DIRENT;

#pragma pack()

typedef DIRENT *PDIRENT;

#pragma pack(1)

typedef struct _SRCHBUF {
    UCHAR	uchDriveNumber;
    CHAR	FileName[8];
    CHAR	FileExt[3];
    USHORT	usCurBlkNumber;
    USHORT	usRecordSize;
    ULONG	ulFileSize;
    DIRENT	DirEnt;
} SRCHBUF;

#pragma pack()

typedef SRCHBUF *PSRCHBUF;


/** VOLINFO - GetSetMediaID data structure */

#pragma pack(1)

typedef struct _VOLINFO {
    USHORT	usInfoLevel;
    ULONG	ulSerialNumber;
    CHAR	VolumeID[DOS_VOLUME_NAME_SIZE];
    CHAR	FileSystemType[FILESYS_NAME_SIZE];
} VOLINFO;

#pragma pack()

typedef VOLINFO *PVOLINFO;


/** CDS LIST - CurrDirStructure (Moved to DOSWOW.H) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\demmsg.c ===
/* demmsg.c - debug messages handling for DEM
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 */
#if DBG

#include <stdio.h>
#include "demmsg.h"
#include "dem.h"

PCHAR   aMsg [] = {
    "DOS Location Not Found. Using Default.\n",
    "Read On NTDOS.SYS Failed.\n",
    "Open On NTDOS.SYS Failed.\n",
    "EAs Not Supported\n",
    "Letter mismatch in Set_Default_Drive\n",
    "Volume ID support is missing\n",
    "Invalid Date Time Format for NT\n",
    "DTA has an Invalid Find Handle for FINDNEXT\n",
    "Unexpected failure to get file information\n",
    "File Size is too big for DOS\n"
};


/* demPrintMsg - Print Debug Message
 *
 * Entry - iMsg (Message Index; See demmsg.h)
 *
 * Exit  - None
 *
 */

VOID demPrintMsg (ULONG iMsg)
{

    if (fShowSVCMsg){
       sprintf(demDebugBuffer,aMsg[iMsg]);
       OutputDebugStringOem(demDebugBuffer);
    }

    iMsg;

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\dem\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=mvdm
MINORCOMP=dem

TARGETNAME=dem
TARGETPATH=obj
TARGETTYPE=LIBRARY

W32_SB=1

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=\
    ..\..\..\inc;\
    $(WINDOWS_INC_PATH);\
    $(SOFTPC_TREE)\base\inc;\
    $(SOFTPC_TREE)\host\inc;\
    ..\..\..\vdd\h

SOURCES=..\dem.c       \
    ..\demfcb.c    \
    ..\demdata.c   \
    ..\demdir.c    \
    ..\demdisp.c   \
    ..\demerror.c  \
    ..\demfile.c   \
    ..\demgset.c   \
    ..\demhndl.c   \
    ..\demioctl.c  \
    ..\demlock.c   \
    ..\demmisc.c   \
    ..\demmsg.c    \
    ..\demsrch.c   \
    ..\demdasd.c   \
    ..\demlabel.c  \
    ..\demlfn.c

C_DEFINES=-DWIN_32

UMTYPE=console
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cleanup.inc ===
makedir:
!if "$(OBJ)" != ""
    @-if not exist $(OBJ) md $(OBJ)
!endif
!if "$(OBJINTL)" != ""
    @-if not exist $(OBJINTL) md $(OBJINTL)
!endif

clean: cleanup all

cleanup:
    -del *.bin *.sys *.obj *.sym *.map *.exe *.exc *.exs *.cl* *.ctl *.com 2>nul
!if "$(OBJ)" != ""
    if exist $(OBJ)\*.obj del $(OBJ)\*.obj
!endif
!if "$(OBJINTL)" != ""
    if exist $(OBJINTL)\*.obj del $(OBJINTL)\*.obj
    if exist $(OBJINTL)\*.cl* del $(OBJINTL)\*.cl*
    if exist $(OBJINTL)\*.ctl del $(OBJINTL)\*.ctl
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\appendm.asm ===
page	60,120
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;      @@04 07/30/86 Fix second APPEND hang		 PTM P0000053
;      @@05 08/13/86 Fix bad parm message		PTM P0000125
;      @@10 08/28/86 Change message for @@05		PTM P0000291
;      @@11 09/10/86 Support message profile and make
;		     msg length variable.	R.G. PTM P0000479
cseg	segment public para 'CODE'
	assume	cs:cseg

	public	bad_append_msg			;@@11
	public	path_error_msg			;@@11
	public	parm_error_msg			;@@11
	public	path_parm_error_msg		;@@11
	public	no_append_msg			;@@11
	public	append_assign_msg		;@@11
	public	append_tv_msg			;@@11
	public	bad_DOS_msg			;@@11
	public	second_append_msg		;@@11

	public	len_bad_append_msg		;@@11
	public	len_path_error_msg		;@@11
	public	len_parm_error_msg		;@@11
	public	len_path_parm_error_msg 	;@@11
	public	len_no_append_msg		;@@11
	public	len_append_assign_msg		;@@11
	public	len_append_tv_msg		;@@11
	public	len_bad_DOS_msg 		;@@11
	public	len_second_append_msg		;@@11

cr	equ	13
lf	equ	10

include appendm.inc

cseg		ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\appendp.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

INCSW	EQU	0			;INCLUDE PSDATA.INC			;AN000;
FARSW	EQU	1			;CALL THE PARSER BY NEAR CALL
DATESW	EQU	0			;SUPPRESS DATE CHECKING 		;AN000;
TIMESW	EQU	0			;SUPPRESS TIME CHECKING 		;AN000;
FILESW	EQU	0			;SUPPRESS CHECKING FILE SPECIFICATION	;AN000;
CAPSW	EQU	0			;SUPPRESS FILE TABLE CAPS		;AN000;
CMPXSW	EQU	1			;SUPPRESS CHECKING COMPLEX LIST
DRVSW	EQU	1			;SUPPRESS SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT ;AN000;
NUMSW	EQU	1			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT		;AN000;
SWSW	EQU	1			;DO SUPPORT SWITCHES			;AN000;
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1 ;AN000;
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2 ;AN000;
VAL3SW	EQU	1			;DO SUPPORT VALUE DEFINITION 3

include psdata.inc
;***********************************************************************

;-------------------------------------------------------------------
;
;	parser stuff for APPEND
;
;-------------------------------------------------------------------



p_block1  $P_PARMS_Blk <offset px_block1, 0, 0>    ; parm block
p_block2  $P_PARMS_Blk <offset px_block2, 0, 0>    ; parm block

;------------------------
;	extended parameter block for APPEND first load

px_block1:
	db	0		; min number positional operands
	db	0		; max number positional operands
;	dw	0		; offset into control block for positionals

	db	4		; APPEND has two switches /E, /X, /PATH, /?
	dw	offset e_switch 	; control block for /E switch
	dw	offset x_switch 	; control block for /X switch
	dw	offset qu_switch        ; " " for /? switch
	dw	offset path_switch	; control block for /PATH switch

	db	0		; max number of keywords
	dw	0		; offset of keyword control block

;------------------------
;	extended parameter block for 2nd, 3rd, ... APPEND invocations

px_block2:
	db	0		; min number positional operands
	db	1		; max number positional operands
	dw	offset dirs_control	; pointer to dirs control block

;	db	2		; APPEND after first load has two switches /X, /PATH
	db	4		; APPEND has two switches /E, /X, /PATH
	dw	offset e_switch 	; control block for /E switch
	dw	offset x_switch 	; control block for /X switch
	dw	offset qu_switch        ; " " for /? switch
	dw	offset path_switch	; control block for /PATH switch

	db	0		; max number of keywords

;------------------------
dirs_control:
	dw	$P_Simple_S+$P_Optional   ; complex, optional string
	dw	$P_CAP_File		; cap by file table
	dw	offset dirs_result	; dirs result buffer
	dw	offset dirs_values	; pointer to null value list
	db	0			; no synonyms

dirs_values:
	db	0			; null value list for dirs



;------------------------
x_switch:
	dw	$P_Simple_s+$P_Optional       ; /X, /X:ON, /X:OFF simple, optional string
	dw	$P_CAP_Char		; cap by char table
	dw	offset x_result 	; pointer to result block
	dw	offset x_values 	; pointer to values block
	db	1			; number of switches and synonyms
	db	"/X",0                  ; only /X is valid

x_values:
	db	3			; string values
	db	0			; zeroes here for ranges and
	db	0			; values
	db	2			; 2 possible string values
	db	0			; /X:OFF = 0
	dw	offset off_string	; pointer to "OFF"
	db	1			; /X:ON  = 1
	dw	offset on_string
;------------------------

e_switch:
	dw	0			; /E
	dw	$P_CAP_Char		; cap by char table
	dw	offset e_result 	; pointer to result block
	dw	offset e_values 	; pointer to values block, none
	db	1			; number of switches and synonyms
	db	"/E",0                   ; only /E is valid

e_values:
	db	0			; null value list for /E


;------------------------

qu_switch:
	dw      1                       ; optional
	dw	0
	dw	offset qu_result 	; pointer to result block
	dw	offset qu_values 	; pointer to values block, none
	db	1			; number of switches and synonyms
	db	"/?",0                   ; only /? is valid

qu_values:
	db	0			; null value list for /E



path_switch:
	dw	$P_Simple_s		; /PATH:ON, /PATH:OFF simple string
	dw	$P_CAP_Char		; cap by char table
	dw	offset path_result	; pointer to result block
	dw	offset path_values	; pointer to values block
	db	1			; number of switches and synonyms
	db	"/PATH",0                ; only /PATH is valid


path_values:
	db	3			; string values
	db	0			; zeroes here for ranges and
	db	0			; values
	db	2			; 2 possible string values
	db	0			; /PATH:OFF = 0
	dw	offset off_string	; pointer to "OFF"
	db	1			; /PATH:ON  = 1
	dw	offset on_string


;------------------------

off_string:
	db	"OFF",0                 ; off string

on_string:
	db	"ON",0                  ; on string


;------------------------

x_result	$P_Result_Blk <>	; /X result block
e_result	$P_Result_Blk <>	; /E result block
qu_result       $P_Result_Blk <>        ; /? result block
path_result	$P_Result_Blk <>	; /PATH result block
dirs_result	$P_Result_Blk <>	; dirs result block



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\make.inc ===
!include $(NTMAKEENV)\makefile.plt

# Common makefile defines for DOSKRNL (NTIO.SYS and NTDOS.SYS) and utilities
#
# Created Sudeepb 20-Mar-1991

MAKE	=nmake

!IFNDEF ALT_PROJECT
ALT_PROJECT=usa
ALT_PROJECT_TARGET=.
!ENDIF

msg = ..\..\messages\$(ALT_PROJECT)

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEST=$(ALT_PROJECT)\obj\i386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEST=$(ALT_PROJECT)\obj\alpha
!endif

inc	=..\..\inc
cinc	=..\..\..\..\inc

#############################################################################
#                                                                           #
# These are the built in rules and path definitions used by the new MS Make #
# Utility (NMAKE). The following variables are set externaly (ie set in the #
# individual makefiles.                                                     #
#                                                                           #
# extasw = The 'extra assembly switch' variable is optionaly used in the    #
#          makefile to specify special MASM command line switches.          #
#                                                                           #
# extcsw = The 'extra C switch' variable is optionaly used in the makefile  #
#          to specify special C compiler command line switches.             #
#                                                                           #
# inc    = The include file search path from the utility being built to the #
#          INC directory. Used if needed.                                   #
#                                                                           #
# hinc   = The include file search path from the utility being built to the #
#          H directory. Used if needed for C source compilation.            #
#                                                                           #
#############################################################################

########## Definitions for the Assembler      #####
########## awarn can be overridden by placing #####
##########    the new warning level in extasw #####
##########    in the makefile                 #####

asm     =masm386
awarn	=-W1
!if "$(ALT_PROJECT)" == "JPN" || "$(ALT_PROJECT)" == "KOR"
aflags  =-Mx -t $(awarn) $(extasw) $(DBCS_FLAGS) -DBILINGUAL
!else
aflags  =-Mx -t $(awarn) $(extasw) $(DBCS_FLAGS)
!endif
ainc    =-I. -I..\..\inc -I..\..\..\..\inc -I$(msg) -I$(DEST)

########## Definitions for C compiler         #####
########## cwarn can be overridden by placing #####
##########    the new warning level in extcsw #####
##########    in the makefile                 #####

cc      =cl16
cwarn   =-W3
cflags  =-Os -Zp $(cwarn) $(extcsw) $(DBCS_FLAGS) /Zl

incc	=-I. -I..\..\h

########## Definitions for linker ##########

link_opts = /MAP
LINK    =link16
exelink =/E

########## Definitions for compress ##########

compress =compress

########## Path definition so we find 16 bit tools ##########
# Also works around bug in RC 3.1 that doesn't allow rcpp.err to be
# in a directory that is greater than 128 chars down the path, even if
# rc 3.1 is running as an OS/2 app.

PATH    = $(BASEDIR)\tools\tools16;$(PATH)

########## Built-in rules ##########

.SUFFIXES:
.SUFFIXES: .c .obj .lst .exe .exc .exs .com .sal .cod .sil .inc .skl .cla .cl1 .ctl .asm .idx .msg

.sal.asm:
        salut $*.sal,nul,$*.asm

.asm{$(DEST)}.obj:
        $(asm) $(ainc) $(aflags) $(<F),$*.obj;

.asm{$(DEST)}.lst:
        $(asm) -l $(ainc) $(aflags) $(<F),$*.obj;

.asm{$(DEST)}.obj:
        $(asm) $(ainc) $(aflags) $<,$*.obj;

.asm{$(DEST)}.lst:
        $(asm) -l $(ainc) $(aflags) $<,$*.obj;

.asm.obj:
        $(asm) $(ainc) $(aflags) $*.asm;

.asm.lst:
        $(asm) -l $(ainc) $(aflags) $*.asm;

.c{$(DEST)}.obj:
        $(cc) -c $(incc) $(cflags) -Fo$*.obj $<

.c{$(DEST)}.lst:
        $(cc) -c $(incc) $(cflags) -Fc$*.cod -Fo$*.obj $<

.c{$(DEST)}.obj:
        $(cc) -c $(incc) $(cflags) -Fo$*.obj $<

.c{$(DEST)}.lst:
        $(cc) -c $(incc) $(cflags) -Fc$*.cod -Fo$*.obj $<

.c.obj:
	$(cc) -c $(incc) $(cflags) $*.c

.c.lst:
	$(cc) -c $(incc) $(cflags) -fc$*.cod -fo$*.obj $*.c

{$(DEST)}.exs{$(DEST)}.sys:
        copy $*.exs $*.exe
        reloc $* $*.sys
        del $*.exe

{$(DEST)}.exc{$(DEST)}.com:
        copy $*.exc $*.exe
        reloc $* $*.com
        del $*.exe

.exs.sys:
        copy $*.exs $*.exe
        reloc $* $*.sys
        del $*.exe

.exc.com:
        copy $*.exc $*.exe
        reloc $* $*.com
        del $*.exe

.exe.com:
        convert $*.exe

{$(ALT_PROJECT)}.skl{$(DEST)}.cl1:
        cd $(DEST)
        copy ..\..\$(<F)
        -nosrvbld $(<F) ..\..\..\$(msg)\$(ALT_PROJECT).msg
        -nosrvbld $(<F) ..\..\..\$(msg)\$(ALT_PROJECT).msg
        erase $(<F)
        cd ..\..\..

{$(ALT_PROJECT)}.skl{$(DEST)}.ctl:
        cd $(DEST)
        buildmsg ..\..\..\$(msg)\$(ALT_PROJECT) ..\..\$(<F)
        cd ..\..\..


{$(ALT_PROJECT)}.skl{$(DEST)}.cla:
        cd $(DEST)
        buildmsg ..\..\..\$(msg)\$(ALT_PROJECT) ..\..\$(<F)
        cd ..\..\..

.sil.inc:
	salut $*.sil,nul,$*.inc

.sal.obj:
	salut $*.sal,nul,$*.asm
	$(asm) $(aflags) $(ainc) $*.asm,$*.obj;

.msg.idx:
        chmode -r $*.msg
        buildidx $*.msg
        chmode +r $*.msg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\append.asm ===
page	60,120
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
.sall
title	APPEND
include sysmsg.inc
include version.inc
msg_utilname<APPEND>
;-----------------------------------------------------------------------------
;
;      Title:	       APPEND
;
;      Author:	       G. G. A. 		     Network version
;		       B. A. F.`		     DOS changes
;
;      Syntax:	       From the DOS command line:
;
;		       APPEND [d:]path[[;[d:]path]...]
;			     - Used to specify the directories to be
;			       searched after the working directory.
;
;		       APPEND ;
;			     - Used to release all appended directories.
;
;		       APPEND
;			     - Used to show appended directories.
;
;		       First time only:
;
;		       APPEND  [[d:]path |  | /X | /E | /X /E]
;			     - [d:]path Normal support and Set path
;			     -		Normal support
;			     - /X	Extended support, SEARCH, FIND and EXEC
;			     - /E	Use DOS Environment for path(s)
;
;      Revision History:
;      @@01 07/11/86 Fix hang in TopView start			    PTM P00000??
;      @@02 07/28/86 Fix APPEND size problem			    PTM P0000045
;      @@03 07/29/86 Fix APPEND status with /E problem		    PTM P00000??
;      @@04 07/30/86 Fix second APPEND hang			    PTM P0000053
;      @@05 08/13/86 Fix parameter error			    PTM P0000125
;      @@06 08/20/86 Fix APPEND xxx fails in TopView		    PTM P0000217
;      @@07 08/21/86 Resurrect APPEND version message		    PTM P0000252
;      @@08 08/21/86 APPEND=path first time hangs		    PTM P0000254
;      @@09 08/22/86 APPEND gets wrong path under nested COMMAND    PTM P0000276
;      @@10 08/28/86 Change message for @@05			    PTM P0000291
;      @@11 09/10/86 Support message profile and make
;		     msg length variable.	R.G.		    PTM P0000479
;      @@12 09/25/86 Allow second external append call. (RG)	    PTM P0000515
;      @@13 09/30/86 APPEND gets wrong path under nested COMMAND    PTM P0000600
;		     Again. Fix in COMMAND now, so remove @@09 changes
;      @@14 10/01/86 Lower case drive in path files		    PTM P0000600
;      @@15 10/06/86 Include "," and "=" in skip leading of
;		     argument area parsing.			    PTM P0000677
;      @@16 10/06/86 Fix not using full APPEND path		    PTM P0000794
;      @@17 12/03/86 When searching for "APPEND=" string in
;		     environment, make sure delimiter precedes.(RG) PTM P0000893
;
;-------------------------------------------------------------------
;
;      AN000	     3.30 changes, GGA 6/87 new code.			P000
;      AN001	     Support DRIVE and PATH modes			D043
;      AN002	     Add truename function				P1276
;      AN003	     Add extended handle open function			D250
;      AN005
;      AN006	     Add DBCS support
;      AN007	     Release Environmental Vector space 		P2666
;      AN008	     Allow equal symbol with append - APPEND=A:/1;	P2901
;      AN009	     Release Environmental Vector on only the		P3333
;		     first invocation of APPEND
;      AN010	     display invalid parm from command line		P3908
;
;
;-----------------------------------------------------------------------------
;Date	       Rev     Comments
;-----------------------------------------------------------------------------
;06-02-86      0.0     Begin conversion to PC/DOS version
;06-20-86      0.0     End conversion to PC/DOS version
;
page

cseg		segment public para 'CODE'
		assume	cs:cseg
		assume	ds:nothing,es:nothing

;-----------------------------------------------------------------------------
;	Equates
;-----------------------------------------------------------------------------

.xlist
;include fsi.lib
NETSYSUTIL   EQU  0C2H			; SYSTEM UTILITIES
NETENQ	     EQU  07H			; ENQ RESOURCE
NETDEQ	     EQU  08H			; DEQ RESOURCE
;include task.lib
TCBR_APPEND	EQU	   001H 	; APPEND ACTIVE
;include DOS.lib
DOSSERVER    EQU  5DH			; SERVER OPERATION
DOSSETERROR  EQU  0AH			; SET EXTENDED ERROR
;include server.lib
DPL		STRUC
DPL_AX		DW	0		;AX REG
DPL_BX		DW	0		;BX REG
DPL_CX		DW	0		;CX REG
DPL_DX		DW	0		;DX REG
DPL_SI		DW	0		;SI REG
DPL_DI		DW	0		;DI REG
DPL_DS		DW	0		;DS REG
DPL_ES		DW	0		;ES REG
DPL_XID 	DW	0		;RESERVED
DPL_UID 	DW	0		;SERVER USER ID
DPL_PID 	DW	0		;REDIRECTOR PROCESS ID
DPL		ENDS
include sysmac.lib
include versiona.inc
include appendp.inc			; parseing stuff for append			 ;AN004;
.list
;		extrn	end_address:near	; end of stay resident stuff

;		extrn	bad_append_msg:byte	; messages
;		extrn	path_error_msg:byte
;		extrn	parm_error_msg:byte
;		extrn	path_parm_error_msg:byte
;		extrn	no_append_msg:byte		; @@05
;		extrn	append_assign_msg:byte
;		extrn	append_TV_msg:byte		; @@01
;		extrn	bad_DOS_msg:byte
;		extrn	second_APPEND_msg:byte		; @@04

;		extrn	len_bad_append_msg:word 	;@@11
;		extrn	len_path_error_msg:word 	;@@11
;		extrn	len_parm_error_msg:word 	;@@11
;		extrn	len_path_parm_error_msg:word	;@@11
;		extrn	len_no_append_msg:word		;@@11
;		extrn	len_append_assign_msg:word	;@@11
;		extrn	len_append_TV_msg:word		;@@11
;		extrn	len_bad_DOS_msg:word		;@@11
;		extrn	len_second_APPEND_msg:word	;@@11

;	Environmental Vector

PSP_Env 	equ	2ch		;Environmental vector segment in PSP	;an007; dms;

;	Interrupts

DOS_function	equ	21h		; DOS function call interrupt
int_function	equ	2fh		; DOS internal function interrupt, used
					; to verify APPEND presence
termpgm 	equ	20h						; @@05
resident	equ	27h

;	Function calls

get_vector	equ	3521h		; DOS function call to get INT 21 vector
set_vector	equ	2521h		; DOS function call to set INT 21 vector
get_intfcn	equ	352fh		; DOS function call to get INT 2f vector
set_intfcn	equ	252fh		; DOS function call to set INT 2f vector
get_version	equ	30h		; DOS function call to get DOS version number
get_DTA 	equ	2fh		; DOS function get DTA
set_DTA 	equ	1ah		; DOS function set DTA
get_crit_err	equ	3524h		; DOS function call to get INT 24 vector
set_crit_err	equ	2524h		; DOS function call to set INT 24 vector
get_PSP 	equ	62h		; DOS function call to get PSP address
Free_Alloc_Mem	equ	49h		; DOS function call to free alloc. mem. ;an007; dms;

print_string	equ	09h		; DOS function call to get print a string
ctrl_break	equ	33h		; DOS function call to get/set ctrl-break

awrite		equ	40h		; write function
get_dir 	equ	47h		; get current dir
change_dir	equ	3bh		; change dir
get_disk	equ	19h		; get current disk
change_disk	equ	0eh		; change disk
term_stay	equ	31h		; terminate a process and stay resident
term_proc	equ	4ch		; terminate a process

redir_flag	equ	0000000000001000B ; redir flag for net installation check

;	DOS INT 2f function for APPEND presence

append_2f	equ	0b7h		; int 2f function code for append
applic_2f	equ	0aeh		; int 2f function code for applications
COMMAND_2f	equ	-1		; int 2f subfunction code for COMMAND call
append_inst	equ	0ffh		; flag means append is there

;	INT 2f sub-function codes						;AN000;

are_you_there	equ	0		; function code for presence check
old_dir_ptr	equ	1		; means APPEND 1.0 is trying to run
get_app_version equ	2		; fun code for get ver request
tv_vector	equ	3		; fun code for set TV vector
dir_ptr 	equ	4		; function code to return dirlist ptr
get_state	equ	6		; function code to return append ;AN001;
					; state 			 ;AN001;
set_state	equ	7		; function code to set append	 ;AN001;
					; state 			 ;AN001;

DOS_version	equ	10h		; function call to get DOS version
true_name	equ	11h		; one-shot truename fcn for ASCIIZ ops ;AN002;

;	DOS INT 21 function calls that APPEND traps

FCB_opn 	equ	0fh
file_sz 	equ	23h
handle_opn	equ	3dh
dat_tim 	equ	57h
FCB_sch1	equ	11h
handle_fnd1	equ	4eh
exec_proc	equ	4bh
ext_handle_opn	equ	6ch								  ;AN003;

break	macro			; this is a dummy break macro so PDB.INC
	endm			; won't blow up in the build

;	define some things for PDB (PSP)						  ;AN002;
											  ;AN002;
include pdb.inc 									  ;AN002;
											  ;AN002;
true_name_flag		equ	01h	; flag for true name function			  ;AN002;
eo_create		equ	00f0h	; mask to check extended opens for create	  ;AN003;

;	Error codes that don't mean stop looking

FCB_failed		equ	0ffh	; FCB open failed
FCB_file_not_found	equ	2	; file not found on FCB open
handle_file_not_found	equ	2	; file not found on handle open
handle_path_not_found	equ	3	; path not found on handle open
FCB_no_more_files	equ	18	; no more matching files
handle_no_more_files	equ	18	; no more matching files

;	Equates for TOPVIEW barrier
TV_TRUE equ	-1			; this was changed from TRUE	 ;AN000;
					; because 3.30 parser uses TRUE  ;AN000;
false	equ	0			;

;	Message equates

tab_char equ	9
cr	equ	13
lf	equ	10
beep	equ	7
STDOUT	equ	0001h			; standard output file
STDERR	equ	0002h			; standard error file
null	equ	0

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     316

page

;-----------------------------------------------------------------------------
;	Resident data area
;-----------------------------------------------------------------------------

version_loc:				; version number
	db	major_version,minor_version
;	 dw	 message_list		 ; pointer to message table

		even
vector_offset	dw	0		; save pointer to old int 21 here
vector_segment	dw	0
crit_vector_offset  dw	0		; save pointer to old int 24 here
crit_vector_segment dw	0
intfcn_offset	dw	0		; save pointer to old int 2f here
intfcn_segment	dw	0
dirlst_offset	dw	0		; save pointer to dir list here
dirlst_segment	dw	0
tv_vec_off	dw	0		; save TV vector here
tv_vec_seg	dw	0

pars_off	dd	cseg: SysParse	; save pointer to parser here
;pars_off	 dw	 offset SysParse ; save pointer to parser here
;pars_seg	 dw	 0

app_dirs_seg	dw	0		; save ES here during FCB

FCB_ptr 	dd	0		; save pointer to FCB here
handle_ptr	dd	0		; save pointer to ASCIIZ string here

stack_offset	dw	0
stack_segment	dw	0		; Calling process stack

incoming_AX	dw	0		; AX saved at entry to interrupt handler
incoming_CX	dw	0		; CX saved at entry to interrupt handler
; must be together
incoming_BX	dw	0		; BX saved at entry to interrupt handler
incoming_ES	dw	0		; ES saved at entry to interrupt handler
; must be together
ax_after_21	dw	0		; AX saved after call to real INT 21
; temp_DS_save	  dw	  0		  ; DS saved during stack ops
temp_CS_save	dw	0		; CS saved during stack ops (set_return_flags)
temp_IP_save	dw	0		; IP saved during stack ops (set_return_flags)
FCB_drive_id	db	0		; save the drive id for FCB opens here

;------------------------
;	DBCS stuff here 								 ;AN006;
											 ;AN006;
DBCSEV_OFF	DW	0		; OFFSET OF DBCS EV				 ;AN006;
DBCSEV_SEG	DW	0		; SEGMENT OF DBCS EV				 ;AN006;
											 ;AN006;
;DEFAULT DBCS ENVIRONMENTAL VECTOR							 ;AN006;
EVEV	DB	00H,00H 								 ;AN006;
	DB	00H,00H 								 ;AN006;
	DB	00H,00H 								 ;AN006;
											 ;AN006;
dbcs_fb 	dw	0		; offset of DBCS first byte chars found
;------------------------

initial_pass	dw	0		; flag used to indicate inital APPEND		 ;AN007;

incoming_DX	dw	0		; used for saves for extended open		  ;AN003;
incoming_SI	dw	0		; used for saves for extended open		  ;AN003;
incoming_DI	dw	0		; used for saves for extended open		  ;AN003;
incoming_DS	dw	0		; used for saves for extended open		  ;AN003;
true_name_count dw	0		; used to save number of chars in true_name dir   ;AN003;

int_save_ip	dw	0		; save registers here during critical
int_save_cs	dw	0		; error handler stack ops

work_disk	db	"?:\"		; user's working disk
work_dir	db	64 dup(" ")	; user's working dir
app_disk	db	"?:\"		; user's working disk
app_dir 	db	64 dup(" ")	; user's append disk's working dir
ctrl_break_state db	0		; save the old ctrl-break state here

end_search	db	0		; end search flag
try_dir 	db	128 dup (0)	; try this dir
fname		db	15 dup (0)	; 8.3 filename stripped from original
					; ASCIIZ string
app_dirs_ptr	dw	0		; pointer to appended dir to try

set_name	db	"SET     "	; SET command
; must be together
setappend_name	db	"SET "		; SET command
append_id	db	"APPEND="	; display from here for user
; must be together
app_dirs	db	";"
		db	128 dup (0)	; area for storing appended dirs
		db	0		; just to insure that the last dir is null terminated
semicolon	db	";",0		; null list

;	Flags / barriers added for TopView

tv_flag 	db	0		; flag to indicate re-entr from TopView

parse_flag	db	0		; flag used by APPEND parsing

FCB_ext_err	db	0		; flag used to indicate that FCB
					; open failed and ext err was done
crit_err_flag	db	0		; flag used to indicate that a critical
					; error happened
ext_err_flag	db	0		; flag used to indicate that ext err
					; must be set 0 = don't set, 1 = do set
in_middle	db	0		; flag used to tell if we made it to
					; middle of string before finding a space
equal_found	db	0		; multiple = check
;crit_sect_flag  db	 0		 ; critical section flag

stack_area	dw	99 dup(0)	; stack area for append
append_stack	dw	0

net_config	dw	0		; flag word for what (if any) network
					; config we are running under
					; as long as this word is zero, a clear determination
					; has not been made about the configuration

		even
ext_err_dpl	DPL	<>		; reserve a DPL for get/set extended error code


save_ext_err	DPL	<>		; reserve a DPL for first extended
					; error code

;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;
;	mode_flags	This status word is used to control the various  ;AN001;
;			APPEND functions and modes.			 ;AN001;
;									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
mode_flags	dw	Path_mode + Drive_mode + Enabled		 ;AN001;
					; mode control flags		 ;AN001;
					; initially - path, drive and	 ;AN001;
					; enabled			 ;AN001;

;	equates for mode_flags follow:					 ;AN001;

X_mode		equ	8000h		; in /X mode
E_mode		equ	4000h		; in /E mode
Path_mode	equ	2000h		; PATH in string OK		 ;AN001;
Drive_mode	equ	1000h		; DRIVE in string OK		 ;AN001;
Enabled 	equ	0001h		; APPEND enabled		 ;AN001;

;-------------------------------------------------------------------

cmd_name@	dd	?		; internal name string

expected_error	dw	?		; error to do append scan
expected_ext_error dw	?		; error to do append scan

cmd_env 	dw	?		; pointer to COMMANDs environment
cmd_buf 	dw	?		; CMDBUF offset (in SS)

incoming_DTA	dd	?		; user's DTA (on EXEC)
exec_DTA	db	21+1+2+2+2+2+13 dup(0)	; find DTA for exec emulation

old_syntax	db	0		; using network syntax

res_append	db	0		; resident append call		  ; @@05

abort_sp	dw	?		; sp to restore on errors	  ; @@05

crlf	label	byte
	db	CR,LF
crlf_len equ	 $ - crlf

;*******************************************************************		;an010;bgb
; parser message display area							;an010;bgb
;*******************************************************************		;an010;bgb
inv_parm    db	0bh	;length 						;an010;bgb
	    db	0	;reserved						;an010;bgb
si_off	    dw	0	;put offset of command line here			;an010;bgb
si_seg	    dw	0	;put segment of command line here			;an010;bgb
	    db	0	;use percent zero					;an010;bgb
	    db	Left_Align+Char_Field_ASCIIZ ;type of data			;an010;bgb
	    db	128			;max width				;an010;bgb
	    db	1			;min width				;an010;bgb
	    db	' '			;pad char				;an010;bgb

;-------------------------------------------------------------------
;
;	resident message area
;
;-------------------------------------------------------------------

MSG_SERVICES <MSGDATA>
MSG_SERVICES <DISPLAYmsg,CHARmsg>						;an010;bgb
MSG_SERVICES <APPEND.CLA,APPEND.CL1,APPEND.CTL>

.xlist
;-----------------------------------------------------------------------------
;	macros
;-----------------------------------------------------------------------------

;-----------------------------
;	save and restore register macros
save_regs macro
	push	bx
	push	cx
	push	dx

	push	di
	push	si
	push	ds
	push	es
	endm

restore_regs macro
	pop	es
	pop	ds
	pop	si
	pop	di

	pop	dx
	pop	cx
	pop	bx
	endm

;-----------------------------
;	this macro is used instead of the normal POPF instruction to help
;	prevent a 286 bug from occurring
popff	macro
	local	myret
	jmp	$+3
myret	label	near
	iret
	push	cs
	call	myret
	endm

;-----------------------------						  ; @@12
;	check character 						  ; @@12
;									  ; @@12
chkchar macro	char							  ; @@12
	lodsb								  ; @@12
	and	al,0dfh 						  ; @@12
	cmp	al,char 						  ; @@12
	jne	ccn_ret 						  ; @@12
	endm								  ; @@12
.list

page
;-----------------------------------------------------------------------------
;	resident routine - control transferred here on INT 21
;	check to see if this call has a function code we are interested in
;-----------------------------------------------------------------------------


tv_entry:
	pushf								  ; @@01
	jmp	SHORT  check_fcb_open						  ; @@01

interrupt_hook:
resident_routine:
	pushf				; save the user's flags (old stack)

	cmp	tv_flag,TV_TRUE 	; see if in TV			 ;AN000;
	je	use_old 		; yes, old_vect

check_fcb_open: 							  ; @@01

;-------------------------------------------------------------------	 ;AN001;
;	first, check to see if APPEND disabled, if so, skip everything	 ;AN001;
;	and go to real INT 21 handler					 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
	test	mode_flags,Enabled	; APPEND disabled?		 ;AN001;
	jz	real_jump		; yes, skip all other checks	 ;AN001;

	cmp	ah,FCB_opn		; FCB open?
	jump	E,FCB_open		; yes, do the APPEND

	cmp	ah,handle_opn		; handle open?
	jump	E,handle_open		; yes, do the APPEND

	cmp	ah,ext_handle_opn	; extended handle open? 			  ;AN003;
	jump	E,ext_handle_open	; yes, do the APPEND				  ;AN003;
											  ;AN003;
	cmp	ah,file_sz		; file size?
	je	FCB_open		; yes, do the APPEND


	test	mode_flags,X_mode	; /X mode not selected
	jz	real_jump

	call	IsItFCB_FindFirst?
	je	FCB_search1

;------ following two lines replaced by the above to lines of code Bug #121
;	 cmp	 ah,FCB_sch1		 ; search?
;	 jump	 E,FCB_search1		 ; yes, do the APPEND
;--------------------------------------------------------------------------

	call	IsItHandle_FindFirst?
	jump	E, handle_find1

;------ following two lines replaced by the above to lines of code Bug #121
;	 cmp	 ah,handle_fnd1 	 ; find?
;	 jump	 E,handle_find1 	 ; yes, do the APPEND
;--------------------------------------------------------------------------

	cmp	tv_flag,TV_TRUE 	; cant do in TopView		 ;AN000;
	je	skip_exec
	cmp	ax,exec_proc*256+0	; EXEC?
	jump	E,exec_pgm		; yes, do the APPEND
skip_exec:
	cmp	ax,exec_proc*256+3	; EXEC?
	jump	E,exec_pgm		; yes, do the APPEND

	page
;-----------------------------------------------------------------------------
;	By here, we know that the call was not one we are interested in,
;	pass through to old INT 21.
;	Since this is done with a jmp, control will pass back to original caller
;	after DOS is finished.
;-----------------------------------------------------------------------------

real_jump:
	cmp	tv_flag,TV_TRUE 	; see if called by TV		 ;AN000;
	jne	use_old 		; yes, use old vect

	popff				; restore user's flags
	jmp	dword ptr tv_vec_off	; pass through to TV

use_old:
	popff				; restore user's flags (old stack)
	jmp	dword ptr Vector_Offset ; jump to old INT 21

page
;-----------------------------------------------------------------------------
; New functions added to resolve Bug #121
; IsItFCB_FindFirst?
; IsItHandle_FindFirst?
;-----------------------------------------------------------------------------
VOL_LABEL	equ	08h
IsItFCB_FindFirst?	proc	near
		cmp	ah, FCB_sch1		; search?
		jne	not_FCB_FindFirst
		push	bx
		mov	bx, dx			; ds:bx == ptr to FCB
		cmp	byte ptr [bx], 0ffh	; extended FCB ?
		jne	FCB_FindFirst
		test	byte ptr [bx+6], VOL_LABEL	; search for label ?
		pop	bx
		ret
FCB_FindFirst:
		pop	bx			; restore BX (bug #1027)
		cmp	al, al
not_FCB_FindFirst:
		ret
IsItFCB_FindFirst?	endp
;
;----------------- This routine can be made in line MOHAN
;
IsItHandle_FindFirst?	proc	near
		cmp	ah, handle_fnd1 	; handle find ?
		jne	not_Handle_FindFirst
		test	cl, VOL_LABEL
not_Handle_FindFirst:
		ret
IsItHandle_FindFirst?	endp
;
page
;-----------------------------------------------------------------------------
;	FCB_search1 - this routine handles FCB search first calls
;-----------------------------------------------------------------------------

FCB_search1:
	mov	expected_ext_error,fcb_no_more_files
	jmp	short FCB_openx1

;-----------------------------------------------------------------------------
;	FCB_open - this routine handles FCB open calls
;-----------------------------------------------------------------------------

FCB_open:
	mov	expected_ext_error,fcb_file_not_found
FCB_openx1:
	call	check_config		; check the config flags
	call	crit_sect_set		; set critical section flag

	call	tv_barrier

	mov	incoming_AX,ax		; save user's AX
	mov	word ptr FCB_ptr+0,dx	; save FCB pointer
	mov	word ptr FCB_ptr+2,ds

	popff				; restore user's flags
	call	int_21			; try the open

	cli
	mov	AX_after_21,ax		; save AX as it came back from INT
	pushf				; save flags from operation
	cmp	al,FCB_failed		; open failed ?
	je	check_error		; yes, lets check extended error
	jmp	set_return_flags	; no, fix the stack, then ret to caller

check_error:
	call	get_ext_err_code	; get the extended error code
	mov	FCB_ext_err,1		; set FCB ext error
	call	save_first_ext_err	; save first extended error code
	mov	ax,ext_err_dpl.DPL_AX	; get error in ax
	cmp	ax,expected_ext_error	; file not found?
	je	FCB_openx2		; yes, lets look around for file
	lea	dx,save_ext_err 	;
	call	set_ext_err_code	; set the extended error code
	jmp	set_return_flags	; no, fix the stack, then return

FCB_openx2:

;	set up APPEND's stack

	popff				; get rid of the flags from the
					; real operation
;	mov	temp_DS_save,ds 	; Save DS reg
	mov	stack_segment,ss	; Save it
	mov	stack_offset,sp 	; Save it
	mov	ax,cs			; Get current segment
	mov	ss,ax			; and point stack seg here
	lea	sp,append_stack 	; set up new stack

	save_regs			; save registers

	push	cs			; establish addressability
	pop	ds

	call	ctrl_break_set		; set ctrl-break handler
	call	crit_err_set		; set crit err handler

	mov	ext_err_flag,1		; flag for setting critical error

;	fix FCB drive spec

	les	bx,dword ptr FCB_ptr	; ES:BX points to FCB
	mov	ah,ES:byte ptr [bx]	; get FCB drive spec
	cmp	ah,-1			; extended FCB?
	jne	not_ext_FCB1
	add	bx,1+5+1		; point to real drive letter
	mov	ah,ES:byte ptr [bx]	; get FCB drive spec

not_ext_FCB1:
	mov	FCB_drive_id,ah 	; save it for later
	mov	ES:byte ptr [bx],0	; zero the drive field out to
					; use default drive

	mov	ah,get_disk		; get disk
	call	int_21			; call DOS INT 21 handler

	add	al,"A"			; make it a character
	mov	work_disk,al		; save it

	mov	ah,get_dir		; get directory
	xor	dx,dx			; default drive
	lea	si,work_dir		; save area
	call	int_21			; call DOS INT 21 handler

	call	address_path		; get address of path
	cmp	es: byte ptr [di],";"	; is the append list null?
	jump	E,null_list		; exit append
	mov	app_dirs_seg,es 	; save app dirs segment
	mov	si,di			; source

try_another1:
	lea	di,try_dir		; destination
	call	get_app_dir		; copy dir to try into try_dir
	mov	app_dirs_ptr,si 	; save updated pointer


;-----------------------------
try_app_dir1:
	mov	app_disk,0		; zero for current dir
	cmp	try_dir+1,":"		; see if we have a drive
	jne	no_drive		; char should be a colon

;	yes, there was a drive specified, must do the change disk function call

	mov	ah,change_disk		; change disk
	mov	dl,try_dir		; get the char representation of the drive
	mov	app_disk,dl		; save it away for later use
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler
;	jc	check_end_dir_list	; there was an error, see if there is
					; another to try

	cmp	crit_err_flag,0 	; did we experience a critical error
	jne	set_err_code		; yes, fake a file_not_found

no_drive:
	mov	ah,get_dir		; get directory
	xor	dx,dx			; default drive
	lea	si,app_dir		; save area
	call	int_21			; call DOS INT 21 handler

;	check to see if there was a critical error

	cmp	crit_err_flag,0 	; did we experience a critical error
	je	cd_worked		; no, the cd worked
	jmp	short set_err_code

save_regs_and_set:
	pushf				; save everything again
	save_regs
	push	cs			; re-establish addressability
	pop	ds			; ds = cs

set_err_code:
	xor	ah,ah			; make ax look like open failed
	mov	al,FCB_failed
	mov	ax_after_21,ax		; save it away so we can restore it below

	jmp	no_more_to_try

cd_worked:
	lea	dx,try_dir		; point dx to dir to try
	mov	ah,change_dir		; change dir to appended directory
	call	int_21			; call DOS INT 21 handler

;	try the open in this dir

	restore_regs			; make regs look like when user
	mov	ax,incoming_AX		; called us

	call	int_21			; call DOS INT 21 handler
	mov	ax_after_21,ax		; save AX
	cmp	crit_err_flag,0 	; did we get critical error?
	jne	save_regs_and_set	; yes, fake a file_not_found
	cmp	al,FCB_failed	   ; did open work?
	jne	open_ok
	call	get_ext_err_code	; get the extended error code

open_ok:
	pushf				; save everything again
	save_regs

	push	cs			; re-establish addressability
	pop	ds			; ds = cs

;	restore user's working disk and restore the dir on the appended drive

	mov	ah,change_disk		; change disk back to our original
	mov	dl,work_disk
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler

	mov	ah,change_dir		; change dir
	lea	dx,app_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

;	this is for ..\dirname ptr

	mov	ah,change_dir		; change dir
	lea	dx,work_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

	mov	ax,ax_after_21		; restore AX
	cmp	al,FCB_failed		; did open work?
	jne	FCB_open_worked
	mov	ax,ext_err_dpl.DPL_AX
	cmp	ax,expected_ext_error
	jne	no_more_to_try		; not file not found

check_end_dir_list:
	mov	es,app_dirs_seg 	; restore es
	mov	si,app_dirs_ptr
	cmp	si,null 		; should we try again?
	je	no_more_to_try		; no
	jmp	try_another1		; yes

FCB_open_worked:
	mov	byte ptr ext_err_flag,0 ; the open worked, no need to set ext err code
	jmp	short set_disk

no_more_to_try:
;	restore user's working disk and dir

;	The following code up to label "null_list" which
;	restores the user's drive and path was moved in front
;	of the code to restore the drive spec in FCB.
;
	mov	ah,change_disk		; change disk
	mov	dl,work_disk
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler

	mov	ah,change_dir		; change dir
	lea	dx,work_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

null_list:
	mov	ah,FCB_drive_id 	; get FCB drive spec
;	cmp	ah,0			; did they ask for default drive?
;	je	fix_drive_spec		; yes, leave it alone
	jmp	short fix_drive_spec

set_disk:				; set drive number in FCB
	mov	ah,work_disk		; no, give them the found drive spec
	sub	ah,"A"-1		; convert from char to drive spec

;	ah has proper drive spec to put into FCB, do it

fix_drive_spec:
	les	bx,dword ptr FCB_ptr	; ES:BX points to FCB
	cmp	ES:byte ptr[bx],-1	; extended FCB
	jne	not_ext_FCB2		; put in the proper drive spec
	add	bx,1+5+1		; point to real drive letter

not_ext_FCB2:
	mov	ES:byte ptr [bx],ah


	call	ctrl_break_restore
	call	crit_err_restore

;	find out if there is a need to set the extended error code

	cmp	ext_err_flag,0		; do we need to set the extended error code?
	je	no_ext_err		; no, finish up
	lea	dx,ext_err_dpl
	cmp	FCB_ext_err,0
	je	handle_ext_err
	lea	dx,save_ext_err

handle_ext_err:
	call	set_ext_err_code	; yes, go set the ext error info

;	all done with append, clean things back up for the user

no_ext_err:
	restore_regs			; restore registers

	jmp	reset_stack		; fix stack, ret to caller
page

;-----------------------------------------------------------------------------
;	handle_find - APPEND handle find function
;-----------------------------------------------------------------------------

handle_find1:
	mov	incoming_CX,cx		; save user's CX
	mov	expected_error,handle_no_more_files
;	mov	expected_ext_error,handle_no_more_files
	jmp	short handle_openx

;-----------------------------------------------------------------------------
;	exec_pgm - APPEND exec program function
;-----------------------------------------------------------------------------

exec_pgm:
	mov	incoming_BX,bx		; save user's ES:BX
	mov	incoming_ES,es
	mov	expected_error,handle_file_not_found
;	mov	expected_ext_error,handle_no_more_files
	jmp	short handle_openx

;-----------------------------------------------------------------------------		  ;AN003;
;	ext_handle_open - APPEND extended handle open function					       ;AN003;
;-----------------------------------------------------------------------------		  ;AN003;
ext_handle_open:									  ;AN003;
	test	dx,eo_create		; does this call specify create?		  ;AN003;
	jz	no_eo_create		; no, we can continue				  ;AN003;
											  ;AN003;
	jmp	real_jump		; yes, do nothing but pass on to real		  ;AN003;
					; INT 21 handler				  ;AN003;
											  ;AN003;
;	getting here means the caller did not specify the create option 		  ;AN003;
											  ;AN003;
no_eo_create:										  ;AN003;
											  ;AN003;
	mov	incoming_BX,bx		; save user's registers                           ;AN003;
	mov	incoming_CX,cx		; extended open sure does use a lot		  ;AN003;
	mov	incoming_DX,dx		; of registers					  ;AN003;
	mov	incoming_SI,si								  ;AN003;
	mov	incoming_DI,di								  ;AN003;
	mov	incoming_ES,es								  ;AN003;
	mov	incoming_DS,ds								  ;AN003;
											  ;AN003;
	mov	expected_error,handle_file_not_found					  ;AN003;
	jmp	short handle_openx	; for now ...					  ;AN003;
											  ;AN003;
;-----------------------------------------------------------------------------
;	handle_open - APPEND handle open function
;-----------------------------------------------------------------------------

handle_open:
	mov	expected_error,handle_file_not_found
;	mov	expected_ext_error,handle_file_not_found

handle_openx:
	call	check_config		; check the config flags
	call	crit_sect_set		; set critical section flag

	call	tv_barrier		; no op on exec

	mov	incoming_AX,ax		; save user's AX
	mov	word ptr handle_ptr+0,dx	 ; save path pointer
	mov	word ptr handle_ptr+2,ds

	popff				; restore user's flags
	call	int_21			; try the open

	cli
	mov	AX_after_21,ax		; save AX as it came back from INT
	pushf				; save flags from operation

;	find out if we had an error, and if so was it the one we were
;	looking for

	jc	what_happened		; yes, lets find out what happened
	mov	incoming_AX,-1		; insure no exec done later
	jmp	set_return_flags	; no, fix the stack, then ret to caller
					; this means that the real call worked,
					; APPEND does not need to do anything

what_happened:
;	cmp	ax,handle_path_not_found  ; normal errors
;	je	handle_search		; yes, look for the file
	cmp	ax,expected_error	; was the error file not found?
	je	handle_search		; yes, look for the file
	jmp	set_return_flags	; no, fix the stack, then ret to caller


handle_search:
	call	get_ext_err_code	; get the extended error code information

;	set up APPEND's stack
	popff				; get rid of the flags from the
					; real operation
;	mov	temp_DS_save,ds 	; Save DS reg
	mov	stack_segment,ss	; Save it
	mov	stack_offset,sp 	; Save it
	mov	ax,cs			; Get current segment
	mov	ss,ax			; and point stack seg here
	lea	sp,append_stack 	; set up new stack

	save_regs			; save registers
	pushf				;
	push	cs			; establish addressability
	pop	ds

	call	crit_err_set

	call	ctrl_break_set

;	all done with the prep stuff, let's get down to business

;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;
;	before doing anything else, check DRIVE and PATH modes		 ;AN001;
;									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;

	pushf				; save flags			 ;AN001;
	push	ax			; save AX			 ;AN001;
									 ;AN001;
	cmp	incoming_AX,exec_proc*256 ; is this call an exec?
	je	drive_and_path_ok


;-------------------------------------------------------------------
;	Set up ES:SI to point to incoming string
;-------------------------------------------------------------------

	cmp	incoming_AX,ext_handle_opn*256+0 ;is this call an ext open?		  ;AN003;
	jne	no_eo13 								  ;AN003;
	mov	si,incoming_SI		; DS:SI points to original name for ex open	  ;AN003;
	mov	es,incoming_DS		; but this code wants ES:SI to point to it	 ;AN003;
	lea	di,fname		; DS:DI points to fname area			  ;AN003;
	jmp	SHORT eo_skip3		; skip the old stuff				  ;AN003;
											  ;AN003;
no_eo13:										   ;AN003;
	les	si,dword ptr handle_ptr ; ES:SI points to original handle
	lea	di,fname		; DS:DI points to fname area
eo_skip3:
;-------------------------------------------------------------------

	test	mode_flags,Drive_mode	; Drive_mode enabled?
	jnz	check_path_mode 	; yes, go check path mode

	call	check_for_drive 	; no, find out if there is a drive
					; specified
	cmp	ax,0			; was there a drive letter?
	je	check_path_mode 	; no, go check path mode

;-------------------------------------------------------------------
;	getting here means that Drive_mode is disabled and that a drive letter
;	was found.  This means we give up on this APPEND operation

	jmp	SHORT drive_or_path_conflict


check_path_mode:
	test	mode_flags,Path_mode	; Path_mode enabled?
	jnz	drive_and_path_ok	; yes, go do the APPEND function

	call	check_for_path		; no, find out if there is a path
					; specified

	cmp	ax,0			; was there a path?
	jne	drive_or_path_conflict	; no, go do the APPEND function


	call	check_for_drive 	; no, find out if there is a drive
					; specified
	cmp	ax,0			; was there a drive letter?
	je	drive_and_path_ok	; no, everything is OK
					; yes, fall through and exit w/error

;-------------------------------------------------------------------	 ;AN001;
;	getting here means that Drive_mode is disabled and that a drive  ;AN001;
;	letter was found.  This means we give up on this APPEND operatio ;AN001; n

drive_or_path_conflict:

	pop	ax			; clean up stack
	popff

;	restore_regs			; restore some regs				  ;AN002;
;	pop	ax

	mov	ext_err_flag,1		; we need to set extended error info
	mov	ax,expected_error	; make ax look like we got file not found
	mov	ax_after_21,ax		; save it away so we can restore it below
	popff				; get flags from stack
	stc				; set the carry flag
	pushf				; put 'em back

	jmp	no_more_to_try2


drive_and_path_ok:							 ;AN001;
	pop	ax			; restore AX			 ;AN001;
	popff				; restore flags 		 ;AN001;
									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
;	end of code to check DRIVE and PATH modes			 ;AN001;
;-------------------------------------------------------------------	 ;AN001;

	cmp	incoming_AX,ext_handle_opn*256+0 ;is this call an ext open?		  ;AN003;
	jne	no_eo1									  ;AN003;
	mov	si,incoming_SI		; DS:SI points to original name for ex open	  ;AN003;
	mov	es,incoming_DS		; but this code wants ES:SI to point to it	 ;AN003;
	lea	di,fname		; DS:DI points to fname area			  ;AN003;
	jmp	SHORT eo_skip1		; skip the old stuff				  ;AN003;
											  ;AN003;
no_eo1: 										  ;AN003;
	les	si,dword ptr handle_ptr ; ES:SI points to original handle
	lea	di,fname		; DS:DI points to fname area
eo_skip1:										  ;AN003;
	call	get_fname		; strip just the 8.3 filename from
					; the original ASCIIZ string
	call	address_path		; address the path
	cmp	es: byte ptr [di],";"	; is append list null ?
	jump	E,no_more_to_try2	; exit append
	popff				;
	mov	si,di			; pointer to list of appended directories
	pushf				; push flags onto stack just for the
					; popff below

try_another2:
	popff
	lea	di,try_dir		; buffer to be filled with dir name
					; to try
	push	cx			; save CX
	call	get_app_dir		; this routine will return with a dir
					; to try in try_dir
	mov	true_name_count,cx	; save number of chars for later us		  ;AN003;
	pop	cx
	mov	app_dirs_ptr,si 	; save updated pointer


;-----------------------------
try_app_dir2:

	call	append_fname		; glue the filename onto the end of the dir to try


;	we now have an ASCIIZ string that includes the original 8.3 filename
;	and one of the appended dir paths

	mov	ax,incoming_AX
	mov	cx,incoming_CX
	lea	dx,try_dir		; point to new ASCIIZ string

	cmp	incoming_AX,ext_handle_opn*256+0     ; extended open?			  ;AN003;
	jne	not_eo1 								  ;AN003;
											  ;AN003;
;	this is an extended open call							  ;AN003;
											  ;AN003;
	save_regs									  ;AN003;
											  ;AN003;
	mov	si,dx			; ext open wants DS:SI -> filename		  ;AN003;
	push	cs									  ;AN003;
	pop	ds									  ;AN003;
											  ;AN003;
	mov	ax,incoming_AX		; function code 				  ;AN003;
	mov	bx,incoming_BX		; mode word					  ;AN003;
	mov	cx,incoming_CX		; attributes					  ;AN003;
	mov	dx,incoming_DX		; flags 					  ;AN003;
	mov	es,incoming_ES		; ES:DI parm_list pointer			  ;AN003;
	mov	di,incoming_DI								  ;AN003;
											  ;AN003;
	call	int_21			; try the extended open 			  ;AN003;
											  ;AN003;
	restore_regs									  ;AN003;
	pushf				; save flags					  ;AN003;
;	mov	es,incoming_ES		; restore es as it was				  ;AN003;
	jmp	SHORT not_exec2		; go find out what happened			  ;AN003;
											  ;AN003;
											  ;AN003;
not_eo1:										  ;AN003;
	cmp	incoming_AX,exec_proc*256+0	; exec pgm call
	jne	not_exec1

;	this is an exec call								  ;AN003;

	push	es
	push	bx
	mov	ah,get_DTA
	call	int_21
	mov	word ptr incoming_DTA+0,bx	; save callers DTA
	mov	word ptr incoming_DTA+2,es
	pop	bx
	pop	es
	push	ds
	push	dx
	mov	ah,set_DTA
	lea	dx,exec_DTA		; set for fake exec search
	push	cs
	pop	ds
	call	int_21
	pop	dx
	pop	ds
	mov	ah,handle_fnd1		; precess search by finds
	mov	expected_error,handle_no_more_files

not_exec1:

	push	es			; save append's ES
	push	bx			; save append's BX
	mov	es,incoming_ES		; must restore ES before doing the call ; fix for P37, GGA 9/10/87
	mov	bx,incoming_BX		; must resatore user's ES:BX

	call	int_21			; try the open

	pop	bx			; restore append's BX
	pop	es			; restore append's es
	pushf				; save flags
	cmp	incoming_AX,exec_proc*256+0	; exec pgm call
	jne	not_exec2
	push	ds
	push	dx
	push	ax
	mov	ah,set_DTA
	mov	dx,word ptr incoming_DTA+0	; restore callers DTA
	mov	ds,word ptr incoming_DTA+2
	call	int_21
	pop	ax
	pop	dx
	pop	ds
not_exec2:
	popff
	pushf
	jnc	found_it_remote 	; all done

	cmp	crit_err_flag,0 	; process critical errors
	jne	check_crit_err

	cmp	ax,handle_path_not_found  ; normal errors
	je	should_we_look_more

	cmp	ax,expected_error	; was the error we found file not found?
	je	should_we_look_more	; yes, look some more
	jmp	no_more_to_try2 	; no, any other error, we pack it in

should_we_look_more:
	mov	si,app_dirs_ptr 	; yes, see if we should look more
	cmp	si,null 		; should we try again?
	je	no_more_to_tryx
	jmp	try_another2		; yes
no_more_to_tryx:
	jmp	no_more_to_try2

check_crit_err:
	mov	ext_err_flag,1		; we need to set extended error info
	mov	ax,expected_error	; make ax look like we got file not found
	mov	ax_after_21,ax		; save it away so we can restore it below
	popff				; get clags from stack
	stc				; set the carry flag
	pushf				; put 'em back

	jmp	no_more_to_try2

found_it_remote:			; come here only if the file was found in
					; an appended directory
	mov	ax_after_21,ax		; save AX


;											  ;AN002;
;	Find out if this process has the true_name flag set in thier PSP.		  ;AN002;
;	At this point, DS:DX points to the true name of the found file			  ;AN002;
;											  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	save_regs
											  ;AN002;
	mov	ah,get_PSP		; function code for get PSP operation		  ;AN002;
	call	int_21			; get the PSP, segment returned in BX		  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is true name flag armed?			  ;AN002;
	jz	no_true_name		; no, don't copy true name                        ;AN002;
											  ;AN002;
	sub	ax,true_name_flag	; clear true name flag				  ;AN002;
	mov	es:[di],ax		; save it in PSP				  ;AN002;
											  ;AN002;
	mov	di,word ptr handle_ptr+0	; get user's buffer pointer ES:DI         ;AN002;
	mov	es,word ptr handle_ptr+2						  ;AN002;

;	find out if this is a handle find or an open or an exec

	cmp	incoming_AX,exec_proc*256+0   ; exec?
	je	no_true_name		; yes, do nothing with true name
											  ;AN002;
	cmp	incoming_AX,handle_fnd1*256+0	; handle find?
	jne	not_hf			; no, go do the easy stuff
											  ;AN002;
;	function we are doing is a handle find, must get part of true_name
;	string from append path, part from DTA.  Messy!

	lea	si,try_dir		; buffer that has last APPEND path tried

	mov	cx,true_name_count	; get number of chars in true_name dir		  ;AN002;

copy_true_name_loop2:
	mov	ah,ds:[si]		; get byte of append dir path			  ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	inc	si			; in this loop, the null is not copied		  ;AN002;
	inc	di									  ;AN002;
	loop	copy_true_name_loop2							  ;AN002;

;	put in the "\"

	mov	ah,"\"			; get a \
	mov	es:[di],ah		; copy it
	inc	di			; increment pointer

;	we have copied the first part of the string, now get the real filename
;	from the DTA

	push	es
	push	bx

	mov	ah,get_DTA
	call	int_21
	push	es
	pop	ds
	mov	si,bx

	pop	bx
	pop	es

copy_true_name_loop3:
	mov	ah,ds:[si+30]	     ; get byte of actual filename		       ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	cmp	ah,null 		; is it a null? 				  ;AN002;
	je	true_name_copied	; yes, all done 				  ;AN002;
	inc	si			; in this loop the null is copied		  ;AN002;
	inc	di									  ;AN002;
	jmp	copy_true_name_loop3							  ;AN002;

not_hf:
	mov	si,dx			; make DS:SI point to true name

copy_true_name_loop:									  ;AN002;
	mov	ah,ds:[si]		; get byte of true name 			  ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	cmp	ah,null 		; is it a null? 				  ;AN002;
	je	true_name_copied	; yes, all done 				  ;AN002;
	inc	si									  ;AN002;
	inc	di									  ;AN002;
	jmp	copy_true_name_loop							  ;AN002;
											  ;AN002;
true_name_copied:									  ;AN002;
											  ;AN002;
no_true_name:										  ;AN002;
	restore_regs			; restore some regs				  ;AN002;
	pop	ax
											  ;AN002;
											  ;AN002;
no_more_to_try2:

	call	ctrl_break_restore	; restore normal control break address
	call	crit_err_restore	; restore normal critical error  address

;	find out if there is a need to set the extended error code

	cmp	ext_err_flag,0		; do we need to set the extended error code?
	je	no_ext_err2		; no, finish up
	lea	dx,ext_err_dpl
	call	set_ext_err_code	; yes, go set the ext error info

;	reset flags, and pack it in

no_ext_err2:
	popff
	restore_regs			; restore registers
	pushf				; put the real flags on the stack

	jmp	reset_stack		; fix stack, ret to caller

page
;-------------------------------------------------------------------
;
;	support routines for drive and path mode checking
;
;
;-------------------------------------------------------------------


check_for_drive:			; input:  ES:SI -> original string
					; output: AX = 0  no drive present
					; output: AX = -1 drive present

	xor	ax,ax			; assume no drive letter present

	cmp	es: byte ptr [si+1],':' ; is the second char a ":"?
	jne	exit_check_for_drive	; no, skip setting the flag

	mov	ax,-1			; yes, set the flag

exit_check_for_drive:

	ret

;-------------------------------------------------------------------

check_for_path: 			; input:  ES:SI -> original string
					; output: AX = 0  no path present
					; output: AX = -1 path present

	push	si			; save pointer

	xor	ax,ax			; assume no path present


;	walk the string and look for "/", or "\".  Any of these mean that a
;	path is present

walk_handle_string:

	push	ax									 ;AN006;
	mov	al,es: byte ptr [si]	; is this a dbcs char?				 ;AN006;
	call	Chk_DBCS								 ;AN006;
	pop	ax									 ;AN006;
											 ;AN006;
	jnc	no_dbcs1		; no, keep looking				 ;AN006;

	add	si,2			; yes, skip it and the next char		 ;AN006;
	jmp	walk_handle_string	; the next char could be a "\", but		 ;AN006;
					; would not mean a path was found		 ;AN006;
											 ;AN006;
no_dbcs1:										 ;AN006;
	cmp	es: byte ptr [si],"\"	; is the char a "\"?
	je	found_path		; yes, set flag and return
	cmp	es: byte ptr [si],"/"	; is the char a "/"?
	je	found_path		; yes, set flag and return
	cmp	es: byte ptr [si],0	; is the char a null
	je	exit_check_for_path	; yes, got to the end of the
					; handle string

	inc	si			; point to next char
	jmp	walk_handle_string	; and look again

found_path:
	mov	ax,-1			; yes, set the flag

exit_check_for_path:
	pop	si			; restore si
	ret

page
;-----------------------------------------------------------------------------
;	Entry point for interrupt 2f handler
;-----------------------------------------------------------------------------

intfcn_hook:
	cmp	ah,append_2f		; is this function call for append?
;;;;;;	je	do_appends						  ; @@12
	jne	ih_10							  ; @@12
	jmp	do_appends						  ; @@12
ih_10:									  ; @@12
	cmp	ah,applic_2f		; is this function call for applications
	je	do_applic
	jmp	pass_it_on

do_applic:
	cmp	dx,-1			; not COMMAND call
	jump	NE,pass_it_on
	cmp	al,0			; match name request
	jne	ck01

	mov	cmd_buf,bx		; save CMDBUF offset
	call	check_cmd_name
	jne	no_internal1
	mov	al,append_inst		; inidicate I want this command
no_internal1:
	iret

ck01:
	cmp	al,1			; match name request
	jne	ck02

;	save pointer to parser

	mov	word ptr pars_off+0,di	; ES:DI points to COMMAND.COM's parser
	mov	word ptr pars_off+2,es	; save it for later

	mov	cmd_env,bx		; save env pointer address
	call	check_cmd_name
	jne	no_internal2
	call	COMMAND_begin		; process internal command
no_internal2:
	iret

ck02:
;	cmp	al,2			; set COMMAND active	    ; @@13; @@09
;	jne	ck03						    ; @@13; @@09
;	mov	cmd_active,1					    ; @@13; @@09
;	iret							    ; @@13; @@09
ck03:								    ; @@13; @@09
;	cmp	al,3			; set COMMAND in active     ; @@13; @@09
;	jne	ck04						    ; @@13; @@09
;	mov	cmd_active,0					    ; @@13; @@09
;	iret							    ; @@13; @@09
ck04:								    ; @@13; @@09
	jmp	pass_it_on

;*******************************************************************************
;   The following old code is commented out.				    @@12
;*******************************************************************************
;check_cmd_name:			 ; see if internal APPEND
;	push	es
;	push	cs
;	pop	es
;	push	di
;	push	cx
;	push	si
;	cmp	ds:byte ptr[si],6	; length must match
;	jne	skip_comp
;	comp	append_id,6,[si+1]	; see if APPEND is command
;skip_comp:
;	pop	si
;	pop	cx
;	pop	di
;	pop	es
;	ret
;*********************************************************************
check_cmd_name: 			; See if APPEND 		    @@12
	push	ax			;				    @@12
	push	si			;				    @@12
	push	cx			;				    @@12
	push	di			;				    @@12
	push	es			;				    @@12
	mov	si,cmd_buf		; DS:SI -> cmd buf ended with cr    @@12
	add	si,2			; 1st 2 bytes garbage		    @@12
					;				    @@12
ccn_skip_leading:			;				    @@12
	lodsb				; skip leading stuff		    @@12

	call	Chk_DBCS		; find out if this is DBCS			 ;AN006;
	jnc	no_dbcs2		; no, keep looking				 ;AN006;
	lodsb				; yes, skip it and the next byte		 ;AN006;
	jmp	ccn_skip_leading	; the second byte will be skipper when		 ;AN006;
					; we go back through				 ;AN006;

no_dbcs2:										 ;AN006;
	cmp	al," "			;	blank			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,tab_char		;	tab			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,","			;	comma			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,"="			;	equal			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,";"			;	semi-colon		    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,"\"			;	back slash		    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,cr			; bad ret for early terminate	    @@12
	jne	ccn_02			;				    @@12
	cmp	al,0			;   reset z for no match	    @@12
	jmp	SHORT ccn_ret 		;				    @@12
ccn_02: 				;				    @@12
	mov	di,si			; di -> beginning of possible	    @@12
	dec	di			;	"APPEND " string	    @@12
	lodsb				;				    @@12
	cmp	al,":"			;				    @@12
	jne	ccn_cont		;				    @@12
	mov	di,si			;				    @@12
	lodsb				;				    @@12
ccn_cont:				;				    @@12
	call	Chk_DBCS								 ;AN006;
	jnc	no_dbcs3		; no, carry on					 ;AN006;
	add	si,2			; yes, skip it and the next byte		 ;AN006;
	jmp	SHORT ccn_20									 ;AN006;
											 ;AN006;
no_dbcs3:										 ;AN006;
	cmp	al,"\"			; move di up upon "\"		    @@12
	jne	ccn_20			;				    @@12
	mov	di,si			;				    @@12
ccn_10: 				;				    @@12
	lodsb				;				    @@12
	jmp	ccn_cont		;				    @@12
ccn_20: 				;				    @@12
	cmp	al," "			; look for separator		    @@12
	je	ccn_30			; if found, then have command	    @@12
	cmp	al,"="			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,cr			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,tab_char		;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,","			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,";"			;				    @@12
	jne	ccn_10			;				    @@12

ccn_30: 				;				    @@12
	sub	si,di			;				    @@12
	cmp	si,7			;				    @@12
	jne	ccn_ret 		; no match			    @@12
					;				    @@12
	mov	si,di			;				    @@12
	chkchar "A"			; look for "APPEND" string	    @@12
	chkchar "P"			;				    @@12
	chkchar "P"			;				    @@12
	chkchar "E"			;				    @@12
	chkchar "N"			;				    @@12
	chkchar "D"			;				    @@12
					; exit with z set for match	    @@12
ccn_ret:				;				    @@12
	pop	es			;				    @@12
	pop	di			;				    @@12
	pop	cx			;				    @@12
	pop	si			;				    @@12
	pop	ax			;				    @@12
	ret				;				    @@12

page
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
;	do_appends							 ;AN000;
;									 ;AN000;
;	This is the INT 2F handler for the APPEND			 ;AN000;
;			  subfunction					 ;AN000;
;									 ;AN000;
;	New functions added for 3.30:					 ;AN000;
;									 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	Get /X status							 ;AN000;
;									 ;AN000;
;	Input:	AX = B706						 ;AN000;
;									 ;AN000;
;	Output: BX = 0000	/X not active				 ;AN000;
;		   = 0001	/X active				 ;AN000;
;									 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	Set /X status							 ;AN000;
;									 ;AN000;
;	Input:	AX = B707						 ;AN000;
;									 ;AN000;
;		BX = 0000	turn /X off				 ;AN000;
;		BX = 0001	turn /X on (active)			 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;
do_appends:
	cmp	al,are_you_there	; is the function request for presence?
	jne	ck1

	mov	al,-1			; set flag to indicate we are here
	iret				; return to user

ck1:
	cmp	al,dir_ptr		; is the function request for pointer?
	jne	ck2

	les	di,dword ptr dirlst_offset     ; return dirlist pointer to caller
	iret

ck2:
	cmp	al,get_app_version	; is the function request for version?
	jne	ck3			; no, check for next function

	mov	ax,-1			; yes, set NOT NETWORK version
	iret

ck3:
	cmp	al,tv_vector		; is the function request for TV vector?
	jne	ck4			; no, check for old dir ptr

	mov	tv_vec_seg,es		; yes, save the TV vector
	mov	tv_vec_off,di

	push	cs			; set ES:DI to tv ent pnt
	pop	es			;
	lea	di,tv_entry

	xor	byte ptr tv_flag,TV_TRUE ; set flag			  ;AN000;
	iret

ck4:					;
	cmp	al,old_dir_ptr		; is it the old dir ptr
	jne	ck5			; no, pass it on

	push	ds
	push	cs
	pop	ds

	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,1			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

	pop	ds
	mov	al,1
	call	terminate		; exit to DOS			  ; @@05

ck5:					;
	cmp	al,DOS_version		; is it the new version check
	jne	ck6			; no, pass it on

	mov	ax,mode_flags		; set mode bits
	xor	bx,bx			; destroy registers
	xor	cx,cx
	mov	dl,byte ptr version_loc   ; major version num
	mov	dh,byte ptr version_loc+1 ; minor version num
	iret

ck6:									 ;AN000;
	cmp	al,get_state		; is it get state call? 	 ;AN001;
	jne	ck7			; no, look some more		 ;AN000;
									 ;AN000;
	mov	bx,mode_flags		; get mode bits 		 ;AN000;
	iret				; return to user		 ;AN000;
									 ;AN000;
ck7:									 ;AN000;
	cmp	al,set_state		; is it set state  call?	 ;AN001;
	jne	ck8			; no, look some more		 ;AN000;
									 ;AN000;
	mov	mode_flags,bx		; save the new state		 ;AN001;
	iret								 ;AN000;
									 ;AN000;
ck8:									 ;AN000;

	cmp	al,true_name		; is it the set true name function?		  ;AN002;
	jne	ck9			; no, look some more				  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	push	bx									  ;AN002;
	push	es									  ;AN002;
	push	di									  ;AN002;
											  ;AN002;
											  ;AN002;
;	get the PSP and then get the APPEND flags byte

	mov	ah,get_PSP		; function code to get PSP address		  ;AN002;
	call	int_21			; get the PSP address				  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
;	is the flag already set?

	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is it set?					  ;AN002;
	jnz	no_set_true_name	; yes, do nothing				  ;AN002;
											  ;AN002;
;	set the true_name flag

set_true_name:										  ;AN002;
	add	ax,true_name_flag	; set true name flag				  ;AN002;
	mov	es:[di],ax		; save in PSP					  ;AN002;
											  ;AN002;
no_set_true_name:
	pop	di			; restore some regs				  ;AN002;
	pop	es									  ;AN002;
	pop	bx									  ;AN002;
	pop	ax									  ;AN002;
											  ;AN002;
	iret				; return					  ;AN002;
											  ;AN002;
ck9:											  ;AN002;

;-------------------------------------------------------------------
;	fill in additional 2F functions here
;-------------------------------------------------------------------

pass_it_on:				; the function call (ah) was not for append
	jmp	dword ptr intfcn_Offset ; jump to old INT 2f

page
;-----------------------------------------------------------------------------
;	Entry point for interrupt 24 handler
;-----------------------------------------------------------------------------

crit_err_handler:

	mov	crit_err_flag,0ffh	; set critical error flag
	mov	al,3			; fail int 21h
	iret

page
;-----------------------------------------------------------------------------
;	miscellaneous routines
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;	tv_barrier
;-----------------------------------------------------------------------------

tv_barrier:

	cmp	tv_flag,TV_TRUE 	; in Topview			 ;AN000;
	jne	no_barrier

	push	ax
	mov	ax,2002h		; wait on DOS barrier
	int	2Ah
	pop	ax
no_barrier:
	ret

;-----------------------------
;	check_config - this routine is called by both the FCB and handle open
;	code.  I checks the net_config flag to see if it is zero, if so it
;	does an installation check. If it is non-zero, nothing is done.

check_config:

	push	ax			; save a few registers
	push	bx

;	examine the config flag to see if we already know what config we have

	cmp	net_config,0
	jne	do_not_look		; we know config already

;	the flag word has not been set before,	go find out what config we have

	mov	ax,0b800h		; installation code function code
	int	2fh			; do the installation check

	mov	net_config,bx		; save flag word for later

do_not_look:
	pop	bx			;restore regs and leave
	pop	ax
	ret

;*( Chk_DBCS ) *************************************************************
;*									   *
;*  Function: Check if a specified byte is in ranges of the DBCS lead bytes*
;*  Attention: If your code is resident, comment out the lines marked	   *
;*	       ;** .							   *
;*									   *
;*  Input:								   *
;*	   AL	 = Code to be examined					   *
;*									   *
;*									   *
;*  Output:								   *
;*	   If CF is on then a lead byte of DBCS 			   *
;*									   *
;* Register:								   *
;*	   FL is used for the output, others are unchanged.		   *
;*									   *
;***************************************************************************
Chk_DBCS	PROC
	PUSH	DS
	PUSH	SI
;	CMP	CS:DBCSEV_SEG,0 	; ALREADY SET ? ;**
;	JNE	DBCS00					;**
	MOV	SI,OFFSET EVEV		; SET DEFAULT OFFSET  ;**
	PUSH	CS					      ;**
	POP	DS			; SET DEFAULT SEGMENT ;**
     PUSH    AX
	MOV	AX,6300H		; GET DBCS EV CALL
	INT	21H
	MOV	CS:DBCSEV_OFF,SI			      ;**
	MOV	CS:DBCSEV_SEG,DS			      ;**
     POP     AX
DBCS00:
	MOV	SI,CS:DBCSEV_OFF			      ;**
	MOV	DS,CS:DBCSEV_SEG			      ;**
DBCS_LOOP:
	CMP	WORD PTR [SI],0
	JE	NON_DBCS
	CMP	AL,[SI]
	JB	DBCS01
	CMP	AL,[SI+1]
	JA	DBCS01
	STC
	JMP	SHORT DBCS_EXIT
DBCS01:
	ADD	SI,2
	JMP	DBCS_LOOP
NON_DBCS:
	CLC
DBCS_EXIT:
	POP	SI
	POP	DS
	RET
Chk_DBCS	ENDP


;-----------------------------
;	append_fname - glues the fname onto the end of the dir to try

append_fname:
	push	es
	push	ds
	pop	es
	lea	di,try_dir		; destination, sort of (dir name)
	lea	si,fname		; source (filename)

;	find the end of the dir name

	mov	dbcs_fb,-1		; set flag for no dbcs first byte chars 	 ;AN006;

walk_dir_name:
	mov	al,byte ptr [di]	; get a char from dir name
	cmp	al,null 		; are we at the end?
	je	end_of_dir		; yes, add on the fname

	call	Chk_DBCS		; char is in al 				 ;AN006;
	jnc	no_dbcs4		; no, keep looking				 ;AN006;
	mov	dbcs_fb,di		; save offset					 ;AN006;
	inc	di			; skip second byte

no_dbcs4:
	inc	di			; no, keep stepping
	jmp	walk_dir_name

;	now it is time to append the filename

end_of_dir:
	mov	al,byte ptr [di-1]	; get last char of dir name
	cmp	al,"\"			; is it a dir seperator?
	jne	check_next_dir_sep	; no, check the next dir sep char		 ;AN006;
											 ;AN006;
	sub	di,2			; yes, must find out if real dir sep		 ;AN006;
					; or DBCS second byte				 ;AN006;
	cmp	dbcs_fb,di		; is the char before our dir sep a DBCS 	 ;AN006;
					; first byte?					 ;AN006;
	jne	no_dbcs4a		; no, must check for the next dir sep		 ;AN006;
					; yes, this means we must put in a dir sep	 ;AN006;
	add	di,2			; restore di					 ;AN006;
	jmp	SHORT put_in_dir_sep	; put int the dir sep char			 ;AN006;
											 ;AN006;
no_dbcs4a:										 ;AN006;
	add	di,1			; restore di, then check next dir sep		 ;AN006;

check_next_dir_sep:
	cmp	al,"/"			; is it the other dir seperator?
	je	add_fname		; yes, no need to add one
put_in_dir_sep: 									 ;AN006;
	mov	al,"\"			; get dir seperator
	stosb				; add to end of dir

add_fname:
	lodsb				; get a char from fname
	stosb				; copy the char
	cmp	al,null 		; are we at the and of the filename?
	je	eo_name 		; yes, all done!
	jmp	add_fname







eo_name:
	pop	es
	ret


;-----------------------------
;	get_fname strips out the 8.3 filename from the original ASCIIZ string
;
;	INPUT:	ES:SI points to original string
;		DS:DI points to area for filename

get_fname:

	mov	bx,si			; save the pointer
	mov	dbcs_fb,-1		; set the dbcs flag off 			 ;AN006;

gfn1:
	mov	ah,ES:byte ptr [si]	; get a char from the source
	cmp	ah,null 		; is it a null?
	je	got_the_end		; yes, we found the end

	call	chk_dbcs		; is this char a DBCS first byte?		 ;AN006;
	jnc	no_dbcs5		; no, carry on
	mov	dbcs_fb,si		; yes, save pointer
	inc	si			; skip second byte

no_dbcs5:
	inc	si			; no, point to next char
	jmp	gfn1			; loop till end found

got_the_end:
	mov	ah,ES:byte ptr [si]	; get a char
	cmp	ah,"/"			; did we find a /
	je	went_too_far		; yes, we found the start
	cmp	ah,"\"			; did we find a \
	je	found_bslash		; yes, we found the start			 ;AN006;
	cmp	ah,":"			; did we find a :
	je	went_too_far		; yes, we found the start
	cmp	si,bx			; are we back to the original start?
	je	got_the_beg		; yes, we found the start of the fname
	dec	si			; step back a char, then look some more
	jmp	got_the_end

found_bslash:				; found a backslash, must figure out if 	 ;AN006;
					; is second byte of DBCS			 ;AN006;
	dec	si			; point to next char				 ;AN006;
	cmp	si,dbcs_fb		; do they match?
	jne	no_dbcs5a		; no, fix up si and carry on			 ;AN006;
	dec	si			; skip dbcs byte and loop some more		 ;AN006;
	jmp	got_the_end								 ;AN006;

no_dbcs5a:										 ;AN006;
	inc	si			; went too far by one extra			 ;AN006;
											 ;AN006;
went_too_far:
	inc	si			; went one char too far back

;	ES:SI now points to the beginning of the filename

got_the_beg:
	mov	ah,ES:byte ptr [si]	; get a char from the source
	mov	byte ptr [di],ah	; copy to dest
	cmp	ah,null 		; did we just copy the end?
	je	done_with_fname 	; yes, all done
	inc	si			; no, get the next char
	inc	di
	cmp	di,offset app_dirs_ptr	; make sure we dont try to copy past the
	je	done_with_fname 	; area
	jmp	got_the_beg

done_with_fname:
	ret

;-----------------------------
;	this code executed to return to caller after APPEND's stack has been
;	initialized

reset_stack:

;	reset the stack 								  ;AN002;

	popff				; restore flags from real open
	mov	ss,Stack_Segment	; Get original stack segment
	mov	sp,Stack_Offset 	; Get original stack pointer
	pushf				; put the flags on the old stack


;-----------------------------
;	before jumping to this routine, SS:SP must point to the caller's stack,
;	and the flags from the real INT 21 operation must have been pushed

set_return_flags:

;	must be sure to clear the true_name flag before leaving 			  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	push	bx									  ;AN002;
	push	es									  ;AN002;
	push	di									  ;AN002;
											  ;AN002;
	mov	ah,get_PSP		; function code for get PSP operation		  ;AN002;
	call	int_21			; get the PSP, segment returned in BX		  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is true name flag armed?			  ;AN002;
	jz	reset_stack2		; no, don't copy true name                        ;AN002;
											  ;AN002;
	sub	ax,true_name_flag	; clear true name flag				  ;AN002;
	mov	es:[di],ax		; save it in PSP				  ;AN002;
											  ;AN002;
											  ;AN002;
reset_stack2:										  ;AN002;
											  ;AN002;
	pop	di			; restore					  ;AN002;
	pop	es									  ;AN002;
	pop	bx									  ;AN002;
	pop	ax									  ;AN002;
											  ;AN002;
	cmp	tv_flag,TV_TRUE 					 ;AN000;
	jne	tv_flag_not_set

	mov	ax,2003h		; clear open barrier
	int	2Ah


;	pop down to the old flags on the user's stack

tv_flag_not_set:

	cmp	incoming_AX,exec_proc*256+0	; need to do exec
	jne	not_exec3
	popff				; discard bad flags
	mov	ax,incoming_AX		; set exec parms

	push	ds			; save DS, this must be done					;an005;
					; to pervent DS from being trashed on return to caller		;an005;

	push	cs
	pop	ds
	lea	dx,try_dir
	mov	bx,incoming_BX
	mov	es,incoming_ES
	call	int_21			; issue the exec

	pop	ds			; restore DS							; an005;

	pushf

not_exec3:
	popff				; get flags from real int 21 (old stack)
	pop	temp_IP_save		; save IP, CS
	pop	temp_CS_save
	lahf				; save flags in AH
	popff				; pop old flags off stack
	sahf				; replace old with new

;	push the new flags onto the stack, then fix CS and IP on stack

	pushf				; push new flags onto stack
	push	temp_CS_save		; restore IP, CS
	push	temp_IP_save
	mov	ax,AX_after_21		; Set AX as it was after open

	call	crit_sect_reset 	; clear the critical section flag
	iret				; return to the calling routine


;-----------------------------
;	This routine is used to extract an appended dir from the dir list
;	On entry, DS:DI points to an area for the appended dir
;	and ES:SI points to the source string

get_app_dir:

	xor	cx,cx			; keep a count of chars in cx			  ;AN003;
copy_dir:
	mov	ah,es:byte ptr [si]	; get the char, and copy it into dest
	cmp	ah,null 		; find a null?
	je	no_more_dirs		; yes, inform caller that this is the last one

	cmp	ah,";"			; check to see if we are at the end of a dir
	je	update_pointer		; yes,

	mov	byte ptr [di],ah	; if not null or semi-colon, then copy it
	inc	si			; increment both pointers
	inc	di
	inc	cx			; count of chars				  ;AN003;
	jmp	copy_dir		; do it some more

update_pointer:
	inc	si			; point to next char
	mov	ah,es:byte ptr [si]	; get char			  ; @@16
	cmp	ah,null 		; did we reach the end of the dir list?
	je	no_more_dirs		;

	cmp	ah,";"			; is is a semi-colon
	je	update_pointer
	jmp	SHORT  all_done


no_more_dirs:
	xor	si,si			; set end search flag

all_done:
	mov	byte ptr [di],null	; null terminate destination
	ret				; return to caller

;-----------------------------
;	set ctrl-break check off
;	first, save the old state so we can restore it later,
;	then turn ctrl-break checking off

ctrl_break_set:

	mov	ah,ctrl_break		; function code for ctrl-break check
	xor	al,al			; 0 = get current state
	call	int_21			; call DOS INT 21 handler

	mov	ctrl_break_state,dl	; save the old ctrl-break state

	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	xor	dl,dl			; 0 = off
	call	int_21			; call DOS INT 21 handler
	ret


;-----------------------------
;	restore ctrl-break checking flag to the way it was
ctrl_break_restore:
	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	mov	dl,ctrl_break_state	; get the way is was before we messed with it
	call	int_21			; call DOS INT 21 handler
	ret

;-----------------------------
;	restore ctrl-break checking flag to the way it was
ctrl_break_rest:
	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	mov	dl,ctrl_break_state	; get the way is was before we messed with it
	call	int_21
	ret

;-----------------------------
;
crit_err_set:
	mov	crit_err_flag,0 	; clear the critical error flag

	mov	ax,get_crit_err 	; Get INT 24h vector
	call	int_21			; call DOS INT 21 handler

	mov	crit_vector_offset,bx	; Save it
	mov	ax,es			; es hase segment for resident code
	mov	crit_vector_segment,ax

	lea	dx,crit_err_handler	; DS:DX = New INT 21h vector
	mov	ax,set_crit_err 	; function code for setting critical error vector
	call	int_21			; call DOS INT 21 handler
	ret				; go back to the caller


;-----------------------------
;
crit_err_restore:
	push	ds			; save ds for this function
	mov	ax,set_crit_err 	; function code for setting critical error vector
	mov	dx,crit_vector_offset	; get old int 24 offset
	mov	ds,crit_vector_segment	; get old int 24 segment
	call	int_21			; call INT 21
	pop	ds
	ret

;-----------------------------
;	crit_sect_set - issues an enque request to the server to protect
;	against reentry.  This request is issued only if the network is started,
;	and then, only for RCV, MSG, and SRV configurations
crit_sect_set:
	push	ax
	push	bx
	push	di
	push	es

	mov	ax,net_config		; check the server config flag
	cmp	ax,0			; is it zero?
	je	dont_set_crit_sect	; yes, skip it

	cmp	ax,redir_flag		; is it a redir?
	je	dont_set_crit_sect	; yes, skip it
					; otherwise, issue the request

;	the config flag was not zero or redir, so set crit section

	mov	ah,NETSYSUTIL
	mov	al,NETENQ
	mov	bx,TCBR_APPEND
	int	2Ah

dont_set_crit_sect:			; because of the config we don't want
	pop	es			; to set critical section
	pop	di
	pop	bx
	pop	ax
	ret

;-----------------------------
;
crit_sect_reset:
	push	ax
	push	bx

	mov	ax,net_config		; check the server config flag
	cmp	ax,0			; is it zero?
	je	not_set 		; yes, skip it

	cmp	ax,redir_flag		; is it a redir?
	je	not_set 		; yes, skip it

	mov	ah,NETSYSUTIL		; turn critical section off
	mov	al,NETDEQ
	mov	bx,TCBR_APPEND
	int	2Ah

not_set:
	pop	bx
	pop	ax
	ret


;-----------------------------
;	save_first_ext_err - this routine is used to save the extended
;		error info after the first FCB open.
save_first_ext_err:

	push	ax

	mov	ax,ext_err_dpl.DPL_AX		; copy all registers
	mov	save_ext_err.DPL_AX,ax
	mov	ax,ext_err_dpl.DPL_BX
	mov	save_ext_err.DPL_BX,ax
	mov	ax,ext_err_dpl.DPL_CX
	mov	save_ext_err.DPL_CX,ax
	mov	ax,ext_err_dpl.DPL_DX
	mov	save_ext_err.DPL_DX,ax
	mov	ax,ext_err_dpl.DPL_SI
	mov	save_ext_err.DPL_SI,ax
	mov	ax,ext_err_dpl.DPL_DI
	mov	save_ext_err.DPL_DI,ax
	mov	ax,ext_err_dpl.DPL_DS
	mov	save_ext_err.DPL_DS,ax
	mov	ax,ext_err_dpl.DPL_ES
	mov	save_ext_err.DPL_ES,ax

	pop	ax
	ret

;-----------------------------
;	get_ext_err_code - this routine is used to get the extended error
;		info for the error that cause append to start its search

get_ext_err_code:
	push	ax			; save register that are changed by this
	push	bx			; DOS function
	push	cx
	push	di
	push	si
	push	es
	push	ds

;	get the extended error information

	mov	ah,59h			; function code for get extended error
	xor	bx,bx			; version number
	call	int_21			; get the extended error

;	save it away in a DPL for set_ext_error_code
;	all fields in the DPL will be filled in except the last three,
;	which will be left at zero

	mov	ext_err_dpl.DPL_AX,ax
	mov	ext_err_dpl.DPL_BX,bx
	mov	ext_err_dpl.DPL_CX,cx
	mov	ext_err_dpl.DPL_DX,dx
	mov	ext_err_dpl.DPL_SI,si
	mov	ext_err_dpl.DPL_DI,di
	mov	ext_err_dpl.DPL_DS,ds
	mov	ext_err_dpl.DPL_ES,es


;	restore regs and return

	pop	ds
	pop	es			; restore registers
	pop	si
	pop	di
	pop	cx
	pop	bx
	pop	ax
	ret

;-----------------------------
;	set_ext_err_code - this routine is used to get the extended error
;		info for the error that cause append to start its search
;		CS:DX points to return list
set_ext_err_code:
	push	ax			; save register that are changed by this
	push	ds			; DOS function

;	get the extended error information

	mov	ah,DOSSERVER		; function code for DOSSERVER call
	mov	al,DOSSETERROR		; sub-function code for set extended error
	push	cs
	pop	ds
	call	int_21			; set the extended error

;	restore regs and return

	pop	ds			; restore registers
	pop	ax
	ret
page
;-----------------------------
;	This routine is used to initiate DOS calls from within the APPEND interrupt
;	handlers.  An INT instruction can not be used because it would cause APPEND
;	to be re-entered.
;
;	SS, SP saved incase call is EXEC which blows them away
int_21: 				;
	cmp	tv_flag,TV_TRUE 	; see if being re-entered	 ;AN000;
	jne	use_old_vec		; yes, pass through to DOS

	pushf				; to comp for iret pops
	call	dword ptr tv_vec_off	; Call INT 21h
	ret				;

use_old_vec:
	cmp	vector_segment,0	; not installed yet
	je	use_int

	pushf				;  to comp for iret pops
	call	dword ptr vector_offset ; Call INT 21h
	ret				;

use_int:
	int	DOS_function
	ret
page
;-----------------------------
;	This routine is used to locate the current APPEND path string
;	result to ES:DI

address_path:
address_status: 							  ; @@13
	test	mode_flags,E_mode
	jnz	get_env_mode

address_pathx:
	mov	ax,append_2f*256+dir_ptr	; get from buffer
	int	int_function
	clc
	ret

get_env_mode:					; get from environment
;	cmp	cmd_active,0			; different logic   ; @@13; @@09
;	jne	use_cmd_env			; if in COMMAND     ; @@13; @@09
	push	bx
	mov	ah,get_PSP
	call	int_21				; get the PSP
	mov	es,bx
	mov	bx,002ch			; address environment
	mov	ax,es:word ptr[bx]
	mov	es,ax
	pop	bx
	cmp	ax,0				; PSP pointer is set
	je	address_pathx						  ; @@13
use_cmd_env:								  ; @@13
;	cmp	cmd_env,0			; have not set my pointer yet
;	je	address_pathx						  ; @@13
;	mov	es,cmd_env						  ; @@13
env_mode1:
	mov	di,0				; start at start
	cmp	es:byte ptr[di],0		; no environment
	je	no_appendeq
find_append:
	cmp	es:word ptr[di],0		; at environment end
	je	no_appendeq
	push	di
	push	si
	push	cx
	push	ds
	push	cs
	pop	ds
	comp	,6+1,append_id			; string = "APPEND="
	pop	ds
	pop	cx
	pop	si
	pop	di
	je	at_appendeq
	inc	di
	jmp	find_append
at_appendeq:					; must insure this is	    @@17
	cmp	di,0				; genuine "APPEND=" string  @@17
	je	at_appendeq_genuine		; if start of environ ok    @@17
	dec	di				; else check that 0	    @@17
	cmp	es:byte ptr[di],0		;      precedes string	    @@17
	je	at_appendeq_10			; jmp if ok		    @@17
	add	di,8				; else cont.search after    @@17
	jmp	find_append			;      "="		    @@17
at_appendeq_10: 				;			    @@17
	inc	di				;			    @@17
at_appendeq_genuine:				;			    @@17
	add	di,6+1				; skip APPEND=
	cmp	es:byte ptr[di],0		; null value
	je	no_appendeq			; treat as not found
	cmp	es:byte ptr[di]," "
	je	no_appendeq
	cmp	es:byte ptr[di],";"
	je	no_appendeq
	clc					; set ok
	ret

no_appendeq:					; not found, use default
	lea	di,semicolon			; null list
	push	cs
	pop	es
	stc					; set error
	ret

;-----------------------------						  ; @@03
;	This routine is used to locate the current APPEND path string	  ; @@03
;	result to ES:DI.  Used by APPEND status.			  ; @@03

;address_status:						    ; @@13; @@03
;	test	mode_flags,E_mode				    ; @@13; @@03
;	jump	Z,address_pathx 				    ; @@13; @@03
;	jmp	use_cmd_env					    ; @@13; @@03

cap_dl: 					; convert dl to uppercase
	cmp	dl,"a"			; find out if we have a lower case; @@14
	jb	cap_dlx 		; char				  ; @@14
	cmp	dl,"z"							  ; @@14
	ja	cap_dlx 						  ; @@14
	sub	dl,"a"-"A"		; convert char to upper case	  ; @@14
cap_dlx:
	ret

;	end_address:				; this is the end of the TSR stuff		 ;AN002;

page
;-----------------------------------------------------------------------------
;	Main routine. Used to determine if APPEND has been loaded
;	before. If not, load resident portion of APPEND. Then handle setting
;	or displaying appended directory list.
;-----------------------------------------------------------------------------

main_begin:				; DOS entry point

	mov	ax,seg mystack		; set up stack
	mov	ss,ax
	lea	sp,mystack

	cld

	mov	res_append,0		; set external copy		  ; @@05

	push	cs			; make DS point to CS
	pop	ds

	push	cs			; make ES point to CS
	pop	es


;	find out if append has been loaded				  ; @@04
									  ; @@04
	mov	ah,append_2f		; int 2f function code for append ; @@04
	mov	al,are_you_there	; function code to ask if append  ; @@04
					; has been loaded		  ; @@04
	int	int_function						  ; @@04
									  ; @@04
	cmp	al,append_inst		; is append there?		  ; @@04
	jne	not_there_yet		; no				  ; @@04

	mov	dx,0			; set for network version	  ; @@07
	mov	ah,append_2f		; int 2F function code for append ; @@07
	mov	al,DOS_version		; function code for get version   ; @@07
	int	int_function						  ; @@07
	cmp	dx,word ptr version_loc ; does the version match?	  ; @@07
	jne	bad_append_ver		; no, cough up an error messsage  ; @@07


	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,9			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;
;	mov	cx,len_second_APPEND_msg; length of string		 ;AN000;   ; @@04
;	lea	dx,second_APPEND_msg	; second load message		 ;AN000;   ; @@04
;	call	print_STDERR		; display error message 	 ;AN000;   ; @@04
;	lea	dx,crlf 		; carriage return, line feed	  ; @@04
;	mov	cx,crlf_len		; length of string		  ; @@04
;	call	print_STDERR						  ; @@04
									  ; @@04
	mov	al,0fch 		; second load			  ; @@05
	call	terminate		; exit to DOS			  ; @@05

bad_append_ver: 			; append version mismatch	  ; @@07
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,1			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;
;	mov	cx,len_bad_append_msg					 ;AN000;   ; @@07
;	lea	dx,bad_append_msg	; bad app message		 ;AN000;   ; @@07
;	call	print_STDERR						 ;AN000;   ; @@07
;	lea	dx,crlf 		; carriage return, line feed	  ; @@07
;	mov	cx,crlf_len		; length of string		  ; @@07
;	call	print_STDERR						  ; @@07
	mov	ax,0feh 		; bad APPEND version		  ; @@05
	call	terminate		; exit to DOS			  ; @@05

not_there_yet:								  ; @@04

	mov	cs:initial_pass,-1	; set a flag for initial pass			 ;AN007;
	call	do_command		; do actual APPEND

	mov	bx,4			; close all standard files
do_closes:
	mov	ah,3eh			; close file handle
	call	int_21
	dec	bx
	jns	do_closes

	call	set_vectors		; set append vectors on success   ; @@05

	call	Release_Environment	; release the environmental vector space	;an007; dms;

	lea	dx,end_address+15	; normal end
	mov	cl,4			; calc end address in paragraphs
	shr	dx,cl
	mov	ah,get_PSP		; calc space from PSP to my code  ; @@02
	call	int_21							  ; @@02
	mov	ax,cs							  ; @@02
	sub	ax,bx							  ; @@02
	add	dx,ax			; calc length to keep		  ; @@02
	mov	al,0			; exit with no error
	mov	ah,term_stay
	call	int_21

page

COMMAND_begin:				; COMMAND entry point
	save_regs
	mov	word ptr cmd_name@+0,si  ; save internal command buffer @
	mov	word ptr cmd_name@+2,ds
	cld

	mov	abort_sp,sp		; save sp for aborts		  ; @@05
	mov	res_append,1		; set resident copy		  ; @@05
	call	do_command		; do actual APPEND
abort_exit:				; exit to abort append		  ; @@05
	mov	sp,abort_sp						  ; @@05

	push	es
	push	di
	les	di,cmd_name@
	mov	es:byte ptr[di],0	; set no command now
	pop	di
	pop	es

	cmp	ax,0			; error
	jne	no_E_mode_via
	test	mode_flags,E_mode	; no /E processing
	jz	no_E_mode_via

	mov	ax,append_2f*256+dir_ptr; int 2f function code for append
	int	int_function
	push	es
	pop	ds
	mov	si,di

;	mov	ah,get_PSP		; set new command
;	call	int_21
	mov	bx,ss
	mov	es,bx
	mov	bx,cmd_buf		; command line iput buffer
	inc	bx			; skip max length
	mov	es:byte ptr[bx],3+1+6+1
	mov	di,bx			; address command line buffer
	inc	di			; skip current length
	push	ds
	push	si
	push	cs
	pop	ds
	move	,3+1+6+1,setappend_name ; set in "SET APPEND="
	pop	si
	pop	ds
	cmp	ds:byte ptr[si],";"	; null list is special case
	jne	copy_path
append_blank:
	mov	al," "
	stosb
	inc	es:byte ptr[bx]
	jmp	short copy_path_done
no_E_mode_via:
	jmp	short no_E_mode
copy_path:
	mov	dl, byte ptr es:[bx-1]	; get max len of command buffer
	sub	dl, 3+1+6+1		; take care of 'SET APPEND='
;
;------ now find the strlen of path string pointed by ds:si
;
;	REPLACE WITH BETTER CODE LATER --- mohan
;
	push	si			; save ptr to paths
	xor	cx, cx
count_next_char:
	lodsb
	or	al, al
	jz	check_len
	inc	cx
	jmp	count_next_char
null_path:
	pop	si
	jmp	append_blank
check_len:
	pop	si
;
;------ check whether the length is ok
;
	cmp	cl, dl			; len < maxlen ?
	jb	copy_it
	push	si
	add	si, cx			; point to end of path str
next_char:
	jcxz	null_path		; null str ?
	dec	cl
	dec	si
	cmp	byte ptr ds:[si], ';'
	jne	next_char
	cmp	cl, dl			; found ';' but is len ok?
	jae	next_char
	pop	si
	add	byte ptr es:[bx], cl
copy_it:
	rep	movsb
;
;------ The code in this box replaced by code below copy_path:------------
;	 lodsb								;
;	 cmp	 al,0							;
;	 je	 copy_path_done 					;
;	 stosb								;
;	 inc	 es:byte ptr[bx]					;
;	 jmp	 copy_path						;
;--------------------------------------------------------------------------
copy_path_done:
	mov	es:byte ptr[di],cr	; set end delimiter

	les	di,cmd_name@
	mov	al,3			; SET length
	stosb
	push	cs							  ; @@06
	pop	ds							  ; @@06
	move	,8,set_name		; set up "SET" command

	mov	ax,0			; set to do SET
no_E_mode:

	restore_regs
	ret

page

do_command:				; APPEND process

;	set ctrl-break check off
;	first, save the old state so we can restore it later,
;	then turn ctrl-break checking off

	mov	ah,ctrl_break		; function code for ctrl-break check
	xor	al,al			; 0 = get current state
	call	int_21

	mov	ctrl_break_state,dl	; save the old ctrl-break state

	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	xor	dl,dl			; 0 = off
	call	int_21

;	find out if append has been loaded

	mov	ah,append_2f		; int 2f function code for append
	mov	al,are_you_there	; function code to ask if append
					; has been loaded
	int	int_function

	cmp	al,append_inst		; is append there?
	jne	not_already_there	; yes, don't try to put it
	jmp	already_there		; yes, don't try to put it
					; there again

;	get DOS version and decide if it is in the allowed range for
;	APPEND

not_already_there:
	mov	ah,get_version		; lets find out if we should do it
	call	int_21			; try the open
	cmp	ax,expected_version	; compare with DOS version
	jne	bad_DOS

	jmp	SHORT check_assign	; valid range
					; lets see if assign has been loaded

;	Break it to the user that he's trying to do an APPEND with
;	the wrong DOS version

bad_DOS:
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,8			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	mov	cx,len_bad_DOS_msg	; length of string		 ;AN000;
;	lea	dx,bad_DOS_msg		; bad DOS message		 ;AN000;
;	call	print_STDERR		; display error message 	 ;AN000;

	call	ctrl_break_rest
	mov	al,0ffh 		; bad DOS version		  ; @@05
	call	terminate		; exit to DOS			  ; @@05

check_assign:
	mov	ax,0600h
	int	2fh
	or	al,al
	jnz	assign_there
	jmp	SHORT check_TopView	; ASSIGN has not been loaded,	  ; @@01

;	ASSIGN has been loaded before APPEND, bad news!

assign_there:
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,6			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	mov	cx,len_append_assign_msg; length of string
;	lea	dx,append_assign_msg
;	call	print_STDERR		; display error message
	jmp	SHORT conflict_exit						  ; @@01
									  ; @@01
check_Topview:								  ; @@01
	mov	bx,0			; incase not there		  ; @@01
if	not MSVER			; MSKK02 07/14/89
	mov	ax,10h*256+34		; TopView version check 	  ; @@01
	int	15h							  ; @@01
endif
	cmp	bx,0							  ; @@01
	jnz	TopView_there						  ; @@01
	jmp	replace_vector		; TopView has not been loaded,	  ; @@01
									  ; @@01
;	TopView has been loaded before APPEND, bad news!		  ; @@01
									  ; @@01
TopView_there:								  ; @@01
;	mov	cx,len_append_TV_msg	; length of string		  ; @@01
;	lea	dx,append_TV_msg					  ; @@01
;	call	print_STDERR		; display error message 	  ; @@01
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,7			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

									  ; @@01
conflict_exit:								  ; @@01
	call	ctrl_break_rest
	mov	al,0fdh 						  ; @@05
	call	terminate		; exit to DOS			  ; @@05

;	get pointer to dir list, on return ES:DI points to buffer

already_there:

;	This code has been moved to main_begin				  ; @@07
;									  ; @@07
;	make sure the right version of APPEND has been loaded		  ; @@07
;

;	mov	dx,0			; set for network version	  ; @@07
;	mov	ah,append_2f		; int 2F function code for append ; @@07
;	mov	al,DOS_version		; function code for get version   ; @@07
;	int	int_function						  ; @@07
;	cmp	dx,word ptr version_loc ; does the version match?	  ; @@07
;	jump	NE,bad_append_ver	; no, cough up an error messsage  ; @@07

process_args:				; process all arguments

;-------------------------------------------------------------------
	mov	si,0081h		; DS:SI points to argument area
	mov	cs:byte ptr e_switch+9,0	; turn /E switch off

process_argsx:				; process all arguments
;


;	make sure that the /PATH and /X switches are re-enabled, and
;	various flags are cleared

	xor	cx,cx			; ordinal value, must start as 0
	xor	dx,dx			; these regs must be 0 for call to Scan_For_Equal

	mov	ah,"/"
	mov	cs:byte ptr x_switch+9,ah		; re-enable /X switch
	mov	cs:byte ptr path_switch+9,ah		; re-enable /PATH switch
	mov	cs:byte ptr x_result.$P_Type,cl 	; clear flag
	mov	cs:byte ptr path_result.$P_Type,cl	; clear flag
	mov	cs:byte ptr dirs_result.$P_Type,cl	; clear flag
	mov	cs:parse_flag,cl			; clear parse flag

;	set up things to call PARSER

	push	cs			; make sure ES points to segment where
	pop	es			; parm block info is
	lea	di,cs:p_block2		; ES:DI points to parm block, for secondary parsing

;
;	Note CX and DX, cleared above, must stay cleared for this call

	call	Scan_For_Equal		; yes - let's see if we have "=" symbol ;an008; dms;
					; parse past it if we do

get_pars_info:
	call	dword ptr pars_off	; call to COMMAND.COM's parser

	or	ax,ax			; end of line?	-1 if yes
	jns	not_end_of_line 	; no, carry on
	jmp	end_of_line_reached	; yes, go figure out what we got

not_end_of_line:

	or	ax,ax			; no, find out if there an error
	je	not_parse_error 	; no, carry on
	jmp	parse_error		; yes, go display the error message

;	got here without any errors, set the proper bits in mode_flags

not_parse_error:
	mov	cs: parse_flag,0ffh	; set parse flag

check_e:
	cmp	e_result.$P_Type,3	; was there a /E in this pass?
	jne	check_? 		; no, look for an ?

	mov	byte ptr e_switch+9,0	; turn this off so we don't allow another
	mov	e_result.$P_Type,0	; clear this so we don't get fooled later

	or	mode_flags,E_mode	; set E mode on

	jmp	get_pars_info		; go get another argument


check_?:
	cmp	qu_result.$P_Type,3
	jne	check_x
	mov	qu_result.$P_Type,0	; clear this so we don't get fooled later
	call	sysloadmsg				
						
	mov	ax,MSG_OPTIONS_FIRST
p_n:	cmp	ax,MSG_OPTIONS_LAST
	jg 	end_?
	mov	bx,STDOUT		; no handle	
	xor	cx,cx			; sub count	
	xor	dl,dl			; no input	
	mov	dh,-1			; message class 
	call	sysdispmsg				
	inc	ax                      ; sysdispmsg does NOT trash ax
	jmp	short  p_n

end_?:	xor	ax,ax                   ; return normal exit code
	call	ctrl_break_rest
	call    terminate	

check_x:
	cmp	x_result.$P_Type,3	; was there a /X on this pass? list index
	je	set_x			; yes, and it was /X w/o ON or OFF

	cmp	x_result.$P_Type,2	; was there a /X on this pass? list index
	jne	check_path

	mov	byte ptr x_switch+9,0	; turn this off so we don't allow  another
	mov	x_result.$P_Type,0	; clear this so we don't get fooled later

	cmp	x_result.$P_Item_Tag,1	; was /X or /X:ON specified?
	je	set_x			; yes, set X mode on
	and	mode_flags,NOT x_mode	; no, clear it
	jmp	get_pars_info

set_x:
	or	mode_flags,x_mode
	jmp	get_pars_info

check_path:
	cmp	path_result.$P_Type,2	; was there a /path on this pass? list index
	jne	check_dirs

	xor	ah,ah			; turn this off so we don't allow
	mov	byte ptr path_switch+9,ah	 ; another
	mov	path_result.$P_Type,0	; clear this so we don't get fooled later


	cmp	path_result.$P_Item_Tag,1	; was /PATH:ON specified?
	je	set_path			; yes, set PATH mode
	and	mode_flags,NOT path_mode	; no, clear it
	jmp	get_pars_info

set_path:
	or	mode_flags,path_mode	; set PATH mode on
	jmp	get_pars_info

;	find out if dirs specified

check_dirs:
	cmp	dirs_result.$P_Type,3	; was a simple string returned?
	je	check_dirs2		; yes, carry on
	jmp	get_pars_info		; no, all done for now

;	set up stuff to do the dirs copy

check_dirs2:
	push	es
	push	ds
	push	si
	push	di

	lds	si,dword ptr dirs_result.$P_Picked_Val	  ; get pointer to dirs string
	mov	dirs_result.$P_Type,0	; clear this so we don't get fooled later

	mov	di,0			; set incase int 2f not installed ; @@08
	mov	es,di							  ; @@08
	mov	ax,append_2f*256+dir_ptr  ; es:di -> internal result area ; @@08
	int	int_function						  ; @@08
	mov	ax,es			; see if active yet		  ; @@08
	or	ax,di							  ; @@08
	jnz	copy_dirs_loop		; ok, do the copy		  ; @@08
	push	cs			; not active, set myself	  ; @@08
	pop	es							  ; @@08
	lea	di,app_dirs						  ; @@08

copy_dirs_loop:
	movs	es: byte ptr[di],ds:[si]; copy char

	cmp	byte ptr ds:[si-1],0	; is char a null
	je	done_copy_dirs

	jmp	copy_dirs_loop

done_copy_dirs:

	pop	di
	pop	si
	pop	ds
	pop	es

	jmp	get_pars_info		; no error yet, loop till done

end_of_line_reached:
	mov	old_syntax,0		; process old format operands

	cmp	cs:initial_pass,-1	; is this the first APPEND			 ;AN006;
	je	first_one		; yes, clear flag and exit			 ;AN006;

	cmp	cs:parse_flag,0 	; if this flag is off, means null command line
					; was nothing on the command line
	je	display_dirs		; go display the dirs

first_one:										 ;AN006;
	mov	cs:initial_pass,0	; clear first pass flag 			 ;AN006;

done_for_now:
normal_exit:
	call	ctrl_break_rest 	; reset control break checking
	mov	ax,0			; set string
	ret				; exit to COMMAND


parse_error:
	push	ax			;save parser error code 		;an010;bgb
	call	sysloadmsg						 ;AN000;
	pop	ax			;restore parser error coed		;an010;bgb
	call	do_parse_err							;an010;bgb
	jmp	SHORT bad_parmx		; display message and get out

;-------------------------------------------------------------------

;	 mov	 si,0081h		 ; point si to argument area
;	 mov	 bx,ss
;	 mov	 ds,bx
;
;process_argsx: 			 ; process all arguments
;	 mov	 di,0			 ; set incase int 2f not installed ; @@08
;	 mov	 es,di							   ; @@08
;	 mov	 ax,append_2f*256+dir_ptr  ; es:di -> internal result area ; @@08
;	 int	 int_function						   ; @@08
;	 mov	 ax,es			 ; see if active yet		   ; @@08
;	 or	 ax,di							   ; @@08
;	 jnz	 have_ptr						   ; @@08
;	 push	 cs			 ; not active, set myself	   ; @@08
;	 pop	 es							   ; @@08
;	 lea	 di,app_dirs						   ; @@08
;have_ptr:								   ; @@08
;
;;	 step through the DOS command line argument area, and copy the new dir
;;	 list to the proper place in APPEND. This requires some parsing for
;;	 spaces, tabs chars, equal signs, as well as conversion to upper case
;
;	 cmp	 byte ptr[si],"="	 ; APPEND=path is OK syntax
;	 jne	 skip_leading
;	 inc	 si
;skip_leading:				 ; skip leading spaces
;	 lodsb
;	 cmp	 al," "
;	 je	 skip_leading
;	 cmp	 al,tab_char
;	 je	 skip_leading
;	 cmp	 al,"," 						   ; @@15
;	 je	 skip_leading						   ; @@15
;	 cmp	 al,"=" 						   ; @@15
;	 je	 skip_leading						   ; @@15
;	 cmp	 al,cr			 ; did we have command line arguments?
;	 jump	 E,display_dirs 	 ; no, display the dirs currently appended
;	 cmp	 al,"/" 		 ; is it a parm starter?	   ; @@05
;	 jump	 E,bad_path_parm	 ; yes, it's an error              ; @@05
;	 dec	 si
;
;copy_args:
;	 lodsb				 ; get char from command line area
;	 cmp	 al,cr			 ; are we at the end?
;	 jump	 E,found_end		 ; yes, display the currently appended dirs
;	 cmp	 al," " 		 ; is it a space?
;	 je	 found_space		 ; yes, at end
;	 cmp	 al,tab_char		 ; is it a tab?
;	 je	 found_space		 ; yes, treat it like a space
;	 cmp	 al,"/" 		 ; is it a parm starter?
;	 je	 bad_path_parm		 ; yes, it's an error              ; @@05
;	 cmp	 al,"a" 		 ; find out if we have a lower case char
;	 jb	 copy_char						   ; @@14
;	 cmp	 al,"z"
;	 ja	 copy_char						   ; @@14
;	 sub	 al,"a"-"A"		 ; convert char to upper case	   ; @@14
;
;copy_char:
;	 mov	 in_middle,-1		 ; say that we made it to the middle
;	 stosb				 ; no, copy char into resident storage area
;	 jmp	 copy_args		 ; do it some more
;
;found_space:
;	 cmp	 in_middle,0		 ; set the space flag then go through
;	 jump	 E,copy_args		 ; loop some more
;
;found_end:
;	 cmp	 in_middle,0		 ; if I found the end of string but not
;	 jump	 E,display_dirs 	 ; in the middle, go display some dirs
;
;	 mov	 es:byte ptr [di],0	 ; null terminate the string
;	 mov	 in_middle,0
;	 cmp	 al,cr
;	 je	 past_trailing
;
;skip_trailing: 			 ; skip end spaces
;	 lodsb
;	 cmp	 al," "
;	 je	 skip_trailing
;	 cmp	 al,tab_char
;	 je	 skip_trailing
;	 cmp	 al,"/" 		 ; path and parm not together	   ; @@05
;	 je	 bad_path_parm						   ; @@05
;	 cmp	 al,cr			 ; only white space allowed at end
;	 jne	 bad_path
;past_trailing:
;
;	 cmp	 old_syntax,0		 ; go back to normal mode
;	 je	 normal_exit
;	 jmp	 exit_append2
;normal_exit:
;	 call	 ctrl_break_rest	 ; reset control break checking
;	 mov	 ax,0			 ; set string
;	 ret				 ; exit to COMMAND

bad_path:				; bad paath operand
;	mov	cx,len_path_error_msg	; length of string
;	lea	dx,path_error_msg
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
;gga	call	sysdispmsg						 ;AN000;

	jmp	short bad_parmx

bad_path_parm:				; bad parameter 		  ; @@05
;	mov	cx,len_path_parm_error_msg   ; length of string 	  ; @@05
;	lea	dx,path_parm_error_msg					  ; @@05
	call	sysloadmsg						 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; standard error		 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	jmp	short bad_parmx 					  ; @@05
bad_parm:				; bad parameter
;	mov	cx,len_parm_error_msg	; length of string
;	lea	dx,parm_error_msg
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; standard error		 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;

bad_parmx:				; bad parameter
	push	ds
	push	cs
	pop	ds
;	call	print_STDERR		; display error message
	lea	si,inv_parm		; point to msg parm			;an010;bgb
	call	sysdispmsg						 ;AN000;
	pop	ds
	call	ctrl_break_rest
	mov	al,1							  ; @@05
	call	terminate		; exit to DOS			  ; @@05

;	This code has been moved to main_begin				  ; @@07
;bad_append_ver:			; append version mismatch	  ; @@07
;	push	ds							  ; @@07
;	push	cs							  ; @@07
;	pop	ds							  ; @@07
;	mov	cx,len_bad_append_msg					  ; @@07
;	lea	dx,bad_append_msg	; bad app message		  ; @@07
;	call	print_STDERR						  ; @@07
;	lea	dx,crlf 		; carriage return, line feed	  ; @@07
;	mov	cx,crlf_len		; length of string		  ; @@07
;	call	print_STDERR						  ; @@07
;	pop	ds							  ; @@07
;	call	ctrl_break_rest 					  ; @@07
;	mov	ax,0feh 		; bad APPEND version		  ; @@05
;	call	terminate		; exit to DOS			  ; @@05

;	Display currently appended directories

display_dirs:
	call	address_status		; get working path		  ; @@03
	push	ds
	push	es
	pop	ds

	cmp	es:byte ptr[di],";"	; no append now
	je	no_dirs_appended

;	count the chars in the dir list, cx will hold the count

	mov	si,di
	sub	si,6+1			; move pointer to APPEND
	mov	dx,si			; save pointer to string
	xor	cx,cx

scanit:
	lodsb				; get character
	cmp	al,null 		; are we at end?
	je	print_it		; yes, print it
	inc	cx			; look at the next character
	jmp	scanit			; loop till we find the end

print_it:
	call	print_STDOUT		; display appended dirs
	push	cs
	pop	ds
	lea	dx,crlf 		; carriage return, line feed
	mov	cx,crlf_len		; length of string
	call	print_STDOUT
	pop	ds

exit_append:
	cmp	old_syntax,0		; process old format operands
	je	exit_append2
	mov	si,0081h		; set up rescan
	mov	ah,get_PSP
	call	int_21
	mov	ds,bx
	jmp	process_argsx

exit_append2:
	mov	old_syntax,0		; after first time this must be off
	call	ctrl_break_rest 	; reset control break checking
	mov	ax,-1			; no action
	ret				; exit to COMMAND

no_dirs_appended:
	push	cs
	pop	ds

	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,5			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	lea	dx,no_append_msg	; no dirs message		 ;AN000;
;	mov	cx,len_no_append_msg	; length of string		 ;AN000;
;	call	print_STDOUT						 ;AN000;
	pop	ds
	jmp	exit_append2		; APPEND = = fix		    ;GGA

page
;-------------------------------------------------------------------
;	Getting here means that APPEND has not been loaded yet.  Get the
;	old vector, save it, and point the vector to the new routine.
;-------------------------------------------------------------------

replace_vector:

	push	ds
	mov	si,0081h		; point si to argument area
	mov	ah,get_PSP
	call	int_21
	mov	ds,bx

;	Process /X and /E parameters

skip_leading2:				; skip leading spaces
;	lodsb
;	cmp	al," "
;	je	skip_leading2
;	cmp	al,tab_char
;	je	skip_leading2
;	cmp	al,cr			; at end
;	jump	E,parms_done
;	cmp	al,"/"
;	jne	set_old_syntax

found_slash:
;	lodsb
;	cmp	al,"e"
;	je	slash_E
;	cmp	al,"E"
;	je	slash_E
;	cmp	al,"x"
;	je	slash_X
;	cmp	al,"X"
;	je	slash_X
bad_parmy:
;	pop	ds
;	jmp	bad_parm
bad_path_parmy:
;	pop	ds
;	jmp	bad_path_parm

slash_X:
;	test	mode_flags,X_mode	; no duplicates allowed
;	jnz	bad_parmy
;	or	mode_flags,X_mode
;	jmp	short slashx

slash_E:
;	test	mode_flags,E_mode	; no duplicates allowed
;	jnz	bad_parmy
;	or	mode_flags,E_mode
slashx:
;	jmp	skip_leading2		; loop some more
set_old_syntax:
;;	test	mode_flags,0		; no /? switches on old mode
;;	jne	bad_path_parmy
	mov	old_syntax,1
parms_done:
	pop	ds
	jmp	exit_append
page

set_vectors:				; set append hooks		  ; @@05
	push	es

;	Get INT 2f vector. Save to call older 2f handlers

	mov	ax,get_intfcn		; Get INT 2fh vector
	call	int_21
	mov	intfcn_offset,bx	; Save it
	mov	intfcn_segment,es

;	get int 21 vector

	mov	ax,get_vector		; Get INT 21h vector
	call	int_21
	mov	vector_offset,bx	; Save it
	mov	vector_segment,es
	pop	es

	push	ds							  ; @@08
	push	cs							  ; @@08
	pop	ds							  ; @@08
	lea	dx,intfcn_hook		; DS:DX = New INT 2fh vector
	mov	ax,set_intfcn		; Hook the interrupt
	call	int_21

	lea	dx,interrupt_hook	; DS:DX = New INT 21h vector
	mov	ax,set_vector		; Hook the interrupt
	call	int_21

	mov	dirlst_segment,cs	; save the address of the dirlist
	lea	dx,app_dirs
	mov	dirlst_offset,dx
	pop	ds							  ; @@08

	ret								  ; @@05

terminate:				; terminate to dos or return	  ; @@05
	cmp	res_append,0						  ; @@05
	jne	is_res							  ; @@05
	call	Release_Environment	; release environmental vector		;ac009; dms;
	mov	ah,term_proc		; return to DOS on first time	  ; @@05
	call	int_21							  ; @@05
is_res: 								  ; @@05
	mov	ax,-1			; set abort requested		  ; @@05
	jmp	abort_exit		; must go back to COMMAND	  ; @@05


print_STDOUT:
	mov	bx,STDOUT		; Standard output device handle
	mov	ah,awrite		; function code for write
	call	int_21
	ret

print_STDERR:
	mov	bx,STDERR		; Standard output device handle
	mov	ah,awrite
	call	int_21
	ret

Release_Environment:								;an007; dms;

	push	ax			;save regs				;an007; dms;
	push	bx			;					;an007; dms;
	push	es			;					;an007; dms;
	mov	ah,Get_PSP		; get the PSP segment			;an007; dms;
	call	int_21			; invoke INT 21h			;an007; dms;
	mov	es,bx			; BX contains PSP segment - put in ES	;an007; dms;
	mov	bx,word ptr es:[PSP_Env]; get segment of environmental vector	;an007; dms;
	mov	es,bx			; place segment in ES for Free Memory	;an007; dms;
	mov	ah,Free_Alloc_Mem	; Free Allocated Memory 		;an007; dms;
	int	21h			; invoke INT 21h			;an007; dms;
	pop	es			; restore regs				;an007; dms;
	pop	bx			;					;an007; dms;
	pop	ax			;					;an007; dms;

	ret				; return to caller			;an007; dms;

;=========================================================================
; Scan_For_Equal	: This routine scans the command line from the
;			  beginning until it encounters anything other
;			  than the equal, tab, or space characters.
;			  Register SI is sent back to the caller pointing
;			  to the character that does not meet the match
;			  criteria.
;
;	Inputs	: DS:SI - pointer to next parm
;
;	Outputs : SI	- adjusted to byte not matching the following:
;			  "="
;			  " "
;			  TAB
;
;	Author	: David M. Sewell
;	Date	: 1/27/88
;	Version : DOS 3.4
;=========================================================================

Scan_For_Equal:

	push	ax				; save regs			;an008; dms;
	push	cx				;				;an008; dms;

	xor	cx,cx				; clear cx			;an008; dms;
	mov	cl,byte ptr ds:[80h]		; get length of command line	;an008; dms;

Scan_For_Equal_Loop:

	cmp	cx,0				; at end?			;an008; dms;
	jbe	Scan_For_Equal_Exit		; exit loop			;an008; dms;
	mov	al,byte ptr ds:[si]		; get 1st. character		;an008; dms;
	call	Chk_DBCS			; DBCS lead byte?		;an008; dms;
	jnc	Scan_For_Equal_No_DBCS		; no				;an008; dms;
		cmp	byte ptr ds:[si],DB_SP_HI   ; blank lead byte		    ;an008; dms;
		jne	Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;
		cmp	byte ptr ds:[si+1],DB_SP_LO ; DBCS blank		    ;an008; dms;
		jne	Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;

		add	si,2			; yes - DBCS lead byte		;an008; dms;
		sub	dx,2			; decrease counter		;an008; dms;
		jmp	Scan_For_Equal_Loop

Scan_For_Equal_No_DBCS:

	cmp	al,"="				; = found?			;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	cmp	al,20h				; space?			;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	cmp	al,09h				; tab?				;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	jmp	SHORT Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;

Scan_For_Equal_Next:

	inc	si				; adjust ptr			;an008; dms;
	dec	cx				; decrease counter		;an008; dms;
	jmp	Scan_For_Equal_Loop		; continue loop 		;an008; dms;

Scan_For_Equal_Exit:

	pop	cx				;				;an008; dms;
	pop	ax				;				;an008; dms;

	ret					; return to caller		;an008; dms;



;=========================================================================	;an010;bgb
; do_parse_err		: This routine sets up for the display of a parse	;an010;bgb
;			  error, and displays the offending parameter.		;an010;bgb
;										;an010;bgb
;	Inputs	: DS:SI - points just past offending parm in command line	;an010;bgb
;										;an010;bgb
;	Outputs : si_off- parm for msg ret.					;an010;bgb
;		  si_seg- parm for msg ret.					;an010;bgb
;		  command line - hex zero at end of offending parm		;an010;bgb
;										;an010;bgb
;	Date	: 3/29/88							;an010;bgb
;	Version : DOS 4.0 (wow!)						;an010;bgb
;=========================================================================	;an010;bgb
do_parse_err	PROC								;an010;bgb
;;;;;;;;mov	ax,3 ;removed- parser handles this				;an010;bgb
	mov	bx,STDERR		; handle				;an010;bgb
;;;;;;;;xor	cx,cx			; sub count				;an010;bgb
	mov	cx,1			;display invalid parm			;an010;bgb
	xor	dl,dl			; no input				;an010;bgb
	mov	dh,02			; message class of parse error		;an010;bgb
;;;;;;;;mov	cs:si_off,81h		   ;initialize pointer			;an010;bgb
										;an010;bgb
	   dec	  si			;point to last byte of invalid parm	;an010;bgb
public decsi									;an010;bgb
decsi:	   cmp	   byte ptr [si],' '	;are we pointing to a space?		;an010;bgb
;	   $IF	   E,OR 		;if so, we dont want to do that 	;an010;bgb
	   JE $$LL1
	   cmp	   byte ptr [si],0dh	;are we pointing to CR? 		;an010;bgb
;	   $IF	   E			;if so, we dont want to do that 	;an010;bgb
	   JNE $$IF1
$$LL1:
	       dec   si 		;find the last byte of parm		;an010;bgb
	       jmp   decsi							;an010;bgb
;	   $ENDIF								;an010;bgb
$$IF1:
	   mov	   byte ptr [si+1],00	  ;zero terminate display string	;an010;bgb
nextsi: 									;an010;bgb
public nextsi									;an010;bgb
	   dec	   si			;look at previous char			;an010;bgb
	   cmp	   byte ptr [si],' '	;find parm separator			;an010;bgb
	   jnz	   nextsi		;loop until begin of parm found 	;an010;bgb
										;an010;bgb
	mov	cs:si_off,si		;mov si into display parms		;an010;bgb
	mov	cs:si_seg,ds		   ;initialize pointer			;an010;bgb
	ret					; return to caller		;an010;bgb
do_parse_err	ENDP								;an010;bgb


;-------------------------------------------------------------------
;
;-------------------------------------------------------------------

MSG_SERVICES <LOADmsg>
MSG_SERVICES <APPEND.CLB,APPEND.CL2,APPEND.CTL>

end_address:				; this is the end of the TSR stuff		 ;AN004;

include parse.asm			; include the parser code
include msgdcl.inc

cseg	ends
sseg	segment para stack 'STACK'
	assume	ss:sseg
	dw	512 dup(0)
mystack dw	0
sseg	ends



	end	main_begin

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
 	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

append.skl : ..\usa\append.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\append\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\backup\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\command1.asm ===
page ,132
	title	COMMAND - resident code for COMMAND.COM
	name	COMMAND
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;*****************************************************************************
;
; MODULE:	       COMMAND.COM
;
; DESCRIPTIVE NAME:    Default DOS command interpreter
;
; FUNCTION:	       This version of COMMAND is divided into three distinct
;		       parts.  First is the resident portion, which includes
;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
;		       error), and 2EH (command line execute); it also has
;		       code to test and, if necessary, reload the transient
;		       portion. Following the resident is the init code, which
;		       is overwritten after use.  Then comes the transient
;		       portion, which includes all command processing (whether
;		       internal or external).  The transient portion loads at
;		       the end of physical memory, and it may be overlayed by
;		       programs that need as much memory as possible. When the
;		       resident portion of command regains control from a user
;		       program, a check sum is performed on the transient
;		       portion to see if it must be reloaded.  Thus programs
;		       which do not need maximum memory will save the time
;		       required to reload COMMAND when they terminate.
;
; ENTRY POINT:	       PROGSTART
;
; INPUT:	       command line at offset 81H
;
; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
;		       from a secondary command processor via the EXIT
;		       internal command.
;
; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
;		       hang the system.
;
; INTERNAL REFERENCES:
;
;     ROUTINES:        See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
;     DATA AREAS:      See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
; EXTERNAL REFERENCES:
;
;      ROUTINES:       none
;
;      DATA AREAS:     none
;
;*****************************************************************************
;
;			      REVISION HISTORY
;			      ----------------
;
; DOS 1.00 to DOS 3.30
; --------------------------
; SEE REVISION LOG IN COPY.ASM ALSO
;
; REV 1.17
;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
;	       resident since the EXELOAD may have overwritten the transient.
;
; REV 1.18
;    05/21/82  IBM version always looks on drive A
;	       MSVER always looks on default drive
;
; REV 1.19
;    06/03/82  Drive spec now entered in command line
;    06/07/82  Added VER command (print DOS version number) and VOL command
;	       (print volume label)
;
; REV 1.20
;    06/09/82  Prints "directory" after directories
;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
;
; REV 1.50
;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
;	       do it right.
;
; REV 1.70
;	       EXEC used to fork off new processes
;
; REV 1.80
;	       C switch for single command execution
;
; REV 1.90
;	       Batch uses XENIX
;
; Rev 2.00
;	       Lots of neato stuff
;	       IBM 2.00 level
;
; Rev 2.01
;	       'D' switch for date time suppression
;
; Rev 2.02
;	       Default userpath is NUL rather than BIN
;		       same as IBM
;	       COMMAND split into pieces
;
; Rev 2.10
;	       INTERNATIONAL SUPPORT
;
; Rev 2.50
;	       all the 2.x new stuff -MU
;
; Rev 3.30     (Ellen G)
;	       CALL internal command (TBATCH2.ASM)
;	       CHCP internal command (TCMD2B.ASM)
;	       INT 24H support of abort, retry, ignore, and fail prompt
;	       @ sign suppression of batch file line
;	       Replaceable environment value support in batch files
;	       INT 2FH calls for APPEND
;	       Lots of PTR fixes!
;
; Beyond 3.30 to forever  (Ellen G)
; ----------------------
;
; A000 DOS 4.00  -	Use SYSPARSE for internal commands
;			Use Message Retriever services
;			/MSG switch for resident extended error msg
;			Convert to new capitalization support
;			Better error recovery on CHCP command
;			Code page file tag support
;			TRUENAME internal command
;			Extended screen line support
;			/P switch on DEL/ERASE command
;			Improved file redirection error recovery
;	(removed)	Improved batch file performance
;			Unconditional DBCS support
;			Volume serial number support
;	(removed)	COMMENT=?? support
;
; A001	PTM P20 	Move system_cpage from TDATA to TSPC
;
; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
;			require delimiters.
;
; A003	PTM P5,P9,P111	Included in A000 development
;
; A004	PTM P86 	Fix IF command to turn off piping before
;			executing
;
; A005	DCR D17 	If user specifies an extension on the command
;			line search for that extension only.
;
; A006	DCR D15 	New message for MkDir - "Directory already
;			exists"
;
; A007	DCR D2		Change CTTY so that a write is done before XDUP
;
; A008	PTM P182	Change COPY to set default if invalid function
;			returned from code page call.
;
; A009	PTM P179	Add CRLF to invalid disk change message
;
; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
;			transient COMMAND.
;
; A011	DCR D130	Change redirection to overwrite an EOF mark
;			before appending to a file.
;
; A012	PTM P189	Fix redirection error recovery.
;
; A013	PTM P330	Change date format
;
; A014	PTM P455	Fix echo parsing
;
; A015	PTM P517	Fix DIR problem with * vs *.
;
; A016	PTM P354	Fix extended error message addressing
;
; A017	PTM P448	Fix appending to 0 length files
;
; A018	PTM P566,P3903	Fix parse error messages to print out parameter
;			the parser fails on. Fail on duplicate switches.
;
; A019	PTM P542	Fix device name to be printed correctly during
;			critical error
;
; A020	DCR D43 	Set append state off while in DIR
;
; A021	PTM P709	Fix CTTY printing ascii characters.
;
; A022	DCR D209	Enhanced error recovery
;
; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
;
; A024	PTM P899	Fix EXTOPEN open modes.
;
; A025	PTM P922	Fix messages and optimize PARSE switches
;
; A026	DCR D191	Change redirection error recovery support.
;
; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
;			with a carriage return.
;
; A028	PTM P1076	Print a blank line before printing invalid
;			date and invalid time messages.
;
; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
;			and TIME.
;
; A030	DCR D201	New extended attribute format.
;
; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
;
; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
;
; A033	PTM P1298	Fix problem with system crashes on ECHO >""
;
; A034	PTM P1387	Fix COPY D:fname+,, to work
;
; A035	PTM P1407	Fix so that >> (appending) to a device does
;			do a read to determine eof.
;
; A036	PTM P1406	Use 69h instead of 44h to get volume serial
;			so that ASSIGN works correctly.
;
; A037	PTM P1335	Fix COMMAND /C with FOR
;
; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
;
; A039	DCR D284	Change invalid code page tag from -1 to 0.
;
; A040	PTM P1787	Fix redirection to cause error when no file is
;			specified.
;
; A041	PTM P1705	Close redirected files after internal APPEND
;			executes.
;
; A042	PTM P1276	Fix problem of APPEND paths changes in batch
;			files causing loss of batch file.
;
; A043	PTM P2208	Make sure redirection is not set up twice for
;			CALL'ed batch files.
;
; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
;			as an end of line character
;
; A045	PTM P2560	Make sure we don't lose parse, critical error,
;			and extended message pointers when we EXIT if
;			COMMAND /P is the top level process.
;
; A046	PTM P2690	Change COPY message "fn File not found" to
;			"File not found - fn"
;
; A047	PTM P2819	Fix transient reload prompt message
;
; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
;			when DBCS code was added.
;
; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
;			on line.
;
; A050	PTM P3030	Fix TYPE to work properly on files > 64K
;
; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
;
; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
;
; A053	PTM P2865	Fix DIR to work in 40 column mode.
;
; A054	PTM P3407	Code reduction and critical error on single line
;	PTM P3672	(Change to single parser exported under P3407)
;
; A055	PTM P3282	Reset message service variables in INT 23h to fix
;			problems with breaking out of INT 24h
;
; A056	PTM P3389	Fix problem of environment overlaying transient.
;
; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
;			before the "string".  EX: COMMAND /CDIR
;
; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
;			DBCS switch.
;
; A059	PTM P3394	Change the TIME command to right align the display of
;			the time.
;
; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
;			messages to be disk based.  Only keep them if /MSG
;			is used.
;
; A061	PTM P3928	Fix so that transient doesn't reload when breaking
;			out of internal commands, due to substitution blocks
;			not being reset.
;
; A062	PTM P4079	Fix segment override for fetching address of environment
;			of parent copy of COMMAND when no COMSPEC exists in
;			secondary copy of environment.	Change default slash in
;			default comspec string to backslash.
;
; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
;			text for critical error messages.
;
; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
;	5/20/88 	with Microsoft product already shipped.
;
; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
;	 5/20/88	with Microsoft product already shipped.
;
; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
;	 5/24/88	cases; where the listing would barely fit without the
;			header and space remaining.
;
; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
;			environment was putting a "Z block" marker in the old
;			environment.  The fix is to move to the old environment
;			to the new environment before doing the SETBLOCK.
;
; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
;        09/19/88       because the check for APPEND needed to be performed
;                       before the DIR's findfirst.
;
; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
;                       loading trans w/new comspec with no user change comspec.
;
; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
;        11/05/88       Expansion of environment variables into batch line of
;                       128 chars was not being counted and "%" which should be
;                       ignored were being counted.
;
; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
;        03/02/89       used.  Comspec_flag was not in protected data file be-
;                       ing included in checksum and was being overwritten by
;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
;                       Also removed fix A069 (because flag now protected).
;
; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
;        07/25/89       version and CSD version in U.S. date format.  Files
;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
;
;***********************************************************************************

;
;	Revision History
;	================
;
;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
;				at init time (date/time prompt)
;


.xcref
.xlist
	include dossym.inc		; basic DOS symbol set
	include syscall.inc		; DOS function names
	include comsw.asm		; build version info
	include comequ.asm		; common command.com symbols
	include resmsg.equ		; resident message names

	include comseg.asm		;segment ordering
.list
.cref

CODERES segment public byte
CODERES ends

DATARES 	segment public byte
		extrn	AccDen:byte
		extrn	Batch:word
		extrn	EchoFlag:byte
		extrn	ExeBad:byte
		extrn	ExecEMes:byte
		extrn	ExecErrSubst:byte
		extrn	ExtCom:byte
		extrn	ForFlag:byte
		extrn	IfFlag:byte
		extrn	InitFlag:BYTE
		extrn	Nest:word
		extrn	PipeFlag:byte
		extrn	RBadNam:byte
		extrn	RetCode:word
		extrn	SingleCom:word
		extrn	TooBig:byte

		extrn	OldDS:word
                EXTRN   SCS_REENTERED:BYTE
                EXTRN   SCS_CMDPROMPT:BYTE

DATARES 	ends


INIT		segment public para
		extrn	ConProc:near
		extrn	Init_Contc_SpecialCase:near
INIT		ends


		include envdata.asm

Prompt32        equ     1

;***	START OF RESIDENT PORTION

CODERES segment public byte

	public	Ext_Exec
	public	ContC
	public	Exec_Wait
	public	Exec_Ret

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	extrn	LodCom:near
	extrn	LodCom1:near

	org	0
Zero	=	$

;;	org	80h - 1
;;ResCom	label byte
;;	public	ResCom

;;	org	100h

public	StartCode
StartCode:
;;	jmp	RESGROUP:ConProc



;***	EXEC error handling
;
;	COMMAND has issued an EXEC system call and it has returned an error.
;	We examine the error code and select an appropriate message.

;	Bugbug:	optimize reg usage in following code?  Careful of DX!
;	Condense the error scan?
;	RBADNAM is checked by transient, no need here?
;	Move below Ext_Exec.

Exec_Err:
;SR;
; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
;in order here

	assume	ds:DATARES,es:DATARES

;	Bugbug:	can we use byte compares here?
;	Might be able to use byte msg#s, too.

;	Store errors in a 3 or 4 byte table.  Msg #s in another.
;	Speed not high priority here.

;	Move this to transient.

	mov	bx,offset DATARES:RBadNam
	cmp	al,ERROR_FILE_NOT_FOUND
	je	GotExecEMes		  	; bad command
	mov	bx,offset DATARES:TooBig
	cmp	al,ERROR_NOT_ENOUGH_MEMORY
	je	GotExecEMes		 	; file not found
	mov	bx,offset DATARES:ExeBad
	cmp	al,ERROR_BAD_FORMAT
	je	GotExecEMes		 	; bad exe file
	mov	bx,offset DATARES:AccDen
	cmp	al,ERROR_ACCESS_DENIED
	je	GotExecEMes		 	; access denied

Default_Message:
	mov	bx,offset DATARES:ExecEMes	; default message
	mov	si,offset DATARES:ExecErrSubst ; get address of subst block

GotExecEMes:
        mov     dx,bx                           ; DX = ptr to msg
;; williamh: no reason of doing this. When command.com receives a command,
;;	     it means the VDM process has been created successfully and there
;;	     is no way for the parent process to know that we are not able
;;	     to launch the program and therefore, it won't display any error
;;	     message for us.
;;	 cmp	 byte ptr [scs_reentered],1
;;	 jne	 NoErrMsg
;;	 cmp	 byte ptr [scs_cmdprompt],Prompt32
;;	 je	 NoErrMsg
        invoke  RPrint
NoErrMsg:
	jmp	short NoExec



;***	EXEC call
;
;	The transient has set up everything for an EXEC system call.
;	For cleanliness, we issue the EXEC here in the resident 
;	so that we may be able to recover cleanly upon success.
;
;	CS,DS,ES,SS = DATARES seg addr

Ext_Exec:
;SR;
; The words put on the stack by the stub will be popped off when we finally
;jump to LodCom ( by LodCom).
;
;;	int	21h			; do the exec

Exec_Ret:
	jc	Exec_Err		; exec failed

;	The exec has completed.  Retrieve the exit code.

Exec_Wait:
	mov	ah,WAITPROCESS		; get errorlevel
	int	21h			; get the return code
	mov	RetCode,ax

;	See if we can reload the transient.  The external command
;	may have overwritten part of the transient.

NoExec:
;SR;
; ds = es = ss = DATARES when we jump to LodCom
;
	jmp	LodCom




;***	Int 23 (ctrl-c) handler
;
;	This is the default system INT 23 handler.  All processes
;	(including COMMAND) get it by default.  There are some
;	games that are played:  We ignore ^C during most of the
;	INIT code.  This is because we may perform an ALLOC and
;	diddle the header!  Also, if we are prompting for date/time
;	in the init code, we are to treat ^C as empty responses.


;	Bugbug:	put init ctrl-c handling in init module.

;SR;
; The stub has pushed the previous ds and DATARES onto the stack. We get
;both these values off the stack now
;
ContC	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;OldDS = old ds

	test	InitFlag,INITINIT		; in initialization?
	jz	NotAtInit			; no
	test	InitFlag,INITSPECIAL		; doing special stuff?
	jz	CmdIRet 			; no, ignore ^C
	pop	ds			; restore before jumping; M021
	jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
CmdIret:
;SR;
; Restore ds to its previous value
;

;	mov	ds,OLdDS		;
	pop	ds
	iret				; yes, ignore the ^C

NotAtInit:
	test	InitFlag,INITCTRLC		; are we already in a ^C?
	jz	NotInit 			; nope too.

;*	We are interrupting ourselves in this ^C handler.  We need
;	to set carry and return to the user sans flags only if the
;	system call was a 1-12 one.  Otherwise, we ignore the ^C.

	cmp	ah,1
	jb	CmdIRet
	cmp	ah,12
	ja	CmdIRet

	pop	ds			;restore ds to old value
	add	sp,6				; remove int frame
	stc

;	mov	ds,OldDS		;restore ds to its old value
	ret	2				; remove those flags...

NotInit:

;*	We have now received a ^C for some process (maybe ourselves
;	but not at INIT).
;	
;	Note that we are running on the user's stack!!!  Bad news if
;	any of the system calls below go and issue another INT
;	24...  Massive stack overflow!  Another bad point is that
;	SavHand will save an already saved handle, thus losing a
;	possible redirection...
;	
;	All we need to do is set the flag to indicate nested ^C. 
;	The above code will correctly flag the ^C diring the
;	message output and prompting while ignoring the ^C the rest
;	of the time.
;	
;	Clean up: flush disk.  If we are in the middle of a batch
;	file, we ask if he wants to terminate it.  If he does, then
;	we turn off all internal flags and let the DOS abort.

	or	InitFlag,INITCTRLC	; nested ^c is on
	sti

;;	push	cs			; el yucko!  change the user's ds!!
;;	pop	ds
;;	assume	ds:RESGROUP

	pop	ax			;discard the old ds value

	mov	ax,SingleCom
	or	ax,ax
	jnz	NoReset
	push	ax
	mov	ah,DISK_RESET
	int	21h			; reset disks in case files were open
	pop	ax

NoReset:

;	In the generalized version of FOR, PIPE and BATCH, we would
;	walk the entire active list and free each segment.  Here,
;	we just free the single batch segment.

	test	Batch,-1
	jz	ContCTerm
	or	ax,ax
	jnz	ContCTerm
	invoke	SavHand
	invoke	AskEnd			; ask if user wants to end batch

;	If the carry flag is clear, we do NOT free up the batch file

	jnc	ContBatch
	mov	cl,EchoFlag		; get current echo flag
	push	bx

ClearBatch:
	mov	es,Batch		; get batch segment
	mov	di,BatFile		; get offset of batch file name
;	Bugbug:	verify the following shell interface still works
;;	mov	ax,MULT_SHELL_BRK	; does the SHELL want this terminated?
;;	int	2Fh			; call the SHELL
;;	cmp	al,SHELL_ACTION 	; does shell want this batch?
;;	je	Shell_Bat_Cont		; yes - keep it

	mov	bx,es:BatForPtr		; get old FOR segment
	cmp	bx,0			; is a FOR in progress
	je	no_bat_for		; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,DEALLOC		;
	int	21h			;
	pop	es			; restore to batch segment

No_Bat_For:
	mov	cl,es:BatEchoFlag	; get old echo flag
	mov	bx,es:BatLast	 	; get old batch segment
	mov	ah,DEALLOC		; free it up...
	int	21h
	mov	Batch,bx		; get ready to deallocate next batch
	dec	nest			; is there another batch file?
	jnz	ClearBatch		; keep going until no batch file


;	We are terminating a batch file; restore the echo status


Shell_Bat_Cont: 			; continue batch for SHELL

	pop	bx
	mov	EchoFlag,cl		; reset echo status
	mov	PipeFlag,0		; turn off pipeflag
ContBatch:
	invoke	Crlf			; print out crlf before returning
	invoke	RestHand

;	Yes, we are terminating.  Turn off flags and allow the DOS to abort.

ContCTerm:
	xor	ax,ax			; indicate no read
	mov	bp,ax

;	The following resetting of the state flags is good for the
;	generalized batch processing.

	mov	IfFlag,al		; turn off iffing
	mov	ForFlag,al		; turn off for processing
	call	ResPipeOff
	cmp	SingleCom,ax		; see if we need to set singlecom
	jz	NoSetSing
	mov	SingleCom,-1		; cause termination on 
					;  pipe, batch, for
NoSetSing:

;	If we are doing an internal command, go through the reload process.
;	If we are doing an external, let DOS abort the process.
;	In both cases, we are now done with the ^C processing.

	and	InitFlag,not INITCTRLC
	cmp	ExtCom,al
	jnz	DoDAb				; internal ^c
	jmp	LodCom1
DoDAb:
	stc					; tell dos to abort

;SR;
;We dont need to restore ds here because we are forcing DOS to  do an abort
;by setting carry and leaving flags on the stack
;
	ret					; Leave flags on stack
ContC	endp


;SR;
; ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
;both have ds = DATARES
;

ResPipeOff:
	public	ResPipeOff

	assume	ds:DATARES,es:NOTHING

	savereg <ax>
	xor	ax,ax
	xchg	PipeFlag,al
	or	al,al
	jz	NoPipePop
	shr	EchoFlag,1
NoPipePop:
	restorereg  <ax>
	return


CODERES ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\buildmsg.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* -------------------------------------------------------------------------- */

#include "dos.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "ctype.h"
#include "process.h"
#include "malloc.h"
#include "bldmsg.h"

/* -------------------------------------------------------------------------- */

#define FALSE		(char) (1==0)
#define TRUE		(char) !FALSE
#define NUL		(char) '\0'
#define READONLY	0
#define NAME_COMMAND	"COMMAND\0"     /* Mar 88, SWN */

#define MAXLINE 	200		/* Supposed to be used for getting the message text. */
#define MAXUTILERROR	       300
#define MAXEXTENDEDERROR       100
#define MAXPARSERERROR		20
#define MAXCOMMONERROR	       100
#define MAXLENGTH	       500
#define TOTALUTIL		45

/* -------------------------------------------------------------------------- */

#define ParseOrExtend ((!strnicmp(USEstring,"PARSE\n",5) ) || (!strnicmp(USEstring,"EXTEND\0",5) ) )
#define IsReserved(c)	( (c == '1') || (c == '2') )

/* -------------------------------------------------------------------------- */

	char	*MessageSkeletonFilePtr;


	char	*CommentLinePtr = "\x0d\x0a; ----------------------------------------------------------\x0d\x0a\x0d\x0a";

	char	EofFlags[256];

	char	ClassFlag1;
	char	ClassFlag2;
	int	ClassCount;
	int	ClassCounts[256];
	int	CurrentClass;
	int	CurrentClassIndex;
	int	CurrentMessageNumber;
	int	LineNumber;
	int	add_crlf ;

	int	Pass;

	char	Done;
	char	MessagePending;
	char	ClassPending;

	char	UtilityName[16];
	char	USEstring[16] ;
	char	Is_Utility_Command[16]; /* Mar 88, SWN */
	char	Is_Command_set[] = "12cdeCDE";
	char	CurrentClassFileName[128];

	unsigned	SkeletonHandle = 0xffff;
	unsigned	ClassHandle = 0xffff;
	unsigned	CommonMessageLines;
	unsigned	ParserMessageLines;
	unsigned	ExtendedMessageLines;
	unsigned	UtilMessageLines;
	unsigned	ContinueLine;

	char	CountryIdx[128];
	char	CountryMsg[128];
	char	CountryName[128];

	char	ReadCommonFlag = FALSE;
	char	ReadExtendFlag = FALSE;
	char	ReadParserFlag = FALSE;
	char	ReadUtilFlag   = FALSE;

	char	*UtilErrorTexts[MAXUTILERROR+1];
	char	*ExtendedErrorTexts[MAXEXTENDEDERROR+1];
	char	*ParserErrorTexts[MAXPARSERERROR+1];
	char	*CommonErrorTexts[MAXCOMMONERROR+1];

	char	Debugging = FALSE;

/* -------------------------------------------------------------------------- */

void	 error(union REGS *, union REGS *, struct SREGS *);

void	 LineInput( unsigned, char far * );
unsigned DosRead( unsigned, char far *, int );
unsigned DosWrite( unsigned, char far *, int );
long	 DosLSeek( unsigned, long, int );
void	 DosClose( unsigned );
unsigned DosOpen( char far *, unsigned );
unsigned DosCreate( char far *, unsigned );

unsigned LowOf(long);
unsigned HighOf(long);
long	 LongOf(unsigned, unsigned);

void	 main(int, char * []);

void	 ProcessSkeletonFile(char *);
void	 UtilRecord(char *);
void	 ClassRecord(char *);
void	 DefRecord(char *);
void	 UseRecord(char *);
void	 EndRecord(char *);
void	 DefContinue(char *);
void	 UseContinue(char *);
void	 MessageTerminate(void);
void	 ClassTerminate(void);

void	 CommentLine(void);
void	 BlankLine(void);
void	 PublicLine(void);
void	 ReadCommon(void);

char	*MyMalloc(int);

/* -------------------------------------------------------------------------- */

void	main(argc,argv)
int	argc;
char	*argv[];
{

	int		i;
	char		*s;
	unsigned	len;

	char	 far	*PspCharPtr;
	unsigned far	*PspWordPtr;
	unsigned long	ProgramSize;
	unsigned long	MemoryAllocatable;

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	/* check for assistance needed */

	if ( (argc < 3) && (*argv[1] == (char) '?') )
	      {
		printf("BUILDMSG country skeleton-file-spec\n");
		exit(1);
		}

	/* get the 1st parm is the Country name       */
	/* get the skeleton file name (2nd Parm) to be processed */

	strcpy(CountryName, argv[1]);
    strupr(CountryName);
	strcpy(CountryIdx,CountryName);
	strcat(CountryIdx, ".IDX");
	strcpy(CountryMsg,CountryName);
	strcat(CountryMsg, ".MSG");

	for (i = 0; i <= MAXUTILERROR	 ; i++) UtilErrorTexts[i]     = "";
	for (i = 0; i <= MAXEXTENDEDERROR; i++) ExtendedErrorTexts[i] = "";
	for (i = 0; i <= MAXPARSERERROR  ; i++) ParserErrorTexts[i]   = "";
	for (i = 0; i <= MAXCOMMONERROR  ; i++) CommonErrorTexts[i]   = "";

	for (i = 0; i < 256; i++)
	      {
		ClassCounts[i] = 0;
		EofFlags[i] = TRUE;
		}

    if ( (argc > 3) && (strnicmp(argv[3],"/D",2) == 0) ) Debugging = TRUE;

	InRegs.x.ax = 0x6200;
	intdos(&InRegs, &OutRegs);

	printf("BuildMsg - PSP at %04x\n",OutRegs.x.bx);
	FP_SEG(PspWordPtr) = OutRegs.x.bx;
	FP_OFF(PspWordPtr) = 0;
	FP_SEG(PspCharPtr) = OutRegs.x.bx;
	FP_OFF(PspCharPtr) = 0;
	ProgramSize = (unsigned long) *(PspWordPtr+1);
	printf("Program memory size is %ld\n",ProgramSize);

	InRegs.x.ax = 0x4800;
	InRegs.x.bx = 0xffff;
	intdos(&InRegs, &OutRegs);
	if (OutRegs.x.cflag)
	      {
		InRegs.x.bx = OutRegs.x.bx;
		}
	 else {
		SegRegs.es = OutRegs.x.ax;
		InRegs.x.ax = 0x4900;
		intdosx(&InRegs, &OutRegs, &SegRegs);
		}

	MemoryAllocatable = (unsigned long) InRegs.x.bx;
	MemoryAllocatable *= 16;
	printf("Allocatable memory size is %ld\n",MemoryAllocatable);


	ProcessSkeletonFile(argv[2]);

	exit(0);

}

/* -------------------------------------------------------------------------- */

void	ProcessSkeletonFile(FileName)
char	*FileName;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	unsigned	SkeletonHandle;

	char		*s;
	int		i;
	char		out[128];

	char		CurrentRecord[256];
	char		RecordTypeText[32];
	int		LastRecord;
	char		Processed;


	MessageSkeletonFilePtr = FileName;

	printf("Processing [%s]\n",MessageSkeletonFilePtr);

	/* Process the MESSAGE.SKL file */

	SkeletonHandle = DosOpen( (char far *) MessageSkeletonFilePtr, READONLY);

	ClassCount = 0;

	for (Pass = 1; Pass < 3; Pass++)
	      {
		if (Debugging) printf("--> Starting Pass %d <--\n",Pass);
		ClassFlag1 = FALSE;
		ClassFlag2 = FALSE;
		CurrentClassIndex = 0;
		LineNumber = 0;
		CurrentClass = 0;
		Done = FALSE;
		LastRecord = 0;
		MessagePending = FALSE;
		ClassPending = FALSE;

		InRegs.x.ax = 0x4200;
		InRegs.x.bx = SkeletonHandle;
		InRegs.x.cx = 0;
		InRegs.x.dx = 0;
		intdosx(&InRegs,&OutRegs,&SegRegs);
		if (OutRegs.x.cflag)
			error(&InRegs,&OutRegs,&SegRegs);

		while ( (!EofFlags[SkeletonHandle]) && (!Done) )
		      { CurrentRecord[0] = NUL;
			LineInput(SkeletonHandle, (char far *) &CurrentRecord[0] );
			LineNumber++;

			RecordTypeText[0] = NUL;
			sscanf(&CurrentRecord[0]," %s ",&RecordTypeText[0]);
			i = strlen(RecordTypeText);

            strupr(RecordTypeText);

			if (RecordTypeText[0] == (char) ':') Processed = FALSE;
						       else  Processed = TRUE;

			if (strcmp(RecordTypeText,":UTIL")  == 0)
			      { UtilRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 1;
				}

			if (strcmp(RecordTypeText,":CLASS") == 0)
			      { ClassRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 2;
				}

			if (strcmp(RecordTypeText,":DEF")   == 0)
			      { DefRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 3;
				}

			if (strcmp(RecordTypeText,":USE")   == 0)
			      { UseRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 4;
				}

			if (strcmp(RecordTypeText,":END")   == 0)
			      { EndRecord(&CurrentRecord[i]);
				Processed = TRUE;
				LastRecord = 5;
				}

			if (!Processed)
			      { printf("Error: unrecognized record in skeleton file, line %d\n",LineNumber);
				exit(1);
				}

			}

		if (!ClassFlag1) ClassRecord(" 1 ");
		if (!ClassFlag2) ClassRecord(" 2 ");

		if (MessagePending) MessageTerminate();
		if (ClassPending) ClassTerminate();

		if (Debugging) printf("--> Ending   Pass %d <--\n",Pass);
		}

	DosClose(SkeletonHandle);

	sprintf(CurrentClassFileName,"%s.CTL",UtilityName);
	ClassHandle = DosCreate((char far *) &CurrentClassFileName[0], 0);
	i = sprintf(out,"$M_NUM_CLS  EQU %d\x0d\x0a",ClassCount-2);
	DosWrite(ClassHandle,(char far *) &out[0], i);
	DosClose(ClassHandle);

	SkeletonHandle = 0xfffe;  /*  0xfffe == -2  */

	return;

	}

/* -------------------------------------------------------------------------- */

void UtilRecord(Record)
char	*Record;
{

	sscanf(Record," %s ",UtilityName);

    strupr(UtilityName);

	if (Pass == 1)
	      {
		printf(" Utility Name = [%s]\n",UtilityName);
		ReadCommon();

		}

	return;
	}

/* -------------------------------------------------------------------------- */

void	PublicLine()
{

	int	i;
	char	out[128];

	if ( !IsReserved(CurrentClass) ) i = sprintf(out,"        PUBLIC  $M_CLS_%d\x0d\x0a",CurrentClassIndex);
				else i = sprintf(out,"        PUBLIC  $M_MSGSERV_%c\x0d\x0a",CurrentClass);

	DosWrite(ClassHandle,(char far *) &out[0], i);

	return;

	}

/* -------------------------------------------------------------------------- */

void ClassRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i;
	char	out[128];

	MessageTerminate();
	ClassTerminate();

	while ( isspace(*Record) ) Record++;

	*Record = (char) toupper(*Record);
	CurrentClass = (int) *Record;

	if ( !IsReserved(CurrentClass) ) CurrentClassIndex++;

	if (CurrentClass == '1') ClassFlag1 = TRUE;
	if (CurrentClass == '2') ClassFlag2 = TRUE;

	sprintf(CurrentClassFileName,"%s.%s%c",UtilityName,"CL",CurrentClass);

	if (Pass == 1)
	      {
		ClassHandle = DosCreate((char far *) &CurrentClassFileName[0], 0);

		printf(" Created include file [%s]\n",CurrentClassFileName);

		CommentLine();

		PublicLine();
		i = sprintf(out,"        IF1\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        %%out    ... Including message Class %c\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        ENDIF\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);

		CommentLine();

		i = sprintf(out,"$M_CLASS_%c_STRUC LABEL BYTE\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        $M_CLASS_ID <%03XH,EXPECTED_VERSION,Class_%c_MessageCount>\x0d\x0a",
			   ((!IsReserved(CurrentClass)) ? 255 : (CurrentClass-'0')),CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);

		CommentLine();

		ClassCount++;

		}

	if (Pass == 2)
	      {

		ClassHandle = DosOpen((char far *) &CurrentClassFileName[0], 2);

		InRegs.x.ax = 0x4202;
		InRegs.x.bx = ClassHandle;
		InRegs.x.cx = 0;
		InRegs.x.dx = 0;
		intdosx(&InRegs,&OutRegs,&SegRegs);
		if (OutRegs.x.cflag)
			error(&InRegs,&OutRegs,&SegRegs);

		}

	ClassPending = TRUE;

	return;
	}

/* -------------------------------------------------------------------------- */

void	CommentLine()
{

	DosWrite(ClassHandle,(char far *) CommentLinePtr, strlen(CommentLinePtr) );

	return;

	}

/* -------------------------------------------------------------------------- */

void	BlankLine()
{

	DosWrite(ClassHandle,(char far *) "\x0d\x0a", 2 );

	return;

	}

/* -------------------------------------------------------------------------- */

void DefRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i,m;
	char	*TextPtr;
	char	*NumberPtr;
	char	out[128];
	char	ActualMsg[256];
	int	MsgNumber;

	char	MsgStatus;
	char	MsgLevel[5];

	char	*LfPtr;

	if ( IsReserved(CurrentClass) )
	      { printf("Error: :DEF not allowed in Class 1 or Class2, line %d\n",LineNumber);
		exit(1);
		}

	MessageTerminate();

	TextPtr = Record;
	while ( (isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;
	NumberPtr = TextPtr;
	while ( (!isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;

	sscanf(NumberPtr," %d ",&CurrentMessageNumber);

	if (Pass == 1)
	      {
		BlankLine();

		i = sprintf(out,"$M_%c_%05XH_STRUC LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        $M_ID   <%05XH,0,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",  */
		i = sprintf(out,"        $M_ID   <%05XH,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",    /* Mar 88, SWN */
				CurrentMessageNumber,CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		}

	if (Pass == 2)
	      {
		BlankLine();
		while ( (*TextPtr != NUL) && (isspace(*TextPtr)) ) TextPtr++;

		i = sprintf(out,"$M_%c_%05XH_MSG LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        DW      $M_%c_%05XH_END-$M_%c_%05XH_MSG-2\x0d\x0a",     */
		i = sprintf(out,"        DB      $M_%c_%05XH_END-$M_%c_%05XH_MSG-1\x0d\x0a",    /* Mar 88, SWN */
				CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);

		for ( m=1; m <= UtilMessageLines; m++)
		      {
			sscanf(UtilErrorTexts[m], " %d %s %s ",&MsgNumber,&MsgStatus,&MsgLevel[0]);
			LfPtr = strchr(UtilErrorTexts[m], ' ');
			LfPtr = strchr(LfPtr+1, ' ');
			LfPtr = strchr(LfPtr+1, ' ');
			strcpy(ActualMsg, LfPtr+1 );
			if ( MsgNumber == CurrentMessageNumber)
			      {
				if (Debugging) printf("DefRecord() :: MsgNumber = %d, CurrentMessageNumber = %d\n",
						       MsgNumber,CurrentMessageNumber);
				i = sprintf(out,"        DB      %s\x0d\x0a",ActualMsg);
				DosWrite(ClassHandle,(char far *) &out[0], i);
				ContinueLine = m + 1;
				}
			}

		MessagePending = TRUE;
	      }


	return;
	}

/* -------------------------------------------------------------------------- */

void UseRecord(Record)
char	*Record;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	int	i,j;
	char	*TextPtr;
	char	*NumberPtr;
	int	TempNumber;
	char	out[128];

	MessageTerminate();

	NumberPtr = Record;
	while ( (isspace(*NumberPtr)) && (*NumberPtr != NUL) ) NumberPtr++;

	if ( (isdigit(*NumberPtr)) || ( (*NumberPtr == (char) '-') && (isdigit(*(NumberPtr+1))) ) )
	      { if ( IsReserved(CurrentClass) )
		      { printf("Error: :USE in CLASS 1, cannot specify a msg-number on line %d\n",LineNumber);
			exit(1);
			}

		sscanf(NumberPtr," %d ",&CurrentMessageNumber);

		TextPtr = NumberPtr;
		while ( (!isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;
		while ( ( isspace(*TextPtr)) && (*TextPtr != NUL) ) TextPtr++;

		strcpy(USEstring, "empty\0");

        if (strnicmp(TextPtr,"PARSE",5) == 0)  { strcpy(USEstring, "PARSE\0");  i = 5; j = 1; }
        if (strnicmp(TextPtr,"COMMON",6) == 0) { i = 6; j = 2; }
        if (strnicmp(TextPtr,"EXTEND",6) == 0) { strcpy(USEstring, "EXTEND\0"); i = 6; j = 3; }

		NumberPtr = TextPtr + i;
		sscanf(NumberPtr," %d ",&TempNumber);

		switch(j)
		      {
			case 1: if (TempNumber <= MAXPARSERERROR)
					TextPtr = ParserErrorTexts[TempNumber];
				   else if (TempNumber == 999)
					      { TextPtr = ParserErrorText999;
						}
					   else TextPtr = "";
				break;
			case 2: if (TempNumber <= MAXCOMMONERROR)
					TextPtr = CommonErrorTexts[TempNumber];
				   else TextPtr = "";
				break;
			case 3: if (TempNumber <= MAXEXTENDEDERROR)
					TextPtr = ExtendedErrorTexts[TempNumber];
				   else if (TempNumber == 999)
					      { TextPtr = ExtendedErrorText999;
						}
					   else TextPtr = "";
				break;

			default:TextPtr = "";
				break;
			}

		if (*TextPtr == NUL)
		      { printf("Error: :USE of PARSE, COMMON or EXTENDED with invalid msg-number, line %d\n",LineNumber);
			if (Debugging) printf("then ->CurrentMessageNumber = %d, TempNumber = %d, j = %d\n",
					       CurrentMessageNumber,TempNumber,j);
			exit(1);
			}

		}

	 else {

		strcpy(USEstring, "empty\0");

		TextPtr = NumberPtr;
        if (strnicmp(TextPtr,"PARSE",5) == 0)  { strcpy(USEstring, "PARSE\0"); i = 5; j = 1; }
        if (strnicmp(TextPtr,"COMMON",6) == 0) { i = 6; j = 2; }
        if (strnicmp(TextPtr,"EXTEND",6) == 0) { strcpy(USEstring, "PARSE\0"); i = 6; j = 3; }

		NumberPtr += i;
		sscanf(NumberPtr," %d ",&CurrentMessageNumber);

		TempNumber = CurrentMessageNumber;

		if ( (CurrentClass == '1') && (j != 3) )
		      { printf("Error: :USE in CLASS 1 must be EXTENDED ERROR on line %d\n",LineNumber);
			exit(1);
			}

		if ( (CurrentClass == '2') && (j != 1) )
		      { printf("Error: :USE in CLASS 1 must be PARSE ERROR on line %d\n",LineNumber);
			exit(1);
			}

		switch(j)
		      {
			case 1: if (TempNumber <= MAXPARSERERROR)
					TextPtr = ParserErrorTexts[TempNumber];
				   else if (TempNumber == 999)
						TextPtr = ParserErrorText999;
					   else TextPtr = "";
				break;
			case 2: if (TempNumber <= MAXCOMMONERROR)
					TextPtr = CommonErrorTexts[TempNumber];
				   else TextPtr = "";
				break;
			case 3: if (TempNumber <= MAXEXTENDEDERROR)
					TextPtr = ExtendedErrorTexts[TempNumber];
				   else if (TempNumber == 999)
						TextPtr = ExtendedErrorText999;
					   else TextPtr = "";
				break;

			default:TextPtr = "";
				break;
			}

		if (*TextPtr == NUL)
		      { printf("Error: :USE of PARSE, COMMON or EXTENDED with invalid msg-number, line %d\n",LineNumber);
			if (Debugging) printf("else ->CurrentMessageNumber = %d, TempNumber = %d, j = %d\n",
					      CurrentMessageNumber,TempNumber,j);
			exit(1);
			}

		}

	if (Pass == 1)
	      {
		BlankLine();

		i = sprintf(out,"$M_%c_%05XH_STRUC LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
	/*	i = sprintf(out,"        $M_ID   <%05XH,0,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",   */
		i = sprintf(out,"        $M_ID   <%05XH,$M_%c_%05XH_MSG-$M_%c_%05XH_STRUC>\x0d\x0a",    /* Mar 88, SWN */
				CurrentMessageNumber,CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		}

	if (Pass == 2)
	  {
	  strcpy( Is_Utility_Command, NAME_COMMAND ) ;
	  if ( !ParseOrExtend )
	    {
	    add_crlf = 0 ;
	    }
	  else
	    {
        if ( !strnicmp( Is_Utility_Command, UtilityName, 5) )
	      {
	      if ( ( CurrentClass != 67 ) && ( CurrentClass != 68 ) &&
		   ( CurrentClass != 69 ) && ( CurrentClass != '1') &&
		   ( CurrentClass != '2') )
		{
		add_crlf = 1 ;
		}
	      else
		{
		add_crlf = 0 ;
		}

	      }
	    else
	      {
	      if ( ( CurrentClass != '1') && ( CurrentClass != '2') )
		{
		add_crlf = 1 ;
		}
	      else
		{
		add_crlf = 0 ;
		}

	      }
	    }

	  BlankLine();

	  i = sprintf(out,"$M_%c_%05XH_MSG LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
	  DosWrite(ClassHandle,(char far *) &out[0], i);
  /*	  i = sprintf(out,"        DW      $M_%c_%05XH_END-$M_%c_%05XH_MSG-2\x0d\x0a",     */
	  i = sprintf(out,"        DB      $M_%c_%05XH_END-$M_%c_%05XH_MSG-1\x0d\x0a",    /* Mar 88, SWN */
			  CurrentClass,CurrentMessageNumber,CurrentClass,CurrentMessageNumber);
	  DosWrite(ClassHandle,(char far *) &out[0], i);
	  if ( add_crlf )
	    {
	    i = sprintf(out,"        DB      %s,CR,LF\x0d\x0a",TextPtr);
	    }
	  else
	    {
	    i = sprintf(out,"        DB      %s\x0d\x0a",TextPtr);
	    }
	  DosWrite(ClassHandle,(char far *) &out[0], i);

	  MessagePending = TRUE;
	  }

	return;
	}

/* -------------------------------------------------------------------------- */

void DefContinue(Record)
char	*Record;
{

	printf("Error: :DEF continue should not occur",LineNumber);
	exit(1);

	return;

}

/* -------------------------------------------------------------------------- */

void UseContinue(Record)
char	*Record;
{

	printf("Error: :USE continue should not occur",LineNumber);
	exit(1);

	}

/* -------------------------------------------------------------------------- */

void EndRecord(Record)
char	*Record;
{

	if (!ClassFlag1) ClassRecord(" 1 ");
	if (!ClassFlag2) ClassRecord(" 2 ");

	MessageTerminate();
	ClassTerminate();

	Done = TRUE;

	return;
	}

/* -------------------------------------------------------------------------- */

void MessageTerminate()
{

	char	out[128];

	if (MessagePending)
	      {
		sprintf(out,"$M_%c_%05XH_END LABEL BYTE\x0d\x0a",CurrentClass,CurrentMessageNumber);
		DosWrite(ClassHandle,(char far *) &out[0],strlen(out) );
	 /*	sprintf(out,"        DB        \"$\"\x0d\x0a");      */
		sprintf(out,"  \0",CurrentClass,CurrentMessageNumber);  /* Mar 88, SWN */
		DosWrite(ClassHandle,(char far *) &out[0],strlen(out) );

		ClassCounts[CurrentClass]++;
		}

	MessagePending = FALSE;

	return;
	}

/* -------------------------------------------------------------------------- */

void ClassTerminate()
{

	int	i;
	char	out[128];

	if ( (ClassPending) && (Pass == 1) )
	      { CommentLine();

		if (CurrentClass == '1')
		      { i = sprintf(out,"$M_1_FF_STRUC LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        $M_ID <0FFFFH,0,$M_1_FF_MSG-$M_1_FF_STRUC>\x0d\x0a");  */
			i = sprintf(out,"        $M_ID <0FFFFH,$M_1_FF_MSG-$M_1_FF_STRUC>\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
			ClassCounts[CurrentClass] ++;
			CommentLine();
			}

		if (CurrentClass == '2')
		      { i = sprintf(out,"$M_2_FF_STRUC LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        $M_ID <0FFFFH,0,$M_2_FF_MSG-$M_2_FF_STRUC>\x0d\x0a");  */
			i = sprintf(out,"        $M_ID <0FFFFH,$M_2_FF_MSG-$M_2_FF_STRUC>\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
			ClassCounts[CurrentClass] ++;
			CommentLine();
			}


		DosClose(ClassHandle);
		ClassHandle = 0xfffe;	 /* 0xfffe  ==	-2  */
		}

	if ( (ClassPending) && (Pass == 2) )
	      { CommentLine();

		if (CurrentClass == '1')
		      { i = sprintf(out,"$M_1_FF_MSG LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DW      $M_1_FF_END-$M_1_FF_MSG-2\x0d\x0a");   */
			i = sprintf(out,"        DB      $M_1_FF_END-$M_1_FF_MSG-1\x0d\x0a");   /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out, EXTENDED_STR);	 /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"$M_1_FF_END LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DB      \"$\"\x0d\x0a");       */
			i = sprintf(out,"  \0");        /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			CommentLine();
			}

		if (CurrentClass == '2')
		      { i = sprintf(out,"$M_2_FF_MSG LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DW      $M_2_FF_END-$M_2_FF_MSG-2\x0d\x0a");   */
			i = sprintf(out,"        DB      $M_2_FF_END-$M_2_FF_MSG-1\x0d\x0a");   /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,PARSE_STR); /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			i = sprintf(out,"$M_2_FF_END LABEL BYTE\x0d\x0a");
			DosWrite(ClassHandle,(char far *) &out[0], i);
		/*	i = sprintf(out,"        DB      \"$\"\x0d\x0a");       */
			i = sprintf(out,"  \0");        /* Mar 88, SWN */
			DosWrite(ClassHandle,(char far *) &out[0], i);
			CommentLine();
			}

		i = sprintf(out,"Class_%c_MessageCount EQU     %d\x0d\x0a",CurrentClass,ClassCounts[CurrentClass]);
		DosWrite(ClassHandle,(char far *) &out[0], i );

		CommentLine();

		i = sprintf(out,"        IF      FARmsg\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d PROC FAR\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c PROC FAR\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		i = sprintf(out,"        ELSE\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d PROC NEAR\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c PROC NEAR\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		i = sprintf(out,"        ENDIF\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		BlankLine();
		i = sprintf(out,"        PUSH    CS\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        POP     ES\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        LEA     DI,$M_CLASS_%c_STRUC\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        ADD     CX,$-$M_CLASS_%c_STRUC\x0d\x0a",CurrentClass);
		DosWrite(ClassHandle,(char far *) &out[0], i);
		i = sprintf(out,"        RET\x0d\x0a");
		DosWrite(ClassHandle,(char far *) &out[0], i);
		BlankLine();
		if ( !IsReserved(CurrentClass) )
		      { i = sprintf(out,"$M_CLS_%d ENDP\x0d\x0a",CurrentClassIndex);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}
		 else { i = sprintf(out,"$M_MSGSERV_%c Endp\x0d\x0a",CurrentClass);
			DosWrite(ClassHandle,(char far *) &out[0], i);
			}

		CommentLine();

		DosClose(ClassHandle);
		ClassHandle = 0xfffe;	   /* 0xfffe == -2   */

		printf(" Completed [%s]\n",CurrentClassFileName);

		}

	ClassPending = FALSE;

	return;
	}

/* -------------------------------------------------------------------------- */

unsigned LowOf(LongValue)
long LongValue;
{

	return ( (unsigned) ( LongValue & 0x0000FFFFl ) );

	}

/* -------------------------------------------------------------------------- */

unsigned HighOf(LongValue)
long LongValue;
{

	return ( (unsigned) ( (LongValue & 0xFFFF0000l) >> 16 ) );

	}

/* -------------------------------------------------------------------------- */

long	 LongOf(HighValue,LowValue)
unsigned HighValue;
unsigned LowValue;
{

	long	hv;
	long	lv;

	hv = (long) HighValue;
	lv = (long) LowValue;

	return ( ( hv << 16 ) + lv );

	}

/* -------------------------------------------------------------------------- */

unsigned DosOpen(FileNamePtr,OpenType)
char far *FileNamePtr;
unsigned OpenType;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3d00 + OpenType;
	InRegs.x.dx = FP_OFF(FileNamePtr);
	SegRegs.ds = FP_SEG(FileNamePtr);
	intdosx(&InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	EofFlags[OutRegs.x.ax] = FALSE;
	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

long	 DosLSeek(Handle, ToPosition, Relative)
unsigned Handle;
long	 ToPosition;
int	 Relative;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x4200 + (Relative & 0x000f);
	InRegs.x.bx = Handle;
	InRegs.x.cx = HighOf(ToPosition);
	InRegs.x.dx = LowOf(ToPosition);
	intdosx(&InRegs, &OutRegs, &SegRegs);

	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	return( LongOf(OutRegs.x.dx,OutRegs.x.ax) );

	}

/* -------------------------------------------------------------------------- */

unsigned DosCreate(FileNamePtr,Attributes)
char far *FileNamePtr;
unsigned Attributes;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3c00;
	InRegs.x.cx = Attributes;
	InRegs.x.dx = FP_OFF(FileNamePtr);
	SegRegs.ds = FP_SEG(FileNamePtr);
	intdosx(&InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag)
		error(&InRegs,&OutRegs,&SegRegs);

	EofFlags[OutRegs.x.ax] = FALSE;
	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

void	 DosClose(Handle)
unsigned Handle;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3e00;
	InRegs.x.bx = Handle;
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag) error(&InRegs,&OutRegs,&SegRegs);

	return;

	}

/* -------------------------------------------------------------------------- */

unsigned DosRead(Handle,BufferPtr,ReadLength)
unsigned Handle;
char far *BufferPtr;
int	 ReadLength;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	InRegs.x.ax = 0x3f00;
	InRegs.x.bx = Handle;
	InRegs.x.cx = ReadLength;
	InRegs.x.dx = FP_OFF(BufferPtr);
	SegRegs.ds = FP_SEG(BufferPtr);
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag) error(&InRegs,&OutRegs,&SegRegs);

	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

unsigned DosWrite(Handle,BufferPtr,WriteLength)
unsigned Handle;
char far *BufferPtr;
int	 WriteLength;
{

	union	REGS	InRegs;
	union	REGS	OutRegs;
	struct	SREGS	SegRegs;

	union	REGS	InRegs2;
	union	REGS	OutRegs2;
	struct	SREGS	SegRegs2;

	InRegs.x.ax = 0x4000;
	InRegs.x.bx = Handle;
	InRegs.x.cx = WriteLength;
	InRegs.x.dx = FP_OFF(BufferPtr);
	SegRegs.ds = FP_SEG(BufferPtr);
	intdosx(&InRegs,&OutRegs,&SegRegs);
	if (OutRegs.x.cflag)
	      { InRegs2.x.ax = 0x4000;
		InRegs2.x.bx = 1;
		InRegs2.x.cx = WriteLength;
		InRegs2.x.dx = FP_OFF(BufferPtr);
		SegRegs2.ds = FP_SEG(BufferPtr);
	  /*	intdosx(&InRegs2,&OutRegs2,&SegRegs2);	*/
		error(&InRegs,&OutRegs,&SegRegs);
		}

	return(OutRegs.x.ax);

	}

/* -------------------------------------------------------------------------- */

void	 LineInput(Handle,BufferPtr)
unsigned Handle;
char far *BufferPtr;
{
	char		c;
	char far	*BufferPosition;

	BufferPosition = BufferPtr;
	*BufferPosition = NUL;

	if (DosRead( Handle, (char far *) &c, 1) != 1)
		EofFlags[Handle] = TRUE;

	while ( (c != (char) '\x0a') && !EofFlags[Handle])
	      {
		*BufferPosition = c;
		if (c == (char) '\x0d') *BufferPosition = NUL;
		BufferPosition++;

		if (DosRead( Handle, (char far *) &c, 1) != 1)
			EofFlags[Handle] = TRUE;

		}

	*BufferPosition = NUL;

	return;
}

/*----------------------------------------------------------------------------*/

void	error(InRegs,OutRegs,SegRegs)
union	REGS	*InRegs;
union	REGS	*OutRegs;
struct	SREGS	*SegRegs;
{

	char	far	*s;
	char		*t;
	char	AsciizString[256];

	struct	DOSERROR ErrorInformation;

	dosexterr(&ErrorInformation);

	printf("\n Function %02X, Error %d, Class %d, Action %d, Locus %d \n",
		InRegs->h.ah,
		ErrorInformation.exterror,ErrorInformation.class,
		ErrorInformation.action,ErrorInformation.locus);

	printf("  InRegs:\n");
	printf("  AX:%04X BX:%04X CX:%04X DX:%04X SI:%04X DI:%04X DS:%04X ES:%04X\n",
		InRegs->x.ax,InRegs->x.bx,InRegs->x.cx,InRegs->x.dx,InRegs->x.si,InRegs->x.di,
		SegRegs->ds,SegRegs->es);

	switch(InRegs->h.ah)
	      {
		case 0x3d:
		case 0x3c:
		case 0x4e:
			FP_SEG(s) = SegRegs->ds;
			FP_OFF(s) = InRegs->x.dx;
			t = &AsciizString[0];
			while (*s != (char) '\0') *t++ = *s++;
			*t++ = (char) '\0';
			printf("  DS:DX -> [%s]\n",AsciizString);
			break;
		}

	printf("  OutRegs:\n");
	printf("  AX:%04X BX:%04X CX:%04X DX:%04X SI:%04X DI:%04X DS:%04X ES:%04X\n",
		OutRegs->x.ax,OutRegs->x.bx,OutRegs->x.cx,OutRegs->x.dx,OutRegs->x.si,OutRegs->x.di,
		SegRegs->ds,SegRegs->es);



	exit(1);

	}


/* -------------------------------------------------------------------------- */

char * MyMalloc(Length)
int	Length;
{
	char	*Ptr;

	Ptr = malloc(Length);

	if (Ptr == (char *) 0)
	      { printf("ERROR: insufficient memory available, line %d\n",LineNumber);
		exit(1);
		}

	return (Ptr);
	}


/* -------------------------------------------------------------------------- */

	unsigned	IdxHandle;
	unsigned	MsgHandle;

void ReadCommon()
{


	char	    IdxComponentName[16];
	long	    MsgOffset;
	int	    MsgCount;

	char		Line[MAXLENGTH];
	char		NextLine[MAXLENGTH];
	char		CurrentIdxRecord[256];
	char		CurrentMsgRecord[256];
	int		CurrentIdxLevel;
	int		CurrentMsgLevel;
	char		RcdIDXType[32];
	struct		Idx_Structure  *IdxPtr;
	int		i;
	int		NumberOfMsg;
	int		k;
	long		n;
	int		ComponentNameLen = 20;
	char		*s, *p;
	unsigned	len;
	char		ContinueMessageInfo[32];
	int		ContinueMessageInfoLen;

	/* initialize the things that need to be... */

	printf(" Loading messages from %s\n",CountryMsg);

	k = 32000;
	s = malloc(k);
	while ( (s == (char *) 0) && (k > 1) )
	      {
		k -= 1000;
		s = malloc(k);
		}
	if (s != (char *) 0) free(s);
	printf(" (Available message memory space: %d bytes)\n",k);

	IdxHandle = DosOpen( (char far *) CountryIdx, READONLY);
	MsgHandle = DosOpen( (char far *) CountryMsg, READONLY);

	LineInput(IdxHandle, (char far *) &CurrentIdxRecord[0] );
	LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );

	sscanf(CurrentIdxRecord," %d ",&CurrentIdxLevel);
	sscanf(CurrentIdxRecord," %d ",&CurrentMsgLevel);
	if ( CurrentIdxLevel != CurrentMsgLevel )
	      {
		printf("\nERROR: %s and %s levels do not match\n",CountryIdx,CountryMsg);
		exit(1);
		}

	/* find out the offset into the big message file for COMMON error */
	/*						     EXTENDED	  */
	/*						     PARSER	  */
	/*						     Utility	  */

	while ( !EofFlags[IdxHandle] )
	      {
		LineInput(IdxHandle, (char far *) &CurrentIdxRecord[0] );

		sscanf(CurrentIdxRecord, " %s %lx %d ",
			IdxComponentName, &MsgOffset, &MsgCount);
		if (Debugging) printf("---> [%s] %04lX %04d<---\n",IdxComponentName, MsgOffset, MsgCount);

        strupr(IdxComponentName);

		if (strcmp(IdxComponentName,"COMMON")  == 0)
		      {
			if ( !ReadCommonFlag )
			      {
				ReadCommonFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s COMMON headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				CommonMessageLines = 1;
				ExtendedMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;      /* skip msg number */
					p = strchr(p, ' ') + 1;         /* skip status flag */
					p = strchr(p, ' ') + 1;         /* skip revision level */
					len = strlen(p);
					CommonErrorTexts[CommonMessageLines] = MyMalloc(len+1);
					strcpy(CommonErrorTexts[CommonMessageLines], p);
					if (Debugging) printf("CommonErrorTexts[%d] = (%s)\n",
							       CommonMessageLines,CommonErrorTexts[CommonMessageLines]);
					CommonMessageLines++;
					if (CommonMessageLines >= MAXCOMMONERROR)
					      {
						printf("\nERROR: COMMON message number too large, %d\n",CommonMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,"EXTEND")  == 0)
		      {
			if ( !ReadExtendFlag )
			      {
				ReadExtendFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s EXTEND headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				ExtendedMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;      /* skip msg number */
					p = strchr(p, ' ') + 1;         /* skip status flag */
					p = strchr(p, ' ') + 1;         /* skip revision level */
					len = strlen(p);
					ExtendedErrorTexts[ExtendedMessageLines] = MyMalloc(len+1);
					strcpy(ExtendedErrorTexts[ExtendedMessageLines], p);
					if (Debugging) printf("ExtendedErrorTexts[%d] = (%s)\n",
							      ExtendedMessageLines,ExtendedErrorTexts[ExtendedMessageLines]);
					ExtendedMessageLines++;
					if (ExtendedMessageLines >= MAXEXTENDEDERROR)
					      {
						printf("\nERROR: EXTENDED message number too large, %d\n",ExtendedMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,"PARSE")  == 0)
		      {
			if ( !ReadParserFlag )
			      {
				ReadParserFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s PARSE headers do not match\n",CountryIdx,CountryMsg);
					exit(1);
					}
				ParserMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					p = strchr(Line, ' ') + 1;
					p = strchr(p, ' ') + 1;
					p = strchr(p, ' ') + 1;
					len = strlen(p);
					ParserErrorTexts[ParserMessageLines] = MyMalloc(len+1);
					strcpy(ParserErrorTexts[ParserMessageLines], p);
					if (Debugging) printf("ParserErrorTexts[%d] = (%s)\n",
							       ParserMessageLines,ParserErrorTexts[ParserMessageLines]);
					ParserMessageLines++;
					if (ParserMessageLines >= MAXPARSERERROR)
					      {
						printf("\nERROR: PARSER message number too large, %d\n",ParserMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		else if (strcmp(IdxComponentName,UtilityName)  == 0)
		      {
			if ( !ReadUtilFlag )
			      {
				ReadUtilFlag = TRUE;
				DosLSeek( MsgHandle, MsgOffset, 0);
				LineInput(MsgHandle, (char far *) &CurrentMsgRecord[0] );
				if (strcmp(CurrentIdxRecord, CurrentMsgRecord) != 0)
				      {
					printf("\nERROR: %s and %s %s headers do not match\n",
						CountryIdx,CountryMsg,UtilityName);
					exit(1);
					}
				UtilMessageLines = 1;
				LineInput(MsgHandle, (char far *) &Line[0] );
				while ( ( !isalpha(Line[0]) ) && (!EofFlags[MsgHandle]) )
				      {
					if ( !isdigit(Line[0]) )
					      {
						MsgCount++;
						/* need to fake  MsgNumber, Status, Level fields*/
						len =  strlen(Line) + strlen(ContinueMessageInfo);
						UtilErrorTexts[UtilMessageLines] = MyMalloc(len+1);
						strcpy(UtilErrorTexts[UtilMessageLines], ContinueMessageInfo);
						strcat(UtilErrorTexts[UtilMessageLines], Line);
						if (Debugging) printf("UtilErrorTexts[%d] = (%s)\n",
								       UtilMessageLines,UtilErrorTexts[UtilMessageLines]);
						}
					 else
					      {
						len = strlen(Line);
						UtilErrorTexts[UtilMessageLines] = MyMalloc(len+1);
						strcpy(UtilErrorTexts[UtilMessageLines], Line);
						if (Debugging) printf("UtilErrorTexts[%d] = (%s)\n",
								       UtilMessageLines,UtilErrorTexts[UtilMessageLines]);
						strncpy(ContinueMessageInfo,Line,12);
						ContinueMessageInfo[12] = (char) '\0';
						if (Debugging) printf(" ContinueMessageInfo = (%s)\n",
								       ContinueMessageInfo);
						}
					UtilMessageLines++;
					if (UtilMessageLines >= MAXUTILERROR)
					      {
						printf("\nERROR: Utility message number too large, %d\n",UtilMessageLines);
						exit(1);
						}
					LineInput(MsgHandle, (char far *) &Line[0] );
					}
				}
			}

		}

	DosClose(IdxHandle);
	DosClose(MsgHandle);

	UtilMessageLines--;
	CommonMessageLines--;
	ParserMessageLines--;
	ExtendedMessageLines--;

	k = 32000;
	s = malloc(k);
	while ( (s == (char *) 0) && (k > 1) )
	      {
		k -= 1000;
		s = malloc(k);
		}
	if (s != (char *) 0) free(s);
	printf(" (Still available message memory space: %d bytes)\n",k);

	if (!ReadCommonFlag)
	      { printf("\nERROR: COMMON messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadExtendFlag)
	      { printf("\nERROR: EXTEND messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadParserFlag)
	      { printf("\nERROR: PARSE messages not found in %s\n",CountryIdx);
		exit(1);
		}

	if (!ReadUtilFlag)
	      { printf("\nERROR: %s messages not found in %s\n",UtilityName,CountryIdx);
		exit(1);
		}

	return;

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\comsw.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comsw.asm	1.1 85/05/14
;	SCCSID = @(#)comsw.asm	1.1 85/05/14

include version.inc


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\command2.asm ===
page ,132
	title	COMMAND2 - resident code for COMMAND.COM part II
	name	COMMAND2
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
;			reserve memory by changing int 12h and then give it
;			back to DOS by changing arenas in autoexec.bat.
;			This makes command.com reload transient and this
;			cannot be done at this stage.
;
;



.xcref
.xlist
	include dossym.inc
	include pdb.inc
	include syscall.inc
	include comsw.asm
	include comequ.asm
	include resmsg.equ

	include comseg.asm
.list
.cref


DATARES 	segment public byte
		extrn	Append_State:word
		extrn	Append_Flag:byte
		extrn	BMemMes:byte
		extrn	ComBad:byte
		extrn	ComDrv:byte
		extrn	ComSpec:byte
		extrn	EnvirSeg:word
		extrn	ExtCom:byte
		extrn	FRetMes:byte
		extrn	HaltMes:byte
		extrn	Handle01:word
		extrn	InitFlag:BYTE
		extrn	Int_2e_Ret:dword
		extrn	Io_Save:word
		extrn	Io_Stderr:byte
		extrn	Loading:byte
		extrn	LTpa:word
		extrn	MemSiz:word
		extrn	NoHandMes:byte
		extrn	OldTerm:dword
		extrn	Parent:word
		extrn	PermCom:byte
		extrn	Prompt:byte
		extrn	PutBackDrv:byte
		extrn	PutBackMsg:byte
		extrn	PutBackSubst:byte
		extrn	Res_Tpa:word
		extrn	RetCode:word
		extrn	Save_Pdb:word
		extrn	SingleCom:word
		extrn	Sum:word
		extrn	Trans:dword
		extrn	TranVarEnd:byte
		extrn	TranVars:byte
		extrn	TrnSeg:word
		extrn	VerVal:word

		extrn	ResSize:word
		extrn	OldDS:word
		extrn	RStack:word

		extrn	Ctrlc_Trap:near
		extrn	CritErr_Trap:near
		extrn	LodCom_Trap:near

DATARES 	ends

;;ENVARENA 	segment public para
;;ENVARENA 	ends

;;ENVIRONMENT 	segment public para      ; default COMMAND environment
;;ENVIRONMENT 	ends

INIT		segment public para
		extrn	EnvSiz:word
		extrn	OldEnv:word
		extrn	ResetEnv:byte
		extrn	UsedEnv:word

		extrn	Chuckenv:byte


INIT		ends


TRANDATA	segment public byte
		extrn	trandataend:byte
TRANDATA	ends

TRANSPACE	segment public byte
		extrn	transpaceend:byte
		extrn	headcall:dword
TRANSPACE	ends




CODERES segment public byte

	public	BadMemErr

	public	ChkSum
;;	public	EndInit
	public	GetComDsk2
	public	Int_2e
	public	LoadCom
	public	LodCom
	public	LodCom1
	public	RestHand
	public	SavHand
	public	SetVect
	public	THeadFix
	public	TRemCheck
	public	TJmp

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	extrn	ContC:near
	extrn	DskErr:near

	extrn	Alloc_error:near

;*	If we cannot allocate enough memory for the transient or there
;	was some other allocation error, we display a message and
;	then die.

;SR;
; We will have to make sure that at this entry point and at FatalC, 
;ds = DATARES. All jumps to these points are made from only within this file
;and so we should be able to do this

	assume	ds:DATARES
BadMemErr:
	mov	dx,offset DATARES:BMemMes	; DX = ptr to msg
FatalC:

;;	push	cs
;;	pop	ds
;;	assume	ds:ResGroup
	invoke	RPrint

;	If this is NOT a permanent (top-level) COMMAND, then we exit;
;	we can't do anything else!

	cmp	PermCom,0
	je	FatalRet

;	We are a permanent command.  If we are in the process of the
;	magic interrupt (Singlecom) then exit too.

	cmp	SingleCom,0			; if permcom and singlecom
	jne	FatalRet			; must take int_2e exit

;	Permanent command.  We can't do ANYthing except halt.

	mov	dx,offset DATARES:HaltMes	; DX = ptr to msg
	invoke	RPrint
	sti
Stall:
	jmp	Stall				; crash the system nicely

FatalRet:
	mov	dx,offset DATARES:FRetMes	; DX = ptr to msg
	invoke	RPrint
FatalRet2:
	cmp	PermCom,0			; if we get here and permcom,
	jne	Ret_2e				; must be int_2e

;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
;	were a non-permanent COMMAND that had hooked it!  (Just in 
;	case we decide to do that.)
	mov	ax,Parent
	mov	word ptr ds:Pdb_Parent_Pid,ax
	mov	ax,word ptr OldTerm
	mov	word ptr ds:Pdb_Exit,ax
	mov	ax,word ptr OldTerm+2
	mov	word ptr ds:Pdb_Exit+2,ax
	mov	ax,(EXIT shl 8) 		; return to lower level
	int	21h

Ret_2e:
;SR;
; We will ensure that ds = DATARES for all entries to this place
;

;;	push	cs
;;	pop	ds
;;	assume	ds:resgroup,es:nothing,ss:nothing
  	
	assume	ds:DATARES

	mov	SingleCom,0		; turn off singlecom
	mov	es,Res_Tpa
	mov	ah,DEALLOC
	int	21h			; free up space used by transient
	mov	bx,Save_Pdb
	mov	ah,SET_CURRENT_PDB
	int	21h			; current process is user
	mov	ax,RetCode
	cmp	ExtCom,0
	jne	GotECode
	xor	ax,ax			; internals always return 0
GotECode:
	mov	ExtCom,1		; force external

;SR; This is actually returning to the caller. However, the old code had
;ds = RESGROUP so I guess we can keep ds = DATARES for us.
;Yes, int 2eh can corrupt all registers so we are ok.
;
	jmp	Int_2e_Ret		;"iret"




;***	Int_2e, magic command executer

Int_2e:
	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
;SR;
; We are going to come here from the stub with the old ds and DATARES value
;pushed on the stack in that order. Pick up this stuff off the stack
;
	pop	ds			;ds = DATARES
	assume	ds:DATARES
	pop	ax
;	pop	ds:OldDS 		;Save old value of ds

	pop	word ptr Int_2e_Ret
	pop	word ptr [Int_2e_Ret+2] ; store return address
	;pop	ax			; chuck flags
	add	sp,2

;;	push	cs
;;	pop	es

	push	ds
	pop	es			;es = DATARES
;	mov	ds,OldDS
	mov	ds,ax
	assume	ds:nothing		;ds = old value

	mov	di,80h
	mov	cx,64
;	Bugbug:	cld
	rep	movsw
	mov	ah,GET_CURRENT_PDB
	int	21h			; get user's header
	mov	es:Save_Pdb,bx
	mov	ah,SET_CURRENT_PDB

;;	mov	bx,cs
;SR;
; Set ds = DATARES because BadMemErr expects this
;
	push	es
	pop	ds
	assume	ds:DATARES

	mov	bx,ds			;es = our PSP now

	int	21h			; current process is me
	mov	SingleCom,81h
	mov	ExtCom,1		; make sure this case forced

;SR;
; We can enter LodCom directly after a command shell is terminated or we
;can fall thru from above. When we enter directly from the stub, the stack
;has the old ds value and the data seg value on the stack, so that ds can
;be properly set. To fake this, we push dummy values here.
;
	push	ds			;old value of ds
	push	ds			;data seg value, ds = DATARES

LodCom: 					; termination handler
	pop	ds			;ds = DATARES 
	assume	ds:DATARES
	add	sp,2
;	pop	OldDS			;store old ds

	cmp	ExtCom,0
	jne	@f 		; internal cmd - memory allocated
	jmp	LodCom1
@@:
	mov	bx,0FFFFh
	mov	ah,ALLOC
	int	21h
	call	SetSize
	add	ax,20h
	cmp	bx,ax
	jnc	MemOk			; > 512 byte buffer - good enough
BadMemErrJ:
	jmp BadMemErr			; not enough memory




;***	SetSize - get transient size in paragraphs

SetSize	proc
	assume	ds:NOTHING,es:NOTHING
	mov	ax,offset TRANGROUP:TranSpaceEnd + 15
	mov	cl,4
	shr	ax,cl
	ret
SetSize	endp




MemOk:
	assume	ds:DATARES		;we have set ds = DATARES 

	mov	ah,ALLOC
	int	21h
	jc	BadMemErrJ		; memory arenas probably trashed
	mov	ExtCom,0		; flag not to alloc again
	mov	Res_Tpa,ax		; save current tpa segment
	and	ax, 0F000h
	add	ax, 01000h		; round up to next 64k boundary
	jc	Bad_Tpa 		; memory wrap if carry set

;	Make sure that new boundary is within allocated range

	mov	dx,Res_Tpa
	add	dx,bx			; compute maximum address
	cmp	dx,ax			; is 64k address out of range?
	jbe	Bad_Tpa

;	Must have 64K of usable space.

	sub	dx,ax			; compute the usable space
	cmp	dx,01000h		; is space >= 64k ?
	jae	LTpaSet
Bad_Tpa:
	mov	ax,Res_Tpa
LTpaSet:
	mov	LTpa,ax			; usable tpa is 64k buffer aligned
	mov	ax,Res_Tpa		; actual tpa is buffer allocated
	add	bx,ax
	mov	MemSiz,bx
	call	SetSize
	sub	bx,ax
;
;M038; Start of changes
; Changes for Novell RPL. These guys reserve memory for themselves by
;reducing int 12h size and add this memory to the system at autoexec time by
;running a program that changes arenas. This changes the largest block that
;command.com gets and so changes the transient segment. So, command.com does
;a checksum at the wrong address and thinks that the transient is destroyed
;and tries to reload it. At this point, no Comspec is defined and so the
;reload fails, hanging the system. To get around this we just copy the
;transient from the previous address to the new address(if changed) and
;then let command.com do the checksum. So, if the transient area is not
;corrupted, there will not be any reload. In Novell's case, the transient
;is not really corrupted and so this should work.
;
	cmp	bx,TrnSeg		;Segment still the same?
	je	LodCom1		;yes, dont copy
;
;Check if the new segment is above or below the current move. If the new
;segment is above(i.e new block is larger than previous block), then we
;have to move in the reverse direction
;
	mov	cx,offset TRANGROUP:TranSpaceEnd ;cx = length to move
	ja	mov_down		;new seg > old seg, reverse move
	xor	si,si			;normal move
	mov	di,si
	cld
	jmp	short copy_trans
mov_down:
	mov	si,cx			;reverse move, start from end
	dec	si
	mov	di,si
	std
copy_trans:
	push	ds
	push	es
	mov	es,bx			;dest segment
	mov	ds,TrnSeg		;source segment
	assume	ds:nothing

	rep	movsb			;copy transient
	cld
	pop	es
	pop	ds
	assume	ds:DATARES
;
;M038; End of changes
;

	mov	TrnSeg,bx		;new location of transient
LodCom1:
;;	mov	ax,cs
;;	mov	ss,ax
;SR; At this point ds = DATARES which is where the stack is located
;
	mov	ax,ds
	mov	ss,ax
	assume	ss:DATARES
	mov	sp,offset DATARES:RStack

;;	mov	ds,ax

	assume	ds:DATARES
	call	HeadFix 		; close files, restore stdin, stdout
	xor	bp,bp			; flag command ok
	mov	ax,-1
	xchg	ax,VerVal
	cmp	ax,-1
	je	NoSetVer
	mov	ah,SET_VERIFY_ON_WRITE	; AL has correct value
	int	21h
NoSetVer:
	cmp	SingleCom,-1
	jne	NoSng
	jmp	FatalRet2		; we have finished the single command
NoSng:
	call	ChkSum			; check the transient
	cmp	dx,Sum
	je	HavCom			; transient ok
Bogus_Com:
	mov	Loading,1		; flag DskErr routine
	call	LoadCom
ChkSame:

	call	ChkSum
	cmp	dx,Sum
	jz	HavCom			; same command
Also_Bogus:
	call	WrongCom
	jmp	short ChkSame
HavCom:
	mov	Loading,0		; flag to DskErr
	mov	si,offset DATARES:TranVars
	mov	di,offset TRANGROUP:HeadCall
	mov	es,TrnSeg
	cld
	mov	cx,offset DATARES:TranVarEnd
	sub	cx,si
	rep	movsb			; transfer info to transient
	mov	ax,MemSiz
	mov	word ptr ds:Pdb_Block_Len,ax	; adjust my own header

;***	TJmp - jump-off to transient
;
;	Public label so debugger can find this spot.

TJmp:
	jmp	Trans




;***	TRemCheck - far version of RemCheck for transient

TRemCheck	proc	far

	pop	ds			;ds = DATARES
	add	sp,2			;discard old value of ds

	call	RemCheck
	ret

TRemCheck endp




;***	RemCheck
;
;	ENTRY	AL = drive (0=default, 1=A, ...)
;
;	EXIT	ZR set if removeable media
;		ZR clear if fixed media
;
;	USED	none

RemCheck:
	savereg	<ax,bx>
	mov	bx,ax
	mov	ax,(IOCTL shl 8) + 8
	int	21h
	jnc	rcCont			

;	If an error occurred, assume the media is non-removable.
;	AX contains the non-zero error code from the int 21, so
;	'or ax,ax; sets non-zero. This behavior makes network drives
;	appear to be non-removable.				
					
	or	ax,ax			
	jmp	short ResRegs
rcCont:
	and	ax,1
	not	ax
ResRegs:
	restorereg  <bx,ax>
	ret




;***	THeadFix
;
;	Far version of HeadFix, called from transient.

THeadFix	proc	far
	pop	ds			;ds = DATARES
	add	sp,2			;discard old ds value on stack

	call	HeadFix
	ret

THeadFix	endp




;***	HeadFix

HeadFix:
	call	SetVect			; set vectors to our values

;	Clean up header

;	Bugbug:	optimize:
;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes

	xor	bx,bx				; BX = handle = 0
	mov	cx,Io_Save			; CX = original stdin, stdout
	mov	dx,word ptr ds:Pdb_Jfn_Table	; DX = current stdin, stdout
	cmp	cl,dl
	je	Chk1			; stdin matches
	mov	ah,CLOSE
	int	21h			; close stdin
	mov	ds:Pdb_Jfn_Table,cl	; restore stdin
Chk1:
	inc	bx			; BX = handle = 1
	cmp	ch,dh			
	je	ChkStderr		; stdout matches
	mov	ah,CLOSE
	int	21h			; close stdout
	mov	ds:Pdb_Jfn_Table+1,ch	; restore stdout

ChkStderr:
	inc	bx			; BX = handle = 2
	mov	dl,byte ptr ds:[Pdb_Jfn_Table+2]	; Dl = current stderr
	mov	cl,Io_Stderr		; Cl = original stderr
	cmp	dl,cl
	je	ChkOtherHand		; stderr matches
	mov	ah,CLOSE
	int	21h			; close stderr
	mov	ds:Pdb_Jfn_Table+2,cl	; restore stderr

ChkOtherHand:
	add	bx,3			; skip handles 3,4
ifdef NEC_98
	add	bx,4   			 ; skip handles 2,3,4
endif   ;NEC_98
	mov	cx,FILPERPROC - 5	; CX = # handles to close
					;   (handles 0-4 already done)
;; williamh: March 30, 1993, don't close invalid handle , save some time
	push	si
	mov	si, pdb_jfn_table	;go to the handle table
CloseLoop:
	cmp	byte ptr [bx][si], 0ffh
	je	Skip_this_handle
	mov	ah,CLOSE
	int	21h			; close each handle
Skip_this_handle:
	inc	bx
	loop	CloseLoop
	pop	si
;	Bugbug:	since this is for transient code, move it there

;	M012: remove this CS -> DS.  Must've been missed during
;	purification.
;;	push	ds			; save data segment
;;	push	cs			; get local segment into DS
;;	pop	ds			;
	cmp	Append_Flag,-1		; do we need to reset APPEND?
	jne	Append_Fix_End		; no - just exit
	mov	ax,AppendSetState	; set the state of Append
	mov	bx,Append_State 	;     back to the original state
	int	2Fh			;
	mov	Append_Flag,0		; set append flag to invalid
Append_Fix_End: 			;
;;	pop	ds			; get data segment back
	ret




;***	SavHand - save current program's stdin/out & set to our stderr
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Handle01 = current program's stdin,stdout JFN entries
;	  current program's stdin,stdout set to our stderr
;

;SR;
; Changed ds = DATARES. We need it to access our JFN_Table
; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
;
SavHand	proc

	assume	ds:DATARES,es:NOTHING,ss:NOTHING

	push	bx			;preserve registers
	push	ax
	push	es
	push	ds			; save DATARES value

	mov	ah,GET_CURRENT_PDB
	int	21h			; BX = user's header seg addr
	mov	ds,bx			; DS = user's header seg addr
	lds	bx,ds:PDB_JFN_POINTER	; DS:BX = ptr to JFN table
	mov	ax,word ptr ds:[bx]	; AX = stdin,stdout JFN's

	pop	es			;es = DATARES
	push	es			;save it back on stack
	mov	es:Handle01,ax		; save user's stdin, stdout

;SR;
; Use es to address Handle01 & our JFN_Table
;

	mov	al,es:[PDB_JFN_TABLE+2] ; AL = COMMAND stderr
	mov	ah,al			; AH = COMMAND stderr
	mov	word ptr ds:[bx],ax	; set user's stdin/out to our stderr

	pop	ds			; restore registers
	pop	es
	pop	ax
	pop	bx
	ret

SavHand	endp




	assume	ds:DATARES

GetComDsk2:
	call	GetComDsk
	jmp	LodCom1 		; memory already allocated

RestHand:
	push	ds
	push	bx			; restore stdin, stdout to user
	push	ax
	mov	ah,GET_CURRENT_PDB
	int	21h			; point to user's header
	mov	ax,Handle01
	mov	ds,bx
	assume ds:NOTHING
	lds	bx,ds:Pdb_Jfn_Pointer	; DS:BX = ptr to jfn table
	mov	word ptr ds:[bx],ax	; stuff his old 0 and 1
	pop	ax
	pop	bx
	pop	ds
	ret




	assume ds:DATARES,ss:DATARES

Hopeless:
	mov	dx,offset DATARES:ComBad
	jmp	FatalC

GetComDsk:
	mov	al,ComDrv
	call	RemCheck
	jnz	Hopeless			; non-removable media
GetComDsk3:
	cmp	dx,offset DATARES:ComBad
	jnz	GetComDsk4
	mov	dx,offset DATARES:ComBad	; DX = ptr to msg
	invoke	RPrint				; say COMMAND is invalid
GetComDsk4:
;	Bugbug:	there's always a drive here?  No need to check?
	cmp	PutBackDrv,0		; is there a drive in the comspec?
	jnz	Users_Drive		; yes - use it
	mov	ah,GET_DEFAULT_DRIVE	; use default drive
	int	21h
	add	al,"A"                  ; convert to ascii
	mov	PutBackDrv,al		; put in message to print out

Users_Drive:
	mov	dx,offset DATARES:PutBackMsg		; prompt for diskette
	mov	si,offset DATARES:PutBackSubst		;  containing COMMAND
	invoke	RPrint
	mov	dx,offset DATARES:Prompt		; "Press any key"
	invoke	RPrint
	call	GetRawFlushedByte
	ret




;***	GetRawFlushedByte - flush world and get raw input

GetRawFlushedByte:
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) or RAW_CON_INPUT
	int	21h			; get char without testing or echo
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + 0
	int	21h
;	Bugbug:	get rid of this return and the following retz.
	return




;***	LoadCom - load in transient

LoadCom:
	inc	bp				; flag command read
	mov	dx,offset DATARES:ComSpec
	mov	ax,OPEN shl 8
	int	21h				; open command.com
	jnc	ReadCom
	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
	jnz	TryDoOpen
	mov	dx,offset DATARES:NoHandMes
	jmp	FatalC				; will never find a handle

TryDoOpen:
	call	GetComDsk
	jmp	LoadCom

ReadCom:
	mov	bx,ax				; BX = handle
	mov	dx,offset RESGROUP:TranStart
	xor	cx,cx				; CX:DX = seek loc
	mov	ax,LSEEK shl 8
	int	21h
	jc	WrongCom1
	mov	cx,offset TRANGROUP:TranSpaceEnd - 100h

	push	ds
	mov	ds,TrnSeg
	assume	ds:NOTHING
	mov	dx,100h
	mov	ah,READ
	int	21h
	pop	ds
	assume	ds:DATARES
WrongCom1:
	pushf
	push	ax
	mov	ah,CLOSE
	int	21h			; close command.com
	pop	ax
	popf
	jc	WrongCom		; error on read
	cmp	ax,cx
	retz				; size matched
WrongCom:
	mov	dx,offset DATARES:ComBad
	call	GetComDsk
	jmp	LoadCom 		; try again



;***	ChkSum - compute transient checksum

ChkSum:
	push	ds
	mov	ds,TrnSeg
	mov	si,100h
	mov	cx,offset TRANGROUP:TranDataEnd - 100H

Check_Sum:
	cld
	shr	cx,1
	xor	dx,dx
Chk:
	lodsw
	add	dx,ax
	adc	dx,0
	loop	Chk
	pop	ds
	ret




;***	SetVect - set interrupt vectors

SetVect:
	mov	dx,offset DATARES:LodCom_Trap
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 22h
	mov	word ptr ds:Pdb_Exit,dx
	mov	word ptr ds:Pdb_Exit+2,ds
	int	21h
	mov	dx,offset DATARES:Ctrlc_Trap
	inc	al
	int	21h
	mov	dx,offset DATARES:CritErr_Trap
	inc	al
	int	21h
	ret

;SR;
; We have this to take care of the extra values pushed on the stack by 
;the stub before jumping to LodCom1. We set up ds here and then jump to
;Lodcom1
;
public	TrnLodCom1
TrnLodCom1:
	pop	ds			;ds = DATARES
	add	sp,2
;	pop	ds:OldDS
	jmp	LodCom1




;***	EndInit - end up initialization sequence
;
;	Move the environment to a newly allocated segment.

;;EndInit:
;;	push	ds			; save segments
;;	push	es			;
;;	push	cs			; get resident segment to DS
;;	pop	ds			;
;;	assume	ds:RESGROUP
;;	mov	cx,UsedEnv		; get number of bytes to move
;;	mov	es,EnvirSeg		; get target environment segment
;;	assume	es:NOTHING
;;
;;	mov	ds:Pdb_Environ,es	; put new environment in my header
;;	mov	ds,OldEnv		; source environment segment
;;	assume	ds:NOTHING
;;	xor	si,si			; set up offsets to start of segments
;;	xor	di,di
;;	cld
;;	rep	movsb			; move it
;;	xor	ax,ax
;;	stosb				; make sure it ends with double-null
;;
;;	cmp	ResetEnv,1		; do we need to setblock to env end?
;;	jne	NoReset 		; no - we already did it
;;	mov	bx,EnvSiz		; BX = size of environ in paragraphs
;;	push	es			; save environment - just to be sure
;;	mov	ah,SETBLOCK		;
;;	int	21h
;;	pop	es
;;
;;NoReset:
;;	mov	InitFlag,FALSE		; turn off init flag
;;	pop	es
;;	pop	ds
;;	jmp	LodCom			; allocate transient

;
;The init code has been changed to take care of the new way in which the
;environment segment is allocated.
;NB: We can use all the init variables at this point because they are all in
;RESGROUP
;Bugbug: The above approach will not work for ROMDOS
;

IF 0

EndInit:
	push	ds
	push	es			;save segments
	push	cs
	pop	ds		
	assume	ds:RESGROUP
;
;Chuckenv flag signals whether it is a passed environment or not
;
	mov	bx,ds
	mov	es,bx			;es = RESGROUP
;
;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
; code + data for low COMMAND
;
	mov	bx,ResSize		;Total size of resident
	mov	ah,SETBLOCK
	int	21h			;Set block to resident size
;
;Allocate the correct size for the environment
;
	mov	bx,EnvSiz		;bx = env size in paras
	mov	ah,ALLOC
	int	21h			;get memory
	jc	nomem_err		;out of memory,signal error

	mov	EnvirSeg,ax		;Store new environment segment
	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
	mov	es,ax			;es = address of allocated memory
	assume	es:nothing

;
;Copy the environment to the newly allocated segment
;
	mov	cx,UsedEnv		;number of bytes to move

	push	ds
	mov	ds,OldEnv		;ds = Old environment segment
	assume	ds:nothing

	xor	si,si
	mov	di,si			;Start transfer from 0

	cld
	rep	movsb			;Do the copy

	xor	ax,ax			
	stosb				;Make it end with double-null

	pop	ds			;ds = RESGROUP
	assume	ds:RESGROUP
;
;We have to free the old environment block if it was allocated by INIT
;
	cmp	Chuckenv,0		;has env been allocated by INIT?
	jne	no_free		;no, do not free it

	mov	ax,OldEnv		;Get old environment
	mov	es,ax
	mov	ah,DEALLOC	
	int	21h			;Free it
no_free:
	mov	InitFlag,FALSE		;indicate INIT is done
	
	pop	es
	pop	ds
	assume	ds:nothing
	
	jmp	LodCom			;allocate transient

nomem_err:
;
;We call the error routine which will never return. It will either exit
;with an error ( if not the first COMMAND ) or just hang after an error 
;message ( if first COMMAND )
;

	call	Alloc_error
ENDIF

CODERES ends



;	This TAIL segment is used to produce a PARA aligned label in
;	the resident group which is the location where the transient
;	segments will be loaded initial.

TAIL		segment public para

		org	0
TranStart	label	word
		public	TranStart

TAIL		ends



;	This TAIL segment is used to produce a PARA aligned label in
;	the transient group which is the location where the exec
;	segments will be loaded initial.
;
;	Bugbug:	Is TRANTAIL used anymore?

TRANTAIL	segment public para

		org	0
ExecStart   	label   word

TRANTAIL    	ends

		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\comequ.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;*************************************
; COMMAND EQUs which are not switch dependant

		include	curdir.inc	; to get DIRSTRLEN
;		Note dossym.inc must already have been included!

EMGDEBUG = FALSE

SYM		EQU	">"

ifdef JAPAN
LINESPERPAGE	EQU	24
else					; if Not JAPAN
LINESPERPAGE	EQU	25		;AC000; default lines per page
endif
NORMPERLIN	EQU	1
WIDEPERLIN	EQU	5
COMBUFLEN       EQU     128             ; Length of commmand buffer
EXECPATHLEN     EQU     273             ; MAX_PATH+13 (expanded for ntvdm)
BatLen		EQU	32		; buffer for batch files
YES_ECHO	EQU	1		; echo line
NO_ECHO 	EQU	0		; don't echo line
No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
call_in_progress EQU	1		; indicate we're in the CALL command
length_call	EQU	4		; length of CALL
max_nest	EQU    10		; max # levels of batch nesting allowed
fail_allowed	EQU    00001000b	; critical error
retry_allowed	EQU    00010000b	; critical error
Ignore_allowed	EQU    00100000b	; critical error
nullcommand	EQU    1		; no command on command line
end_of_line	EQU    -1		;AN000; end of line return from parser
end_of_line_out EQU	0		;AN000; end of line for output
end_of_line_in	EQU	0dh		;AN000; end of line for input
result_number	EQU	1		;AN000; number returned from parser
result_string	EQU	3		;AN000; string returned from parser
result_filespec EQU	5		;AN000; filespec returned from parser
result_drive	EQU	6		;AN000; drive returned from parser
result_date	EQU	7		;AN000; date returned from parser
result_time	EQU	8		;AN000; time returned from parser
result_no_error EQU	0		;AN000; no error returned from parser
no_cont_flag	EQU	0		;AN000; no control flags for message
util_msg_class	EQU	-1		;AN000; message class for utility
ext_msg_class	EQU	1		;AN000; message class for extended error
parse_msg_class EQU	2		;AN000; message class for parse error
crit_msg_class	EQU	3		;AN000; message class for critical error
ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
colon_char	EQU	":"             ;AN000; colon character
crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
text_mode	EQU	1		;AN000; text mode return from ioctl
get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
Parm_off_pos	equ	word ptr 2	;AN000; Offset from start of subst list for subst offset
parm_block_size equ	11		;AN000; size of message subst block
blank		equ	" "             ;AN000; blank character
no_subst	equ	0		;AN000; no substitutions for messages
one_subst	equ	1		;AN000; one substitution for messages
no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
res_subst	equ	2		;AN000; offset from start of message definition to number of subst
read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
capital_A	equ	'A'             ;AC000;
vbar		equ	'|'             ;AC000;
labracket	equ	'<'             ;AC000;
rabracket	equ	'>'             ;AC000;
dollar		equ	'$'             ;AC000;
lparen		equ	'('             ;AC000;
rparen		equ	')'             ;AC000;
nullrparen	equ	29h		;AC000;
in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
star		equ	'*'             ;AC000;
plus_chr	equ	'+'             ;AC000;
small_a 	equ	'a'             ;AC000;
small_z 	equ	'z'             ;AC000;
dot_chr 	equ	'.'             ;AC000;
tab_chr 	equ	9		;AN032;
equal_chr	equ	'='             ;AN032;
semicolon	equ	';'             ;AN049;
dot_qmark	equ	2e3fh		;AC000; '.?'
dot_colon	equ	2e3ah		;AC000; '.:'
capital_n	equ	0		;AC000; result from Y/N call if N entered
capital_y	equ	1		;AC000; result from Y/N call if Y entered
AppendInstall	equ	0B700H		;AN020; append install check
AppendDOS	equ	0B702H		;AN020; append DOS version check
AppendGetState	equ	0B706H		;AN020; append get current state
AppendSetState	equ	0B707H		;AN020; append set current state
AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
search_attr	equ	attr_read_only+attr_hidden+attr_directory  ;AC042;

;*************************************
;* PARSE ERROR MESSAGES
;*************************************

MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number

;*************************************
;* EQUATES FOR MESSAGE RETRIEVER
;*************************************

GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever

;*********************************
;* EQUATES FOR INT 10H
;*********************************

VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white

AltPipeChr	equ	"|"             ; alternate pipe character

FCB		EQU	5CH

VARSTRUC	STRUC
ISDIR		DB	?
SIZ		DB	?
TTAIL		DW	?
INFO		DB	?
BUF		DB	DIRSTRLEN + 20 DUP (?)
VARSTRUC	ENDS

;
; Flags for internal command parsing
;
fCheckDrive	equ	00000001b	; validate drive letter
fSwitchAllowed	equ	00000010b	; switches allowed
fLimitHelp	equ	00000100b	; /? must appear alone

;
; Test switches
;
fParse		EQU	0001h		; display results of parseline

;
; Batch segment structure
;
;   BYTE    type of segment
;   BYTE    echo state of parent on entry to batch file
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;

BatchType   equ 0

BatchSegment	struc
BatType 	DB	BatchType	; signature
Batechoflag	DB	0		; G state of echo
BatchEOF		DB	0	;records if EOF reached on file
Batlast 	DW	0		; G segment of last batch file
Batforptr	DW	0		; G segment for FOR command
Batforflag	DB	0		; G state of FOR
BatSeek 	DD	?		; lseek position of next char
BatParm 	DW	10 dup (?)	; pointers to parameters
BatFile 	DB	?		; beginning of batch file name
BatchSegment	ends

ANULL		equ	0		; terminates an argv string
ARGMAX		equ	64		; max args on a command line
ARGBLEN 	equ	2*128		; 1char each plus term NUL
tplen		equ	64		; max size of one argument
arg_cnt_error	equ	1		; number of args > MAXARG
arg_buf_ovflow	equ	2		; overflowed argbuffer

argv_ele   STRUC			; elements in the argv array
    argpointer	DW	(?)		; pointer to the argstring
    argflags	DB	(?)		; cparse flags for this argstring
    argstartel	DW	(?)		; the result of cparse's [STARTEL]
    arglen	DW	(?)		; cparse's char count + one (for null)
    argsw_word	DW	(?)		; any switches after this?  what kinds?
    arg_ocomptr DW	(?)		; pointer into original command string
argv_ele   ENDS

arg_unit    STRUC
    argv	DB	(ARGMAX * SIZE argv_ele) DUP (?)
    argvcnt	DW	(?)		; number of arguments
    argswinfo	DW	(?)		; Switch information for entire line
    argbuf	DW	ARGBLEN DUP (?) ; storage for argv strings
    argforcombuf db	COMBUFLEN DUP (?) ; Original for loop command string
arg_unit    ENDS

parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1

SwitchQues 	EQU	20h
SwitchV 	EQU	10h
SwitchB 	EQU	08h
SwitchA 	EQU	04h
SwitchP 	EQU	02h
SwitchW 	EQU	01h
fSwitch 	EQU	8000h
fBadSwitch	EQU	4000h

SwitchDir	EQU	SwitchP + SwitchW + fSwitch
SwitchCopy	EQU	SwitchV + SwitchA + SwitchB + fSwitch

break <Trap:  Get the attention of MSDOS>
;   TRAP snares the operating system for a service call
; AX, as well as any other registers MS-DOS takes a fancy to, will be crunched.
trap	MACRO	dos_function,dos_info
    ifnb    <dos_info>
	mov	AX, (dos_function SHL 8) + dos_info
    else
	mov	AX, (dos_function SHL 8)
    endif
	int	21h
ENDM

;
; Equates for initialization
;
initInit	equ	01h		; initialization in progress
initSpecial	equ	02h		; in initialization time/date routine
initCtrlC	equ	04h		; already in ^C handler

;M052 BETA3WARN	equ	1		; Yank anything related to this EQU
					; out before we ship


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\copy.asm ===
page ,132
	title	COMMAND COPY routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

comment % -----------------------------------------------------------------

;***	COPY.ASM

Source files:  copy.asm, copypr1.asm, copypr2.asm


;***	MODIFICATION HISTORY

11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
11/02/83 EE  Commented out the code in CPARSE which added drive designators
	     to tokens which begin with path characters so that PARSELINE
	     will work correctly.
11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
	     individual tokens.  That distinction is no longer needed for
	     FOR loop processing.
11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
	     1 when Cparse is called from COPY.
11/17/83 EE  Took out the comment chars around code described in 11/04/83
	     mod.  It now is conditional on flag like previous mod.
11/21/83 NP  Added printf
12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
	     be added to a token.
05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
	     NOTE: DestHand is the destination handle.  There are two
	     special values:  -1 meaning destination was never opened and
	     0 which means that the destination has been openned and
	     closed.
06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
06/06/86 EG  Change to fix problem of source switches /a and /b getting
	     lost on large and multiple file (wildcard) copies.
06/09/86 EG  Change to use xnametrans call to verify that source and
	     destination are not equal.

06/24/90 DO  If the destination of a file concatenation is the same as
	     first source file AND we run out of disk space before
	     completing the concatenation, restore the first source
	     file as best we can.  See SeekEnd and CopErr.  Bug #859.

M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
		instead of compatibility mode. This gives lesser sharing
		violations when files are opened for read on a copy.

% -------------------------------------------------------------------------

	.xlist
	.xcref

	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	.list
	.cref


DATARES 	segment public byte
	extrn	VerVal:word
DATARES 	ends

TRANDATA 	segment public byte
	extrn	BadCd_Ptr:word
	extrn	Copied_Ptr:word
	extrn	Extend_Buf_Ptr:word
	extrn	Extend_Buf_Sub:byte
	extrn	File_Name_Ptr:word
	extrn	InBDev_Ptr:word    
	extrn	Msg_Disp_Class:byte
	extrn	Overwr_Ptr:word
TRANDATA	ends

TRANSPACE	segment public byte
	extrn	AllSwitch:word
	extrn	ArgC:byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	BytCnt:word
	extrn	CFlag:byte
	extrn	Comma:byte
	extrn	Concat:byte
	extrn	Copy_Num:word	   
	extrn	CpDate:word
	extrn	CpTime:word
	extrn	CpyFlag:byte	   
	extrn	CurDrv:byte
	extrn	DestBuf:byte
	extrn	DestClosed:byte
	extrn	DestFcb:byte
	extrn	DestFcb2:byte
	extrn	DestHand:word
	extrn	DestInfo:byte
	extrn	DestIsDir:byte
	extrn	DestSiz:byte
	extrn	DestSwitch:word
	extrn	DestTail:word
	extrn	DestVars:byte
	extrn	DirBuf:byte
	extrn	Expand_Star:byte
	extrn	FileCnt:word
	extrn	FirstDest:byte
	extrn	FrstSrch:byte
	extrn	Inexact:byte
	extrn	MelCopy:byte
	extrn	MelStart:word
	extrn	Msg_Flag:byte	   
	extrn	NoWrite:byte
	extrn	NxtAdd:word
	extrn	ObjCnt:byte
	extrn	OCtrlZ:byte
	extrn	OFilePtr_Hi:word
	extrn	OFilePtr_Lo:word
	extrn	One_Char_Val:byte  
	extrn	Parse_Last:word    
	extrn	Plus:byte
	extrn	Plus_Comma:byte
	extrn	RdEof:byte
	extrn	ResSeg:word
	extrn	ScanBuf:byte
	extrn	SDirBuf:byte
	extrn	SrcBuf:byte
	extrn	SrcHand:word
	extrn	SrcInfo:byte
	extrn	SrcIsDev:byte
	extrn	SrcPt:word
	extrn	SrcSiz:byte
	extrn	SrcTail:word
	extrn	SrcVars:byte
	extrn	SrcXName:byte
	extrn	StartEl:word
	extrn	String_Ptr_2:word
	extrn	TermRead:byte
	extrn	Tpa:word
	extrn	UserDir1:byte
	extrn	Written:word
TRANSPACE	ends




;***	COPY CODE

TRANCODE	segment public byte

	extrn	CError:near
	extrn	CopErr:near
	extrn	TCommand:near

	public	Copy

	assume	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING

	break	Copy

Copy:
	assume	ds:TRANGROUP,es:TRANGROUP

; 	Initialize internal variables.

	xor	ax,ax		; AX = 0
	mov	Copy_Num,ax	; # files copied (destinations) = 0
	mov	SrcPt,ax	; cmd line ptr for source scan = 0
	mov	SrcTail,ax	; ptr to last element of source pathname = 0
	mov	CFlag,al	; 'destination file created' = false
	mov	NxtAdd,ax	; ptr into TPA buffer = 0
	mov	DestSwitch,ax	; destination switches = none
	mov	StartEl,ax	; CParse ptr to last pathname element = 0
	mov	DestTail,ax	; ptr to last element of dest pathname = 0
	mov	DestClosed,al	; 'destination file closed' = false
	mov	DestSiz,al	; length of destination pathname = 0
	mov	SrcSiz,al	; length of source pathname = 0
	mov	DestInfo,al	; destination pathname flags = none
	mov	SrcInfo,al	; source pathname flags = none
	mov	Inexact,al	; 'inexact copy' = false
	mov	DestVars,al	; 'dest pathname is directory' = false
	mov	SrcVars,al	; 'source pathname is directory' = false
	mov	UserDir1,al	; saved working directory = null
	mov	NoWrite,al	; 'no write' (source = dest) = false
	mov	RdEof,al	; 'read end of file' = false
	mov	SrcHand,ax	; source handle = 0
	mov	CpDate,ax	; copy date = 0
	mov	CpTime,ax	; copy time = 0
	mov	SrcIsDev,al	; 'source is device' = false
	mov	OCtrlZ,al	; 'Ctrl+Z removed from original' = false
	mov	OFilePtr_Lo,ax
	mov	OFilePtr_Hi,ax	; original destination file ptr = null
	mov	TermRead,al	; 'terminate read' = false
	mov	Comma,al	; '"+,," found' = false
	mov	Plus_Comma,al	; '"+,," found last time' = false (?)
	mov	Msg_Flag,al	;AN022; 'non-utility msg issued' = false
	mov	AllSwitch,ax	; all switches = none
	mov	ArgC,al		; source/dest argument count = 0
	mov	Plus,al		; '"+" in command line' = false
	mov	Binary,al	; 'binary copy' = false
	mov	Ascii,al	; 'ascii copy' = false
	mov	FileCnt,ax	; # files copied (destinations) = 0
	mov	Written,ax	; 'destination written to' = false
	mov	Concat,al	; 'concatenating' = false
	mov	MelCopy,al	; 'Mel Hallerman copy' = false
	mov	MelStart,ax	; Mel Hallerman cmd line ptr = 0

;	Initialize buffers with double-nulls.

	mov	word ptr ScanBuf,ax
	mov	word ptr DestBuf,ax
	mov	word ptr SrcBuf,ax 
	mov	word ptr SDirBuf,ax
	mov	word ptr DirBuf,ax 
	mov	word ptr DestFcb,ax

	mov	ObjCnt,al	; # CParse cmd-line objects found = 0

	dec	ax		; AX = 0FFFFh
	mov	DestHand,ax	; destination handle = 'never opened'
	mov	FrstSrch,al	; 'first search for source' = true
	mov	FirstDest,al	; 'first time for dest' = true
	mov	DestIsDir,al	; 'haven't analyzed destination'

	mov	si,81h		; SI = ptr to command line
	mov	bl,PLUS_CHR	; BL = special delimiter = "+"
	inc	Expand_Star	; CParse 'expand * to ?s' = true
	mov	CpyFlag,1	; CParse 'called from COPY' = true


;*	Scan the command line for destination information.

DestScan:
	xor	bp,bp				; BP = switch flag accumulator
	mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to pathname buf
	mov	Parse_Last,si			;AN018; save cmd line ptr
	invoke	CParse				; parse next object
	pushf					; save CParse flags
	inc	ObjCnt				; count object

	test	bh,80h
	jz	@f			; no "+" delimiter
	mov	Plus,1			; "+" delimiter occurred
@@:
	test	bh,1
	jz	TestP2			; not a switch

;	Found a switch.

	test	bp,SwitchV		;AN038; Verify requested?
	jz	Not_SlashV		;AN038; No - set the switch
	test	AllSwitch,SwitchV	;AN038; Verify already entered?
	jz	Not_SlashV		;AN038; No - set the switch
;AD018; or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
	or	bp,FBadSwitch		;AN018; Set up bad switch

Not_SlashV:				;AN038;
	or	DestSwitch,bp	 	; assume destination
	or	AllSwitch,bp		; keep tabs on all switches

	test	bp,not SwitchCopy	;AN018; Bad switch?
	jz	Not_Bad_Switch		;AN018; Switches are okay
	popf				;AN018; fix up stack
	mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
	invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
	jmp	CError			;AC018; exit

Not_Bad_Switch: 			;AN018; switch okay
	popf				; restore CParse flags
	jc	CheckDone		; found CR
	jmp	short DestScan		; continue scanning for destination

TestP2:
	popf				; restore CParse flags
	jc	CheckDone		; found CR

	test	bh,80h
	jnz	@f	 		; found a "+pathname" argument
	inc	ArgC			; count independent pathname args
@@:
	push	si				; save cmd line ptr
	mov	ax,StartEl			; AX = ptr to last path element
	mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to path string
	sub	ax,si				; AX = offset of last element
	mov	di,offset TRANGROUP:DestBuf	; DI = ptr to destination buf
	add	ax,di				; AX = ptr to last element in
						;  destination path buffer
	mov	DestTail,ax			; save ptr to last element
	mov	DestSiz,cl			; save path string length

	inc	cx			; CX = mov length (incl null)
	rep	movsb			; DestBuf = possible destination path
	mov	DestInfo,bh		; save CParse info flags
	mov	DestSwitch,0		; clear destination switches
	pop	si			; SI = ptr into cmd line again
	jmp	DestScan		;AC018; continue scanning for dest

CheckDone:

;	We reached the CR.  The destination scan is finished.

;	Disallow "copy file1+" as file overwriting itself.
;
;	(Note that "copy file1+file2+" will be accepted, and
;	equivalent to "copy file1+file2".)

;	Bugbug:  it looks like "copy /x file1+" would slip
;	through this check, since the switch would count
;	as another object in ObjCnt.

	cmp	Plus,1			; "+" with
	jne	cdCont
	cmp	ArgC,1			; one arg,
	jne	cdCont
	cmp	ObjCnt,2		; two objects..
	jne	cdCont
	mov	dx,offset TRANGROUP:OverWr_ptr
	jmp	CopErr			; is file overwrite.

cdCont:	mov	al,Plus			; AL = '"+" occurred'
	mov	Concat,al		; if "+" occurred, we're concatenating
	shl	al,1
	shl	al,1
	mov	Inexact,al		; therefore making an inexact copy

	mov	al,ArgC			; AL = # independent arguments
	or	al,al
	jnz	Try_Too_Many		; more than 0 args; check if too many

	mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
	jmp	short CError_ParseJ		; take parse error exit

Try_Too_Many:
	cmp	al,2
	jbe	ACountOk			; <= 2 arguments - ok

	mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
CError_ParseJ:
	mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message
CError4J:
	jmp	CError				; command error exit


ACountOk:
	mov	bp,offset TRANGROUP:DestVars	; BP = base of dest variables

;	Bugbug:  use of BP without segment override implies SS.
;	SS is implicitly assumed to point at TRANGROUP.

	cmp	al,1
	jne	Got2Args		; we have 2 arguments

;	Only one independent pathname argument on command line.
;	Set destination to d:*.*, where d: is current drive.

;	Bugbug:  but is this appropriate for "copy x:file1+x:file2"?
;	The two files would be appended as d:file1, rather than x:file1.

	mov	al,CurDrv		; AL = current drive (0 = A)
	add	al,CAPITAL_A		; AL = current drive letter
	mov	ah,':'			; AX = "d:"
	mov	[bp].siz,2		; pathname length = 2

	mov	di,offset TRANGROUP:DestBuf	; ES:DI = ptr to dest path buf
	stosw					; store "d:"

	mov	DestSwitch,0		; clear destination switches
	mov	[bp].info,2		; mark destination 'wildcard present'
	mov	[bp].isdir,0		; mark destination 'not a directory'
	invoke	SetStars		; add wildcards

Got2Args:

;	If destination pathname is "d:", add full wildcard filename

	cmp	[bp].siz,2
	jne	NotShortDest		; not two chars, can't be "d:"

	mov	al,':'
	cmp	destbuf+1,al
	jne	NotShortDest		; it's just a 2-character filename

	or	[bp].info,2		; mark destination 'wildcard present'
	mov	di,offset TRANGROUP:DestBuf+2
					; ES:DI = ptr after "d:"
	mov	[bp].isdir,0		; mark destination 'not a directory'
	invoke	SetStars		; add wildcards

NotShortDest:

;	If destination pathname ends with "\", try to make
;	sure it's "d:\".

	mov	di,[bp].ttail		; DI = ptr to last path element
	cmp	byte ptr [di],0
	jne	ChkSwtches		; not a null, so last char not "\"

	mov	dx,offset TRANGROUP:BadCD_Ptr	; DX = ptr to msg block
	mov	al,':'
	cmp	byte ptr [di-2],al
	jne	CError4J		; it's not "d:\", exit with error msg
	mov	[bp].isdir,2		; destination 'is a directory'
	or	[bp].info,6		; destination wildcarded and contains
					;  path character
	invoke	SetStars		; add wildcards

ChkSwtches:

;AD018; mov	ax,[ALLSWITCH]
;AD018; test	ax,NOT SwitchCopy
;AD018; jz	NOT_BAD_SWITCH			;AN000; Switches are okay
;AD018; MOV	DX,OFFSET TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
;AD018; mov	Extend_Buf_ptr,BadSwt_ptr	;AN000; get "Invalid switch" message number
;AD018; jmp	short CERROR_PARSEJ		;AC000; Switch specified which is not known
;AD018; NOT_BAD_SWITCH:

;	We have enough information about the destination for now.

;	Turn on verify if requested.  Save the current verify flag.

	mov	ax,AllSwitch		; AX = all switch flags
	test	ax,SwitchV
	jz	NoVerif 		; no /v, no verify

	mov	ah,GET_VERIFY_ON_WRITE	; AH = 'Get Verify Flag'
	int	21h			; call DOS

	push	ds
	mov	ds,ResSeg
	assume	ds:RESGROUP
	xor	ah,ah
	mov	VerVal,ax		; save current verify flag
	pop	ds
	assume	ds:TRANGROUP
	mov	ax,(SET_VERIFY_ON_WRITE shl 8) or 1  ; AX = 'Set Verify Flag'
	int	21h				     ; call DOS

NoVerif:

;*	Scan for first source.

	xor	bp,bp			; BP = switch flags accumulator
	mov	si,81h			; SI = ptr into command line
	mov	bl,PLUS_CHR		; BL = special CParse delimiter = "+"
ScanFSrc:
	mov	di,offset TRANGROUP:ScanBuf	; DI = ptr to pathname buf
	invoke	CParse			; parse first source pathname
	test	bh,1			; switch?
	jnz	ScanFSrc		; yes, try again
	or	DestSwitch,bp 		; include copy-wide switches on dest

;	Set ascii copying mode if concatenating, unless /b is specified.

	test	bp,SWITCHB
	jnz	NoSetCAsc		; /b - explicit binary copy
	cmp	Concat,0
	je	NoSetCAsc		; we're not concatenating
	mov	Ascii,SWITCHA		; set ascii copy
NoSetCAsc:
	call	Source_Set		; set source variables
	call	FrstSrc			; set up first source copy
	jmp	FirstEnt		; jump into the copy loop




	public	EndCopy

EndCopy:

;*	End of the road.  Close destination, display # files
;	copied (meaning # destinations), and go back to main
;	transient COMMAND code.

	call	CloseDest
EndCopy2:
	mov	dx,offset TRANGROUP:Copied_Ptr
	mov	si,FileCnt
	mov	Copy_Num,si
	invoke	Std_PrintF
	jmp	TCommand		; stack could be messed up




SrcNonexist:

;*	Source doesn't exist.  If concatenating, ignore and continue.
;	Otherwise, say 'file not found' and quit.

	cmp	Concat,0
	jne	NextSrc 		; concatenating - go on to next source

;	Set up error message.

	mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
	mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
	mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
	mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
	mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution

	jmp	CopErr			; print msg and clean up




SourceProc:

;*	Preparatory processing for each source file.
;	Called at FrstSrc for first source file.

	call	Source_Set		; set source variables & ascii/binary
	cmp	Concat,0
	jne	LeaveCFlag		; concatenating - leave CFlag alone
FrstSrc:
	xor	ax,ax
	mov	CFlag,al		; 'destination not created'
	mov	NxtAdd,ax		; copy buffer ptr = 0
	mov	DestClosed,al		; 'destination not closed'
LeaveCFlag:
	mov	SrcPt,si			; save cmd-line ptr
	mov	di,offset TRANGROUP:UserDir1	; DI = ptr to buf for user's 
						;   current dir
	mov	bp,offset TRANGROUP:SrcVars	; BP = base of source variables
	invoke	BuildPath			; cd to source dir, figure
						;   out stuff about source
	mov	si,SrcTail			; SI = ptr to source filename
	return




NextSrc:

;*	Next source.  Come here after handling each pathname.
;	We're done unless there are additional source pathnames
;	to be appended.
;
;	Note that all files matching an ambiguous pathname
;	are processed before coming here.

	cmp	Plus,0
	jne	MoreCp			; copying "+" sources - keep going

EndCopyJ2:
	jmp	EndCopy 		; done copying

MoreCp:
	xor	bp,bp			; BP = switch flags accumulator
	mov	si,SrcPt		; SI = ptr to current pos'n in cmd line
	mov	bl,PLUS_CHR		; BL = special delimiter = "+"

ScanSrc:
	mov	di,offset TRANGROUP:ScanBuf	; DI = ptr to pathname buf
	invoke	CParse				; parse first source name
	jc	EndCopyJ2			; CR found - we're done

	test	bh,80h
	jz	EndCopyJ2		; no "+" delimiter - we're done

	test	bh,1
	jnz	ScanSrc 		; switch found - keep looking

;	ScanBuf contains the next source pathname.

	call	SourceProc		; prepare this source
	cmp	Comma,1 		;g  was +,, found last time?
	jne	NoStamp 		;g  no - try for a file
	mov	Plus_Comma,1		;g  yes - set flag
	jmp	SrcNonexist		;g  we know we won't find it

NoStamp:				;g
	mov	Plus_Comma,0		;g  reset +,, flag

FirstEnt:
;
;M047
; The only case we need to worry about is when the source is wildcarded and
;the destination is not. For this case, ConCat is not yet set to indicate
;concatenation. We check for this case.
;
;NB: This change has been backed out and replaced by M048. This is not the
;right place to do this check.
;

;	This is where we enter the loop with the first source.

	mov	di,FCB				; DI = ptr to FCB
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8	; 'Parse Filename'
	int	21h				; call DOS

	cmp	byte ptr [si],0 	; did we parse the whole thing?
	jne	SrchDone		; no, error, simulate 'not found'

	mov	ax,word ptr SrcBuf	; AX = possible "d:"
	cmp	ah,':'
	je	@f			; AX = definite "d:"
	mov	al,'@'			; AL = drive 'letter' for current drive
@@:
	or	al,20h			; AL = lowercase drive letter
	sub	al,60h			; AL = drive id (0=current,1=A,..)
	mov	ds:FCB,al		; put drive id in FCB

;	FCB contains drive and filename to search.

	mov	ah,DIR_SEARCH_FIRST	; AH = 'Find First File'
	call	Search

SrchDone:
	pushf				; save flags from Search
	invoke	RestUDir1		; restore users current directory
	popf				; restore flags from search
	jz	@f			; found the source - continue
	jmp	SrcNonexist		; didn't find the source
@@:
	xor	al,al
	xchg	al,FrstSrch
	or	al,al
	jz	NextAmbig

SetNMel:
	mov	cx,12
	mov	di,offset TRANGROUP:SDirBuf
	mov	si,offset TRANGROUP:DirBuf
	rep	movsb			; save very first source name

NextAmbig:
	xor	al,al
	mov	NoWrite,al		; turn off nowrite
	mov	di,SrcTail
	mov	si,offset TRANGROUP:DirBuf + 1
	invoke	Fcb_To_Ascz		; SrcBuf has complete name

MelDo:
	cmp	Concat,0
	jne	ShowCpNam		; concatenating - show name
	test	SrcInfo,2		; wildcard - show name
	jz	DoRead

ShowCpNam:
	mov	dx,offset TRANGROUP:File_Name_Ptr
	invoke	Std_PrintF
	invoke	CrLf2

DoRead:
	call	DoCopy
	cmp	Concat,0
	jne	NoDClose		; concatenating - don't close dest

	call	CloseDest		; close current destination
	jc	NoDClose		; concatenating - dest not closed

	mov	CFlag,0			; 'destination not created'

NoDClose:
	cmp	Concat,0
	je	NoFlush			; not concatenating - don't flush

;	Concatenating - flush output between source files so LostErr
;	stuff works correctly.

	invoke	FlshFil
	test	MelCopy,0FFh
	jz	@f
	jmp	short DoMelCopy
@@:
NoFlush:
	call	SearchNext		; try next match
	jnz	NextSrcJ		; not found - finished with 
					;   this source spec
	mov	DestClosed,0		; 'destination not closed'
	jmp	NextAmbig		; do next ambig match




DoMelCopy:
	cmp	MelCopy,0FFh
	je	ContMel
	mov	si,SrcPt
	mov	MelStart,si
	mov	MelCopy,0FFh
ContMel:
	xor	bp,bp
	mov	si,SrcPt
	mov	bl,PLUS_CHR
ScanSrc2:
	mov	di,offset TRANGROUP:ScanBuf
	invoke	CParse
	test	bh,80h
	jz	NextMel 		; no "+" - go back to start

	test	bh,1
	jnz	ScanSrc2		; switch - keep scanning

	call	SourceProc
	invoke	RestUDir1
	mov	di,offset TRANGROUP:DestFcb2
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8
	int	21h
	mov	bx,offset TRANGROUP:SDirBuf + 1
	mov	si,offset TRANGROUP:DestFcb2 + 1
	mov	di,SrcTail

	invoke	BuildName

	cmp	Concat,0
	je	MelDoJ			; not concatenating - continue

;	Yes, turn off nowrite because this part of the code 
;	is only reached after the first file has been dealt with.

	mov	NoWrite,0

MelDoJ:
	jmp	MelDo

NextSrcJ:
	jmp   NextSrc

NextMel:
	call	CloseDest
	xor	ax,ax
	mov	CFlag,al
	mov	NxtAdd,ax
	mov	DestClosed,al
	mov	si,MelStart
	mov	SrcPt,si
	call	SearchNext
	jz	SetNMelJ
	jmp	EndCopy2
SetNMelJ:
	jmp	SetNMel




SearchNext:
	mov	ah,DIR_SEARCH_NEXT
	test	SrcInfo,2
	jnz	Search			; do search-next if ambig
	or	ah,ah			; reset zero flag
	return

Search:
	push	ax
	mov	ah,SET_DMA
	mov	dx,offset TRANGROUP:DirBuf
	int	21h			; put result of search in dirbuf
	pop	ax			; restore search first/next command
	mov	dx,FCB
	int	21h			; Do the search
	or	al,al
	return




DoCopy:
	mov	si,offset TRANGROUP:SrcBuf	;g do name translate of source
	mov	di,offset TRANGROUP:SrcXName	;g save for name comparison
	mov	ah,XNAMETRANS			;g
	int	21h				;g

	mov	RdEof,0				; no EOF yet

	mov	ax,EXTOPEN shl 8		; open the file
;M046
; For reads, the sharing mode should be deny none so that any process can
;open this file again in any other sharing mode. This is mainly to allow
;multiple command.com's to access the same file without getting sharing
;violations
;
	mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
	xor	cx,cx				; no special files
	mov	dx,READ_OPEN_FLAG		; set up open flags
	int	21h

	jnc	OpenOk

;	Bogosity:  IBM wants us to issue Access Denied in this case.
;	They asked for it...

	jmp	short Error_On_Source 		;AC022; clean up and exit

OpenOk:
	mov	bx,ax				; save handle
	mov	SrcHand,bx			; save handle
	mov	ax,(FILE_TIMES shl 8)
	int	21h
	jc	Error_On_Source
	mov	CpDate,dx			; save date
	mov	CpTime,cx			; save time
	jmp	short No_Copy_Xa		; (xa copy code removed)


Error_On_Source:				;AN022; we have a BAD error
	invoke	Set_Ext_Error_Msg		;AN022; set up the error message
	mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN022; put number of subst in control block
	invoke	Std_EprintF			;AN022; print it
	cmp	SrcHand,0			;AN022; did we open the file?
	je	No_Close_Src			;AN022; no - don't close
	call	CloseSrc			;AN022; clean up
No_Close_Src:					;AN022;
	cmp	CFlag,0				;AN022; was destination created?
	je	EndCopyJ3			;AN022; no - just cleanup and exit
	jmp	EndCopy 			;AN022; clean up concatenation and exit
EndCopyJ3:					;AN022;
	jmp	EndCopy2			;AN022;

No_Copy_Xa:
	mov	bx,SrcHand			;AN022; get handle back
	mov	ax,(IOCTL shl 8)
	int	21h				; get device stuff
	and	dl,DEVID_ISDEV
	mov	SrcIsDev,dl			; set source info
	jz	CopyLp				; source not a device
	cmp	Binary,0
	je	CopyLp				; ascii device ok
	mov	dx,offset TRANGROUP:InBDev_Ptr	; cannot do binary input
	jmp	CopErr


CopyLp:
	mov	bx,SrcHand
	mov	cx,BytCnt
	mov	dx,NxtAdd
	sub	cx,dx				; compute available space
	jnz	GotRoom
	invoke	FlshFil
	cmp	TermRead,0
	jne	CloseSrc			; give up
	mov	cx,BytCnt
GotRoom:
	push	ds
	mov	ds,Tpa
	assume	ds:NOTHING
	mov	ah,READ
	int	21h
	pop	ds
	assume	ds:TRANGROUP
	jc	Error_On_Source 		;AC022; give up if error
	mov	cx,ax				; get count
	jcxz	CloseSrc			; no more to read
	cmp	SrcIsDev,0
	jne	NoTestA 			; is a device, ascii mode
	cmp	Ascii,0
	je	BinRead
NoTestA:
	mov	dx,cx
	mov	di,NxtAdd
	mov	al,1Ah
	push	es
	mov	es,Tpa
	repne	scasb				; scan for EOF
	pop	es
	jne	UseAll
	inc	RdEof
	inc	cx
UseAll:
	sub	dx,cx
	mov	cx,dx
BinRead:
	add	cx,NxtAdd
	mov	NxtAdd,cx
	cmp	cx,BytCnt			; is buffer full?
	jb	TestDev 			; if not, we may have found eof
	invoke	FlshFil
	cmp	TermRead,0
	jne	CloseSrc			; give up
	jmp	short CopyLp

TestDev:
	cmp	SrcIsDev,0
	je	CloseSrc			; if file then EOF
	cmp	RdEof,0
	je	CopyLp				; on device, go till ^Z
CloseSrc:
	mov	bx,SrcHand
	mov	ah,CLOSE
	int	21h
	return




CloseDest:

;	We are called to close the destination.
;	We need to note whether or not there is any internal data left
;	to be flushed out.

	cmp	DestClosed,0
	retnz				; don't double close
	mov	al,byte ptr DestSwitch
	invoke	SetAsc			; check for b or a switch 
	jz	BinClos			;   on destination
	mov	bx,NxtAdd
;
;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
;^Z, let's always flush out. This way if the ConCat flag changes, we will
;just return without appending a ^Z incorrectly for the first file(since we
;are concatenating now). Also, in case it is a single file copy, we will
;anyway write the ^Z out separately. The only drawback is that there is a
;performance overhead on single ASCII file copies which now always involve
;2 writes instead of 1 before. Is this really that important?
;
;M048;	cmp	bx,BytCnt		; is memory full?
;M048;	jne	PutZ

	invoke	TryFlush		; flush (and double-check for concat)
	je	NoConc
ConChng:				; concat flag changed on us
	stc
	return
NoConc:
	xor	bx,bx
PutZ:
	push	ds
	mov	ds,Tpa
	mov	word ptr [bx],1Ah	; add EOF mark (ctrl-Z)
	pop	ds
	inc	NxtAdd
	mov	NoWrite,0		; make sure our ^z gets written
	mov	ax,Written
	add	ax,NxtAdd
	jc	BinClos 		; > 1
	cmp	ax,1
	je	ForgetItJ		; Written = 0 NxtAdd = 1 (the ^Z)
BinClos:
	invoke	TryFlush
	jnz	ConChng
	cmp	Written,0
ForgetItJ:
	jne	No_Forget		; wrote something
	jmp	ForgetIt		; never wrote nothing
No_Forget:
	mov	bx,DestHand
	mov	cx,CpTime
	mov	dx,CpDate
	cmp	Inexact,0		; copy not exact?
	je	DoDClose		; if no, copy date & time
	mov	ah,GET_TIME
	int	21h
	shl	cl,1
	shl	cl,1			; left justify min in cl
	shl	cx,1
	shl	cx,1
	shl	cx,1			; hours to high 5 bits, min to 5-10
	shr	dh,1			; divide seconds by 2 (now 5 bits)
	or	cl,dh			; and stick into low 5 bits of cx
	push	cx			; save packed time
	mov	ah,GET_DATE
	int	21h
	sub	cx,1980
	xchg	ch,cl
	shl	cx,1			; year to high 7 bits
	shl	dh,1			; month to high 3 bits
	shl	dh,1
	shl	dh,1
	shl	dh,1
	shl	dh,1			; most sig bit of month in carry
	adc	ch,0			; put that bit next to year
	or	dl,dh			; or low three of month into day
	mov	dh,ch			; get year and high bit of month
	pop	cx			; get time back
DoDClose:
	cmp	bx,0
	jle	CloseDone
	mov	ax,(FILE_TIMES shl 8) or 1
	int	21h			; set date and time
	jc	Cleanup_Err		;AN022; handle error

;	See if the destination has *anything* in it.
;	If not, just close and delete it.

	mov	ax,(LSEEK shl 8) + 2	; seek to EOF
	xor	dx,dx
	mov	cx,dx
	int	21h

;	DX:AX is file size

	or	dx,ax
	pushf
	mov	ax,(IOCTL SHL 8) + 0	; get the destination attributes
	int	21h
	push	dx			; save them away
	mov	ah,CLOSE
	int	21h
	pop	dx
	jnc	Close_Cont		;AN022; handle error on close
	popf				;AN022; get the flags back
Cleanup_Err: 				;AN022;
	call	CleanUpErr		;AN022; attempt to delete the target
	call	DestDelete		;AN022; attempt to delete the target
	jmp	short FileClosed	;AN022; close the file
Close_Cont:				;AN022; no error - continue
	popf
	jnz	CloseDone
	test	dx,80h			; is the destination a device?
	jnz	CloseDone		; yes, copy succeeded
	call	DestDelete
	jmp	short FileClosed
CloseDone:
	inc	FileCnt
FileClosed:
	inc	DestClosed
Ret50:
	clc
	return


ForgetIt:
	mov	bx,DestHand
	call	DoDClose		; close the dest
	call	DestDelete
	mov	FileCnt,0		; no files transferred
	jmp	Ret50


DestDelete:
	mov	dx,offset TRANGROUP:DestBuf
	mov	ah,UNLINK
	int	21h			; and delete it
	return




Source_Set	proc near

	push	si
	mov	ax,StartEl
	mov	si,offset TRANGROUP:ScanBuf	; adjust to copy
	sub	ax,si
	mov	di,offset TRANGROUP:SrcBuf
	add	ax,di
	mov	SrcTail,ax
	mov	SrcSiz,cl		; save its size
	inc	cx			; include the nul
	rep	movsb			; save this source
	mov	SrcInfo,bh		; save info about it
	pop	si
	mov	ax,bp			; switches so far
	invoke	SetAsc			; set a,b switches accordingly
	invoke	Switch			; get any more switches on this arg
	invoke	SetAsc			; set
	return

Source_Set	endp




;****************************************************************
;*
;* ROUTINE:	CleanupErr
;*
;* FUNCTION:	Issues extended error message for destination
;*		if not alreay issued
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	none
;*
;****************************************************************

CleanupErr	proc	near			;AN022;

	cmp	Msg_Flag,0			;AN022; have we already issued a message?
	jnz	CleanupErr_Cont 		;AN022; yes - don't issue duplicate error
	invoke	Set_Ext_Error_Msg		;AN022; set up error message
	mov	String_Ptr_2,offset TRANGROUP:DestBuf ;AN022; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN022; put number of subst in control block
	invoke	Std_EPrintF			;AN022; issue the error message

CleanupErr_Cont:				;AN022;
	ret					;AN022; return to caller

CleanupErr	endp				;AN022;


TRANCODE	ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\comseg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; The following are all of the segments used in the load order
;
;SR; We switch the order of the CODE and DATA segments since we will have to
;move the CODE segment for HIMEM COMMAND
;


DATARES 	segment public byte	; resident data
DATARES 	ends

;
;Dummy segment to align the code segment on a paragraph boundary
;
DUMMY	segment public para
DUMMY	ENDS

CODERES 	segment public byte	; resident code
CODERES 	ends

;SR;
;No environment segments
;
;;ENVARENA	segment public para	; space for DOS ALLOCATE header
;;ENVARENA	ends

;;ENVIRONMENT	segment public para	; default COMMAND environment
;;ENVIRONMENT	ends

INIT		segment public para	; initialization code
INIT		ends

TAIL		segment public para	; end of init - start of transient
TAIL		ends

TRANCODE	segment public byte	; transient code
TRANCODE	ends

TRANDATA	segment public byte	; transient data area
TRANDATA	ends

TRANSPACE	segment public byte	; transient modifiable data area
TRANSPACE	ends

TRANTAIL	segment public para	; end of transient
TRANTAIL	ends

;SR;
;  We still keep the CODE and DATA in a group. This is to make addressability
;easy during init. This will not work for COMMAND in ROM but it is fine for
;HIMEM COMMAND. However, the resident code will not refer to any data using
;RESGROUP
;

RESGROUP  	group CODERES,DATARES,INIT,TAIL
TRANGROUP 	group TRANCODE,TRANDATA,TRANSPACE,TRANTAIL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\copypr2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;M031	SR 10/11/90    Bug #3069. Use deny write sharing mode to open files
;		      	instead of compatibility mode. This gives lesser
;			sharing violations when files are opened for read on
;			a copy operation.
;
;




	.xlist
	.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	.list
	.cref


TRANDATA	segment public byte
	extrn	FulDir_Ptr:word 	;AN052;
TRANDATA ends

TRANSPACE	segment public byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	Concat:byte
	extrn	DestBuf:byte
	extrn	DestFcb:byte
	extrn	DestInfo:byte
	extrn	DestIsDir:byte
	extrn	DestTail:word
	extrn	DestVars:byte
	extrn	DirBuf:byte
	extrn	DirChar:byte
	extrn	FirstDest:byte
	extrn	Inexact:byte
	extrn	MelCopy:byte
	extrn	NxtAdd:word
	extrn	Plus:byte
	extrn	SDirBuf:byte
	extrn	SrcInfo:byte
	extrn	SrcXName:byte
	extrn	Tpa:word
	extrn	TrgXName:byte
	extrn	UserDir1:byte
TRANSPACE	ends

TRANCODE	segment public byte

	extrn	BadPath_Err:near	;AN022;
	extrn	CopErr:near		;AN052;
	extrn	Extend_Setup:near	;AN022;

	public	BuildPath
	public	SetStars
	public	SetAsc

ASSUME	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING




;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
;
;	Given switch vector in AX,
;	  Set Ascii flag if /a is set
;	  Clear Ascii flag if /b is set
;	  Binary set if /b specified
;	  Leave Ascii unchanged if neither or both are set
; 	Also sets Inexact if Ascii is ever set. 
;	AL = Ascii on exit, flags set
;

SetAsc:

	and	al,SWITCHA+SWITCHB	; AL = /a, /b flags
	jpe	LoadSw			; even parity - both or neither
	push	ax
	and	al,SWITCHB
	mov	Binary,al
	pop	ax
	and	al,SWITCHA
	mov	Ascii,al
	or	Inexact,al

LoadSw:
	mov	al,Ascii
	or	al,al
	return




;***	BuildDest

	public BuildDest

BuildDest:

	cmp	DestIsDir,-1
	jne	KnowAboutDest			; figuring already done
	mov	di,offset TRANGROUP:UserDir1
	mov	bp,offset TRANGROUP:DestVars
	call	BuildPath
	invoke	RestUDir1

;	We now know all about the destination.

KnowAboutDest:
	xor	al,al
	xchg	al,FirstDest
	or	al,al
	jnz	FirstDst
	jmp	NotFirstDest

FirstDst:

;	Create an fcb of the original dest.

	mov	si,DestTail			
	mov	di,offset TRANGROUP:DestFcb
	mov	ax,PARSE_FILE_DESCRIPTOR shl 8
	int	21h
	cmp	byte ptr [si],0
	je	GoodParse
;AD052; mov	byte ptr [di+1],"|"             ; must be illegal file name character
	mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
	jmp	CopErr				;AN052;

GoodParse:
	mov	ax,word ptr DestBuf		; AX = possible "d:"
	cmp	ah,':'
	je	@f
	mov	al,'@'
@@:
;	AX = "d:" for following FCB drive computation

	mov	cl,Ascii		; CL = saved Ascii flag
	or	al,20h
	sub	al,60h
	mov	DestFcb,al		; store drive # in FCB

;*	Figure out what copy mode we're in.
;	Letters stand for unambiguous, * for ambiguous pathnames.
;	+n stands for additional sources delimited by +'s.
;
;	copy a b	not concatenating
;	copy a *	not concatenating
;	copy * a	concatenating
;	copy * *	not concatenating
;	copy a+n b	concatenating
;	copy *+n a	concatenating
;	copy *+n *	concatenating, Mel Hallorman style

;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file..  Why?
;		 copy a.b+*.a *.t  picks up all *.a files.

	mov	al,DestInfo		; AL = destination CParse flags
	mov	ah,SrcInfo		; AH = source CParse flags
	and	ax,0202h		; AH,AL = source,dest wildcard flags
	or	al,al
	jz	NotMelCopy		; no destination wildcard

;	Destination is wildcarded.

	cmp	al,ah
	jne	NotMelCopy		; no source wildcard

;	Source and destination are both wildcarded.

	cmp	Plus,0
	je	NotMelCopy		; no +'s in source

;	Source and destination are wildcarded, and source includes +'s.
;	It's Mel Hallorman copy time.

	inc	MelCopy			; 'Mel copy' = true
	xor	al,al
	jmp	short SetConc

NotMelCopy:
	xor	al,2		; AL=0 -> ambiguous destination, 2 otherwise
	and	al,ah
	shr	al,1		; AL=1 -> ambiguous source, unambiguous dest
				;   (implies concatenation)

SetConc:
	or	al,Plus		; "+" always infers concatenation

;	Whew.  AL = 1 if concatenating, 0 if not.

	mov	Concat,al
	shl	al,1
	shl	al,1
	mov	Inexact,al		; concatenation -> inexact copy
	cmp	Binary,0
	jne	NotFirstDest		; explicit binary copy

	mov	Ascii,al		; otherwise, concatenate in ascii mode
	or	cl,cl
	jnz	NotFirstDest		; Ascii flag set before, data read correctly
	or	al,al
	jz	NotFirstDest		; Ascii flag did not change state

;	At this point there may already be binary read data in the read
;	buffer.  We need to find the first ^Z (if there is one) and trim the
;	amount of data in the buffer correctly.

	mov	cx,NxtAdd
	jcxz	NotFirstDest		; no data, everything ok
	mov	al,1Ah
	push	es
	xor	di,di
	mov	es,Tpa
	repne	scasb			; scan for EOF
	pop	es
	jne	NotFirstDest		; no ^z in buffer, everything ok
	dec	di			; point at ^z
	mov	NxtAdd,di		; new buffer length

NOTFIRSTDEST:
	mov	bx,offset trangroup:DIRBUF+1	; Source of replacement chars
	cmp	CONCAT,0
	jz	GOTCHRSRC			; Not a concat
	mov	bx,offset trangroup:SDIRBUF+1	; Source of replacement chars

GOTCHRSRC:
	mov	si,offset trangroup:DESTFCB+1	; Original dest name
	mov	di,DESTTAIL			; Where to put result

public buildname
BUILDNAME:

ifdef DBCS					; ### if DBCS ###

	mov	cx,8
	call	make_name
	cmp	byte ptr [si],' '
	jz	@f				; if no extention
	mov	al,dot_chr
	stosb
	mov	cx,3
	call	make_name
@@:
	xor	al,al
	stosb					; nul terminate
	return

else						; ### if Not DBCS ###

	mov	cx,8

BUILDMAIN:
	lodsb
	cmp	al,'?'
	jnz	NOTAMBIG
	mov	al,byte ptr [BX]

NOTAMBIG:
	cmp	al,' '
	jz	NOSTORE
	stosb

NOSTORE:
	inc	bx
	loop	BUILDMAIN
	mov	cl,3
	mov	al,' '
	cmp	byte ptr [SI],al
	jz	ENDDEST 			; No extension
	mov	al,dot_chr
	stosb

BUILDEXT:
	lodsb
	cmp	al,'?'
	jnz	NOTAMBIGE
	mov	al,byte ptr [BX]

NOTAMBIGE:
	cmp	al,' '
	jz	NOSTOREE
	stosb

NOSTOREE:
	inc	bx
	loop	BUILDEXT
ENDDEST:
	xor	al,al
	stosb					; NUL terminate
	return

endif						; ### end if Not DBCS ###


ifdef DBCS				; ### if DBCS ###
make_name:
	mov	ah,0			; reset DBCS flag
	mov	dh,cl			; save length to do
mkname_loop:
	cmp	ah,1			; if it was lead byte
	jz	mkname_dbcs
	mov	ah,0			; reset if it was single or tail byte
	mov	al,[bx]			; get source char
	invoke	testkanj
	jz	mkname_load		; if not lead byte
mkname_dbcs:
	inc	ah			; set dbcs flag
mkname_load:
	lodsb				; get raw char
	cmp	al,'?'
	jnz	mkname_store		; if not '?'
	cmp	ah,0
	jz	mkname_conv		; if source is single
	cmp	ah,1
	jnz	mkname_pass		; if source is not lead
	cmp	cl,dh
	jnz	mkname_lead		; if this is not 1st char
	cmp	byte ptr [si],' '
	jz	mkname_double		; if this is the end
mkname_lead:
	cmp	byte ptr [si],'?'
	jnz	mkname_pass		; if no '?' for tail byte
	cmp	cx,1
	jbe	mkname_pass		; if no room for tail byte
mkname_double:
	mov	al,[bx]
	stosb
	inc	bx
	inc	si
	dec	cx
	inc	ah			; tail byte will be loaded
mkname_conv:
	mov	al,[bx]
mkname_store:
	cmp	al,' '
	jz	mkname_pass
	stosb				; store in destination
mkname_pass:
	inc	bx
	loop	mkname_loop
	return
endif					; ### end if DBCS ###

BUILDPATH:
	test	[BP.INFO],2
	jnz	NOTPFILE			; If ambig don't bother with open
	mov	dx,bp
	add	dx,BUF				; Set DX to spec

	push	di				;AN000;
	MOV	AX,EXTOPEN SHL 8		;AC000; open the file
	mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
	xor	cx,cx				;AN000; no special files
	mov	si,dx				;AN030; get file name offset
	mov	dx,read_open_flag		;AN000; set up open flags
	INT	21h
	pop	di				;AN000;
	jnc	pure_file			;AN022; is pure file
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_file_not_found 	;AN022; if file not found - okay
	jz	notpfile			;AN022;
	cmp	ax,error_path_not_found 	;AN022; if path not found - okay
	jz	notpfile			;AN022;
	cmp	ax,error_access_denied		;AN022; if access denied - okay
	jz	notpfile			;AN022;
	jmp	extend_setup			;AN022; exit with error

pure_file:
	mov	bx,ax				; Is pure file
	mov	ax,IOCTL SHL 8
	INT	21h
	mov	ah,CLOSE
	INT	21h
	test	dl,devid_ISDEV
	jnz	ISADEV				; If device, done
	test	[BP.INFO],4
	jz	ISSIMPFILE			; If no path seps, done

NOTPFILE:
	mov	dx,word ptr [BP.BUF]
	cmp	dl,0				;AN034; If no drive specified, get
	jz	set_drive_spec			;AN034;    default drive dir
	cmp	dh,':'
	jz	DRVSPEC5

set_drive_spec: 				;AN034;
	mov	dl,'@'

DRVSPEC5:
	or	dl,20h
	sub	dl,60h				; A = 1
	invoke	SAVUDIR1
	jnc	curdir_ok			;AN022; if error - exit
	invoke	get_ext_error_number		;AN022; get the extended error
	jmp	extend_setup			;AN022; exit with error

curdir_ok:					;AN022;
	mov	dx,bp
	add	dx,BUF				; Set DX for upcomming CHDIRs
	mov	bh,[BP.INFO]
	and	bh,6
	cmp	bh,6				; Ambig and path ?
	jnz	CHECKAMB			; jmp if no
	mov	si,[BP.TTAIL]
	mov	bl,':'
	cmp	byte ptr [si-2],bl
	jnz	KNOWNOTSPEC
	mov	[BP.ISDIR],2			; Know is d:/file
	jmp	short DOPCDJ

KNOWNOTSPEC:
	mov	[BP.ISDIR],1			; Know is path/file
	dec	si				; Point to the /

DOPCDJ:
	jmp	DOPCD				;AC022; need long jump

CHECKAMB:
	cmp	bh,2
	jnz	CHECKCD

ISSIMPFILE:
ISADEV:
	mov	[BP.ISDIR],0			; Know is file since ambig but no path
	return

CHECKCD:
	invoke	SETREST1
	mov	ah,CHDIR
	INT	21h
	jc	NOTPDIR
	mov	di,dx
	xor	ax,ax
	mov	cx,ax
	dec	cx

Kloop:						;AN000;  3/3/KK
	MOV	AL,ES:[DI]			;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	OR	AL,AL				;AN000;  3/3/KK
	JZ	Done				;AN000;  3/3/KK
	xor	ah,ah				;AN000;  3/3/KK
	invoke	Testkanj			;AN000;  3/3/KK
	JZ	Kloop				;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	INC	AH				;AN000;  3/3/KK
	jmp	Kloop				;AN000;  3/3/KK

Done:						;AN000;  3/3/KK
	dec	di
	mov	al,DIRCHAR
	mov	[bp.ISDIR],2			; assume d:/file
	OR	AH, AH				;AN000; 3/3/KK
	JNZ	Store_pchar			;AN000; 3/3/KK	 this is the trailing byte of ECS code
	cmp	al,[di-1]
	jz	GOTSRCSLSH

Store_pchar:					;AN000; 3/3/KK
	stosb
	mov	[bp.ISDIR],1			; know path/file

GOTSRCSLSH:
	or	[bp.INFO],6
	call	SETSTARS
	return


NOTPDIR:
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; if path not found - okay
	jz	notpdir_try			;AN022;
	cmp	ax,error_access_denied		;AN022; if access denied - okay
	jnz	extend_setupj			;AN022; otherwise - exit error

notpdir_try:					;AN022;
	mov	[bp.ISDIR],0			; assume pure file
	mov	bh,[bp.INFO]
	test	bh,4
	retz					; Know pure file, no path seps
	mov	[bp.ISDIR],2			; assume d:/file
	mov	si,[bp.TTAIL]
	cmp	byte ptr [si],0
	jz	BADCDERRJ2			; Trailing '/'
	mov	bl,dot_chr
	cmp	byte ptr [si],bl
	jz	BADCDERRJ2			; If . or .. pure cd should have worked
	mov	bl,':'
	cmp	byte ptr [si-2],bl
	jz	DOPCD				; Know d:/file
	mov	[bp.ISDIR],1			; Know path/file
	dec	si				; Point at last '/'

DOPCD:
	xor	bl,bl
	xchg	bl,[SI] 			; Stick in a NUL
	invoke	SETREST1
	CMP	DX,SI				;AN000;  3/3/KK
	JAE	LookBack			;AN000;  3/3/KK
	PUSH	SI				;AN000;  3/3/KK
	PUSH	CX				;AN000;  3/3/KK
	MOV	CX,SI				;AN000;  3/3/KK
	MOV	SI,DX				;AN000;  3/3/KK

Kloop2: 					;AN000;  3/3/KK
	LODSB					;AN000;  3/3/KK
	invoke	TestKanj			;AN000;  3/3/KK
	jz	NotKanj4			;AN000;  3/3/KK
	LODSB					;AN000;  3/3/KK
	CMP	SI,CX				;AN000;  3/3/KK
	JB	Kloop2				;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	POP	SI				;AN000;  3/3/KK
	JMP	SHORT DoCdr			;AN000;  3/3/KK  Last char is ECS code, don't check for
						;		 trailing path sep
NotKanj4:					;AN000;  3/3/KK
	CMP	SI,CX				;AN000;  3/3/KK
	JB	Kloop2				;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	POP	SI				;AN000;  3/3/KK

LookBack:					;AN000;  3/3/KK
	CMP	BL,[SI-1]			; if double slash, then complain.
	JZ	BadCDErrJ2

DoCdr:						;AN000;  3/3/KK
	mov	ah,CHDIR
	INT	21h
	xchg	bl,[SI]
	retnc
	invoke	get_ext_error_number		;AN022; get the extended error

EXTEND_SETUPJ:					;AN022;
	JMP	EXTEND_SETUP			;AN022; go issue the error message

BADCDERRJ2:
	jmp	badpath_err			;AC022; go issue path not found message

SETSTARS:
	mov	[bp.TTAIL],DI
	add	[bp.SIZ],12
	mov	ax,dot_qmark
	mov	cx,8
	rep	stosb
	xchg	al,ah
	stosb
	xchg	al,ah
	mov	cl,3
	rep	stosb
	xor	al,al
	stosb
	return

PUBLIC CompName
COMPNAME:

	mov	si,offset trangroup:DESTBUF	;g do name translate of target
	mov	di,offset trangroup:TRGXNAME	;g save for name comparison
	mov	ah,xnametrans			;g
	int	21h			;g

	MOV	si,offset trangroup:SRCXNAME	;g get name translate of source
	MOV	di,offset trangroup:TRGXNAME	;g get name translate of target


	invoke	STRCOMP

	return

TRANCODE ENDS
	 END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\cparse.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)cparse.asm 1.1 85/05/14
;	SCCSID = @(#)cparse.asm 1.1 85/05/14
	INCLUDE comsw.asm

.xlist
.xcref
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm
.list
.cref


TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADCD_PTR:WORD		;AC022;
	EXTRN	BADCPMES_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	comma:byte
	EXTRN	cpyflag:byte
	EXTRN	CURDRV:BYTE
	EXTRN	ELCNT:BYTE
	EXTRN	ELPOS:BYTE
	EXTRN	EXPAND_STAR:BYTE
	EXTRN	SKPDEL:BYTE
	EXTRN	STARTEL:WORD
	EXTRN	SWITCHAR:BYTE
	EXTRN	switch_list:byte
	EXTRN	TPA:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

	EXTRN	CERROR:NEAR

	PUBLIC	BADCDERR		;AC022;
	PUBLIC	CPARSE

SWCOUNT EQU	6			; Must agree with length of switch_list

;-----------------------------------------------------------------------;
; ENTRY:								;
;	DS:SI	Points input buffer					;
;	ES:DI	Points to the token buffer				;
;	BL	Special delimiter for this call 			;
;		    Always checked last 				;
;		    set it to space if there is no special delimiter	;
; EXIT: 								;
;	DS:SI	Points to next char in the input buffer 		;
;	ES:DI	Points to the token buffer				;
;	[STARTEL] Points to start of last element of path in token	;
;		points to a NUL for no element strings 'd:' 'd:/'       ;
;	CX	Character count 					;
;	BH	Condition Code						;
;			Bit 1H of BH set if switch character		;
;				Token buffer contains char after	;
;				switch character			;
;				BP has switch bits set (ORing only)	;
;			Bit 2H of BH set if ? or * in token		;
;				if * found element ? filled		;
;			Bit 4H of BH set if path sep in token		;
;			Bit 80H of BH set if the special delimiter	;
;			   was skipped at the start of this token	;
;		Token buffer always starts d: for non switch tokens	;
;	CARRY SET							;
;	    if CR on input						;
;		token buffer not altered				;
;									;
;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
; MODIFIES:								;
;	CX, SI, AX, BH, DX and the Carry Flag				;	;
;									;
; -----------------------------------------------------------------------;
;---------------
; Modifications to cparse:  recognition of right and left parentheses
; as integral tokens, and removal of automatic upper-case conversion code.
;
; Both modifications were installed in the course of adding a coherent
; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
; structure for command-line arguments.  This parser relies on cparse to
; recognize individual tokens.
;
; To process for-loops correctly, parentheses must therefore be
; recognized as tokens.  The upper-case conversion code was removed so
; that commands (such as for and echo) would be able to use the "original"
; text of the command line.
;
; Note also the modification to prevent the automatic conversion of colons
; into spaces WITHIN THE SOURCE TEXT!
;
; Also note that BP is also clobbered if cparse recognizes any switches
; on the command line.
;
; Alan L, OS/MSDOS				    14 August 1983
;---------------

CPARSE:
ASSUME	DS:TRANGROUP,ES:TRANGROUP

	xor	ax,ax
	mov	[STARTEL],DI			; No path element (Is DI correct?)
	mov	[ELPOS],al			; Start in 8 char prefix
	mov	[SKPDEL],al			; No skip delimiter yet
	mov	bh,al				; Init nothing
	pushf					; save flags
	push	di				; save the token buffer addrss
	xor	cx,cx				; no chars in token buffer
	mov	comma,cl			;g reset comma flag
moredelim:
	LODSB
	INVOKE	DELIM
	JNZ	SCANCDONE
	CMP	AL,' '
	JZ	moredelim
	CMP	AL,9
	JZ	moredelim
	xchg	al,[SKPDEL]
	or	al,al
	jz	moredelim			; One non space/tab delimiter allowed
	test	bh,080h 			;g  has a special char been found?
	jz	no_comma			;g  no - just exit
	mov	comma,1 			;g  set comma flag
no_comma:
	JMP	x_done				; Nul argument

SCANCDONE:

;;;;	IFNDEF	DBCS	3/3/KK
;---------------
; Mod to avoid upper-case conversion.
;	cmp	cpyflag,1		3/3/KK
;	jnz	cpcont1 		3/3/KK
;	invoke	UPCONV			3/3/KK
cpcont1:
;---------------
;;;;	ENDIF			3/3/KK

	cmp	al,bl				; Special delimiter?
	jnz	nospec
	or	bh,80H
	jmp	short moredelim

nospec:
	cmp	al,0DH				; a CR?
	jne	ncperror
	jmp	cperror

ncperror:
	cmp	al,[SWITCHAR]			; is the char the switch char?
	jne	na_switch			; yes, process...
	jmp	a_switch

na_switch:
	mov	dl,':'
	cmp	byte ptr [si],dl
	jne	anum_chard			; Drive not specified

;;;;	IFDEF	DBCS		3/3/KK
;---------------
; Mod to avoid upper-case conversion.
	cmp	cpyflag,1
	jnz	cpcont2
	invoke	UPCONV
cpcont2:
;---------------
;;;;	ENDIF			3/3/KK

	call	move_char
	lodsb					; Get the ':'
	call	move_char
	mov	[STARTEL],di
	mov	[ELCNT],0
	jmp	anum_test

anum_chard:
	mov	[STARTEL],di
	mov	[ELCNT],0			; Store of this char sets it to one
	cmp	cpyflag,1			; Was CPARSE called from COPY?
	jnz	anum_char			; No, don't add drive spec.
	invoke	PATHCHRCMP			; Starts with a pathchar?
	jnz	anum_char			; no
	push	ax
	mov	al,[CURDRV]			; Insert drive spec
	add	al,capital_A
	call	move_char
	mov	al,':'
	call	move_char
	pop	ax
	mov	[STARTEL],di
	mov	[ELCNT],0

anum_char:

;;;;	IFDEF	DBCS		3/3/KK
	invoke	TESTKANJ
	jz	NOTKANJ 			;AC048;
ifdef NEC_98 
if BUGFIX

	cmp	byte ptr [si],' '
	jb	NOTKANJ
endif
endif   ;NEC_98
	call	move_char
	lodsb
	jmp	short notspecial

NOTKANJ:					;AN048; If not kanji
	cmp	cpyflag,1			;AN048; and if we're in COPY
	jnz	testdot 			;AN048;
	invoke	upconv				;AN048; upper case the char

TESTDOT:
;;;;	ENDIF			3/3/KK

	cmp	al,dot_chr
	jnz	testquest
	inc	[ELPOS] 			; flag in extension
	mov	[ELCNT],0FFH			; Store of the '.' resets it to 0

testquest:
	cmp	al,'?'
	jnz	testsplat
	or	bh,2

testsplat:
	cmp	al,star
	jnz	testpath
	or	bh,2
	cmp	byte ptr [expand_star],0
	jnz	expand_filename
	jmp	SHORT testpath

badperr2j:
	jmp	short badperr2

expand_filename:
	mov	ah,7
	cmp	[ELPOS],0
	jz	gotelcnt
	mov	ah,2

gotelcnt:
	mov	al,'?'
	sub	ah,[ELCNT]
	jc	badperr2j
	xchg	ah,cl
	jcxz	testpathx

qmove:
	xchg	ah,cl
	call	move_char
	xchg	ah,cl
	loop	qmove

testpathx:
	xchg	ah,cl

testpath:
	invoke	PATHCHRCMP
	jnz	notspecial
	or	bh,4
	cmp	byte ptr [expand_star],0
	jz	no_err_check
	test	bh,2				; If just hit a '/', cannot have ? or * yet
	jnz	badperr

no_err_check:
	mov	[STARTEL],di			; New element
	INC	[STARTEL]			; Point to char after /
	mov	[ELCNT],0FFH			; Store of '/' sets it to 0
	mov	[ELPOS],0

notspecial:
	call	move_char			; just an alphanum string
anum_test:

	lodsb

;;;;	IFNDEF	DBCS		3/3/KK
;---------------
; Mod to avoid upper-case conversion.
;	cmp	cpyflag,1		3/3/KK
;	jnz	cpcont3 		3/3/KK
;	invoke	UPCONV			3/3/KK
cpcont3:
;---------------
;;;;	ENDIF				3/3/KK

	INVOKE	DELIM
	je	x_done

	cmp	al,0DH
	je	x_done
	cmp	al,[SWITCHAR]
	je	x_done
	cmp	al,bl
	je	x_done
	cmp	al,':'                          ; ':' allowed as trailer because
						; of devices
;;;;	IFDEF	DBCS		3/3/KK
	je	FOO15
	jmp	anum_char
FOO15:
;;;	ELSE			3/3/KK
;;;	jne	anum_charj	3/3/KK
;;;	ENDIF			3/3/KK

;---------------
; Modification made for parseline.
; Why would it be necessary to change colons to spaces?  In this
; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
; but so does 'echo foo:bar' yield 'echo foo bar'.
;---------------
	cmp	cpyflag,2			; Is CPARSE parsing the 1st token from
						;  from PARSELINE?
	jnz	cpcont4 			; No, continue
	call	move_char			; Yes, save the ':' and go get another
	jmp	anum_test			;  character.

cpcont4:
	inc	si				;Skip the ':'
	jmp	short x_done

anum_charj:
	jmp	anum_char

badperr2:
	mov	dx,offset trangroup:BADCPMES_ptr
	jmp	CERROR

badperr:
BADCDERR:					;AC022; Issue "Invalid Directory"
	MOV	DX,OFFSET TRANGROUP:BADCD_ptr	;AC022;     message
	JMP	CERROR				;AC022;

cperror:
	dec	si				; adjust the pointer
	pop	di				; retrive token buffer address
	popf					; restore flags
	stc					; set the carry bit
	return

x_done:
	dec	si				; adjust for next round
;---------------
; Mod to recognize right and left parens as integral tokens.
x_done2:
;---------------
	jmp	short out_token

a_switch:
	OR	BH,1				; Indicate switch
	OR	BP,fSwitch
	INVOKE	SCANOFF
	INC	SI
	invoke	testkanj			;AN057; See if DBCS lead byte
	jz	a_switch_notkanj		;AN057; no - continue processing
ifdef NEC_98
if BUGFIX
	cmp	byte ptr [si],' '
	jb	a_switch_notkanj		;AN057; no - continue processing
endif
endif   ;NEC_98
	call	move_char			;AN057; DBCS - store first byte
	lodsb					;AN057; get second byte
	call	move_char			;AN057; store second byte
	or	bp,fBadSwitch			;AN057; DBCS switch is invalid
	jmp	short out_token 		;AN057; don't bother checking switch
a_switch_notkanj:				;AN057;
	cmp	al,0DH
	jne	Store_swt
	mov	al,0
	stosb					; null at the end
	OR	BP,fBadSwitch
	jmp	cperror 			; Trailing switch character error
						;   BP = fSwitch but no switch
						;   bit is set (unknown switch)
Store_swt:
	call	move_char			; store the character
;
;---------------
; This upconv call must stay.  It is used to identify copy-switches
; on the command line, and won't store anything into the output buffer.
	invoke	UPCONV
;---------------
;
	PUSH	ES
	PUSH	DI
	PUSH	CX
	PUSH	CS
	POP	ES
ASSUME	ES:TRANGROUP
	MOV	DI,OFFSET TRANGROUP:switch_list
	MOV	CX,SWCOUNT
	OR	BP,fBadSwitch
	REPNE	SCASB
	JNZ	out_tokenp
	AND	BP,NOT fBadSwitch
	MOV	AX,1
	SHL	AX,CL
	OR	BP,AX

out_tokenp:
	POP	CX
	POP	DI
	POP	ES

ASSUME	ES:NOTHING
out_token:
	mov	al,0
	stosb				; null at the end
	pop	di			; restore token buffer pointer
	popf
	clc				; clear carry flag
	return

move_char:
	stosb				; store char in token buffer
	inc	cx			; increment char count
	inc	[ELCNT] 		; increment element count for * substi
	return

TRANCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\copypr1.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.xlist
	.xcref

	include comsw.asm
	include dossym.inc
	include syscall.inc
	include sf.inc
	include comseg.asm
	include comequ.asm

	.list
	.cref


TRANDATA	segment public byte
	extrn	DevWMes_Ptr:word
	extrn	Extend_Buf_Sub:byte
	extrn	LostErr_Ptr:word
	extrn	NoSpace_Ptr:word
	extrn	Overwr_Ptr:word
TRANDATA	ends

TRANSPACE	segment public byte
	extrn	Ascii:byte
	extrn	Binary:byte
	extrn	CFlag:byte
	extrn	Concat:byte
	extrn	DestBuf:byte
	extrn	DestClosed:byte
	extrn	DestHand:word
	extrn	DestIsDev:byte
	extrn	DestSwitch:word
	extrn	Inexact:byte
	extrn	NoWrite:byte
	extrn	NxtAdd:word
	extrn	OCtrlZ:byte
	extrn	OFilePtr_Hi:word
	extrn	OFilePtr_Lo:word
	extrn	Plus_Comma:byte
	extrn	RdEof:byte
	extrn	SrcIsDev:byte
	extrn	String_Ptr_2:word
	extrn	TermRead:byte
	extrn	Tpa:word
	extrn	Written:word
TRANSPACE	ends

TRANCODE	segment public byte

	extrn	EndCopy:near

	public	FlshFil
	public	TryFlush

	assume	cs:TRANGROUP,ds:TRANGROUP,es:TRANGROUP,ss:NOTHING



;***	TryFlush - flush copy buffer, double-check for concatenation
;
;	EXIT	ZR set if concatenate flag unchanged

TryFlush:
	mov	al,Concat
	push	ax
	call	FlshFil
	pop	ax
	cmp	al,Concat
	return


;***	Flshfil - write out any data remaining in copy buffer.
;
;	Inputs:
;	  [NXTADD] = No. of bytes to write
;	  [CFLAG] <> 0 if file has been created
;	Outputs:
;	  [NXTADD] = 0

FlshFil:
	mov	TermRead,0
	cmp	CFlag,0
	je	NotExists
	jmp	Exists

NotExists:
	invoke	BuildDest		; find out all about the destination
	invoke	CompName		; source and dest. the same?
	jne	ProcDest		; if not, go ahead

	cmp	SrcIsDev,0
	jne	ProcDest		; same name on device ok

	cmp	Concat,0		; concatenation?
	mov	dx,offset TRANGROUP:Overwr_Ptr
	jne	No_Concat_Err		; concatenating

	jmp	CopErr			; not concatenating - overwrite error

No_Concat_Err:
	mov	NoWrite,1		; flag not writing (just seeking)

ProcDest:
	mov	ax,EXTOPEN shl 8		; open the file
	mov	si,offset TRANGROUP:DestBuf	; get file name
;M046
; For writes, we want to deny writes by anyone else at the same time that we
;are writing to it. For instance, on a network, 2 workstations could try
;writing to the same file. Also, because we opened the source file with
;DENY NONE, it is fine if the source and destination files are the same as
;would happen when we append to an existing file.
;
	mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
	xor	cx,cx				; no special files
	mov	dx,WRITE_OPEN_FLAG		; set up open flags

	cmp	NoWrite,0
	jne	DoDestOpen		; don't actually create if nowrite set
	mov	dx,CREAT_OPEN_FLAG	; set up create flags

DoDestOpen:
	int	21h

;	We assume that the error is normal.
;	TriageError will correct the DX value appropriately.

	jnc	Dest_Open_Okay			;AC030;

Xa_Set_Error:					;AN030; error occurred on XA
	invoke	Set_Ext_Error_Msg		;AN030; get extended error

Ext_Err_Set:					;AN030;
	mov	String_Ptr_2,offset TRANGROUP:DestBuf ;AN000; get address of failed string
	mov	Extend_Buf_Sub,ONE_SUBST	;AN030; put number of subst in control block


CopErrJ2:					;AN030;
	jmp	CopErr				;AN030; go issue message

Dest_Open_Okay: 				;AC030
	mov	DestHand,ax			; save handle
	mov	CFlag,1				; destination now exists
	mov	bx,ax
	mov	ax,(IOCTL shl 8)
	int	21h				; get device stuff
	mov	DestIsDev,dl			; set dest info
	test	dl,DEVID_ISDEV
	jz	Exists				;AC030; Dest not a device

;	Destination is device.

	mov	al,byte ptr DestSwitch
	and	al,SWITCHA+SWITCHB
	jnz	TestBoth
	mov	al,Ascii		; neither set, use current setting
	or	al,Binary
	jz	ExSetA			; neither set, default to ascii

TestBoth:
	jpe	Exists			; both are set, ignore
	test	al,SWITCHB
	jz	Exists			; leave in cooked mode
	mov	ax,(IOCTL shl 8) or 1
	xor	dh,dh
	or	dl,DEVID_RAW
	mov	DestIsDev,dl		; new value
	int	21h			; set device to raw mode
	jmp	short Exists

CopErrJ:
	jmp	CopErr


ExSetA:

;	What we read in may have been in binary mode, flag zapped write OK

	mov	Ascii,SWITCHA 		; set ascii mode
	or	Inexact,SWITCHA		; ascii -> inexact

Exists:
	cmp	NoWrite,0
	jne	NoChecking		; if nowrite don't bother with name check
	cmp	Plus_Comma,1		;g  don't check if just doing +,,
	je	NoChecking		;g
	invoke	CompName		; source and dest. the same?
	jne	NoChecking		; if not, go ahead
	cmp	SrcIsDev,0
	jne	NoChecking		; same name on device ok

;	At this point we know in append (would have gotten overwrite error
;	on first destination create otherwise), and user trying to specify
;	destination which has been scribbled already (if dest had been named
;	first, NoWrite would be set).

	mov	dx,offset TRANGROUP:LostErr_Ptr ; tell him he's not going to get it
	invoke	Std_EprintF			;ac022;
	mov	NxtAdd,0			; set return
	inc	TermRead			; tell read to give up

Ret60:
	return


NoChecking:
	mov	bx,DestHand		; get handle
	xor	cx,cx
	xchg	cx,NxtAdd
	jcxz	Ret60			; if nothing to write, forget it
	inc	Written			; flag that we wrote something
	cmp	NoWrite,0		; if nowrite set, just seek cx bytes
	jne	SeekEnd
	xor	dx,dx
	push	ds
	mov	ds,Tpa
	assume	ds:NOTHING
	mov	ah,WRITE
	int	21h
	pop	ds
	assume	ds:TRANGROUP
	mov	dx,offset TRANGROUP:NoSpace_Ptr
	jnc	@f
	jmp	Xa_Set_Error			;AC022; failure
@@:	sub	cx,ax
	retz					; wrote all supposed to
	test	DestIsDev,DEVID_ISDEV
	jz	CopErr				; is a file, error
	test	DestIsDev,DEVID_RAW
	jnz	DevWrtErr			; is a raw device, error
	cmp	Inexact,0
	retnz					; inexact so ok
	dec	cx
	retz					; wrote one byte less (the ^z)


DevWrtErr:
	mov	dx,offset TRANGROUP:DevWMes_Ptr
	jmp	short CopErr




SeekEnd:
	xor	dx,dx			; zero high half of offset
	xchg	dx,cx			; cx:dx is seek location
	mov	ax,(LSEEK shl 8) or 1
	int	21h			; seek ahead in the file

;	Save the file pointer in DX:AX to restore the file
;	with in case the copy should fail.

	mov	OFilePtr_Lo,ax
	mov	OFilePtr_Hi,dx

	cmp	RdEof,0
	retz				; EOF not read yet

;	^Z has been read - we must set the file size to the current
;	file pointer location

	mov	ah,WRITE
	int	21h			; cx is zero, truncates file
	jc	Xa_Set_Error_Jmp	;AC022; failure

;	Make note that ^Z was removed, in case the
;	copy should fail and we need to restore the file.

	mov	OCtrlZ,1Ah

	return




	public	CopErr
CopErr:
	invoke	Std_EPrintF		;AC022;

CopErrP:
	inc	DestClosed
	cmp	CFlag,0
	je	EndCopyJ		; never actually got it open
	mov	bx,DestHand
	cmp	bx,0
	jle	NoClose

;	Check to see if we should save part of the destination file.

	mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
	mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr

	mov	ax,cx
	or	ax,dx
	jz	ceClose			; null file ptr means nothing to save

;	Destination was also the first source.  Do the best we can to
;	restore it.  Truncate it back to the size we took from it (which
;	may have been due to a Ctrl-Z, so may not have included the whole
;	file).  If a Ctrl-Z was originally read, put it back.

	mov	ax,LSEEK shl 8
	int	21h

	xor	cx,cx			; CX = # bytes to write = 0
	mov	ah,WRITE
	int	21h			; truncate file

	cmp	OCtrlZ,0
	je	@f			; no ctrl-z removed from original
	inc	cx			; CX = # bytes to write = 1
	mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
	mov	ah,WRITE
	int	21h			; write ctrl-z
@@:
	mov	ah,CLOSE
	int	21h			; close it
;;	mov	CFlag,0
	jmp	EndCopy			; and go home

ceClose:
	mov	ah,CLOSE		; close the file
	int	21h

NoClose:
	mov	dx,offset TRANGROUP:DestBuf
	mov	ah,UNLINK
	int	21h			; and delete it
	mov	CFlag,0

EndCopyJ:
	jmp	EndCopy

Xa_Set_Error_Jmp:			;AN022; go set up error message
	jmp	Xa_Set_Error		;AN022;

TRANCODE	ends
	 	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\dir.asm ===
page	,132
	title	DIR Internal Command
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;***	DIR.ASM - DIR internal command

comment	% =================================================================

This module replaces TCMD1A.ASM.  The old module was titled 
"PART4 COMMAND Transient routines".

From residual documentation, I surmise that TCMD.ASM originally
contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
VER.  The file seems to have been successively split:

  TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B

TCMD1A.ASM contained only the DIR command.

Usage:
------

DIR <filespec> /w /p /b /s /l /o<sortorder> /a<attriblist>

DIR /?


<filespec> may include any or none of:  drive; directory path;
           wildcarded filename.  If drive or directory path are
	   omitted, the current defaults are used.  If the
	   file name or extension is omitted, wildcards are
	   assumed.

/w	Wide listing format.  Files are displayed in compressed
	'name.ext' format.  Subdirectory files are enclosed in
	brackets, '[dirname]'.

/p	Paged, or prompted listing.  A screenful is displayed
	at a time.  The name of the directory being listed appears
	at the top of each page.

	Bugbug:  pages nead to be uniform length..?

/b	Bare listing format.  Turns off /w or /p.  Files are 
	listed in compressed 'name.ext' format, one per line,
	without additional information.  Good for making batch
	files or for piping.  When used with /s, complete
	pathnames are listed.

/s	Descend subdirectory tree.  Performs command on current
	or specified directory, then for each subdirectory below
	that directory.  Directory header and footer is displayed
	for each directory where matching files are found, unless
	used with /b.  /b suppresses headers and footers.

	Tree is explored depth first, alphabetically within the
	same level.

	Bugbug:  hidden directories aren't searched.

/l	Display file names, extensions and paths in lowercase.	;M010

/o	Sort order.  /o alone sorts by default order (dirs-first, name,
	extension).  A sort order may be specified after /o.  Any of
	the following characters may be used: nedsg (name, extension,
	date/time, size, group-dirs-first).  Placing a '-' before any
	letter causes a downward sort on that field.  E.g., /oe-d
	means sort first by extension in alphabetical order, then
	within each extension sort by date and time in reverse chronological
	order.

/a	Attribute selection.  Without /a, hidden and system files
	are suppressed from the listing.  With /a alone, all files
	are listed.  An attribute list may follow /a, consisting of
	any of the following characters:  hsdar (hidden, system,
	directory, archive, read-only).  A '-' before any letter
	means 'not' that attribute.  E.g., /ar-d means files that
	are marked read-only and are not directory files.  Note
	that hidden or system files may be included in the listing.
	They are suppressed without /a but are treated like any other
	attribute with /a.

/?	Help listing.  Display DIR useage information.	;M008;Handled externally

/h has been removed.					;M008

DIRCMD	An environment variable named DIRCMD is parsed before the
	DIR command line.  Any command line options may be specified
	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
	A filespec may be specified in DIRCMD and will be used unless
	a filespec is specified on the command line.  Any switch
	specified in DIRCMD may be overridden on the command line.
	If the original DIR default action is desired for a particular
	switch, the switch letter may be preceded by a '-' on the
	command line.  E.g.,

	  /-w	use long listing format
	  /-p	don't page the listing
	  /-b	don't use bare format
	  /-s	don't descend subdirectory tree
	  /-o	display files in disk order
	  /-a	suppress hidden and system files


Notes:
------

For sorted listings, file entries are loaded into the TPA buffer, which
is usually about 64K in size.  This allows sorts of up to 3000 files at
a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
The byte after the last entry is 0FFh.  The first byte of each entry is
a flag byte which is made zero when the entry is loaded, and made one
when the entry is used.


Revision History
================
M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
				in the absence of ANSI.SYS

M007	sa	8/1/90		Allow /p/b combination

M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
				to internally handle /? message.

M010	sa	8/5/90		Add support for /l (lowercase) option.

M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
				first FCB with the drive number when the drive
				letter in the command line is preceded by a
				switch.  Now dir manually loads the drive
				number after parsing.

M018	md	8/12/90 	Increment the screen height by 1 when obtained
				from the ROM BIOS.

M023	sa	8/31/90		Prevent DIR from failing if it encounters
				a subdirectory having len(pathname)>MAXPATH.
				Just skip over that subdirectory.

M028	dbo	9/24/90		When country=US, sort by strict character
				byte value, rather than collating table.
				This to match MS-DOS Shell's sort order.

========================================================================= %




;***	SYMBOLS & MACROS

	.xlist
	.xcref

	include	comsw.asm	; get COMMAND version switches
	include dossym.inc	; get DOS basic symbol set
	include syscall.inc	; get DOS call names
	include doscntry.inc	; get extended country info symbols
	include bpb.inc
	include filemode.inc
	include find.inc
	include	comseg.asm	; define segment order
	include comequ.asm	; get equates for COMMAND routines
	include ioctl.inc	; get symbols for ioctl's
	include rombios.inc	; get ROM BIOS data definition

	.list
	.cref

				;M008;NUM_DIR_SWS reduced by 2 for /h,/? not used
				;M010;NUM_DIR_SWS increased by 2 for /l,/-l
NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list

				;M010;'lcase' replaces removed 'help' in OptionRec
OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1	
; 		on/off bit record for /l, /b, /s, /p, /w options
;		(order is hard-coded; see OnOffSw)
;		Inmem is set when entries are loaded in memory.

NUM_ATTR_LTRS	equ	6	; length of attribute letter list
NUM_ORDER_LTRS	equ	5	; length of sort order letter list

ResultBuffer	struc		; structure of parse result buffer
ValueType	db	?
ValueTag	db	?
SynPtr		dw	?
ValuePtr	dd	?
ResultBuffer	ends

ErrorRec	record	baddir:1,dev:1
;		Error bits are:
;		  Invalid directory format
;		  File is device

EntryStruc	struc			; our private directory entry structure
used		db	?		; =0 until entry used, then =1
filename	db	8 dup (?)	; filename
fileext		db	3 dup (?)	; extension
fileattr	db	?		; file attributes
filetime	dw	?		; file time
filedate	dw	?		; file date
filesize	dd	?		; file size
EntryStruc	ends

shove	macro	val		; hose-bag 8086 doesn't push immediate
	mov	ax,val		; invisible, dangerous use of AX!
	push	ax
	endm


	
	
;***	DATA

DATARES	segment public byte

	extrn	Append_Flag:byte	; true when APPEND needs to be reset
	extrn	Append_State:word	; state to reset APPEND to

DATARES	ends


TRANDATA segment public byte

	extrn	AttrLtrs:byte		; list of attribute letters
	extrn	BadCd_Ptr:word		; "invalid directory" msg block
	extrn	Bytes_Ptr:word		; "%1 bytes" msg block
	extrn	BytMes_Ptr:word		; "%1 bytes free" msg block
	extrn	DirCont_Ptr:word	; "(continuing %1)" msg block
	extrn	DirDat_Yr:word		; year field of date msg block
	extrn	DirDat_Mo_Day:word	; month/day field of date msg block
	extrn	DirDatTim_Ptr:word	; date/time msg block
	extrn	DirEnvVar:byte		; DIR environment variable name
	extrn	DirHead_Ptr:word	; directory header message block
	extrn	DirMes_Ptr:word		; "%1 File(s)" msg block
	extrn	DirTim_Hr_Min:word	; time field of msg block
	extrn	Dir_Sw_Ptrs:word	; list of DIR switch synonym ptrs
	extrn	Disp_File_Size_Ptr:word	; file size message block
	extrn	DMes_Ptr:word		; <DIR> message block
	extrn	ErrParsEnv_Ptr:word	; "(Error occurred in env.." msg blk
	extrn	Extend_Buf_Ptr:word	; extended error message block
	extrn	Extend_Buf_Sub:byte	; # substitions in message block
	extrn	Msg_Disp_Class:byte	; message display class
	extrn	OrderLtrs:byte		; list of sort order letters
	extrn	Parse_Dir:byte		; DIR parse block
	extrn	String_Buf_Ptr:word	; message block ptr to string
	extrn	Tab_Ptr:word		; tab output block
	extrn	Total_Ptr:word		; "Total:" msg block

TRANDATA ends


TRANSPACE segment public byte

	extrn	AttrSelect:byte		; attribute select states -
	extrn	AttrSpecified:byte	; attribute mask -

;		Attribute conditions are recorded in two steps.  
;		AttrSpecified indicates which attributes are to be checked.
;		AttrSelect indicates which state the specified attributes
;		 must be in for a file to be included in the listing.
;		Attributes not indicated in AttrSpecified are ignored when
;		 deciding which files to include.

	extrn	Bits:word		; some option flags (see OptionRec)
	extrn	BwdBuf:byte		; 'build working dir string' buf
	extrn	BytCnt:word		; # bytes in TPA
	extrn	Bytes_Free:word		; #bytes free for BytMes_Ptr msg block
	extrn	CharBuf:byte		; character string buffer
	extrn	ComSw:word		; error bits (see ErrorRec)
	extrn	CountryPtrInfo:byte	; buffer for collating table ptr
	extrn	CountryPtrId:byte	; info ID for collating table ptr
	extrn	CountryPtr:dword	; collating table ptr
	extrn	CurDrv:byte		; current drive # (0-based)
	extrn	DestBuf:byte		; null-terminated sort codes -

;	Sort order is specified as a series of 0 to 5 sort code
;	bytes, followed by a zero byte.
;	Codes are 1=name, 2=extension, 3=date&time, 4=size, and
;	5=filetype (subdir or not).
;	Bit 7 of code is set for a downwards sort.

	extrn	DestIsDir:byte		; indicator of delim char's in path
	extrn	DestTail:word		; ptr to filename in pathname
	extrn	Dir_Num:word		; #files for DirMes_Ptr msg block
	extrn	DirBuf:byte		; DTA buffer for DOS calls
	extrn	DirFlag:byte		; signal to PathCrunch routine
	extrn	Display_Ioctl:word	; display info block for IOCTL call
	extrn	EndDestBuf:byte		; end of DestBuf (sort order codes)
	extrn	File_Size_High:word	; field for file size message block
	extrn	File_Size_Low:word	; field for file size message block
	extrn	FileCnt:word		; file count in a single directory
	extrn	FileCntTotal:dword	; file count in all directories
	extrn	FileSiz:dword		; file sizes in a single directory
	extrn	FileSizTotal:dword	; file sizes in all directories
	extrn	InternatVars:byte	; buffer for international info
	extrn	LeftOnLine:byte		; entries left on current display line
	extrn	LeftOnPage:word		; lines left on page
	extrn	LinPerPag:word		; lines/page entry in Display_Ioctl
	extrn	Msg_Numb:word		; extended error code
	extrn	OldCtrlCHandler:dword	; old int 23 vector
	extrn	Parse1_Syn:word		; ptr to matched synonym
	extrn	PathCnt:word		; length of pathname (see PathPos)
	extrn	PathPos:word		; ptr to pathname buffer (see SrcBuf)
	extrn	PerLine:byte		; # entries per line
	extrn	ResSeg:word		; RESGROUP seg addr
	extrn	ScanBuf:byte		; buffer for environment value and
					;  subdirectory names
	extrn	SrcBuf:byte		; pathname buffer
	extrn	String_Ptr_2:word	; message substitution string ptr
	extrn	Tpa:word		; TPA buffer seg addr

TRANSPACE ends




;***	PRINCIPAL ROUTINES

TRANCODE segment public byte

	extrn	CError:near	; COMMAND error recycle point

	public	Catalog		; our entry point

	break	<DIR (Catalog) principal routines>

	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP

;	Bugbug:	Each routine should start with it's own ASSUME.




;***	Catalog - DIR command main routine
;
;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
;		Cmd-line tail text is at 81h, terminated by 0Dh
;		CS, DS, ES, SS = TRANGROUP seg addr
;		Tpa = TPA buffer seg addr
;		BytCnt = # bytes in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	ERROR EXITS
;
;	  Errors are handled by setting up error message pointers
;	   for Std_EPrintf and jumping to CError.  Syntax errors in
;	   the environment variable, however, are handled by printing
;	   an error message and continuing.
;
;	EFFECTS
;
;	  Directory listing is displayed (on standard output).
;	  APPEND is disabled.  HeadFix routine is expected to
;	   restore APPEND state.
;	  Working directory may be changed.  The user's default
;	   directory is saved and flagged for restoration by RestUDir
;	   during COMMAND cycle.
;	  Lots of variables may be changed in TRANSPACE segment.
;
;	NOTES
;
;	  ES = TRANGROUP seg addr except when used to address the
;	   the TPA buffer, where directory entries are loaded from disk.

Catalog	proc

	call	SetDefaults
	call	ParseEnvironment
	call	ParseCmdLine
	jnc	@F		; no parse error
	jmp	catErr		; error msg is set up
@@:	call	SetOptions
	call	SetCollatingTable

;	Drive # to operate on has already been placed in FCB by
;	COMMAND preprocessing.  OkVolArg & PathCrunch depend on that.

	test	Bits,mask bare
	jnz	@F		; don't display volume info for /b
	invoke	OkVolArg	; find & display volume info
	sub	LeftOnPage,2	; record display lines used by volume info
	jmp	short catCrunch

;	OkVolArg side effects:
;	APPEND is disabled;
;	DTA established at DirBuf;
;	Filename fields in FCB are wildcarded.

@@:
;	OkVolArg wasn't executed, so we have to do these ourselves.

	invoke	DisAppend	; disable APPEND

	mov	dx,offset TRANGROUP:DirBuf
	mov	ah,Set_DMA
	int	21h		; set DTA

	mov	di,FCB		; ES:DI = ptr to FCB
	inc	di		; ES:DI = ptr to filename field of FCB
	mov	al,'?'		; AL = wildcard character
	mov	cx,11
	rep	stosb		; wildcard filename field

catCrunch:
	call	CrunchPath	; crunch pathname to get directory and filename
	jc	catRecErr	; handle recorded or extended error

;	User's directory has been saved, we've changed to specified directory.
;	ComSw = error bits for later use
;	FCB contains parsed filename

	cmp	ComSw,0
	jne	catRecErr	; handle recorded error

	call	InstallCtrlC	; install control-C handler

	call	ZeroTotals	; zero grand totals
	call	ListDir		; list main directory
	jc	catExtErr

	test	Bits,mask subd
	jz	@F		; subdirectories option not set
	call	ListSubds	; list subdirectories
	jc	catExtErr
@@:
;	Check if any files were found.

	test	Bits,mask bare
	jnz	catRet		; don't bother for bare format

	mov	ax,word ptr FileCntTotal
	or	ax,ax
	jz	catNoFiles	; no files found

	call	DisplayTotals	; display trailing grand totals
	jmp	short catRet	; all done

catRecErr:

;	ComSw may have error bit set.  If not, do extended error.

	test	ComSw,mask dev
	jnz	catNoFiles	; filename is device, respond 'file not found'

	test	ComSw,mask baddir
	jz	catExtErr	; no ComSw error bits, must be extended error
	mov	dx,offset TRANGROUP:BadCd_Ptr	; invalid directory
	jmp	short catErr

catNoFiles:

;	Display header and force 'file not found' message.

	call	DisplayHeader
	mov	ax,ERROR_FILE_NOT_FOUND
	mov	Msg_Disp_Class,EXT_MSG_CLASS
	mov	dx,offset TRANGROUP:Extend_Buf_ptr
	mov	Extend_Buf_ptr,ax
	jmp	short catErr

catExtErr:

;	DOS has returned an error status.  Get the extended error#, and
;	set up an error message, changing 'No more files' error 
;	to 'File not found' error.

	invoke	Set_Ext_Error_Msg
	cmp	Extend_Buf_Ptr,ERROR_NO_MORE_FILES
	jne	@F
	mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND
@@:

;	Error exit.  Error message information has been set up
;	for Std_EPrintf.

catErr:	jmp	CError		; go to COMMAND error recycle point

catRet:	ret

Catalog	endp




;***	SetDefaults - set default pathname, options
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,DI
;
;	EFFECTS
;	  SrcBuf = '*',EOL - default pathname
;	  PathPos = ptr to pathname
;	  PathCnt = length of pathname



SetDefaults	proc

	mov	di,offset TRANGROUP:SrcBuf	; DI = ptr to pathname buffer
	mov	PathPos,di			; PathPos = ptr to pathname
	mov	al,STAR
	stosb
	mov	al,END_OF_LINE_IN
	stosb				; SrcBuf = '*',0Dh
	mov	PathCnt,1		; PathCnt = pathname length

	xor	ax,ax			; AX = 0
	mov	ComSw,ax		; = no error
	mov	Bits,ax			; = options off
	mov	DestBuf,al		; = no sort
	mov	AttrSpecified,ATTR_HIDDEN+ATTR_SYSTEM
	mov	AttrSelect,al		; exclude hidden, system files

	ret

SetDefaults	endp




;***	ParseEnvironment - find and parse our environment variable
;
;	Find our environment variable and parse it.  If a parse
;	error occurs, issue an error message.  The parse results
;	up to the error will still have effect.  Always leave
;	the option variables in a useable state.
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If a parse error occurred, an error message will be issued.

ParseEnvironment	proc

	call	GetEnvValue		; get environment variable value
	jc	peRet			; name not found in environment

;	SI = ptr to value of environment variable, in TRANGROUP seg

	call	ParseLine		; parse environment value
	cmp	ax,END_OF_LINE
	je	peRet			; successful completion

;	Some kind of parse error occurred.
;	We're set up for a Std_EPrintf call.

	invoke	Std_EPrintf			; display the parse error
	mov	Msg_Disp_Class,UTIL_MSG_CLASS	; restore default msg class

	mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
	invoke	Printf_Crlf		; "(Error occurred in environment.."

					;M008;Internal handling of /? removed
;peOk:	and	Bits,not mask help	; disallow /h in environment variable

peRet:	ret

ParseEnvironment	endp




;***	ParseCmdLine - parse and record command line parameters
;
;	ENTRY	PSP offset 81h is beginning of cmd line buffer
;		DS, ES, CS = TRANGROUP seg addr
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = system parser error code
;		DX = ptr to message block
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseCmdLine	proc

	mov	si,81h			; SI = ptr to cmd-line tail text
	call	ParseLine		; parse cmd line tail
	cmp	AX,END_OF_LINE
	je	pcOk			; parse completed successfully

;	A parse error occurred.  We're all set up for message output.

	stc		   		; return failure
	jmp	short pcRet

pcOk:	clc				; return success

pcRet:	ret

ParseCmdLine	endp




;***	SetCollatingTable - set up character collating table for sorting
;
;	If country is other than USA, try to get a collating table
;	for character sorting.  For USA, use straight byte values.
;	This is so DIR behaves like the MS-DOS Shell, which sorts
;	by straight byte values in the USA for better performance.
;
;	ENTRY	ES = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  If collating table is set -
;	    CountryPtrId = 6.
;	    CountryPtr points to collating table.
;
;	  Otherwise -
;	    CountryPtrId = 0.

SetCollatingTable	proc

;	Begin modification M028

	mov	dx,offset TRANGROUP:InternatVars
				; DS:DX = ptr to international info buffer
	mov	ax,INTERNATIONAL shl 8
				; AX = 'Get current country info'
	int	21h		; call DOS
	jc	scNoTable	; error - so don't collate

;	BX = country code

	cmp	bx,1
	je	scNoTable	; we're in USA, don't collate

;	End modification M028

;*	Country code is other than USA.  Try to get a collating table.

	mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
				; AH = 'Get Extended Country Info'
				; AL = 'Get Pointer to Collating Table'
	mov	bx,-1		; BX = code page of interest = CON
	mov	cx,5		; CX = length of info buffer
	mov	dx,bx		; DX = country ID = default
	mov	di,offset TRANGROUP:CountryPtrInfo
				; ES:DI = ptr to info buffer
	int	21h		; call DOS
	jnc	scRet		; success

;*	Set CountryPtrId = 0 to signal no collating table.

scNoTable:			;M028
	mov	CountryPtrId,0

scRet:	ret

SetCollatingTable	endp




;***	SetOptions - check and set options
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX
;
;	EFFECTS
;
;	  Bits may contain modified option settings.
;	  Display_Ioctl table, including LinPerPag variable, is filled in.
;	  LeftOnPage is initialized to # lines till end of page is handled.
;	  PerLine is set according to /w presence.

SetOptions	proc

;	If bare listing requested, cancel wide listings.

	test	Bits,mask bare
	jz	@F
	and	Bits,not mask wide		;M007;Allow /p with /b

@@:

;	Set # lines per display page.

;M01  Obtain screen height from ROM BIOS data area
;
;M01	mov	LinPerPag,LINESPERPAGE			; default value

ifndef JAPAN
	push	ds
	MOV	AX,ROMBIOS_DATA 	; Get ROM Data segment
	MOV	DS,AX			;
	Assume	DS:ROMBIOS_DATA

	MOV	al,CRT_Rows		; Get max rows
	pop	ds			;
	Assume	DS:Trangroup

	or	al,al			; If zero specified
	jnz	@F			;
endif
	MOV	al,LINESPERPAGE 	; assume 24 rows

@@:
	xor	ah,ah
ifndef JAPAN
	inc	al			; height + 1 ;M018
endif
	mov	LinPerPag,ax		; set the rows now

; Now the console driver can change the rows if it knows better (M01 end)

	mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE	; IOCTL for handles
	mov	bx,STDOUT				; handle #
	mov	ch,IOC_SC				; screen
	mov	cl,GET_GENERIC				; get display info
	mov	dx,offset TRANGROUP:Display_Ioctl	; info block
	int	21h					; call DOS

	mov	ax,LinPerPag		; AX = # lines per page
	mov	LeftOnPage,ax		; initialize # lines left on page

;	Set # entries per line.

	mov	PerLine,NORMPERLIN	; # entries per line without /w
	test	Bits,mask wide
	jz	@F
	mov	PerLine,WIDEPERLIN	; # entries per line with /w
@@:
				;M011;start;The following code checks if a drive
				;letter has been parsed into SrcBuf, and if
				;so, the correct drive number is loaded into
				;the first FCB, at offset 5C.

	cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
	jne	soRet
	mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
	and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
	sub	al,'@'				; convert to 1-based number (1=A)
	mov	ds:FCB,al 			; store in first FCB
						;M011;end
soRet:	ret

SetOptions	endp




;***	CrunchPath - analyze supplied or default pathname
;
;	ENTRY	PathPos = ptr to pathname buffer
;		PathCnt = length of pathname, not incl trailing delimiter
;		Pathname in buffer must end in delimiter (like CR) and
;		 must have space for another char after the delimiter.
;
;	EXIT	CY = clear if no error
;		We are changed to directory found in pathname
;		Previous directory ready to be restored via RestUDir
;		FCB filename fields contain filename (possibly w/ wildcards)
;
;		If error occurred,
;		CY = set
;		ComSw = error bits (see ErrorRec)
;		If ComSw not set,
;		Ready for DOS Get Extended Error call


CrunchPath	proc

	call	FileIsDevice
	jne	@F		; not a device, skip ahead
	or	ComSw,mask dev	; signal file is device
	jmp	short cpErr	; return error
@@:
	push	PathPos		; save ptr to pathname
	mov	DirFlag,-1	; tell PathCrunch not to parse file into FCB
	invoke	PathCrunch	; change to directory in pathname
	mov	DirFlag,0	; reset our little flag
	pop	si		; SI = ptr to pathname
	jc	cpNoDir		; didn't find directory path
	jz	cpRet		; found directory path w/ no filename
				;  - leave wildcard default in FCB and return

;*	We found a directory, and there was a filename attached.
;	DestTail = ptr to ASCIIZ filename

	mov	si,DestTail	; SI = ptr to filename
	jmp	short cpFile	; go parse the file into FCB

;*	PathCrunch failed to find a directory in the pathname.
;
;	Msg_Numb = error code
;	DestIsDir = nonzero if path delimiter char's occur in pathname
;	SI = ptr to pathname (now an ASCIIZ string)

cpNoDir:
	mov	ax,Msg_Numb	  ; AX = error code from PathCrunch
	or	ax,ax
	jnz	cpErr		  ; error occurred - return it
	cmp	DestIsDir,0
	je	cpMaybe		  ; no path delimiters seen, maybe it's a file
	or	ComSw,mask baddir ; signal invalid directory name
	jmp	short cpErr	  ; return error

cpMaybe:

;	SI = ptr to pathname

	cmp	byte ptr [si+1],COLON_CHAR
	jnz	@F		  ; no drive specifier, skip ahead
	lodsw			  ; SI = ptr past drive specifier "d:"
@@:	cmp	[si],".."
	jne	cpFile		  ; if not "..", treat as a file
	cmp	byte ptr [si+2],0
	jne	cpFile		  ; or if there's more after "..", treat as file
	or	ComSw,mask baddir ; signal invalid directory
	jmp	short cpErr	  ; return error

;	The preceding code was taken from the old DIR routine.
;	It's garbage, I'm afraid.  It's meant to check for ".."
;	occurring when we're at the root directory.  Too bad it
;	doesn't handle problems with "..\..", etc.


;	We're ready to parse a filename into the FCB.
;	SI = ptr to ASCIIZ filename

cpFile:	mov	di,FCB		; DI = ptr to FCB
	mov	ax,(PARSE_FILE_DESCRIPTOR shl 8) or 0Eh
				; wildcards already in FCB used as defaults
	int	21h
	clc			; return success
	jmp	short cpRet

cpErr:	stc			; return error

cpRet:	ret

CrunchPath	endp




;***	InstallCtrlC - install our private control-C handler
;
;	Put our control-c handler in front of command.com's default
;	handler, to make sure the user's default directory gets restored.
;	This shouldn't be necessary, but, for now, there are situations
;	where the TDATA segment is left in a modified state when a
;	control-c occurs.  This means that the transient will be
;	reloaded, and the user's directory cannot be restored.
;
;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  CtrlCHandler address placed in int 23 vector.
;
;	NOTE
;
;	  Command.com's basic control-c handler will be restored
;	  to the int 23 vector by the HeadFix routine, after DIR finishes.

InstallCtrlC	proc

	push	es				 ; preserve ES
	mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	mov	word ptr OldCtrlCHandler,bx	 ; save old int 23 vector
	mov	word ptr OldCtrlCHandler+2,es	 
	pop	es				 ; restore ES

	mov	dx,offset TRANGROUP:CtrlCHandler ; DS:DX = ptr to CtrlCHandler
	mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	ret

InstallCtrlC	endp




;***	ListSubds - search and list files in subdirectories
;
;	ENTRY	Current directory (on selected drive) is top of subdir tree
;		FCB is still set up for file searches
;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;		FileSiz = total size of files found
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Subdirectories may be listed on standard output device.
;
;	NOTES
;
;	  ListSubds seeds the recursive entry point lsNode with a ptr
;	   to a buffer where we'll stack up subdirectory filenames.
;	   Each name is stored ASCIIZ.

ListSubds	proc

	invoke	SetRest1		; make sure user's dir gets restored

	mov	bx,offset TRANGROUP:ScanBuf   ; BX = ptr to child name buffer

lsNode:
	mov	byte ptr ds:[bx],0	; start with null child name
lsLoop:
	call	FindNextChild		; search for next subdirectory
	jc	lsErr			; search failed - examine error

	mov	dx,bx			; DX = ptr to child's name
	call	ChangeDir		; enter child directory

					; M023;start
	jnc	@F			; check for error
	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
	je	lsLoop			; yes, skip over this subdirectory
	jmp	SHORT lsRet		; no, other error: DIR must fail
					; M023;end

@@:	push	bx
	call	ListDir			; list the directory
	pop	bx

;	Note we're ignoring errors returned here.

	mov	di,bx			; DI = ptr to child's name
	mov	cx,13			; CX = max name length w/ null
	xor	al,al			; AL = zero byte to look for
	repne	scasb			; DI = ptr to next name pos'n in buf
	push	bx			; save ptr to child's name
	mov	bx,di			; BX = ptr to next name pos'n in buf
	call	lsNode			; recurse from new node
	pop	bx			; BX = ptr to child's name
	pushf				; save error condition
	
	shove	0
	shove	".."
	mov	dx,sp			; DX = ptr to "..",0 on stack
	call	ChangeDir		; return to parent directory
	pop	ax			; restore stack
	pop	ax

	popf				; restore error condition from child
	jc	lsRet			; return error

	jmp	lsLoop			; look for more children
lsErr:
	invoke	Get_Ext_Error_Number	; AX = extended error code
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	lsRet			; file not found, we're ok
	cmp	ax,ERROR_NO_MORE_FILES
	je	lsRet			; no more files, we're ok
	stc				; return other errors

lsRet:	ret

ListSubds	endp




	break	<DIR support routines>

;***	SUPPORT ROUTINES




;***	CheckChild - check potential subdirectory name for FindNextChild
;
;	ENTRY	DirBuf contains DOS Find-buffer with potential child
;		BX = ptr to last child's name
;		BP = ptr to temp child's name
;
;	EXIT	nothing
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename pointed to by BP may be changed.
;
;	NOTES
;
;	  Potential filename replaces temp filename if:
;	   it's a subdirectory file;
;	   it doesn't start with a '.';
;	   it's alphanumerically greater than last child's name;
;	   and it's alphanumerically less than temp name.

CheckChild	proc

	test	DirBuf.find_buf_attr,ATTR_DIRECTORY
	jz	ccRet		; not a subdirectory file- return

	cmp	DirBuf.find_buf_pname,'.'
	je	ccRet		; starts with a dot- return

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bx
	call	CmpAscz		; compare candidate to last child's name
	jna	ccRet		; it's not above it- return

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bp
	call	CmpAscz		; compare candidate to temp name
	jnb	ccRet		; it's not below it- return

;	New kid is alright.  Copy to temp.

	mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	mov	di,bp
	mov	cx,13
	rep	movsb

ccRet:	ret

CheckChild	endp




;***	CmpEntry - compare one directory entry to another in sort order
;
;	Compare one directory entry against another according to
;	the sort codes in DestBuf.  One or more comparisons
;	may be made of file name, extension, time/date, and
;	size.  Comparisons may be made for upward or downward
;	sort order.
;
;	ENTRY	ES:BX = ptr to entry to compare
;		ES:BP = ptr to entry to be compared against
;		DestBuf contains sort codes (see DestBuf)
;		DS = TRANGROUP seg addr
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry against BP entry.
;		 'Same, above, below' translate to 'same, after, before'.
;
;	USED:	AX,CX,DX,SI,DI

CmpEntry	proc

	mov	si,offset TRANGROUP:DestBuf	; (DS:SI) = ptr to sort codes
ceLoop:
	xor	ax,ax			; AX = 0
	mov	al,[si]			; AL = sort code
	or	al,al
	jz	ceDone			; sort code is zero, we're done
	inc	si			; DS:SI = ptr to next sort code
	push	si			; save ptr to next sort code
	dec	al
	sal	al,1			; AX = index into cmp call table
					; CY set for downward sort order
	mov	si,ax			; SI = index into cmp call table
	mov	ax,cs:FieldCmps[si]	; AX = addr of compare routine
	jc	ceDn			; downwards sort - go swap entries
	call	ax 			; do upwards sort
	jmp	short @F
ceDn:
	xchg	bx,bp		; swap entry ptrs for downward sort order
	call	ax		; do sort
	xchg	bx,bp		; swap ptrs back
@@:
	pop	si		; SI = ptr to next sort code
	je	ceLoop		; compare showed no difference, keep trying

ceDone:

;	Get here either from unequal compare or sort code = 0.
;	In the latter case, condition codes indicate equality,
;	which is correct.

	ret

FieldCmps	label	word	; call table of entry comparisons
		dw	CmpName
		dw	CmpExt
		dw	CmpTime
		dw	CmpSize
		dw	CmpType

CmpEntry	endp




;***	CmpName - compare file name of two entries
;***	CmpExt - compare extension of two entries
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX,CX,DX,SI,DI

CmpName	proc

	mov	si,bx		; ES:SI = ptr to BX entry
	mov	di,bp		; ES:DI = ptr to BP entry
	add	si,filename	; ES:SI = ptr to BX name
	add	di,filename	; ES:DI = ptr to BP name
	mov	cx,size filename; CX = length of name
	jmp	short CmpStr

CmpExt:	mov	si,bx		; ES:SI = ptr to BX entry
	mov	di,bp		; ES:DI = ptr to BP entry
	add	si,fileext	; ES:SI = ptr to BX extension
	add	di,fileext	; ES:DI = ptr to BP extension
	mov	cx,size fileext	; CX = length of extension field

;	Bugbug:	use symbol for subfunction code.

CmpStr:	cmp	CountryPtrId,6
	jne	cnNoCollTable	; no collating table available

;*	Compare strings using collating table.
;
;	ES:SI = ptr to 1st string
;	ES:DI = ptr to 2nd string
;	CX = length

	push	bp			; preserve BP
	push	bx			; preserve BX
	push	ds			; preserve DS
	lds	bx,CountryPtr		; DS:BX = ptr to collating table
	assume	ds:NOTHING
	mov	bp,ds:[bx]		; BP = size of collating table
	inc	bx
	inc	bx			; DS:BX = ptr to collating values
					; DS:[BX]-2 = size of table
	xor	ax,ax			; AX = 0 for starters

;	Bugbug:	Investigate removing collating table length checks.

cnNextChar:
	mov	al,es:[di]		; AL = AX = char from 2nd string
	inc	di			; ES:DI = ptr to next char 2nd string
	cmp	ax,bp			; compare to collating table length
	jae	@F			; char not in table
	xlat				
@@:					; AL = AX = collating value
	mov	dx,ax			; DX = collating value from 2nd string
	lods	byte ptr es:[si]	; AL = AX = char from 1st string
					; ES:SI = ptr to next char 1st string
	cmp	ax,bp			; compare to collating table length
	jae	@F			; char not in table
	xlat				
@@:					; AL = AX = collating value
	cmp	ax,dx			; compare collating values

ifdef DBCS				; DBCS tail byte must not use
					; collating table
	jnz	cnNot_Same
	mov	al,es:[di-1]		; get previous 2nd string character
	invoke	testkanj
	jz	cnDo_Next		; if it was not DBCS lead byte
	mov	al,es:[di]		; get tail byte from 2nd string
	cmp	es:[si],al		; compare with 1st strings tail byte
	jnz	cnNot_Same
	inc	si			; pass tail byte
	inc	di
	dec	cx
cnDo_Next:
	loop	cnNextChar
cnNot_Same:

else					; Not DBCS

	loope	cnNextChar		; until unequal or no more left
endif

	pop	ds			; restore DS
	assume	ds:TRANGROUP
	pop	bx			; restore BX
	pop	bp			; restore BP
	ret

;*	If no collating table is available, simply compare raw ASCII values.
;	Don't we wish we could just do this all the time?  Sigh.

cnNoCollTable:
	rep	cmps byte ptr es:[si],[di]
	ret

CmpName	endp




;***	CmpTime - compare entries by date/time
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI
;
;	NOTE	Filetime and filedate fields in our private entry
;		structure must be adjacent and in that order.

CmpTime	proc

	mov	si,bx
	mov	di,bp
	add	si,filedate + size filedate - 1
	add	di,filedate + size filedate - 1
	mov	cx,size filetime + size filedate
	std
	repe	cmps byte ptr es:[si],[di]
	cld
	ret

CmpTime	endp




;***	CmpSize - compare entries by size
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI

CmpSize	proc

	mov	si,bx
	mov	di,bp
	add	si,filesize + size filesize - 1
	add	di,filesize + size filesize - 1
	mov	cx,size filesize
	std
	repe	cmps byte ptr es:[si],[di]
	cld
	ret

CmpSize	endp




;***	CmpType - compare entries by file type (subdirectory or not)
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX

CmpType	proc

	mov	al,es:[bx].fileattr
	mov	ah,es:[bp].fileattr
	and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
	cmp	ah,al
	ret

CmpType	endp





;***	DefaultAttr - set default attribute conditions
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.

DefaultAttr	proc

	mov	AttrSpecified,ATTR_HIDDEN+ATTR_SYSTEM	; specify H and S
	mov	AttrSelect,0				; H and S must be off
	clc						; return success
	ret

DefaultAttr	endp




;***	DisplayTotals - display grand total stats
;
;	If we searched subdirectories, display the total # files found
;	 and total size of files found.
;	Display disk space remaining.
;
;	ENTRY	FileCntTotal, FileSizTotal contain correct values
;		Bits contains setting of /s
;		FCB contains drive #
;
;	EXIT	nothing
;
;	USES	AX,DX
;		FileSiz

DisplayTotals	proc

	test	Bits,mask subd
	jz	dtFree			; no subdirectories- do bytes free

	invoke	Crlf2			; start on new line
	call	UseLine

	mov	dx,offset TRANGROUP:Total_Ptr
	invoke	Std_Printf			; "Total:",cr,lf
	call	UseLine

	mov	ax,word ptr FileCntTotal	; AX = # files found mod 64K
	mov	si,offset TRANGROUP:FileSizTotal
	mov	di,offset TRANGROUP:FileSiz
	movsw
	movsw				; move total size to size variable
	call	DisplayCntSiz		; display file count & size
dtFree:
	mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
	mov	dl,byte ptr ds:FCB	; DL = drive#
	int	21h			; call DOS
	cmp	ax,-1			; check 'invalid drive' return code
	jz	dtRet			; can't get drive space - return
	mul	cx
	mul	bx
	mov	Bytes_Free,ax
	mov	Bytes_Free+2,dx
	mov	dx,offset TRANGROUP:BytMes_Ptr
	invoke	Std_Printf		; "nnn bytes free",cr,lf
	call	UseLine

dtRet:	ret

DisplayTotals	endp




;***	FileIsDevice - see if file looks like a device
;
;	ENTRY	PathPos = ptr to pathname
;		PathCnt = length of pathname w/o terminating char
;		DirBuf is DOS DTA
;
;	EXIT	ZR = set if file looks like a device
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  DTA buffer holds results of Find First function
;
;	NOTES
;
;	  We try to flag devices in two ways.  First, we try
;	  the DOS Find First function.  It returns attribute bit 6
;	  set on a successful find if it identifies a device name.
;	  Unfortunately, it returns 'path not found' for a device
;	  name terminated with colon, such as "CON:".  So, we look
;	  for any colon in the pathname after the 2nd character,
;	  and flag the pathname as a device if we find one.

FileIsDevice	proc

	mov	dx,PathPos	 ; DX = ptr to pathname

	mov	di,dx
	add	di,PathCnt	 ; DI = ptr to byte after pathname
	xor	bl,bl		 ; BL = NUL to terminate pathname with
	xchg	bl,byte ptr [di] ; BL = saved pathname terminating char

	xor	cx,cx		 ; CX = attribute mask (normal search)
	mov	ah,FIND_FIRST	 ; AH = DOS Find First function code
	int	21h	 	 ; call DOS
	xchg	bl,byte ptr [di] ; restore pathname terminating char
	jc	piCol		 ; didn't find a dir entry, check for colon

;	Found a dir entry, see if Find First thinks it's a device.

	test	byte ptr DirBuf.Find_Buf_Attr,ATTR_DEVICE
	jz	piCol		 ; device attribute not set, look for colon
	xor	cx,cx		 ; it's a device, return ZR flag
	jmp	short piRet

;	Device attribute not returned by Find First function.  But
;	let's check for a colon anywhere in the pathname after the
;	second byte.
;
;	DI = ptr to byte after pathname

piCol:	dec	di		 ; DI = ptr to last char in pathname
	mov	al,COLON_CHAR	 ; AL = colon char to search for
	mov	cx,PathCnt	 ; CX = # chars to scan
	dec	cx
	dec	cx		 ; ignore 1st two chars of pathname
	or	cx,cx
	js	piRet		 ; if < 2 chars in pathname, just return
	or	di,di		 ; clear ZR in case CX = 0
	std			 ; scan downward
	repne	scasb
	cld			 ; restore default upward direction

;	After scanning, the ZR flag is set to indicate presence of a colon.

piRet:	ret

FileIsDevice	endp




;***	FindFirst - find first directory entry to display
;***	FindNext - find next directory entry to display
;
;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
;		AttrSpecified, AttrSelect are set
;
;	EXIT	CY = clear if successful
;		BX = offset in TPA buffer of directory entry found
;
;		If unsuccessful,
;		CY = set
;		AX = DOS error code
;		DOS Get Extended Error call will get error code
;
;		NOTE:  if entries were loaded into TPA, AX contains
;		ERROR_NO_MORE_FILES when no more entries are available,
;		but DOS Get Extended Error call WON'T return the correct
;		error.  That's ok, because we'll see the value in AX
;		and recognize it as a non-error condition.
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Entries in memory may be marked as output.
;	  If not sorted, entry is loaded at TPA.
;
;	NOTES
;
;	  If we don't find a qualifying file, we return after the final
;	   DOS Find File call.  A DOS Get Extended Error call will then
;	   indicate an appropriate condition.

FindFirst	proc

	mov	ax,offset TRANGROUP:GetFirst
	jmp	short ffFindEntry

FindNext:
	mov	ax,offset TRANGROUP:GetNext

;	AX = address of correct disk get routine to use.

ffFindEntry:
	push	es			; save TRANGROUP seg addr
	test	Bits,mask inmem
	jz	ffDisk			; entries not in memory, search disk

;	Entries are loaded in memory to sort out.  Find the first one.
;	There will always be one, or LoadEntries would've failed.

	call	FindInMem		; find first entry in TPA
	jmp	short ffRet		; return what TPA search returns

;	Get entry from disk.

ffDisk:
	call	ax			; get entry from disk
	jc	ffGetErr		; get & return error
	mov	es,Tpa			; ES = seg addr of TPA
	xor	di,di			; ES:DI = ptr to TPA
	mov	bx,di			; BX = offset of entry in TPA
	call	LoadEntry		; load entry to TPA
	clc				; return success
	jmp	short ffRet

ffGetErr:
	invoke	Get_Ext_Error_Number	; AX = DOS error code
	stc

ffRet:	pop	es			; ES = TRANGROUP seg addr again
	ret

FindFirst	endp




;***	FindInMem - find next directory entry in TPA buffer
;
;	ENTRY	TPA is loaded (see LoadEntries)
;
;	EXIT	BX = offset in TPA of entry found
;
;		If no more files,
;		CY = set
;		AX = DOS 'no more files' error code
;
;	USED	AX,BX,CX,DX,SI,DI,BP,ES
;
;	EFFECTS
;
;	  Entry found is flagged as 'used' (see EntryStruc).

FindInMem	proc

	mov	es,Tpa		; ES = TPA seg addr
	xor	bx,bx		; ES:BX = ptr to 1st entry in TPA
	cld			; make sure default string direction is up
	
	call	FindOneInMem	; locate an entry
	jc	fiNoMore	; none left, set up 'no more files' error

;	BX = ptr to entry in TPA

fiBest:
	mov	bp,bx		; BP = ptr to best entry so far
fiNext:
	call	FindNextInMem	; locate next entry
	jc	fiFound		; no more, best entry so far wins

;	BX = ptr to next entry

	call	CmpEntry	; compare it to best found so far (BP)
	jnb	fiNext		; it's not better, go look at next one
	jmp	fiBest		; it's better, go mark it as best so far

fiNoMore:

;	No more entries available in TPA.  Set up 'no more files' error.

	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
	stc				; return error
	jmp	short fiRet

fiFound:
	mov	bx,bp			; BX = ptr to best entry found
	mov	byte ptr es:[bx],1	; mark entry 'used'
	clc				; return success
fiRet:	ret

FindInMem	endp




;***	FindNextChild - find next subdirectory in current directory
;
;	ENTRY	BX = ptr to last child found, ASCIIZ filename
;		DirBuf is established DTA
;
;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
;
;		If failure,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  DirBuf is used for find first/next calls.
;
;	NOTES
;
;	  We keep on checking files until DOS returns an error.  If
;	  the error is 'no more files' and the temp filename is not
;	  the initial high tag, copy the temp to the child's name spot
;	  and return success.  Otherwise, send the error back to caller.
;
;	  This routine depends on DS,ES,CS, & SS all being equal.

FindNextChild	proc

	sub	sp,12			; make temp filename buf on stack
	shove	00FFh			; temp filename = high tag
	mov	bp,sp			; BP = ptr to temp filename buf
	shove	"*"
	shove	".*"
	call	GetDriveLtr		; AX = "d:"
	push	ax
	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack

;	See that the stack is restored properly at the end of this proc.

	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,FIND_FIRST
	int	21h			; DOS- Find First matching file
	jc	fcRet			; return error

	call	CheckChild		; check child against last, temp

fcNext:	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,FIND_NEXT
	int	21h			; DOS- Find Next matching file
	jc	fcErr			; examine error

	call	CheckChild		; check child against last, temp
	jmp	fcNext			; go find another child

fcErr:
	invoke	Get_Ext_Error_Number	; AX = extended error code
	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
	jne	short fcNope		; some other error- return it

;	We ran out of files.  See if we qualified at least one.

	cmp	byte ptr [bp],0FFh
	je	fcNope			; temp filename is unused- no child

;	Move temp filename to child name position.

	mov	si,bp		; SI = ptr to temp filename
	mov	di,bx		; DI = ptr to child name pos'n
fcMove:	lodsb			; AL = next byte of filename
	stosb			; store byte
	or	al,al
	jz	fcRet		; byte was zero, return success (CY clear)
	jmp	fcMove		; go move another byte

fcNope:	stc			; return error
fcRet:	lahf
	add	sp,20		; restore stack
	sahf
	ret

FindNextChild	endp





;***	FindOneInMem - find the first available entry in TPA
;***	FindNextInMem - find the next available entry in TPA
;
;	ENTRY	ES = TPA seg addr
;		BX = ptr to entry in TPA
;
;	EXIT	BX = ptr to entry found
;		CY = set if no more entries available in TPA
;
;	USED	AL

FindOneInMem	proc

	mov	al,es:[bx]	; examine 'used' byte of starting entry
	cmp	al,1
	je	FindNextInMem	; entry has already been used
	cmp	al,0FFh
	je	foNoMore	; 0FFh, we're at the end of the list

;	BX = ptr to entry that hasn't been output yet.

	clc			; return success
	ret

FindNextInMem:
	add	bx,size EntryStruc	; BX = ptr to next entry
	jmp	FindOneInMem		; go look at it

foNoMore:
	stc				; ran out of entries, return failure
	ret

FindOneInMem	endp




;***	GetEnvValue - get value of our environment variable
;
;	ENTRY	DS, ES = TRANGROUP seg addr
;
;	EXIT	CY = set if environment variable not in environment
;
;		Otherwise:
;		SI = ptr to environment variable asciiz value in TRANGROUP
;
;	USED	AX,BX,CX,DX,DI
;		(We assume the (almost) worst, since we don't know about
;		Find_Name_In_Environment.)
;
;	EFFECTS
;
;	  ScanBuf is loaded with value text

GetEnvValue proc

	push	es				; save ES
	mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
	invoke	Find_Name_In_Environment
	jc	geRet				; name not found in environment

;	ES:DI = ptr to value of environment variable
;	We're assuming DS, CS, and SS are unchanged.

	push	ds
	push	es
	pop	ds
	pop	es

	assume	ds:nothing

;	DS = seg addr of environment variable value (in environment segment)
;	ES = TRANGROUP seg addr

	mov	si,di				; DS:SI = ptr to value string
	mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
@@:	lodsb
	or	al,al
	stosb
	loopnz	@B		; move the string, including trailing null

	push	es
	pop	ds		; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP

	mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
geRet:	pop	es				; restore ES
	ret

GetEnvValue endp




;***	GetFirst - get first directory entry from disk
;
;	ENTRY	DOS DTA established at DirBuf
;		FCB contains drive # and filename
;		Current directory (on selected drive) is the one to search
;		AttrSpecified & AttrSelect masks set
;
;	EXIT	CY = clear if success
;		DirBuf contains extended FCB for file found
;
;		If unsuccessful,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FCB-7 = 0FFh to mark extended FCB
;	  FCB-1 = attribute mask to find all files
;	  These fields should remain unmodified for GetNext calls.
;
;
;***	GetNext - get next directory entry from disk
;
;	ENTRY	As for GetFirst, plus
;		FCB-7 set up as extended FCB w/ find-all attribute byte
;
;	EXIT	As for GetFirst
;
;	USED	AX,DX

GetFirst	proc

	mov	byte ptr ds:FCB-7,0FFh	; signal extended FCB
	mov	byte ptr ds:FCB-1,ATTR_ALL
					; find any file
	mov	dx,FCB-7		; DX = ptr to extended FCB
	mov	ah,DIR_SEARCH_FIRST	; AH = DOS Find First function code
	int	21h			; call DOS
	shl	al,1			; CY = set if error
	jc	gfRet			; return error
	jmp	short gfFound		; go look at attr's

GetNext:
	mov	dx,FCB-7		; DX = ptr to extended FCB
	mov	ah,DIR_SEARCH_NEXT	; AH = DOS Find Next function code
	int	21h			; call DOS
	shl	al,1			; CY = set if error
	jc	gfRet			; return error

;*	Found an entry.  Check attributes.

gfFound:
	mov	al,[DirBuf+8].dir_attr	; AL = file attributes
	mov	ah,AttrSpecified	; AH = mask of pertinent attr's
	and	al,ah			; AL = pertinent attr's of file
	and	ah,AttrSelect		; AH = attr settings to match
	cmp	al,ah
	jne	GetNext			; attr's don't match, look for another

gfRet:	ret

GetFirst	endp




;***	ListDir - search for and list files in the current directory
;
;	List header, files, and trailer for current directory on selected
;	drive.  Header & trailer are listed if at least one file is found.
;	If no qualifying files are found, no display output occurs.
;
;	ENTRY	Current directory (on selected drive) is the one to be listed
;		FCB contains selected drive # and filename spec
;		Option bits, attribute masks, and sort codes set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;		FileSiz
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Files found are listed.  A directory header and trailer are
;	   displayed only if files are found.

ListDir	proc

	xor	ax,ax
	mov	FileCnt,ax		; zero file count
	mov	word ptr FileSiz,ax	; zero file size accumulator
	mov	word ptr FileSiz+2,ax

	cmp	DestBuf,0		; check for sort code
	je	@F			; no sort
	call	LoadEntries		; load entries for sorted listing
	jnc	@F			; no error - continue
	invoke	Get_Ext_Error_Number	; AX = DOS error code
	stc
	jmp	short ldErr		; return error
@@:
	call	FindFirst		; find first file
	jc	ldErr			; not found, return error

;	BX = offset in TPA buffer of entry found

	call	DisplayHeader		; if at least one file, display header
	call	DisplayFile		; display the file entry
ldNext:
	call	FindNext		; find another file
	jc	ldErr			; not found
	call	DisplayFile		; display entry
	jmp	ldNext			; go find another one

ldErr:
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	ldDone			; file not found, we're done
	cmp	ax,ERROR_NO_MORE_FILES
	je	ldDone			; no more files, we're done
	stc
	jmp	short ldRet

ldDone:
	cmp	FileCnt,0
	je	@F			; no files found, just return
	call	DisplayTrailer		; display trailing info
@@:	clc				; return success

ldRet:	ret

ListDir	endp




;***	LoadEntries - attempt to load entries from current directory
;
;	Load all qualifying directory entries from the current directory
;	into the TPA.  If an error is returned by FindFirst/FindNext calls
;	other than 'no more files', return to caller with carry flag set.
;	If we run out of buffer space, display a message that we haven't
;	enough memory to sort this directory, but return without error.
;	Other routines know whether or not entries have been loaded by
;	the 'inmem' flag bit, which we set here.
;
;	The TPA is usually 64K - 512 bytes long.  At 20 bytes per entry,
;	this allows sorting over 3000 entries in a directory.
;
;	ENTRY	Tpa = buffer seg addr
;		BytCnt = buffer length, in bytes
;		Current directory (on selected drive) is the one to load
;		FCB contains drive # and filespec
;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
;
;	EXIT	CY = set if error
;		If error, DOS Get Extended Error will get error info
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Inmem bit of Bits = set if load succeeded.
;	  Tpa buffer contains directory entries.
;	  Byte after last entry = 0FFh.

LoadEntries	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr
	xor	di,di			; ES:DI = destination ptr
	and	Bits,not mask inmem	; signal entries not loaded

	call	GetFirst		; look for first file
	jc	leRet			; return any error
	call	LoadEntry		; load entry into TPA

leNext:	call	GetNext			; get another file
	jc	leLoaded		; assume any error is no more files
	mov	ax,BytCnt		; AX = size of TPA
	sub	ax,di			; AX = bytes left in TPA
	cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
	jb	leOk			; not enough memory left, give up
	call	LoadEntry		; load entry into TPA
	jmp	leNext			; go get another file

leLoaded:
	mov	byte ptr es:[di],0FFh	; mark end of entry list
	or	Bits,mask inmem		; signal entries loaded in memory
leOk:	clc				; return no error

leRet:	pop	es			; ES = TRANGROUP seg addr again
	ret

LoadEntries	endp




;***	LoadEntry - load directory entry from DirBuf ext'd FCB
;
;	ENTRY	ES:DI = ptr to load point in TPA
;		DirBuf contains extended FCB of entry to load
;
;	EXIT	ES:DI = ptr to next byte available in TPA
;
;	USED	AX,CX,SI
;
;	NOTES
;
;	  I could've used symbolic offsets and sizes of fields from
;	   the dir_entry struc to do this, but this is time-critical,
;	   so I hard-wired the structure of the DOS 4.x returned FCB,
;	   as well as our private directory entry structure.
;
;	  We force a zero size for subdirectory files.  A zero size is
;	   ordinarily returned for subdirectories, but with Novell
;	   Netware 286 or 386 loaded, we can't depend on it.  Bug #1594.

LoadEntry	proc

	mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
	xor	al,al				; AL = 0
	stosb					; 'used' byte = false
	mov	cx,11
	rep	movsb				; transfer filename & extension
	lodsb					; AL = attrib byte
	stosb					; store attrib byte
	add	si,dir_time-dir_attr-1		; skip to time field
	movsw					; transfer time
	movsw					; transfer date
	inc	si				; skip alloc unit
	inc	si

	and	al,ATTR_DIRECTORY
	jnz	leSetDirSize			; force zero size for subdir

	movsw
	movsw					; transfer size
	ret

leSetDirSize:
	xor	ax,ax
	stosw
	stosw					; store zero size
	ret

LoadEntry	endp




;***	NoOrder - turn sorting off
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED	AX
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes.  See DestBuf description.

NoOrder	proc

	mov	DestBuf,0	; no sort
	clc			; no error
	ret

NoOrder	endp




;***	OnOffSw - record occurence of on/off option switch
;
;	ENTRY	DI = index into word list of switches
;
;	EXIT	CY clear
;
;	USED	AX,CX
;
;	EFFECTS
;
;	  Bits modified to indicate option state.

OnOffSw	proc

	mov	cx,di		; CX = index into word list of options
	shr	cx,1
	shr	cx,1		; CX = bit position of option
	mov	ax,1		
	shl	ax,cl		; AX = bit mask of option
	test	di,2		; check if it is a negated option
	jz	@F		; it's negated
	or	Bits,ax		; turn option on
	jmp	short ooRet

@@:	not	ax		; AX = complemented bit mask of option
	and	Bits,ax		; turn option off

ooRet:	clc			; always return success
	ret

OnOffSw	endp




;***	ParseAttr - parse and record /A option
;
;	ENTRY	BX = ptr to system parser result buffer for /A occurence
;
;	EXIT	CY = set if error occurs parsing attribute conditions
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
;	  If parse error occurs, attribute conditions parsed so far hold.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

ParseAttr	proc

	push	si			; save SI
	mov	AttrSpecified,0		; cancel all attribute conditions

;	Each /A invocation starts by assuming all files are to be listed.

	mov	si,word ptr [bx].ValuePtr ; SI = ptr to string after /A

paLoop:	mov	dx,1			; DX = 1 (for un-negated attribute)

	lodsb				; AL = next char in string
	or	al,al
	jz	paOk			; it's terminating null, we're done
	cmp	al,'-'
	jne	@F			; not '-', go look for letter
	dec	dx			; DX = 0 (for negated attribute)
	lodsb				; AL = next char
@@:	
	mov	di,offset TRANGROUP:AttrLtrs  ; DI = ptr to attrib letter list
	mov	cx,NUM_ATTR_LTRS	; CX = length of attrib letter list
	repne	scasb			; look for our letter in the list
	jne	paErr			; not found, return error

	not	cx
	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5

;	Note that we rely on AttrLtrs to be in the attribute bit order,
;	starting from bit 0.

;	Record this attribute bit in AttrSpecified.

	mov	al,1
	shl	al,cl			; AL = mask for our bit
	or	AttrSpecified,al	; set it in the 'specified' mask

;	Record the selected state for this attribute in AttrSelect.
;	DX = 0 or 1, the selected state for this attribute.

	not	al			; AL = mask for all other bits
	and	AttrSelect,al		; clear our bit
	shl	dl,cl			; DL = our bit state in position
	or	AttrSelect,dl		; set selected attr state
	jmp	paLoop			; go look at next char

;	The attribute letter string is invalid.

paErr:	
	call	SetupParamError		; set message up for Std_EPrintf
	stc		   		; return error
	jmp	short paRet

paOk:	clc				; return success		

paRet:	pop	si			; restore SI
	ret

ParseAttr	endp




;***	ParseLine - parse a line of text
;
;	Parse text until an EOL (CR or NUL) is found, or until a parse
;	error occurs.
;
;	ENTRY	DS:SI = ptr to text
;		CS, DS, ES = TRANGROUP seg addr
;
;	EXIT	AX = last return code from system parser
;		CX = # positional parameters (pathnames) found - 0 or 1
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		DX = ptr to message block
;
;	USED	BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseLine	proc

	mov	di,offset TRANGROUP:Parse_Dir	 ; ES:DI = ptr to parse block
	xor	cx,cx				 ; CX = # positionals found
plPars:
	invoke	Parse_With_Msg		; call parser
	cmp	ax,END_OF_LINE
	je	plRet			; EOL encountered, return
	cmp	ax,RESULT_NO_ERROR
	jne	plRet			; parse error occurred, return

;	Parse call succeeded.  We have a filespec or a switch.
;	DX = ptr to result buffer

	mov	bx,dx			; BX = ptr to parse result buffer
	cmp	byte ptr [bx],RESULT_FILESPEC
	je	plFil			; we have a filespec

	call	ParseSwitch		; else we have a switch
	jc	plRet			; error parsing switch, return
	jmp	plPars			; parse more

plFil:	call	CopyPathname		; copy pathname into our buffer
	jmp	plPars			; parse more

plRet:	ret

ParseLine	endp




;***	ParseOrder - parse and record /O option
;
;	ENTRY	BX = ptr to system parser result buffer for /O occurence
;
;	EXIT	CY = set if error occurs parsing order
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes.  See DestBuf description.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

ParseOrder	proc

	push	si				; save SI
	push	bx				; save ptr to result buffer

	mov	si,word ptr [bx].ValuePtr	; SI = ptr to order letters
	mov	bx,offset TRANGROUP:DestBuf	; BX = ptr to sort code buffer
	mov	al,[si]				; AL = 1st char of order string
	or	al,al
	jnz	poLtr			; not NUL, go parse letters

;	We have /O alone.  Set standard sort order.
;	Note hardwired dependency on character order in OrderLtrs.

	mov	byte ptr [bx],5		; sort 1st by group (subdirs 1st)
	inc	bx
	mov	byte ptr [bx],1		; then by name
	inc	bx
	mov	byte ptr [bx],2		; then by extension
	inc	bx
	jmp	short poOk		; return success

;	We have /O<something>.  Parse sort order letters.

poLtr:	xor	dl,dl			; DL = 0 (upward sort)
	lodsb				; AL = next sort order letter
	or	al,al
	jz	poOk			; NUL found, return success

	cmp	al,'-'
	jne	@F			; not '-', go look for letter
	mov	dl,80h			; DL = downward sort mask
	lodsb				; AL = next char
@@:
	mov	di,offset TRANGROUP:OrderLtrs  ; DI = ptr to list of letters
	mov	cx,NUM_ORDER_LTRS	; CX = length of list
	repne	scasb			; look for our letter in the list
	jne	poErr			; not found, return error

	neg	cx
	add	cx,NUM_ORDER_LTRS	; CL = sort order code, 1-5
	or	cl,dl			; CL = sort code with up/dn bit
	mov	[bx],cl			; store sort order code in buffer
	inc	bx			; BX = ptr to next spot in buffer
	cmp	bx,offset TRANGROUP:EndDestBuf
	jae	poErr			; too many letters

	jmp	poLtr			; go look at next char

;	The sort order string is invalid.  

poErr:	pop	bx			; BX = ptr to result buffer
	call	SetupParamError		; set message up for Std_EPrintf
	stc				; return failure
	jmp	short poRet

poOk:	mov	byte ptr [bx],0		; mark end of sort code list
	pop	bx			; BX = ptr to result buffer
	clc				; return success

poRet:	pop	si			; restore SI
	ret

ParseOrder	endp




;***	ParseSwitch - parse a switch
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a switch
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

ParseSwitch	proc

	push	cx			; save CX
	push	di			; save DI

	mov	ax,[bx].SynPtr		; AX = synonym ptr
	mov	di,offset TRANGROUP:Dir_Sw_Ptrs
					; ES:DI = ptr to list of synonym ptrs
	mov	cx,NUM_DIR_SWS		; CX = # of dir switches in list
	cld				; scan direction = upward
	repne	scasw			; locate synonym ptr in list
	sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2

;	DI = index into word list of synonym ptrs

	call	cs:SwHandlers[di]	; use same index into call table

	pop	di			; restore DI
	pop	cx			; restore CX

	ret

;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
;	Simple on/off switches must occur first in both lists, and must be
;	  in order of option bits in Bits, starting with bit 0.

SwHandlers	label	word
	dw	OnOffSw		; /-W
	dw	OnOffSw		; /W
	dw	OnOffSw		; /-P
	dw	OnOffSw		; /P
	dw	OnOffSw		; /-S
	dw	OnOffSw		; /S
	dw	OnOffSw		; /-B
	dw	OnOffSw		; /B
	dw	OnOffSw		; /-L	;M010
	dw	OnOffSw		; /L	;M010
	dw	NoOrder		; /-O
	dw	ParseOrder	; /O
	dw	DefaultAttr	; /-A
	dw	ParseAttr	; /A

ParseSwitch	endp



	break	<DIR utility routines>

;***	UTILITY ROUTINES




;***	ChangeDir - change directory on target drive
;
;	ENTRY	FCB contains drive #
;		DS:DX = ptr to ASCIIZ string w/o drive specifier
;
;	EXIT	Changed current directory on drive
;
;		If error,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  DirBuf is used to build "d:string".

ChangeDir	proc

	mov	di,offset TRANGROUP:DirBuf
	call	GetDriveLtr	; AX = "d:"
	stosw			; put drive specifier in buffer
	mov	si,dx		; SI = ptr to argument string
cdLoop:
	lodsb
	stosb			; move byte to buffer
	or	al,al
	jne	cdLoop		; continue until null transferred

	mov	dx,offset TRANGROUP:DirBuf	; DX = ptr to "d:string"
	mov	ah,CHDIR
	int	21h				; change directory
	ret					; return what CHDIR returns

ChangeDir	endp




;***	CmpAscz - compare two ASCIIZ strings alphanumerically
;
;	ENTRY	DS:SI = ptr to one ASCIIZ string
;		ES:DI = ptr to another ASCIIZ string
;
;	EXIT	flags set after REPE CMPSB
;
;	USED	AL,CX,SI,DI
;
;	NOTES
;
;	Maximum run of comparison is length of DS:SI string.
;	This ensures that two identical strings followed by
;	random characters will compare correctly.

CmpAscz	proc

	push	di

	mov	di,si
	xor	al,al
	mov	cx,0FFFFh
	repne	scasb
	not	cx

	pop	di
	repe	cmpsb
	ret

CmpAscz	endp




;***	CopyPathname - copy pathname to our buffer
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a filespec
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  SrcBuf may contain a new pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.

CopyPathname	proc

	push	si
	lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
	invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
	pop	si
	ret

CopyPathname	endp



;***	CountFile - update counters with current file
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.

CountFile	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr

	inc	FileCnt			; # files this directory
	inc	word ptr FileCntTotal	; # files total
	jnz	@F
	inc	word ptr FileCntTotal+2
@@:
	mov	ax,word ptr es:[bx].filesize	; AX = low word of file size
	mov	dx,word ptr es:[bx].filesize+2	; DX = high word of file size
	add	word ptr FileSiz,ax
	adc	word ptr FileSiz+2,dx		; size of this directory
	add	word ptr FileSizTotal,ax
	adc	word ptr FileSizTotal+2,dx	; total size of files listed

	pop	es			; ES = TRANGROUP seg addr again
	ret

CountFile	endp




;***	DisplayBare - display filename in bare format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format, followed by cr/lf.
;	  If /s is on, complete pathname is displayed.
;
;	NOTE
;
;	  Directory pseudofiles . and .. and suppressed in bare listing.

DisplayBare	proc

;	Suppress . and .. files from bare listing.

	mov	cx,ds			; CX = saved TRANGROUP seg addr
	mov	ds,Tpa			; DS:BX = ptr to file entry
	assume	ds:NOTHING
	cmp	ds:[bx].filename,'.'	; check 1st char of filename
	mov	ds,cx			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	je	dbRet			; it's . or .. - don't display

	test	Bits,mask subd
	jz	dbNameExt		; not /s - display filename only

	invoke	Build_Dir_String
	mov	di,offset TRANGROUP:BwdBuf	; ES:DI = ptr to dir string
   
	test	Bits,mask lcase		;M010;check for lowercase option
	jz	@F			;M010;lowercase not needed
	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
	call	LowercaseString		;M010;path string is in BwdBuf

@@:	xor	al,al			; AL = 0
	mov	cx,0FFFFh
	cld
	repne	scasb			; ES:DI = ptr to byte after null
	dec	di			; ES:DI = ptr to null byte

ifdef DBCS
	push	si
	push	di
	mov	si,offset TRANGROUP:BwdBuf
	dec	di
	call	CheckDBCSTailByte
	pop	di
	pop	si
	jz	dbTailByte		; if last char is double byte
endif

	cmp	byte ptr es:[di-1],'\'
	je	@F			; already terminated w/ '\'

ifdef DBCS
dbTailByte:
endif

	mov	ax,'\'			; AX = '\',0
	stosw				; add to dir string
@@:
	mov	String_Ptr_2,offset TRANGROUP:BwdBuf
	mov	dx,offset TRANGROUP:String_Buf_Ptr
	invoke	Std_Printf		; display device & directory path

dbNameExt:
	call	DisplayDotForm		; display name.ext
	invoke	CrLf2			; display cr/lf
	call	UseLine			;M007;Allow /p with /b
dbRet:	ret

DisplayBare	endp




;***	DisplayDotForm - display filename in compressed dot format
;
;	Display name.ext, with no cr/lf's.  Dot is displayed only
;	if the filename has a nonblank extension.
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format.
;
;	NOTE
;
;	  We allow for bogus filenames that have blanks embedded
;	  in the name or extension.

;	Bugbug:	might be a good performance gain if we buffered
;	up the output and used DOS function 9.

DisplayDotForm	proc

	push	ds			; save TRANGROUP seg addr
	push	es			; save ES
	mov	ax,cs:Tpa		; AX = TPA seg addr
	mov	ds,ax			; DS:BX = ptr to entry
	assume	ds:nothing
	mov	es,ax			; ES:BX = ptr to entry

	mov	di,bx			; ES:DI = ptr to entry
	add	di,filename + size filename - 1
					; ES:DI = ptr to last char in name field
	mov	cx,size filename	; CX = length of name field
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank

;	Assume file name has at least one character.

	inc	cx			; CX = # chars in name
	mov	dx,cx			; DX = # chars to be displayed

	mov	si,bx			; DS:SI = ptr to entry
	add	si,filename		; DS:SI = ptr to name

NextNameChar:
	cld
	lodsb				; AL = next char

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	invoke	Print_Char		; display lead byte
	dec	cx
	jz	ExtChar			; if this is end
	lodsb				; get tail byte
	jmp	short NameChar10	; display tail byte
@@:
endif

	test	Bits,mask lcase		;M010;check for lowercase option
	jz	@F			;M010;lowercase not required
	call	LowerCase		;M010;filename char is in AL

ifdef DBCS
NameChar10:
endif

@@:	invoke	Print_Char		; display it
	loop	NextNameChar

ifdef DBCS
ExtChar:
endif

;	Now do extension.

	mov	di,bx			; ES:DI = ptr to entry
	add	di,fileext + size fileext - 1
					; ES:DI = ptr to last char in ext field
	mov	cx,size fileext		; CX = length of ext field
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank
	je	ddDone			; no nonblank chars in ext

	inc	cx			; CX = # chars in ext
	add	dx,cx			; DX = total # chars to be displayed
	inc	dx			;      including dot

	mov	al,'.'
	invoke	Print_Char
	mov	si,bx			; DS:SI = ptr to entry
	add	si,fileext		; DS:SI = ptr to ext

NextExtChar:
	cld
	lodsb				; AL = next char

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	invoke	Print_Char		; display lead byte
	dec	cx
	jz	ddDone			; if this is end
	lodsb				; get tail byte
	jmp	short ExtChar10		; display tail byte
@@:
endif

	test	CS:Bits,mask lcase	;M010;check for lowercase option
	jz	@F			;M010;lowercase not required
	call	LowerCase		;M010;fileext char is in AL

ifdef DBCS
ExtChar10:
endif

@@:	invoke	Print_Char		; display it
	loop	NextExtChar

ddDone:	pop	es			; restore ES
	pop	ds			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	cld				; leave direction flag = up
	ret

DisplayDotForm	endp




;***	DisplayFile - display file entry, update counters
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Bits contains /w, /p settings
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  Entry is displayed.  
;	  If not /b,
;	    Cursor is left at end of entry on screen.
;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
;	  If /b,
;	    Cursor is left at beginning of next line.
;	    Cnt's and Siz's aren't updated.

DisplayFile	proc

	test	Bits,mask bare
	jz	dfNorm			; not /b - do normal display

	call	DisplayBare		; display file in bare format
	jmp	short dfRet

dfNorm:	call	DisplayNext		; pos'n cursor for next entry
	test	Bits,mask wide
	jz	dfFull			; full format
	call	DisplayWide		; wide format
	jmp	short dfCnt

dfFull:	call	DisplayName		; display filename & extension
	call	DisplayTheRest		; display size, date, time

dfCnt:	call	CountFile		; update file counters
dfRet:	ret

DisplayFile	endp




;***	DisplayHeader - display directory header of working directory
;
;	ENTRY	Current directory (on selected drive) is the one to display
;		LeftOnPage = # lines left on display page
;
;	EXIT	nothing
;
;	ERROR EXIT
;
;	  Build_Dir_String will exit through CError with "Invalid drive
;	   specification" if there's a problem obtaining the current 
;	   directory pathname.
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  BwdBuf (which is really the same buffer as DirBuf, which
;	   we are using for the DTA) contains the directory string.
;	  LeftOnPage is adjusted.

DisplayHeader	proc

	test	Bits,mask bare
	jnz	dhRet			; /b - don't display header

	test	Bits,mask subd
	jz	dhNorm			; not /s

;	For subdirectory listings, put a blank line before the header.

	invoke	Crlf2			; start with a blank line
	call	UseLine
	jmp	short dhCom
dhNorm:
	mov	al,BLANK		; if not /s, precede by a blank
	invoke	Print_Char		; print a leading blank
dhCom:
	invoke	Build_Dir_String
	mov	dx,offset TRANGROUP:DirHead_ptr
	invoke	Std_Printf		; print header & cr/lf
	call	UseLine
	invoke	Crlf2			; another cr/lf
	call	UseLine
dhRet:	ret

DisplayHeader	endp




;***	DisplayName - display file name & extension
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Filename & extension are displayed in spread format.
;	  Cursor is left at end of extension.

DisplayName	proc

	push	ds				; save TRANGROUP seg addr
	mov	ds,Tpa				; DS:BX = ptr to entry
	assume	ds:nothing
	mov	si,bx				; DS:SI = ptr to entry
	add	si,filename			; DS:SI = ptr to filename
	mov	di,offset TRANGROUP:CharBuf	; ES:DI = ptr to CharBuf

	mov	cx,8
	cld
	rep	movsb				; move filename to CharBuf
	mov	al,' '
	stosb					; add a blank
	mov	cx,3
	rep	movsb				; add extension
	xor	al,al
	stosb					; add a NULL

	pop	ds				; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP

	test	Bits,mask lcase			;M010;check for lowercase option
	jz	@F			        ;M010;lowercase not required
	mov	si,offset TRANGROUP:CharBuf	;M010;DS:SI --> ASCIIZ string
	call	LowercaseString			;M010;filename.ext string is in CharBuf

@@:	mov	String_Ptr_2,offset TRANGROUP:CharBuf
	mov	dx,offset TRANGROUP:String_Buf_Ptr
	invoke	Std_Printf			; print filename & extension
	ret

DisplayName	endp




;***	DisplayNext - move display cursor to next entry position
;
;	ENTRY	LeftOnLine = # entries can still be printed on this line
;		LeftOnPage = # lines can still be printed for this page
;		FileCnt = # files in this dir displayed before this one
;		Bits contains /w setting
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  LeftOnLine will be updated to reflect the entry about to be
;	   displayed.
;	  LeftOnPage may be updated.

DisplayNext	proc

	cmp	FileCnt,0
	je	dn1st			; 1st file in directory
	cmp	LeftOnLine,0
	jng	dnEol			; no more room on this line

;	We are in wide mode (LeftOnLine is always 0 otherwise) and
;	we still have room for more on this line.
;	Tab to next position.

	mov	dx,offset TRANGROUP:Tab_Ptr
	invoke	Std_Printf
	jmp	short dnDone

dnEol:	

;	Start this entry on a new line.

	invoke	Crlf2		; start on new line
	call	UseLine
dn1st:	mov	al,PerLine
	mov	LeftOnLine,al	; reset # entries left on line

dnDone:	dec	LeftOnLine	; reflect the entry about to be displayed
	ret

DisplayNext	endp




;***	DisplayTheRest - display file size/dir, date, time
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Display cursor is at end of file extension
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  File size, date, & time are displayed.

DisplayTheRest	proc

	push	es			; save TRANGROUP seg addr
	mov	es,Tpa			; ES = TPA seg addr
	mov	bp,bx			; BP = offset of entry in TPA
	test	es:[bp].fileattr,ATTR_DIRECTORY
	jz	drNonDir		; not a directory file

;	For a directory file, display <DIR> instead of size.

	mov	dx,offset TRANGROUP:DMes_Ptr
	invoke	Std_Printf
	jmp	short drCom		; skip to common fields

drNonDir:

;	For a non-directory file, display file size.

	mov	dx,word ptr es:[bp].filesize
	mov	File_Size_Low,dx
	mov	dx,word ptr es:[bp].filesize+2
	mov	File_Size_High,dx
	mov	dx,offset TRANGROUP:Disp_File_Size_Ptr
	invoke	Std_Printf

drCom:

;	For all files, display date & time.

	mov	ax,es:[bp].filedate	; AX = date word
	or	ax,ax			; test for null date (DOS 1.x)
	jz	drDone			; no date, skip date/time display
	mov	bx,ax			; BX = date word
	and	ax,1Fh			; AX = day of month
	mov	dl,al			; DL = day of month
	mov	ax,bx			; AX = date word
	mov	cl,5
	shr	ax,cl			; shift day out
	and	al,0Fh			; AL = month
	mov	dh,al			; DH = month
	mov	cl,bh
	shr	cl,1			; CL = year - 1980
	xor	ch,ch			; CX = year - 1980
	add	cx,80			; CX = 2-digit year
	cmp	cl,100
	jb	@F			; not year 2000 yet, skip ahead
	sub	cl,100			; adjust for 21st century
@@:	xchg	dh,dl			; DX = month/day
	mov	DirDat_Yr,cx		; move year to msg block
	mov	DirDat_Mo_Day,dx	; move month/day to msg block
	mov	cx,es:[bp].filetime	; CX = file time
	jcxz	drPrint			; no time field - go print
	shr	cx,1
	shr	cx,1
	shr	cx,1			; CH = hours
	shr	cl,1
	shr	cl,1			; CL = minutes
	xchg	ch,cl			; CX = hr/min
	mov	DirTim_Hr_Min,cx	; move time to msg block
drPrint:mov	dx,offset TRANGROUP:DirDatTim_Ptr
	invoke	Std_Printf		; print date & time

drDone:	pop	es			; ES = TRANGROUP seg addr again	
	mov	bx,bp			; BX = offset of entry in TPA again
	ret

DisplayTheRest	endp




;***	DisplayTrailer - display trailing lines for directory listing
;
;	ENTRY	LeftOnPage = # lines left on display page
;		FileCnt = # files listed
;		FileSiz = total size of files listed
;
;	EXIT	nothing
;
;	USED
;
;	EFFECTS
;
;	  Trailing info lines are displayed

DisplayTrailer	proc

	test	Bits,mask bare
	jnz	dtrRet				; /b - don't display trailer

	invoke	Crlf2				; start on new line
	call	UseLine
	mov	ax,FileCnt			; AX = # files found

DisplayCntSiz:

;	DisplayTotals uses this entry point.
;
;	AX = # files
;	FileSiz = dword total size of files

	mov	Dir_Num,ax			; load # files
	mov	dx,offset TRANGROUP:DirMes_Ptr	; DX = ptr to message block
	invoke	Std_Printf			; "nnn File(s)"

	mov	dx,offset TRANGROUP:Bytes_Ptr
	invoke	Std_Printf			; "nnn bytes",cr,lf
	call	UseLine

dtrRet:	ret

DisplayTrailer	endp




;***	DisplayWide - display filename in wide format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Name.ext is displayed.  Cursor left at end of field (padded
;	  with blanks).  Subdirectory files are displayed as [name.ext].

DisplayWide	proc

	push	ds				; save TRANGROUP seg addr
	mov	ds,Tpa				; DS:BX = ptr to entry
	assume	ds:nothing

	test	ds:[bx].fileattr,ATTR_DIRECTORY
	jz	@F				; not a subdirectory file
	mov	al,'['
	invoke	Print_Char			; prefix subdirectory

@@:	call	DisplayDotForm			; display name.ext

;	DX = # chars displayed in name.ext

	test	ds:[bx].fileattr,ATTR_DIRECTORY
	jz	@F				; not a subdirectory file
	mov	al,']'
	invoke	Print_Char			; postfix subdirectory
@@:
;	Pad field with blanks.

	mov	cx,size filename + size fileext + 1
						; CX = field size
	sub	cx,dx				; CX = # pad char's
	jcxz	dwDone
	mov	al,' '

@@:	invoke	Print_Char
	loop	@B

dwDone:	pop	ds			; DS = TRANGROUP seg addr again
	assume	ds:TRANGROUP
	ret

DisplayWide	endp




;***	EndPage - end the current display page
;
;	ENTRY	LeftOnPage = # lines left on display page
;		Current directory (on selected drive) is the one being listed
;		Bits contains /p setting
;
;	EXIT	LeftOnPage = # lines left for next page
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  Pause is invoked to display a message and wait for a keystroke.
;	  BwdBuf (same as DirBuf) used to build directory string.

EndPage	proc

	test	Bits,mask pagd
	jz	epNew			; paged display isn't enabled

	push	bx			; save BX
	push	cx			; save CX

	invoke	Pause			; "Press any key to continue..."

	invoke	Build_Dir_String
	mov	dx,offset TRANGROUP:DirCont_Ptr
	invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf

	pop	cx			; restore CX
	pop	bx			; restore BX

epNew:	mov	ax,LinPerPag		; AX = # lines per page
	dec	ax			; AX = # lines till next EndPage
	mov	LeftOnPage,ax		; LeftOnPage = countdown variable

	ret

EndPage	endp




;***	GetDriveLtr - get target drive letter
;
;	ENTRY	FCB contains drive #
;
;	EXIT	AX = "d:"
;
;	USED	nothing

GetDriveLtr	proc

	mov	al,ds:Fcb	; AL = target drive #
	or	al,al
	jnz	@F		; not current drive default, skip ahead
	mov	al,ds:CurDrv	; AL = current drive #
	inc	al		; AL = 1-based drive #
@@:	add	al,'A'-1	; AL = target drive letter
	mov	ah,':'		; AX = "d:"
	ret

GetDriveLtr	endp





;***	SetupParamError - set up for Std_EPrintf parameter parse error message
;
;	Do for our /O and /A string parsers what Parse_With_Msg does
;	for system parser calls.  Set up a message substitution block,
;	etc. for invalid value strings.  I copied the procedure from
;	Setup_Parse_Error_Msg.
;
;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
;		
;
;	EXIT	AX = system parser error return code for bad param format
;		DX = ptr to message description block for Std_EPrintf
;
;	USED	SI
;
;	EFFECTS
;
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

SetupParamError	proc

	mov	ax,9			; parse error #
	mov	Msg_Disp_Class,PARSE_MSG_CLASS
	mov	Extend_Buf_Ptr,ax
	mov	si,word ptr [bx].ValuePtr
	mov	String_Ptr_2,si
	mov	Extend_Buf_Sub,ONE_SUBST
	mov	dx,offset TRANGROUP:Extend_Buf_Ptr
	ret

SetupParamError	endp




;***	UseLine - use a display line, start a new page if none left
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags

UseLine	proc

	dec	LeftOnPage
ifndef NEC_98
	cmp	LeftOnPage,2
else    ;NEC_98
	cmp	LeftOnPage,1            ;NEC04 Canged Page Line (23 to 24)
endif   ;NEC_98
	ja	ulRet
	call	EndPage
ulRet:	ret

UseLine	endp




;***	ZeroTotals - zero grand total file count, size
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  FileCntTotal & FileSizTotal are zeroed.
;
;	NOTES
;
;	  FileCntTotal & FileSizTotal must be juxtaposed, in that order.

ZeroTotals	proc

	mov	di,offset TRANGROUP:FileCntTotal
	mov	cx,size FileCntTotal+size FileSizTotal
	xor	al,al
	rep	stosb
	ret	

ZeroTotals	endp




;***	CtrlCHandler - our own control-c handler
;
;	Make sure user's default directory gets restored.  See notes
;	at InstallCtrlCHandler.
;
;	ENTRY	control-c
;
;	EXIT	to OldCtrlCHandler
;
;	USED	DS,flags
;
;	EFFECTS
;
;	  Restore user's default directory.
;
;	NOTES
;
;	  This handler is only installed after calling PathCrunch,
;	  which sets UserDir1, so the restoration will work.
;
;	  The original control-c vector will be restored, whether
;	  or not this one is invoked, in the HeadFix routine.

CtrlCHandler	proc	far

;SR;
; Save all registers used: ds, dx, ax. I know ax is being used by the 
;CtrlC handler, am not sure about ds & dx. Save them to be safe
;
	push	ds
	push	cs
	pop	ds			; DS = TRANGROUP seg addr
	push	ax
	push	dx
	invoke	RestUDir		; restore user's default directory
	pop	dx
	pop	ax
	pop	ds
	jmp	cs:OldCtrlCHandler		; go to previous int 23 handler

CtrlCHandler	endp


;M010;start
;***	LowerCase - convert ASCII character in AL to lowercase
;
;	ENTRY	AL = character to be displayed
;
;	EXIT	AL is lowercase
;
;	USED	nothing

LowerCase	proc

	assume	ds:NOTHING,es:NOTHING

	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
	jb	lcRet
	cmp	al,'Z'
	ja	lcRet

	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase

lcRet:	ret

LowerCase	endp




;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
;
;	ENTRY	DS:SI points to start of ASCIIZ string
;		ES = DS
;
;	EXIT	nothing
;	
;	USED	AL,SI

LowercaseString	proc

	assume	ds:NOTHING,es:NOTHING

	push	di			; save di
	mov	di,si			; ES:DI --> ASCIIZ string
	cld

NextChar: 
	lodsb				; get character from string into al
	or	al,al			; are we at end of string?
	jz	EndOfString

ifdef DBCS
	invoke	testkanj
	jz	@f			; if this is not lead byte
	stosb				; store lead byte
	lodsb				; get tail byte
	or	al,al
	jz	EndOfString		; if end
	stosb				; store tail byte
	jmp	short NextChar
@@:
endif

	call	LowerCase		; convert character to lowercase
	stosb				; store character back into buffer
	jmp	SHORT NextChar		; repeat until end of string

EndOfString:
	pop	di			; restore di
	ret

LowercaseString	endp
;M010;end	

ifdef DBCS
;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	ds:si = start address of the string
;		ds:di = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	cx
	push	di
	mov	cx,di			; save character position
cdtb_check:
	cmp	di,si
	jz	cdtb_next		; if at the top
	dec	di			; go back
	mov	al,[di]			; get character
	invoke	testkanj
	jnz	cdtb_check		; if DBCS lead byte do next
	inc	di			; adjust
cdtb_next:
	sub	cx,di			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	di
	pop	cx
	pop	ax
	ret
CheckDBCSTailByte	endp
endif


TRANCODE ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\ifequ.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;       SCCSID = @(#)ifequ.asm  1.1 85/05/14
;       SCCSID = @(#)ifequ.asm  1.1 85/05/14
;*************************************
; COMMAND EQUs which are switch dependant

IF1
    IF IBM
        %OUT DBCS Enabled IBM  version
    ELSE
        %OUT Normal version
    ENDIF

ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\fordata.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)fordata.asm	1.1 85/05/14
;	SCCSID = @(#)fordata.asm	1.1 85/05/14
; Data structure definitions included by tfor.asm

for_info        STRUC
    for_args        DB          (SIZE arg_unit) DUP (?) ; argv[] structure
    FOR_COM_START   DB          (?)                     ; beginning of <command>
    FOR_EXPAND      DW          (?)                     ; * or ? item in <list>?
    FOR_MINARG      DW          (?)                     ; beginning of <list>
    FOR_MAXARG      DW          (?)                     ; end of <list>
    forbuf          DW          64 DUP (?)              ; temporary buffer
    fordma          DW          64 DUP (?)              ; FindFirst/Next buffer
    FOR_VAR         DB          (?)                     ; loop control variable
for_info        ENDS

; empty segment done for bogus addressing
for_segment     segment
f       LABEL   BYTE
for_segment     ends

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\envdata.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)envdata.asm	1.1 85/05/14
;	SCCSID = @(#)envdata.asm	1.1 85/05/14
; This file is included by command.asm and is used as the default command
; environment.

Environment Struc		      ; Default COMMAND environment

Env_PathString 	db	"path="
		db	0		; Null path
Env_Comstring	db	"comspec="
Env_Ecomspec 	db	"\command.com"      ;AC062
		db	134 dup (0)

Environment ends

ENVIRONSIZ 	equ	SIZE Environment
ENVIRONSIZ2 	equ 	SIZE Environment - Env_Ecomspec

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\init.asm ===
page ,132
    title   COMMAND Initialization
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;   Revision History
;   ================
;   M002    SR  07/15/90    Resize right at the start because
;               Carousel depends on it.
;
;   M004    SR  07/17/90    Initialization reworked so that
;               transient is now moved at EndInit.
;               The old approach assumed that the
;               biggest block is the one currently
;               loaded in, an assumption not true
;               for UMBs.
;
;   M005    SR  07/20/90    Numerous hacks for Carousel
;               1. Set CurrentPDB to ours at start
;               2. Normalize cs:ip of int 2fh hook
;               so that cs is different.
;
;   M013    SR  08/06/90    Fixed Setup_res_end & Move_res_code
;               to use new GetVersion call that
;               returns info about whether DOS is in
;               HMA or not.
;
;   M015    SR  08/09/90    Increased default environment size to
;               256 bytes from 160 bytes
;
;   M026    SR  9/12/90 Fixed environment trashing on second
;               Command if new comspec is given.
;
;   M030    SR  10/3/90 Before calling int 2fh 4a02h, set di
;               to 0ffffh so that we are ok if no one
;               answers this int 2fh.
;
;   M042    SR  12/13/90    Bug #4660. Changed setup_res_end to
;               take care of the dummy segment that
;               adds a para to the resident size.
;

.xlist
.xcref
    include comsw.asm
    include dossym.inc
    include pdb.inc
    include mult.inc
    include syscall.inc
    include doscntry.inc
    include comseg.asm
    include comequ.asm
    include resmsg.equ

    include envdata.asm
    include xmm.inc
    include cmdsvc.inc
    include dossvc.inc
.list
.cref



ENVBIG          equ 32768
ENVSML          equ 256     ;Increased to 256 ; M015
KOREA_COUNTRY_CODE  equ 82


CODERES segment public byte

    extrn   ContC       :near
    extrn   DskErr      :near
    extrn   Int_2e      :near
    extrn   LodCom      :near
    extrn   MsgInt2fHandler :far
    extrn   SetVect :near
    extrn   ChkSum      :near
    extrn   CrLf        :near
    extrn   LoadCom :near
    extrn   RPrint      :near
ifdef BILINGUAL
    extrn   RPrint@     :near
endif ; BILINGUAL

    extrn   EndCode :byte
    extrn   StartCode   :byte

    ifdef   DBCS
    extrn   ItestKanj   :near
    endif

    extrn   BadMemErr   :near

CODERES ends

DATARES segment public byte

    extrn   Abort_Char  :byte
    extrn   AccDen      :byte
    extrn   Append_State    :word
    extrn   Batch       :word
    extrn   Com_Fcb1    :dword
    extrn   Com_Fcb2    :dword
    extrn   Com_Ptr :dword
    extrn   ComDrv      :byte
    extrn   ComSpec :byte
    extrn   ComSpec_End :word
    extrn   Crit_Msg_Off    :word
    extrn   Crit_Msg_Seg    :word
    extrn   DataResEnd  :byte
    extrn   Dbcs_Vector_Addr    :word
    extrn   EchoFlag    :byte
    extrn   EnvirSeg    :word
    extrn   ExtMsgEnd   :byte
    extrn   fFail       :byte
    extrn   FUCase_addr :word
    extrn   InitFlag    :byte
    extrn   Int2fHandler    :dword
    extrn   Io_Save :word
    extrn   Io_Stderr   :byte
    extrn   LTpa        :word
    extrn   MemSiz      :word
    extrn   MySeg       :word
    extrn   MySeg1      :word
    extrn   MySeg2      :word
    extrn   MySeg3      :word
    extrn   Nest        :word
    extrn   OldTerm :dword
    extrn   Parent      :word
    extrn   ParseMes_Ptr    :word
    extrn   ParsMsgPtrs :word
    extrn   PermCom :byte
    extrn   PutBackDrv  :byte
    extrn   PutBackComSpec  :byte
    extrn   RDirChar    :byte
    extrn   Res_Tpa :word
    extrn   ResMsgEnd   :word
    extrn   RSwitChar   :byte
    extrn   SingleCom   :word
    extrn   KSwitchFlag :byte
    extrn   Sum     :word
    extrn   TrnSeg      :word
    extrn   TrnMvFlg    :byte

    extrn   ResSize :word
    extrn   RStack      :word

    extrn   ComInHMA    :byte   ;flag set if in HMA
    extrn   XMMCallAddr :dword  ;far call address to XMM
        EXTRN   SCS_CMDPROMPT   :BYTE
        EXTRN   SCS_DOSONLY     :BYTE

;
;All far pointers to resident routines that are to be patched
;
    extrn   Int2f_Entry :dword
    extrn   Int2e_Entry :dword
    extrn   Ctrlc_Entry :dword
    extrn   CritErr_Entry   :dword

    extrn   Int2f_Trap  :near
    extrn   Int2e_Trap  :near
    extrn   Ctrlc_Trap  :near
    extrn   CritErr_Trap    :near
    extrn   LodCom_Trap :near

    EXTRN   SCS_PAUSE:BYTE      ; yst

    extrn   EndInit :near

    extrn   Carousel_i2f_Hook   :byte   ; M005

    extrn   SCS_REENTERED   :byte
    extrn   SCS_FIRSTCOM    :byte

ifdef   BETA3WARN
    %out    Take this out before we ship
    extrn   Beta3Warned:byte
endif


DATARES ends


;;ENVIRONMENT   segment public para     ; default COMMAND environment
;;
;;  extrn   EComSpec    :byte
;;  extrn   EnvirEnd    :byte
;;  extrn   PathString  :byte
;;
;;ENVIRONMENT   ends


TAIL    segment public para

    extrn   TranStart   :word

TAIL    ends


TRANCODE    segment public byte

    extrn   DatInit :far

TRANCODE    ends

TRANDATA    segment

    extrn   TranDataEnd :byte

TRANDATA    ends

TRANSPACE   segment public byte

    extrn   TranSpaceEnd    :byte

TRANSPACE   ends




; *******************************************************************
; START OF INIT PORTION
; This code is deallocated after initialization.

INIT    SEGMENT PUBLIC PARA

;NTVDM not used        extrn   AutoBat :byte
    extrn   BadComAccMsg    :byte
    extrn   BadComLkMsg :byte
    extrn   Badcspfl    :byte
    extrn   BadVerMsg   :byte

    extrn   Chuckenv    :byte
    extrn   Command_?_syn   :byte
    extrn   Command_c_syn   :byte
    extrn   Command_d_syn   :byte
    extrn   Command_e_syn   :byte
    extrn   Command_f_syn   :byte
    extrn   Command_k_syn   :byte
    extrn   Command_l_syn   :byte
    extrn   Command_l2_syn   :byte
    extrn   Command_m_syn   :byte
    extrn   Command_u_syn   :byte
    extrn   Command_p_syn   :byte
    extrn   Command_y_syn   :byte
    extrn   Command_z_syn   :byte
    extrn   Comnd1_syn  :word
    extrn   Comnd1_addr :dword
    extrn   ComSpect    :byte
    extrn   ComspString :byte
    extrn   CopyrightMsg    :byte
    extrn   Dswitch :byte
;;  extrn   Ecomloc :word
    extrn   EnvMax      :word
    extrn   EnvSiz      :word
    extrn   EqualSign   :byte
    extrn   Eswitch :byte
    extrn   Ext_msg :byte
    extrn   HelpMsgs:word
    extrn   InitAdd :dword
    extrn   InitEnd :word
    extrn   Init_Parse  :dword
    extrn   Internat_Info   :byte
; NTVDM not used extrn   KautoBat        :byte
    extrn   Lcasea      :byte
    extrn   Lcasez      :byte
    extrn   Num_positionals :word
    extrn   OldEnv      :word
    extrn   Old_parse_ptr   :word
    extrn   OutEnvMsg   :byte
    extrn   Parse_command   :byte
    extrn   PrdAttm :byte
    extrn   ResetEnv    :word
    extrn   Scswitch    :byte
    extrn   Skswitch    :byte
    extrn   Space       :byte
    extrn   Triage_Add  :dword
    extrn   TrnSize :word
    extrn   Ucasea      :byte
    extrn   UsedEnv :word

    extrn   PathString  :byte
    extrn   ComspString :byte
    extrn   Reloc_Table :word
    extrn   FirstCom    :byte
    extrn   ResJmpTable :dword

    extrn   TriageError :near

    extrn   NUM_RELOC_ENTRIES   :abs

    extrn   DevFlag :byte
        extrn   PathFlag        :byte

        PUBLIC  ConProc
    PUBLIC  Init_ContC_SpecialCase

    assume  cs:ResGroup,ds:ResGroup,es:ResGroup,ss:ResGroup

    org 0
ZERO    =   $


ConProc:
    mov sp,offset ResGroup:RStack   ; must be first instruction
;
; M005; We need to set the PSP to us right at start because Carousel needs
; M005; to be lied to and it does not set PSP when it transfers control to
; M005; us after loading us as an overlay. By setting PSP, we ensure that
; M005; command.com is also not lied to.
;
    mov ah,SET_CURRENT_PDB      ; M005
    mov bx,es           ; M005
    int 21h         ; M005

    mov ah,GET_VERSION
    int 21h
    cmp ax,EXPECTED_VERSION
    je  OkDos               ; DOS version is ok

    mov dx,offset ResGroup:BadVerMsg    ; DX = ptr to msg
    call    RPrint
    mov ax,es
    cmp es:PDB_Parent_Pid,ax        ; if COMMAND is own parent,
Here:   jnz GoExit              ;  loop forever
    SVC SVC_DEMEXITVDM

GoExit:
    int 20h             ; otherwise, exit
okdos:

;
;  Calculate and save the end of the INIT segment (which is also
;  the beginning of TRANGROUP).
;
    mov dx,offset resgroup:TranStart+15 ;eg  get end of init code
    mov cl,4                ;eg change to paragraphs
    shr dx,cl               ;eg
    mov ax,cs               ;eg get current segment
    add ax,dx               ;eg calculate segment of end of init
        mov     InitEnd,ax                      ;eg save this

        SAVE    <SI,BP>
        xor     si,si
        xor     bp,bp
        mov     al,5                            ; query cmdprompt
        mov     ah,setdpb
        int     21h
        mov     byte ptr [scs_cmdprompt],al     ; ds is resseg
        mov     al,7                            ; query DOSONLY bit
        mov     ah,setdpb
        int     21h
        mov     byte ptr [scs_dosonly],al       ; ds is resseg
        RESTORE <BP,SI>

;
;  Check for /? on the command line.  If found, display help text
;  and exit.
;
;  NOTE:  this routine may terminate the program, never returning.
;
    call    CheckHelp

    call    CheckZSwitch

;SR;
; We have to patch the segment values for the various interrupt entry points.
;This is because we need to have the default addresses of the handlers in our
;stub before the relocation is done. These values will then be changed once
;the resident is relocated
;
    call    patch_segs

;
;  Turn APPEND off during initialization processing
;
    mov ax,APPENDINSTALL            ; see if append installed
    int 2fh             ;
    cmp al,0                ; append installed?
    je  set_msg_addr            ; no - continue
    mov ax,APPENDDOS            ; see if append DOS version right
    int 2fh             ;
    cmp ax,-1               ; append version correct?
    jne set_msg_addr            ; no - continue
    mov ax,APPENDGETSTATE           ; Get the state of Append
    int 2fh             ;
    mov Append_State,bx             ; save append state
    xor bx,bx               ; clear out state
    mov ax,APPENDSETSTATE           ; Set the state of Append
    int 2fh             ; set everything off

set_msg_addr:
    mov di,offset resgroup:DataresEnd   ; get address of resident end
    mov ResMsgEnd,di            ; save it


    call    get_XMMAddr         ;get XMM call address
;
;Check if this is the first instance of command.com. If not, we just exit
;this routine without moving any code.
;After the int 2fh, ds:si points at the resident jump table in the previous
;stub. We just have to copy this over
;

    mov ax,GET_COMMAND_STATE
    int 2fh
    assume  ds:nothing

    or  ax,ax
    jnz first_com           ;this is the first instance

ifdef   BETA3WARN
    %out    Take this out before we ship
    mov es:Beta3Warned, 0ffh
endif

    mov word ptr es:ResJmpTable,si      ;save old stub jump table
    mov word ptr es:ResJmpTable+2,ds
    jmp short init_cntry

first_com:
        mov     es:FirstCom,1                   ;indicate first command.com
    mov SCS_FIRSTCOM,1

init_cntry:
    push    es
    pop ds
    assume  ds:RESGROUP


    mov ah,GETEXTCNTRY          ; get extended country info
    mov al,4                ; get file ucase table
    mov dx,-1               ;
    mov bx,-1               ;
    mov cx,5                ; number of bytes we want
    mov di,offset resgroup:Fucase_addr  ; buffer for address
    int 21h             ;

;   Bugbug: conditionalize dbcs_vector stuff?
    push    ds              ;
    mov ax, (ECS_CALL shl 8) or GETLEADBTBL ;
    int 21h             ;
    mov bx,ds               ; get segment to bx
    pop ds              ;
    mov Dbcs_vector_addr,si         ; save address of
    mov Dbcs_vector_addr+2,bx           ; dbcs vector


    mov ax,word ptr ds:PDB_Parent_Pid   ; Init PARENT so we can exit
    mov Parent,ax           ;  correctly.
    mov ax,word ptr ds:Pdb_Exit
    mov word ptr OldTerm,ax
    mov ax,word ptr ds:Pdb_Exit+2
    mov word ptr Oldterm+2,ax


    mov ax,offset ResGroup:EndCode + 15
    mov cl,4                ; ax = size of resident part of
    shr ax,cl               ;  command in paragraphs.  Add
    mov cx,cs               ;  this to CS and you get the
    add ax,cx               ;  segment of the TPA.

    mov Res_tpa, ax         ; Temporarily save the TPA segment
    and ax, 0f000h
    add ax, 01000h          ; Round up to next 64K boundary
    jnc TpaSet              ; Memory wrap if carry set
    mov ax, Res_tpa
TpaSet:
    mov Ltpa,ax         ; Good enough for the moment
    mov ax,word ptr ds:PDB_Block_Len    ; ax = # of paras given to command

    mov Myseg1,ds           ; These 3 variables are used as part of
    mov Myseg2,ds           ;  3 long ptrs that the transient will
    mov Myseg,ds            ;  use to call resident routines.
    mov Myseg3,ds           ; segment of msg retriever routine
    mov Memsiz,ax           ; Needed for execing other programs

; M002;
; M002; First reallocate the COMMAND size to its memory image
; M002;
    push    ax              ; M002
    mov bx,offset RESGROUP:TranStart    ; M002
    add bx,offset TRANGROUP:TranSpaceEnd; M002
    add bx,15               ; M002; round up the size

    mov cl,4                ; M002
    shr bx,cl               ;size of command.com ; M002

    mov ah,SETBLOCK         ;free all memory above pgm ; M002
    int 21h             ; M002
    pop ax              ; M002


;
; Compute maximum size of environment
;
    mov EnvMax,(Environsiz + 15) / 16 + (EnvMaximum-zero + 15)/16 - 1
;
; Compute minimum size of environment
;

    mov EnvSiz, ENVSML / 16

    mov dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
    mov cl,4                ;  in paragraphs.
    shr dx,cl
    mov Trnsize,dx          ;eg save size of transient in paragraphs

    sub ax,dx               ; max seg addr - # para's needed for transient
    mov Trnseg,ax           ;  = seg addr to load the transient at.
    mov ax,ds:PDB_Environ           ; ax = environment segment
    or  ax,ax               ; if there is no environment segment,
    jz  buildenv            ;  go compute one.
    inc byte ptr Chuckenv           ; flag no new environseg to set up
    jmp short environpassed         ; otherwise one was passed to us.

buildenv:   ; (this label isn't very accurate)
;
;We allocate a buffer here just large enough to hold the 'PATH=' and
;the COMSPEC. After parsing, we will allocate an environment of the right
;size and free this buffer. We need this buffer because we no longer have an
;ENVIRONMENT segment but need a place to store the COMSPEC which can be
;given on the command line before we know the environment size. This routine
;will not return in case of an allocation error. It will either exit or hang
;depending on whether or not this is the first COMMAND.COM or not.
;

    call    alloc_env           ;try to allocate buffer

;;  mov ax,offset ResGroup:PathString   ; compute the segment of the
;;  mov cl,4                ;  environment and put it in
;;  shr ax,cl               ;  ax.
;;  mov dx,ds
;;  add ax,dx

environpassed:
    mov Envirseg,ax         ; save the environment's segment and
    mov es,ax               ;  load into es.
    assume  es:nothing

gottheenvir:
;
; initialize the command drive
;
    mov ah,GET_DEFAULT_DRIVE
    int 21h
    inc al
    mov Comdrv,al

    mov al,byte ptr ds:Fcb          ; al = default drive number for command
    or  al,al
    jz  nocomdrv            ; no drive specified

    mov ah,':'
    mov Comdrv,al
    add al,40h              ; convert number to uppercase character

    std
    cmp byte ptr Chuckenv,0         ; if a new environment is being built,
    jnz notwidenv           ;  move the default comspec string in it
    push    ds              ;  2 bytes to make room for a drivespec.
    push    es              ;  the drivespec is in ax and is copied
    pop ds              ;  on to the front of the string.
    mov di,Env_Ecomspec + ENVIRONSIZ2 - 1 ;eg
    mov si,Env_Ecomspec + ENVIRONSIZ2 - 3 ;eg

    mov cx,ENVIRONSIZ2 - 2
    rep movsb
    pop ds
    mov word ptr es:Env_Ecomspec,ax

notwidenv:
        cld                                     ; add the drivespec to the string
; NTVDM not used
;        mov     word ptr AutoBat,ax                     ; used to reference autoexec.bat
;        mov     word ptr KautoBat,ax                    ; used to reference kautoexe.bat 3/3/kk

nocomdrv:
    call    setvect             ; set interrupt vectors 22h, 23h, & 24h

;*********************************
; parsing starts here
;*********************************

    push    cs              ; get local segment
    push    cs              ; into ds,es
    pop ds              ;
    pop es              ;

assume  ds:ResGroup,es:ResGroup             ;

    mov si,80h              ; get command line
    lodsb                   ; get length of line
    mov di,si               ; get line position in di
    xor ah,ah               ; ax = length of command line
;
; insure that the command line correctly ends with a cr
;
    add di,ax               ; go to end of command line
    mov byte ptr [di],0dh           ; insert a carriage return
    xor cx,cx               ; clear cx
    mov Num_positionals,cx          ; initialize positionals
;
; Scan the command line looking for the parameters
;

Parse_command_line:
    mov di,offset ResGroup:Parse_Command ; Get address of parse_command
    mov cx,Num_positionals          ; Get number of positionals
    xor dx,dx               ; clear dx
    mov Old_parse_ptr,si            ; save position before calling parser
    call    init_parse          ; call parser
    mov Num_positionals,cx          ; Save number of positionals
    cmp ax,END_OF_LINE          ; are we at end of line?
    jnz SkipArgdsDoneJmp
    jmp  ArgsDoneJ3          ; yes - exit

SkipArgdsDoneJmp:
    cmp ax,RESULT_NO_ERROR          ; did an error occur
    jz  parse_cont          ; no - continue

;
; Before issuing error message - make sure switch is not /C or /K
;

parse_line_error:
    push    si              ; save line position
    push    ax              ; save error number
    cmp ax,BADSWT_PTR           ; Was error invalid switch?
    jnz parse_line_error_disp           ; No - just issue message
    mov di,si               ; Get terminating pointer in DI
    mov si,Old_parse_ptr            ; Get starting pointer in SI

init_chk_delim:
    cmp si,di               ; at end of parsed parameter?
    jz  parse_line_error_disp           ; Yes - just display message
    lodsb                   ;
    cmp al,Space            ; Skip blank spaces
    jz  init_chk_delim          ;
    cmp al,TAB_CHR          ; Skip tab characters
    jz  init_chk_delim          ;

    cmp al,Rswitchar            ; Switch?
    jnz parse_line_error_disp           ; No - just issue message
    lodsb                   ; Get the char after the switch

    ifdef   DBCS
    call    ItestKanj           ; Is it DBCS?
    jnz parse_line_error_disp           ; Yes - can't be /C or /K
    endif

    call    iupconv             ; upper case it
    cmp al,Scswitch         ; it is /C?
    jz  AltSetCSwitch
    cmp al,Skswitch         ; it is /K?
    jz  AltSetKSwitch
    jmp parse_line_error_disp           ;
AltSetCSwitch:
    pop dx              ; even up stack
    pop dx              ; even up stack
    jmp setSSwitch          ; Yes - go set COMMAND /C

AltSetKSwitch:
    pop dx              ; even up stack
    pop dx              ; even up stack
    jmp setKSwitch          ; Yes - go set COMMAND /K

parse_line_error_disp:

    pop ax              ; restore error number
    pop si              ; restore line position
    mov dx,ax               ; get message number
    call    RPrintParse
    call    CrLf
    jmp short Parse_command_line        ; continue parsing

parse_cont:
;
; See if a switch was entered
;
; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare

;
; Several stub switches have been added below in order to provide improved
; compatibility with applications using unsupported switches in command.com
; The stubs generally do not do anything, but, they keep command.com
; from erroring out. In many cases, this is enough to keep the app working.
;
;  STUB SWITCHES
;  /LOW             Force command.com to keep resident data in LOW memory.
;   (does nothing)
;  /Y               Step through batch file specified by /c or /k
;   (does nothing)
;  /L:nnnn          internal buffers size
;   (does nothing)
;  /U:nnn           input buffers size
;   (does nothing)
;  /K command       run batch file specified by command and continue
;    turns on /P switch if not already specified.
;

    cmp Comnd1_Syn,offset ResGroup:Command_f_syn ; was /F entered?
    jnz NoFSwitch
    jmp  SetFSwitch               ; yes go set fail switch

NoFSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_p_syn ; was /P entered?
    jnz NoPSwitch
    jmp  SetPSwitch               ; yes go set up PERMCOM

NoPSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_d_syn ; was /D entered?
    jnz NoDSwitch
    jmp  SetDSwitch               ; yes go set date switch

NoDSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_c_syn ; was /C entered?
    jnz NoSSwitch
    jmp  SetSSwitch               ; yes go set up SINGLECOM

NoSSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_k_syn ; was /K entered?
    jnz NoKSwitch
    jmp  SetKSwitch               ; yes go set up environment

NoKSwitch:

    cmp Comnd1_Syn,offset resgroup:Command_y_syn ; was /Y entered?
    jnz NoYSwitch
    jmp  SetYSwitch               ; yes go set up environment

NoYSwitch:

    cmp Comnd1_Syn,offset resgroup:Command_e_syn ; was /E entered?
    jnz NoESwitch
    jmp  SetESwitch               ; yes go set up environment

NoESwitch:

    cmp Comnd1_Syn,offset resgroup:Command_l_syn ; was /LOW entered?
    jnz NoLSwitch
    jmp  SetLSwitch                ; yes go set up message flag

NoLSwitch:


    cmp Comnd1_Syn,offset resgroup:Command_l2_syn ; was /L entered?
    jnz NoL2Switch
    jmp  SetL2Switch               ; yes go set up environment

NoL2Switch:

    cmp Comnd1_Syn,offset resgroup:Command_m_syn ; was /MSG entered?
    jnz NoMSwitch
    jmp  SetMSwitch                ; yes go set up message flag

NoMSwitch:
    cmp Comnd1_Syn,offset resgroup:Command_u_syn ; was /U entered?
    jnz NoUSwitch
    jmp  SetUSwitch                ; yes go set up message flag

NoUSwitch:


    jmp ChkOtherArgs                 ; Must be something else

ArgsdoneJ3:                 ; long jump needed
    jmp ArgsDone            ;

SetFSwitch:
    cmp fFail,-1            ; has fail switch been set?
    jnz failok              ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp parse_line_error            ; go issue error message

failok:
    mov fFail,-1            ; fail all INT 24s.
    jmp Parse_command_line          ;

SetPSwitch:
;
; We have a permanent COMMAND switch /P.  Flag this and stash the
; termination address.
;
    cmp PermCom,0           ; has /p switch been set?
    jz  permcomok           ; no - set it
    mov ax,moreargs_ptr             ; set up too many arguments
    jmp parse_line_error            ; go issue error message

permcomok:
    inc PermCom
    mov word ptr OldTerm,offset DATARES:LodCom_Trap
    mov word ptr OldTerm+2,ds
;
; make sure that we display the date and time.  if the flag was not
; initialized, set it to indicate yes, do prompt.
;

    cmp Comnd1_Syn,offset resgroup:Command_k_syn
    jnz RealPSwitch
    jmp ArgsDone
RealPSwitch:
    cmp byte ptr PrdAttm,-1
    jnz Parse_command_line_jmp      ; keep parsing
    mov byte ptr PrdAttm,0          ; if not set explicit, set to prompt

Parse_command_line_jmp:             ;
    jmp parse_command_line          ; keep parsing

ArgsDoneJump:
    jmp ArgsDone

SetDSwitch:
;
; Flag no date/time prompting.
;
    cmp Dswitch,0           ; has /D switch been set?
    jz  setdateok           ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp parse_line_error            ; go issue error message

setdateok:
    inc Dswitch             ; indicate /D entered
    mov byte ptr PrdAttm,1          ; user explicitly says no date time
    jmp Parse_command_line          ; continue parsing

SetYSwitch:
;
; Y switch is ignored. Present to keep apps that actually use it in a
; static create process or something from having problems
; (important after a win9xupg.)
;
    jmp Parse_command_line          ; continue parsing


SetKSwitch:
;
; Treat this just like /C, just keep going
;
    mov KSwitchFlag,1
    jmp SetSSwitch

;
; Look for environment-size setting switch
;
; The environment size is represented in decimal bytes and is
; converted into pargraphs (rounded up to the next paragraph).
;

SetSSwitch:
;
; Set up pointer to command line, flag no date/time and turn off singlecom.
;
    mov SingleCom,si            ; point to the rest of the command line
    mov Permcom,0           ; a singlecom must not be a permcom
    mov byte ptr PrdAttm,1          ; no date or time either, explicit
    jmp ArgsDone
;
; Look for environment-size setting switch
;
; The environment size is represented in decimal bytes and is
; converted into pargraphs (rounded up to the next paragraph).
;

SetESwitch:
    cmp Eswitch,0           ; has fail switch been set?
    jz  eswitchok           ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp Parse_line_error            ; go issue error message

eswitchok:
    inc Eswitch             ; indicate /E entered
    mov di,offset ResGroup:Comnd1_Addr  ; get number returned
    mov bx,word ptr [di]            ; into bx

    add bx, 0fh             ; Round up to next paragraph
    mov cl,4                ; convert to pargraphs
    shr bx, cl              ; by right 4

    mov EnvSiz,BX           ; EnvSiz is in paragraphs
    jmp Parse_command_line          ; continue parsing command line

SetL2Switch:
    Jmp Parse_Command_Line

SetMSwitch:
    cmp Ext_msg,SET_EXTENDED_MSG        ; has /MSG switch been set?
    jnz setMswitchok            ; no - set it
    mov ax,Moreargs_ptr             ; set up too many arguments
    jmp Parse_line_error            ; go issue error message
setMswitchok:
    mov Ext_msg,SET_EXTENDED_MSG        ; set /MSG switch
    jmp Parse_command_line          ; keep parsing

SetLSwitch:
    jmp Parse_Command_Line

SetUSwitch:
    Jmp Parse_Command_Line


ArgsDoneJ:
    jmp  ArgsDone

;
; We have a non-switch character here.
;
ChkOtherArgs:
    push    ds              ;
    push    si              ; save place in command line
    lds si,Comnd1_Addr          ; get address of filespec
    assume  ds:nothing          ;

    mov dx,si               ; put in dx also
    mov ax,(OPEN shl 8) or 2            ; Read and write
    int 21h
    jc  ChkSrchSpec         ; Wasn't a file
    mov bx,ax
    mov ax,IOCTL shl 8
    int 21h
    test    dl,80h
    jnz IsaDevice

BadSetCon:                  ;
    mov ah,CLOSE            ; Close initial handle, wasn't a device
    int 21h
    jmp short ChkSrchSpec

IsaDevice:
    xor dh,dh
    or  dl,3                ; Make sure has CON attributes
    mov ax,(IOCTL shl 8) or 1
    int 21h
    jc  BadSetCon           ; Can't set attributes - quit
    mov dx,bx               ; Save new handle

    cmp es:DevFlag,1
    jz  DevErr

    push    cx
    mov cx,3
    xor bx,bx

rcclloop:                   ; Close 0,1 and 2
    mov ah,CLOSE
    int 21h
    inc bx
    loop    rcclloop

    mov bx,dx               ; New device handle
    mov ah,XDUP
    int 21h             ; Dup to 0
    mov ah,XDUP
    int 21h             ; Dup to 1
    mov ah,XDUP
    int 21h             ; Dup to 2
    mov ah,CLOSE
    int 21h             ; Close initial handle
    pop cx
    pop si              ; restore position of command line
    pop ds              ;
;SR;
; Register the fact that we already have redirected the output and cannot do
;it again
;
    inc es:DevFlag          ;
    jmp Parse_command_line          ; continue parsing

DevErr:
    pop si
    pop ds
    mov dx,1
    call    RPrintParse                 ;"Too many parameters"
    call    CrLf
    jmp Parse_command_line

ChkSrchSpec:                    ; Not a device, so must be directory spec

    cmp es:PathFlag,1           ;already set COMSPEC?
    jz  DevErr              ;yes, error

    inc es:PathFlag         ;mark that we have a path
;
;We do not have an ENVIRONMENT segment any more so we need to allocate a
;temporary buffer to hold the COMSPEC. Later, this buffer will be freed and
;its contents moved to the final location of the environment. If there was
;no environment passed before, then a buffer has already been allocated and
;so we check for this case. Fortunately, Chuckenv would have been previously
;set if we had been passed an environment.
;

    mov ax,EnvirSeg
    cmp byte ptr Chuckenv,1         ;passed environment?
    mov byte ptr Chuckenv,0         ;ignore passed environment
    jne no_alloc            ;no, default, dont allocate
;
;We have to override the passed environment. Allocate a buffer for use now.
;This buffer will later be replaced by a proper environment
;
    call    alloc_env           ;allocate env buffer

;;  mov ax,offset ResGroup:PathString   ; Figure environment pointer
;;  mov cl,4
;;  shr ax,cl
;;  mov dx,cs               ;
;;  add ax,dx

    mov EnvirSeg,ax
no_alloc:
    mov es,ax
    assume  es:nothing
    push    si              ; remember location of file
    xor cx,cx               ; clear cx for counting

countloop:
    lodsb                   ; get a character
    inc cx              ; increment counter
    cmp al,END_OF_LINE_OUT          ; are we at end of line?
    jnz countloop           ; no - keep counting

    mov al,Space
    dec si              ; move back one
    mov byte ptr [si],al            ; put a space at end of line
    pop si              ; get location back

    mov di,Env_Ecomspec         ; get location of COMSPEC

ComtrLoop:
    lodsb
    dec cx
    cmp al,Space
    jz  SetComsr
    stosb

    ifdef   DBCS
    xor ah,ah
    endif

    jcxz    setcomsr

    ifdef   DBCS

    push    ds              ; Make sure we have
    push    cs              ;  local DS for
    pop ds              ;  ItestKanj
    call    ItestKanj
    pop ds              ; restore parser ds
    jz  ComtrLoop
    dec cx
    movsb
    inc ah
    jcxz    setcomsr

    endif

    jmp short comtrloop

setcomsr:
    push    cx

    push    cs              ; Get local segment
    pop ds              ;
    assume  ds:ResGroup         ;

    push    ds
    mov si,offset ResGroup:ComSpect
    mov cx,14

    mov al,es:[di-1]

    ifdef   DBCS
    or  ah,ah
    jnz iNotRoot            ; Last char was KANJI second byte, might be '\'
    endif

    cmp al,RDirChar
    jnz iNotRoot
    inc si              ; Don't make a double /
    dec cx

iNotRoot:
    rep movsb

    mov dx,Env_Ecomspec         ; Now lets make sure its good!
    push    es
    pop ds

    mov ax,OPEN shl 8
    int 21h             ; Open COMMAND.COM
    pop ds
    jc  SetComsrBad         ; No COMMAND.COM here
    mov bx,ax               ; Handle
    mov ah,CLOSE
    int 21h             ; Close COMMAND.COM

SetComsrRet:
    pop cx
    pop si
    pop ds              ;
    assume  ds:ResGroup         ;

ArgsDoneJ2:
    push    cs              ; Make sure local ES is
    pop es              ;  restored
    jmp Parse_command_line          ; continue parsing command line

SetComsrBad:
    mov dx,offset ResGroup:BadComlkMsg  ; dx = ptr to msg

;   Note:  we're about to make a near call to TriageError, which
;   lives in a different segment and group.  Some linkers will
;   generate a warning like "Possible fix-up overflow".  We're
;   ok, though, because we all fit in 64 KB and, at init time,
;   we're still all together.

    call    triageError
    cmp ax, 65
    jnz doprt
    mov dx,offset ResGroup:BadComaccMsg ; dx = ptr to msg
DoPrt:
    call    RPrint
    mov si,offset ResGroup:ComSpect
    mov di,Env_Ecomspec
    mov cx,14
    rep movsb               ; get my default back

    jmp short SetComsrRet

;*********************************
; Parsing Ends Here
;*********************************

ArgsDone:

    mov es,EnvirSeg         ; get environment back
    assume  es:nothing          ;

    cmp PermCom,0
    jz  ComReturns

    push    es              ; Save environment pointer
    mov ah,SET_CURRENT_PDB
    mov bx,ds
    mov es,bx
    int 21h             ; current process is me
    mov di,PDB_EXIT         ; Diddle the addresses in my header
    mov ax,offset DATARES:LodCom_Trap
    stosw
    mov ax,ds
    stosw
    mov ax,offset DATARES:Ctrlc_Trap
    stosw
    mov ax,ds
    stosw
    mov ax,offset DATARES:CritErr_Trap
    stosw
    mov ax,ds
    stosw
    mov word ptr ds:PDB_Parent_Pid,ds   ; Parent is me forever

    mov dx,offset DATARES:Int2e_Trap
    mov ax,(SET_INTERRUPT_VECTOR shl 8) or 02eh
    int 21h             ;set magic interrupt
    pop es              ;Remember environment

ComReturns:
    mov ax,word ptr ds:PDB_Parent_Pid
    mov Parent,ax           ; Save parent
    mov word ptr ds:PDB_Parent_Pid,ds   ; Parent is me
    mov ax,word ptr ds:PDB_Jfn_Table
    mov Io_save,ax          ; Get the default stdin and out
    mov al,byte ptr ds:[PDB_Jfn_Table+2]
    mov Io_Stderr,al            ; Get the default stdin and out
    mov word ptr Com_ptr+2,ds           ; set all these to resident
    mov word ptr Com_fcb1+2,ds
    mov word ptr Com_fcb2+2,ds
    mov di,offset ResGroup:ComSpec

    mov si,Env_Ecomspec
    cmp byte ptr Chuckenv,0

    mov ax,ds               ; Xchg es,ds
    push    es
    pop ds
    mov es,ax

    jz  CopyComsp           ; All set up for copy

    push    cs
    pop ds

    mov si,offset ResGroup:ComspString
    push    es
    push    di
    call    IfindE
    mov si,di
    push    es
    pop ds
    pop di
    pop es
    jnc CopyComsp

ComSpecNofnd:
    mov si,Env_Ecomspec             ;
    push    cs
    pop ds

    assume  es:ResGroup

CopyComsp:
    mov es:PutBackComSpec.SubstPtr,di   ; Save ptr to beginning of comspec path
    cmp byte ptr [si+1],':'             ; Is there a drive specifier in comspec
    jnz CopyComspLoop           ; If not, do not skip over first 2 bytes
    add es:PutBackComSpec.SubstPtr,2

CopyComspLoop:
    lodsb
    stosb
    or  al,al
    jnz CopyComspLoop
    mov es:Comspec_end,di           ; Save ptr to end of comspec path
    dec es:Comspec_end
    mov ah,es:comdrv
    add ah,'A'-1
    mov es:PutBackDrv,ah            ; save drive letter


    call    setup_for_messages          ; set up parse and extended error messages
;SR;
;The routine below sets up the exact resident size of COMMAND. If this is not
;the first COMMAND, then the resident code is not duplicated and the resident
;size is just the data. If we are the first COMMAND, it checks if we are to
;be loaded into HIMEM. If not, then the resident size includes the code and
;the data otherwise it is just the data.
;
    call    Setup_res_end           ;put resident size in ResSize

    push    cs
    pop ds
    assume  ds:RESGROUP

;; if we are the permanent one, tell ntvdm the real comspec.
    cmp PermCom, 0
    je  comspec_to_32_done
    push    ax
    mov dx, offset RESGROUP:ComSpec
    CMDSVC  SVC_CMDCOMSPEC
    mov SCS_PAUSE,al            ; yst 4-5-93
    pop ax


comspec_to_32_done:
;;  mov bx,ResMsgEnd            ; get end of resident
;;  add bx,15
;;  mov cl,4
;;  shr bx,cl

Public EnvMaximum
EnvMaximum:
;;;
;;; NOTE: The transient has to loaded directly after shrinking to the
;;; resident size.
;;; There is an assumption made when loading the transient that it
;;; still intact after the resident portion.
;;; If any other ALLOC/DEALLOC/SETBLOCK operations are performed
;;; inbetween, then there is a real good chance that the non-resident
;;; portion will be overwritten by arena information.

;SR;
;Do not shrink to the resident now. We will then be running in deallocated
;memory and BAAADNESS! can ensue.
;

;;  mov ah,SETBLOCK
;;  int 21h             ; shrink to the resident only

;
; Load in the transient and compute the checksum.  We may do this in one of
; two ways:  First, cheat and use the transient loading code that exists in
; the resident piece.  This may be OK except that it will hit the disk.
;
; But we do not need to hit the disk!  The transient is already loaded but is
; in the wrong place.  We need to block transfer it up to the correct spot.
;

;
; M004; Start of changes
;

;
; Compute checksum right now before we can get corrupted and save it
;

    mov si,offset RESGROUP:TranStart
    add si,100h
    mov cx,offset TRANGROUP:TranDataEnd - 100H

    cld
    shr cx,1
    xor dx,dx
Ichksum:
    lodsw
    add dx,ax
    adc dx,0
    loop    Ichksum

    mov Sum,dx              ;store checksum

;
; M004; End of changes
;

    cmp byte ptr PrdAttm,0          ;eg
    jnz NoBatchSeg          ;eg don't do autoexec or date time
;
; allocate batch segment for d:/autoexec.bat + no arguments
;

; NTVDM temp name of the batch file may be up to 63 bytes, plus NULL
;        mov     bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ;eg
        mov     bx,((SIZE BatchSegment) + 64 + 0fh)/16 ;eg

    mov ah,ALLOC            ;eg
    int 21h             ;eg
    jc  NoBatchSeg          ;eg didn't allocate - pretend no batch
    mov Batch,ax            ;eg save batch segment

nobatchseg:
;;  mov bx, 0ffffh          ; get size of largest block for env
;;  mov ah, ALLOC
;;  int 21h
;;
;;; only allocate maximum 64k worth of environment
;;
;;  sub bx,TrnSize          ;eg subtract # of transient paragraphs
;;  sub bx,128              ;eg make sure we have 2k left
;;  mov EnvMax, bx
;;  cmp bx, 4096            ; 64k = 4096 paragraphs
;;  jb  maxok
;;  mov bx, 4096-1
;;  mov EnvMax, bx
;;maxok:
;;
;;  mov ah, ALLOC           ; get max size
;;  int 21h
;;
    mov bx,EnvirSeg         ;g get old environment segment
    mov OldEnv,bx           ;g save it

    mov UsedEnv,0           ;g initialize env size counter
    mov ds,bx
    assume  ds:nothing

;;  mov EnvirSeg,ax
;;;Bugbug: There is no need to initialize es at this point-- no string moves
;;  mov es,ax

    xor si,si
    mov di,si
;SR;
;This is the maximum allowed size for the environment
;
    mov bx,4096 - 1             ; max. allowed env. size
    mov EnvMax,bx

    shl bx,1
    shl bx,1
    shl bx,1
    shl bx,1
    mov EnvMax, bx          ; convert envmax to bytes
    dec bx              ; dec by one to leave room for double 0
    xor dx,dx               ; use dx to indicate that there was
                        ; no environment size error.
public NxtStr
NxtStr:
    call    GetStrLen           ; get the size of the current env string

;Bugbug: Can use ss here to address UsedEnv

    push    ds              ;g get addressability to environment
    push    cs              ;g           counter
    pop ds              ;g
    assume  ds:ResGroup
    add UsedEnv,cx          ;g  add the string length to env size
    pop ds              ;g
    assume  ds:nothing
    cmp cx,1                ; end of environment was encountered.
    jz  EnvExit
    sub bx,cx
    jae OkCpyStr            ; can't fit in all of enviroment.
    inc dx              ; out of env space msg must be displayed
    jmp short EnvExit
OkCpyStr:
    jmp NxtStr
EnvExit:

    push    cs
    pop ds
    assume  ds:ResGroup
    or  dx,dx               ; dx will be non-zero if error
    jz  EnvNoErr
    mov dx,offset ResGroup:OutEnvMsg    ; dx = ptr to msg
    call    RPrint

EnvNoErr:
    mov ax,EnvSiz           ;env size previously set
    mov cl,4
    shl ax,cl               ;get size in bytes
    cmp ax,UsedEnv          ;is it a new env?
    ja  st_envsize          ;yes, store the size

    mov ax,UsedEnv
    add ax,15               ;round up
st_envsize:
    shr ax,cl
    mov EnvSiz,ax           ;store env size needed(paras)
;;;
;;; bx now has the left over size of the maximum environment
;;; we want to shrink the environment down to the minimum size
;;; set the environment size to max(envsiz,env used)

;;  mov cx, EnvMax
;;  sub cx, bx              ; cx now has the environment used
;;  add cx, 16              ; round up to next paragraph
;;  shr cx, 1
;;  shr cx, 1
;;  shr cx, 1
;;  shr cx, 1
;;  cmp cx, EnvSiz          ; is environment used > envsiz
;;  jb  EnvSet
;;  mov EnvSiz, cx
;;EnvSet:
;;  mov bx, EnvSiz          ; set environment to size needed
;;  mov ax,es               ;eg get environment segment
;;  add ax,bx               ;eg add number of environment paragraphs
;;  cmp ax,InitEnd          ;eg does this go past end of init?
;;  ja  EnvSetOk            ;eg yes - do the setblock
;;  mov ax,es               ;eg no - get back the environment segment
;;  mov bx,InitEnd          ;eg get the segment at end of init
;;  sub bx,ax               ;eg setblock envir segment to end of init code
;;  mov ResetEnv,1          ;eg set flag so we know to set envir later
;;
;;envsetok:
;;  mov ah, setblock
;;  int 21h
ifndef NEC_98
        cmp     SCS_FIRSTCOM,1
        jz      nophead                         ; don't print header for first instance
else    ;NEC_98
endif   ;NEC_98
        cmp     SCS_CMDPROMPT,1
        je      nophead
    cmp SingleCom,0
    jnz nophead             ; don't print header if singlecom
        mov     dx,offset ResGroup:CopyrightMsg ; dx = ptr to msg
        call    RPrint

nophead:

        cmp     Batch,0                 ;eg did we set up a batch segment?
    jnz DoDate              ;eg yes - go initialize it
    jmp NoDttm              ; don't do autoexec or date time
;
; allocate batch segment for d:/autoexec.bat + no arguments
;
DoDate:
    mov ax,Batch            ;eg get batch segment
    mov EchoFlag,3          ; set batch echo
    mov Nest,1              ; g set nest flag to 1 batch
    mov es,ax
;
; initialize the segment
;
    xor di,di
    mov al,BATCHTYPE
    stosb
    mov al,1                ; g initialize echo for batch exit
    stosb                   ; g
;SR;
; Hosebag! This guy does not use the struct fields to init the BatchSegment
;
    xor ax,ax               ; initialize to zero
    stosb                   ; clear out BatchEOF

    stosw                   ; g batch segment of last job - batlast
    stosw                   ; g segment for for
    stosb                   ; g for flag
    stosw                   ; position in file - batseek
    stosw
;
; clean out the parameters
;
    mov ax,-1               ; initialize to no parameters
    mov cx,10
        rep     stosw

;
; NTVDM Get temp file name from 32 bit command.lib
;
if 0
;
; decide whether we should grab the default drive
;
    cmp byte ptr AutoBat,0
    jnz NoAutSet
    mov ah,GET_DEFAULT_DRIVE
    int 21h
    add al,Ucasea

    mov AutoBat,al
    mov KautoBat,al         ; 3/3/kk

NoAutSet:


;
; copy in the batch file name (including nul)
;
    mov si,offset ResGroup:AutoBat
    mov cx,8
    rep movsw
        movsb                                   ; move in carriage return to terminate string
endif
        push    es
        pop     ds
        assume ds:nothing

        mov     dx, di
        CMDSVC  SVC_GETAUTOEXECBAT

;NTVDM not used mov     dx,offset ResGroup:AutoBat
    mov ax,OPEN shl 8
        int     21h                             ; see if autoexec.bat exists

        push    cs
        pop     ds
        assume  ds:ResGroup

        jc      NoAbat
    mov bx,ax
    mov ah,CLOSE
    int 21h
ifndef NEC_98
    jmp Drv0                ; go process autoexec
else    ;NEC_98
    jmp short   Drv0            ; NEC01 91/07/30 Warning Error Del
endif   ;NEC_98

noabat:
    push    ax
    call    Setup_Seg
    mov word ptr Triage_Add+2,ax
    pop ax
    call    Triage_Add
    cmp ax, 65
    jz  AccDenErr           ; was network access denied

; NTVDM we don't do kautoexe.bat
if 0
; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT.  Changed
; by Ellen to check only when in Korea.  The country information
; returned will overlay the old parse data area, but we don't care
; since we won't need the parse information or country information.
; We only care about the country code returned in BX.

    mov dx,offset ResGroup:Internat_Info ; set up internat vars
    mov ax,INTERNATIONAL shl 8      ; get country dependent info
    int 21h             ;
    jc  NoKabat             ; error - don't bother with it
    cmp bx,KOREA_COUNTRY_CODE           ; are we speaking korean?
    jnz OpenErr             ; no, don't check for kautoexe

    mov di,BatFile          ; 3/3/kk
    mov si,offset ResGroup:KautoBat ; another trial to do   3/3/kk
    mov cx,8                ; auto execution for the 3/3/kk
    rep movsw               ; non-english country   3/3/kk
    movsb                   ; move in carraige return to terminate string
    mov dx,offset ResGroup:KautoBat ; 3/3/kk
    mov ax,OPEN shl 8           ; 3/3/kk
    int 21h             ; see if kautoexe.bat exists    3/3/kk
    jc  NoKabat             ; 3/3/kk
    mov bx,ax               ; 3/3/kk
    mov ah,CLOSE            ; 3/3/kk
    int 21h             ; 3/3/kk
    jmp short Drv0          ; 3/3/kk

NoKabat:                        ; 3/3/kk
    call    Triage_Add          ; get extended error
    cmp ax, 65              ; network access denied?
        jnz     OpenErr                         ; no - go deallocate batch
endif

AccDenErr:                  ; yes - put out message
    mov dx,offset ResGroup:AccDen       ; dx = ptr to msg
    call    RPrint

OpenErr:
    mov es,Batch            ; not found--turn off batch job
    mov ah,DEALLOC
    int 21h
    mov Batch,0         ; after dealloc in case of ^c
    mov EchoFlag,1
    mov Nest,0              ;g indicate no batch in progress

DoDttm:
    mov ax,offset TranGroup:Datinit
    mov word ptr InitAdd,ax
;;;M004 mov ax,TrnSeg
;
; M004; We cant use TrnSeg now because it is not initialized. We now that
; M004; the transient starts on a para boundary at the label TranStart.
; M004; We use TranStart to get the start of the transient segment.
;
    mov ax,offset RESGROUP:TranStart    ; M004
    mov cl,4                ; M004
    shr ax,cl               ; get relative seg ; M004
    mov cx,cs
    add ax,cx               ; ax = transient seg ; M004

    mov word ptr InitAdd+2,ax
;   call    dword ptr InitAdd

NoDttm:

Copyright:
    public  Copyright
;   Bugbug: remove Copyright label.

;if IBMVER
;   cmp SingleCom,0
;   jnz Drv0                ; don't print header if singlecom
;   mov dx,offset ResGroup:CopyrightMsg ; dx = ptr to msg
;   call    RPrint
;endif

Drv0:                       ; Reset APPEND state
    push    ds              ; save data segment
    push    cs              ; Get local segment into DS
    pop ds              ;
    mov ax,APPENDSETSTATE           ; Set the state of Append
    mov bx,Append_State             ;  back to the original state
    int 2fh             ;
    pop ds              ; get data segment back
;
;Check FirstCom set previously to see if this is the first instance of
;command.com. If not, we do not move command.com. Instead, we copy over the
;jump table from the previous stub to the current stub.
;
    cmp FirstCom,1          ;first command.com?
    jz  move_code           ;yes, move it

    push    es
    push    ds

    push    ds
    pop es
    mov di,offset DATARES:Int2f_Entry

    mov ds,word ptr es:ResJmpTable+2    ;get segment address
    mov si,word ptr es:ResJmpTable      ;get offset address

    mov     cx,NUM_RELOC_ENTRIES            ;number of dword ptrs
    shl cx,1
    shl cx,1                ;size of table in bytes

    cld
    rep movsb               ;copy the jump table
;
;Check if the resident code is in HMA. We assume that it is in HMA if its
;code segment > 0f000h. If in HMA, we set the ComInHMA flag
;
    cmp es:[di-2],0f000h            ;is resident code in HMA?
    jb  res_low         ;no, dont set flag

    mov es:ComInHMA,1           ;indicate code in HMA

res_low:
    pop ds
    pop es
    jmp short finish_init
;
;Now, we can move the resident code to its final location, either to HIMEM
;or to overlay the messages in the data segment if the user has not used the
;/msg switch.
;
move_code:
    call    Move_res_code           ;move the code

finish_init:
    jmp RESGROUP:EndInit            ;g finish initializing

;
;   Get length of string pointed to by DS:SI.  Length includes NULL.
;   Length is returned in CX
;
GetStrLen:
    xor cx,cx
NxtChar:
    lodsb
    inc cx
    or  al,al
    jnz NxtChar
    ret
;
; If the transient has been loaded in TranSeg, then we need to use that
; segment for calls to routines in the transient area. Otherwise, the current
; code segment is used
; Segment returned in AX.
;
Setup_Seg:
    mov ax,TrnSeg
    cmp TrnMvFlg, 1         ; Has transient portion been moved
    jz  setup_end
    push    bx
    mov bx,cs
    mov ax,offset ResGroup:TranStart
    shr ax,1
    shr ax,1
    shr ax,1
    shr ax,1
    add ax,bx
    pop bx
setup_end:
    ret


;***    RPrintParse - display parse error message
;
;   ENTRY   DX = parse error #
;
;   EXIT    nothing
;
;   USED    flags
;
;   EFFECTS
;     Message is displayed on stdout.

RPrintParse proc

    assume  ds:ResGroup,ss:ResGroup

    push    dx              ; preserve DX
    xchg    bx,dx               ; bx = parse error #
                        ; dx = saved BX
ifdef BILINGUAL
    push    ax
    push    bx
    mov ax,4f01h        ; get code page
    xor bx,bx
    int 2fh
ifdef JAPAN
    cmp bx,932
endif ; JAPAN
ifdef KOREA
    cmp bx,949
endif ; KOREA
ifdef TAIWAN
    cmp bx,950
endif ; TAIWAN
ifdef PRC
    cmp bx,936
endif ; TAIWAN
    pop bx
    pop ax
    jz  @f          ; if DBCS code page
    add bx,11
@@:
endif ; BILINGUAL
    dec bx              ; bx = parse error index, from 0
    shl bx,1                ; bx = offset in word table
    mov bx,ParsMsgPtrs[bx]          ; bx = ptr to error msg
    xchg    bx,dx               ; dx = ptr to error msg
                        ; bx = restored
ifdef BILINGUAL
    call    RPrint@             ; print the message
else ; !BILINGUAL
    call    RPrint              ; print the message
endif ; !BILINGUAL
    pop dx              ; restore DX
    ret

RPrintParse endp



IfindE:
    call    ifind               ; find the name
    jc  ifind2              ; carry means not found
    jmp short Iscasb1           ; scan for = sign
;
; on return of find1, es:di points to beginning of name
;
ifind:
    cld
    call    Icount0             ; cx = length of name
    mov es,EnvirSeg
    xor di,di

ifind1:
    push    cx
    push    si
    push    di

Ifind11:
    lodsb

    ifdef   DBCS

    call    ItestKanj
    jz  NotKanj4
    dec si
    lodsw
    inc di
    inc di
    cmp ax,es:[di-2]
    jnz Ifind12
    dec cx
    loop    Ifind11
    jmp short Ifind12
NotKanj4:

    endif

    call    IupConv
    inc di
    cmp al,es:[di-1]
    jnz Ifind12
    loop    Ifind11

Ifind12:
    pop di
    pop si
    pop cx
    jz  Ifind2
    push    cx
    call    Iscasb2             ; scan for a nul
    pop cx
    cmp byte ptr es:[di],0
    jnz Ifind1
    stc                 ; indicate not found

Ifind2:
    ret

Icount0:
    push    ds
    pop es
    mov di,si

    push    di              ; count number of chars until "="
    call    Iscasb1
    jmp short Icountx
    push    di              ; count number of chars until nul
    call    Iscasb2

Icountx:
    pop cx
    sub di,cx
    xchg    di,cx
    ret

Iscasb1:
    mov al,Equalsign            ; scan for an =
    jmp short Iscasbx

Iscasb2:
    xor al,al               ; scan for a nul

Iscasbx:
    mov cx,100h
    repnz   scasb
    ret


; ****************************************************************
; *
; * ROUTINE:     IUPCONV    (ADDED BY EMG 4.00)
; *
; * FUNCTION:    This routine returns the upper case equivalent of
; *      the character in AL from the file upper case table
; *      in DOS if character if above  ascii 128, else
; *      subtracts 20H if between "a" and "z".
; *
; * INPUT:   DS       set to resident
; *      AL       char to be upper cased
; *      FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:  AL       upper cased character
; *
; ****************************************************************


IupConv proc    near
    assume  ds:ResGroup         ;

    cmp al,80h              ; see if char is > ascii 128
    jb  other_fucase            ; no - upper case math
    sub al,80h              ; only upper 128 chars in table
    push    ds              ;
    push    bx              ;
    lds bx,dword ptr fucase_addr+1      ; get table address
    add bx,2                ; skip over first word
    xlat    ds:byte ptr [bx]            ; convert to upper case
    pop bx              ;
    pop ds              ;
    jmp short iupconv_end           ; we finished - exit

other_fucase:                   ;
    cmp al,Lcasea           ; if between "a" and "z",
    jb  iupconv_end         ;     subtract 20h to get
    cmp al,Lcasez           ; upper case equivalent.
    ja  iupconv_end         ;
    sub al,20h              ; Change lower-case to upper

iupconv_end:                    ;
    ret

IupConv endp                    ;


init_contc_specialcase:
                        ; This routine is called if control-C
    add sp,6                ;  is type during the date/time prompt
    push    si              ;  at initialization time.  The desired
    mov si,dx               ;  response is to make it look like the
    mov word ptr [si+1],0d00h           ;  user typed <CR> by "popping" the
    pop si              ;  INT 21h stuff off the stack, putting
    iret                    ;  a <CR> in the user's buffer, and
                        ;  returning directly to the user.
                        ; In this case the user is TCODE.


; ****************************************************************
; *
; * ROUTINE:     Setup_for_messages
; *
; * FUNCTION:    Sets up system for PARSE and EXTENDED ERROR
; *      messages as follows:
; *
; *      IF /P and /MSG are entered
; *         keep PARSE and EXTENDED ERRORS in memory
; *      ELSE IF /P is entered
; *         use PARSE and EXTENDED ERRORS on disk
; *         remove PARSE ERRORS from memory
; *      ELSE
; *         remove PARSE ERRORS from memory
; *      ENDIF
; *
; * INPUT:   PERMCOM    Set up with user input
; *      EXT_MSG    Set up with user input
; *      System set up to retain PARSE ERRORS
; *
; * OUTPUT:  registers unchanged
; *
; ****************************************************************


setup_for_messages  proc    near

    push    bx
    push    ds              ; save data segment
    push    es              ; save environment segment
    push    ax              ;
    push    dx              ;
    push    di              ;
    mov ax,cs               ; get local segment to ES and DS
    mov ds,ax               ;
    mov es,ax               ;

    cmp PermCom,0           ; was permcom set?
    jz  no_permcom          ; No - don't worry about messages

;*  We're permanent.  Install our message services int 2f handler.

    push    es
    mov ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
    int 21h
    mov word ptr Int2fHandler,bx
    mov word ptr Int2fHandler+2,es
    pop es

;   DS = RESGROUP seg addr

;
; M005; We will not hook int 2fh on any command.com other than the first.
; M005; Carousel loads as a permanent command.com and when we exit Carousel,
; M005; it just wipes our arena out. So, int 2fh is still hooked and the
; M005; first int 2fh call after exit from Carousel (from the DOS terminate
; M005; call) goes off into space.
;
    cmp FirstCom,0          ; M005
    je  no_msg_hook         ; M005
;
; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
; M005; Carousel plays around with the interrupt vector tables. He saves it
; M005; before loading a new command.com. Then, it takes hold of the current
; M005; command.com's PSP and then looks at all interrupt vectors whose
; M005; segment matches the command.com PSP and then updates these segments
; M005; to the new command.com's PSP in his saved vector table. Whenever we
; M005; we pop into his menu, he puts this saved table into the vector table.
; M005; If we now quit, Carousel just wipes out command.com's arena and then
; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
; M005; the command.com that was wiped out and so the next int 2fh call will
; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
; M005; renormalize our int 2fh pointer so that its cs is not the same as the
; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
; M005; remains nice and happy. The renormalized pointer points at a far
; M005; jump to the actual int 2fh entry point.
;
    push    ds              ; M005
    mov dx,offset DATARES:Carousel_i2f_Hook ; M005
    sub dx,10h              ; renormalize offset; M005
    mov ax,ds               ; M005
    inc ax              ; Relocated cs ; M005
    mov ds,ax               ; M005
    mov ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
    int 21h
    pop ds              ; M005
    mov word ptr Carousel_i2f_Hook+3,ds ; M005
                        ; patch in the cs for jump
no_msg_hook:                    ; M005

    cmp Ext_Msg,SET_EXTENDED_MSG
    jne short permcom_end           ; no /msg - exit

permcom_slash_msg:              ; Keep messages in memory
    mov di,offset ResGroup:ExtMsgEnd    ; get address of resident end
    mov ResMsgEnd,di            ; save it
    jmp short permcom_end           ; exit

no_permcom:
    cmp Ext_msg,SET_EXTENDED_MSG        ; was /msg specified?
    jnz permcom_end         ; no - no error
    mov dx,LessArgs_Ptr             ; get message number for "Required parameter missing"
    call    RPrintParse

permcom_end:
    pop di              ;
    pop dx              ;
    pop ax              ;
    pop es              ; get environment back
    pop ds              ;
    pop bx

    ret                 ;

setup_for_messages  endp




;***    CheckHelp - print help text and exit if /? is on command line
;
;   ENTRY   command-line tail at 81h
;
;   EXIT    return if /? not found
;       terminate if /? found
;
;   USED    AX,BX,CX,DX,SI,DI
;
;   EFFECTS Help text displayed if /? found on command line

CheckHelp   proc

    assume  cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP

    mov si,81h          ; DS:SI = ptr to command-line tail
    mov di,offset RESGROUP:Parse_Command
                    ; ES:DI = ptr to primary parse block
    xor cx,cx           ; CX = # positional param's found
    xor dx,dx           ; DX will be ptr to result buffer

chParse:
    call    Init_Parse      ; call system parser

    cmp ax,END_OF_LINE
    je  chRet           ; end of command line, no /? found
    cmp ax,RESULT_NO_ERROR
    je  chWhich         ; valid syntax element found
    jmp chParse         ; go parse more

chWhich:
    cmp Comnd1_Syn,offset RESGROUP:Command_?_Syn
    je  chHelp          ; /? found - display help & exit
    cmp Comnd1_Syn,offset RESGROUP:Command_C_Syn
    je  chRet           ; /c found - ignore rest of line
    cmp Comnd1_Syn,offset RESGROUP:Command_K_Syn
    je  chRet           ; /k found - ignore rest of line
    cmp Comnd1_Syn,offset RESGROUP:Command_z_Syn
    je  chRet           ; /c found - ignore rest of line
    jmp chParse         ; anything else - ignore, keep looking

chHelp:
    mov si,offset RESGROUP:HelpMsgs ; SI = ptr to msg ptr list
chHelpNext:
    lodsw                   ; AX = ptr to msg
    or  ax,ax
    jz  chHelpDone          ; end of list - all done
    mov dx,ax               ; DX = ptr to msg
    call    RPrint              ; display msg
    jmp chHelpNext          ; go do next msg
chHelpDone:
    int 20h             ; terminate program

chRet:  ret

CheckHelp       endp

st_invalid macro
        mov     ax,0ffffh
        push    ax
        push    ax
endm

st_valid macro
        push    bx
        push    cx
endm

CleanForStd macro
        add     sp,12
endm

;***    CheckZSwitch -  Handle special /Z switch of command.com.
;           This switch has been added for SCS functionality
;           such that DOS apps can exec non-dos apps and
;           still leave DOS in a consistant state such that
;           it can be re-entered.
;
;   ENTRY   command-line tail at 81h
;
;   EXIT    non-dos binary is execed and command.com terminates after
;       non-dos binary completes.
;
;   EFFECTS

CheckZSwitch    proc
    assume  cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP

    mov si,81h          ; DS:SI = ptr to command-line tail
    mov di,offset RESGROUP:Parse_Command
                    ; ES:DI = ptr to primary parse block
    xor cx,cx           ; CX = # positional param's found
    xor dx,dx           ; DX will be ptr to result buffer

czParse:
    call    Init_Parse      ; call system parser

    cmp ax,END_OF_LINE
    je  czRet           ; end of command line, no /? found
    cmp ax,RESULT_NO_ERROR
    je  czWhich         ; valid syntax element found
    jmp short czRet

czWhich:
    cmp Comnd1_Syn,offset RESGROUP:Command_z_Syn
    je  czSwitch
    jmp short czRet

czSwitch:
        push    bp
        xor     bx,bx
        mov     si,bx
        mov     bp,bx
        mov     ax,5303h
        int     21h
        jnc     st_stdin
        st_invalid
        jmp     short go_stdout
st_stdin:
        st_valid
go_stdout:
        mov     bx,1
        mov     ax,5303h
        int     21h
        jnc     st_stdout
        st_invalid
        jmp     short go_stderr
st_stdout:
        st_valid
go_stderr:
        mov     bx,2
        mov     ax,5303h
        int     21h
        jnc     st_stderr
        st_invalid
        jmp     short std_done
st_stderr:
        st_valid
std_done:
    mov ah,19h
    int 21h
        mov     si,84h                  ; 84h because that is where the real
                                        ; command starts (i.e. 7/z\bfoo.exe)
    mov bx,ds:2ch
        mov     bp,sp
    push    es
        mov     es,bx
        xor     ah,ah                   ; no "cmd /c"
    CMDSVC  SVC_CMDEXEC     ; Exec non-dos binary
    pop es          ; ds:si is command tail (DOS_style)
                    ; es    is env segment
                                        ; al = current drive
                                        ; ss:bp = std handles
                                        ; returns al = return code
        lahf
        CleanForStd
        pop     bp
        sahf
    jc  czReEnter

    mov ah,4ch
    int 21h

czRet:  ret

czReEnter:
        xor     ah,ah
        mov     [SCS_REENTERED],3
    mov byte ptr ds:80h,0
    ret

CheckZSwitch    endp

;***** Setup_res_end -- This routine determines the resident size of COMMAND.
; It determines based on 2 factors:
;   1. Is this is the first COMMAND?
;   2. Is COMMAND to be loaded into HIMEM?
;   The strategy works as follows:
;
;   if ( First COMMAND)
;   then if (COMMAND in HIMEM)
;       ResSize = resident_data;
;        else
;       ResSize = resident_data + resident_code;
;   else
;      ResSize = resident_data;
;
; Int 2fh calls have been added to determine whether or not we are the first
;COMMAND and whether DOS is in HIMEM.
;
;   ENTRY: ResMsgEnd = resident size of data in paras
;
;   EXIT:  ResSize = resident size in low memory
;
;   REGISTERS AFFECTED: ax,cx,dx
;

; NTVDM use diff al value so we don't confuse dos 5.0
; NTVDM command.com GET_COMMAND_STATE       equ     5500h
GET_COMMAND_STATE       equ     5501h
GET_HMA_ADDR        equ 4a02h

Setup_res_end   proc    near

    push    ds
    mov ax,cs
    mov ds,ax               ;ds = RESGROUP
    assume  ds:RESGROUP

    mov cx,ResMsgEnd            ;set resident size = data

;M042 -- Begin changes
;If messages are to be kept behind, we need to round up the messages to
;the next para boundary. This is because we have a dummy segment between the
;data and the resident code segment so that the code segment starts on a
;para boundary
;
    cmp cx,offset RESGROUP: ExtMsgEnd   ;messages to be resident?
    jne calc_res            ;no, continue
    add cx,15               ;round up
    and cx,0fff0h
calc_res:
;
;M042 -- End changes
;
    xor ax,ax
        cmp FirstCom,1          ;is it first command.com?
    jnz not_first           ;no, do not keep code
;
;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
;bit 4 of dh is set
;
    push    bx
    push    cx
    mov ax,(SET_CTRL_C_TRAPPING shl 8) or 06h ;is DOS in HIMEM? ;M013
    int 21h
    pop cx
;bugbug: remove version check after testing
    cmp bl,5                ;bl has true version ; M013
    jb  oldver

    xor ax,ax
    and dh,10h              ;is DOS in HMA ; M013
    pop bx
    jnz not_first           ;DOS in HIMEM, code not
                        ;   resident

    mov ax,offset CODERES: EndCode      ;size of code in bytes
not_first:
;
;Note that ax = 0(side effect of int 2fh), if the code is not to be retained
;
    add cx,ax
    add cx,15               ;round up to next para
    shr cx,1
    shr cx,1
    shr cx,1
    shr cx,1                ;ax = para size of res code
    mov ResSize,cx          ;store resident size

    pop ds
    assume  ds:nothing
    ret
;bugbug: remove this code (for version independent COMMAND) after testing
oldver:
    pop bx
    mov ax,offset CODERES: EndCode      ;size of code in bytes
        jmp short not_first

setup_res_end   endp


;*** Move_res_code -- This routine moves the resident code to its final
; location. We check if DOS is in HIMEM. If so, we try to load ourselves
; in HIMEM. If we fail, then we remain low and update ResSize to reflect
; the correct resident size. When remaining low, we have to check if we
; need to overlay the messages part of the data segment which is determined
; by the /msg switch.
;
;   ENTRY: ResMsgEnd = end of resident data
;
;   EXIT:  The resident code is either up high or in its final location
;       down low.
;
;   REGISTERS AFFECTED: ax,bx,cx,dx,si,di
;

Move_res_code   proc    near

    push    ds
    push    es

    mov ax,cs
    mov ds,ax
    assume  ds:RESGROUP

    mov ax,(SET_CTRL_C_TRAPPING shl 8) or 06h ; M013
    int 21h             ;DOS in HIMEM?

    and dh,10h              ; M013
    jnz move_high           ;yes, move code high

;
;Check if messages have been discarded or not
;
load_low:
    push    ds
    pop es              ;es = RESGROUP
    mov di,ResMsgEnd            ;end offset in DATARES
    mov bx,offset RESGROUP: ExtMsgEnd   ;end offset of messages

    cmp di,bx               ;are messages to be kept?
    jz  no_move         ;yes, dont move code

    jmp short setup_move            ;es:di points at dest.

move_high:

;
;We have to call DOS to get the load address in HIMEM for COMMAND
;We pass in bx the number of bytes we need
;
    mov bx,offset CODERES: EndCode

;M030;
; Set di=0ffffh so that we load low in case no one answers this int 2fh
;
    mov di,0ffffh           ;DT - in case no-one handles
                        ;this ; M030
    mov ax,GET_HMA_ADDR
    int 2fh

;
;If the offset = 0xffff, then no HMA available
;
    cmp di,0ffffh           ;HMA available?
    mov ComInHMA,1          ;assume command.com in HMA
    jnz setup_move          ;no error, es:di = memory

    mov ComInHMA,0          ;could not load in HMA
;
;Zero means that we do not have enough HIMEM. Remain low and update
;ResSize to reflect this
;
    mov cx,ResMsgEnd            ;size of data in bytes
    mov ax,offset CODERES: EndCode      ;size of code in bytes

    add cx,ax
    add cx,15               ;round up to next para
    shr cx,1
    shr cx,1
    shr cx,1
    shr cx,1                ;ax = para size of res code
    mov ResSize,cx          ;store resident size
    jmp short load_low          ;let code remain low

no_move:
    mov cl,4
    add di,0fh
    and di,0fff0h           ;round it to a para offset
    jmp short patch_up

setup_move:
    mov si,offset RESGROUP: StartCode
    mov cx,offset CODERES: EndCode      ;cx = bytes to move

    cld
    push    di              ;need di for patching offset
    rep movsb
    pop di

patch_up:
    call    patch_stub
    pop es
    pop ds
    assume  ds:nothing
    ret

Move_res_code   endp


;*** Alloc_env -- This routine allocates the temporary environment for the
; Init code to initialize the COMSPEC. This is not a complete environment.
; Later on, at EndInit time, a proper sized environment is allocated and
; the contents of this temporary environment are copied to it. This routine
; will not be called in case a valid environment is passed to command.com
;
;   ENTRY:  None
;
;   EXIT:   ax = segment of allocated environment segment
;
;   REGISTERS AFFECTED: ax,bx,cx
;

Alloc_env   proc    near

    push    ds
    push    es
    push    si
    push    di

;
;Allocate default environment size
;
    mov bx,SIZE Environment / 16        ;temp env size in paras
    mov ah,ALLOC
    int 21h
    jc  init_nomem          ;insufficient memory, error

    mov es,ax
    assume  es:nothing          ;es = temp env segment
    xor di,di
    mov ax,di
;
;First clear out the entire buffer
;
    mov cx,SIZE Environment
    rep stosb

;
;Init. the path string (PATH=) first
;

    push    ss              ; M026
    pop ds              ; ds = RESGROUP ; M026
    assume  ds:RESGROUP         ; M026
    mov si,offset RESGROUP: PathString  ;ds:si = "PATH=\0"
    mov di,Env_Pathstring           ;offset of Path in env seg
pathlp:
    lodsb
    stosb
    or  al,al               ;end of string?
    jnz pathlp              ;no, continue transfer
;
;Init. the Comspec string
;
    mov si,offset RESGROUP: ComspString ;"COMSPEC=\COMMAND.COM\0"
    mov di,Env_Comstring            ;location of Comspec string
comsplp:
    lodsb
    stosb
    or  al,al               ;end of string?
    jnz comsplp

    mov ax,es               ;return env seg in ax

    pop di
    pop si
    pop es
    pop ds
    assume  ds:nothing
    ret

init_nomem:
;
;We call the error routine from here. This routine never returns. It either
;terminates COMMAND with error( if it is not the first invocation ) or hangs
;the system ( if it is the first COMMAND.COM ).
;
    call    alloc_error

Alloc_env   endp

;*** Alloc_error: This routine just jumps to the actual label where we
; check if this is a permanent or secondary command.com and take the
; appropriate action.
;
;   ENTRY:  ds = RESGROUP = DATARES
;
;   EXIT:   None - does not return
;
;   REGISTERS AFFECTED: Does not matter
;

public Alloc_error
Alloc_error proc    near

    jmp RESGROUP:BadMemErr

Alloc_error endp

;*** Patch_stub -- This routine patches in the segment and offset values in
; the stub table of the various entry points in the resident code segment.
; Some of them are interrupt entry points and some of them are entries from
; the transient to the resident code segment.
;
;   ENTRY:  ds = RESGROUP
;       es:di = segment:offset of final location of resident code
;
;   EXIT:   All segments and offsets patched into the stub table
;
;   REGISTERS AFFECTED: ax, bx, cx, dx, si, di
;
;
Patch_stub  proc    near

    assume  ds:RESGROUP

    push    es

    mov bx,es           ;bx = resident code segment
    mov dx,di
    mov di,offset DATARES:Int2f_Entry
    mov si,offset RESGROUP:Reloc_Table
    push    ds
    pop es          ;es = RESGROUP = DATARES
;
;bx:dx = segment:offset of resident code segment
;es:di = entry point table in stub
;ds:si = offset table in INIT segment -- offsets of code entry points now
;
    mov cx,NUM_RELOC_ENTRIES        ;number of entry points
patchlp:
    lodsw               ;get current offset
    add ax,dx           ;offset it by code seg location
    stosw               ;store offset
    mov ax,bx
    stosw               ;store segment
    loop    patchlp

    pop es
    ret

Patch_stub  endp

;*** Patch_segs -- This routine patches the segment values in the dword
; pointers that the stub uses to jump to the actual handler. These values
; are temporarily needed to handle these interrupts if they occur before
; the resident is relocated to its final position and all the addresses of
; the handlers have been updated.
;
;   ENTRY:  es = PSP segment = code segment
;
;   EXIT:   Current segment values patched into the jump table in the
;       stub.
;
;   REGISTERS AFFECTED: ax, cx, di
;

Patch_segs  proc    near

    mov di,offset RESGROUP:Int2f_Entry
    mov cx,4            ;we have to patch 4 handlers
    add di,2
    mov ax,es

pseglp:
    stosw               ;store the segment value
    add di,2            ;skip the next offset value
    loop    pseglp

    ret

Patch_segs  endp


;*** get_XMMAddr -- This routine gets the call address for the XMM driver
; by issuing the appropriate int 2fh. This is stored in a stub variable
; and is used by the stub when we have to jump to the resident in HMA
;
;   ENTRY:  ds = RESGROUP
;
;   EXIT:   XMMCallAddr = XMM driver far call address
;
;   REGISTERS AFFECTED:
;

get_XMMAddr proc    near
    assume  ds:RESGROUP

    push    es

    mov ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
    int 2Fh
    cmp al,80h          ; Q: installed
    jne short cXMMexit  ;   N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
    mov ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
    int 2Fh

    mov word ptr [XMMCallAddr], bx
    mov word ptr [XMMCallAddr+2],es

cXMMexit:
    pop es
    ret             ; done

get_XMMAddr endp


; IRename
; Input : ds:dx - Existing File
;     ds:di - NewFile
; Output  None
;


IRename proc near

    mov ah,56h
    push    ds
    pop es
    int 21h
    ret

IRename endp

; IAccess
; Input : ds:dx - file name
; Output  CY Set if file not found
;     CY Clear if file found

IAccess proc near

    mov ax,4300h
    int 21h
    ret

IAccess endp

; IDelete
; Input   ds:dx - file to delete
; Output  None

IDelete proc near

    mov ah,41h
    int 21h
    ret

IDelete endp

INIT    ENDS

    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\iparse.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)iparse.asm 4.1 87/04/28
;	SCCSID = @(#)iparse.asm 4.1 87/04/28
TITLE	COMMAND interface to SYSPARSE

.xlist
.xcref
	INCLUDE comseg.asm		;AN000;
.list
.cref


INIT		SEGMENT PUBLIC PARA	;AN000;

ASSUME	CS:RESGROUP,DS:RESGROUP,ES:NOTHING,SS:NOTHING	;AN000;


;AD054; public	SYSPARSE		;AN000;

	DateSW	equ	0		;AN000; do not Check date format
	TimeSW	equ	0		;AN000; do not Check time format
	CmpxSW	equ	0		;AN000; do not check complex list
	KeySW	equ	0		;AN025; do not support keywords
	Val2SW	equ	0		;AN025; do not Support value definition 2
	Val3SW	equ	0		;AN000; do not Support value definition 3
	QusSW	equ	0		;AN025; do not include quoted string
	DrvSW	equ	0		;AN025; do not include drive only

.xlist
.xcref
;AD054; INCLUDE parse.asm		;AN000;
.list
.cref


INIT	    ends			;AN000;
	    end 			;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\loadhi.asm ===
page	,132
	title	LOADHIGH Internal Command
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;************ LOADHIGH command -- loads programs into UMBs.
;
comment %==================================================================

This is a new module added to support loading programs into UMBs provided
by DOS 5.0. 

Usage:

LOADHIGH <filespec>

<filespec> has to be a filename that is not wildcarded.


==========================================================================%

;
;	Revision History
;	================
;
;	M009	SR	08/01/90	Set flags to indicate that we are
;				loading and high and also remember
;				current UMB state.
;
;	M016	SR	08/09/90	Give special error message on attempt
;				to loadhigh batch files and invalid
;				filename on Loadhigh command line.
;
;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
;				after the program name also as part
;				of the command line being passed to
;				the program to be invoked.
;


;*** INCLUDE FILES


	.xlist
	.xcref

	include	comseg.asm
	include	comequ.asm
	include	dossym.inc
	include	syscall.inc
	include arena.inc

	.list
	.cref

;*** EQUATES AND STRUCTURES

NUM_LH_SWS	equ	5	;number of valid switches


ResultBuffer	struc		; structure of parse result buffer

ValueType	db	?
ValueTag	db	?
SynPtr		dw	?
ValuePtr	dd	?

ResultBuffer	ends


DATARES		segment

	extrn	LoadHiFlg	:BYTE

DATARES		ends


TRANDATA		segment

	extrn	ComExt		:BYTE
	extrn	ExeExt		:BYTE
	extrn	Extend_Buf_Ptr	:WORD
	extrn	Msg_Disp_Class	:BYTE
	extrn	Parse_LoadHi	:BYTE
	extrn	NoExecBat_Ptr	:WORD	; M016
	extrn	LhInvFil_Ptr	:WORD	; M016

TRANDATA		ends

TRANSPACE	segment

	extrn	ResSeg		:WORD
	extrn	ExecPath	:BYTE
	extrn	Comsw		:WORD
	extrn	Arg		:BYTE
	extrn	SwitChar	:BYTE	; M039

TRANSPACE	ends

TRANCODE		segment

	extrn	Cerror:near
	extrn	Parse_With_Msg:near
	extrn	Lh_Execute:near			;new execute label; M051
	extrn	Path_Search:near

	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP

;****	LoadHigh -- Main routine for Loadhigh command
;
;	ENTRY	Command line tail is at PSP:81h terminated by 0dh
;		CS = DS = SS = TRANGROUP
;
;	EXIT	None
;
;	USED	ax, bx, cx, dx, si, di, es
;
;	ERROR EXITS
;		Message pointers are setup at the error locations and then
;	we jump back to CERROR which is the transient error recycle point.
;	Apart from parse errors, the other errors handled are too many
;	switches anf invalid filenames.
;
;	EFFECTS
;		The allocation strategy and the state of the arena chain are
;	put in the requested state according to the given options. If a 
;	filename is also given, it is executed as well.
;
;

	public	LoadHigh

LoadHigh		proc	near

	push	ds
	pop	es
	assume	es:TRANGROUP
;
;M039
; Get command tail to be passed to the program. This includes any whitespace
;chars between the program name and its parameters as well.
;On return, ds:si points at the start of the command tail.
;
	call	GetCmdTail		;Get command tail for pgm ;M039
	push	si			;save its start offset ;M039

	call	ParseLhCmd		;parse the command line
	pop	si			;restore start offset ;M039
	jc	LhErr			;error parsing, abort

	call	SetupCmdLine		;setup pgm's command line

	call	SetupPath		;setup path for file
	jc	LhErr			;file not found

;
;Set allocation strategy to HighFirst and link in UMBs for exec. This will
;be reset after return from the Exec
;We will also set a resident flag to indicate that UMBs were activated for
;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
;
	call	SetupUMBs		;set alloc strat & link state

	jmp	Lh_Execute		;go and exec file ;M051

LhErr:
;
;The error message has been setup at this stage
;
	jmp	Cerror			;print error message and recycle 
					
LoadHigh		endp


;*** 	ParseLhCmd	-- calls system parser to parse command line
;
;	ENTRY	Parse block Parse_LoadHi setup
;
;	EXIT	Carry clear -- command line parsed successfully
;		Carry set -- appropriate error message setup
;
;	USED	di, cx, bx, ax, si, dx
;
;	EFFECTS
;		Options set up
;		Filename to be executed setup
;


ParseLhCmd	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	si,81h			;ds:si points at command line
	mov	Comsw,0		;clear switch indicator
	mov	di,offset TRANGROUP:Parse_LoadHi ;es:di = ptr to parse blk
	xor	cx,cx			;no positionals found yet
lhParse:
	call	Parse_With_Msg
	cmp	ax,END_OF_LINE
	je	lhpRet			;EOL encountered, return(no carry)
	cmp	ax,RESULT_NO_ERROR
	jne	lhperrRet		;parse error, return
;
;Parse call succeeded.  We have a filespec
;DX = ptr to result buffer
;
	mov	bx,dx			;BX = ptr to parse result buffer
	call	LhCopyFilename		;copy filename into our buffer
	jc	lhpRet			;bad filename, return
	jmp	short lhpRet		;done parsing, return (no error)

lhperrRet:
	stc
lhpRet:
	ret

	
ParseLhCmd	endp


;***	Lh_On -- Activate allocation of UMBs
;
;	ENTRY	None
;
;	EXIT	None
;
;	USED	
;
;	EFFECTS
;		Allocation strategy is set to HighFirst
;

Lh_On		proc 	near

	mov	ax,(ALLOCOPER shl 8) OR 0
	int	21h			;get alloc strategy

	mov	bx,ax
	or	bx,HIGH_FIRST		;set alloc to HighFirst

	mov	ax,(ALLOCOPER shl 8) OR 1
	int	21h			;set alloc strategy

	ret
Lh_On	endp


;***	Lh_Link -- links UMBs to arena
;
;	ENTRY	None
;
;	EXIT	None
;
;	USED	ax, bx
;
;	EFFECTS
;		UMBs are linked into the DOS arena chain
;

Lh_Link		proc	near

	mov	ax,(ALLOCOPER shl 8) OR 3
	mov	bx,1
	int	21h			;link in UMBs

	ret

Lh_Link		endp


;***	LhCopyFilename -- copy filename from command line to buffer
;
;	ENTRY	ds:bx points at parse result block
;
;	EXIT	CY set -- filename has wildcards
;			   Setup for error message
;
;	USED	ax
;
;	EFFECTS
;		ExecPath contains the filename
;

LhCopyFilename	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	push	ds
	push	si
	push	di

	lds	si,[bx].ValuePtr
	mov	di,offset TRANGROUP:ExecPath

movlp:
	lodsb
;
;If there are any wildcards in the filename, then we have an error
;
	cmp	al,'*'			;wildcard?
	je	lhfilerr		;yes, error
	cmp	al,'?'			;wildcard?
	je	lhfilerr		;yes, error

	stosb				;store char
	or	al,al			;EOS reached?
	jnz	movlp			;no, continue

	clc				;indicate no error
lhcopyret:
	pop	di
	pop	si
	pop	ds
	ret

lhfilerr:
	mov	dx,offset TRANGROUP:LhInvFil_Ptr ; "Invalid Filename" ; M016
	stc
	jmp	short lhcopyret

LhCopyFilename	endp

;
;M039; Begin changes

;*** 	GetCmdTail -- scan through the command line looking for the start
;	of the command tail to be passed to program that is to be invoked.
;
;	ENTRY	ds = TRANGROUP
;		At ds:80h, command tail for lh is present.
;
;	EXIT	ds:si points at the command tail for program
;
;	USED
;

GetCmdTail	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	si,81h			;ds:si = command line for lh

	invoke	scanoff		;scan all delims before name
;
; Skip over the program name until we hit a delimiter
;
lhdo_skipcom:
	lodsb			   	; 
	invoke	delim		   	;is it a delimiter? 
	jz	scandone	   	;yes, we are done 
	cmp	AL, 0DH 	   	;end of line? 
	jz	scandone	   	;yes, found command tail
	cmp	al,SwitChar	   	;switch char?
	jnz	lhdo_skipcom		;no, continue scanning

scandone:
	dec	si			;point at the command tail start

	ret

GetCmdTail	endp

;M039; End changes
;

;***	SetupCmdLine -- prepare command line for the program
;
;	ENTRY	ds:si = points just beyond prog name on command line
;
;	EXIT	None
;
;	USED
;
;	EFFECTS		
;		The rest of the command line following the pgm name is 
;	moved to the top of the command line buffer (at TRANGROUP:80h)
;	and a new command line length is put in
;

SetupCmdLine	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP
	
	mov	di,81h
	xor	cl,cl
	dec	cl			;just CR means count = 0
stcllp:
	lodsb
	stosb
	inc	cl			;update count

	cmp	al,0dh			;carriage return?
	jne	stcllp			;no, continue storing

	mov	es:[80h],cl		;store new cmd line length

	ret

SetupCmdLine	endp



;***	LhSetupErrMsg -- Sets up error messages
;
;	ENTRY	ax = error message number
;
;	EXIT	None
;
;	USED	dx
;
;	EFFECTS
;		Everything setup to display error message
;

LhSetupErrMsg	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	msg_disp_class,EXT_MSG_CLASS
	mov	dx,offset TranGroup:Extend_Buf_ptr
	mov	Extend_Buf_ptr,ax

	ret

LhSetupErrMsg	endp

;
;M009; Start of changes
;

;***	GetUMBState -- get the current alloc strat and link state
;
;	ENTRY	None
;
;	EXIT	al contains the status as follows:
;			b0 = 1 if Alloc strat is HighFirst
;			   = 0 if alloc strat is LowFirst
;			b1 = 1 if UMBs are linked in
;			   = 0 if UMBs are unlinked
;
;	USED	ax, bx
;

GetUMBState	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

	mov	ax,(ALLOCOPER shl 8) OR 0		;get alloc strat
	int	21h
	mov	bl,al

	mov	ax,(ALLOCOPER shl 8) OR 2		;get link state
	int	21h
	mov	bh,al

	xchg	ax,bx				;ax contains the state
	rol	al,1				;get HighFirst state in b0
	and	al,01				;mask off b1-b7
	shl	ah,1				;linkstate in b1
	or	al,ah				;b0=HighFirst, b1=Linkstate

	ret

GetUMBState	endp

;
; M009; End of changes
;


;***	SetupUMBs -- set allocation strategy to HighFirst and link in UMBs to
;	DOS arena to load the program into UMBs
;
;	ENTRY	None
;
;	EXIT	None
;
;	USED	
;
;	EFFECTS
;		Allocation strategy set to HighFirst
;		UMBs linked into DOS arena

SetupUMBs	proc	near
	assume	ds:TRANGROUP

	push	ds

	call	GetUMBState		;get current state of UMBs ;M009

	mov	ds,ds:ResSeg		; M009
	assume	ds:DATARES		; M009
	mov	LoadHiFlg,al		; M009
	or	LoadHiFlg,80h		;indicate loadhigh issued ; M009

	pop	ds
	assume	ds:TRANGROUP

	call	Lh_On			;alloc strategy to HighFirst
	call	Lh_Link		;link in UMBs

	ret

SetupUMBs	endp

;***	SetupPath -- Do path search for the file to be executed
;
;	ENTRY	None
;
;	EXIT	Carry set if file not found or not executable file
;
;	EFFECTS
;		ExecPath contains the full path of the file to be executed
;

SetupPath	proc	near
	assume	ds:TRANGROUP, es:TRANGROUP

;
;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
;because the path search routine that we are about to invoke expects the
;filename to search for to be argv[0]
;
	mov	ax,arg.argvcnt		;total number of arguments
	dec	ax			;less one - skip "LoadHigh"
	mov	bx,SIZE Argv_ele
	mul	bx			;dx:ax = size of argument lists

;
;Move argv[1]..argv[n] to argv[0]..argv[n-1]
;
	mov	di,offset TRANGROUP:Arg
	mov	si,di
	add	si,SIZE Argv_ele
	mov	cx,ax			;size to move

	cld
	rep	movsb			;Move the argument list

	dec	arg.argvcnt		;fake one less argument

	call	path_search		;look in the path
;
;ax = 0, no file found
;ax < 4, batch file found -- cant be executed
;ax = 4,8 => .com or .exe file found
;
	or	ax,ax			;any file found?
	jz	no_exec_file		;no, error

	cmp	ax,4			;executable file?
	jl	no_exec_bat		;no, indicate fail ; M016

	clc
	ret

no_exec_bat:				; M016
	mov	dx,offset TRANGROUP:NoExecBat_Ptr ;Setup message ptr ; M016
	jmp	short lhsp_errret		;return error; M016

no_exec_file:
	mov	ax,ERROR_FILE_NOT_FOUND
	call	LhSetupErrMsg		;setup error message

lhsp_errret:				; M016
	stc
	ret

SetupPath	endp



TRANCODE		ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\parse2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)parse.asm	1.1 85/05/14
;	SCCSID = @(#)parse.asm	1.1 85/05/14
.sall
.xlist
.xcref
    INCLUDE DOSSYM.INC
    INCLUDE DEVSYM.INC
    include comsw.asm
    include comseg.asm
    include comequ.asm
.list
.cref


break <Parse.Asm>
;----------------------------------------------------------------------------
;    PARSE.ASM contains the routines to perform command line parsing.
;    Parse and Path share a buffer and argv[] definitions.
;   Invoking <Parseline> maps the unparsed command line in COMBUF into an
;   array of pointers to the parsed tokens.  The resulting array, argv[],
;   also contains extra information provided by cparse about each token
;   <Parseline> should be executed prior to <Path_Search>
;
; Alan L, OS/MSDOS				    August 15, 1983
;
;
; ENTRY:
;   <Parseline>:	    command line in COMTAB.
; EXIT:
;   <Parseline>:	    success flag, argcnt (number of args), argv[].
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

DATARES 	SEGMENT PUBLIC BYTE
	EXTRN	FORFLAG:BYTE
DATARES     ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	combuf:byte
	EXTRN	cpyflag:byte
	EXTRN	expand_star:byte
	EXTRN	RESSEG:word
	EXTRN	STARTEL:word
TRANSPACE   ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;
	PUBLIC	argv_calc		; convert array index into address
	PUBLIC	parseline


assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing


break <Parseline:  Munch on the command line>
;----------------------------------------------------------------------------
;    PARSELINE takes an MSDOS command line and maps it into a UNIX-style
; argv[argvcnt] array.	The most important difference between this array and
; the tradition UNIX format is the extra cparse information included with
; each argument element.
;---------------
; ENTRY:
;	(BL	     special delimiter for cparse -- not implemented)
;---------------
; EXIT:
;	CF	    set if error
;	AL	    error code (carry set).  Note AH clobbered in any event.
;	argv[]	    array of cparse flags and pointers to arguments
;	argvcnt     argument count
;---------------
; NOTE(S):
;	*   BL (special delimiter) is ignored, for now (set to space).
;	*   Parseflags record contains cparse flags, as follows:
;		sw_flag 	--	was this arg a switch?
;		wildcard	--	whether or not it contained a * or ?
;		path_sep	--	maybe it was a pathname
;		unused		--	for future expansion
;		special_delim	--	was there an initial special delimiter?
;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
;	*   Relationship between input, cparse output, and comtail can be
;	    found in the following chart.  Despite the claim of the cparse
;	    documentation that, "Token buffer always starts d:  for non switch
;	    tokens", such is not the case (see column two, row two).
;	    Similarly, [STARTEL] is not null when the command line is one of
;	    the forms, "d:", "d:\", or "d:/".  In fact, *STARTEL (i.e., what
;	    STARTEL addresses) will be null.  This is clearly just a
;	    documentation error.
;	*   cparse also returns a switch code in BP for each switch it
;	    recognizes on the command line.
;	*   arglen for each token does NOT include the terminating null.
;	*   Finally, note that interesting constructions like 'foodir/*.exe'
;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
;	    echo 'foodir', then '*', then '.exe'.  Using cparse for command-
;	    line parsing may result in slightly different behavior than
;	    previously observed with the old COMMAND.COM command-line parser.
;
;	    Input		    Cparse		Command Line (80H)
;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
;	alan\foo.bat		alan\foo.bat		alan\foo.bat
;	foo.bat 		foo.bat 		foo.bat
;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
;	c:foo.bat		c:foo.bat		c:foo.bat
;---------------
; CONSTANTS:
;---------------
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	argbufptr:word
	EXTRN	comptr:word
	EXTRN	last_arg:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

;---------------
parseline:
;---------------

	push	AX				; most of these are clobbered
	push	BX				; by cparse...
	push	CX
	push	DX
	push	DI
	push	SI
	pushf
	mov	cpyflag,0			; Turn "CPARSE called from COPY flag" off

	mov	[LAST_ARG], -1			; last argument at which to accumulate
	xor	ax,ax
	mov	cx,SIZE arg_unit
	mov	di,offset trangroup:arg
	rep	stosb
	mov	argbufptr,offset trangroup:arg.argbuf
	mov	arg.argswinfo, 0		; switch information, and info to date
	mov	arg.argvcnt, 0			; initialize argvcnt/argv[]
	mov	SI, OFFSET TRANGROUP:combuf+2	; prescan leaves cooked input in combuf

; This next section of code (up to pcont:)  makes sure that si is set up for
; parsing.  It should point at COMBUF if FORFLAG is set and arg.argforcombuf
; otherwise.  This is done so that commands can get arg pointers into their
; original command line (or an exact copy of it) in arg_ocomptr.
; Arg.argforcombuf is used so that the for loop processor will always be able
; to get a hold of its original command line; even after COMBUF is blasted by
; the command to be repeated or the transient part of command has been
; reloaded.

	push	ds
	mov	ds,[RESSEG]
	assume	ds:resgroup
	cmp	FORFLAG,0
	pop	ds
	assume	ds:trangroup
	jnz	pcont
	mov	di,OFFSET TRANGROUP:arg.argforcombuf
	xor	ch,ch
	mov	cl,[COMBUF+1]
	inc	cl
	rep	movsb
	mov	si,OFFSET TRANGROUP:arg.argforcombuf

pcont:
	mov	DI, OFFSET TRANGROUP:tpbuf	; destination is temporary token buffer
	mov	BL, ' '                         ; no special delimiter, for now

parseloop:
	mov	comptr,si			; save ptr into original command buffer
	xor	BP, BP				; switch information put here by cparse
	mov	byte ptr [expand_star],0	; don't expand *'s to ?'s
	invoke	scanoff 			; skip leading blanks...
	invoke	cparse				; byte off a token (args in SI, DI, BL)
	jnc	More_prse
	or	BP,BP				; Check for trailing switch character
	jz	parsedone
	call	newarg				; We hit CR but BP is non-zero. The
						;   typical cause of this is that a
						;   switch char IMMEDIATELY preceeds
						;   the CR. We have an argument, but it
						;   is sort of an error.
	jmp	short parsedone 		; We're done (found the CR).

More_prse:
	mov	cpyflag,2			; tell CPARSE that 1st token is done
	call	newarg				; add to argv array (CX has char count)
	jnc	parseloop			; was everything OK?
	jmp	short parse_error		; NO, it wasn't -- bug out (CF set)

parsedone:					; successful completion of parseline
	popf
	clc
	jmp	short parse_exit

parse_error:					; error entry (er, exit) point
	popf
	stc
parse_exit:					; depend on not changing CF
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret

;---------------
; parseline ends
;----------------------------------------------------------------------------


break <NewArg>
;----------------------------------------------------------------------------
;   NEWARG adds the supplied argstring and cparse data to arg.argv[].
; ENTRY:
;   BH			argflags
;   CX			character count in argstring
;   DI			pointer to argstring
;   comptr		ptr to starting loc of current token in original command
;   [STARTEL]		cparse's answer to where the last element starts
; EXIT:
;   argbufptr		points to next free section of argbuffer
;   arg.argbuf		contains null-terminated argument strings
;   arg.argvcnt 	argument count
;   arg.argv[]		array of flags and pointers
;   arg.arg_ocomptr	ptr to starting loc of current token in original command
;   CF			set if error
;   AL			carry set:  error code; otherwise, zero
;---------------
newarg:
;---------------

	push	BX
	push	CX
	push	DX				; one never knows, do one?
	push	DI
	push	SI
	pushf
	call	arg_switch			; if it's a switch, record switch info
						; LEAVE SWITCH ON COMMAND LINE!!
;;;	jc	newarg_done			; previous arg's switches -- and leave

	cmp	arg.argvcnt, ARGMAX		; check to ensure we've not
	jge	too_many_args			; exceeded array limits
	mov	DH, BH				; save argflags
	mov	BX, arg.argvcnt 		; argv[argvcnt++] = arg data
	inc	arg.argvcnt
	mov	AX, OFFSET TRANGROUP:arg.argv
	call	argv_calc			; convert offset to pointer
	mov	[BX].argsw_word, 0		; no switch information, yet...
	mov	[BX].arglen, CX 		; argv[argvcnt].arglen = arg length
	mov	[BX].argflags, DH		; argv[argvcnt].argflags = cparse flags
	mov	SI, argbufptr
	mov	[BX].argpointer, SI		; argv[argvcnt].argpointer = [argbufptr]
	add	SI, [STARTEL]			; save startel from new location
	sub	SI, DI				; form pointer into argbuf
	mov	[BX].argstartel, SI		; argv[argvcnt].argstartel = new [STARTEL]
	mov	si,[comptr]
	mov	[BX].arg_ocomptr,si		; arg_ocomptr=ptr into original com line

	mov	SI, DI				; now save argstring in argbuffer
	mov	DI, argbufptr			; load the argbuf pointer and make
	add	DI, CX				; sure we're not about to run off
	cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
	jge	buf_ovflow			; the end of the buffer (plus null byte)
	sub	DI, CX				; adjust the pointer
	cld
	rep	movsb				; and save the string in argbuffer
	mov	AL, ANULL			; tack a null byte on the end
	stosb
	mov	argbufptr, DI			; update argbufptr after copy

newarg_done:
	popf
	clc
	jmp	short newarg_exit

too_many_args:
	mov	AX, arg_cnt_error
	jmp	short newarg_error

buf_ovflow:
	mov	AX, arg_buf_ovflow

newarg_error:
	popf
	stc

newarg_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret

;---------------
; NewArg ends
;----------------------------------------------------------------------------


break <Arg_Switch>
;----------------------------------------------------------------------------
;   ARG_SWITCH decides if an argument might really be a switch.  In the
; event that it is, and we can recognize
; ENTRY:
;   As in <newarg>.
; EXIT:
;   CF	    --	    clear (wasn't a switch); set (was a switch)
; NOTE(S):
;   *	The mechanism mapping a switch into a bit-value depends entirely
;	on the order of definition in the <switch_list> variable and the
;	values chosen to define the bits in CMDT:COMEQU.ASM.  Change either
;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
;	this mechanism.  This code taken from CMDT:TCODE.ASM.
;   *	The <switch_list> declared below is redundant to one declared in
;	TDATA.ASM, and used in TCODE.ASM.
;   *	An ugly routine.
;---------------
; CONSTANTS:
;---------------
;   Constants come from the definitions in CMDT:COMEQU.ASM.
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE		;AC000;
    extrn   switch_list:byte
    switch_count    EQU     $-switch_list
transpace   ends

;---------------
Arg_Switch:
;---------------

	push	AX
	push	BX
	push	CX
	push	DI
	pushf
	test	BH, MASK sw_flag		; is it a switch? (preserve flag word)
	jz	arg_no_switch0
	cmp	[LAST_ARG], -1			; have we encountered any REAL args yet?
	je	arg_no_switch1			; no, so leading switches don't matter
	mov	BX, [LAST_ARG]			; yes, add switch info to last REAL arg
	mov	AX, OFFSET TRANGROUP:arg.argv
	call	argv_calc
	or	[BX].argsw_word, BP
	or	arg.argswinfo, BP

arg_yes_switch: 				; ah, sweet success...
	popf
	stc
	jmp	short arg_switch_exit

arg_no_switch0:
	mov	AX, arg.argvcnt 		; future switches should then affect
	mov	[LAST_ARG], AX			; this argument

arg_no_switch1: 				; wasn't a switch, or we're pretending
	popf
	clc

arg_switch_exit:
	pop	DI
	pop	CX
	pop	BX
	pop	AX
	ret

;---------------
; Arg_Switch ends
;----------------------------------------------------------------------------


break <Argv_calc>
;----------------------------------------------------------------------------
;   ARGV_CALC maps an array index into a byte-offset from the base of
; the supplied array.  Method used for computing the address is:
;	Array Index * Array Elt Size + Base Addr = Elt Addr
; ENTRY:
;   AX	    --	    base of array
;   BX	    --	    array index
; EXIT:
;   BX	    --	    byte offset
;---------------

argv_calc:
	push	ax				; Save base
	mov	al,bl				; al = array index
	mov	bl,SIZE argv_ele		; bl = size of an argv element
	mul	bl				; ax = base offset
	pop	bx				; Get base
	add	ax,bx				; Add in base offset
	xchg	ax,bx				; Restore ax and put byte offset in bx
	ret

;---------------
; argv_calc ends
;----------------------------------------------------------------------------



trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\path1.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)path1.asm	1.1 85/05/14
;	SCCSID = @(#)path1.asm	1.1 85/05/14
.sall
.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref

break <Path.Asm>
;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation.  Path and
;    Parse share a temporary buffer and argv[] definitions.  <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk.  Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>.  Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory.	This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	baddrv_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	BADPMES_ptr:word
	EXTRN	curdrv:byte
	EXTRN	EXECPATH:byte
	EXTRN	search_best_buf:byte
	EXTRN	search_error:word
	EXTRN	string_ptr_2:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing

break <Path_Search>
;------------------------------------------------------------------------------
;   PATH_SEARCH tries to find the file it's given, somewhere.  An initial value
; of *argv[0].argstartel == 0 implies that there is no command (empty line
; or 'd:'  or 'd:/').  This check is done in strip; otherwise, strip formats
; the filename/pathname into tpbuf.  Search(tpbuf) is executed to see if we
; have a match, either in the current working directory if we were handed
; a filename, or in the specified directory, given a pathname.	If this call
; fails, and we were given a pathname, then Path_Search fails.	Otherwise,
; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
; prefix, we want to skip it) for each pathstring in userpath.	Success on
; either the first invocation of search or on one of the succeeding calls
; sets up the appropriate information for copying the successful pathname
; prefix (if any) into the result buffer, followed by the successful filename
; match (from [search_best_buf]).  The result is returned in in EXECPATH.
; ENTRY:
;   argv[0]		--	command name and associated information
; EXIT:
;   AX			--	non-zero indicates type of file found
;   EXECPATH		--	successful pathname (AX non-zero)
; NOTE(S):
;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
;   2)	Some files are more equal than others.	See search: for rankings.
;   3)	Path_Search terminates as soon as a call to search succeeds, even
;	if search returns an .exe or .bat.
;   5)	Clobbers dma address.

pbuflen         equ     EXECPATHLEN            ; len EXECPATH - ntvdm extended
path_sep_char	equ	';'

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	fbuf:byte
	EXTRN	pathinfo:word
	EXTRN	psep_char:byte
TRANSPACE	ENDS

Procedure   Path_Search,NEAR
	assume	ds:trangroup, es:trangroup

	push	BX
	push	CX
	push	DX				; could use a "stack 'em" instruction
	push	SI
	push	DI
	push	BP
	pushf
	test	DS:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
	jz	path_search_ok

path_failure_jmp:
	jmp	path_failure			; ambiguous commands not allowed

path_search_ok:
	call	store_pchar			; figure out the pathname separator
	mov	DX, OFFSET TRANGROUP:fbuf	; clobber old dma value with
	trap	set_dma 			; a pointer to our dma buffer
	push	ES
	invoke	find_path			; get a handle (ES:DI) on user path
	mov	DS:pathinfo[0], ES		; and squirrel it away
	mov	DS:pathinfo[2], DI		; "old" pathstring pointer
	mov	DS:pathinfo[4], DI		; "new" pathstring pointer
	pop	ES

	mov	BX, pbuflen			; copy/format argv[0] into temp buffer
	mov	SI, OFFSET TRANGROUP:EXECPATH
	invoke	strip
	jc	path_failure_jmp		; if possible, of course

	mov	DX, SI				; search(EXECPATH, error_message)
	mov	[search_error], OFFSET TRANGROUP:BADDRV_ptr
	invoke	search				; must do at least one search
	or	AX, AX				; find anything?
	jz	path_noinit			; failure ... search farther

	mov	BP, AX				; success... save filetype code
	mov	DI, OFFSET TRANGROUP:EXECPATH
	mov	SI, DS:arg.argv[0].argpointer
	mov	CX, DS:arg.argv[0].argstartel
	sub	CX, SI				; compute prefix bytes to copy
;
; We have the number of bytes in the prefix (up to the final component).
; We need to form the complete pathname including leading drive and current
; directory.
;
; Is there a drive letter present?
;
        cmp    word ptr [si], 05c5ch            ; If a UNC name, copy straight in
        je     CopyPath

        mov     ah,':'
	cmp	cx,2				; room for drive letter?
	jb	AddDrive			; no, stick it in
	cmp	[si+1],ah			; colon present?
	jz	MoveDrive			; yes, just move it

AddDrive:
	mov	al,curdrv			; get current drive
	add	al,"A"                          ; convert to uppercase letter
	stosw					; store d:
	jmp	short CheckPath

MoveDrive:
	lodsw					; move d:
	stosw
	sub	cx,2				; 2 bytes less to move

CheckPath:
	or	al,20h
	mov	dl,al
	sub	dl,"a"-1                        ; convert to 1-based for current dir
;
; Stick in beginning path char
;
	mov	al,psep_char
	stosb
;
; Is there a leading /?  If so, then no current dir copy is necessary.
; Otherwise, get current dir for DL.
;
	cmp	cx,1				; is there room for path char?
	jb	AddPath 			; no, go add path
	lodsb
	dec	cx
	cmp	al,psep_char			; is there a path separator?
	jz	MovePath			; yes, go move remainder of path
	inc	cx
	dec	si				; undo the lodsb

AddPath:
	SaveReg <SI>
	mov	si,di				; remainder of buffer
	trap	Current_dir
;
; The previous current dir will succeed a previous find_first already worked.
;
; Find end of string.
;
	mov	di,si
	RestoreReg  <SI>
	mov	al,psep_char
	cmp	byte ptr [di],0 		; root (empty dir string)?
	jz	MovePath			; yes, no need for path char

ScanEnd:
	cmp	byte ptr [dI],0 		; end of string?
	jz	FoundEnd
	inc	di
	jmp	ScanEnd
;
; Stick in a trailing path char
;
FoundEnd:
	stosb
;
; Move remaining part of path.	Skip leading path char if present.
;
MovePath:
	cmp	[si],al 			; first char a path char?
	jnz	CopyPath
	inc	si				; move past leading char
	dec	cx				; drop from count

CopyPath:
	jcxz	CopyDone			; no chars to move!
	rep	movsb

CopyDone:
	jmp	path_success			; run off and form complete pathname

path_noinit:
	test	DS:arg.argv[0].argflags, MASK path_sep
	jnz	path_failure			; complete pathname specified ==> fail

	mov	BH, path_sep_char		; semicolon terminates pathstring
	mov	DX, DS:arg.argv[0].argstartel	; this is where the last element starts
	sub	DX, DS:arg.argv[0].argpointer	; form pointer into EXECPATH,
	add	DX, OFFSET TRANGROUP:EXECPATH	; skipping over drive spec, if any

path_loop:
	call	path_crunch			; pcrunch(EXECPATH, pathinfo)
	mov	BP, AX				; save filetype code

	lahf					; save flags, just in case
	or	BP, BP				; did path_crunch find anything?
	jne	path_found
	sahf					; see?	needed those flags, after all!
	jnc	path_loop			; is there anything left to the path?

path_failure:
	xor	AX, AX
;;	jmp	short path_exit 		; 3/3/KK
	jmp	path_exit			;AC000;  3/3/KK

path_found:					; pathinfo[] points to winner
	mov	DI, OFFSET TRANGROUP:EXECPATH
	mov	CX, pathinfo[4] 		; "new" pointer -- end of string
	mov	SI, pathinfo[2] 		; "old" pointer -- beginning of string

;
;	BAS Nov 20/84
;   Look at the pathname and expand . and .. if they are the first element
;   in the pathname (after the drive letter)
;
	push	ES
	push	pathinfo[0]
	pop	ES
;SR;
; Oops! Gets fooled if path= \;..
; We should also check if a drive letter is really present
;
	cmp	Byte Ptr ES:[SI+2],'.'          ; Look for Current dir at start of path
	jnz	path_cpy

	cmp	byte ptr es:[si+1],':'		;does path have drive letter?
	jnz	path_cpy			;no, copy the path string

	push	CX				; Save pointer to end of string
	mov	AL, ES:[SI]
	mov	[DI],AL 			; Copy drive letter, :, and root char
	mov	AL, ES:[SI+1]			; to EXECPATH
	mov	[DI+1],AL
	mov	AL,psep_char
	mov	[DI+2],AL
	push	SI				; Save pointer to begining of string
	mov	DL,ES:[SI]			; Convert device letter for cur dir
	or	DL,20h
	sub	DL,"a"-1
	mov	SI,DI				; pointer to EXECPATH
	add	SI, 3				; Don't wipe out drive and root info
	trap	Current_dir
	invoke	DStrlen 			; Determine length of present info
	add	SI,CX				; Don't copy over drive and root info
	dec	SI
	mov	DI,SI				; Point to end of target string
	pop	SI				; Restore pointer to begining of string
	add	SI, 3				; Point past drive letter, :, .
	pop	CX				; Restore pointer to end of string

path_cpy:
	pop	ES
	sub	CX, SI				; yields character count
	push	DS				; time to switch segments
	push	pathinfo[0]			; string lives in this segment
	pop	DS
	cld
;;	rep	movsb	    3/3/KK		; copy the prefix path into EXECPATH

Kloop:						;AN000;  3/3/KK
	lodsb					;AN000;  3/3/KK
	stosb					;AN000;  3/3/KK
	invoke	testkanj			;AN000;  3/3/KK
	jz	NotKanj1			;AN000;  3/3/KK
	dec	cx				;AN000;  3/3/KK
	JCXZ	PopDone 			;AN000;  Ignore boundary error	 3/3/KK
	movsb					;AN000;  3/3/KK
	dec	cx				;AN000;  3/3/KK
	cmp	cx,1				;AN000;  One char (the terminator) left ? 3/3/KK
	ja	Kloop				;AN000;  no.			 3/3/KK

PopDone:					;AN000;  3/3/KK
	POP	DS				;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
	mov	AL, psep_char			;AN000;       KANJI		  3/3/KK
	jmp	Short path_store		;AN000;  3/3/KK

NotKanj1:
	loop	Kloop
	pop	DS				; return to our segment
	dec	DI				; overwrite terminator
	mov	AL, psep_char			; with a pathname separator
	cmp	al,byte ptr [di-1]
	jz	path_success

path_store:					;AN000;  3/3/KK
	stosb

path_success:
	mov	SI, OFFSET TRANGROUP:search_best_buf
	xor	CX, CX

path_succ_loop:
	lodsb					; append winning filename to path
	stosb					; (including terminating null)
	or	al,al
	jnz	path_succ_loop
	mov	AX, BP				; retrieve filetype code

path_exit:
	popf
	pop	BP
	pop	DI
	pop	SI				; chill out...
	pop	DX
	pop	CX
	pop	BX
	ret
EndProc Path_Search

break <Store_Pchar>
;----------------------------------------------------------------------------
;   STORE_PCHAR determines the pathname-element separator and squirrels
; it away.  In other words, must we say '/bin/ls' or '\bin\ls'?
; ENTRY:
; EXIT:
; NOTE(S):
;   *	Uses <psep_char>, defined in <path_search>.
;---------------
;---------------
Procedure   Store_PChar,NEAR
;---------------
	assume	ds:trangroup, es:trangroup

	push	AX
	mov	AL, '/'                         ; is the pathname-element separator
	invoke	pathchrcmp			; a regular slash?
	jz	store_slash			; if yes, remember slash
	mov	al,'\'
	mov	[psep_char], al 		; otherwise, remember back-slash
	pop	ax
	ret

store_slash:
	mov	[psep_char], al
	pop	ax
	return
;---------------
EndProc Store_Pchar
;----------------------------------------------------------------------------

break <Path_Crunch>
;----------------------------------------------------------------------------
; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
; EXECPATH, and smooshes them into tpbuf.  The caller may supply an
; additional separator to use for breaking up the path-string.	Null is the
; default.  Once the user-string has been formed, search is invoked to see
; what's out there.
; ENTRY:
;   BH			--	additional terminator character
;   SI			--	pointer into pathstring to be dissected
;   DX			--	pointer to stripped filename
; EXIT:
;   AX			--	non-zero (file type), zero (nothing found)
;   SI			--	moves along pathstring from call to call
;   [search_best_buf]	--	name of best file (AX non-zero)
;   [tpbuf]		--	clobbered
; NOTE(S):
;   *	Implicit in this code is the ability to specify when to search
;	the current directory (if at all) through the PATH defined by
;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
;	current directory before the bin and etc directories of drive c).
;---------------
Procedure   Path_Crunch,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	pushf
	call	store_pchar			; figure out pathname separator
	mov	DI, OFFSET TRANGROUP:tpbuf	; destination of concatenated string
	mov	SI, pathinfo[4] 		; "new" pointer to start with
	mov	pathinfo[2], SI 		; becomes "old" pointer
	push	DS				; save old segment pointer
	push	pathinfo[0]			; replace with pointer to userpath's
	pop	DS				; segment
	xor	cl,cl				;AN000;  clear flag for later use 3/3/KK

path_cr_copy:
	lodsb					; get a pathname byte
	or	al,al				; check for terminator(s)
	jz	path_seg			; null terminates segment & pathstring
	cmp	AL, BH
	jz	path_seg			; BH terminates a pathstring segment
	invoke	testkanj			;AN000;  3/3/KK
	jz	NotKanj2			;AN000;  3/3/KK
	stosb					;AN000;  3/3/KK
	movsb					;AN000;  3/3/KK
	MOV	CL,1				;AN000;  CL=1 means latest stored char is DBCS 3/3/KK
	jmp	path_cr_copy			;AN000;  3/3/KK

NotKanj2:					;AN000;  3/3/KK
	xor	cl,cl				;AN000;  CL=0 means latest stored char is SBCS 3/3/KK
	stosb					; save byte in concat buffer
	jmp	path_cr_copy			; loop until we see a terminator

path_seg:
	pop	DS				; restore old data segment
	mov	pathinfo[4], SI 		; save "new" pointer for next time
	mov	BL, AL				; remember if we saw null or not...
						;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
	xor	AX, AX				; in case nothing in pathstr...
	cmp	DI, OFFSET TRANGROUP:tpbuf	; was there really anything in pathstr?
	je	path_cr_leave			; if nothing was copied, pathstr empty

path_cr_look:					; form complete pathname
	mov	al, psep_char			; add pathname separator for suffix
	or	cl,cl				;AN000;  3/3/KK
	jnz	path_cr_store			;AN000;  this is a trailing byte of ECS code 3/3/KK
	cmp	al,byte ptr [di-1]
	jz	path_cr_l1

path_cr_store:					;AN000;  3/3/KK
	stosb

path_cr_l1:
	mov	SI, DX

path_cr_l2:
	lodsb					; tack the stripped filename onto
	stosb					; the end of the path, up to and
	or	AL, AL				; including the terminating null
	jnz	path_cr_l2
	mov	DX, OFFSET TRANGROUP:tpbuf	; and look for an appropriate file...
	mov	[search_error], OFFSET TRANGROUP:BADPMES_ptr
	invoke	search				; results are in AX & search_best_buf

path_cr_leave:
	or	BL, BL				; did we finish off the pathstring?
	jz	path_cr_empty			; null in BL means all gone...
	popf					; otherwise, plenty left
	clc
	jmp	short path_cr_exit

path_cr_empty:
	popf
	stc

path_cr_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret
;---------------
EndProc Path_Crunch
;----------------------------------------------------------------------------


trancode    ends
END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\path2.asm ===
page ,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)path2.asm	1.1 85/05/14
;	SCCSID = @(#)path2.asm	1.1 85/05/14
.sall
.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include find.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES SEGMENT PUBLIC BYTE
	EXTRN	FORFLAG:BYTE
DATARES ENDS


break <Path.Asm>
;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation.  Path and
;    Parse share a temporary buffer and argv[] definitions.  <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk.  Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>.  Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory.	This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line.  <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about.  This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;---------------
; CONSTANTS:
;---------------
    DEBUGx	equ	    FALSE	; prints out debug info
;---------------
; DATA:
;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte
	EXTRN	BADPMES_ptr:word
	EXTRN	curdrv:byte
	EXTRN	EXECPATH:byte
	EXTRN	ext_entered:byte	;AN005;
	EXTRN	fbuf:byte
	EXTRN	pathinfo:word
	EXTRN	psep_char:byte
	EXTRN	string_ptr_2:word
	EXTRN	tpbuf:byte
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

assume cs:trangroup, ds:trangroup, es:trangroup, ss:nothing

break <Search>
;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions:  .com, .exe, .bat (highest to
; lowest priority).  Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   fbuf	--	dma buffer for findfirst/next
; EXIT:
;   AX		--	8)  file found with .com extension
;			4)  file found with .exe extension
;			2)  file found with .bat extension
;			0)  no such file to be found
;   (if AX is non-zero:)
;   [search_best]	identical to AX
;   [search_best_buf]	null-terminated filename
; NOTES:
;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
;---------------
; CONSTANTS:
;---------------
search_file_not_found	    equ 	0
search_com		    equ 	8
search_exe		    equ 	4
search_bat		    equ 	2
fname_len		    equ 	8
fname_max_len		    equ 	13
dot			    equ 	'.'
wildchar		    equ 	'?'

;---------------
; DATA:
;---------------
TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	search_best:byte
	EXTRN	search_best_buf:byte
	EXTRN	search_curdir_buf:byte
	EXTRN	search_error:word
TRANSPACE	ENDS

;---------------
Procedure   Search,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	CX
	push	DX
	push	DI
	push	SI
	pushf

	push	DX				; check drivespec (save pname ptr)
	mov	DI, DX				; working copy of pathname
	mov	SI, OFFSET TRANGROUP:search_curdir_buf
	xor	DX, DX				; zero means current drive
	cmp	BYTE PTR [DI+1],':'             ; is there a drive spec?
	jne	search_dir_check
	mov	DL, [DI]			; get the drive byte
	and	DL, NOT 20H			; uppercase it
	sub	DL, '@'                         ; and convert to drive number

search_dir_check:
	trap	Current_Dir			; can we get the drive's current
	pop	DX				; directory?  If we can't we'll
	jc	search_invalid_drive		; assume it's a bad drive...

	mov	CX, search_attr 		; filetypes to search for
	trap	Find_First			; request first match, if any
	jc	search_no_file
	mov	search_best, search_file_not_found
	mov	[search_best_buf], ANULL	; nothing's been found, yet

search_loop:
	call	search_ftype			; determine if .com, &c...
	cmp	AL, search_best 		; better than what we've found so far?
	jle	search_next			; no, look for another
	mov	search_best, AL 		; found something... save its code
	mov	SI, OFFSET TRANGROUP:fbuf.find_buf_pname
	mov	DI, OFFSET TRANGROUP:search_best_buf
	mov	CX, fname_max_len
	cld
	rep	movsb				; save complete pathname representation
	cmp	AL, search_com			; have we found the best of all?
	je	search_done

search_next:					; keep on looking
	mov	CX, search_attr
	trap	Find_Next			; next match
	jnc	search_loop

search_done:					; it's all over with...
	mov	AL, search_best 		; pick best to return with
	cmp	ext_entered,1			;AN005; Did user request a specific ext?
	jz	search_exit			;AN005; no - exit
	mov	al,ext_entered			;AN005; yes - get the real file type back
	mov	search_best,al			;AN005; save the real file type
	jmp	short search_exit

search_invalid_drive:				; Tell the user path/drive
	mov	DX, [search_error]		; appropriate error message
	invoke	std_printf			; and pretend no file found

search_no_file: 				; couldn't find a match
	mov	AX, search_file_not_found

search_exit:
	popf
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	ret
;---------------
EndProc Search
;----------------------------------------------------------------------------


break <Search_Ftype>
;----------------------------------------------------------------------------
;   SEARCH_FTYPE determines the type of a file by examining its extension.
; ENTRY:
;   fbuf    --	    dma buffer containing filename
; EXIT:
;   AX	    --	    file code, as given in search header
; NOTE(S):
;   *	Implicit assumption that NULL == search_file_not_found
;---------------
; DATA:
;---------------
TRANDATA	SEGMENT PUBLIC BYTE		;AC000;
	extrn	comext:byte,exeext:byte,batext:byte
trandata     ends
;---------------
Procedure   Search_Ftype,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	DI
	push	si
	mov	AX, ANULL			; find the end of the filename
	mov	DI, OFFSET TRANGROUP:fbuf.find_buf_pname
	mov	CX, fname_max_len
	cld
	repnz	scasb				; search for the terminating null
	jnz	ftype_exit			; weird... no null byte at end
	sub	di,5				; . + E + X + T + NULL
;
; Compare .COM
;
	mov	si,offset trangroup:comext
	mov	ax,di
	cmpsw
	jnz	ftype_exe
	cmpsw
	jnz	ftype_exe
	mov	AX, search_com			; success!
	jmp	short ftype_exit
;
; Compare .EXE
;

ftype_exe:					; still looking... now for '.exe'
	mov	di,ax
	mov	si,offset trangroup:exeext
	cmpsw
	jnz	ftype_bat
	cmpsw
	jnz	ftype_bat
	mov	AX, search_exe			; success!
	jmp	short ftype_exit
;
; Compare .BAT
;

ftype_bat:					; still looking... now for '.bat'
	mov	di,ax
	mov	si,offset trangroup:batext
	cmpsw
	jnz	ftype_fail
	cmpsw
	jnz	ftype_fail
	mov	AX, search_bat			; success!
	jmp	short ftype_exit

ftype_fail:					; file doesn't match what we need
	mov	ax,ANULL

ftype_exit:
	cmp	ext_entered,1			;AN005; was an extension entered?
	jz	ftype_done			;AN005; no - exit
	cmp	ax,ANULL			;AN005; was any match found
	jz	ftype_done			;AN005; no - exit
	mov	ext_entered,al			;AN005; save the match type found
	mov	AX, search_com			;AN005; send back best was found to stop search

ftype_done:					;AN005;
	pop	SI
	pop	DI
	ret

;---------------
EndProc Search_Ftype
;----------------------------------------------------------------------------


break <Strip>
;----------------------------------------------------------------------------
;    STRIP copies the source string (argv[0]) into the destination buffer,
; replacing any extension with wildcards.
; ENTRY:
;	BX		--		maximum length of destination buffer
;	DS:SI		--		address of destination buffer
;	argv[0] 	--		command name to be stripped
; EXIT:
;	CF		--		set if failure, clear if successful
; NOTE(S):
;---------------
Procedure   Strip,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	AX
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	pushf

	mov	ext_entered,1			;AN005; assume no extension on file name
	mov	DX, DS:arg.argv[0].argpointer	; save pointer to beginning of argstring
	mov	DI, DS:arg.argv[0].argstartel	; beginning of last pathname element
	cmp	BYTE PTR [DI], 0		; *STARTEL == NULL means no command
	jz	strip_error
	mov	CX, DX				; compute where end of argstring lies
	add	CX, DS:arg.argv[0].arglen
	sub	CX, DI				; and then find length of last element
	inc	CX				; include null as well
	mov	AL, dot 			; let's find the filetype extension
	cld
	repnz	scasb				; wind up pointing to either null or dot
	jcxz	process_ext			;AN005; if no extension found, just continue
	mov	ext_entered,0			;AN005; we found an extension
	mov	al,ANULL			;AN005; continue scanning until the
	repnz	scasb				;AN005;    end of line is reached.

process_ext:					;AN005;
	mov	CX, DI				; pointer to end of argstring yields
	sub	CX, DX				; number of bytes to be copied
	sub	BX, 4				; can argstring fit into dest. buffer?
	cmp	CX, BX
	jg	strip_error			; if not, we must have a bad pathname
	mov	DI, SI				; destination buffer
	mov	SI, DX				; source is beginning of pathname
	cld
	rep	movsb				; SI=arg,DI=buffer,CX=argend-argbeg
	cmp	ext_entered,1			;AN005; if an extension was entered
	jnz	skip_wilds			;AN005;    don't set up wildcard ext.

	dec	DI				; overwrite null or dot
	stosb					; with a dot
	mov	AL, wildchar			; now add wildcards
	stosb
	stosb
	stosb
	mov	AL, ANULL			; and a terminating null
	stosb

skip_wilds:					;AN005;
	popf
	clc					; chill out...
	jmp	short strip_exit

strip_error:
	popf
	stc

strip_exit:
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret
;---------------
EndProc Strip
;----------------------------------------------------------------------------


break <Save_Args>
;----------------------------------------------------------------------------
;   SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
; structure in newly allocated memory.	The argv[] structure is found at the
; beginning of this area.  The caller indicates how much extra space is
; needed in the resulting structure; Save_Args returns a segment number and
; an offset into that area, indicating where the caller may preserve its own
; data.  Note that <argvcnt> can be found at <offset-2>.
; ENTRY:
;   BX	    --	    size (in bytes) of extra area to allocate
; EXIT:
;   AX	    --	    segment of new area.
;   CF	    --	    set if unable to save a copy.
; NOTE(S):
;   1)	The allocated area will be AT LEAST the size requested -- since
;	the underlying MSDOS call, <alloc> returns an integral number of
;	paragraphs.
;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
;	as the caller of Save_Args requests.
;   3)	AX is undefined if CF indicates an error.
;---------------
Procedure   Save_Args,NEAR
;---------------
	assume	ds:trangroup, es:trangroup
	push	BX
	push	CX
	push	DX
	push	DI
	push	SI
	push	BP
	pushf
	add	BX, SIZE arg_unit + 0FH 	; space for arg structure, round up
	mov	CL, 4				; to paragraph size and convert
	shr	BX, CL				; size in bytes to size in paragraphs
	trap	Alloc
	jc	save_error
	mov	BP, AX				; save segment id
	push	ES				; save TRANGROUP address
	mov	ES, AX				; switch to new memory segment
assume	ES:nothing
	mov	CX, SIZE arg_unit		; get back structure size
	xor	DI, DI				; destination is new memory area
	mov	SI, OFFSET TRANGROUP:arg	; source is arg structure
	rep	movsb				; move it
	mov	CX, arg.argvcnt 		; adjust argv pointers
	xor	AX, AX				; base address for argv_calc
;	Bugbug:	What did they mean by this?
;	Note that the replacement line produces exactly the same code.
;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
	mov	SI, OFFSET TRANGROUP:arg

save_ptr_loop:
	dec	CX				; exhausted all args?
	jl	save_done
	mov	BX, CX				; get arg index and
	invoke	argv_calc			; convert to a pointer
	mov	DX, DS:arg.argv[BX].argpointer
	sub	DX, SI				; adjust argpointer
	mov	ES:argv[BX].argpointer, DX
	mov	DX, DS:arg.argv[BX].argstartel
	sub	DX, SI				; and adjust argstartel
	mov	ES:argv[BX].argstartel, DX
	mov	DX, DS:arg.argv[BX].arg_ocomptr
	sub	DX, SI				; and adjust arg_ocomptr
	mov	ES:argv[BX].arg_ocomptr, DX
	jmp	save_ptr_loop

save_done:
	pop	ES				; back we go to TRANGROUP
assume	ES:trangroup
	mov	AX, BP				; restore segment id
	jmp	short save_ok

save_error:
	popf
	stc
	jmp	short save_exit

save_ok:
	popf
	clc
save_exit:
	pop	BP
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	ret
;---------------
EndProc Save_Args
;----------------------------------------------------------------------------

trancode    ends
END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\rdata.asm ===
page ,132
    title   COMMAND Resident DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;   Revision History
;   ================
;   M003    SR  07/16/90    Added LoadHiFlg for LoadHigh support
;
;   M004    SR  07/17/90    Transient is now moved to its final
;               location at EndInit time by allocating
;               the largest available block, moving
;               the transient to the top of the block
;               and then freeing up the block.
;
;   M027    SR  9/20/90 Fixed bug #2827. EndInit was using
;               INIT seg variables after INIT seg
;               had been freed.
;
;   M036    SR  11/1/90 Free up environment segment passed
;               by Exec always.
;

.xlist
.xcref
    include dossym.inc
    include pdb.inc
    include syscall.inc
    include comsw.asm
    include comseg.asm
    include resmsg.equ
    include comequ.asm
    include cmdsvc.inc
.list
.cref

;   Equates for initialization (from COMEQU)
;
;   Bugbug:  Toss these after putting ctrl-c handler in init module.

INITINIT    equ     01h         ; initialization in progress
INITSPECIAL equ     02h         ; in initialization time/date routine
INITCTRLC   equ     04h         ; already in ^C handler


CODERES segment public byte
    extrn   Ext_Exec:near
    extrn   MsgRetriever:far
    extrn   TRemCheck:near

;SR;
; The stack has no right to be in the code segment. Moved it to DATARES
;
;   bugbug: Why this odd stack size?  And what should stack size be?
;;  db  (80h - 3) dup (?)
;;RStack    label   word
;;  public  RStack
CODERES ends

INIT    segment

    extrn   ConProc:near
    extrn   Chuckenv:byte
    extrn   UsedEnv:word
    extrn   OldEnv:word
    extrn   EnvSiz:word
    extrn   TrnSize:word        ; M004

INIT    ends

TAIL    segment

    extrn   TranStart   :word

TAIL    ends

TRANCODE    segment public byte
    extrn   Command:near
TRANCODE    ends

TRANSPACE   segment

    extrn   TranSpaceEnd    :byte

TRANSPACE   ends

;SR;
; All the routines below are entry points into the stub from the transient.
;The stub will then transfer control to the appropriate routines in the
;resident code segment, wherever it is present.
;

DATARES segment

    extrn   Exec_Trap   :near
    extrn   RemCheck_Trap   :near
    extrn   MsgRetrv_Trap   :near
    extrn   HeadFix_Trap    :near
    extrn   Issue_Exec_Call :near

DATARES ends


DATARES segment public byte
    assume  cs:DATARES
    Org 0
ZERO    =   $

;;  Org 100h
;;ProgStart:
;;  jmp RESGROUP:ConProc

    public  Abort_Char
    public  Append_Flag
    public  Append_State
    public  BadFatSubst
    public  Batch
    public  Batch_Abort
    public  BlkDevErrRw
    public  BlkDevErrSubst
    public  Call_Batch_Flag
    public  Call_Flag
    public  CDevAt
    public  CharDevErrSubst
    public  CharDevErrRw
    public  Com_Fcb1
    public  Com_Fcb2
    public  Com_Ptr
    public  ComDrv
    public  ComSpec
    public  ComSpec_End
    public  Crit_Err_Info
    public  Crit_Msg_Off
    public  Crit_Msg_Seg
    public  CritMsgPtrs
    public  DataResEnd
    public  Dbcs_Vector_Addr
    public  DevName
    public  DrvLet
    public  EchoFlag
    public  EnvirSeg
    public  ErrCd_24
    public  ErrType
    public  Exec_block
    public  ExecErrSubst
    public  Extcom
    public  ExtMsgEnd
    public  Fail_Char
    public  fFail
    public  ForFlag
    public  ForPtr
    public  FUCase_Addr
    public  Handle01
    public  IfFlag
    public  Ignore_Char
    public  In_Batch
    public  InitFlag
    public  InPipePtr
    public  Int_2e_Ret
    public  Int2fHandler
    public  Io_Save
    public  Io_Stderr
    public  LenMsgOrPathBuf
    public  Loading
    public  LTpa
    public  MemSiz
    public  MsgBuffer
    public  MsgPtrLists
    public  MySeg
    public  MySeg1
    public  MySeg2
    public  MySeg3
    public  NeedVol
    public  NeedVolSubst
    public  Nest
    public  Next_Batch
    public  No_Char
    public  NullFlag
    public  NUMEXTMSGS
    public  NUMPARSMSGS
    public  OldErrNo
    public  OldTerm
    public  OutPipePtr
    public  Parent
    public  ParsMsgPtrs
    public  PermCom
    public  Pipe1
;;; public  Pipe1T
    public  Pipe2
;;; public  Pipe2T
    public  PipeFiles
    public  PipeFlag
    public  PipePtr
    public  PipeStr
    public  KSwitchFlag
    public  PutBackComSpec
    public  PutBackDrv
    public  PutBackSubst
    public  RDirChar
    public  Re_Out_App
    public  Re_OutStr
    public  ResMsgEnd
    public  Res_Tpa
    public  RestDir
    public  ResTest
    public  RetCode
    public  Retry_Char
    public  RSwitChar
    public  SafePathBuffer      ; MSKK01 07/14/89
    public  Save_Pdb
    public  SingleCom
    public  Sum
    public  Suppress
    public  Trans
    public  TranVarEnd
    public  TranVars
    public  TrnSeg
    public  TrnMvFlg
    public  VerVal
    public  VolName
    public  VolSer
    public  Yes_Char

    public  ResSize
    public  RStack
    public  OldDS


    public  LoadHiFlg       ;For LoadHigh support ; M003
    public  SCS_Is_First
    public  SCS_REENTERED
    public  SCS_FIRSTCOM

    public  SCS_PAUSE
        public  SCS_CMDPROMPT
        public  SCS_DOSONLY
        public  SCS_PROMPT16
        public  SCS_FIRSTTSR
        public  RES_RDRINFO
        public  RES_BATSTATUS

    extrn   LodCom_Trap:near
    extrn   Alloc_error:near


;***    Message substitution blocks


BlkDevErrSubst  label   byte
BlkDevErrRw subst   <STRING,>       ; "reading" or "writing"
        subst   <CHAR,DATARES:DrvLet>   ; block device drive letter

DrvLet      db  'A'         ; drive letter


CharDevErrSubst label   byte
CharDevErrRw    subst   <STRING,>         ; "reading" or "writing"
CharDevErrDev   subst   <STRING,DATARES:DevName> ; character device name

DevName     db  8 dup (?),0       ; device name, asciiz


NeedVolSubst    label   byte
        subst   <STRING,DATARES:VolName>    ; volume name
        subst   <HEX,DATARES:VolSer+2>      ; hi word of serial #
        subst   <HEX,DATARES:VolSer>        ; lo word of serial #

;       NOTE:   VolName and VolSer must be adjacent
VolName     db  11 dup (?),0        ; volume name
VolSer      dd  0           ; volume serial #


CDevAt      db  ?


BadFatSubst label   byte
        subst   <CHAR,DATARES:DrvLet>   ; drive letter


PutBackSubst    label   byte
PutBackComSpec  subst   <STRING,>           ; comspec string
        subst   <CHAR,DATARES:PutBackDrv>   ; drive to put it in

PutBackDrv  db  ' '         ; drive letter


ExecErrSubst    subst   <STRING,DATARES:SafePathBuffer>


NeedVol     dd  ?   ; ptr to volume name from get ext err
ErrType     db  ?   ; critical error message style, 0=old, 1=new

Int_2e_Ret  dd  ?   ; magic command executer return address
Save_Pdb    dw  ?
Parent      dw  ?
OldTerm     dd  ?
ErrCd_24    dw  ?
Handle01    dw  ?
Loading     db  0
Batch       dw  0   ; assume no batch mode initially

;;;;SR;
;;;; This flag has been added for a gross hack introduced in batch processing.
;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
;;;;we need to fake the CR-LF for the line to be properly processed
;;;;
;;;BatchEOF     db  0

;       Bugbug: ComSpec should be 64+3+12+1?
;       What's this comspec_end about?
ComSpec     db  64 dup (0)
ComSpec_End dw  ?

Trans       label   dword
        dw  TRANGROUP:Command
TrnSeg      dw  ?

TrnMvFlg    db  0   ; set if transient portion has been moved

In_Batch    db  0   ; set if we are in batch processing mode
Batch_Abort db  0   ; set if user wants to abort from batch mode

ComDrv      db  ?   ; drive spec to load autoexec and command
MemSiz      dw  ?
Sum     dw  ?
ExtCom      db  1   ; for init, pretend just did an external
RetCode     dw  ?
Crit_Err_Info   db  ?   ; hold critical error flags for r,i,f


; The echo flag needs to be pushed and popped around pipes and batch files.
; We implement this as a bit queue that is shr/shl for push and pop.

EchoFlag    db  00000001b   ; low bit true => echo commands
Suppress    db  1       ; used for echo, 1=echo line
Io_Save     dw  ?
Io_Stderr   db  ?
RestDir     db  0
PermCom     db  0       ; true => permanent command
SingleCom   dw  0       ; true => single command version
KSwitchFlag db  0
VerVal      dw  -1
fFail       db  0       ; true => fail all int 24s
IfFlag      db  0       ; true => IF statement in progress

ForFlag     db  0       ; true => FOR statement in progress
ForPtr      dw  0

Nest        dw  0       ; nested batch file counter
Call_Flag   db  0       ; no CALL (batch command) in progress
Call_Batch_Flag db  0
Next_Batch  dw  0       ; address of next batch segment
NullFlag    db  0       ; flag if no command on command line
FUCase_Addr db  5 dup (0)   ; buffer for file ucase address
; Bugbug: don't need crit_msg_ anymore?
Crit_Msg_Off    dw  0       ; saved critical error message offset
Crit_Msg_Seg    dw  0       ; saved critical error message segment
Dbcs_Vector_Addr dw 0       ; DBCS vector offset
         dw 0       ; DBCS vector segment

Append_State    dw  0       ; current state of append
                    ;  (if Append_Flag is set)
Append_Flag db  0       ; set if append state is valid

SCS_PAUSE   db  0       ; yst 4-5-93

Re_Out_App  db  0
Re_OutStr   db  64+3+13 dup (?)
SCS_Is_First    db  1
SCS_REENTERED   db  0
SCS_FIRSTCOM    db  0
SCS_CMDPROMPT   db      0               ; means on TSR/Shell out use command.com
SCS_DOSONLY     db      0               ; means by default run all binaries
                                        ; when at command.com prompt. if 1 means
                                        ; allow only dos binaries.
SCS_PROMPT16    db      0
SCS_FIRSTTSR    db      1
RES_RDRINFO     DD      0
RES_BATSTATUS   db      0

; We flag the state of COMMAND in order to correctly handle the ^Cs at
; various times.  Here is the breakdown:
;
;   INITINIT    We are in the init code.
;   INITSPECIAL We are in the date/time prompt
;   INITCTRLC   We are handling a ^C already.
;
; If we get a ^C in the initialization but not in the date/time prompt, we
; ignore the ^C.  This is so the system calls work on nested commands.
;
; If we are in the date/time prompt at initialization, we stuff the user's
; input buffer with a CR to pretend an empty response.
;
; If we are already handling a ^C, we set the carry bit and return to the user
; (ourselves).  We can then detect the carry set and properly retry the
; operation.

InitFlag    db  INITINIT

; Note:  these two bytes are referenced as a word
PipeFlag    db  0
PipeFiles   db  0

;--- 2.x data for piping
;
; All the "_" are substituted later, the one before the : is substituted
; by the current drive, and the others by the CreateTemp call with the
; unique file name. Note that the first 0 is the first char of the pipe
; name. -MU
;
;--- Order-dependent, do not change

;;;Pipe1        db  "_:/"
;;;Pipe1T       db  0
;;;     db  "_______.___",0
;;;Pipe2        db  "_:/"
;;;Pipe2T       db  0
;;;     db  "_______.___",0

;SR
; Pipe1 & Pipe2 now need to store full-fledged pathnames
;

; Bugbug:  can we find any way around maintaining these
; large buffers?

Pipe1       db  67+12 dup (?)
Pipe2       db  67+12 dup (?)

PipePtr     dw  ?

PipeStr     db  129 dup (?)

EndPipe label   byte            ; marks end of buffers; M004

;SR;
; We can move our EndInit code into above buffers. This way, the code will
;automatically be discarded after init.
;
; M004; We overlap our code with the Pipe buffers located above by changing
; M004; the origin.
;
    ORG Pipe1           ; M004

; Bugbug:  really need a procedure header for EndInit, describing
; what it expects, what it does.

Public  EndInit
EndInit:
    push    ds
    push    es          ;save segments
    push    cs
    pop ds
    assume  ds:RESGROUP

;
; M004; Save size of transient here before INIT segment is deallocated
;
    mov dx,TrnSize      ; M004
;M027
; These variables are also defined in the INIT segment and need to be saved
;before we resize
;
    mov ax,OldEnv       ; Old Environment seg ;M027
    mov bx,EnvSiz       ; Size of new environment ;M027
    mov cx,UsedEnv      ; Size of old environment ;M027
    push    ax          ; Save all these values ;M027
    push    bx          ; M027
    push    cx          ; M027


; Bugbug:  push ds, pop es here.
    mov bx,ds
    mov es,bx           ;es = RESGROUP
;
;ResSize is the actual size to be retained -- only data for HIMEM COMMAND,
; code + data for low COMMAND
;
    mov bx,ResSize      ;Total size of resident
    mov ah,SETBLOCK
    int 21h         ;Set block to resident size
;
;We check if this is for autoexec.bat (PermCom = 1). If so, we then
;allocate a new batch segment, copy the old one into new batchseg and free
;the old batchseg. Remember that the old batchseg was allocated on top of the
;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
;
; Bugbug:  also describe why we alloc & copy batch seg BEFORE environment.
    cmp PermCom,1       ;permanent command.com?
    jne adjust_env      ;no, do not free batchseg

    cmp Batch,0         ;was there a valid batchseg?
    je  adjust_env      ;no, dont juggle

; NTVDM temp name of the batch file may be up to 63 bytes, plus NULL
;        mov     bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ;batchseg size
        mov     bx,((SIZE BatchSegment) + 64 + 1 + 0fh)/16 ;batchseg size
    mov ah,ALLOC
    int 21h
; Bugbug:  I just had a thought.  If DOS or SHARE or somebody leaves
; a hole, the batch segment COULD already be in the ideal place.  We
; could be making it worse!  We're second-guessing where memory
; allocations go, which might not be such a great idea.  Is there
; a strategy, short of doing something even worse like diddling
; arena headers, where we can minimize the possibility of fragmentation
; under all cases?  Hmm..
    jc  adjust_env      ;no memory, use old batchseg
    mov es,ax           ;es = New batch segment
    xor di,di
    xor si,si

    push    ds
    mov ds,Batch        ;ds = Old Batch Segment
    assume  ds:nothing
        mov     cx,SIZE BatchSegment
; NTVDM temp name of the batch file may be up to 63 bytes, plus NULL
;       add     cx,16                   ;for the filename
        add     cx,64
    ; Bugbug: 16?  Shouldn't this be a common equate or something?
    ; It's sure be bad if we copied more bytes than the batch segment
    ; holds!
    cld
    rep movsb
    pop ds
    assume  ds:RESGROUP

    mov cx,es           ;save new batch segment
    mov es,Batch
    mov ah,DEALLOC
    int 21h         ;free the old batch segment
    ; Bugbug:  should we check for error?

    mov Batch,cx        ;store new batch segment address

adjust_env:
    pop cx          ;cx = size of old env ;M027
    pop bx          ;bx = size of new env needed ;M027
    pop bp          ;bp = old env seg ;M027

;
;Allocate the correct size for the environment
;
    mov ah,ALLOC
    int 21h         ;get memory
    jc  init_env_err        ;out of memory,signal error

    ; Bugbug:  why not continue, leaving environment where it is?

    mov EnvirSeg,ax     ;Store new environment segment
    mov ds:PDB_Environ,ax       ;Put new env seg in PSP
    mov es,ax           ;es = address of allocated memory
    assume  es:nothing

    cmp PermCom, 1
    jne copy_old_env

;
; First get the size of 32bit env
;

    push bx
    mov bx, 0
    CMDSVC  SVC_GETINITENVIRONMENT
    mov ax, bx
    pop  bx
    cmp ax, 0           ;bx returns 0, use old environment
    je  copy_old_env

;
; now compute the new size
;   [ax] = size of 32 bit env
;

    add bx, ax
    mov ah, DEALLOC     ;free the block
    int 21h
    mov ah, ALLOC       ;and get a new block(don't use realloc please)
    int 21h
    jc  nomem_err

    mov EnvirSeg,ax     ;Store new environment segment
    mov ds:PDB_Environ,ax       ;Put new env seg in PSP
    mov es,ax           ;es = address of allocated memory
    mov EnvSiz, bx      ;new size
    push bx
    CMDSVC  SVC_GETINITENVIRONMENT  ;get new environment
    pop ax
    cmp bx, ax
    jbe adjust_env_done
init_env_err:
    jmp short nomem_err
copy_old_env:
;
;Copy the environment to the newly allocated segment
;
    push ds
    mov  ds, bp           ;ds = Old environment segment
    assume ds:nothing

    xor si,si
    mov di,si           ;Start transfer from 0

    cld
    rep movsb           ;Do the copy

    pop ds          ;ds = RESGROUP
    assume  ds:RESGROUP
adjust_env_done:

;
;We have to free the old environment block if it was allocated by INIT
;
; Bugbug:  is this only for the case when we were NOT passed an environment,
; or does it also apply to passed environments?
;M036
; Free up old env segment always because this is a copy passed by Exec and
;takes up memory that is never used
;
;M044
;Go back to the old strategy of not freeing the environment. Freeing it leaves
;a hole behind that Ventura does not like. Basically, Ventura gives strange
;errors if it gets a memory alloc that it is below its load segment. The
;freed environment creates a large enough hole for some of its allocs to fit
;in
;
    cmp Chuckenv,0      ;has env been allocated by INIT?
    jne no_free     ;no, do not free it

    mov es,bp
    mov ah,DEALLOC
    int 21h         ;Free it
no_free:

;
; M004; Start of changes
;

;
; Move the transient now. We will allocate the biggest block available
; now and move the transient to the top of the block. We will then
; deallocate this block. When the resident starts executing, it will
; hopefully allocate this block again and find the transient intact.
;
    MOV TrnMvFlg, 1         ; Indicate that transient has been moved
    push    es
    mov si,offset ResGroup:TranStart
    mov di,0
    mov cx,offset TranGroup:TranSpaceEnd ;size to move
;
; Find the largest block available
;
    mov bx,0ffffh
    mov ah,ALLOC
    int 21h

;
; dx = size of transient saved previously
;
    cmp bx,dx           ;enough memory?
    jb  nomem_err       ;not enough memory for transient

    mov ah,ALLOC
    int 21h         ;get the largest block
    jc  nomem_err       ;something is really messed up

    push    ax          ;save memory address
    add ax,bx           ;ax = top of my memory block
    sub ax,dx           ;less size of transient
    mov TrnSeg,ax       ;save transient segment
    mov es,ax           ;
    pop ax          ;restore our seg addr

;
; Everything is set for a move. We need to move in the reverse direction to
; make sure we dont overwrite ourselves while copying
;
    add si,cx
    dec si
    add di,cx
    dec di
    std
    rep movsb
    cld
;
; Now we have to free up this block so that resident can get hold of it
;
    mov es,ax
    mov ah,DEALLOC
    int 21h         ;release the memory block

;
; M004; End of changes
;

    mov InitFlag,FALSE      ;indicate INIT is done

    pop es
    pop ds
    ; Bugbug:  did we need to save & restore seg reg's during EndInit?
    assume  ds:nothing

    jmp LodCom_Trap     ;allocate transient

nomem_err:
;
;We call the error routine which will never return. It will either exit
;with an error ( if not the first COMMAND ) or just hang after an error
;message ( if first COMMAND )
;

    jmp Alloc_error

public EndCodeInit          ; M004
EndCodeInit label   byte        ; M004

;
; M004; Check if the EndInit code will fit into the Pipe buffers above.
; M004; If not, we signal an assembly error
;
IF2
    IF ($ GT EndPipe)
        .err
        %out    "ENDINIT CODE TOO BIG"
    ENDIF
ENDIF
;
; M004; Set the origin back to what it was at the end of the buffers
;
        ORG EndPipe     ; M004



InPipePtr   dw  offset DATARES:Pipe1
OutPipePtr  dw  offset DATARES:Pipe2

Exec_Block  label   byte        ; the data block for exec calls
EnvirSeg    dw  ?
Com_Ptr     label   dword
        dw  80h     ; point at unformatted parameters
        dw  ?
Com_Fcb1    label   dword
        dw  5Ch
        dw  ?
Com_Fcb2    label   dword
        dw  6Ch
        dw  ?

;       variables passed to transient
TranVars    label   byte
        dw  offset DATARES:HeadFix_Trap
MySeg       dw  0       ; put our own segment here
LTpa        dw  0       ; will store tpa segment here
RSwitChar   db  "/"
RDirChar    db  "\"
        dw  offset DATARES:Issue_Exec_Call
MySeg1      dw  ?
        dw  offset DATARES:RemCheck_Trap
MySeg2      dw  0
ResTest     dw  0
Res_Tpa     dw  0       ; original tpa (not rounded to 64k)
TranVarEnd  label   byte

OldErrNo    dw  ?


;*      NOTE:  MsgBuffer and SafePathBuffer use the same
;       memory.  MsgBuffer is only used while a command
;       is being executed.  SafePathBuffer is no longer
;       needed, since it is used for unsuccessful program
;       launches.

MsgBuffer   label   byte        ; buffer for messages from disk
SafePathBuffer  label   byte        ; resident pathname for EXEC
;                db      128 dup (0)     ; path + 'd:\' 'file.ext' + null
                 db      EXECPATHLEN dup (0)    ; MAX_PATH+13 ntvdm extended
LenMsgOrPathBuf equ $ - MsgBuffer


Int2fHandler    dd  ?   ; address of next int 2f handler
ResMsgEnd   dw  0   ; holds offset of msg end (end of resident)

;SR;
; The three vars below have been added for a pure COMMAND.COM
;

ResSize     dw  ?

;SR;
; Moved the stack here from the code segment
;
;   bugbug: Why this odd stack size?  And what should stack size be?
    db  (80h - 3) dup (?)
RStack  label   word

OldDS       dw  ?   ;keeps old ds value when jumping to
                ;resident code segments

LoadHiFlg   db  0   ;Flag set to 1 if UMB loading enabled ; M003

ifdef   BETA3WARN
    %out    Take this out before we ship
public  Beta3Warned
Beta3Warned db  0
endif

;***    MESSAGES
;   and other translatable text

    include comrmsg.inc ;M00

DATARES ends
    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tbatch.asm ===
page ,132
;	SCCSID = @(#)tbatch.asm 4.5 85/10/01
;	SCCSID = @(#)tbatch.asm 4.5 85/10/01
TITLE	Batch processing routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M006	SR	07/20/90	Changed BatCom to understand batch
;				segments in UMBs. Check only for 
;				overlap.
;	M017	MD	08/10/90	Eliminate extra DEC, to fix bug #1
;
;	M037	SR	11/1/90	Bug #1745 & #3438 fixed. Fixed ReadBat
;				to check if we have hit EOF on
;				batchfile and if so, just clear everything
;				and return finishing batch processing.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
	include doscntry.inc		;an000;
	include version.inc
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	Batch_Abort:byte
	EXTRN	call_batch_flag:byte
	EXTRN	ECHOFLAG:BYTE
	EXTRN	forflag:byte
	EXTRN	forptr:word
	EXTRN	IFFlag:BYTE
	EXTRN	In_Batch:byte
	EXTRN	LTPA:WORD
	EXTRN	Nest:word
	EXTRN	next_batch:word
	EXTRN	nullflag:byte
	EXTRN	PIPEFLAG:BYTE
	EXTRN	RES_TPA:WORD
	EXTRN	SINGLECOM:WORD
	EXTRN	SUPPRESS:BYTE		;AC000;
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADBAT_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AC000;
	EXTRN	Extend_buf_sub:byte	;AN022;
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	NEEDBAT_PTR:WORD
	EXTRN	pausemes_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BatBufPos:WORD
	EXTRN	BATHAND:WORD
	EXTRN	bwdbuf:byte		;AN022;
	EXTRN	BYTCNT:WORD
	EXTRN	COMBUF:BYTE
	EXTRN	EXECPATH:BYTE
	EXTRN	ID:BYTE
	EXTRN	RCH_ADDR:DWORD
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word	;AC000;
	EXTRN	TPA:WORD
	EXTRN	TRAN_TPA:WORD

	extrn	TranSpaceEnd:byte	; M006
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	tcommand:near

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
    extrn   arg:byte			; the arg structure!
transpace   ends
;---------------

Break	<PromptBat - Open or wait for batch file>

;
; Open the batch file.	If we cannot find the batch file.  If the media is
; changeable, we prompt for the change.  Otherwise, we terminate the batch
; file.  Leave segment registers alone.
;

Procedure   PromptBat,NEAR
	ASSUME	DS:ResGroup,ES:NOTHING
	invoke	BATOPEN 			; attempt to open batch file
	retnc
	cmp	dx,error_file_not_found 	;AN022; Ask for diskette if file not found
	jz	Bat_Remcheck			;AN022;
	cmp	dx,error_path_not_found 	;AN022; Ask for diskette if path not found
	jz	Bat_Remcheck			;AN022;    Otherwise, issue message and exit
	invoke	output_batch_name		;AN022; set up batch name in bwdbuf
	jmp	short BatDie			;AN022;

Bat_Remcheck:					;AN022; Go see if media is removable
	CALL	[RCH_ADDR]			; DX has error number
	JZ	AskForBat			; Media is removable
;
; The media is not changeable.	Turn everything off.
;
	invoke	ForOff
	invoke	PipeOff
	MOV	IfFlag,AL			; No If in progress.
	MOV	DX,OFFSET TRANGROUP:BADBAT_ptr

BatDie:
	call	BatchOff
	PUSH	CS
	POP	DS
	ASSUME	DS:TranGroup
	invoke	std_eprintf			;AC022; display message

;
; TCOMMAND resets the stack.  This is the equivalent of a non-local goto.
;
	JMP	TCOMMAND			; he cleans off stack

;
; Ask the user to reinsert the batch file
;
ASKFORBAT:
	ASSUME	DS:ResGroup
	PUSH	DS
	PUSH	CS
	POP	DS
	ASSUME	DS:TranGroup
	MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
	invoke	std_eprintf			 ;Prompt for batch file on stderr
	mov	dx,offset trangroup:pausemes_ptr ;AN000; get second part of message
	invoke	std_eprintf			 ;AN000; print it to stderr
	CALL	GetKeystroke
	POP	DS
	ASSUME	DS:ResGroup
	jmp	PromptBat
EndProc PromptBat

;****************************************************************
;*
;* ROUTINE:	Output_batch_name
;*
;* FUNCTION:	Sets up batch name to be printed on extended error
;*
;* INPUT:	DX - extended error number
;*
;* OUTPUT:	Ready to call print routine
;*
;****************************************************************

public	output_batch_name			;AN022;

Output_batch_name    proc near			;AN022;

	push	ds				;AN022; save resident segment
	mov	ds,[batch]			;AN022; get batch file segment
assume	DS:nothing				;AN022;
	mov	SI,BatFile			;AN022; get offset of batch file
	invoke	dstrlen 			;AN022; get length of string
	mov	di,offset Trangroup:bwdbuf	;AN022; target for batch name
	rep	movsb				;AN022; move the name

	push	cs				;AN022; get local segment
	pop	ds				;AN022;
assume	DS:trangroup				;AN022;
	mov	extend_buf_ptr,dx		;AN022; put message number in block
	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr   ;AN022; get extended message pointer
	mov	string_ptr_2,offset trangroup:bwdbuf ;AN022; point to substitution
	mov	extend_buf_sub,one_subst	;AN022; set up for one subst
	pop	ds				;AN022; restore data segment

	ret					;AN022; return

Output_batch_name    endp			;AN022;

Break	<GetKeystroke - get a keystroke and flush queue>

;
; read the next keystroke.  Since there may be several characters in the queue
; after the one we ask for (function keys/Kanji), we need to flush the queue
; AFTER waiting.
;
Procedure   GetKeyStroke,NEAR
;
; read any character at any mode, interim mode or not.
;
	assume	ds:trangroup

	PUSH	DX					;AN000;  3/3/KK
	MOV	AX,(ECS_call SHL 8) OR GetInterimMode	;AN000;  3/3/KK
	INT	21h				;AN000;  3/3/KK
	PUSH	DX					;AN000;  save interim state 3/3/KK
	MOV	AX,(ECS_call SHL 8) OR SetInterimMode	;AN000;  3/3/KK
	MOV	DL,InterimMode				;AN000;  3/3/KK
	INT	21h				;AN000;  3/3/KK

	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
	INT	21h		; Get character with KB buffer flush
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21h

	MOV	AX,(ECS_call SHL 8) OR SetInterimMode	;AN000;  3/3/KK
	POP	DX					;AN000;  restore interim state 3/3/KK
	INT	21h				;AN000;  3/3/KK
	POP	DX					;AN000;  3/3/KK

	return
EndProc GetKeyStroke

Break	<ReadBat - read 1 line from batch file>

;
; ReadBat - read a single line from the batch file.  Perform all substitutions
; as appropriate
;

Procedure   ReadBat,NEAR
	ASSUME	DS:ResGroup,ES:TranGroup
	mov	suppress,yes_echo		;g initialize line suppress status
	test	byte ptr [Batch_Abort],-1
	jnz	Trying_To_Abort
	mov	byte ptr [In_Batch],1		; set flag to indicate batch job
;
;M037; Start of changes
; We check here if we have set the flag indicating that the batchfile is at
;EOF. In this case, we do not want to continue with the normal processing.
;We call GetBatByt once more so that the batch segment gets freed up, the
;batch file gets closed etc. and then return as if everything is done.
;
	push	ds
	mov	ds,Batch
	cmp	ds:BatchEOF,0		; are we at EOF in batchfile
	pop	ds
	jz	contbat		; no, continue normal processing
	invoke	GetBatByt		; frees up batchseg
	mov	es:ComBuf+2,al		; stuff CR into command buffer
					; as a dummy command
	invoke 	CrLf2			; print a CR-LF
	return				; done batch processing
contbat:
;
;M037; End of changes
;

	CALL	PromptBat

Trying_To_Abort:
	MOV	DI,OFFSET TRANGROUP:COMBUF+2

;
; Save position and try to scan for first non delimiter.
;

TESTNOP:
	MOV	AX,DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	PUSH	WORD PTR DS:[BatSeek]
	PUSH	WORD PTR DS:[BatSeek+2] 	; save current location.
	MOV	DS,AX
	ASSUME	DS:ResGroup
	invoke	SkipDelim			; skip to first non-delim
;
; If the first non-delimiter is not a :  (label), we reseek back to the
; beginning and read the line.
;
	CMP	AL,':'                          ; is it a label?
	POP	CX
	POP	DX				; restore position in bat file
	JZ	NopLine 			; yes, resync everything.
	TEST	[BATCH],-1			; are we done with the batch file?
	JZ	RdBat

	CMP	AL, NO_ECHO_CHAR		;g see if user wants to suppress line
	JNZ	SET_BAT_POS			;g no - go and set batch file position
	MOV	SUPPRESS, NO_ECHO		;g yes set flag to indicate
	jmp	short Rdbat			;g go read batch file

SET_BAT_POS:					;g
	PUSH	DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	MOV	WORD PTR DS:[BatSeek],DX	; reseek back to beginning
	MOV	WORD PTR DS:[BatSeek+2],CX
	POP	DS
	ASSUME	DS:ResGroup
	MOV	AX,(LSEEK SHL 8) + 0		; seek back
	INT	21h
	MOV	BatBufPos,-1			; nuke batch buffer position
	xor	cx,cx				; Initialize line length to zero
	JMP	SHORT RdBat
;
; The first non-delimiter is a :.  This line is not echoed and is ignored.
; We eat characters until a CR is seen.
;

NOPLINE:
	CALL	SkipToEOL
	invoke	GetBatByt			; eat trailing LF
	TEST	[BATCH],-1			; are we done with the batch file?
	JNZ	TESTNOP 			; no, go get another line
	return					; Hit EOF

;
; Read a line into the buffer pointed to by ES:DI.  If any %s are seen in the
; input, we are to consider two special cases:
;
;   %0 to %9	These represent replaceable parameters from the batch segment
;   %sym%	This is a symbol from the environment
;

RDBAT:
	invoke	GetBatByt
	inc	cx				; Inc the line length

	invoke	testkanj		; MSKK04 07/14/89
	jz	rdbat1			;
	cmp	cx, COMBUFLEN-1		;
	jae	TooLong			; can't start DBCS char at last pos'n
	stosb				;
	invoke	GetBatByt		;
	inc	cx			;
	jmp	short SAVBATBYT		;
rdbat1:					;

	cmp	cx,COMBUFLEN			; Is it too long?
	jae	TooLong 			; Yes - handle it, handle it
;
; See if we have a parameter character.
;
	CMP	AL,'%'                          ; Check for parameter
	JZ	NEEDPARM
;
; no parameter character.  Store it as usual and see if we are done.
;

SAVBATBYT:
	STOSB
	CMP	AL,0DH				; End of line found?
	JNZ	RDBAT				; no, go for more
;
; We have read in an entire line.  Decide whether we should echo the command
; line or not.
;

Found_EOL:
	SUB	DI,OFFSET TRANGROUP:COMBUF+3
	MOV	AX,DI				; remember that we've not counted the CR
	MOV	ES:[COMBUF+1],AL		; Set length of line
	invoke	GetBatByt			; Eat linefeed
	invoke	BATCLOSE
	CMP	SUPPRESS, NO_ECHO		;G
	JZ	Reset				;G
	test	[echoflag],1			; To echo or not to echo, that is the
	jnz	try_nextflag

Reset:
	PUSH	CS				;  question.  (Profound, huh?)
	POP	DS				; Go back to local segment
	retz					; no echoing here...
;
; Echo the command line with appropriate CRLF...
;


try_nextflag:
	cmp	nullflag,nullcommand		;G was there a command last time?
	jz	No_crlf_print			;G no - don't print crlf
	invoke	CRLF2				;G  Print out prompt

no_crlf_print:
	invoke	PRINT_PROMPT			;G
	PUSH	CS				;G change data segment
	POP	DS				;G

ASSUME DS:TRANGROUP
	mov	dx,OFFSET TRANGROUP:COMBUF+2	; get command line for echoing
	invoke	CRPRINT
	invoke	CRLF2
	return
;
; The line was too long.  Eat remainder of input text up until the CR
;
TooLong:
	ASSUME	DS:ResGroup
	cmp	al,0dh				; Has the end of the line been reached?
	jz	Ltlcont 			; Yes, continue
	CALL	SkipToEOL			; Eat remainder of line

Ltlcont:
	stosb					; Terminate the command
	jmp	Found_EOL			; Go process the valid part of the line
;
; We have found a parameter lead-in character.	Check for the 0-9 case first
;

NEEDPARM:
	invoke	GetBatByt			; get next character
	CMP	AL,'%'                          ; Check for two consecutive %
	JZ	SAVBATBYT			; if so, replace with a single %
	CMP	AL,0Dh				; Check for end-of-line
	JZ	SAVBATBYT			; yes, treat it normally
;
; We have found %<something>.  If the <something> is in the range 0-9, we
; retrieve the appropriate parameter from the batch segment.  Otherwise we
; see if the <something> has a terminating % and then look up the contents
; in the environment
;
PAROK:
	SUB	AL,'0'
	JB	NEEDENV 			; look for parameter in the environment
	CMP	AL,9
	JA	NEEDENV
;
; We have found %<number>.  This is taken from the parameters in the
; allocated batch area.
;
	CBW
	MOV	BX,AX				; move index into AX
	SHL	BX,1				; convert word index into byte ptr
	SaveReg <ES>
	MOV	ES,Batch
;
; The structure of the batch area is:
;
;   BYTE    type of segment
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; Get pointer to BX'th argument
;
	MOV	SI,ES:BatParm[BX]
	RestoreReg  <ES>
;
; Is there a parameter here?
;
	CMP	SI,-1				; Check if parameter exists
	JNZ	Yes_there_is			;G Yes go get it
	JMP	RDBAT				; Ignore if it doesn't
;
; Copy in the found parameter from batch segment
;

Yes_there_is:
	PUSH	DS
	MOV	DS,Batch
	ASSUME	DS:NOTHING
	dec	cx				; Don't count '%' in line length

CopyParm:
	LODSB					; From resident segment
	CMP	AL,0DH				; Check for end of parameter
	JZ	EndParam
	inc	cx				; Inc the line length
	cmp	cx,COMBUFLEN			; Is it too long?
	jae	LineTooL			; Yes - handle it, handle it
	STOSB
	JMP	CopyParm
;
; We have copied up to the limit.  Stop copying and eat remainder of batch
; line.  We need to make sure that the tooLong code isn't fooled into
; believing that we are at EOL.  Clobber AL too.
;

LineTooL:
	XOR	AL,AL
	POP	DS
	ASSUME	DS:RESGROUP
	JMP	TooLong
;
; We have copied in an entire parameter.  Go back for more
;

EndParam:
	POP	DS
	JMP	RDBat
;
; We have found % followed by something other than 0-9.  We presume that there
; will be a following % character.  In between is an environment variable that
; we will fetch and replace in the batch line with its value.
;

NEEDENV:
        dec     cx                              ;AN070; Don't count "%"
	SaveReg <DS,DI>
	MOV	DI,OFFSET TRANGROUP:ID		; temp spot for name
	ADD	AL,'0'                          ; reconvert character
	STOSB					; store it in appropriate place
;
; loop getting characters until the next % is found or until EOL
;

GETENV1:
	invoke	GetBatByt			; get the byte
	STOSB					; store it
	CMP	AL,0Dh				; EOL?
	JNZ	GETENV15			; no, see if it the term char
;
; The user entered a string with a % but no trailing %.  We copy the string.
;
	mov	byte ptr es:[di-1],0		; nul terminate the string
	mov	si,offset TranGroup:ID		; point to buffer
	pop	di				; point to line buffer
	push	cs
	pop	ds
	call	StrCpy
	jc	LineTooL
	pop	ds
	jmp	SavBatByt

GETENV15:
	CMP	AL,'%'                          ; terminating %?
	JNZ	GETENV1 			; no, go take out more characters

; M017 - following DEC is wrong, because we replace the % with a = here.
; This was the source of bug #1.
;	dec	cx				;AN070; Don't count "%"

	mov	al,'='                          ; terminate  with =
	MOV	ES:[DI-1],al
;
; ID now either has a =-terminated string which we are to find in the
; environment or a non =-terminated string which will not be found in the
; environment.
;
GETENV2:
	MOV	SI,OFFSET TRANGROUP:ID
	PUSH	CS
	POP	DS				; DS:SI POINTS TO NAME
	ASSUME DS:TRANGROUP
	PUSH	CX
	INVOKE	FIND_NAME_IN_environment
	ASSUME ES:RESGROUP
	POP	CX
	PUSH	ES
	POP	DS
	assume ds:resgroup
	PUSH	CS
	POP	ES
	ASSUME ES:TRANGROUP
	MOV	SI,DI
	POP	DI				; get back pointer to command line
;
; If the parameter was not found,  there is no need to perform any replacement.
; We merely pretend that we've copied the parameter.
;
	JC	GETENV6
;
; ES:DI points to command line being built
; DS:SI points either to nul-terminated environment object AFTER =
;

	ASSUME	ES:NOTHING
	call	StrCpy				; (let RdBat handle overflow)
GETENV6:
	pop	ds
	JMP	RDBAT				; no, go back to batch file

EndProc ReadBat

;
;   SkipToEOL - read from batch file until end of line
;

Procedure   SkipToEOL,NEAR

	ASSUME	DS:ResGroup,ES:NOTHING

	TEST	Batch,-1
	retz					; no batch file in effect
	invoke	GetBatByt
	CMP	AL,0Dh				; eol character?
	JNZ	SkipToEOL			; no, go eat another
	return

EndProc SkipToEOL

Break	<Allocate and deallocate the transient portion>

;
; Free Transient.  Modify ES,AX,flags
;

Procedure   Free_TPA,NEAR

ASSUME	DS:TRANGROUP,ES:RESGROUP

	PUSH	ES
	MOV	ES,[RESSEG]
	MOV	ES,[RES_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Make lots of free memory
	POP	ES

	return

EndProc Free_TPA

;
; Allocate transient.  Modify AX,BX,DX,flags
;

Procedure   Alloc_TPA,NEAR

ASSUME DS:TRANGROUP,ES:RESGROUP

	PUSH	ES
	MOV	ES,[RESSEG]
	MOV	BX,0FFFFH			; Re-allocate the transient
	MOV	AH,ALLOC
	INT	21h
	PUSH	BX				; Save size of block
	MOV	AH,ALLOC
	INT	21h
;
; Attempt to align TPA on 64K boundary
;
	POP	BX				; Restore size of block
	MOV	[RES_TPA], AX			; Save segment to beginning of block
	MOV	[TRAN_TPA], AX
;
; Is the segment already aligned on a 64K boundary
;
	MOV	DX, AX				; Save segment
	AND	AX, 0FFFH			; Test if above boundary
	JNZ	Calc_TPA
	MOV	AX, DX
	AND	AX, 0F000H			; Test if multiple of 64K
	JNZ	NOROUND

Calc_TPA:
	MOV	AX, DX
	AND	AX, 0F000H
	ADD	AX, 01000H			; Round up to next 64K boundary
	JC	NOROUND 			; Memory wrap if carry set
;
; Make sure that new boundary is within allocated range
;
	MOV	DX, [RES_TPA]
	ADD	DX, BX				; Compute maximum address
	CMP	DX, AX				; Is 64K address out of range?
	JB	NOROUND
;
; Make sure that we won't overwrite the transient
;
	MOV	BX, CS				; CS is beginning of transient
	CMP	BX, AX
	JB	NOROUND
;
; The area from the 64K boundary to the beginning of the transient must
; be at least 64K.
;
	SUB	BX, AX
	CMP	BX, 4096			; Size greater than 64K?
	JAE	ROUNDDONE

NOROUND:
	MOV	AX, [RES_TPA]

ROUNDDONE:
	MOV	[LTPA],AX			; Re-compute everything
	MOV	[TPA],AX
	MOV	BX,AX
	MOV	AX,CS
	SUB	AX,BX
	PUSH	BX
	MOV	BX,16
	MUL	BX
	POP	BX
	OR	DX,DX
	JZ	SAVSIZ2
	MOV	AX,-1

SAVSIZ2:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
	CMP	AX,512
	JBE	GotSize
	AND	AX,0FE00h			; NOT 511 = NOT 1FF

GotSize:
	MOV	[BYTCNT],AX
	POP	ES

	return

EndProc Alloc_TPA

Break	<BatCom - enter a batch file>

;
; The exec search has determined that the user has requested a batch file for
; execution.  We parse the arguments, create the batch segment, and signal
; batch processing.
;
Procedure   BatCom,NEAR

ASSUME	DS:TRANGROUP, ES:NOTHING

;
; Batch parameters are read with ES set to segment of resident part
;

	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	cmp	es:[call_batch_flag],call_in_progress ;AN043; If in CALL,
	jz	skip_ioset			;AN043;   redirection was already set up
	invoke	IOSET				; Set up any redirection

skip_ioset:					;AN043;
	CALL	FREE_TPA			; G
	cmp	es:[call_batch_flag],call_in_progress ;G
	jz	getecho 			; G if we're in a call, don't execute
;
; Since BATCH has lower precedence than PIPE or FOR.  If a new BATCH file is
; being started it MUST be true that no FOR or PIPE is currently in progress.
; Don't execute if in call
;
	invoke	ForOff

getecho:
	invoke	PipeOff
	mov	al,EchoFlag			; preserve echo state for chaining

	and	al, 1				; Save current echo state
	push	ax

	xor	ax,ax				;G
	test	es:[batch],-1			;G  Are we in a batch file?
	jz	leavebat			;G  No, nothing to save
	mov	ax,es:[batch]			;G get current batch segment
	cmp	es:[call_batch_flag],call_in_progress  ;G
	jz	leavebat			;G
;
;  We are in a chained batch file, save batlast from previous batch segment
;  so that if we're in a CALL, we will return to the correct batch file.
;
	push	es				;G
	mov	es,ax				;G get current batch segment
	mov	ax,es:[batlast] 		;G get previous batch segment
	pop	es				;G

leavebat:					;G
	push	ax				;G keep segment until new one created
	cmp	es:[call_batch_flag],call_in_progress  ;G are we in a CALL?
	jz	startbat			;G Yes, keep current batch segment
	call	BatchOff			;G No, deallocate old batch segment

;
; Find length of batch file
;

startbat:					;G
	ASSUME	ES:RESGROUP
	MOV	es:[CALL_BATCH_FLAG], 0 	;G  reset call flag
	mov	SI, OFFSET TRANGROUP:EXECPATH

	mov	ax,AppendTruename		;AN042; Get the real path where the batch file
	int	2fh				;AN042;    was found with APPEND
	mov	ah,Find_First			;AN042; The find_first will return it
	mov	dx,si				;AN042; Get the string
	mov	cx,search_attr			;AN042; filetypes to search for
	int	21h			;AN042;

	invoke	DStrLen
;
; Allocate batch area:
;   BYTE    type of segment
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; We allocate the maximum size for the command line and use setblock to shrink
; later when we've squeezed out the extra
;

	MOV	BX,CX				; length of file name.
	ADD	BX,0Fh + (SIZE BatchSegment) + COMBUFLEN + 0Fh
						; structure + max len + round up
	SaveReg <CX>
	MOV	CL,4
	SHR	BX,CL				; convert to paragraphs
	PUSH	BX				;G save size of batch segment
	MOV	AH,ALLOC
	INT	21h			; Allocate batch segment
	POP	BX				;G get size of batch segment
;
; This should *NEVER* return an error.	The transient is MUCH bigger than
; the batch segment.  This may not be true, however, in a multitasking system.
; G This error will occur with nesting of batch files.	We also need to
; G make sure that we don't overlay the transient.
;
	jc	mem_error			;G not enough memory - exit
	push	ax				;G save batch segment
	add	ax,bx				;G get end of batch segment
	add	ax,20h				;G add some tpa work area
	mov	bx,cs				;G get the transient segment
;
; M006; We cant check just for above. If the batchseg goes into a UMB, the
; M006; batchseg is always above the transient. We need to change this code
; M006; to only check for an overlap
;
	mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
	add	dx,15				;round up para; M006
	shr	dx,cl				;para size of transient; M006
	add	dx,bx				;dx = top of transient; M006

	cmp	ax,bx				; M006
	jb	enough_mem			; Batchseg below transient
						; enough memory ; M006
	cmp	ax,dx				; M006
	ja	enough_mem			; Batchseg above transient
						; enough memory ; M006
;
; M006; Batchseg overlaps transient -- insufficient memory
;
	pop	ax				; restore ax; M006

;M006;	cmp	ax,bx				;G do we end before the transient
;M006;	pop	ax				;G get batch segment back
;M006;	jb	enough_mem			;G we have enough memory - continue

	push	es				;G no we're hitting the transient
	mov	es,ax
	mov	ax,DEALLOC SHL 8		;G deallocate the batch segment
	int	21h
	pop	es

mem_error:
	jmp	no_memory			;G Set up for message and exit

enough_mem:
	pop	ax				; restore ax; M006

	MOV	[BATCH],AX
	CALL	ALLOC_TPA
;
; Initialize batch segment
;
	RestoreReg  <DX>			; length of name
	POP	AX				;G  get saved batch segment back
	inc	es:nest 			;G increment # batch files in progress
	PUSH	ES
	MOV	ES,[BATCH]
ASSUME	ES:NOTHING
	MOV	ES:[BatType],BatchType		; signal batch file type
	MOV	ES:[batlast],ax 		;G save segment of last batch file
	push	DS				;G
	mov	DS,[resseg]			;G set to resident data
ASSUME	DS:RESGROUP
	xor	ax,ax				;G
	mov	bl,forflag			;G get the current FOR state
	mov	ES:[batforflag],bl		;G save it in the batch segment
	test	bl,-1				;G are we in a FOR?
	jz	for_not_on			;G no, for segment set to 0
	mov	ax,forptr			;G yes, get current FOR segment
	mov	forflag,0			;G reset forflag

for_not_on:
	mov	ES:[batforptr],ax		;G save FOR segment in batch segment
	XOR	AX,AX
	mov	forptr,ax			;G make sure for segment is not active
	mov	bl,echoflag			;G
	pop	DS				;G

	mov	byte ptr es:[Batechoflag],bl	;G save echo state of parent
;SR;
; Initialize the new BatchEOF flag we have added to 0
;
	mov	es:BatchEOF,0

	MOV	WORD PTR ES:[BatSeek],AX	; point to beginning of file
	MOV	WORD PTR ES:[BatSeek+2],AX
;
; Initialize pointers
;
	DEC	AX				; put -1 into AX
	MOV	DI,BatParm			; point to parm area
	MOV	BX,DI
	MOV	CX,10
	REP	STOSW				; Init to no parms
;
; Move in batch file name
;
	MOV	CX,DX
	rep	movsb				; including NUL.
;
; Now copy the command line into batch segment, parsing the arguments along
; the way.  Segment will look like this:
;
;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
;
; or, in the case of fewer arguments:
;
;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
;
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	MOV	CX,10				; at most 10 arguments
;
; Look for beginning of next argument
;
EACHPARM:
	invoke	SCANOFF 			; skip to argument
;
; AL is first non-delimiter.  DS:SI points to char = AL
;
	CMP	AL,0DH				; end of road?
	JZ	HAVPARM 			; yes, no more arguments
;
; If CX = 0 then we have stored the most parm we can.  Skip store
;
	JCXZ	MOVPARM 			; Only first 10 parms get pointers
;
; Go into allocated piece and stick in new argument pointer.
;
	MOV	ES:[BX],DI			; store batch pointer
	ADD	BX,2				; advance arg counter
;
; Move the parameter into batch segment
;
MOVPARM:
	LODSB					; get byte
	INVOKE	DELIM				; if delimiter
	JZ	ENDPARM 			; then done with parm
	STOSB					; store byte
	CMP	AL,0DH				; if CR then not delimiter
	JZ	HAVPARM 			; but end of parm list, finish
	JMP	SHORT MOVPARM
;
; We have copied a parameter up until the first separator.  Terminate it with
; CR
;

ENDPARM:
	MOV	AL,0DH
	STOSB
	JCXZ	EACHPARM			; if no parameters, don't dec
	DEC	CX				; remember that we've seen one.
	JMP	SHORT EACHPARM
;
; We have parsed the entire line. Terminate the arg list
;

HAVPARM:
	XOR	AL,AL
	STOSB					; Nul terminate the parms
;
; Now we know EXACTLY how big the BATCH segment is.  Round up size (from DI)
; into paragraphs and setblock to the appropriate size
;
	LEA	BX,[DI+15]
	MOV	CL,4
	SHR	BX,CL
	MOV	AH,SetBlock
	INT	21h

	POP	ES
ASSUME	ES:RESGROUP
	PUSH	ES
	POP	DS				; Simply batch FCB setup
ASSUME	DS:RESGROUP
	CMP	[SINGLECOM],-1
	JNZ	NOBATSING
	MOV	[SINGLECOM],0FFF0H		; Flag single command BATCH job

NOBATSING:
;
; Enter the batch file with the current echo state
;
	pop	ax				; Get original echo state
	mov	echoflag,al			;g restore it
	JMP	TCOMMAND

;
; The following is executed if there isn't enough memory for batch segment
;

NO_MEMORY:
	assume ds:trangroup,es:resgroup
	pop	dx				;g even up our stack
	pop	ax				;g
	pop	ax				;g
	call	Alloc_tpa			;g reallocate memory
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr     ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,error_not_enough_memory ;AN000; get message number in control block
	jmp	cerror				;g print error message and go...

EndProc BatCom

Procedure   BatchOff

	ASSUME	DS:NOTHING,ES:NOTHING

	SaveReg <AX,ES>
	PUSH	DS				;G
	PUSH	BX				;G
	MOV	ES,ResSeg
	MOV	DS,ResSeg			;G
	ASSUME	ES:ResGroup,DS:Resgroup 	;G
	MOV	AX,Batch			; Free the batch segment
	OR	AX,AX
	JZ	nofree

	PUSH	ES
	MOV	ES,AX
	test	[echoflag],1			;G Is echo on?
	jnz	echo_last_line			;G Yes - echo last line in file
	mov	suppress,no_echo		;G no - don't echo last line in file

echo_last_line:
	MOV	BL,ES:[BATECHOFLAG]		;G  Get echo state
	mov	[echoflag],bl			;G     and restore it
	MOV	BX,ES:[BATFORPTR]		;G  Get FOR segment
	MOV	FORPTR,BX			;G     and restore it
	MOV	BL,ES:[BATFORFLAG]		;G  Get FOR flag
	MOV	FORFLAG,BL			;G     and restore it
	MOV	BX,es:[batlast] 		;G  get old batch segment
	MOV	AH,DEALLOC
	INT	21h
	POP	ES
	MOV	Next_BATCH,BX			;G  reset batch segment
	DEC	es:NEST 			;G

	XOR	AX,AX
	MOV	Batch,AX			; No batch in progress

NoFree:
	POP	BX				;G
	pop	ds				;G
	RestoreReg  <ES,AX>

	return

EndProc BatchOff


; StrCpy - copy string, checking count in CX against COMBUFLEN
;	Entry : DS:SI ==> source string
;		ES:DI ==> destination string
;		CX = current length of destination string
;	Exit  : string copied, CX updated, Carry set if length limit exceeded
Procedure StrCpy,NEAR
	push	ax
ccycle:
	lodsb
	inc	cx
	cmp	cx,COMBUFLEN
	jb	ccopy
	stc				; set carry to signal error
	jmp	short ccend
ccopy:
	stosb
	or	al,al
	jnz	ccycle

ccend:
	dec	cx			; discount extra byte
	dec	di			; back up pointer
	pop	ax
	return				; return carry clear
EndProc StrCpy

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\rucode.asm ===
page ,132
	title	Localizable code for resident COMMAND
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Added routines Lh_Off, Lh_Unlink &
;				Lh_OffUnlink for UMB support
;
;	M009	SR	08/01/90	Rewrote Lh_OffUnlink to restore the
;				initial UMB state. Removed Lh_off
;				and Lh_Unlink.
;

.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include filemode.inc
	include pdb.inc
	include mult.inc
	include doscntry.inc
	include devsym.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
	include resmsg.equ
	include	arena.inc		; M003
.list
.cref


DATARES segment public byte
	extrn	Abort_Char:byte
	extrn	BadFatMsg:byte
	extrn	BadFatSubst:byte
	extrn	Batch_Abort:byte
	extrn	BlkDevErr:byte
	extrn	BlkDevErrRw:byte
	extrn	BlkDevErrSubst:byte
	extrn	CDevAt:byte
	extrn	CharDevErr:byte
	extrn	CharDevErrRw:byte
	extrn	CharDevErrSubst:byte
	extrn	ComSpec:byte
	extrn	Crit_Err_Info:byte
	extrn	Crit_Msg_Off:word
	extrn	Crit_Msg_Seg:word
	extrn	CritMsgPtrs:word
	extrn	Dbcs_Vector_Addr:dword
	extrn	DevName:byte
	extrn	DrvLet:byte
	extrn	EndBatMes:byte
	extrn	ErrCd_24:word
	extrn	ErrType:byte
	extrn	Fail_Char:byte
	extrn	fFail:byte
	extrn	ForFlag:byte
	extrn	Ignore_Char:byte
	extrn	InitFlag:byte
	extrn	In_Batch:byte
	extrn	Int2fHandler:dword
	extrn	Loading:byte
	extrn	MsgBuffer:byte
	extrn	MsgPtrLists:dword
	extrn	MRead:byte
	extrn	MWrite:byte
	extrn	NeedVol:dword
	extrn	NeedVolMsg:byte
	extrn	NeedVolSubst:byte
	extrn	Newlin:byte
	extrn	No_Char:byte
	extrn	NUMEXTMSGS:abs
	extrn	NUMPARSMSGS:abs
	extrn	OldErrNo:word
	extrn	Parent:word
	extrn	ParsMsgPtrs:word
	extrn	Patricide:byte
	extrn	PermCom:byte
	extrn	Retry_Char:byte
	extrn	Req_Abort:byte
	extrn	Req_End:byte
	extrn	Req_Fail:byte
	extrn	Req_Ignore:byte
	extrn	Req_Retry:byte
	extrn	ResMsgEnd:word
	extrn	PipeFlag:byte
	extrn	SingleCom:word
	extrn	VolName:byte
	extrn	Yes_Char:byte

	extrn	OldDS:word
	extrn	Int2f_Entry:dword

DATARES ends

; NTVDM use diff al value so we don't confuse dos 5.0
; NTVDM command.com GET_COMMAND_STATE       equ     5500h
GET_COMMAND_STATE       equ     5501h



CODERES segment public byte

	extrn	GetComDsk2:near

	public	AskEnd
	public	Crlf
	public	DskErr
	public	MsgInt2fHandler
	public	MsgRetriever
	public	RPrint
ifdef BILINGUAL
	public	RPrint@
endif

	ifdef	DBCS
	public	ITestKanj
	endif

;	Bugbug:	Move rest of PUBLIC declarations up here.

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING



;***	AskEnd - ask user to confirm batch file termination
;
;	Confirm with user before freeing batch ...
;
;	ENTRY	nothing
;
;	EXIT	CY = set if batch termination is confirmed
;
;		CY = clear if batch should continue
;
;	USED	AX,DX,...

;	Bugbug:	move this to transient, copy to batch segment.
;	Bugbug:	or move it to command1 1st.

;	Bugbug: No_Char and Yes_Char should be constants.

AskEnd	proc

	assume	ds:DATARES

	mov	dx,offset DATARES:EndBatMes	; DX = message #
	call	RPrint
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + STD_CON_INPUT
	int	21h
	call	CharToUpper			; change to upper case
	cmp	al,No_Char
	je	aeRet				; answer is no (CY is clear)
	cmp	al,Yes_Char
	jne	AskEnd				; invalid response, try again
	stc					; answer is yes
aeRet:	ret

AskEnd	endp




;***	DskErr - critical error handler
;
;	Default critical error handler unless user intercepts int 24h.
;
;	ENTRY	int 24h
;
;	EXIT
;
;	USED
;
;	EFFECTS

;
;SR; 
; The stub is going to push the old ds value and the resident data segment
;onto the stack in that order. Get it off the stack
;

DskErr	proc	far

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume 	ds:DATARES
	pop	OldDS			;save old ds value

	sti
	push	es
	push	si
	push	cx
	push	di
	push	cx
	push	ax

	push	ds			;save our data segment
	pop	es			;es = DATARES

	mov	ds,bp
	assume	ds:nothing

	mov	ax,[si].SDEVATT
	mov	es:CDevAt,ah

;;	push	cs
;;	pop	es

	mov	di,offset DATARES:DevName
	mov	cx,8
	add	si,SDEVNAME	; save device name (even for block device)

	cld
	rep	movsb
	pop	ax
	pop	cx
	pop	di

;	Stack still contains DS and ES.

;SR;
; We need ds = DATARES for SavHand
;
	push	es
	pop	ds
	assume	ds:DATARES

	invoke	SavHand		; save user's stdin/out, set to our stderr

;;	push	cs
;;	pop	ds		; set up local data segment
;;	assume	ds:resgroup

	push	dx
	call	Crlf
	pop	dx

;	Bugbug:	rename Crit_Err_Info to CritErrAH?

	mov	Crit_Err_Info,ah	; save critical error flags

;	Compute and save ASCII drive letter (nonsense for char devices)

	add	al,'A'
	mov	DrvLet,al

;	Bugbug:	These labels are awful.  Change, especially 'NoHardE'.

	test	ah,80h
	jz	NoHardE			; it's a disk-device error
	test	CDevAt,DEVTYP shr 8
	jnz	NoHardE			; it's a character device
	jmp	FatErr			; it's a FAT error

NoHardE:
	mov	si,offset DATARES:MRead  ; SI = "read" msg #
	test	ah,1
	jz	SavMes			  ; it's a read error
	mov	si,offset DATARES:MWrite ; SI = "write" msg #

SavMes:
	mov	OldErrNo,di		; save critical error code

;	Bugbug:	don't need to save/restore all here?
	push	es
	push	ds			; GetExtendedError likes to STOMP
	push	bp
	push	si
	push	dx
	push	cx
	push	bx
	mov	ah,GetExtendedError	; get extended error info
	int	21h
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	bp
	pop	ds
	mov	word ptr NeedVol,di 	; save possible ptr to volume label
	mov	word ptr NeedVol+2,es
	pop	es

;	Bugbug:	AX has extended error code, so no need to zero AH?

	xor	ah,ah
	mov	di,ax			; DI = error code

; Bugbug:  somewhat obsolete documentation?
;
; DI is now the correct error code.  Classify things to see what we are
; allowed to report.  We convert DI into a 0-based index into a message table.
; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
; the like) are contiguous.
;

;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
;	Check use of ErrCd_24, though.

	sub	di,ERROR_WRITE_PROTECT
	jae	HavCod

;	Bugbug	wouldn't it be better to display the original error msg,
;	even though it's not a critical error?

	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT
;
; DI now has the mapped error code.  Old style errors are:
;   FOOBAR <read|writ>ing drive ZZ.
; New style errors are:
;   FOOBAR
; We need to figure out which the particular error belongs to.
;

HavCod:
	mov	ErrType,0		; assume old style
	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT
	je	SetStyle
	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT
	jne	GotStyle

SetStyle:
;	Bugbug:	use INC
	mov	ErrType,1		; must be new type

GotStyle:
	mov	[ErrCd_24],di
	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT
						; If the error message is unknown
	jbe	NormalError			;  redirector, continue.  Otherwise,
;
; We do not know how to handle this error.  Ask IFSFUNC if she knows
; how to handle things
;

;input to IFSFUNC:    AL=1
;		      BX=extended error number
;
;output from IFSFUNC: AL=error type (0 or 1)
;			 0=<message> error (read/writ)ing (drive/device) xxx
;			   Abort, Retry, Ignore
;			 1=<message>
;			   Abort, Retry, Ignore
;		      ES:DI=pointer to message text
;		      carry set=>no message

	mov	di,ax			; retrieve correct extended error...
	mov	ax,0500h		; is the redir there?
	int	2fh
	cmp	al,0ffh
	jne	NoHandler		; no, go to NoHandler
	push	bx
	mov	bx,di			; get ErrType and ptr to error msg
	mov	ax,0501h
	int	2fh
	pop	bx 
	jc	NoHandler

;	Bugbug:	need to record error type?
	mov	ErrType,al
	push	ds
	push	es
	pop	ds
	mov	dx,di
	mov	cx,-1			; find end of msg
	xor	al,al

	cld
	repnz	scasb

;	Bugbug:	we can do better than this.

	mov	byte ptr [di-1],'$'
	mov	ah,STD_CON_STRING_OUTPUT	; print the message
	int	21h
	mov	byte ptr [di-1],0		; restore terminal byte

	pop	ds				; clean up and continue
	jmp	short CheckErrType

;*	Redir isn't available or doesn't recognize the error.
;	Restore regs to unextended error.

NoHandler:
	mov	ErrType,0
;	Bugbug:	won't this break, since we add error_write_protect back in?
	mov	di,OldErrNo
	mov	ErrCd_24,di

NormalError:
	add	di,ERROR_WRITE_PROTECT
	xchg	di,dx			; may need dx later
	call	RPrintCrit		; print error type

CheckErrType:
	cmp	ErrType,0		; Check error style...
	je	ContOld
	call	CrLf			; if new style then done printing
	jmp	short Ask

ContOld:
	inc	si			; DS:SI = ptr to asciiz string

;	Bugbug:	combine some of the following two sections?

	test	[CDevAt],DEVTYP shr 8
	jz	BlkErr
	mov	dx,offset DATARES:CharDevErr	  ; DX = ptr to device message
	mov	CharDevErrRw.SubstPtr,si	  ; point to read/write string
	mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block

	call	RPrint				; print the message
	jmp	short Ask			; don't ralph on command

BlkErr:
	mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
	mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
	mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
	call	RPrint

	cmp	Loading,0
	jz	Ask
	invoke	RestHand
	jmp	GetComDsk2		; if error loading COMMAND, re-prompt

Ask:
	cmp	[ErrCd_24],15		; error 15 has an extra message
	jne	Not15			; not error 15

;*	For error 15, tell the user which volume/serial # are needed.

	push	cx

;	Bugbug:	does this push/pop need to be done?
	push	ds
	pop	es
	lds	si,NeedVol
	assume	ds:NOTHING
	push	di
	mov	di,offset DATARES:VolName
	mov	cx,16			; copy volume name & serial #
	cld
	rep	movsb
	pop	di
	push	es
	pop	ds
	pop	cx
	assume	ds:DATARES
	mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
	mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
	call	RPrint
Not15:

;*	Print abort, retry, ignore, fail message.
;	Print only options that are valid.

;	Bugbug:	sizzle this.

	mov	dx,offset DATARES:Req_Abort
	call	RPrint
	test	Crit_Err_Info,RETRY_ALLOWED
	jz	Try_Ignore
	mov	dx,offset DATARES:Req_Retry
	call	RPrint

Try_Ignore:
	test	Crit_Err_Info,IGNORE_ALLOWED
	jz	Try_Fail
	mov	dx,offset DATARES:Req_Ignore
	call	RPrint

Try_Fail:
	test	Crit_Err_Info,FAIL_ALLOWED
	jz	Term_Question
	mov	dx,offset DATARES:Req_Fail
	call	RPrint

Term_Question:
	mov	dx,offset DATARES:Req_End
	call	RPrint

;	If the /f switch was given, we fail all requests.

	test	fFail,-1
	jz	DoPrompt
	mov	ah,3				; signal fail
	jmp	EExit

DoPrompt:
	mov	ax,(STD_CON_INPUT_FLUSH shl 8) + STD_CON_INPUT
	int	21h				; get response


;	Bugbug:	can Kanji code be conditional?

	ifdef	DBCS

	invoke	TestKanjR			; 3/3/KK
	jz	NotKanj 			; 3/3/KK
	mov	ax,(STD_CON_INPUT shl 8)	; eat the 2nd byte of ECS code  3/3/KK
	int	21h				; 3/3/KK
	call	Crlf				; 3/3/KK
	jmp	Ask				; 3/3/KK
NotKanj:					; 3/3/KK

	endif

	call	Crlf
	call	CharToUpper			; convert to upper case
	mov	ah,0				; return code for ignore
	test	Crit_Err_Info,IGNORE_ALLOWED	; is ignore allowed?
	jz	user_retry
	cmp	al,Ignore_Char			; ignore?
	jz	EExitJ

;	Bugbug:	optimize following code.

User_Retry:
	inc	ah				; return code for retry
	test	Crit_Err_Info,RETRY_ALLOWED	; is retry allowed?
	jz	User_Abort
	cmp	al,Retry_Char			; retry?
	jz	EExitJ

User_Abort:
	inc	ah				; return code for abort
						;  (abort always allowed)
	cmp	al,Abort_Char			; abort?
	jz	Abort_Process			; exit user program
	inc	ah				; return code for fail
	test	Crit_Err_Info,FAIL_ALLOWED	; is fail allowed?
	jz	AskJ
	cmp	al,Fail_Char			; fail?
	jz	EExitJ

AskJ:
	jmp	Ask

EExitJ:
	jmp short EExit

Abort_Process:
	test	InitFlag,INITINIT		; COMMAND init interrupted?
	jz	AbortCont			; no, handle it normally
	cmp	PermCom,0			; are we top level process?
	jz	JustExit			; yes, just exit
	mov	dx,offset DATARES:Patricide	; no, load ptr to error msg
	call	RPrint				; print it

DeadInTheWater:
	jmp	DeadInTheWater			; loop until the user reboots

JustExit:
	assume	ds:DATARES
	mov	ax,Parent			; load real parent pid
	mov	word ptr ds:Pdb_Parent_Pid,ax 	; put it back where it belongs
	mov	ax,(EXIT shl 8) or 255
	int	21h

AbortCont:
	test	byte ptr In_Batch,-1	; Are we accessing a batch file?
	jz	Not_Batch_Abort
	mov	byte ptr Batch_Abort,1	; set flag for abort

Not_Batch_Abort:
	mov	dl,PipeFlag
	invoke	ResPipeOff
	or	dl,dl
	je	CheckForA
	cmp	SingleCom,0
	je	CheckForA
	mov	SingleCom,-1			; make sure singlecom exits

CheckForA:
	cmp	ErrCd_24,0			; write protect?
	je	AbortFor
	cmp	ErrCd_24,2			; drive not ready?
	jne	EExit				; don't abort the FOR

abortfor:
	mov	ForFlag,0			; abort a FOR in progress
	cmp	SingleCom,0
	je	EExit
	mov	SingleCom,-1			; make sure singlecom exits

EExit:
	mov	al,ah
	mov	dx,di

RestHd:
	invoke	RestHand
	pop	cx
	pop	si				; restore registers
	pop	es

;;	pop	ds
;SR;
; ds has to be got from the variable we saved it in
;

 	mov	ds,OldDS			;restore old value of ds
;	pop	ds
	assume	ds:nothing

	iret

FatErr:
	mov	dx,offset DATARES:BadFatMsg
	mov	si,offset DATARES:BadFatSubst
	call	RPrint

	mov	al,2				; abort
	jmp	RestHd

DskErr	endp




;***	RPrint - print message
;***	Crlf - display cr/lf
;
;	ENTRY	DS:DX = ptr to count byte, followed by message text
;		DS:SI = ptr to 1st substitution block for this msg, if any
;		variable fields related to substitution blocks are set
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout.
;
;	NOTE
;	  Number of substitutions (%1, %2,...) in message text must not
;	    be greater than number of substition blocks present.


Crlf: 
	mov	dx,offset DATARES:Newlin	; cheap newline

RPrint	proc

	assume	ds:DATARES,ss:DATARES

;	Bugbug:	do we need to save all reg's?

	push	si			; preserve registers
	push	ax
	push	bx
	push	cx
	push	dx

	mov	bx,si			; DS:BX = ptr to subst block
	mov	si,dx			; DS:SI = ptr to count byte
	lodsb				; AL = message length
					; DS:SI = ptr to message text
	xor	cx,cx
	mov	cl,al			; CX = message length

ifdef BILINGUAL
	call	IsDBCSCodePage
	jnz	rp_us			; if not DBCS code page
	push	ax
	push	si
	xor	cx,cx
@@:
	lodsb
	inc	cx
	or	al,al
	jnz	@b
	dec	cx
	pop	si
	pop	ax
	jmp	short rp_next
rp_us:
	push	ax
@@:
	lodsb
	dec	cx
	or	al,al
	jnz	@b
	pop	ax
rp_next:

endif

	jcxz	rpRet

	call	RDispMsg

rpRet:	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	si
	ret

RPrint	endp

ifdef BILINGUAL
RPrint@	proc
	push	ax
	push	bx
	push	cx
	push	si
	mov	bx,si			; DS:BX = ptr to subst block
	mov	si,dx			; DS:SI = ptr to count byte
	lodsb				; AL = message length
					; DS:SI = ptr to message text
	xor	cx,cx
	mov	cl,al			; CX = message length
	jcxz	@f

	call	RDispMsg

@@:
	pop	si
	pop	cx
	pop	bx
	pop	ax
	ret
RPrint@	endp
endif




;***	RPrintCrit - print critical error message
;
;	ENTRY	DX = extended error # (19-39)
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout

RPrintCrit	proc

	assume	ds:DATARES,ss:DATARES

	push	dx			; preserve DX
	xchg	bx,dx			; BX = extended error #
					; DX = saved BX
	sub	bx,19			; BX = critical error index, from 0

ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	rpc_next		; if Kanji mode
	add	bx,21
	push	ax
@@:
	lodsb
	or	al,al
	jnz	@b
	pop	ax
	dec	si
rpc_next:
endif

	shl	bx,1			; BX = offset in word table
	mov	bx,CritMsgPtrs[bx]	; BX = ptr to error msg
	xchg	bx,dx			; DX = ptr to error msg
					; BX = restored
ifdef BILINGUAL
	call	RPrint@			; print the message
else
	call	RPrint			; print the message
endif
	pop	dx			; restore DX
	ret

RPrintCrit	endp




;***	RDispMsg - display message
;
;	Display message, with substitutions, for RPrint.
;
;	ENTRY	DS:SI = ptr to message text
;		CX = message length
;		DS:BX = ptr to substitution block, if any
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI

RDispMsg	proc

	assume	ds:DATARES,ss:DATARES

rdNextChar:
	lodsb				; AL = next char
	cmp	al,'%'
	jne	rdOutChar		; not a substitution
	mov	dl,ds:[si]		; DL = possible '1' - '9'
	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
	cmp	dl,9
	jae	rdOutChar		; not a substitution

;*	A substitution code %1 - %9 has been encountered.
;	DL = 0-8, indicating %1-%9
;	DS:BX = ptr to substitution block

	call	SubstMsg		; display the substitution
	inc	si			; SI = ptr past %n
	dec	cx			; count extra character in %n
	jmp	short rdCharDone

;*	Normal character output.

rdOutChar:
	mov	dl,al			; DL = char
	mov	ah,2			; AH = DOS Character Output code
	int	21h			; call DOS
rdCharDone:
	loop	rdNextChar
	ret

RDispMsg	endp




;***	SubstMsg - display message substitution
;
;	Display a substitution string within a message.
;	Substitution can be a char, an ASCIIZ string, or
;	a word to be displayed as hex digits.
;
;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
;		DS:BX = ptr to substitution block
;
;	EXIT	nothing
;
;	USED	AX,DX

SubstMsg	proc

	assume	ds:DATARES,ss:DATARES

	push	bx			; preserve BX
	push	cx			; preserve CX

	mov	al,size SUBST		; AL = size of substitution block
	mul	dl			; AX = offset of desired subst block
	add	bx,ax			; DS:BX = ptr to desired subst block

	mov	al,[bx].SubstType	; AX = substitution type flag
	mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value

;	AL = 1, 2, or 3 for char, string, or hex type

	dec	al
	jz	smChar
	dec	al
	jz	smStr

;*	Hex number substitution.

	mov	ax,ds:[bx]		; AX = word value
	mov	cx,4			; CX = # digits to display
smDigit:
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1			; AL<3:0> = next digit

	push	ax			; save other digits
	and	al,0Fh			; AL = binary digit
	add	al,'0'			; AL = ascii digit if 0-9
	cmp	al,'9'
	jbe	@F			; it's 0-9
	add	al,'A' - '0' - 10	; AL = ascii digit A-F
@@:
	mov	dl,al			; DL = ascii digit
	mov	ah,2
	int	21h			; output the ascii digit
	pop	ax			; restore all digits

	loop	smDigit
	jmp	short smRet

;*	Char substitution.

smChar:
	mov	dl,ds:[bx]		; DL = char to output
	mov	ah,2
	int	21h
	jmp	short smRet

;*	String substitution.

smStr:
	mov	dl,ds:[bx]		; DL = next char
	or	dl,dl
	jz	smRet			; null char - we're done
	mov	ah,2
	int	21h			; display char
	inc	bx			; DS:BX = ptr to next char
	jmp	smStr

smRet:	pop	cx
	pop	bx
	ret

SubstMsg	endp




;***	CharToUpper - convert character to uppercase
;
;	ENTRY	AL = char
;
;	EXIT	AL = uppercase char
;
;	USED	AX

CharToUpper	proc

	assume	ds:DATARES

	push	ax		; put char on stack as arg to int 2F
	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
	int	2Fh
	inc	sp		; throw away old char on stack
	inc	sp
	ret

CharToUpper	endp





	ifdef	DBCS

;***	ITestKanj - DBCS lead byte check

ITestKanj:
TestKanjR:				; 3/3/KK
	push	ds
	push	si
	push	ax
	lds	si,Dbcs_Vector_Addr

ktLop:
	cmp	word ptr ds:[si],0	; end of Lead Byte Table
	je	NotLead
	pop	ax
	push	ax
	cmp	al, byte ptr ds:[si]
	jb	NotLead
	inc	si
	cmp	al, byte ptr ds:[si]
	jbe	IsLead
	inc	si
	jmp	short ktLop		; try another range

NotLead:
	xor	ax,ax			; set zero
	jmp	short ktRet

Islead:
	xor	ax,ax			; reset zero
	inc	ax

ktRet:
	pop	ax
	pop	si
	pop	ds
	ret

	endif




;***	MsgInt2fHandler - int 2f handler for message retrieval
;
;	ENTRY	If we handle it -
;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
;		  DL = operation =
;		     0 = get extended error messages
;		     1 = set extended error messages
;		     2 = get parse error messages
;		     3 = set parse error messages
;		     4 = get critical error messages
;		     5 = set critical error messages
;		     6 = get file system error messages
;		     7 = set file system error messages
;		     8 = get disk retriever routine
;		     9 = set disk retriever routine
;		  ES:DI = address for 'set' operations
;
;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
;
;	NOTE
;	  This handler replaces the one that used to reside in DOS.
;	  'Set' operations are ignored.
;	  'File system error messages' are not supported.

;SR;
; At the int 2fh entry point we push the old ds value and the resident data
;segment address. Get them off the stack
;

MsgInt2fHandler	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;save old value of ds

	cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
	je	miOurs			; it's ours

        cmp     ax, GET_COMMAND_STATE
        je      fcOurs

;SR;
; We cannot do a far jump any more because cs cannot be used. Push the cs:ip
;onto the stack and do a far return to jump to the next 2fh handler. 
;Our old ds is on the stack. We need to restore it but we cannot lose the
;current value of ds as it points at the data segment. So we do some kinky
;stack manipulations.
;
	push	ax
	push	ax			;create 2 words on stack for retf

	push	bp
	push	ax

	mov	bp,sp			;bp can be used to address stack
;
;Swap the old ds value with the second dummy word on the stack. Now, we can
;do a 'pop ds' at the end to restore our ds
;
	mov	ax,[bp+8]		;ax = old ds value
	mov	[bp+4],ax
	
	mov	ax,word ptr ds:Int2fHandler+2
	mov	[bp+8],ax		;put segment address
	mov	ax,word ptr ds:Int2fHandler
	mov	[bp+6],ax		;put offset address


	pop	ax
	pop	bp
	pop	ds

	retf				;chain on to next handler

;;	jmp	Int2fHandler		; hand off to next 2f handler

fcOurs:
;
;We have to clear ax, and return in ds:si a pointer to the stub jump table
;
	pop	ax			;discard ds currently on stack
	push	ds			;store our data segment

	mov	si,offset DATARES:Int2f_Entry ;start of table

	xor	ax,ax			;indicate COMMAND present
	jmp	short miRet		;return to caller


miOurs:
	test	dl,1
	jnz	miRet			; ignore 'set' operations

	push	bx			; preserve BX
	mov	bx,dx
	xor	bh,bh			; BX = index in word table
	shl	bx,1			; BX = index in dword table
	les	di,MsgPtrLists[bx]		; ES:DI = ptr to msg ptr list
	pop	bx			; restore BX

miRet:
;	mov	ds,OldDS		;restore ds
	pop	ds
	assume	ds:nothing

	iret

MsgInt2fHandler	endp




;***	MsgRetriever - message retrieval routine for utilities
;
;	Address of this routine is passed to utility programs via 
;	message services int 2f.  We try to find the desired message
;	in memory or in our disk image.
;
;	ENTRY	AX = message #
;		DI = offset in RESGROUP of msg ptr list
;		ComSpec = asciiz pathname to our disk image
;
;	EXIT	CY clear for success
;		ES:DI = ptr to count byte, followed by message text
;
;		CY set for failure
;
;	USED	flags
;
;	NOTE
;	  The message # in AX is used to compute an offset into
;	  the message ptr list pointed to by DI.  The lists must
;	  start with message # 1 and proceed through consecutive
;	  message #'s.  
;
;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
;	  ExtMsgPtrs.  We use NUMPARSEMSGS and NUMEXTMSGS to check for
;	  valid message #.  ;M033
;
;	  List positions with no corresponding message text are
;	  indicated by null pointers, which this routine detects.

;SR; This routine will be called directly by the utilities. So, we have
; trap for it in the stub. The stub pushes the old value of ds and the 
; DATARES value on the stack. We get them off the stack to setup ds here
;

MsgRetriever	proc	far

	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	pop	ds			;ds = DATARES
	assume	ds:DATARES
;	pop	OldDS			;save old ds

	push	ax			; preserve registers
	push	bx
	push	cx
	push	dx
	push	si

;;	push	ds
;;	push	cs
;;	pop	ds			; DS = DATARES seg addr
;;	assume	ds:RESGROUP
;;	push	cs

	push	ds			; get es from ds
	pop	es			; ES = DATARES seg addr

;	Begin modification M033.

;	Make sure msg # is valid.
;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.

	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
	cmp	di,offset DATARES:ParsMsgPtrs
	je	@f			; it's ParsMsgPtrs
	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
@@:	cmp	bx,ax
	jc	mrRet			; msg # too high, return carry

;	Msg # is valid.

;	End modification M033.

	dec	ax
	shl	ax,1			; AX = offset into msg ptr list
	add	di,ax			; DI = ptr to msg ptr

	cmp	di,ResMsgEnd
	jb	mrInMem			; ptr (and message) in memory

;*	Retrieve message from disk.
;	Read once to get the ptr to the message, then again for the message.

	mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
	mov	dx,EXT_EXISTS_OPEN		; DX = 'open existing file'
	mov	bx,INT_24_ERROR			; BX = 'fail on crit error'
	mov	ax,EXTOPEN shl 8		; AX = 'Extended Open File'
	int	21h				; call DOS
	jc	mrRet				; return failure

	mov	bx,ax				; BX = file handle
	mov	dx,di				; DX = ptr to msg ptr
	xor	si,si				; SI = read count
mrRead:
	sub	dx,100h				; DX = LSW of file offset
	xor	cx,cx				; CX = MSW of file offset
	mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
	int	21h				; call DOS
	jc	mrCloseFile			; handle error

	mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
	mov	cx,64				; CX = # bytes to read
	mov	ah,READ				; AH = 'Read File'
	int	21h				; call DOS
	jc	mrCloseFile			; handle error

	or	si,si				; (CY cleared)
	jnz	mrCloseFile			; 2nd time thru - we're done
	inc	si				; mark one read done
	mov	dx,word ptr MsgBuffer		; DX = ptr to message
	or	dx,dx
	jnz	mrRead				; go read the message
	stc					; null ptr found- no msg

mrCloseFile:
	pushf				; save success/failure (CY)
	mov	ah,CLOSE		; AH = 'Close File'
	int	21h			; call DOS
;	Bugbug: should we avoid this popf?
	popf				; CY = success/failure
	mov	di,dx			; ES:DI = ptr to msg, if successful
	jmp	short mrRet		; we're done


;*	Message ptr is in memory.
;	If ptr is in memory, assume message is in memory (/msg).

mrInMem:
	mov	di,es:[di]		; ES:DI = ptr to msg
	or	di,di			; (CY cleared)
	jnz	mrRet			; found message
	stc				; null ptr found- no message

mrRet:	
	pop	si			;restore all registers
	pop	dx
	pop	cx
	pop	bx
	pop	ax

;	mov	ds,OldDS		;restore ds
	pop	ds
	assume	ds:nothing

	ret

MsgRetriever	endp

;
; M003; Start of changes for UMB support
;


;***	Lh_OffUnlink -- Restore allocation strat and link state
;
;	ENTRY	al = Saved alloc strat and link state
;			b0 = 1 if alloc strat to restore is HighFirst
;			b1 = 1 if link state to restore is Linked
;
;	EXIT	None
;
;	USED	ax, bx, cx
;
;

public	Lh_OffUnlink
Lh_OffUnlink	proc	far

	mov	ch,al
	mov	cl,al
	mov	ax,(ALLOCOPER shl 8) OR 0
	int	21h
	mov	bx,ax
	ror	cl,1				;b7 = HighFirst bit
	and	cl,80h				;mask off b6-b0
	and	bl,7fh				;mask off HighFirst bit
	or	bl,cl				;set HighFirst bit state
	mov	ax,(ALLOCOPER shl 8) OR 1
	int	21h				;set alloc strat

	mov	bl,ch
	shr	bl,1
	xor	bh,bh				;bx = linkstate
	mov	ax,(ALLOCOPER shl 8) OR 3
	int	21h				;set linkstate

	ret

Lh_OffUnlink	endp

;
; M003; End of changes for UMB support
;

ifdef BILINGUAL
IsDBCSCodePage	proc	near
	push	ax
	push	bx
	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh
ifdef JAPAN
	cmp	bx,932
endif
ifdef KOREA
	cmp	bx,949
endif
ifdef TAIWAN
	cmp	bx,950
endif
ifdef PRC
	cmp	bx,936
endif
	pop	bx
	pop	ax
	ret
IsDBCSCodePage	endp
endif

public	EndCode
EndCode	label	byte

CODERES ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tcmd1b.asm ===
page ,132
;	SCCSID = @(#)tcmd1b.asm 1.1 85/05/14
;	SCCSID = @(#)tcmd1b.asm 1.1 85/05/14
TITLE	PART4 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Internal commands DIR,PAUSE,ERASE,TYPE,VOL,VER

.xlist
.xcref
	include dossym.inc
	include bpb.inc
	include syscall.inc
	include filemode.inc
	include sf.inc
	include comseg.asm
	include comsw.asm		;ac000;
	include comequ.asm
	include ioctl.inc		;an000;
.list
.cref

DATARES SEGMENT PUBLIC BYTE             ;AN020;AC068;
        EXTRN   append_flag:byte        ;AN020;AC068;
	EXTRN	append_state:word	;AN020;AC068;
	EXTRN	SCS_PAUSE:BYTE		; yst 4-5-93
DATARES ENDS                            ;AN020;AC068;

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	badcpmes_ptr:word	;AC022;
	EXTRN	Extend_buf_ptr:word	;AC000;
	EXTRN	Extend_buf_sub:byte	;AN000;
	EXTRN	inornot_ptr:word
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	parse_erase:byte	;AC000;
	EXTRN	parse_mrdir:byte	;AC000;
	EXTRN	parse_rename:byte	;AC000;
	EXTRN	parse_vol:byte		;AC000;
	EXTRN	PauseMes_ptr:word
	EXTRN	renerr_ptr:word
	EXTRN	slash_p_syn:word	;AC000;
	EXTRN	volmes_ptr:word 	;AC000;
	EXTRN	volmes_ptr_2:word	;AC000;
	EXTRN	volsermes_ptr:word	;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	bytcnt:word
	EXTRN	charbuf:byte
	EXTRN	comsw:word
	EXTRN	curdrv:byte
	EXTRN	destinfo:byte
	EXTRN	destisdir:byte
	EXTRN	dirbuf:byte
	EXTRN	msg_numb:word		;AN022;
	EXTRN	one_char_val:byte
	EXTRN	parse1_addr:dword	;AN000;
	EXTRN	parse1_syn:word 	;AN000;
        EXTRN   resseg:word             ;AN020;AC068;
	EXTRN	srcbuf:byte		;AN000;
	EXTRN	string_ptr_2:word	;AN000;
	EXTRN	TPA:word
	EXTRN	vol_drv:byte
	EXTRN	vol_ioctl_buf:byte	;AC000;
	EXTRN	vol_label:byte		;AC000;
	EXTRN	vol_serial:dword	;AC000;
	EXTRN	zflag:byte

	extrn	TypeFilSiz:dword
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
transpace   ends
;---------------

	EXTRN	cerror:near
	EXTRN	error_output:near
	EXTRN	notest2:near
	EXTRN	slashp_erase:near	;AN000;
	EXTRN	std_printf:near
	EXTRN	tcommand:near

	PUBLIC	badpath_err		;AN022;
	PUBLIC	crename
	PUBLIC	DisAppend
	PUBLIC	erase
	PUBLIC	extend_setup		;AN022;
	PUBLIC	Get_ext_error_number	;AN022;
	PUBLIC	pause
	PUBLIC	Set_ext_error_msg	;AN000;
	PUBLIC	typefil
	PUBLIC	volume


	break	Pause
PAUSE:
	push	ds
	mov	ds, ResSeg
	assume	ds:resgroup
	cmp	SCS_PAUSE, 0
	pop	ds
	jne	pause_break

assume	ds:trangroup,es:trangroup
	mov	dx,offset trangroup:pausemes_ptr
	call	std_printf
	invoke	GetKeystroke
	invoke	crlf2
pause_break:
	return

	break	Erase

;****************************************************************
;*
;* ROUTINE:	DEL/ERASE - erase file(s)
;*
;* FUNCTION:	PARSE command line for file or path name and /P
;*		and invoke PATHCRUNCH.	If an error occurs, set
;*		up an error message and transfer control to CERROR.
;*		Otherwise, transfer control to NOTEST2 if /P not
;*		entered or SLASHP_ERASE if /P entered.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	if no error:
;*		FCB at 5ch set up with filename(s) entered
;*		Current directory set to entered directory
;*
;****************************************************************

assume	ds:trangroup,es:trangroup

ERASE:
	mov	si,81H				;AC000; get command line
	mov	comsw,0 			;AN000; clear switch indicator
	mov	di,offset trangroup:parse_erase ;AN000; Get adderss of PARSE_erase
	xor	cx,cx				;AN000; clear cx,dx

erase_scan:
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jz	good_line			;AN000; yes - done parsing
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	errj2				;AC000; yes exit

	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
	je	set_erase_prompt		;AN000; yes - go set prompt

;
; Must be filespec since no other matches occurred. move filename to srcbuf
;
	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	cmp	byte ptr[si+1],colon_char	;AC000; drive specified?
	jnz	Erase_drive_ok			;AC000; no - continue
	cmp	byte ptr[si+2],end_of_line_out	;AC000; was only drive entered?
	jnz	erase_drive_ok			;AC000; no - continue
	mov	ax,error_file_not_found 	;AN022; get message number in control block
	jmp	short extend_setup		;AC000; exit

erase_drive_ok:
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	si				;AC000; get position back
	jmp	short erase_scan		;AN000; continue parsing

set_erase_prompt:
	cmp	comsw,0 			;AN018; was /P already entered?
	jz	ok_to_set_erase_prompt		;AN018; no go set switch
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	short errj2			;AN018; exit

ok_to_set_erase_prompt: 			;AN018;
	inc	comsw				;AN000; indicate /p specified
	jmp	short erase_scan		;AN000; continue parsing

good_line:					;G  We know line is good
	invoke	pathcrunch
	jnc	checkdr
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; was message flag set?
	jnz	extend_setup			;AN022; yes - print out message
	cmp	[destisdir],0			; No CHDIRs worked
	jnz	badpath_err			;AC022; see if they should have

checkdr:
	cmp	comsw,0 			;AN000; was /p specified
	jz	notest2j			;AN000; no - go to notest2
	jmp	slashp_erase			;AN000; yes - go to slashp_erase

notest2j:
	jmp	notest2

badpath_err:					;AN022; "Path not found" message
	mov	ax,error_path_not_found 	;AN022; set up error number

extend_setup:					;AN022;
	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC022; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN022; get message number in control block
errj2:						;AC022; exit jump
	jmp	Cerror				;AN022;

	break	Rename

; ****************************************************************
; *
; * ROUTINE:	 CRENAME - rename file(s)
; *
; * FUNCTION:	 PARSE command line for one full filespec and one
; *		 filename.  Invoke PATHCRUNCH on the full filespec.
; *		 Make sure the second filespec only contains a
; *		 filename.  If both openands are valid, attempt
; *		 to rename the file.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

CRENAME:

	mov	si,81H				;AC000; Point to command line
	mov	di,offset trangroup:parse_rename;AN000; Get adderss of PARSE_RENAME
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
;;	jz	crename_no_parse_error		;AC000; no - continue
	jnz	crename_parse_error		;AC000; Yes, fail. (need long jump)

;
;  Get first file name returned from parse into our buffer
;
crename_no_parse_error:
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	invoke	move_to_srcbuf			;AN000; move to srcbuf
	pop	si				;AN000; restore position in line

	xor	dx,dx				;AN000; clear dx
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AN000; did we have an error?
	JNZ	crename_parse_error		;AN000; Yes, fail.

;
;  Check the second file name for drive letter colon
;
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AC000; get address of path

	mov	al,':'                          ;AC000;
	cmp	[si+1],al			;AC000; Does the 2nd parm have a drive spec?
	jnz	ren_no_drive			;AN000; Yes, error
	mov	msg_disp_class,parse_msg_class	;AN000; set up parse error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,BadParm_ptr	;AN000; get "Invalid parameter" message number

	pop	si				;AN000;
crename_parse_error:				;AC022;
	jmp	short errj			;AC000;

;
;  Get second file name returned from parse into the fCB.  Save
;  character after file name so we can later check to make sure it
;  isn't a path character.
;

ren_no_drive:
	mov	di,FCB+10H			;AC000; set up to parse second file name
	mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
	int	21h			;AC000; do the function
	lodsb					;AC000; Load char after filename
	mov	one_char_val,al 		;AN000; save char after filename
	pop	si				;AN000; get line position back

;
; We have source and target.  See if any args beyond.
;

	mov	di,offset trangroup:parse_rename;AC000; get address of parse_rename
	invoke	parse_check_eol 		;AC000; are we at end of line?
	jnz	crename_parse_error		;AN000; no, fail.

	invoke	pathcrunch
	mov	dx,offset trangroup:badcpmes_ptr
	jz	errj2				; If 1st parm a dir, print error msg
	jnc	notest3
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; was message flag set?
	jnz	extend_setup			;AN022; yes - print out message
	cmp	[destisdir],0			; No CHDIRs worked
	jz	notest3 			; see if they should have
	Jmp	badpath_err			;AC022; set up error

notest3:
	mov	al,one_char_val 		;AN000; move char into AX
	mov	dx,offset trangroup:inornot_ptr ; Load invalid fname error ptr
	invoke	pathchrcmp			; Is the char in al a path sep?
	jz	errj				; Yes, error - 2nd arg must be
						;  filename only.

	mov	ah,FCB_Rename
	mov	dx,FCB
	int	21h
	cmp	al, 0FFH			; Did an error occur??
	jnz	renameok

	invoke	get_ext_error_number		;AN022; get extended error
	SaveReg <AX>				;AC022; Save results
	mov	al, 0FFH			; Restore original error state

renameok:
	push	ax
	invoke	restudir
	pop	ax
	inc	al
	retnz

	RestoreReg  <AX>			;AC022; get the error number back
	cmp	ax,error_file_not_found 	;AN022; error file not found?
	jz	use_renerr			;AN022; yes - use generic error message
	cmp	ax,error_access_denied		;AN022; error file not found?
	jz	use_renerr			;AN022; yes - use generic error message
	jmp	extend_setup			;AN022; need long jump - use extended error

use_renerr:
	mov	dx,offset trangroup:RenErr_ptr	;AC022;

ERRJ:
	jmp	Cerror

ret56:	ret

	break	Type

;****************************************************************
;*
;* ROUTINE:	TYPEFIL - Display the contents of a file to the
;*		standard output device
;*
;* SYNTAX:	TYPE filespec
;*
;* FUNCTION:	If a valid filespec is found, read the file until
;*		1Ah and display the contents to STDOUT.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

assume	ds:trangroup,es:trangroup

TYPEFIL:
	mov	si,81H
	mov	di,offset trangroup:parse_mrdir ;AN000; Get adderss of PARSE_MRDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	typefil_parse_error		;AN000; yes - issue error message

	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	si				;AC000; get position back
	mov	di,offset trangroup:parse_mrdir ;AC000; get address of parse_mrdir
	invoke	parse_check_eol 		;AC000; are we at end of line?
	jz	gottarg 			;AC000; yes - continue

typefil_parse_error:				;AN000; no - set up error message and exit
	jmp	Cerror

gottarg:
	invoke	setpath
	test	[destinfo],00000010b		; Does the filespec contain wildcards
	jz	nowilds 			; No, continue processing
	mov	dx,offset trangroup:inornot_ptr ; Yes, report error
	jmp	Cerror
nowilds:
	mov	ax,ExtOpen SHL 8		;AC000; open the file
	mov	bx,read_open_mode		;AN000; get open mode for TYPE
	xor	cx,cx				;AN000; no special files
	mov	dx,read_open_flag		;AN000; set up open flags
	mov	si,offset trangroup:srcbuf	;AN030; get file name
	int	21h
	jnc	typecont			; If open worked, continue. Otherwise load

Typerr: 					;AN022;
	push	cs				;AN022; make sure we have local segment
	pop	ds				;AN022;
	invoke	set_ext_error_msg		;AN022;
	mov	string_ptr_2,offset trangroup:srcbuf ;AC022; get address of failed string
	mov	Extend_buf_sub,one_subst	;AC022; put number of subst in control block
	jmp	cerror				;AC022; exit

typecont:
	mov	bx,ax				;AC000; get  Handle
;M043
; We should do the LSEEK for filesize only if this handle belongs to a file
;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
;indicate it is a device.
;
	mov	ax,(IOCTL shl 8) or 0
	int	21h

	test	dl,80h				;is it a device?
	jz	not_device			;no, a file

	mov	word ptr TypeFilSiz+2,-1 		;indicate it is a device
	jmp	short dotype
not_device:

;SR;
; Find the filesize by seeking to the end and then reset file pointer to
;start of file
;
	mov	ax,(LSEEK shl 8) or 2
	xor	dx,dx
	mov	cx,dx				;seek  to end of file
	int	21h

	mov	word ptr TypeFilSiz,ax
	mov	word ptr TypeFilSiz+2,dx		;store filesize

	mov	ax,(LSEEK shl 8) or 0
	xor	dx,dx
	int	21h	              			;reset file pointer to start
dotype:						;M043
	mov	zflag,0 			; Reset ^Z flag
	mov	ds,[TPA]
	xor	dx,dx
ASSUME	DS:NOTHING

typelp:
	cmp	cs:[zflag],0			;AC050; Is the ^Z flag set?
	retnz					; Yes, return
	mov	cx,cs:[bytcnt]			;AC056; No, continue
;
;Update the filesize left to read
;
	cmp	word ptr cs:TypeFilSiz+2,-1	;is it a device? M043
	je	typ_read			;yes, just read from it; M043

	cmp	word ptr cs:TypeFilSiz+2,0		;more than 64K left?
	jz	lt64k				;no, do word subtraction
	sub	word ptr cs:TypeFilSiz, cx
	sbb	word ptr cs:TypeFilSiz+2, 0 	;update filesize
      	jmp	short typ_read			;do the read
lt64k:
	cmp	cx,word ptr cs:TypeFilSiz		;readsize <= buffer?
	jbe	gtbuf				;yes, just update readsize
;
;Buffer size is larger than bytes to read
;
	mov	cx,word ptr cs:TypeFilSiz
	jcxz	typelp_ret
	mov	word ptr cs:TypeFilSiz,0
	jmp	short typ_read
gtbuf:
	sub	word ptr cs:TypeFilSiz,cx	   	;update filesize remaining
typ_read:
	mov	ah,read
	int	21h
	jnc	@f				;M043
	jmp	typerr				;M043
@@:						;M043
;M043;	jc	typerr				;AN022; Exit if error

	mov	cx,ax
	jcxz	typelp_ret			;AC000; exit if nothing read
	push	ds
	pop	es				; Check to see if a ^Z was read.
assume es:nothing
	xor	di,di
	push	ax
	mov	al,1ah
	repnz	scasb
	pop	ax
	xchg	ax,cx
	cmp	ax,0
	jnz	foundz				; Yes, handle it
	cmp	byte ptr [di-1],1ah		; No, double check
	jnz	typecont2			; No ^Z, continue

foundz:
	sub	cx,ax				; Otherwise change cx so that only those
	dec	cx				;  bytes up to but NOT including the ^Z
	push	cs				;  will be typed.
	pop	es
assume es:trangroup
	not	zflag				; Turn on ^Z flag so that the routine

typecont2:					;  will quit after this write.
	push	bx
	mov	bx,1
	mov	ah,write
	int	21h
	pop	bx
	jc	Error_outputj
	cmp	ax,cx
	jnz	@f				;M043
	jmp	typelp				;M043
@@:						;M043
;M043;	jz	typelp
	dec	cx
	cmp	ax,cx
	retz					; One less byte OK (^Z)

Error_outputj:
	mov	bx,1
	mov	ax,IOCTL SHL 8
	int	21h
	test	dl,devid_ISDEV
	retnz					; If device, no error message
	jmp	error_output

typelp_ret:
	ret

	break	Volume
assume	ds:trangroup,es:trangroup

;
; VOLUME command displays the volume ID on the specified drive
;
VOLUME:

	mov	si,81H
	mov	di,offset trangroup:parse_vol	;AN000; Get adderss of PARSE_VOL
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	OkVolArg			;AC000; Yes, display default volume ID
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	BadVolArg			;AC000; Yes, fail.
;
; We have parsed off the drive.  See if there are any more chars left
;

	mov	di,offset trangroup:parse_vol	;AC000; get address of parse_vol
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jz	OkVolArg			;AC000; yes, end of road
;
; The line was not interpretable.  Report an error.
;
badvolarg:
	jmp	Cerror




;***	DisAppend - disable APPEND
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX
;
;	EFFECTS
;
;	  APPEND is disabled.  If it was active, it will be re-enabled
;	  after the command finishes, by the HeadFix routine.
;
;	NOTE
;
;	  This routine must not be called more than once during a single
;	  command cycle.  The second call would permanently disable APPEND.

DisAppend	proc

	assume	ds:TRANGROUP,es:NOTHING

	push	ds			; save DS
	push	es			; save ES
	push	di

	mov	ax,APPENDINSTALL	; AX = Append Installed Check code
	int	2Fh			; talk to APPEND via multiplex
	or	al,al
	jz	daRet			; APPEND not installed, return

	mov	ax,APPENDDOS		; AX = Get Append Version code
	int	2Fh			; talk to APPEND via multiplex
	cmp	ax,0FFFFh
	jne	daRet			; it's not a local version, return

	mov	ax,APPENDGETSTATE	; AX = Get Function State code
	int	2Fh			; talk to APPEND via multiplex

	mov	ds,ResSeg		; DS = resident seg addr

	assume	ds:RESGROUP

	mov	Append_State,bx		; Append_State = saved APPEND state
	mov	Append_Flag,-1		; Append_Flag = true, restore state

	xor	bx,bx			; BX = APPEND state = off
	mov	AX,APPENDSETSTATE	; AX = Set Append State code
	int	2Fh			; talk to APPEND via multiplex

daRet:	pop	di
	pop	es			; restore ES
	pop	ds			; restore DS

	assume	ds:TRANGROUP

	ret

DisAppend	endp



;
; Find the Volume ID on the disk.
;
PUBLIC	OkVolArg
OKVOLARG:
	assume	ds:TRANGROUP,es:TRANGROUP

	call	DisAppend			; disable APPEND
	invoke	crlf2
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before volume message
	push	ds
	pop	es
;
; Volume IDs are only findable via extended FCBs or find_first with attributes
; of volume_id ONLY.
;

	mov	di,FCB-7			; Point to extended FCB beginning
	mov	al,-1				; Tag to indicate Extention
	stosb
	xor	ax,ax				; Zero padding to volume label
	stosw
	stosw
	stosb
	mov	al,attr_volume_ID		; Look for volume label
	stosb
	inc	di				; Skip drive byte; it is already set
	mov	cx,11				; fill in remainder of file
	mov	al,'?'
	rep	stosb
;
; Set up transfer address (destination of search first information)
;
	mov	dx,offset trangroup:dirbuf
	mov	ah,set_DMA
	int	21h
;
; Do the search
;
	mov	dx,FCB-7
	mov	ah,Dir_Search_First
	int	21h

;********************************
; Print volume ID info

	push	ax				;AC000; AX return from SEARCH_FIRST for VOL ID
	mov	al,DS:[FCB]			;AC000; get drive letter
	add	al,'@'
	cmp	al,'@'
	jnz	drvok
	mov	al,[curdrv]
	add	al,capital_A
drvok:
	mov	vol_drv,al			;AC000; get drive letter into argument
	pop	ax				;AC000; get return code back
	or	al,al				;AC000; volume label found?
	jz	Get_vol_name			;AC000; volume label exists - go get it
	mov	dx,offset trangroup:VolMes_ptr_2 ;AC000; set up no volume message
	jmp	short print_serial		;AC000; go print it

Get_vol_name:
	mov	di,offset trangroup:charbuf
	mov	dx,di
	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
	mov	cx,11				;AN000;  3/3/KK
	rep	movsb				;AN000;  3/3/KK

	xor	al,al				;AC000; store a zero to terminate the string
	stosb
	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message

PRINT_SERIAL:

;
; Attempt to get the volume serial number from the disk.  If an error
; occurs, do not print volume serial number.
;

	push	dx				;AN000; save message offset
	mov	ax,(GetSetMediaID SHL 8)	;AC036; Get the volume serial info
	mov	bl,DS:[FCB]			;AN000; get drive number from FCB
	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
	int	21h			;AN000; do the call
	pop	dx				;AN000; get message offset back
	jc	printvol_end			;AN000; if error, just go print label
	call	std_printf			;AC000; go print volume message
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before volume message
	mov	dx,offset trangroup:VolSerMes_ptr ;AN000; get serial number message

printvol_end:
	jmp	std_printf			;AC000; go print and exit


;****************************************************************
;*
;* ROUTINE:	Set_ext_error_msg
;*
;* FUNCTION:	Sets up extended error message for printing
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	extended error message set up in extended error
;*		buffer.
;*
;****************************************************************

Set_ext_error_msg proc near			;AN000;

	call	get_ext_error_number		;AC022; get the extended error
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block
	stc					;AN000; make sure carry is set

	ret					;AN000; return

Set_ext_error_msg endp				;AN000;

;****************************************************************
;*
;* ROUTINE:	Get_ext_error_number
;*
;* FUNCTION:	Does get extended error function call
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	AX - extended error number
;*
;****************************************************************

Get_ext_error_number proc near			;AN022;

	SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>	;AN022; save registers
	mov	ah,GetExtendedError		;AN022; get extended error
	xor	bx,bx				;AN022; clear BX
	int	21h			;AN022;
	RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>	;AN022; restore registers

	ret					;AN022; return

Get_ext_error_number endp			;AN022;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tcmd2a.asm ===
page ,132
;	SCCSID = @(#)tcmd2a.asm 4.1 85/06/25
;	SCCSID = @(#)tcmd2a.asm 4.1 85/06/25
TITLE	PART5 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Revision History
;	================
;	M01	md 7/13/90	Changed CLS to access ROM BIOS data directly
;
;	M013	SR	08/06/90	Changed Version to use new call to
;				get info about DOS in HMA or ROM.
;	M018	md	08/12/90	Increment screen height by 1 when
;					obtained from ROM BIOS.
;	M022	md	08/29/80	Set correct video page in REG_CLS

	INCLUDE comsw.asm

.xlist
.xcref
	include dossym.inc
	include bpb.inc
	include syscall.inc
	include filemode.inc
	include sf.inc
	include comequ.asm
	include comseg.asm
	include ioctl.inc
	include rombios.inc		;M01
.list
.cref


CODERES 	SEGMENT PUBLIC BYTE	;AC000;
CODERES 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
DATARES 	ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf_ptr:word
	EXTRN	BadCurDrv:byte		;AC000;
	EXTRN	clsstring:byte
	EXTRN	dback_ptr:word
	EXTRN	display_ioctl:word	;AN000;
	EXTRN	display_width:word	;AN000;
	EXTRN	DosHma_Ptr:word
	EXTRN	DosLow_Ptr:word
	EXTRN	DosRev_Ptr:word
	EXTRN	DosRom_Ptr:word
	EXTRN	Extend_buf_ptr:word	;AN049;
	EXTRN	linperpag:word		;AN000;
	EXTRN	msg_disp_class:byte	;AN049;
	EXTRN	nulpath_ptr:word
	EXTRN	Parse_Ver:byte
	EXTRN	prompt_table:word
	EXTRN	string_buf_ptr:word	;AC000;
	EXTRN	vermes_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Arg_Buf:byte
	EXTRN	bwdbuf:byte
	EXTRN	curdrv:byte
	EXTRN	dirchar:byte
	EXTRN	major_ver_num:word
	EXTRN	minor_ver_num:word
	EXTRN	One_Char_Val:byte
	EXTRN	srcxname:byte		;AN049;
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
transpace	ends
;---------------

	EXTRN	cerror:near		;AN049;
	EXTRN	crlf2:near
	EXTRN	drvbad:near
	EXTRN	std_printf:near

	PUBLIC	build_dir_for_chdir
	PUBLIC	build_dir_for_prompt
	PUBLIC	build_dir_string
	PUBLIC	cls
	PUBLIC	path
	PUBLIC	print_char
	PUBLIC	print_drive
	PUBLIC	print_version
	PUBLIC	print_b
	PUBLIC	print_back
	PUBLIC	print_eq
	PUBLIC	print_esc
	PUBLIC	print_g
	PUBLIC	print_l
	PUBLIC	print_prompt
	PUBLIC	version


	break	Version

;***	Version - display DOS version
;
;	SYNTAX	ver [/debug]
;
;		/debug - display additional DOS configuration info
;
;	ENTRY	command-line tail is in PSP
;
;	EXIT	if successful, nothing
;		if parse fails,
;		  parse error message is set up (for Std_EPrintf)
;		    AX = system parser error code
;		    DX = ptr to message block
;		  we jump to CError
;
;	EFFECTS
;	  If parse fails, a parse error message is displayed.
;	  Otherwise, version message is displayed.
;	  If /debug is specified, additional DOS info is displayed.

Version:
	assume	ds:TRANGROUP,es:TRANGROUP

;	Parse command line for /debug switch.

	mov	si,81h				; DS:SI = ptr to command tail
	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
	xor	cx,cx				; CX = # positional param's found
	invoke	Parse_With_Msg

	mov	bl,1			; BL = flag = /debug present
	cmp	ax,RESULT_NO_ERROR
	je	verPrintVer		; something parsed - must be /debug
	dec	bl			; BL = flag = no /debug present
	cmp	ax,END_OF_LINE
	je	verPrintVer		; reached end of line - ok

;	The parse failed.  Error message has been set up.

	jmp	CError

verPrintVer:
	push	bx			; save /debug flag
	call	Crlf2
	call	Print_Version
	call	Crlf2
	pop	bx   			; BL = /debug flag
	or	bl,bl
	jz	verDone			; /debug is false - we're done

;*	For /debug, display DOS internal revision and DOS location
;	(low memory, HMA, or ROM).

;	Bugbug:	use symbols for bitmasks below.

	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
	int	21h
	mov	al,dl			;revision number in dl; M013
	mov	bh,dh			;flags in dh now; M013
;M032	and	al,7			; AL = DOS internal revision
	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
	jbe	@f		;M032	; A-to-Z revision ok
	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
@@:	add	al,'A'			; AL = DOS internal rev letter
	mov	One_Char_Val,al
	mov	dx,offset TRANGROUP:DosRev_Ptr
	invoke	Std_Printf		; print DOS internal revision

	mov	cl,4
	shr	bh,cl			; CY = DOS in ROM
	jc	verRom
	shr	bh,1			; CY = DOS in HMA
	jc	verHma

;	DOS isn't in ROM or HMA, so it must be in lower memory.

	mov	dx,offset TRANGROUP:DosLow_Ptr
	jmp	short verPrintLoc
verRom:	mov	dx,offset TRANGROUP:DosRom_Ptr
	jmp	short verPrintLoc
verHma:	mov	dx,offset TRANGROUP:DosHma_Ptr
verPrintLoc:
	invoke	Std_Printf
verDone:
	jmp	Crlf2

Print_Version:
	mov	ah,GET_VERSION
	int	21h
	push	ax
	xor	ah,ah
	mov	Major_Ver_Num,ax
	pop	ax
	xchg	ah,al
	xor	ah,ah
	mov	Minor_Ver_Num,ax
	mov	dx,offset TRANGROUP:VerMes_Ptr
	jmp	Std_Printf




	assume	ds:TRANGROUP,es:TRANGROUP
print_prompt:
	push	ds
	push	cs
	pop	ds				; MAKE SURE DS IS IN TRANGROUP
	push	es
	invoke	find_prompt			; LOOK FOR PROMPT STRING
	jc	PP0				; CAN'T FIND ONE
	cmp	byte ptr es:[di],0
	jnz	PP1
PP0:
	call	print_drive			; USE DEFAULT PROMPT
	mov	al,sym
	call	print_char
	jmp	short PP5

PP1:
	mov	al,es:[di]			; GET A CHAR
	inc	di
	or	al,al
	jz	PP5				; NUL TERMINATED
	cmp	al,dollar			; META CHARACTER?
	jz	PP2				; NOPE
PPP1:
	call	print_char
	jmp	PP1

PP2:
	mov	al,es:[di]
	inc	di
	mov	bx,offset trangroup:prompt_table-3
	or	al,al
	jz	PP5

PP3:
	add	bx,3
	invoke	upconv
	cmp	al,[bx]
	jz	PP4
	cmp	byte ptr [bx],0
	jnz	PP3
	jmp	PP1

PP4:
	push	es
	push	di
	push	cs
	pop	es
	call	[bx+1]
	pop	di
	pop	es
	jmp	PP1

PP5:
	pop	es				; RESTORE SEGMENTS
	pop	ds
	return


print_back:
	mov	dx,offset trangroup:dback_ptr
	jmp	std_printf

print_EQ:
	mov	al,'='
	jmp	short print_char

print_esc:
	mov	al,1BH
	jmp	short print_char

print_G:
	mov	al,rabracket
	jmp	short print_char

print_L:
	mov	al,labracket
	jmp	short print_char

print_B:
	mov	al,vbar

print_char:

;	Bugbug:	Why bother with ds,es here?

	push	es
	push	ds
	pop	es
	push	di
	push	dx
	mov	dl,al				;AC000; Get char into al
	mov	ah,Std_CON_output		;AC000; print the char to stdout
	int	21h			;AC000;
	pop	dx
	pop	di
	pop	es
	ret

print_drive:
	mov	ah,Get_Default_drive
	int	21h
	add	al,capital_A
	call	print_char
	ret

ASSUME	DS:TRANGROUP,ES:TRANGROUP

build_dir_for_prompt:
	xor	dl,dl
	mov	si,offset trangroup:bwdbuf
	mov	di,SI
	mov	al,CurDrv
	add	al,'A'
	mov	ah,':'
	stosw
	mov	al,[dirchar]
	stosb
	xchg	si,di
	mov	string_ptr_2,di
	mov	ah,Current_dir
	int	21h
	mov	dx,offset trangroup:string_buf_ptr
	jnc	DoPrint
	mov	dx,offset trangroup:BadCurDrv
DoPrint:
	call	std_printf

	ret

build_dir_for_chdir:
	call	build_dir_string
	mov	dx,offset trangroup:bwdbuf
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	call	std_printf
	ret

build_dir_string:
	mov	dl,ds:[FCB]
	mov	al,DL
	add	al,'@'
	cmp	al,'@'
	jnz	gotdrive
	add	al,[CURDRV]
	inc	al

gotdrive:
	push	ax
	mov	si,offset trangroup:bwdbuf+3
	mov	ah,Current_dir
	int	21h
	jnc	dpbisok
	push	cs
	pop	ds
	jmp	drvbad

dpbisok:
	mov	di,offset trangroup:bwdbuf
	mov	dx,di
	pop	ax
	mov	ah,':'
	stosw
	mov	al,[dirchar]
	stosb

	ret

	break	Path
assume	ds:trangroup,es:trangroup

PATH:
	xor	al,al				;AN049; Set up holding buffer
	mov	di,offset Trangroup:srcxname	;AN049;   for PATH while parsing
	stosb					;AN049; Initialize PATH to null
	dec	di				;AN049; point to the start of buffer
	invoke	PGetarg 			; Pre scan for arguments
	jz	disppath			; Print the current path
	cmp	al,semicolon			;AC049; NUL path argument?
	jnz	pathslp 			;AC049;
	inc	si				;AN049; point past semicolon
	jmp	short scan_white		;AC049; Yes - make sure nothing else on line

pathslp:					; Get the user specified path
	lodsb					; Get a character
	cmp	al,end_of_line_in		;AC049; Is it end of line?
	jz	path_eol			;AC049; yes - end of command

	invoke	testkanj			;See if DBCS
	jz	notkanj2			;No - continue
	stosb					;AC049; Yes - store the first byte
	lodsb					;skip second byte of DBCS

path_hold:					;AN049;
	stosb					;AC049; Store a byte in the PATH buffer
	jmp	short pathslp			;continue parsing

notkanj2:
	invoke	upconv				;upper case the character
	cmp	al,semicolon			;AC049; ';' not a delimiter on PATH
	jz	path_hold			;AC049; go store it
	invoke	delim				;delimiter?
	jnz	path_hold			;AC049; no - go store character

scan_white:					;AN049; make sure were at EOL
	lodsb					;AN049; get a character
	cmp	al,end_of_line_in		;AN049; end of line?
	jz	path_eol			;AN049; yes - go set path
	cmp	al,blank			;AN049; whitespace?
	jz	scan_white			;AN049; yes - continue scanning
	cmp	al,tab_chr			;AN049; whitespace?
	jz	scan_white			;AN049; yes - continue scanning

	mov	dx,offset TranGroup:Extend_Buf_ptr ;AN049; no - set up error message
	mov	Extend_Buf_ptr,MoreArgs_ptr	;AN049; get "Too many parameters" message number
	mov	msg_disp_class,parse_msg_class	;AN049; set up parse error msg class
	jmp	cerror				;AN049;

path_eol:					;AN049; Parsing was clean
	xor	al,al				;AN049; null terminate the PATH
	stosb					;AN049;    buffer
	invoke	find_path			;AN049; Find PATH in environment
	invoke	delete_path			;AC049; Delete any offending name
	invoke	scan_double_null		;AC049; Scan to end of environment
	invoke	move_name			;AC049; move in PATH=
	mov	si,offset Trangroup:srcxname	;AN049; Set up source as PATH buffer

store_path:					;AN049; Store the PATH in the environment
	lodsb					;AN049; Get a character
	cmp	al,end_of_line_out		;AN049; null character?
	jz	got_paths			;AN049; yes - exit
	invoke	store_char			;AN049; no - store character
	jmp	short store_path		;AN049; continue

got_paths:					;AN049; we're finished
	xor	ax,ax				;null terminate the PATH in
	stosw					;    the environment
	return

disppath:
	invoke	find_path			;AN049;
	call	print_path
	call	crlf2
	return

print_path:
	cmp	byte ptr es:[di],0
	jnz	path1

path0:
	mov	dx,offset trangroup:nulpath_ptr
	push	cs
	pop	es
	push	cs
	pop	ds
	jmp	std_printf

path1:
	push	es
	pop	ds
	sub	di,5
	mov	si,di
ASSUME  DS:RESGROUP
        xor     al,al                           ; count str len to copy
        mov     cx,128                          ; up to arg_bug len
        repnz   scasb
        mov     cx,di
        sub     cx,si

        push    cs
	pop	es
	mov	di,offset trangroup:arg_buf
	rep	movsb
	mov	dx,offset trangroup:arg_buf_ptr
	push	cs
	pop	ds
	jmp	std_printf

ASSUME	DS:TRANGROUP

	break	Cls

; ****************************************************************
; *
; * ROUTINE:	 CLS
; *
; * FUNCTION:	 Clear the screen using INT 10h.  If ANSI.SYS is
; *		 installed, send a control string to clear the
; *		 screen.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

ifndef NEC_98
ANSI_installed		equ    0ffh

CLS:
	mov	ah,Mult_ANSI			;AN000; see if ANSI.SYS installed
	mov	al,0				;AN000;
	int	2fh				;AN000;
	cmp	al,ANSI_installed		;AN000;
	jz	ansicls 			;AN000; installed - go do ANSI CLS

check_lines:
	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
	mov	bx,stdout			;AN000; lines for stdout
	mov	ch,ioc_sc			;AN000; type is display
	mov	cl,get_generic			;AN000; get information
	mov	dx,offset trangroup:display_ioctl ;AN000;
	int	21h			;AN000;
	jc	no_variable			;AN000; function had error, use default
	mov	ax,linperpag			;AN000; get number of rows returned
	mov	dh,al				;AN000; set number of rows
	mov	ax,display_width		;AN000; get number of columns returned
	mov	dl,al				;AN000; set number of columns
	jmp	short regcls			;AN000; go do cls

no_variable:
	mov	bx,stdout			;AC000; set handle as stdout
	mov	ax,IOCTL SHL 8			;AC000; do ioctl - get device
	int	21h			;AC000;    info
	test	dl,devid_ISDEV			;AC000; is handle a device
	jz	ANSICLS 			;AC000; If a file put out ANSI
	test	dl,devid_SPECIAL		;AC000;
	jnz	cls_normal			;AC000; If not special CON, do ANSI

ansicls:
	call	ansi_cls			;AN000; clear the screen
	jmp	short cls_ret			;AN000; exit

;
; Get video mode
;

cls_normal:					;AC000;

	mov	ah,get_video_state		;AC000; set up to get video state
	int	video_io_int			;AC000; do int 10h - BIOS video IO
	cmp	al,video_alpha			;AC000; see if in text mode
	jbe	DoAlpha
	cmp	al,video_bw			;AC000; see if black & white card
	jz	DoAlpha
;
; We are in graphics mode.  Bogus IBM ROM does not scroll correctly.  We will
; be just as bogus and set the mode that we just got.  This will blank the
; screen too.
;
	mov	ah,set_video_mode		;AC000; set video mode call
	int	video_io_int			;AC000; do int 10h - BIOS video IO
	jmp	short cls_ret			;AC000; exit

DoAlpha:
;
; Get video mode and number of columns to scroll
;

;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
;M01   adaptors.  We circumvent this by reaching directly into the BIOS data
;M01   area
;M01   Commented out code here is the original
;M01	mov	ah,get_video_state		;AC000; set up to get current video state
;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
;M01	mov	dl,ah
;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen

;M01   Following code lifted from a fix Compaq applied to ANSI

	push	ds
	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
	MOV	DS,AX			;  *			M01
	Assume	DS:ROMBIOS_DATA

	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
	pop	ds			;			M01
	Assume	DS:Trangroup

	or	dh,dh			; Q:ZERO		M01
	jnz	regcls			;  *JMP IF NO		M01

	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01

regcls:
	inc	dh			; height+1		M018
	call	reg_cls 			; go clear the screen

cls_ret:
	ret					; exit

; ****************************************************************
; *
; * ROUTINE:	 REG_CLS
; *
; * FUNCTION:	 Clear the screen using INT 10H.
; *
; * INPUT:	 DL = NUMBER OF COLUMNS
; *		 DH = NUMBER OF ROWS
; *
; * OUTPUT:	 none
; *
; ****************************************************************

reg_cls proc	near

;
; Set overscan to black.
;

	dec	dh				;  decrement rows and columns
	dec	dl				;     to zero base
	push	dx				;  save rows,columns
	mov	ah,set_color_palette		;  set up to set the color to blank
	xor	bx,bx
	int	video_io_int			; do int 10h - BIOS video IO
	pop	dx				;  retore rows,colums

	xor	ax,ax				;  zero out ax
	mov	CX,ax				;     an cx
;
; Scroll active page
;
	mov	ah,scroll_video_page		; set up to scroll page up
	mov	bh,video_attribute		; attribute for blank line
	xor	bl,bl				; set BL to 0
	int	video_io_int			; do int 10h - BIOS video IO
;
; Seek to cursor to 0,0
;
;M022 following two lines added
	mov	ah,get_video_state		; get current video page in BH
	int	video_io_int
	mov	ah,set_cursor_position		; set up to set cursor position
	xor	dx,dx				; row and column 0
;M022	mov	bh.0
	int	video_io_int			; do into 10h - BIOS video IO

	ret

reg_cls endp



; ****************************************************************
; *
; * ROUTINE:	 ANSI_CLS
; *
; * FUNCTION:	 Clear the screen using by writing a control code
; *		 to STDOUT.
; *
; * INPUT:	 none
; *
; * OUTPUT:	 none
; *
; ****************************************************************

ansi_cls proc	near				;AC000;

	mov	si,offset trangroup:clsstring
	lodsb
	mov	cl,al
	xor	ch,ch
	mov	ah,Raw_CON_IO
clrloop:
	lodsb
	mov	DL,al
	int	21h
	loop	clrloop
	return

ansi_cls	endp				;AC000;
else    ;NEC_98

CLS:

        mov     si,offset trangroup:clsstring
        lodsb
        mov     cl,al
        xor     ch,ch
        mov     ah,Raw_CON_IO
clrloop:
        lodsb
        mov     DL,al
        int     21h
        loop    clrloop
        return
endif   ;NEC_98

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tbatch2.asm ===
page ,132
;	SCCSID = @(#)tbatch2.asm	4.2 85/07/22
;	SCCSID = @(#)tbatch2.asm	4.2 85/07/22
TITLE	Batch processing routines part II
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M020	SR	08/20/89	Changed GetBatByt to check if we
;				already reached EOF before trying
;				to read from batchfile. Also fixed
;				old bug of ds not being setup on an 
;				error while reading the batchfile.
;
;	M037	SR	11/1/90	Bug #1745 & #3438 fixed. On a GOTO, we
;				reseek to the beginning of the
;				batchfile. Clear the BatchEOF flag
;				to indicate that we are no longer at
;				EOF.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	Batch_Abort:byte
	EXTRN	call_batch_flag:byte
	EXTRN	call_flag:byte
	EXTRN	IFFlag:BYTE
	EXTRN	In_Batch:byte
	EXTRN	Nest:word
	EXTRN	PIPEFILES:BYTE
	EXTRN	RETCODE:WORD
	EXTRN	SINGLECOM:WORD

;;;	extrn	BatchEOF:byte
	extrn	EchoFlag:byte
	extrn	Next_Batch:word
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADLAB_PTR:WORD
	EXTRN	BatBufLen:WORD
	EXTRN	IFTAB:BYTE
	EXTRN	SYNTMES_PTR:WORD
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
	EXTRN	BatBuf:BYTE
	EXTRN	BatBufEnd:WORD
	EXTRN	BatBufPos:WORD
	EXTRN	BATHAND:WORD
	EXTRN	COMBUF:BYTE
	EXTRN	DIRBUF:BYTE
	EXTRN	GOTOLEN:WORD
	EXTRN	if_not_count:word
	EXTRN	IFNOTFLAG:BYTE
	EXTRN	RESSEG:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	docom1:near
	EXTRN	tcommand:near

	public	$if,iferlev,goto,shift,ifexists,ifnot,forerror,$call


Break	<GetBatByt - retrieve a byte from the batch file>

; Get one byte from the batch file and return it in AL.  End-of-file returns
; <CR> and ends batch mode.  DS must be set to resident segment.
; AH, DX destroyed.

Procedure   GETBATBYT,NEAR

ASSUME	DS:RESGROUP

	SaveReg <BX,CX,DS>
	test	byte ptr [Batch_Abort],-1
	jz	@f
	jmp	BatEOF
@@:
	TEST	Batch,-1
	JnZ	@f
	jmp	BatEOF
@@:
	PUSH	ES
	MOV	ES,Batch
	ASSUME	ES:NOTHING

;M020;
;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
;try to read from the batchfile again.
;
	cmp	es:BatchEOF,0			;already reached EOF? ;M020
	jz	not_eof			;no, read batch file ;M020
	jmp	At_EOF				;yes, no more reads ;M020
not_eof:						;M020

	ADD	WORD PTR ES:[BatSeek],1
	ADC	WORD PTR ES:[BatSeek+2],0
	POP	ES
;
; See if we have bytes buffered...
;
	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:TranGroup
	MOV	BX,BatBufPos
	CMP	BX,-1
	JNZ	UnBuf
;
; There are no bytes in the buffer.  Let's try to fill it up.
;
	MOV	DX,OFFSET TranGROUP:BatBuf
	MOV	CX,BatBufLen			; max to read.
	MOV	BX,BatHand
	MOV	AH,READ
	INT	21h			; Get one more byte from batch file
	jnc	bat_read_ok			;AN022; if no error - continue
	invoke	get_ext_error_number		;AN022; get the error
	push	ds				;AN022; save local segment
	mov	ds,[resseg]			;AN022; get resident segment
assume	ds:resgroup				;AN022;
	mov	dx,ax				;AN022; put error in DX
	invoke	output_batch_name		;AN022; set up to print the error
	pop	ds				;AN022;
assume	ds:trangroup				;AN022;
	invoke	std_eprintf			;AN022; print out the error
	mov	byte ptr combuf+2,end_of_line_in;AN022; terminate the batch line for parsing
	mov	byte ptr combuf+3,end_of_line_out ;AN022; terminate the batch line for output
;M020;
;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
;error is never hit (and it shouldn't be)
;
	mov	ds,ResSeg			; ds = RESGROUP ; M020

	jmp	short bateof			;AN022; terminate the batch file

bat_read_ok:					;AN022;
	MOV	CX,AX
	JCXZ	BATEOFDS
	MOV	BatBufEnd,CX
	XOR	BX,BX
	MOV	BatBufPos,BX
;
; Buffered bytes!
;
UnBuf:
	MOV	AL,BatBuf[BX]			; get next byte
	INC	BX
	CMP	BX,BatBufEnd			; beyond end of buffer?
	JB	SetBufPos
	MOV	BX,-1

SetBufPos:
	MOV	BatBufPos,BX
	CMP	AL,1AH				; ^Z for termination?
	jnz	GetByteDone
;
;We get here only when we hit an EOF
;
BatEOFDS:
;SR;
; HACK!!! A massive hack being put in here to get batch processing to work
;properly on EOF. Previously, a CR was returned and batch processing turned
;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
;batch processing is turned off before the last line is processed and so 
;this line would never be executed. 
;   	To fix this, a new flag BatchEOF has been introduced. This flag is
;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
;at the buffer contents. If there is no LF ( we assume that presence of LF
;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
;fake CR to the caller. This decrements BatchEOF. On the next call to this
;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
;third call, BatchEOF becomes zero and batch processing is turned off,
;now that the last line has been processed. If the EOF is the first char read into the buffer 
;during this call, and there was a CR-LF previously, we are going to fake
;another redundant CR-LF. There is no work-around I can think of.
; 	I would love to restructure this entire routine and its caller to
;make the flow really easy to understand but I guess this will have to wait.
;
	push	es
	mov	es,ResSeg
;SR;
; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
;or BatchEOF == 1 now), then do not do the LF check.
;
	mov	es,es:Batch
	cmp	es:BatchEOF,0
	jnz	crpresent

	inc	es:BatchEOF			;match the dec following
	mov	bx,BatBufEnd
	cmp	BatBuf[bx-1],0ah			;was a LF present?
	je	crpresent			;yes, no need to fake it

	add	es:BatchEOF,3			;BatchEOF == 4 to fake CR-LF

crpresent:
;;;	pop	es

	ASSUME	DS:TranGroup
	MOV	DS,ResSeg
	ASSUME	DS:ResGroup

;SR;
; The shift operation is done here to replace the decrement. This is because
;we can jump to this label directly from above when bogus calls are made to
;this routine even after batch processing is turned off. The shift ensures
;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
;it is used as a decrement and also as a NOP to just fall through on bogus 
;calls.
;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
;turning batch processing off.
;
At_EOF:						;new label added ;M020
	shr	es:BatchEOF,1			;decrement the flag
	jz	turn_off			;zero,turn batch off
	cmp	es:BatchEOF,1				
	jz	ret_lf				;BatchEOF was 2, return LF
;
;BatchEOF == 4, indicates return fake CR now and fake LF next.
;
	mov	al,0dh				;return fake CR.
	pop	es
	jmp	short GetByteDone
ret_lf:
	mov	al,0ah				;return fake LF
	pop	es
	jmp	short	GetByteDone			
turn_off:
	pop	es

BATEOF:
	invoke	BatchOff			;turn batch processing off
	CALL	BATCLOSE
;;;	mov	BatchEOF,0			;make sure BatchEOF = 0

;SR; BugBug
; There is a good reason why this carriage return is being returned here. 
;This was part of the old code. Because,
;of the way the caller is structured, a fake CR has to be returned again on
;EOF to ensure the termination of the caller's loop. If echo is on, this
;results in an extra linefeed after the batchfile is run if the last line of
;the batchfile already had a CR-LF. 
;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
;the end-of-line. This CR is to mark the end-of-file.
;
	MOV	AL,0dH				; If end-of-file, then end of line

	test	byte ptr [Batch_Abort],-1
	mov	byte ptr [Batch_Abort],0
	jz	Cont_Get_Byt
	mov	di,offset TRANGROUP:COMBUF+2	; reset pointer to beginning of buffer
	xor	cx,cx				; zero line length
	jmp	short GetByteDone

Cont_Get_Byt:
	CMP	[SINGLECOM],0FFF0H		; See if we need to set SINGLECOM
	JNZ	GetByteDone
	CMP	NEST,0				;G See if we have nested batch files
	JNZ	GETBYTEDONE			;G Yes - don't exit just yet
	MOV	[SINGLECOM],-1			; Cause termination

GetByteDone:
	RestoreReg  <DS,CX,BX>

	return

EndProc GetBatByt

	break	<$If - conditional execution>
assume	ds:trangroup,es:trangroup

IFERRORP:
	POP	AX
IFERROR:
FORERROR:
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	JMP	CERROR

$IF:
;
; Turn off any pipes in progress.
;
	push	ds				;AN004; save local DS
	mov	ds,[resseg]			;AN004; get resident segment
	assume	ds:resgroup			;AN004;
	cmp	[PIPEFILES],0			;AN004; Only turn off if present.
	jz	IFNoPipe			;AN004; no pipe - continue
	invoke	PipeDel 			;AN004; turn off piping

IFNoPipe:					;AN004;
	pop	ds				;AN004; get local DS back
	assume	ds:trangroup			;AN004;
	MOV	[IFNOTFLAG],0
	mov	[if_not_count], 0
	MOV	SI,81H

IFREENT:
	invoke	SCANOFF
	CMP	AL,0DH
	JZ	IFERROR
	MOV	BP,SI
	MOV	DI,OFFSET TRANGROUP:IFTAB	; Prepare to search if table
	MOV	CH,0

IFINDCOM:
	MOV	SI,BP
	MOV	CL,[DI]
	INC	DI
	JCXZ	IFSTRING
	JMP	SHORT FIRSTCOMP

IFCOMP:
	JNZ	IF_DIF				;AC000;

FIRSTCOMP:
	LODSB
	MOV	AH,ES:[DI]
	INC	DI
	CMP	AL,AH
	JZ	IFLP
	OR	AH,20H				; Try lower case
	CMP	AL,AH

IFLP:
	LOOP	IFCOMP

IF_DIF: 					;AC000;
	LAHF
	ADD	DI,CX				; Bump to next position without affecting flags
	MOV	BX,[DI] 			; Get handler address
	INC	DI
	INC	DI
	SAHF
	JNZ	IFINDCOM
	LODSB
	CMP	AL,0DH

IFERRORJ:
	JZ	IFERROR
	invoke	DELIM
	JNZ	IFINDCOM
	invoke	SCANOFF
	JMP	BX

IFNOT:
	NOT	[IFNOTFLAG]
	inc	[if_not_count]
	JMP	IFREENT

;
; We are comparing two strings for equality.  First, find the end of the
; first string.
;

IFSTRING:
	PUSH	SI				; save away pointer for later compare
	XOR	CX,CX				; count of chars in first string

FIRST_STRING:
	LODSB					; get character
	CMP	AL,0DH				; end of line?
	JZ	IFERRORP			; yes => error
	invoke	DELIM				; is it a delimiter?
	JZ	EQUAL_CHECK			; yes, go find equal sign
	INC	CX				; remember 1 byte for the length
	JMP	FIRST_STRING			; go back for more
;
; We have found the end of the first string.  Unfortunately, we CANNOT use
; scanoff to find the next token; = is a valid separator and will be skipped
; over.
;

EQUAL_CHECK:
	CMP	AL,'='                          ; is char we have an = sign?
	JZ	EQUAL_CHECK2			; yes, go find second one.
	CMP	AL,0DH				; end of line?
	JZ	IFERRORPj			;AC004; yes, syntax error
	LODSB					; get next char
	JMP	EQUAL_CHECK
;
; The first = has been found.  The next char had better be an = too.
;

EQUAL_CHECK2:
	LODSB					; get potential = char
	CMP	AL,'='                          ; is it good?
	jnz	iferrorpj			; no, error
;
; Find beginning of second string.
;
	invoke	SCANOFF
	CMP	AL,0DH
	jz	iferrorpj
	POP	DI
;
; DS:SI points to second string
; CX has number of chars in first string
; ES:DI points to first string
;
; Perform compare to elicit match
;
	REPE	CMPSB
	JZ	MATCH				; match found!
;
; No match.  Let's find out what was wrong.  The character that did not match
; has been advanced over.  Let's back up to it.
;
	DEC	SI
;
; If it is EOL, then syntax error
;
	CMP	BYTE PTR [SI],0DH
	JZ	IFERRORJ
;
; Advance pointer over remainder of unmatched text to next delimiter
;

SKIPSTRINGEND:
	LODSB

NOTMATCH:
	CMP	AL,0DH

IFERRORJ2:
	JZ	IFERRORJ
	invoke	DELIM
	JNZ	SKIPSTRINGEND
;
; Signal that we did NOT have a match
;
	MOV	AL,-1
	JMP	SHORT IFRET

iferrorpj:
	jmp	iferrorp
;
; The compare succeeded.  Was the second string longer than the first?	We
; do this by seeing if the next char is a delimiter.
;

MATCH:
	LODSB
	invoke	DELIM
	JNZ	NOTMATCH			; not same.
	XOR	AL,AL
	JMP	SHORT IFRET

IFEXISTS:
ifexist_attr	    EQU     attr_hidden+attr_system

moredelim:
	lodsb					; move command line pointer over
	invoke	delim				; pathname -- have to do it ourselves
	jnz	moredelim			; 'cause parse_file_descriptor is dumb
	mov	DX, OFFSET TRANGROUP:dirbuf
	trap	set_dma
	mov	BX, 2				; if(0) [|not](|1) exist[1|2] file(2|3)
	add	BX, [if_not_count]
	mov	AX, OFFSET TRANGROUP:arg.argv
	invoke	argv_calc			; convert arg index to pointer
	mov	DX, [BX].argpointer		; get pointer to supposed filename
	mov	CX, ifexist_attr		; filetypes to search for
	trap	Find_First			; request first match, if any
	jc	if_ex_c 			; carry is how to determine error
	xor	AL, AL
	jmp	short ifret

if_ex_c:
	mov	AL, -1				; false 'n' fall through...

IFRET:
	TEST	[IFNOTFLAG],-1
	JZ	REALTEST
	NOT	AL

REALTEST:
	OR	AL,AL
	JZ	IFTRUE
	JMP	TCOMMAND

IFTRUE:
	invoke	SCANOFF
	MOV	CX,SI
	SUB	CX,81H
	SUB	DS:[80H],CL
	MOV	CL,DS:[80H]
	MOV	[COMBUF+1],CL
	MOV	DI,OFFSET TRANGROUP:COMBUF+2
	CLD
	REP	MOVSB
	MOV	AL,0DH
	STOSB
;
; Signal that an IF was done.  This prevents the redirections from getting
; lost.
;
	PUSH	DS
	MOV	DS,ResSeg
	ASSUME	DS:RESGROUP
	MOV	IFFlag,-1
	POP	DS
	ASSUME	DS:TRANGROUP
;
; Go do the command
;
	JMP	DOCOM1

iferrorj3:
	jmp	iferrorj2

IFERLEV:
	MOV	BH,10
	XOR	BL,BL

GETNUMLP:
	LODSB
	CMP	AL,0DH
	jz	iferrorj3
	invoke	DELIM
	JZ	GOTNUM
	SUB	AL,'0'
	XCHG	AL,BL
	MUL	BH
	ADD	AL,BL
	XCHG	AL,BL
	JMP	SHORT GETNUMLP

GOTNUM:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	AH,BYTE PTR [RETCODE]
	POP	DS
ASSUME	DS:TRANGROUP
	XOR	AL,AL
	CMP	AH,BL
	JAE	IFRET
	DEC	AL
	JMP	SHORT IFRET


	break	<Shift - advance arguments>

;
; Shift the parameters in the batch structure by 1 and set up the new argument.
; This is a NOP if no batch in progress.
;

Procedure   Shift,NEAR

assume	ds:trangroup,es:trangroup

	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	AX,[BATCH]			; get batch pointer
	OR	AX,AX				; in batch mode?
	retz					; no, done.
	MOV	ES,AX				; operate in batch segment
	MOV	DS,AX

ASSUME	DS:NOTHING,ES:NOTHING

;
; Now move the batch args down by 1 word
;
	MOV	DI,BatParm			; point to parm table
	LEA	SI,[DI+2]			; make source = dest + 2
	MOV	CX,9				; move 9 parameters
	REP	MOVSW				; SHIFT down
;
; If the last parameter (the one not moved) is empty (= -1) then we are done.
; We have copied it into the previous position
;
	CMP	WORD PTR [DI],-1		; if last one was not in use then
	retz					; No new parm
;
; This last pointer is NOT nul.  Get it and scan to find the next argument.
; Assume, first, that there is no next argument
;
	MOV	SI,[DI]
	MOV	WORD PTR [DI],-1		; Assume no parm
;
; The parameters are CR separated.  Scan for end of this parm
;
SKIPCRLP:
	LODSB
	CMP	AL,0DH
	JNZ	SKIPCRLP
;
; We are now pointing at next arg.  If it is 0 (end of original line) then we
; are finished.  There ARE no more parms and the pointer has been previously
; initialized to indicate it.
;
	CMP	BYTE PTR [SI],0
	retz					; End of parms
	MOV	[DI],SI 			; Pointer to next parm as %9

	return

EndProc Shift

;
; Skip delim reads bytes from the batch file until a non-delimiter is seen.
; returns char in AL, carry set -> eof
;

Procedure   SkipDelim,NEAR

	ASSUME	DS:ResGroup,ES:NOTHING
	TEST	Batch,-1
	JZ	SkipErr 			; batch file empty.  OOPS!
	CALL	GetBatByt			; get a char
	invoke	Delim				; check for ignoreable chars
	JZ	SkipDelim			; ignore this char.
	clc
	return

SkipErr:
	stc
	return

EndProc SkipDelim

	break  $Call

;  CALL is an internal command that transfers control to a .bat, .exe, or
;  .com file.  This routine strips the CALL off the command line,  sets
;  the CALL_FLAG to indicate a call in progress, and returns control to
;  DOCOM1 in TCODE to reprocess the command line and execute the file
;  being CALLed.

$CALL:

;  strip off CALL from command line

	ASSUME DS:trangroup,ES:trangroup
	push	si
	push	di
	push	ax
	push	cx
	mov	si,offset trangroup:combuf+2
	invoke	scanoff 			;get to first non-delimeter
	add	si,length_call			;point to char past CALL
	mov	di,offset trangroup:combuf+2
	mov	cx,combuflen-length_call	;get length of buffer
	rep	movsb				;move it
	pop	cx
	pop	ax
	pop	di
	pop	si


;  set call flag to indicate call in progress

	push	ds
	mov	ds,[resseg]
	ASSUME DS:resgroup,ES:resgroup
	mov	call_flag, call_in_progress
	mov	call_batch_flag, call_in_progress
;
; Turn off any pipes in progress.
;
	cmp	[PIPEFILES],0			; Only turn off if present.
	jz	NoPipe
	invoke	PipeDel
NoPipe:
	pop	ds

	ret

	break	Goto

GOTO:

	assume	ds:trangroup,es:trangroup
	MOV	DS,[RESSEG]
	assume	ds:resgroup
	TEST	[BATCH],-1
	retz					; If not in batch mode, a nop
	XOR	DX,DX
	PUSH	DS
	MOV	DS,Batch
	MOV	WORD PTR DS:[BatSeek],DX	; Back to start
	MOV	WORD PTR DS:[BatSeek+2],DX	; Back to start
;M037
; Clear EOF indicator because we have reseeked to the beginning of the file.
;
	mov	ds:BatchEOF,0		; clear eof indicator ;M037

	POP	DS

GotoOpen:
	invoke	promptBat
	MOV	DI,FCB+1			; Get the label
	MOV	CX,11
	MOV	AL,' '
	REPNE	SCASB
	JNZ	NOINC
	INC	CX

NOINC:
	SUB	CX,11
	NEG	CX
	MOV	[GOTOLEN],CX
;
; At beginning of file.  Skip to first non-delimiter char
;
	CALL	SkipDelim
	JC	BadGoto
	CMP	AL,':'
	JZ	CHKLABEL

LABLKLP:					; Look for the label
	CALL	GETBATBYT
	CMP	AL,0AH
	JNZ	LABLKTST
;
; At beginning of line.  Skip to first non-delimiter char
;
	CALL	SkipDelim
	JC	BadGoto
	CMP	AL,':'
	JZ	CHKLABEL

LABLKTST:
	TEST	[BATCH],-1
	JNZ	LABLKLP

BadGoto:
	CALL	BATCLOSE
;SR;
; At this point we are terminating without freeing up any nested batch 
;segments i.e if the error occurred within a called batch file. This routine
;will traverse the linked list of batch segments and free all of them.
;
	call	free_batch		;free up nested batch segments

	PUSH	CS
	POP	DS
	MOV	DX,OFFSET TRANGROUP:BADLAB_ptr
	JMP	CERROR

;
; Found the :.	Skip to first non-delimiter char
;

CHKLABEL:
	CALL	SkipDelim
	JC	BadGoto
	MOV	DI,FCB+1
	MOV	CX,[GOTOLEN]
	JMP	SHORT GotByte

NEXTCHRLP:
	PUSH	CX
	CALL	GETBATBYT
	POP	CX

GotByte:
	INVOKE	TESTKANJ			;AN000;  3/3/KK
	JZ	NOTKANJ1			;AN000;  3/3/KK
	CMP	AL, ES:[DI]			;AN000;  3/3/KK
	JNZ	LABLKTST			;AN000;  3/3/KK
	INC	DI				;AN000;  3/3/KK
	DEC	CX				;AN000;  3/3/KK
	JCXZ	LABLKTST			;AN000;  3/3/KK
	PUSH	CX				;AN000;  3/3/KK
	CALL	GETBATBYT			;AN000;  3/3/KK
	POP	CX				;AN000;  3/3/KK
	CMP	AL, ES:[DI]			;AN000;  3/3/KK
	JMP	SHORT KNEXTLABCHR		;AN000;  3/3/KK

NOTKANJ1:					;AN000;  3/3/KK
	OR	AL,20H
	CMP	AL,ES:[DI]
	JNZ	TRYUPPER
	JMP	SHORT NEXTLABCHR

TRYUPPER:
	SUB	AL,20H
	CMP	AL,ES:[DI]

KNEXTLABCHR:					;AN000;  3/3/KK
	JNZ	LABLKTST

NEXTLABCHR:
	INC	DI
	LOOP	NEXTCHRLP
	CALL	GETBATBYT
	cmp	[GOTOLEN],8			; Is the label atleast 8 chars long?
	jge	gotocont			; Yes, then the next char doesn't matter
	CMP	AL,' '
	JA	LABLKTST

gotocont:
	CMP	AL,0DH
	JZ	SKIPLFEED

TONEXTBATLIN:
	CALL	GETBATBYT
	CMP	AL,0DH
	JNZ	TONEXTBATLIN

SKIPLFEED:
	CALL	GETBATBYT

;SR;
; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
;CR-LF for the last line. On a goto, this flag has to be cleared, because
;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
;to get the EOF has not been made yet because we encountered the Goto. On
;all other cases, EOF will be hit while trying to read the next line and
;we are fine.
;
	push	es
	mov	es,Batch
	mov	es:BatchEOF,0			;invalidate fake CR-LF flag
	pop	es
	CALL	BatClose

	return

Procedure   BatClose,NEAR
	assume	ds:resgroup

	MOV	BX,CS:[BATHAND]
	CMP	BX,5
	JB	CloseReturn
	MOV	AH,CLOSE
	INT	21h

CloseReturn:
	mov	byte ptr [In_Batch],0		; reset flag
	return

EndProc BatClose

;
; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
; Also, fills internal batch buffer.  If access denied, then AX = -1
;

Procedure   BatOpen,NEAR

ASSUME	DS:RESGROUP,ES:TRANGROUP

	PUSH	DS
	MOV	DS,[BATCH]
ASSUME	DS:NOTHING

	MOV	DX,BatFile
	MOV	AX,OPEN SHL 8
	INT	21h			; Open the batch file
	JC	SETERRDL
	MOV	DX,WORD PTR DS:[BatSeek]
	MOV	CX,WORD PTR DS:[BatSeek+2]
	POP	DS
ASSUME	DS:RESGROUP

	MOV	[BATHAND],AX
	MOV	BX,AX
	MOV	AX,LSEEK SHL 8			; Go to the right spot
	INT	21h
	MOV	BatBufPos,-1			; nuke batch buffer position

	return

SETERRDL:
	MOV	BX,DX
	invoke	get_ext_error_number		;AN022; get the extended error
	mov	dx,ax				;AN022; save extended error in DX
	MOV	AL,[BX] 			; Get drive spec
	SUB	AL,'@'                          ; A = 1
	POP	DS
	STC					; SUB mucked over carry

	return

EndProc BatOpen


;
;Free_batch : This routine traverses the linked batch segments freeing all
;the batch and FOR segments until all of them are freed. It also restores
;the old state of the EchoFlag.
;
;	ENTRY:	ds = RESGROUP
;
;	EXIT: 	All batch & FOR segments freed.
;		EchoFlag restored to old state before batch process.
;
;	REGISTERS AFFECTED: bx, cx


free_batch	proc	near
	assume	ds:RESGROUP,es:nothing

	push	es
	mov	bx,Next_Batch
	or	bx,bx
	jz	fb_ret

ClearBatch:
	mov	es,bx			; get batch segment

	mov	bx,es:BatForPtr		; get old FOR segment
	cmp	bx,0			; is a FOR in progress
	je	no_bat_for		; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,DEALLOC		;
	int	21h			;
	pop	es			; restore to batch segment

No_Bat_For:
	mov	cl,es:BatEchoFlag	; get old echo flag
	mov	bx,es:BatLast	 	; get old batch segment
	mov	ah,DEALLOC		; free it up...
	int	21h
	mov	Batch,bx		; get ready to deallocate next batch
	dec	nest			; is there another batch file?
	jnz	ClearBatch		; keep going until no batch file
	
	mov	EchoFlag,cl		;restore echo status
	mov	Batch,0		;no batch process in progress

fb_ret:
	pop	es
	ret

free_batch	endp


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\stub.asm ===
page ,132
	title	Command Stub 
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M003	SR	07/16/90	Check if UMB loading enabled and if so
;				turn it off on return from Exec
;
;	M005	SR	07/20/90	Carousel hack. Added a hard-coded far
;				jump to the actual int 2fh entry 
;				point to fix Carousel problems.
;
;	M009	SR	08/01/90	Restore the UMB state before the Exec
;				from the saved state in LoadHiFlg.
;
;	M035	SR	10/27/90	Enable interrupts at the start of
;				the dispatch code. Otherwise interrupts
;				remain disabled through a whole
;                               of code which is not good.
;
;	M049	SR	1/16/91	Bug #5075. Reworked the scheduling
;				strategy. There is no common
;				dispatcher now. Each entry point
;				now checks A20 and then does a far
;				jump to the appropriate code. This
;				added about 15 bytes of code but the
;				speed increase and reentrancy are
;				well worth the price.
;



;
;This file contains the low memory stub for command.com which hooks all the
;entry points into the resident command.com and directs the calls to the
;appropriate routines in the resident code which may be located in HIMEM. 
;	The stub has been made part of the resident data and will always
;be duplicated on every invocation of command.com. However, the only stubs
;that actually hook the interrupt vectors belong to either the first 
;command.com or to any other command.com executed with the /p switch. 
;	The stub also keeps track of the current active data segment. The 
;INIT code of each command.com updates this variable via an int 2fh mechanism
;with its own data segment. The INIT code also updates a pointer in its data
;segment to the previous resident data segment. Whenever a command.com exits,
;the exit code picks up the previous data segment pointer from the current
;data segment and patches it into the CurResDataSeg variable in the stub.
;	Right now the stub does not bother about A20 switching. We assume
;A20 is always on. It just does a far jump to the resident code with the 
;value of the current data segment in one of the registers. A20 toggle 
;support maybe added as a future enhancement, if the need is felt.
;


	include comseg.asm
	include xmm.inc

INIT	segment

	extrn	ConProc:near

INIT	ends

CODERES	segment

	extrn	MsgInt2fHandler	:near
	extrn	Int_2e		:near
	extrn	Contc		:near
	extrn	DskErr		:near

CODERES	ends

DATARES	segment
	assume	cs:DATARES,ds:nothing,es:nothing,ss:nothing
	Org	0
ZERO	=	$

	Org	100h
ProgStart:
	jmp	RESGROUP:ConProc

	db	?		;make following table word-alligned


;
;All the entry points declared below are patched in at INIT time with the
;proper segment and offset values after the resident code segment has been
;moved to its final location
;
public	Int2f_Entry, Int2e_Entry, Ctrlc_Entry, CritErr_Entry, Lodcom_Entry
public	Exec_Entry, RemCheck_Entry, TrnLodCom1_Entry, MsgRetrv_Entry
public	HeadFix_Entry
public	XMMCallAddr, ComInHMA

;!!!WARNING!!!
; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
;in the correct segments and offsets
;

Int2f_Entry 	label 	dword
		dw	offset RESGROUP:MsgInt2fHandler	;Address of int 2fh handler
		dw	0

Int2e_Entry 	label	dword
		dw	offset RESGROUP:Int_2e ;Address of int 2eh handler
		dw	0

Ctrlc_Entry	label	dword
		dw	offset RESGROUP:ContC ;Address of Ctrl-C handler
		dw	0

CritErr_Entry	label	dword
		dw	offset RESGROUP:DskErr ;Address of critical error handler
		dw	0

Exec_Entry	dd	?	;Entry from transient to Ext_Exec
RemCheck_Entry	dd	?	;Entry from transient to TRemCheck
TrnLodCom1_Entry	dd	?	;Entry from transient to LodCom1
LodCom_Entry	dd	?	;Entry after exit from command.com
MsgRetrv_Entry	dd	?	;Entry from external to MsgRetriever
HeadFix_Entry	dd	?	;Entry from trans to HeadFix

UMBOff_Entry	dd	?	;Entry from here to UMBOff routine; M003

XMMCallAddr	dd	?	;Call address for XMM functions
ComInHMA		db	0	;Flags if command.com in HMA

public	Int2f_Trap, Int2e_Trap, Ctrlc_Trap, CritErr_Trap
public	Exec_Trap, RemCheck_Trap, LodCom_Trap, MsgRetrv_Trap, TrnLodcom1_Trap
public	HeadFix_Trap


Int2f_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Int2f_Entry

Int2e_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Int2e_Entry

Ctrlc_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Ctrlc_Entry

CritErr_Trap:
	sti
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	CritErr_Entry

Exec_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	Exec_Entry

RemCheck_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	RemCheck_Entry

TrnLodCom1_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	TrnLodCom1_Entry

LodCom_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	LodCom_Entry

MsgRetrv_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	MsgRetrv_Entry

HeadFix_Trap:
	call	CheckA20
	push	ds			;push current ds value
	push	cs			;push resident data segment value
	jmp	HeadFix_Entry

CheckA20	proc

	pushf				;save current flags
	push	ax
	cmp	cs:ComInHMA,0		;is resident in HMA?
	jz	A20_on			;no, jump to resident

	call	QueryA20
	jnc	A20_on			;A20 is on, jump to resident

	call	EnableA20		;turn A20 on
A20_on:
	pop	ax
	popf				;flags have to be unchanged
	ret

CheckA20	endp


;
; M005; This is a far jump to the actual int 2fh entry point. The renormalized
; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
; M005; handler. Note that we have to hardcode a jump and we cannot use any
; M005; pointers because our cs is going to be different. The segment to
; M005; jump to is patched in at init time. (in init.asm)
;

public Carousel_i2f_Hook		; M005
Carousel_i2f_Hook:			; M005
	db	0eah			; far jump opcode; M005
	dw	offset DATARES:Int2f_Trap	; int 2fh offset ; M005
	dw	?			; int 2fh segment; M005


QueryA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_QUERY_A20
	call	cs:XMMCallAddr
	or	ax, ax
	pop	ax
	pop	bx
	jnz	short QA20_ON			; AX = 1 => ON

	stc					; OFF
	ret
QA20_ON:
	clc					; ON
	ret

QueryA20	endp



EnableA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_LOCAL_ENABLE_A20
	call	cs:XMMCallAddr
	or	ax, ax
	jz	XMMerror		; AX = 0 fatal error
	pop	ax
	pop	bx
	ret
;
;If we get an error, we just loop forever
;
XMMerror:
	jmp	short XMMerror
	
EnableA20	endp


;
;The Exec call has to be issued from the data segment. The reason for this 
;is TSRs. When a TSR does a call to terminate and stay resident, the call
;returns with all registers preserved and so all our segment registers are
;still set up. However, if the TSR unloads itself later on, it still 
;comes back here. In this case the segment registers and the stack are
;not set up and random things can happen. The only way to setup all the 
;registers is to use the cs value and this can only be done when we are in
;the data segment ourselves. So, this piece of code had to be moved from
;the code segment to the data segment.
;

	extrn	RStack:WORD
	extrn	LoadHiFlg:BYTE

public 	Issue_Exec_Call
Issue_Exec_Call:
	int 	21h
;
;We disable interrupts while changing the stack because there is a bug in 
;some old 8088 processors where interrupts are let through while ss & sp
;are being changed.
;
	cli
	push	cs
	pop	ss
	mov	sp,offset DATARES:RStack	;stack is set up
	sti
	push	cs
	pop	ds			;ds = DATARES
; 
; M009; Restore UMB state to that before Exec
;
;; save execution status(carry flag)
;; and the error code(AL)
	pushf				;save flags ; M003
	push	ax
	mov	al,LoadHiFlg		;current UMB state ; M009
	test	al,80h			;did we try to loadhigh? ;M009
	jz	no_lh			;no, dont restore ;M009
	and	al,7fh			;clear indicator bit ;M009
	call	dword ptr UMBOff_Entry	;restore UMB state ; M009
no_lh:					; M009
	and	LoadHiFlg,7fh		;clear loadhigh indicator bit
					;M009
	pop	ax
	popf				; M003; *bugbug -- popff??
;
;We now jump to the stub trap which returns us to the resident code. All
;flags are preserved by the stub code.
;
	jmp	Exec_Trap


DATARES	ends
	end	ProgStart


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tcmd1a.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
************************************************************
************************************************************
**							  **
**  THIS FILE IS OBSOLETE, NO LONGER USED, DEFUNCT,	  **
**  AND, IN FACT, DOESN'T EVEN EXIST.  YOU ARE NOT	  **
**  HERE.  YOU MAY NOT BE ANYWHERE AT ALL.  THIS	  **
**  WHOLE THING COULDN'T POSSIBLY BE HAPPENING.		  **
**							  **
**  See DIR.ASM for a reality check.			  **
**							  **
************************************************************
************************************************************

 page 80,132
;	SCCSID = @(#)tcmd1a.asm 1.1 85/05/14
;	SCCSID = @(#)tcmd1a.asm 1.1 85/05/14
TITLE	PART4 COMMAND Transient routines.

;	Internal commands DIR,PAUSE,ERASE,TYPE,VOL,VER

	INCLUDE comsw.asm
.xlist
.xcref
	INCLUDE DOSSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm		;AC000;
	include ioctl.inc		;AN000;
.list
.cref

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BadCD_ptr:word
	EXTRN	bits:word
	EXTRN	Bytmes_ptr:word
	EXTRN	comsw:word
	EXTRN	dir_w_syn:word		;AC000;
	EXTRN	dirdat_mo_day:word	;AC000;
	EXTRN	dirdat_yr:word		;AC000;
	EXTRN	dirdattim_ptr:word
	EXTRN	dirhead_ptr:word
	EXTRN	dirtim_hr_min:word	;AC000;
	EXTRN	Dirmes_ptr:word
	EXTRN	disp_file_size_ptr:word
	EXTRN	Dmes_ptr:word
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	msg_disp_class:byte	;AN000;
	EXTRN	parse_dir:byte		;AC000;
	EXTRN	slash_p_syn:word	;AC000;
	EXTRN	string_buf_ptr:word
	EXTRN	tab_ptr:word		;AC000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	bytes_free:word
	EXTRN	charbuf:byte
	EXTRN	COM:byte
	EXTRN	Destisdir:byte
	EXTRN	Desttail:word
	EXTRN	dir_num:word
	EXTRN	Dirbuf:byte
	EXTRN	dirflag:byte		;AN015;
	EXTRN	display_ioctl:word	;AC000;
	EXTRN	display_mode:byte	;AC000;
	EXTRN	filecnt:word
	EXTRN	file_size_high:word
	EXTRN	file_size_low:word
	EXTRN	fullscr:word
	EXTRN	ID:byte
	EXTRN	lincnt:byte		;AC000;
	EXTRN	linlen:byte
	EXTRN	linperpag:word		;AC000;
	EXTRN	msg_numb:word		;AN022;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_syn:word 	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	pathcnt:word		;AN000;
	EXTRN	pathpos:word		;AN000;
	EXTRN	srcbuf:byte		;AC000;
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
TRANSPACE	ENDS
;---------------

	EXTRN	cerror:near
	EXTRN	std_printf:near


	PUBLIC	catalog


	break	Catalog - Directory command
assume	ds:trangroup,es:trangroup

;
; The DIR command displays the contents of a directory.
;
; ****************************************************************
; *
; * ROUTINE:	 CATALOG - display file(s) in directory
; *
; * FUNCTION:	 PARSE command line for drive, file, or path name.
; *		 DIR allows two switches, /P (pause) and /W (wide).
; *		 If an error occurs issue and error message and
; *		 transfer control to CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CATALOG:

;
; Set up DTA for dir search firsts
;
	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
	mov	ah,Set_DMA			;AC000;
	int	int_command			;AC000;
;
; Set up defaults for switches and parse the command line.
;
	mov	msg_numb,0			;AN022; initialize message flag
	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
	mov	[pathpos],di			;AN000; this is start of path
	mov	[pathcnt],1			;AN000; initialize length to 1 char
	mov	al,star 			;AN000; initialize srcbuf to *,0d
	stosb					;AN000;
	mov	al,end_of_line_in		;AN000;
	stosb					;AN000;
	mov	si,81H				;AN000; Get command line
	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
	xor	cx,cx				;AC000; clear counter for positionals
	mov	ComSw,cx			;AC000; initialize flags
	mov	bits,cx 			;AC000; initialize switches
	mov	linperpag,linesperpage		;AC000; Set default for lines per page
	mov	linlen,normperlin		;AC000; Set number of entries per line
	mov	lincnt,normperlin		;AC000;

dirscan:
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jne	dirscan_cont			;AN000; No - continue parsing
	jmp	scandone			;AN000; yes - go process

dirscan_cont:
	cmp	ax,result_no_error		;AN000; did we have an error?
	jz	dirscan_cont2			;AN000; No - continue parsing
	jmp	badparm 			;AN000; yes - exit

dirscan_cont2:
	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
	je	set_dir_width			;AN000; yes - go set wide lines
	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
	je	set_dir_pause			;AN000; yes - go set pause at end of screen
;
; Must be filespec since no other matches occurred. move filename to srcbuf
;
	push	si				;AC000; save position in line
	lds	si,parse1_addr			;AC000; get address of filespec
	push	si				;AN000; save address
	invoke	move_to_srcbuf			;AC000; move to srcbuf
	pop	dx				;AC000; get address in DX

;
; The user may have specified a device.  Search for the path and see if the
; attributes indicate a device.
;
	mov	ah,Find_First			;AC000; find the file
	int	int_command			;AC000;
	jnc	Dir_check_device		;AN022; if no error - check device
	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_no_more_files		;AN022; was error no file found
	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
	cmp	ax,error_path_not_found 	;AN022; was error no file found
	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
	jmp	dir_err_setup			;AN022; otherwise - go issue error message

dir_check_device:				;AN022;
	test	byte ptr (DirBuf+find_buf_attr),attr_device ;AC000;
	jz	Dir_fspec_end			;AC000; no, go do normal operation
	mov	ComSw,-2			;AC000; signal device

dir_fspec_end:
	pop	si				;AC000; restore position in line
	jmp	short dirscan			;AC000; keep parsing

set_dir_width:
	test	byte ptr[bits],SwitchW		;AN018; /W already set?
	jz	ok_set_width			;AN018; no - okay to set width
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	badparm 			;AN018; exit

ok_set_width:
	or	bits,switchw			;AC000; indicate /w was selected
	mov	linlen,wideperlin		;AC000; Set number of entries per line
	mov	lincnt,wideperlin		;AC000;
	jmp	short dirscan			;AC000; keep parsing

set_dir_pause:
	test	byte ptr[bits],SwitchP		;AN018; /p already set?
	jz	ok_set_pause			;AN018; no - okay to set width
	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
	invoke	setup_parse_error_msg		;AN018; set up an error message
	jmp	badparm 			;AN018; exit

ok_set_pause:
	or	bits,switchp			;AC000; indicate /p was selected
	push	cx				;AN000; save necessary registers
	push	si				;AN000;
	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
	mov	bx,stdout			;AN000; lines for stdout
	mov	ch,ioc_sc			;AN000; type is display
	mov	cl,get_generic			;AN000; get information
	mov	dx,offset trangroup:display_ioctl ;AN000;
	int	int_command			;AN000;

lines_set:
	dec	linperpag			;AN000; lines per actual page should
	dec	linperpag			;AN000;     two less than the max
	mov	ax,linperpag			;AN000; get number of lines into
	mov	[fullscr],ax			;AC000;    screen line counter
	pop	si				;AN000; restore registers
	pop	cx				;AN000;
	jmp	dirscan 			;AC000; keep parsing

;
; The syntax is incorrect.  Report only message we can.
;
BadParm:
	jmp	cerror				;AC000; invalid switches get displayed

ScanDone:

;
; Find and display the volume ID on the drive.
;

	invoke	okvolarg			;AC000;
;
; OkVolArg also disables APPEND, which will be re-enabled
; in the HeadFix routine, after we're done.
;
	mov	[filecnt],0			;AC000; Keep track of how many files found
	cmp	comsw,0 			;AC000; did an error occur?
	jnz	doheader			;AC000; yes - don't bother to fix path

	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
	invoke	pathcrunch			;AC000; set up FCB for dir
	mov	dirflag,0			;AN015; reset dirflag
	jc	DirCheckPath			;AC015; no CHDIRs worked.
	jz	doheader			;AC015; chdirs worked - path\*.*
	mov	si,[desttail]			;AN015; get filename back
	jmp	short DoRealParse		;AN015; go parse it

DirCheckPath:
	mov	ax,[msg_numb]			;AN022; get message number
	cmp	ax,0				;AN022; Is there a message?
	jnz	dir_err_setup			;AN022; yes - there's an error
	cmp	[destisdir],0			;AC000; Were pathchars found?
	jz	doparse 			;AC000; no - no problem
	inc	comsw				;AC000; indicate error
	jmp	short doheader			;AC000; go print header

DirNF:
	mov	ax,error_file_not_found 	;AN022; get message number in control block

dir_err_setup:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	mov	extend_buf_ptr,ax		;AN022;

DirError:
	jmp	Cerror

;
; We have changed to something.  We also have a file.  Parse it into a
; reasonable form, leaving drive alone, leaving extention alone and leaving
; filename alone.  We need to special case ...	If we are at the root, the
; parse will fail and it will give us a file not found instead of file not
; found.
;
DoParse:
	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
	jnz	dir_no_drive			;AN000; no - keep going
	lodsw					;AN000; bypass drive

dir_no_drive:
	cmp	[si],".."
	jnz	DoRealParse
	cmp	byte ptr [si+2],0
	jnz	DoRealParse
	inc	ComSw
	jmp	short DoHeader

DoRealParse:
	mov	di,FCB			; where to put the file name
	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
	int	int_command

;
; Check to see if APPEND installed.  If it is installed, set all flags
; off.	This will be reset in the HEADFIX routine
;

DoHeader:
; ORIGINAL APPEND CHECK CODE LOCATION ******************************

;
; Display the header
;

DoHeaderCont:
	mov	al,blank			;AN051; Print out a blank
	invoke	print_char			;AN051;   before DIR header
	invoke	build_dir_string		; get current dir string
	mov	dx,offset trangroup:Dirhead_ptr
	invoke	printf_crlf			; bang!

;
; If there were chars left after parse or device, then invalid file name
;
	cmp	ComSw,0
	jz	DoSearch			; nothing left; good parse
	jl	DirNFFix			; not .. => error file not found
	invoke	RestUDir
	mov	dx,offset TranGroup:BadCD_ptr
	jmp	Cerror				; was .. => error directory not found
DirNFFix:
	invoke	RestUDir
	jmp	DirNF
;
; We are assured that everything is correct.  Let's go and search.  Use
; attributes that will include finding directories.  perform the first search
; and reset our directory afterward.
;
DoSearch:
	mov	byte ptr DS:[FCB-7],0FFH
	mov	byte ptr DS:[FCB-1],010H
;
; Caution!  Since we are using an extended FCB, we will *also* be returning
; the directory information as an extended FCB.  We must bias all fetches into
; DIRBUF by 8 (Extended FCB part + drive)
;
	mov	ah,Dir_Search_First
	mov	dx,FCB-7
	int	int_command

	push	ax				;AN022; save return state
	inc	al				;AN022; did an error occur?
	pop	ax				;AN022; get return state back
	jnz	found_first_file		;AN022; no error - start dir
	invoke	set_ext_error_msg		;AN022; yes - set up error message
	push	dx				;AN022; save message
	invoke	restudir			;AN022; restore user's dir
	pop	dx				;AN022; restore message
	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
	jnz	DirCerrorJ			;AN022; 	file not found
	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;

DirCerrorJ:					;AN022;
	jmp	Cerror				;AN022; exit

;
; Restore the user's directory.  We preserve, though, the return from the
; previous system call for later checking.
;

found_first_file:
	push	ax
	invoke	restudir
	pop	ax
;
; Main scanning loop.  Entry has AL = Search first/next error code.  Test for
; no more.
;
DIRSTART:
	inc	al				; FF = file not found
	jnz	Display
	jmp	DirDone 			; Either an error or we are finished
;
; Note that we've seen a file and display the found file.
;

Display:
	inc	[filecnt]			; Keep track of how many we find
	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
	call	shoname
;
; If we are displaying in wide mode, do not output the file info
;
	test	byte ptr[bits],SwitchW		; W switch set?
	jz	DirTest
	jmp	nexent				; If so, no size, date, or time

;
; Test for directory.
;
DirTest:
	test	[dirbuf+8].dir_attr,attr_directory
	jz	fileent
;
; We have a directory.	Display the <DIR> field in place of the file size
;
	mov	dx,offset trangroup:Dmes_ptr
	call	std_printf
	jmp	short nofsiz
;
; We have a file.  Display the file size
;
fileent:
	mov	dx,[DirBuf+8].dir_size_l
	mov	file_size_low,dx
	mov	dx,[DirBuf+8].dir_size_h
	mov	file_size_high,dx
	mov	dx,offset trangroup:disp_file_size_ptr
	call	std_printf
;
; Display time and date of last modification
;
nofsiz:
	mov	ax,[DirBuf+8].dir_date		; Get date
;
; If the date is 0, then we have found a 1.x level diskette.  We skip the
; date/time fields as 1.x did not have them.
;
	or	ax,ax
	jz	nexent				; Skip if no date
	mov	bx,ax
	and	ax,1FH				; get day
	mov	dl,al
	mov	ax,bx
	mov	cl,5
	shr	ax,cl				; Align month
	and	al,0FH				; Get month
	mov	dh,al
	mov	cl,bh
	shr	cl,1				; Align year
	xor	ch,ch
	add	cx,80				; Relative 1980
	cmp	cl,100
	jb	millenium
	sub	cl,100

millenium:
	xchg	dh,dl				;AN000; switch month & day
	mov	DirDat_yr,cx			;AC000; put year into message control block
	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
	mov	cx,[DirBuf+8].dir_time		; Get time
	jcxz	prbuf				; Time field present?
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cl,1
	shr	cl,1				; Hours in CH, minutes in CL
	xchg	ch,cl				;AN000; switch hours & minutes
	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block

prbuf:
	mov	dx,offset trangroup:DirDatTim_ptr
	call	std_printf
	invoke	crlf2				;AC066;end the line
	dec	byte ptr [fullscr]		;AC066;count the line
	jnz	endif04 			;AN066;IF the last on the screen THEN
	   call    check_for_P			;AN066;   pause if /P requested
	endif04:				;AN066;
	jmp	scroll				; If not, just continue
;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
;
; We are done displaying an entry.  The code between "noexent:" and "scroll:"
; is only for /W case.
;
nexent:
	mov	bl,[lincnt]			;AN066;save for check for first entry on line
	dec	[lincnt]			      ;count this entry on the line
	jnz	else01				;AX066;IF last entry on line THEN
	   mov	   al,[linlen]
	   mov	   [lincnt],al
	   invoke  crlf2
	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
	   jnz	   endif02			;AN066;
	      call    check_for_P		;AN066;   reinitialize fullscr,
	   endif02:				;AN066;   IF P requested THEN pause
	   jmp	   short endif01		;AN066;
	else01: 				;AN066;ELSE since screen not full
	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
	   jne	   endif03			;	     count the line
	      dec     byte ptr [fullscr]	;AN066;   ENDIF
	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
	   call    std_printf
	endif01:				;AX066;
;
; All we need to do now is to get the next directory entry.
;
scroll:
	mov	ah,Dir_Search_Next
	mov	dx,FCB-7			; DX -> Unopened FCB
	int	int_command			; Search for a file to match FCB
	jmp	DirStart
;
; If no files have been found, display a not-found message
;
DirDone:
	invoke	get_ext_error_number		;AN022; get the extended error number
	cmp	ax,error_no_more_files		;AN022; was error file not found?
	jnz	dir_err_setup_jmp		;AN022; no - setup error message
	test	[filecnt],-1
	jnz	Trailer
	mov	ax,error_file_not_found 	;AN022;

dir_err_setup_jmp:				;AN022;
	jmp	dir_err_setup			;AN022; go setup error msg & print it
;
; If we have printed the maximum number of files per line, terminate it with
; CRLF.
;
Trailer:
	mov	al,[linlen]
	cmp	al,[lincnt]			; Will be equal if just had CR/LF
	jz	mmessage
	invoke	crlf2
	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
	jnz	endif06 			;AN066;   pause before going on
	   call    check_for_P			;AN066;   to number and freespace
	endif06:				;AN066;   displays

mmessage:
	mov	dx,offset trangroup:Dirmes_ptr
	mov	si,[filecnt]
	mov	dir_num,si
	call	std_printf
	mov	ah,Get_Drive_Freespace
	mov	dl,byte ptr DS:[FCB]
	int	int_command
	cmp	ax,-1
	retz
	mul	cx				; AX is bytes per cluster
	mul	bx
	mov	bytes_free,ax			;AC000;
	mov	bytes_free+2,dx 		;AC000;
	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
	jmp	std_printf

shoname:
	mov	di,offset trangroup:charbuf
	mov	cx,8
	rep	movsb
	mov	al,' '
	stosb
	mov	cx,3
	rep	movsb
	xor	ax,ax
	stosb
	push	dx
	mov	dx,offset trangroup:charbuf
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	call	std_printf
	pop	DX
	return

check_for_P    PROC  NEAR			;AN066;

test	byte ptr[bits],SwitchP	     ;P switch present?
jz	endif05 				;AN066;
   mov	   ax,linperpag 		   ;AN000;  transfer lines per page
   mov	   [fullscr],ax 		   ;AC000;	to fullscr
   invoke  Pause
endif05:
ret						;AN066;

check_for_P    ENDP				;AN066;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tcmd2b.asm ===
page ,132
;	SCCSID = @(#)tcmd2b.asm 4.1 85/09/22
;	SCCSID = @(#)tcmd2b.asm 4.1 85/09/22
TITLE	PART5 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include mult.inc
	include comseg.asm
	include comequ.asm
	include cmdsvc.inc
.list
.cref


;;CODERES 	SEGMENT PUBLIC BYTE	;AC000;
;;	EXTRN	LODCOM1:NEAR
;;CODERES ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	crit_msg_off:word	;AC000;
	EXTRN	crit_msg_seg:word	;AC000;
	EXTRN	IO_SAVE:WORD
	EXTRN	OldTerm:DWORD
	EXTRN	PARENT:WORD
;AD060; EXTRN	pars_msg_off:word	;AC000;
;AD060; EXTRN	pars_msg_seg:word	;AC000;
	EXTRN	PERMCOM:BYTE		;AN045;
	EXTRN	RetCode:WORD
	EXTRN	SingleCom:word

	extrn	TrnLodCom1_Trap:far

DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ACRLF_PTR:WORD		;AN007;
	EXTRN	baddev_ptr:word
	EXTRN	CP_active_Ptr:word
	EXTRN	CP_not_all_Ptr:word
	EXTRN	CP_not_set_Ptr:word
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	Extend_buf_sub:byte	;AN000;
	EXTRN	inv_code_page:word	;AC000;
	EXTRN	msg_disp_class:byte	;AN000;
	EXTRN	NLSFUNC_Ptr:word	;AC000;
	EXTRN	parse_chcp:byte 	;AC000;
	EXTRN	parse_chdir:byte	;AC000;
	EXTRN	parse_ctty:byte 	;AC000;
	EXTRN	string_buf_ptr:word	;AC000;

	extrn	NoCntry_Ptr:word	;M045

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	COMBUF:BYTE
	EXTRN	parse_last:word 	;AN018;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	RESSEG:WORD
	EXTRN	srcbuf:byte
	EXTRN	srcxname:byte		;AC000;
	EXTRN	string_ptr_2:word
	EXTRN	system_cpage:word
	EXTRN	TRAN_TPA:WORD
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;---------------

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
TRANSPACE	ENDS
;---------------

	EXTRN	cerror:near
	extrn	TCommand:near

	PUBLIC	$exit
	PUBLIC	chcp
	PUBLIC	ctty
	PUBLIC	parse_check_eol 	;AN000;
	PUBLIC	parse_with_msg		;AN018;
	PUBLIC	setup_parse_error_msg	;AN018;
	PUBLIC	truename		;AN000;

	break	Ctty
assume	ds:trangroup,es:trangroup

; ****************************************************************
; *
; * ROUTINE:	 CTTY - Change console
; *
; * SYNTAX:	 CTTY device
; *
; * FUNCTION:	 If a valid console device is specified, CTTY will
; *		 duplicate the device handle to STDIN, STDOUT and
; *		 STDERR.  This routine returns to LODCOM1.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CTTY:
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AC000; Get command argument for CTTY

	mov	di,offset trangroup:parse_ctty	;AC000; Get adderss of PARSE_CTTY
	xor	cx,cx				;AC000; clear cx,dx
	xor	dx,dx				;AC000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jz	ctty_error			;AN000; yes - error
	cmp	ax,result_no_error		;AN000; did an error occur
	jnz	ctty_error			;AN000; YES -ERROR

	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf

ctty_move_filename:				;AN000; put filespec in srcbuf
	lodsb					;AN000; get a char from buffer
	stosb					;AN000; store in srcbuf
	cmp	al,end_of_line_out		;AN000; it char a terminator?
	jnz	ctty_move_filename		;AN000; no - keep moving
	pop	si				;AN000; get line position back
	mov	di,offset trangroup:parse_ctty	;AC000; Get adderss of PARSE_CTTY
ifndef NEC_98
	call	parse_check_eol 		;AN000; are we at end of line?
else    ;NEC_98
;	call	parse_check_eol 		;AN000; are we at end of line?	; NEC01 91/07/31 Del

	xor	dx,dx				;AN000;				; NEC01 91/07/31
	mov	[parse_last],si 		;AN018; save start of parameter	; NEC01 91/07/31
	invoke	cmd_parse			;AN000; call parser		; NEC01 91/07/31
	cmp	al,end_of_line			;AN000; Are we at end of line?	; NEC01 91/07/31
endif   ;NEC_98
	jz	nocolon 			;AN000; yes - continue

ctty_error:
	jmp	short isbaddev			;AC000; yes - exit

nocolon:
	mov	dx,offset trangroup:srcbuf	;AN000; get address of srcbuf
	MOV	AX,(OPEN SHL 8) OR 2		; Read and write
	INT	21h			; Open new device
	JC	ISBADDEV
	MOV	BX,AX
	MOV	AX,IOCTL SHL 8
	INT	21h
	TEST	DL,80H
	JNZ	DEVISOK

CLOSEDEV:					;AN007;
	MOV	AH,CLOSE			; Close initial handle
	INT	21h

ISBADDEV:
	MOV	DX,OFFSET TRANGROUP:BADDEV_ptr
	invoke	std_printf
	JMP	SHORT RESRET

DEVISOK:
	push	dx				;AN007; save device info
	mov	ax,acrlf_ptr			;AN021; get message number for 0d, 0a
	mov	dh,util_msg_class		;AN021; this is a utility message
	push	bx				;AN021; save handle
	invoke	Tsysgetmsg			;AN021; get the address of the message
	mov	dx,si				;AN021; get address into dx
	mov	ax,(write shl 8)		;AN007; write to device
	mov	cx,2				;AN007; write two bytes
	int	21h			;AN007;
	pop	bx				;AN021; get back handle
	pop	dx				;AN007; get back device info
	jc	closedev			;AN007; if error, quit
	XOR	DH,DH
	OR	DL,3				; Make sure has CON attributes
	MOV	AX,(IOCTL SHL 8) OR 1
	INT	21h
	PUSH	BX				; Save handle
	MOV	CX,3
	XOR	BX,BX

ICLLOOP:					; Close basic handles
	MOV	AH,CLOSE
	INT	21h
	INC	BX
	LOOP	ICLLOOP
	POP	BX				; Get handle
	MOV	AH,XDUP
	INT	21h			; Dup it to 0
	MOV	AH,XDUP
	INT	21h			; Dup to 1
	MOV	AH,XDUP
	INT	21h			; Dup to 2
	MOV	AH,CLOSE			; Close initial handle
	INT	21h

RESRET:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	PUSH	DS
	MOV	AX,WORD PTR DS:[PDB_JFN_Table]	; Get new 0 and 1
	MOV	[IO_SAVE],AX
	MOV	AX,OFFSET DATARES:TrnLodCom1_Trap
	PUSH	AX

ZMMMM	PROC FAR
	RET					; Force header to be checked
ZMMMM	ENDP

	break	Chcp

;****************************************************************
;*
;* ROUTINE:	CHCP - Change code page internal command
;*		(added DOS 3.30 07/21/86)
;*
;* SYNTAX:	CHCP [xxx]
;*		where xxx is a valid code page
;*
;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
;*		6402H to set the code page to xxxx. If no parameters
;*		are specified, CHCP will use INT 21H function 6401H
;*		to get global code page and display it to the user.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

NLSFUNC_installed	equ    0ffh
set_global_cp		equ    2
get_global_cp		equ    1

assume	ds:trangroup,es:trangroup

CHCP:
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AC000; Get command argument for CHCP

	mov	di,offset trangroup:parse_chcp	;AN000; Get adderss of PARSE_CHCP
	xor	cx,cx				;AC000; clear cx,dx
	xor	dx,dx				;AC000;
	call	parse_with_msg			;AC018; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?

;;	jnz	setcp				;AC000; no go get number & set code page
	jz	getcp				;AC000; yes - no parm - get code page

setcp:
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	cp_error			;AC018; yes - go issue message

	push	cx				;AN000; save positional count
	mov	bx,offset trangroup:parse1_addr ;AN000; get number returned
	mov	cx,word ptr [bx]		;AN000;     into cx
	mov	system_cpage,cx 		;AN000; save user input number
	pop	cx				;AC000; restore positional count
	mov	di,offset trangroup:parse_chcp	;AN000; Get adderss of PARSE_CHCP
	call	parse_check_eol 		;AN000; are we at end of line?
	jnz	cp_error			;AC000; no - exit

okset:
	mov	ah,NLSFUNC			;AN000; see if NLSFUNC installed
	mov	al,0				;AN000;
	int	2fh				;AN000;
	cmp	al,NLSFUNC_installed		;AN000;
	jz	got_NLS 			;AN000; Yes - continue
	mov	dx,offset trangroup:NLSFUNC_ptr ;AN000; no - set up error message
	jmp	short cp_error			;AN000; error exit

got_NLS:
	mov	bx,system_cpage 		;AN000; get user input code page
	mov	ah,getsetcdpg			;get/set global code page function
	mov	al,set_global_cp		;minor - set
	int	21h
	jnc	chcp_return			;no error - exit
;
;added for p716
;
	cmp	ax,error_file_not_found 	;p716 was the error file not found?
	jnz	chcp_other_error		;no - country.sys was found

	mov	ah,GetExtendedError		;p850 see if error is invalid data
	xor	bx,bx				;  which is file was found but CP
	int	21h			;  information was not found.
	cmp	ax,error_invalid_data		;AC000; invalid code page
	jnz	no_countrysys			;no - use file not found
	mov	dx,offset trangroup:inv_code_page ;AN000; get message
	jmp	short cp_error			;AC000; error exit

no_countrysys:
;M045;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
;M045;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
;M045;	mov	Extend_Buf_ptr,error_file_not_found ;AN000; get message number in control block
	
	mov	dx,offset TRANGROUP:NoCntry_Ptr	;M045

	jmp	short cp_error			;AC000; error exit

chcp_other_error:
;
; end of p716
;
	mov	ah,GetExtendedError		;error - see what it is
	xor	bx,bx
	int	21h
	cmp	ax,65				;was it access denied?
	jnz	none_set			;no - assume all failed
	mov	dx,offset trangroup:cp_not_all_ptr ;set up message
	jmp	short cp_error			;AC000; error exit

none_set:
	mov	dx,offset trangroup:cp_not_set_ptr ;set up message
cp_error:					;AN000;
	jmp	cerror				;exit

getcp:
	mov	ah,getsetcdpg			;get/set global code page function
	mov	al,get_global_cp		;minor - get
	int	21h
	mov	system_cpage,bx 		;get active cp for output
	mov	dx,offset trangroup:cp_active_ptr
	invoke	std_printf			;print it out

chcp_return:

	RET

	break	TRUENAME			;AN000;


; ****************************************************************
; *
; * ROUTINE:	 TRUENAME
; *
; * FUNCTION:	 Entry point for the internal TRUENAME command.
; *		 Parses the command line. If a path is found, set
; *		 SRCXNAME to path.  If only a drive letter is
; *		 found, set SRCXNAME to the drive letter.  If
; *		 no path is found, set the path of SRCXNAME to
; *		 dot (.) for current directory.  Use the NAME
; *		 TRANSLATE system call to get the real name and
; *		 then display the real name.  If an error occurs
; *		 issue an error message and transfer control to
; *		 CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup		;AN000;

TRUENAME:					;AN000; TRUENAME entry point
	push	ds				;AN000; Get local ES
	pop	es				;AN000;
	mov	si,81H				;AN000; Get command line
	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	call	parse_with_msg			;AC018; call parser

	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
	cmp	ax,end_of_line			;AN000; are we at end of line?
	je	tn_eol				;AN000; yes - go process
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	tn_parse_error			;AN000; yes - go issue message
	cmp	parse1_type,result_drive	;AN000; was a drive entered?
	je	tn_drive			;AN000; yes - go process
	jmp	short tn_filespec		;AN000; nothing else - must be filespec

tn_eol: 					;AN000; no parameters on line
	mov	ah,end_of_line_out		;AN000; set buffer to .
	mov	al,dot_chr			;AN000;     for current dir
	stosw					;AN000; store in srcxname
	jmp	short tn_doit			;AN000; go do command

tn_drive:					;AN000; a drive was entered
	push	si				;AN000; save position in line
	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
	lodsb					;AN000; get the drive number
	add	al,"A"-1                        ;AN000; convert it to char
	stosb					;AN000; store it in srcxname
	mov	ax,dot_colon			;AN000; get colon and . and
	stosw					;AN000;    store in srcxname
	mov	al,end_of_line_out		;AN000; put a terminator char
	stosb					;AN000;
	pop	si				;AN000; get line position back
	jmp	short tn_check_eol		;AN000; check to make sure eol

tn_filespec:					;AN000; a filespec was entered
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec

tn_move_filename:				;AN000; put filespec in srcxname
	lodsb					;AN000; get a char from buffer
	stosb					;AN000; store in srcxname
	cmp	al,end_of_line_out		;AN000; it char a terminator?
	jnz	tn_move_filename		;AN000; no - keep moving
	pop	si				;AN000; get line position back

tn_check_eol:					;AN000; make sure no extra parms
	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
	call	parse_check_eol 		;AN000; are we at end of line?
	je	tn_doit 			;AN000; Yes - do the command

tn_parse_error: 				;AN000; A parse error occurred
	jmp	cerror				;AN000; Go to error routine

tn_doit:					;AN000;
	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
	mov	ah,xnametrans			;AN000; do name translate call
	int	21h			;AN000;
	jnc	tn_print_xname			;AN000; If no error - print result

	invoke	Set_ext_error_msg		;AN000; get extended message
	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
	jmp	cerror				;AN000; Go to error routine

tn_print_xname: 				;AN000;
	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
	invoke	crlf2				;AN000; print a crlf
	invoke	printf_crlf			;AN000; print it out

	ret					;AN000;

	break	$Exit

assume	ds:trangroup,es:trangroup

$EXIT:
	push	ds				;AN000; save data segment
	mov	ds,[resseg]			;AN000; get resident data segment

assume	ds:resgroup				;AN000;

	cmp	[permcom],0			;AN045; is this a permanent COMMAND?
	jz	free_com			;AN045; no - free everything

;	We're a permanent command.
;	Unless this is a singlecom (int 2Eh), don't deallocate transient.

	cmp	[singlecom],-1		;M034
	je	no_reset		;M034	;exit singlecom

;	jmp	TCommand			;permanent command, recycle

;Sudeepb 05-Jul-1991; Removed above jmp to terminate the top level
;		      command.com.
	CMDSVC	SVC_CMDEXITVDM		; Never returns

;AD060; mov	ah,multdos			;AN000; reset parse message pointers
;AD060; mov	al,message_2f			;AN000; call for message retriever
;AD060; mov	dl,set_parse_msg		;AN000; set up parse message address
;AD060; mov	di,pars_msg_off 		;AN000; old offset of parse messages
;AD060; mov	es,pars_msg_seg 		;AN000; old segment of parse messages
;AD060; int	2fh				;AN000; go set it

;AD060; mov	ah,multdos			;AN000; set up to call DOS through int 2fh
;AD060; mov	al,message_2f			;AN000; call for message retriever

free_com:
	mov	ax,(multdos shl 8 or message_2f);AN060; reset parse message pointers
	mov	dl,set_critical_msg		;AN000; set up critical error message address
	mov	di,crit_msg_off 		;AN000; old offset of critical messages
	mov	es,crit_msg_seg 		;AN000; old segment of critical messages
	int	2fh				;AN000; go set it
no_reset:					;AN045;
	pop	ds				;AN000; restore local data segment

assume	ds:trangroup				;AN000;
;
;M040
; Restore user directory if the restore flag is set. RestUDir1 checks for
;this, restores user dir if flag is set and resets the flag.
;
	invoke	RestUDir1		;restore user dir if needed ;M040
	MOV	ES,[RESSEG]

assume	es:resgroup

	MOV	AX,[PARENT]
	MOV	WORD PTR ES:[PDB_Parent_PID],AX
	MOV	AX,WORD PTR OldTerm
	MOV	WORD PTR ES:[PDB_Exit],AX
	MOV	AX,WORD PTR OldTerm+2
	MOV	WORD PTR ES:[PDB_Exit+2],AX

	PUSH	ES
	MOV	ES,[TRAN_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Now running in "free" space
	POP	ES

	MOV	AH,Exit
	MOV	AL,BYTE PTR RetCode
	INT	21h


; ****************************************************************
; *
; * ROUTINE:	 PARSE_CHECK_EOL
; *
; * FUNCTION:	 Calls parser to see if end of line occurred.
; *		 If not end of line, set up to print parse
; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
; *		 EXPECTED!
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if end of line found
; *		     zero flag set
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;

parse_check_eol Proc near			;AN000;

	xor	dx,dx				;AN000;
	mov	[parse_last],si 		;AN018; save start of parameter
	invoke	cmd_parse			;AN000; call parser
	cmp	al,end_of_line			;AN000; Are we at end of line?
	jz	parse_good_eol			;AN000; yes - no problem

	cmp	ax,result_no_error		;AN018; was any error found?
	jnz	ok_to_setup_pmsg		;AN018; yes - continue
	inc	ax				;AN018; set AX to 1 and turn off zero flag

ok_to_setup_pmsg:
	call	setup_parse_error_msg		;AN018; go set up error message

parse_good_eol:
	ret					;AN000;

parse_check_eol endp				;AN000;

; ****************************************************************
; *
; * ROUTINE:	 PARSE_WITH_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if no error
; *		     outputs from parser
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *		     error message set up for STD_PRINTF
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;

parse_with_msg	Proc near			;AN018;

	mov	[parse_last],si 		;AN018; save start of parameter
	invoke	cmd_parse			;AN018; call parser
	cmp	al,end_of_line			;AN018; Are we at end of line?
	jz	parse_msg_good			;AN018; yes - no problem
	cmp	ax,result_no_error		;AN018; did an error occur
	jz	parse_msg_good			;AN018; yes - no problem

	call	setup_parse_error_msg		;AN018; go set up error message

parse_msg_good:
	ret					;AN018;

parse_with_msg endp				;AN018;

; ****************************************************************
; *
; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 AX	     Parse error number
; *		 SI	     Set to past last parameter
; *		 Parse_last  Set to start of last parameter
; *
; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
; *		 error message set up for STD_PRINTF
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;

SETUP_PARSE_ERROR_MSG	Proc near		;AN018;

	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
	jz	Setup_parse_msg_ret		;AN018;    no subst
	mov	si,[parse_last] 		;AC018; get start of parameter
	mov	string_ptr_2,si 		;AC018; get address of failed string
	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block

setup_parse_msg_ret:
	inc	si				;AN018; make sure zero flag not set

	ret					;AC018;

SETUP_PARSE_ERROR_MSG	Endp			;AN018;

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tdata.asm ===
page ,132
;	SCCSID = @(#)tdata.asm	4.3 85/05/17
;	SCCSID = @(#)tdata.asm	4.3 85/05/17
TITLE	COMMAND Transient Initialized DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; MODIFICATION HISTORY
;
;	EE 10-20-83	Changed the drive check indicator bytes (DCIB's) in
;			COMTAB to be a flag byte in which bit 0 is now the
;			DCIB(bit) and bit 1 is on if the command can take
;			switches.
;
;	M003	SR	07/16/90 	Added LoadHigh to command table, added
;					parse control block for LoadHigh
;
;	M008	SA	8/1/90		Remove /h parameter. Eliminate code to
;					internally handle /? message.
;
;	M010	SA	8/5/90		Add support for /l (lowercase) option.
;
;	M016	SR	08/09/90	Added public statements for new error
;				messages for LoadHigh.
;



comment %

The TRANDATA segment contains data that is assumed to have predefined
initial values at the beginning of each command cycle.  It is
included in the transient checksum area.  If values in TRANDATA
change, the transient will be reloaded for the next command cycle.

Modification History
--------------------

8/12/89         DBO     History resumes after six years.

8/12/89         DBO     Added for new DIR:
-8/14/89                DirEnvVar, AttrLtrs, OrderLtrs;
                        New PARSE_DIR and subordinate parse blocks
                        (called PARSE_DIR_E for now);

%




fmt macro   name,string,args
	local	a
a	db  string
PUBLIC	name
name	dw  offset trangroup:a
irp val,<args>
	dw  offset trangroup:val
endm
endm

btab	macro	b,sym
    db	b
    dw	    offset trangroup:sym
    endm

.xlist
.xcref
	INCLUDE comsw.asm				;AC000;
	INCLUDE comseg.asm
	INCLUDE dirent.inc				;AN042;
.list
.cref

BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM

;
; WARNING: DO NOT INCLUDE DOSSYM.INC BECAUSE IT DESTROYS THE MACRO 'FMT' THAT
; has been defined above - RS.
;
	INCLUDE ERROR.INC
	INCLUDE ifequ.asm
	INCLUDE comequ.asm
;	Note curdir.inc is included by comequ.asm

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf:BYTE
	EXTRN	bwdbuf:byte
	EXTRN	bytes_free:WORD
	EXTRN	charbuf:byte
	EXTRN	copy_Num:WORD
	EXTRN	DATE_OUTPUT:BYTE	;AC000;
	EXTRN	Dir_Num:WORD
	EXTRN	DRIVE_OUTPUT:BYTE	;AC000;
	EXTRN	file_size_high:WORD
	EXTRN	file_size_low:WORD
        EXTRN   FileSiz:DWORD           ; accumulated file size for DIR
	EXTRN	major_ver_num:WORD
	EXTRN	minor_ver_num:WORD
	EXTRN	one_char_val:BYTE
	EXTRN	PARSE1_OUTPUT:BYTE	;AC000;
	EXTRN	srcbuf:byte
	EXTRN	string_ptr_2:WORD
	EXTRN	system_cpage:word
	EXTRN	TIME_OUTPUT:BYTE	;AC000;
	EXTRN	vol_drv:BYTE
	EXTRN	vol_serial:dword	;AN000;
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	$CALL:NEAR
	EXTRN	$CHDIR:NEAR
	EXTRN	$EXIT:NEAR
	EXTRN	$FOR:NEAR
	EXTRN	$IF:NEAR
	EXTRN	$MKDIR:NEAR
	EXTRN	$RMDIR:NEAR
	EXTRN	ADD_NAME_TO_ENVIRONMENT:NEAR
	EXTRN	ADD_PROMPT:NEAR
	EXTRN	build_dir_for_prompt:near
	EXTRN	CATALOG:NEAR
	EXTRN	CHCP:NEAR
	EXTRN	CLS:NEAR
	EXTRN	CNTRLC:NEAR
	EXTRN	COPY:NEAR
	EXTRN	CRENAME:NEAR
	EXTRN	CRLF2:NEAR
	EXTRN	CTIME:NEAR
	EXTRN	CTTY:NEAR
	EXTRN	DATE:NEAR
	EXTRN	ECHO:NEAR
	EXTRN	ERASE:NEAR
	EXTRN	GOTO:NEAR
	EXTRN	IFERLEV:NEAR
	EXTRN	IFEXISTS:NEAR
	EXTRN	IFNOT:NEAR
	EXTRN	PATH:NEAR
	EXTRN	PAUSE:NEAR
	EXTRN	PRINT_B:NEAR
	EXTRN	PRINT_BACK:NEAR
	EXTRN	PRINT_DATE:NEAR
	EXTRN	PRINT_CHAR:NEAR
	EXTRN	PRINT_DRIVE:NEAR
	EXTRN	PRINT_EQ:NEAR
	EXTRN	PRINT_ESC:NEAR
	EXTRN	PRINT_G:NEAR
	EXTRN	PRINT_L:NEAR
	EXTRN	PRINT_TIME:NEAR
	EXTRN	PRINT_VERSION:NEAR
	EXTRN	SHIFT:NEAR
	EXTRN	TCOMMAND:NEAR
	EXTRN	TRUENAME:NEAR		;AN000;
	EXTRN	TYPEFIL:NEAR
	EXTRN	VERSION:NEAR
	EXTRN	VOLUME:NEAR
	EXTRN	VERIFY:NEAR

	extrn	LoadHigh:NEAR		; M003
;
; WARNING!!! No code may appear after this label!!!!
;
;
; Bugbug:
;   8/12/89 Looks like somebody ignored/missed this warning.  TRANCODE
;           is added to at the end of this file.  Fortunately, it looks
;           like no modules refer to this label.
;
PUBLIC	TranCodeLast
TranCodeLast	LABEL	BYTE
TRANCODE	ENDS

; Data for transient portion

TRANDATA	SEGMENT PUBLIC BYTE

	PUBLIC	accden_ptr		;AN000;
	PUBLIC	acrlf_ptr		;AN000;
	PUBLIC	arg_buf_ptr		;AN000;
        PUBLIC  AttrLtrs
	PUBLIC	badbat_ptr		;AN000;
	PUBLIC	badcd_ptr		;AN000;
	PUBLIC	badCPmes_ptr		;AN000;
	PUBLIC	badcurdrv		;AN000;
	PUBLIC	baddat_ptr		;AN000;
	PUBLIC	baddev_ptr		;AN000;
	PUBLIC	baddrv_ptr		;AN000;
	PUBLIC	badlab_ptr		;AN000;
	PUBLIC	badmkd_ptr		;AN000;
	PUBLIC	badnam_ptr		;AN000;
	PUBLIC	bad_on_off_ptr		;AN000;
	PUBLIC	badPmes_ptr		;AN000;
	PUBLIC	badrmd_ptr		;AN000;
	PUBLIC	badtim_ptr		;AN000;
	PUBLIC	batext
        PUBLIC  bytes_ptr
	PUBLIC	bytmes_ptr		;AN000;
	PUBLIC	CLSSTRING
	PUBLIC	comext
        PUBLIC  comspec_flag            ;AN071;
	PUBLIC	COMSPECSTR
	PUBLIC	COMTAB
	PUBLIC	copied_ptr		;AN000;
	PUBLIC	cp_active_ptr		;AN000;
	PUBLIC	cp_not_all_ptr		;AN000;
	PUBLIC	cp_not_set_ptr		;AN000;
	PUBLIC	ctrlcmes_ptr		;AN000;
	PUBLIC	curdat_mo_day		;AN000;
	PUBLIC	curdat_ptr		;AN000;
	PUBLIC	curdat_yr		;AN000;
	PUBLIC	curtim_hr_min		;AN000;
	PUBLIC	curtim_ptr		;AN000;
	PUBLIC	curtim_sec_hn		;AN000;
	PUBLIC	dback_ptr		;AN000;
	PUBLIC	del_Y_N_ptr		;AN000;
	PUBLIC	devwmes_ptr		;AN000;
        PUBLIC  dircont_ptr
	PUBLIC	dirdattim_ptr		;AN000;
	PUBLIC	dirdat_mo_day		;AN000;
	PUBLIC	dirdat_yr		;AN000;
        PUBLIC  DirEnvVar
	PUBLIC	dirhead_ptr		;AN000;
	PUBLIC	dirmes_ptr		;AN000;
	PUBLIC	dirtim_hr_min		;AN000;
	PUBLIC	dirtim_sec_hn		;AN000;
        PUBLIC  DIR_SW_PTRS
	PUBLIC	disp_file_size_ptr	;AN000;
	PUBLIC	DosHma_Ptr
	PUBLIC	DosLow_Ptr
	PUBLIC	DosRev_Ptr
	PUBLIC	DosRom_Ptr
	PUBLIC	dmes_ptr		;AN000;
	PUBLIC	echomes_ptr		;AN000;
	PUBLIC	enverr_ptr		;AN000;
        PUBLIC  errparsenv_ptr
	PUBLIC	eurdat_ptr		;AN000;
	PUBLIC	exeext
	PUBLIC	extend_buf_off		;AN000;
	PUBLIC	extend_buf_ptr		;AN000;
	PUBLIC	extend_buf_seg		;AN000;
	PUBLIC	extend_buf_sub		;AN000;
	PUBLIC	file_name_ptr		;AN000;
	PUBLIC	fornestmes_ptr		;AN000;
	PUBLIC	fuldir_ptr		;AN000;
	PUBLIC	IFTAB
	PUBLIC	inBdev_ptr		;AN000;
	PUBLIC	inornot_ptr		;AN000;
	PUBLIC	Inv_code_page		;AN000;
	PUBLIC	inval_path_ptr		;AN000;
	PUBLIC	japdat_ptr		;AN000;
	PUBLIC	Losterr_ptr		;AN000;
	PUBLIC	md_exists_ptr		;AN006;
	PUBLIC	msg_cont_flag		;AN000;
	PUBLIC	msg_disp_class		;AN000;
	PUBLIC	needbat_ptr		;AN000;
	PUBLIC	newdat_format		;AN000;
	PUBLIC	newdat_ptr		;AN000;
	PUBLIC	newtim_ptr		;AN000;
	PUBLIC	NLSFUNC_ptr		;AN000;
	PUBLIC	nospace_ptr		;AN000;
	PUBLIC	no_values		;AN000;
	PUBLIC	nulpath_ptr		;AN000;
	PUBLIC	offmes_ptr		;AN000;
	PUBLIC	onmes_ptr		;AN000;
        PUBLIC  OrderLtrs               ; list of sort order letters for DIR
	PUBLIC	overwr_ptr		;AN000;
	PUBLIC	PARSE_BREAK		;AN000;
	PUBLIC	PARSE_CHCP		;AN000;
	PUBLIC	PARSE_CHDIR		;AN000;
	PUBLIC	PARSE_CTTY		;AN000;
	PUBLIC	PARSE_DATE		;AN000;
	PUBLIC	PARSE_DIR		;AN000;
	PUBLIC	PARSE_ERASE		;AN000;
	PUBLIC	PARSE_MRDIR		;AN000;
	PUBLIC	PARSE_RENAME		;AN000;
	PUBLIC	PARSE_TIME		;AN000;
	PUBLIC	PARSE_VER
	PUBLIC	PARSE_VOL		;AN000;

	public	Parse_LoadHi		; Parse block for LoadHigh; M003

	PUBLIC	PATH_TEXT
	PUBLIC	pausemes_ptr		;AN000;
	PUBLIC	pipeEmes_ptr		;AN000;
	PUBLIC	promptdat_moday 	;AN000;
	PUBLIC	promptdat_ptr		;AN000;
	PUBLIC	promptdat_yr		;AN000;
	PUBLIC	PROMPT_TABLE
	PUBLIC	PROMPT_TEXT
	PUBLIC	promtim_hr_min		;AN000;
	PUBLIC	promtim_ptr		;AN000;
	PUBLIC	promtim_sec_hn		;AN000;
	PUBLIC	renerr_ptr		;AN000;
	PUBLIC	SLASH_P_SYN		;AN000;
	PUBLIC	string_buf_ptr		;AN000;
	PUBLIC	suremes_ptr		;AN000;
	PUBLIC	switch_list
	PUBLIC	syntmes_ptr		;AN000;
	PUBLIC	tab_ptr 		;AN000;
        PUBLIC  total_ptr
	PUBLIC	TRANDATAEND
	PUBLIC	usadat_ptr		;AN000;
	PUBLIC	verimes_ptr		;AN000;
	PUBLIC	vermes_ptr		;AN000;
	PUBLIC	volmes_ptr		;AN000;
	PUBLIC	volmes_ptr_2		;AN000;
	PUBLIC	volsermes_ptr		;AN000;
	PUBLIC	WEEKTAB

	public	NoExecBat_Ptr		; M016
	public	LhInvFil_Ptr		; M016
	public	NoCntry_Ptr		; M045

INCLUDE tranmsg.asm

; Lists of help message numbers for internal commands and /?

;;NoHelpMsgs	dw	1200,0		;M014
BreakHelpMsgs	dw	1300,0
ChcpHelpMsgs	dw	1320,1321,0
CdHelpMsgs	dw	1340,1341,1342,0
ClsHelpMsgs	dw	1360,0
CopyHelpMsgs	dw	1400,1401,1402,1403,1404,0
CttyHelpMsgs	dw	1420,0
DateHelpMsgs	dw	1440,1441,0
DelHelpMsgs	dw	1460,1461,1462,0
DirHelpMsgs	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488,0
ExitHelpMsgs	dw	1500,0
MdHelpMsgs	dw	1520,0
PathHelpMsgs	dw	1540,1541,1542,0
PromptHelpMsgs	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
RdHelpMsgs	dw	1580,0
RenHelpMsgs	dw	1600,1601,1602,0
SetHelpMsgs	dw	1620,1621,1622,0
TimeHelpMsgs	dw	1640,1641,0
TypeHelpMsgs	dw	1660,0
VerHelpMsgs	dw	1680,0
VerifyHelpMsgs	dw	1700,0
VolHelpMsgs	dw	1720,0

CallHelpMsgs	dw	1740,1741,0	;M014
RemHelpMsgs	dw	1760,0		;M014
PauseHelpMsgs	dw	1780,0		;M014
EchoHelpMsgs	dw	1800,1801,0	;M014
GotoHelpMsgs	dw	1820,1821,0	;M014
ShiftHelpMsgs	dw	1840,0		;M014
IfHelpMsgs	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
ForHelpMsgs	dw	1880,1881,1882,1883,0	;M014
TruenameHelpMsgs dw	1900,0			;M014
LoadhighHelpMsgs dw	1920,1921,1922,0	;M014


CLSSTRING DB	4,01BH,"[2J"            ; ANSI Clear screen

PROMPT_TABLE LABEL BYTE
	btab	"B",Print_B
	btab	"D",PRINT_DATE
	btab	"E",PRINT_ESC
	btab	"G",PRINT_G
	btab	"H",PRINT_BACK
	btab	"L",PRINT_L
	btab	"N",PRINT_DRIVE
	btab	"P",build_dir_for_prompt
	btab	"Q",PRINT_EQ
	btab	"T",PRINT_TIME
	btab	"V",PRINT_VERSION
	btab	"_",CRLF2
	btab	"$",PRINT_CHAR
	DB	0				; NUL TERMINATED

IFTAB	LABEL	BYTE				; Table of IF conditionals
	DB	3,"NOT"                         ; First byte is count
	DW	OFFSET TRANGROUP:IFNOT
	DB	10,"ERRORLEVEL"
	DW	OFFSET TRANGROUP:IFERLEV
	DB	5,"EXIST"
	DW	OFFSET TRANGROUP:IFEXISTS
	DB	0

; Table for internal command names
COMTAB	DB	3,"DIR",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:CATALOG	; In TCMD1.ASM
	DW	TRANGROUP:DirHelpMsgs
	DB	4,"CALL",fSwitchAllowed
	DW	OFFSET TRANGROUP:$CALL		; In TBATCH2.ASM
	DW	TRANGROUP:CallHelpMsgs
ifndef NEC_98
	DB	4,"CHCP",fSwitchAllowed
else    ;NEC_98
        DB      4,"    ",fSwitchAllowed         ; NEC01 91/07/29 CHCP Command DEL
endif   ;NEC_98
	DW	OFFSET TRANGROUP:CHCP		; In TCMD2B.ASM
	DW	TRANGROUP:ChcpHelpMsgs
	DB	6,"RENAME",fSwitchAllowed+fCheckDrive  ;AC018; P3903
	DW	OFFSET TRANGROUP:CRENAME	; In TCMD1.ASM
	DW	TRANGROUP:RenHelpMsgs
	DB	3,"REN",fSwitchAllowed+fCheckDrive     ;AC018; P3903
	DW	OFFSET TRANGROUP:CRENAME	; In TCMD1.ASM
	DW	TRANGROUP:RenHelpMsgs
	DB	5,"ERASE",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:ERASE		; In TCMD1.ASM
	DW	TRANGROUP:DelHelpMsgs
	DB	3,"DEL",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:ERASE		; In TCMD1.ASM
	DW	TRANGROUP:DelHelpMsgs
	DB	4,"TYPE",fSwitchAllowed+fCheckDrive  ;AC018; P3903
	DW	OFFSET TRANGROUP:TYPEFIL	; In TCMD1.ASM
	DW	TRANGROUP:TypeHelpMsgs
	DB	3,"REM",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:TCOMMAND	; In TCODE.ASM
	DW	TRANGROUP:RemHelpMsgs
	DB	4,"COPY",fSwitchAllowed+fCheckDrive
	DW	OFFSET TRANGROUP:COPY		; In COPY.ASM
	DW	TRANGROUP:CopyHelpMsgs
	DB	5,"PAUSE",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:PAUSE		; In TCMD1.ASM
	DW	TRANGROUP:PauseHelpMsgs
	DB	4,"DATE",fSwitchAllowed
	DW	OFFSET TRANGROUP:DATE		; In TPIPE.ASM
	DW	TRANGROUP:DateHelpMsgs
	DB	4,"TIME",fSwitchAllowed         ;AC018; P3903
	DW	OFFSET TRANGROUP:CTIME		; In TPIPE.ASM
	DW	TRANGROUP:TimeHelpMsgs
	DB	3,"VER",fSwitchAllowed
	DW	OFFSET TRANGROUP:VERSION	; In TCMD2.ASM
	DW	TRANGROUP:VerHelpMsgs
	DB	3,"VOL",fSwitchAllowed+fCheckDrive   ;AC018; P3903
	DW	OFFSET TRANGROUP:VOLUME 	; In TCMD1.ASM
	DW	TRANGROUP:VolHelpMsgs
	DB	2,"CD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$CHDIR 	; In TENV.ASM
	DW	TRANGROUP:CdHelpMsgs
	DB	5,"CHDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$CHDIR 	; In TENV.ASM
	DW	TRANGROUP:CdHelpMsgs
	DB	2,"MD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$MKDIR 	; In TENV.ASM
	DW	TRANGROUP:MdHelpMsgs
	DB	5,"MKDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$MKDIR 	; In TENV.ASM
	DW	TRANGROUP:MdHelpMsgs
	DB	2,"RD",fSwitchAllowed+fCheckDrive    ;AC018; P3903
	DW	OFFSET TRANGROUP:$RMDIR 	; In TENV.ASM
	DW	TRANGROUP:RdHelpMsgs
	DB	5,"RMDIR",fSwitchAllowed+fCheckDrive ;AC018; P3903
	DW	OFFSET TRANGROUP:$RMDIR 	; In TENV.ASM
	DW	TRANGROUP:RdHelpMsgs
	DB	5,"BREAK",fSwitchAllowed        ;AC018; P3903
	DW	OFFSET TRANGROUP:CNTRLC 	; In TUCODE.ASM
	DW	TRANGROUP:BreakHelpMsgs
	DB	6,"VERIFY",fSwitchAllowed       ;AC018; P3903
	DW	OFFSET TRANGROUP:VERIFY 	; In TUCODE.ASM
	DW	TRANGROUP:VerifyHelpMsgs
	DB	3,"SET",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ADD_NAME_TO_ENVIRONMENT; In TENV.ASM
	DW	TRANGROUP:SetHelpMsgs
	DB	6,"PROMPT",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ADD_PROMPT	; In TENV.ASM
	DW	TRANGROUP:PromptHelpMsgs
	DB	4,"PATH",fSwitchAllowed
	DW	OFFSET TRANGROUP:PATH		; In TCMD2.ASM
	DW	TRANGROUP:PathHelpMsgs
	DB	4,"EXIT",0
	DW	OFFSET TRANGROUP:$EXIT		; In TCMD2.ASM
	DW	TRANGROUP:ExitHelpMsgs
	DB	4,"CTTY",fCheckDrive+fSwitchAllowed
	DW	OFFSET TRANGROUP:CTTY		; In TCMD2.ASM
	DW	TRANGROUP:CttyHelpMsgs
	DB	4,"ECHO",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:ECHO		; In TUCODE.ASM
	DW	TRANGROUP:EchoHelpMsgs
	DB	4,"GOTO",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:GOTO		; In TBATCH.ASM
	DW	TRANGROUP:GotoHelpMsgs
	DB	5,"SHIFT",fSwitchAllowed
	DW	OFFSET TRANGROUP:SHIFT		; In TBATCH.ASM
	DW	TRANGROUP:ShiftHelpMsgs
	DB	2,"IF",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:$IF		; In TBATCH.ASM
	DW	TRANGROUP:IfHelpMsgs
	DB	3,"FOR",fSwitchAllowed+fLimitHelp
	DW	OFFSET TRANGROUP:$FOR		; In TBATCH.ASM
	DW	TRANGROUP:ForHelpMsgs
	DB	3,"CLS",0
	DW	OFFSET TRANGROUP:CLS		; In TCMD2.ASM
	DW	TRANGROUP:ClsHelpMsgs
	DB	8,"TRUENAME",fSwitchAllowed+fCheckDrive  ;AN000; P3903 changed
	DW	OFFSET TRANGROUP:TRUENAME	;AN000;
	DW	TRANGROUP:TruenameHelpMsgs
	DB	8,"LOADHIGH",fSwitchAllowed	; M003
	DW	OFFSET TRANGROUP:LoadHigh		; In loadhi.asm ; M003
	DW	TRANGROUP:LoadhighHelpMsgs	; M003
	DB	2,"LH",fSwitchAllowed			; Short form; M003
	DW	OFFSET TRANGROUP:LoadHigh		; In loadhi.asm ; M003
	DW	TRANGROUP:LoadhighHelpMsgs	; M003
	DB	0				; Terminate command table


comext	dB	".COM"
exeext	dB	".EXE"
batext	dB	".BAT"

switch_list	DB	"?VBAPW"                ; flags we can recognize

AttrLtrs        DB      "RHSvDA"                ; attribute letters for DIR

;               Attribute letters in AttrLtrs must appear in the order that
;               attribute bits occur in the attribute byte returned by
;               directory searches, starting with bit 0.
;               The volume label attribute is lowercased to keep it from
;               being matched (by an uppercase comparison).

OrderLtrs       DB      "NEDSG"                 ; sort order letters for DIR

;               Sort order letters stand for file name, extension,
;               date/time, size, and grouped (directory files before others).  
;               DIR routines rely on the specific order of the
;               letters in this list.

comspec_flag    db      0                       ;AN071;



PUBLIC	BatBufLen
BatBufLen   DW	BatLen

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************

;
; COMMON PARSE BLOCKS
;

;
; Indicates no value list for PARSE.
;

NO_VALUES	DW	0			;AN000;  no values

NULL_VALUE_LIST LABEL   BYTE                    ; for unvalidated value
                DB      0                       ; no value lists

;
; PARSE control block for a required file specification (upper cased)
;

FILE_REQUIRED	LABEL	BYTE			;AN000;
		DW	0200H			;AN000;  filespec - required
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional file specification (upper cased)
; or drive number
;

FILE_OPTIONAL	LABEL	BYTE			;AN000;
		DW	0301H			;AN000;  filespec or drive number
						;	 optional
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional file specification (upper cased)
;

FILE_OPTIONAL2  LABEL   BYTE                    ;AN000;
                DW      0201H                   ;AN000;  filespec optional
                DW      1                       ;AN000;  capitalize - file table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE control block for an optional /P switch
;

SLASH_P_SWITCH	LABEL	BYTE			;AN000;
		DW	0			;AN000;  no match flags
		DW	2			;AN000;  capitalize - char table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	1			;AN000;  1 keyword
SLASH_P_SYN	DB	"/P",0                  ;AN000;  /P switch



; PARSE BLOCK FOR BREAK, VERIFY, ECHO

;
; The following parse control block can be used for any command which
; needs only the optional "ON" and "OFF" keywords as operands.  Allows
; the equal sign as an additional delimiter.  Returns verified result
; in PARSE1_OUTPUT.  Currently used for the BREAK, VERIFY, and	ECHO
; internal commands.
;

PARSE_BREAK	LABEL	BYTE			;AN000;
		DW	TRANGROUP:BREAK_PARMS	;AN000;
		DB	0			;AN032; no extra delimiter

BREAK_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:BREAK_CONTROL1;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

BREAK_CONTROL1	LABEL	BYTE			;AN000;
		DW	2001H			;AN000;  string value - optional
		DW	2			;AN000;  capitalize - char table
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:BREAK_VALUES	;AN000;
		DB	0			;AN000;  no keywords

BREAK_VALUES	LABEL	BYTE			;AN000;
		DB	3			;AN000;
		DB	0			;AN000;  no ranges
		DB	0			;AN000;  no numeric values
		DB	2			;AN000;  2 string values
		DB	0			;AN000;  returned if ON
		DW	TRANGROUP:BREAK_ON	;AN000;  point to ON string
		DB	'f'                     ;AN000;  returned if OFF
		DW	TRANGROUP:BREAK_OFF	;AN000;  point to OFF string

BREAK_ON	DB	"ON",0                  ;AN000;
BREAK_OFF	DB	"OFF",0                 ;AN000;

;
; PARSE BLOCK FOR CHCP
;

;
; The following parse control block can be used for any command which
; needs only one optional three digit decimal parameter for operands.
; Returns verified result in PARSE1_OUTPUT.  Currently used for the
; CHCP internal command.
;
CHCP_MINVAL	EQU	100			;AN000;
CHCP_MAXVAL	EQU	999			;AN000;

PARSE_CHCP	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CHCP_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CHCP_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:CHCP_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

CHCP_CONTROL1	LABEL	BYTE			;AN000;
		DW	8001H			;AN000;  numeric value - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:CHCP_VALUES	;AN000;
		DB	0			;AN000;  no keywords

CHCP_VALUES	LABEL	BYTE			;AN000;
		DB	1			;AN000;
		DB	1			;AN000;  1 range
		DB	1			;AN000;  returned if result
		DD	CHCP_MINVAL,CHCP_MAXVAL ;AN000;  minimum & maximum value
		DB	0			;AN000;  no numeric values
		DB	0			;AN000;  no string values


;
; PARSE BLOCK FOR DATE
;

;
; The following parse control block can be used for any command which
; needs only an optional date string as an operand.  Returns unverified
; result in DATE_OUTPUT.  Currently used for the DATE internal command.
;

PARSE_DATE	LABEL	BYTE			;AN000;
		DW	TRANGROUP:DATE_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

DATE_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:DATE_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

DATE_CONTROL1	LABEL	BYTE			;AN000;
		DW	1001H			;AN000;  date - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:DATE_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR TIME
;

;
; The following parse control block can be used for any command which
; needs only an optional time string as an operand.  Returns unverified
; result in TIME_OUTPUT.  Currently used for the TIME internal command.
;

PARSE_TIME	LABEL	BYTE			;AN000;
		DW	TRANGROUP:TIME_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

TIME_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:TIME_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

TIME_CONTROL1	LABEL	BYTE			;AN000;
		DW	0801H			;AN000;  TIME - optional
		DW	0			;AN000;  no function flags
		DW	TRANGROUP:TIME_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords


;
; PARSE BLOCK FOR VOL
;

;
; The following parse control block can be used for any command which
; needs only an optional drive letter as an operand.  Returns unverified
; drive number (one based) in DRIVE_OUTPUT.  Currently used for the VOL
; internal command.
;

PARSE_VOL	LABEL	BYTE			;AN000;
		DW	TRANGROUP:VOL_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

VOL_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:DRIVE_CONTROL1;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

DRIVE_CONTROL1	LABEL	BYTE			;AN000;
		DW	0101H			;AN000;  DRIVE - optional
		DW	1			;AN000;  capitalize - file table
		DW	TRANGROUP:DRIVE_OUTPUT	;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords


;
; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
;

;
; The following parse control block can be used for any command which
; needs only one required file specification as an operand.  Returns a
; pointer to the unverified string in PARSE1_OUTPUT.  Currently used
; for the MKDIR, RMDIR, and TYPE internal commands.
;

PARSE_MRDIR	LABEL	BYTE			;AN000;
		DW	TRANGROUP:MRDIR_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

MRDIR_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR CHDIR, TRUENAME
;

;
; The following parse control block can be used for any command which
; needs only one optional file specification an operand.  Returns a
; pointer to the unverified string in PARSE1_OUTPUT.  Currently used
; for the CHDIR and TRUENAME internal commands.
;

PARSE_CHDIR	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CHDIR_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CHDIR_PARMS	LABEL	BYTE			;AN000;
		DB	0,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_OPTIONAL ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR ERASE
;

;
; The following parse control block is used for the DEL/ERASE internal
; commands.  This command has one required file specification and an
; optional switch (/p) as operands. The verified switch or unverified
; file specification is returned in PARSE1_OUTPUT.
;

PARSE_ERASE	LABEL	BYTE			;AN000;
		DW	TRANGROUP:ERASE_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

ERASE_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	1			;AN000;  1 switch
		DW	TRANGROUP:SLASH_P_SWITCH;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR DIR
;

;
; The following parse control block is used for the DIR internal command.
; This command has one optional file specification and several optional
; switches.  Switches, switch values, and the filespec are returned in 
; PARSE1_OUTPUT.
;
; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
; /w, /-w, /p, and /-p.  The string values for /a and /o are optional,
; do not require colons, and are not checked against a value list.
;
; Switch /h has been removed from the DIR command	;M008
; Switch /? is no longer handled internally		;M008
;
; A list of pointers to all the switch synonyms is provided here to
; help identify which switch has been matched.
;

PARSE_DIR	LABEL	BYTE
		DW	TRANGROUP:DIR_PARMS
		DB	0			; no extra delimiters

DIR_PARMS	LABEL	BYTE
		DB	0,1			; 1 optional positional param
		DW	TRANGROUP:FILE_OPTIONAL2
		DB	2			; 2 kinds of switches
		DW	TRANGROUP:DIR_SW_VALUED
		DW	TRANGROUP:DIR_SW_UNVALUED
		DB	0			; no keywords

DIR_SW_VALUED	LABEL	BYTE
		DW	2001H			  ; optional string value
		DW	21H			  ; optional colon; capitalize 
		DW	TRANGROUP:PARSE1_OUTPUT   ; result buffer
		DW	TRANGROUP:NULL_VALUE_LIST ; don't validate value
		DB	2			  ; 2 'synonyms'
DIR_SW_A	DB	"/A",0
DIR_SW_O	DB	"/O",0

DIR_SW_UNVALUED	LABEL	BYTE
		DW	0			  ; no value
		DW	0			  ; no format functions
		DW	TRANGROUP:PARSE1_OUTPUT   ; result buffer
		DW	TRANGROUP:NO_VALUES
		DB	14			  ; 14 'synonyms'
DIR_SW_NEG_A	DB	"/-A",0
DIR_SW_NEG_O	DB	"/-O",0
DIR_SW_S	DB	"/S",0
DIR_SW_NEG_S	DB	"/-S",0
DIR_SW_B	DB	"/B",0
DIR_SW_NEG_B	DB	"/-B",0
DIR_SW_W	DB	"/W",0
DIR_SW_NEG_W	DB	"/-W",0
DIR_SW_P	DB	"/P",0
DIR_SW_NEG_P	DB	"/-P",0
DIR_SW_L	DB	"/L",0			;M010
DIR_SW_NEG_L	DB	"/-L",0			;M010

;
; Here's a list of pointers to DIR's switch synonyms, for easier
; identification.  Order is critical - DIR routines rely on the
; specific order in this list.  Negated options appear at odd 
; positions in the list, and simple on/off options appear first.
;

DIR_SW_PTRS	LABEL	WORD		; list of ptrs to switch synonyms
		DW	TRANGROUP:DIR_SW_NEG_W
		DW	TRANGROUP:DIR_SW_W
		DW	TRANGROUP:DIR_SW_NEG_P
		DW	TRANGROUP:DIR_SW_P
		DW	TRANGROUP:DIR_SW_NEG_S
		DW	TRANGROUP:DIR_SW_S
		DW	TRANGROUP:DIR_SW_NEG_B
		DW	TRANGROUP:DIR_SW_B
		DW	TRANGROUP:DIR_SW_NEG_L	;M010
		DW	TRANGROUP:DIR_SW_L	;M010
		DW	TRANGROUP:DIR_SW_NEG_O
		DW	TRANGROUP:DIR_SW_O
		DW	TRANGROUP:DIR_SW_NEG_A
		DW	TRANGROUP:DIR_SW_A

;
; PARSE BLOCK FOR RENAME
;

;
; The following parse control block can be used for any command which
; needs only two required file specifications as operands.  Returns
; pointers to the unverified string in PARSE1_OUTPUT.
; Currently used for the RENAME internal command.
;

PARSE_RENAME	LABEL	BYTE			;AN000;
		DW	TRANGROUP:RENAME_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

RENAME_PARMS	LABEL	BYTE			;AN000;
		DB	2,2			;AN000;  2 positional parms
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DW	TRANGROUP:FILE_REQUIRED ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR CTTY
;

;
; The following parse control block can be used for any command which
; needs one required device name as an operand.  Returns a pointer to
; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
; internal command.
;

PARSE_CTTY	LABEL	BYTE			;AN000;
		DW	TRANGROUP:CTTY_PARMS	;AN000;
		DB	0			;AN000;  no extra delimiter

CTTY_PARMS	LABEL	BYTE			;AN000;
		DB	1,1			;AN000;  1 positional parm
		DW	TRANGROUP:CTTY_CONTROL1 ;AN000;
		DB	0			;AN000;  no switches
		DB	0			;AN000;  no keywords

CTTY_CONTROL1	LABEL	BYTE			;AN000;
		DW	2000H			;AN000;  string value - required
		DW	11H			;AN000;  capitalize - file table
						;AN000;  remove colon at end
		DW	TRANGROUP:PARSE1_OUTPUT ;AN000;  result buffer
		DW	TRANGROUP:NO_VALUES	;AN000;
		DB	0			;AN000;  no keywords

;
; PARSE BLOCK FOR VER
;

;
; The following parse control block can be used for any command which
; needs an optional switch "/debug".  Currently used for the VER command.
;

PARSE_VER	LABEL	BYTE
		DW	TRANGROUP:VER_PARMS
		DB	0			; no extra delimiters

VER_PARMS	LABEL	BYTE
		DB	0,0			; no positional parameters
		DB	1			; one switch
		DW	TRANGROUP:SLASH_R
		DB	0			; no keywords

SLASH_R		LABEL	BYTE
		DW	0			; no values
		DW	2			; capitalize by filename table
		DW	TRANGROUP:PARSE1_OUTPUT	; result buffer
		DW	TRANGROUP:NO_VALUES	; no values
		DB	1			; one synonym
SLASH_R_SYN	DB	"/R",0

;
; M003 ; Start of changes for LoadHigh support
;

;
;Parse Control Block for LOADHIGH command
;

Parse_LoadHi	label	byte
	dw	TRANGROUP:LoadHi_Parms	;extended parm table
	db	0			;no extra delimiters

LoadHi_Parms	label	byte
	db	1,1			;min. 1 parm, max. 1 parm
	dw	TRANGROUP:File_Required	;control struc for filename
	db	0			;no switches
	db	0			;no keywords
;
; M003 ; End of changes for LoadHigh support
;

; Table of internal command which have special meaning under NT while at
; command.com prompt. First field is the command name length. Second is the
; command name. Third is only 1 for exit command, rest are all 0. This field
; is returned in al.

    public  NT_INTRNL_CMND

NT_INTRNL_CMND  label byte
    db      4,"EXIT",0
    db      6,"PROMPT",1
    db      3,"SET",1
    db      4,"PATH",1
    db      2,"CD",1
    db      5,"CHDIR",1
    db      0



public TempVarName
TempVarName	db	"TEMP=",0

ifdef	BETA3WARN
%out	Take this out before we ship
public Beta3WarnMsg
Beta3WarnMsg	label	byte

  db      '+--------------------- WARNING! ------------------------+', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|  The license for this pre-release version of MS-DOS   |', 0dh, 0ah
  db      '|  5.0 has expired.  Please replace it with an updated  |', 0dh, 0ah
  db      '|  version of MS-DOS 5.0 immediately.                   |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '|          <Press any key to continue>                  |', 0dh, 0ah
  db      '|                                                       |', 0dh, 0ah
  db      '+-------------------------------------------------------+', 0dh, 0ah
  db	  '$'
endif


TRANDATA	ENDS

TRANCODE	SEGMENT PUBLIC BYTE		;AN000;

.xlist
.xcref

INCLUDE SYSMSG.INC				;AN000;

.list
.cref

ASSUME DS:TRANGROUP,ES:TRANGROUP,CS:TRANGROUP

MSG_UTILNAME <COMMAND>				;AN000; define utility name

MSG_SERVICES <COMT,COMMAND.CLF,COMMAND.CL1,COMMAND.CL2> ;AN000; The transient messages

include msgdcl.inc

TRANCODE	ENDS				;AN000;

TRANDATA	SEGMENT PUBLIC BYTE

TRANDATAEND	LABEL	BYTE

TRANDATA	ENDS				;AN000;

	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tenv.asm ===
page ,132
;	SCCSID = @(#)tenv.asm	4.2 85/08/16
;	SCCSID = @(#)tenv.asm	4.2 85/08/16
TITLE	Part6 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Environment utilities and misc. routines
;
;	Revision History
;	================
;
;	M024	SR	9/5/90	Zero out comspec_flag to fix bug
;				#710 about comspec getting trashed.
;



	INCLUDE comsw.asm

.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include arena.inc
	include comseg.asm
	include comequ.asm
	include doscntry.inc		;an000;
	include	resmsg.equ
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	comdrv:byte
	EXTRN	comspec_end:word
	EXTRN	dbcs_vector_addr:dword	;AN000;
	EXTRN	ENVIRSEG:WORD
	EXTRN	fucase_addr:word	;AC000;
	EXTRN	PutBackDrv:byte
	EXTRN	PutBackComSpec:byte
	EXTRN	RESTDIR:BYTE
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf_ptr:word
	EXTRN	comspec:byte
	EXTRN	comspec_flag:byte
	EXTRN	comspecstr:byte
	EXTRN	ENVERR_PTR:WORD
	EXTRN	PATH_TEXT:byte
	EXTRN	PROMPT_TEXT:byte
	EXTRN	SYNTMES_PTR:WORD
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Arg_Buf:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	USERDIR1:BYTE
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near

	PUBLIC	add_name_to_environment
	PUBLIC	add_prompt
	PUBLIC	delete_path
	PUBLIC	find_name_in_environment
	PUBLIC	find_path
	PUBLIC	find_prompt
	PUBLIC	move_name
	PUBLIC	restudir
	PUBLIC	restudir1
	PUBLIC	scan_double_null
	PUBLIC	scasb2
	PUBLIC	store_char
	PUBLIC	Testkanj		;AN000;  3/3/KK
	PUBLIC	upconv
	PUBLIC	GETENVSIZ

BREAK	<Environment utilities>
ASSUME DS:TRANGROUP

	break	Prompt command
assume	ds:trangroup,es:trangroup

ADD_PROMPT:
	CALL	DELETE_PROMPT			; DELETE ANY EXISTING PROMPT
	CALL	SCAN_DOUBLE_NULL

ADD_PROMPT2:
	PUSH	SI
	CALL	GETARG
	POP	SI
	retz					; PRE SCAN FOR ARGUMENTS
	CALL	MOVE_NAME			; MOVE IN NAME
	CALL	GETARG
	PUSH	SI
	JMP	SHORT ADD_NAME


	break	The SET command
assume	ds:trangroup,es:trangroup

;
; Input: DS:SI points to a CR terminated string
; Output: carry flag is set if no room
;	  otherwise name is added to environment
;

DISP_ENVj:
	jmp	DISP_ENV

ADD_NAME_TO_ENVIRONMENT:
	CALL	GETARG
	JZ	DISP_ENVj
;
; check if line contains exactly one equals sign
;
	XOR	BX,BX				;= COUNT IS 0
	PUSH	SI				;SAVE POINTER TO BEGINNING OF LINE

EQLP:
	LODSB					;GET A CHAR
	CMP	AL,13				;IF CR WE'RE ALL DONE
	JZ	QUEQ
	CMP	AL,'='                          ;LOOK FOR = SIGN
	JNZ	EQLP				;NOT THERE, GET NEXT CHAR
	INC	BL				;OTHERWISE INCREMENT EQ COUNT
	CMP	BYTE PTR [SI],13		;LOOK FOR CR FOLLOWING = SIGN
	JNZ	EQLP
	INC	BH				;SET BH=1 MEANS NO PARAMETERS
	JMP	EQLP				;AND LOOK FOR MORE

QUEQ:
	POP	SI				;RESTORE BEGINNING OF LINE
	DEC	BL				;ZERO FLAG MEANS ONLY ONE EQ
	JZ	ONEQ				;GOOD LINE
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	JMP	CERROR

ONEQ:
	PUSH	BX
	CALL	DELETE_NAME_IN_ENVIRONMENT
	POP	BX
	DEC	BH
	retz

	CALL	SCAN_DOUBLE_NULL
	mov	bx,di				; Save ptr to beginning of env var name
	CALL	MOVE_NAME
	push	si
	xchg	bx,di				; Switch ptrs to beginning and end of
						;  env var name
;
; We want to special-case COMSPEC.  This is to reduce the amount of code
; necessary in the resident for re-reading the transient.  Let's look for
; COMSPEC=
;
	mov	comspec_flag,0			; clear flag ; M024
	mov	si,offset trangroup:comspecstr	; Load ptr to string "COMSPEC"
	mov	cx,4				; If the new env var is comspec, set
	repz	cmpsw				;  the comspec_flag
;
; Zero set => exact match
;
	jnz	not_comspec
	inc	comspec_flag			; comspec is changing ; M024

not_comspec:
	mov	di,bx				; Load ptr to end of env var name

ADD_NAME:					; Add the value of the new env var
	pop	si				;  to the environment.
	push	si

add_name1:
	LODSB
	CMP	AL,13
	jz	add_name_ret
	CALL	STORE_CHAR
	JMP	ADD_NAME1

add_name_ret:
	pop	si
	cmp	comspec_flag,0			; If the new env var is comspec,
	retz					;  copy the value into the
;
; We have changed the COMSPEC variable.  We need to update the resident
; pieces necessary to reread in the info.  First, skip all delimiters
;
	invoke	ScanOff
	mov	es,[resseg]			;  comspec var in the resident
	assume	es:resgroup
;
; Make sure that the printer knows where the beginning of the string is
;
	mov	di,offset resgroup:comspec
	mov	bx,di
;
; Generate drive letter for display
;
	xor	ax,ax				;g assume no drive first
	mov	comdrv,al			;g
	push	ax				;AN000;  3/3/KK
	mov	al,[si] 			;AN000;  3/3/KK
	call	testkanj			;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	jnz	GotDrive
	cmp	byte ptr [si+1],':'             ; drive specified?
	jnz	GotDrive
	mov	al,[si] 			; get his specified drive
	call	UpConv				; convert to uppercase
	sub	al,'A'                          ; convert to 0-based
	add	di,2
	inc	al				; convert to 1-based number
	mov	comdrv,al
;
; Stick the drive letter in the prompt message.  Nothing special needs to be
; done here..
;

	add	al,'A'-1

GotDrive:					;g
	mov	PutBackComSpec.SubstPtr,di	;g point to beginning of name after drive
	mov	es:PutBackDrv,al
;
; Copy chars until delim
;

	mov	di,bx

copy_comspec:
	lodsb
	invoke	Delim
	jz	CopyDone
	cmp	al,13
	jz	CopyDone
	stosb
	jmp	short copy_comspec

CopyDone:
	xor	al,al				; Null terminate the string and quit
	stosb
	mov	comspec_flag,0
	dec	di
	mov	comspec_end,di

	ret

DISP_ENV:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	DS,[ENVIRSEG]
ASSUME	DS:NOTHING
	XOR	SI,SI

PENVLP:
	CMP	BYTE PTR [SI],0
	retz
	mov	di,offset trangroup:arg_buf

PENVLP2:
	LODSB
	stosb
	OR	AL,AL
	JNZ	PENVLP2
	mov	dx,offset trangroup:arg_buf_ptr
	push	ds
	push	es
	pop	ds
	invoke	printf_crlf
	pop	ds
	JMP	PENVLP

ASSUME	DS:TRANGROUP

DELETE_PATH:
	MOV	SI,OFFSET TRANGROUP:PATH_TEXT
	JMP	SHORT DELETE_NAME_IN_environment

DELETE_PROMPT:
	MOV	SI,OFFSET TRANGROUP:PROMPT_TEXT

DELETE_NAME_IN_environment:
;
; Input: DS:SI points to a "=" terminated string
; Output: carry flag is set if name not found
;	  otherwise name is deleted
;
	PUSH	SI
	PUSH	DS
	CALL	FIND				; ES:DI POINTS TO NAME
	JC	DEL1
	MOV	SI,DI				; SAVE IT
	CALL	SCASB2				; SCAN FOR THE NUL
	XCHG	SI,DI
;SR;
; If we have only one env string, then the double null is lost when the last
;string is deleted and we have an invalid empty environment with only a 
;single null. To avoid this, we will look for the double null case and then
;move an extra null char.
; Bugbug: The only possible problem is that the last pathstring 
;will be followed by a triple null. Is this really a problem?
;
	cmp	byte ptr es:[si],0			;null char?
	jnz	not_dnull			;no, we are at a double null
	dec	si				;point at the double null
not_dnull:

	CALL	GETENVSIZ
	SUB	CX,SI
	PUSH	ES
	POP	DS				; ES:DI POINTS TO NAME, DS:SI POINTS TO NEXT NAME
	REP	MOVSB				; DELETE THE NAME

DEL1:
	POP	DS
	POP	SI
	return

FIND_PATH:
	MOV	SI,OFFSET TRANGROUP:PATH_TEXT
	JMP	SHORT FIND_NAME_IN_environment

FIND_PROMPT:
	MOV	SI,OFFSET TRANGROUP:PROMPT_TEXT

FIND_NAME_IN_environment:
;
; Input: DS:SI points to a "=" terminated string
; Output: ES:DI points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format
;
	CALL	FIND				; FIND THE NAME
	retc					; CARRY MEANS NOT FOUND
	JMP	SCASB1				; SCAN FOR = SIGN
;
; On return of FIND1, ES:DI points to beginning of name
;
FIND:
	CLD
	CALL	COUNT0				; CX = LENGTH OF NAME
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	ES,[ENVIRSEG]
ASSUME	ES:NOTHING
	XOR	DI,DI

FIND1:
	PUSH	CX
	PUSH	SI
	PUSH	DI

FIND11:
	LODSB
	CALL	TESTKANJ
	JZ	NOTKANJ3
	DEC	SI
	LODSW
	INC	DI
	INC	DI
	CMP	AX,ES:[DI-2]
	JNZ	FIND12
	DEC	CX
	LOOP	FIND11
	JMP	SHORT FIND12

NOTKANJ3:
	CALL	UPCONV
	INC	DI
	CMP	AL,ES:[DI-1]
	JNZ	FIND12
	LOOP	FIND11

FIND12:
	POP	DI
	POP	SI
	POP	CX
	retz
	PUSH	CX
	CALL	SCASB2				; SCAN FOR A NUL
	POP	CX
	CMP	BYTE PTR ES:[DI],0
	JNZ	FIND1
	STC					; INDICATE NOT FOUND
	return

COUNT0:
	PUSH	DS
	POP	ES
	MOV	DI,SI

COUNT1:
	PUSH	DI				; COUNT NUMBER OF CHARS UNTIL "="
	CALL	SCASB1
	JMP	SHORT COUNTX

COUNT2:
	PUSH	DI				; COUNT NUMBER OF CHARS UNTIL NUL
	CALL	SCASB2

COUNTX:
	POP	CX
	SUB	DI,CX
	XCHG	DI,CX
	return

MOVE_NAME:
	CMP	BYTE PTR DS:[SI],13
	retz
	LODSB

;;;;	IFDEF	DBCS			3/3/KK
	CALL	TESTKANJ
	JZ	NOTKANJ1
	CALL	STORE_CHAR
	LODSB
	CALL	STORE_CHAR
	JMP	SHORT MOVE_NAME

NOTKANJ1:
;;;;	ENDIF				3/3/KK

	CALL	UPCONV
	CALL	STORE_CHAR
	CMP	AL,'='
	JNZ	MOVE_NAME
	return

GETARG:
	MOV	SI,80H
	LODSB
	OR	AL,AL
	retz
	invoke	SCANOFF
	CMP	AL,13
	return

;
; Point ES:DI to the final NULL string.  Note that in an empty environment,
; there is NO double NULL, merely a string that is empty.
;
SCAN_DOUBLE_NULL:
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	ES,[ENVIRSEG]
ASSUME	ES:NOTHING
	XOR	DI,DI
;
; Top cycle-point.  If the string here is empty, then we are done
;
SDN1:
	cmp	byte ptr es:[di],0		; nul string?
	retz					; yep, all done
	CALL	SCASB2
	JMP	SDN1

SCASB1:
	MOV	AL,'='                          ; SCAN FOR AN =
	JMP	SHORT SCASBX
SCASB2:
	XOR	AL,AL				; SCAN FOR A NUL
SCASBX:
        MOV     CX,1000H
	REPNZ	SCASB
	return
;Bugbug: This is Kanji stuff - put it in conditionals

TESTKANJ:
	push	ds				;AN000;  3/3/KK
	push	si				;AN000;  3/3/KK
	push	ax				;AN000;  3/3/KK
	mov	ds,cs:[resseg]			;AN000;  Get resident segment
	assume	ds:resgroup			;AN000;
	lds	si,dbcs_vector_addr		;AN000;  get DBCS vector
ktlop:						;AN000;  3/3/KK
	cmp	word ptr ds:[si],0		;AN000;  end of Table	3/3/KK
	je	notlead 			;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	push	ax				;AN000;  3/3/KK
	cmp	al, byte ptr ds:[si]		;AN000;  3/3/KK
	jb	notlead 			;AN000;  3/3/KK
	inc	si				;AN000;  3/3/KK
	cmp	al, byte ptr ds:[si]		;AN000;  3/3/KK
	jbe	islead				;AN000;  3/3/KK
	inc	si				;AN000;  3/3/KK
	jmp	short ktlop			;AN000;  try another range ; 3/3/KK
Notlead:					;AN000;  3/3/KK
	xor	ax,ax				;AN000;  set zero 3/3/KK
	jmp	short ktret			;AN000;  3/3/KK
Islead: 					;AN000;  3/3/KK
	xor	ax,ax				;AN000;  reset zero  3/3/KK
	inc	ax				;AN000;  3/3/KK
ktret:						;AN000;  3/3/KK
	pop	ax				;AN000;  3/3/KK
	pop	si				;AN000;  3/3/KK
	pop	ds				;AN000;  3/3/KK
	return					;AN000;  3/3/KK
;-------------------------------------		;3/3/KK


; ****************************************************************
; *
; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************

assume	ds:trangroup				;AN000;

upconv	proc	near				;AN000;

	cmp	al,80h				;AN000;  see if char is > ascii 128
	jb	oth_fucase			;AN000;  no - upper case math
	sub	al,80h				;AN000;  only upper 128 chars in table
	push	ds				;AN000;
	push	bx				;AN000;
	mov	ds,[resseg]			;AN000;  get resident data segment
assume	ds:resgroup				;AN000;
	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
	add	bx,2				;AN000;  skip over first word
	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
	pop	bx				;AN000;
	pop	ds				;AN000;
assume	ds:trangroup				;AN000;
	jmp	short upconv_end		;AN000;  we finished - exit

oth_fucase:					;AN000;
	cmp	al,small_a			;AC000; if between "a" and "z",
	jb	upconv_end			;AC000;     subtract 20h to get
	cmp	al,small_z			;AC000;    upper case equivalent.
	ja	upconv_end			;AC000;
	sub	al,20h				;AC000; Change lower-case to upper

upconv_end:					;AN000;
	ret

upconv	endp					;AN000;


;
; STORE A CHAR IN environment, GROWING IT IF NECESSARY
;
STORE_CHAR:
	PUSH	CX
	PUSH	BX
	PUSH	ES				;AN056;
	PUSH	DS				;AN056; Save local DS
	MOV	DS,[RESSEG]			;AN056; Get resident segment
	ASSUME	DS:RESGROUP			;AN056;
	MOV	ES,[ENVIRSEG]			;AN056; Get environment segment
	ASSUME	ES:NOTHING			;AN056;
	POP	DS				;AN056; Get local segment back
	ASSUME	DS:TRANGROUP			;AN056;
	CALL	GETENVSIZ
	MOV	BX,CX
	SUB	BX,2				; SAVE ROOM FOR DOUBLE NULL
	CMP	DI,BX
	JB	STORE1

	PUSH	AX
	PUSH	CX
	PUSH	BX				; Save Size of environment
	invoke	FREE_TPA
	POP	BX
	ADD	BX,2				; Recover true environment size

	CMP	BX, 8000H			; Don't let environment grow > 32K
	JB	ENVSIZ_OK
BAD_ENV_SIZE:					;AN056;
	STC
	JMP	SHORT ENVNOSET
ENVSIZ_OK:

	MOV	CL,4
	SHR	BX,CL				; Convert back to paragraphs
	INC	BX				; Try to grow environment by one para
	MOV	CX,ES				;AN056; Get environment segment
	ADD	CX,BX				;AN056; Add in size of environment
	ADD	CX,020H 			;AN056; Add in some TPA
	MOV	AX,CS				;AN056; Get the transient segment
	CMP	CX,AX				;AN056; Are we hitting the transient?
	JNB	BAD_ENV_SIZE			;AN056; Yes - don't do it!!!
	MOV	AH,SETBLOCK
	INT	21h
ENVNOSET:
	PUSHF
	PUSH	ES
	MOV	ES,[RESSEG]
	invoke	ALLOC_TPA
	POP	ES
	POPF
	POP	CX
	POP	AX
	JNC	STORE1
	POP	ES				;AN056;
	MOV	DX,OFFSET TRANGROUP:ENVERR_ptr
	JMP	CERROR
STORE1:
	STOSB
	MOV	WORD PTR ES:[DI],0		; NULL IS AT END
	POP	ES				;AN056;
	POP	BX
	POP	CX
	return

GETENVSIZ:
;Get size of environment in bytes, rounded up to paragraph boundry
;ES has environment segment
;Size returned in CX, all other registers preserved

	PUSH	ES
	PUSH	AX
	MOV	AX,ES
	DEC	AX				;Point at arena
	MOV	ES,AX
	MOV	AX,ES:[arena_size]
	MOV	CL,4
	SHL	AX,CL				;Convert to bytes
	MOV	CX,AX
	POP	AX
	POP	ES
	return


ASSUME	DS:TRANGROUP


RESTUDIR1:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	CMP	[RESTDIR],0
	POP	DS
ASSUME	DS:TRANGROUP
	retz

RESTUDIR:
	MOV	DX,OFFSET TRANGROUP:USERDIR1
	MOV	AH,CHDIR
	INT	21h			; Restore users DIR
	XOR	AL,AL
	invoke	SETREST
RET56:
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tmisc1.asm ===
page ,132
;	SCCSID = @(#)tmisc1.asm 4.1 85/09/22
;	SCCSID = @(#)tmisc1.asm 4.1 85/09/22
TITLE	Part7 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;	M003	SR	07/16/90	Made Execute public to jump to it for
;				LoadHigh support
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;


;	More misc routines

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include comseg.asm
	include comequ.asm
.list
.cref



CODERES 	SEGMENT PUBLIC BYTE	;AC000;
;;	EXTRN	RSTACK:BYTE
CodeRes 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	CALL_FLAG:BYTE
	EXTRN	EchoFlag:BYTE
	EXTRN	EXEC_BLOCK:BYTE
	EXTRN	EXTCOM:BYTE
	EXTRN	LenMsgOrPathBuf:ABS
	EXTRN	PIPEFLAG:BYTE
	EXTRN	PIPEPTR:WORD
	EXTRN	PIPESTR:BYTE
	EXTRN	RESTDIR:BYTE
	EXTRN	RE_OUT_APP:BYTE
	EXTRN	RE_OUTSTR:BYTE
	EXTRN	SAFEPATHBUFFER:BYTE

	extrn	RStack:word

ifdef	BETA3WARN
	%out	Take this out before we ship
	EXTRN	Beta3Warned:byte
	EXTRN	TrnSeg:word
endif


DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADDRV_PTR:WORD
	EXTRN	BADNAM_PTR:WORD
	EXTRN	COMTAB:BYTE		;AC000;
	EXTRN	extend_buf_ptr:word	;AN000;
	EXTRN	msg_disp_class:byte	;AN000;

ifdef	BETA3WARN
	%out	Take this out before we ship
	EXTRN	Beta3WarnMsg:byte
endif

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg:byte		; the arg structure!
	EXTRN	ALLSWITCH:WORD
	EXTRN	APPEND_EXEC:BYTE	;AN041;
	EXTRN	CHKDRV:BYTE
	EXTRN	COMBUF:BYTE
	EXTRN	COMSW:WORD
	EXTRN	EXECPATH:BYTE
	EXTRN	EXEC_ADDR:DWORD
	EXTRN	FILTYP:BYTE
	EXTRN	IDLEN:BYTE
	EXTRN	KPARSE:BYTE		;AC000;
	EXTRN	PARM1:BYTE
	EXTRN	PARM2:BYTE
	EXTRN	PathPos:word
	EXTRN	RESSEG:WORD
	EXTRN	RE_INSTR:BYTE
	EXTRN	SPECDRV:BYTE
	EXTRN	SWITCHAR:BYTE
	EXTRN	switch_list:byte
        EXTRN   TRAN_TPA:WORD

        EXTRN   EXECPATH_SIZE:WORD
	EXTRN	EXECEXT_TYPE:WORD
	IF  IBM
	EXTRN	ROM_CALL:BYTE
	EXTRN	ROM_CS:WORD
	EXTRN	ROM_IP:WORD
	ENDIF

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	APPEND_PARSE:NEAR	;AN010;
	EXTRN	BATCOM:NEAR
	EXTRN	DOCOM1:NEAR
	EXTRN	PIPEERRSYN:NEAR
	EXTRN	TCOMMAND:NEAR

	IF	IBM
	EXTRN	ROM_EXEC:NEAR
	EXTRN	ROM_SCAN:NEAR
	ENDIF

	PUBLIC	CERROR
	PUBLIC	DRVBAD
	PUBLIC	EXTERNAL
	PUBLIC	FNDCOM
	PUBLIC	PRESCAN
	PUBLIC	SWITCH

	public	Lh_Execute			; M051


ASSUME	DS:TRANGROUP

;---------------------------
; We can get rid of this switch processing code if we can take
; care of the remaining two calls to switch, later in the file.
; However, I have not checked whether or not any other files use
; switch -- after all, it IS public!
;---------------------------

SWCOUNT EQU	6				; Length of switch_list

RETSW:
	XCHG	AX,BX				; Put switches in AX
	return

SWITCH:
	XOR	BX,BX				; Initialize - no switches set
SWLOOP:
	INVOKE	SCANOFF 			; Skip any delimiters
	CMP	AL,[SWITCHAR]			; Is it a switch specifier?
	JNZ	RETSW				; No -- we're finished
	OR	BX,fSwitch			; Indicate there is a switch specified
	INC	SI				; Skip over the switch character
	INVOKE	SCANOFF
	CMP	AL,0DH
	JZ	RETSW				; Oops
	INC	SI
; Convert lower case input to upper case
	INVOKE	UPCONV
	MOV	DI,OFFSET TRANGROUP:switch_list
	MOV	CX,SWCOUNT
	REPNE	SCASB				; Look for matching switch
	JNZ	BADSW
	MOV	AX,1
	SHL	AX,CL				; Set a bit for the switch
	OR	BX,AX
	JMP	SHORT SWLOOP

BADSW:
	JMP	SHORT SWLOOP

DRVBAD:
	MOV	DX,OFFSET TRANGROUP:BADDRV_ptr
	JMP	CERROR

externalj:
	jmp	EXTERNAL

fndcom: 					; search the internal command table
    OR	    AL,AL				; Get real length of first arg
    jz	    externalj				; If 0, it must begin with "\" so has
						;  to be external.
; barryf code starts here

ifndef NEC_98
	IF	IBM
	call	test_append			; see if APPEND installed
	je	contcom 			; not loaded

append_internal:
	mov	cl,TRANGROUP:IDLEN
	mov	ch,0
	mov	pathpos,cx
	inc	append_exec			;AN041; set APPEND to ON

	invoke	ioset				; re-direct the o'l io

	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set invoke function
	mov	di,offset TRANGROUP:APPEND_PARSE;AN010; Get the entry point for PARSE for APPEND
	mov	AX,0AE01H
	int	2FH				; execute command
	cmp	TRANGROUP:IDLEN,0		; execute requested
;;	je	Cmd_done
	jne	contcom
	jmp	Cmd_done

contcom:					; continue with internal scan
	ENDIF
else    ;NEC_98
	call	test_append			; see if APPEND installed
	je	contcom 			; not loaded

append_internal:
	mov	cl,TRANGROUP:IDLEN
	mov	ch,0
	mov	pathpos,cx
	inc	append_exec			;AN041; set APPEND to ON

	invoke	ioset				; re-direct the o'l io

	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set invoke function
	mov	di,offset TRANGROUP:APPEND_PARSE;AN010; Get the entry point for PARSE for APPEND
	mov	AX,0AE01H
	int	2FH				; execute command
	cmp	TRANGROUP:IDLEN,0		; execute requested
;;	je	Cmd_done
	jne	contcom
	jmp	Cmd_done

contcom:					; continue with internal scan
endif   ;NEC_98

; barryf code ends here

    mov     DI, OFFSET TRANGROUP:COMTAB
    XOR     CX,CX

findcom:
    mov     SI, offset TRANGROUP:IDLEN+1	; pointer to command argument
    mov     CL, [DI]				; load length of internal command
    inc     di					; advance past length
    jcxz    externalj				; if it's zero, we're out of internals
    cmp     CL, IDLEN				; that of the command argument
    jnz     abcd				; lengths not equal ==> strings not eq
    MOV     PathPos,CX				; store length of command
    repz    cmpsb

abcd:
    lahf					; save the good ol' flags
    add     DI, CX				; skip over remaining internal, if any
    mov     AL, BYTE PTR [DI]			; load drive-check indicator byte (DCIB)
    mov     [CHKDRV], AL			; save command flag byte in chkdrv
    inc     DI					; increment DI (OK, OK, I'll stop)
    mov     BX, WORD PTR [DI]			; load internal command address
    inc     DI					; skip over the puppy
    inc     DI
    mov     DX, WORD PTR [DI]			; load ptr to help msg #s
    inc     DI
    inc     DI
    sahf					; remember those flags?
    jnz     findcom				; well, if all the cmps worked...
;
; All messages get redirected.
;
    cmp     append_exec,0			;AN041; APPEND just executed?
    jnz     dont_set_io 			;AN041; Yes - this junk is already set
    invoke  ioset				; re-direct the ol' i/o

dont_set_io:					;AN041;
;
; Check for /?.  Certain commands, flagged fLimitHelp,
; respond to /? only if it is the only command-line argument.
;
    mov     ax,[COMSW]				; AX = switches after command
    or      ax,[ALLSWITCH]			; AX = all switches
    and     ax,SwitchQues
    jz      drive_check				; /? not in command line

    test    [CHKDRV],fLimitHelp
    jz      do_help				; /? allowed in combination
;
; Make sure /? is the only argument on the command line.
;
    cmp     [arg.argvcnt],2
    jne     drive_check				; /? not only arg - ignore
;
; Note:  this is all the check we need, even against things like /??.
; Our argv parser breaks /?? into two args, /? and ?.
;

do_help:

; DX = ptr to word list of msg #s, terminated by zero word

    mov     si,dx				; SI = ptr to list of msg #s
    mov     ax,NO_SUBST				; AL = no subst's code
    push    ax					; build subst block on stack

next_help_msg:
    lodsw					; AX = help msg # or zero
    or      ax,ax
    jz      help_done
    push    ax					; SS:SP = ptr to subst block
						;  (msg # and no_subst byte)
; We assume DS = SS.

    mov     dx,sp				; DS:DX = ptr to subst block
    invoke  Std_PrintF				; display help message
    pop     ax					; remove msg # from stack
    jmp     next_help_msg

help_done:
    pop     ax					; clean up stack
    jmp     TCommand

drive_check:
    test    [CHKDRV], fCheckDrive		; did we wanna check those drives?
    jz	    nocheck
    mov     AL, [PARM1] 			; parse_file_descriptor results tell
    or	    AL, [PARM2] 			; us whether those drives were OK
    cmp     AL, -1
    jnz     nocheck
    jmp     drvbad


;
; The user may have omitted the space between the command and its arguments.
; We need to copy the remainder of the user's command line into the buffer.
; Note that thisdoes not mess up the arg structure; it points into COMBUF not
; into the command line at 80.
;
nocheck:
    call    cmd_copy

switcheck:
    test    [CHKDRV], fSwitchAllowed		; Does the command take switches
    jnz     realwork				; Yes, process the command
    call    noswit				; No, check to see if any switches
    jnz     realwork				; None, process the command
    mov     msg_disp_class,parse_msg_class	;AN000; set up parse error msg class
    MOV     DX,OFFSET TranGroup:Extend_Buf_ptr	;AC000; get extended message pointer
    mov     Extend_Buf_ptr,BadSwt_ptr		;AN000; get "Invalid switch" message number
    jmp     CERROR				; Print error and chill out...
realwork:
    call    BX					; do some real work, at last

; See if we're in a batch CALL command. If we are, reprocess the command line,
; otherwise, go get another command.

Cmd_done:
    push    cs					; g  restore data segment
    pop     ds					; g
    push    ds					; g  save data segment
    mov     ds,[resseg] 			; g  get segment containing call flag
    ASSUME  ds:resgroup
    cmp     call_flag, call_in_progress 	; G  Is a call in progress?
    mov     call_flag, 0			; G  Either way, reset flag
    pop     ds					; g  get data segment back
    jz	    incall				; G
    jmp     tcommand				; chill out...

incall:
    JMP     DOCOM1

noswit:
    push    di					; Save di
    mov     di,81h				; di = ptr to command args
    mov     si,80h				; Get address of length of command args
    lodsb					; Load length
    mov     cl,al				; Move length to cl
    xor     ch,ch				; Zero ch
    mov     al,[SWITCHAR]			; al = switch character
    cmp     al,0				; Turn off ZF
    repnz   scasb				; Scan for a switch character and return
    pop     di					;  with ZF set if one was found
    ret

EXTERNAL:

ifndef NEC_98
IF IBM
	call	test_append			; check to see if append installed
	je	not_barryf			; no - truly external command
	jmp	append_internal 		; yes - go to Barryf code

not_barryf:

ENDIF
else    ;NEC_98
	call	test_append			; check to see if append installed
	je	not_barryf			; no - truly external command
	jmp	append_internal 		; yes - go to Barryf code

not_barryf:

endif   ;NEC_98

	MOV	[FILTYP],0
	MOV	DL,[SPECDRV]
	MOV	[IDLEN],DL
IF IBM
	MOV	[ROM_CALL],0
	PUSH	DX
	MOV	DX,OFFSET TRANGROUP:IDLEN
	CALL	ROM_SCAN
	POP	DX
	JNC	DO_SCAN
	INC	[ROM_CALL]
	JMP	short PostSave
DO_SCAN:
ENDIF
IF IBM
PostSave:
ENDIF

        ;
        ; when ntvdm execs via GetNextVdmCommand, execpath is already
        ; fully qualified application name. We know this because the
        ; vdminfo is filled
        ;
	; Note that EXECPATH_SIZE is used only once(the one we got it from
	; CMDGETNEXTCMD bop). And that is why we reset it everytime after
	; we have accessed it. For other executables, we do the regular
	; search(processing a batch file, for example).
	;
	; Two pieces of information we got from 32bits:
	; (1). the application full path name(in EXECPATH)
	; (2). the application file extention type(in EXECEXT_TYPE)
	;      EXECEXT_TYPE	2	-> .BAT
	;			4	-> .EXE
	;			8	-> .COM
	;			>8	-> unknown
	; for unknown extention type, we simply launch it because
	; (1). DOS doesn't impose any extention on program file.
	; (2). If we ever get here, we are sure that the program file
	;      is a valid DOS executable(otherwise, CreateProcess would
	;      have failed and we won't have any file to execute).
	;
	;

	xor	ax, ax
	xchg	ax, [EXECPATH_SIZE]		;get and set
	or	ax, ax				;do we have appname already?
	mov	ax, [EXECEXT_TYPE]		;
	jnz	execute_with_type		;yes, No search

        MOV     DI,OFFSET TRANGROUP:EXECPATH
	MOV	BYTE PTR [DI],0 		; Initialize to current directory
IF IBM
	CMP	[ROM_CALL],0
	JNZ	NeoExecute
ENDIF
	invoke	path_search			; find the mother (result in execpath)

execute_with_type:
	or	AX, AX				; did we find anything?
	je	badcomj45			; null means no (sob)
	cmp	AX, 04H 			; 04H and 08H are .exe and .com
                                                ; sixteen-bit machine ought
	jnl	execute 			; to be able to handle a SIXTEEN-BIT
						; DISPLACEMENT!!
	jmp	batcom				; 02H is .bat
BADCOMJ45:
ifdef	BETA3WARN
	JMP	BADCOM
else
	JMP	short BADCOM
endif

ASSUME	DS:TRANGROUP,ES:TRANGROUP

EXECUTE:
NeoExecute:
	invoke	IOSET
;M051
; Previously LoadHigh was jumping to the execute label above. This was wrong
;because IOSET was getting invoked twice resulting in 2 sets of redirections.
;After a close, this would still leave one open active resulting in sharing
;errors on subsequent opens of the redirected file.
;
Lh_Execute:				;M051

	MOV	ES,[TRAN_TPA]
	MOV	AH,DEALLOC
	INT	21h			; Now running in "free" space
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	INC	[EXTCOM]		; Indicate external command
	MOV	[RESTDIR],0		; Since USERDIR1 is in transient, insure
					;  this flag value for re-entry to COMMAND
	MOV	SI,OFFSET TRANGROUP:EXECPATH
	MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
	MOV	CX,LenMsgOrPathBuf
	CLD
LE_copy_loop:
	lodsb
	stosb
	cmp	al, 0
	je	LE_copy_done
	loop	LE_copy_loop
;; the program name is too long, terminate it with
;; null character. The Exec call will fail and we will print out error message
;; see command1.asm
	mov	byte ptr es:[di - 1], 0
LE_copy_done:

        MOV     DI,FCB
	MOV	SI,DI
	MOV	CX,052H 		; moving (100h-5Ch)/2 = 80h-2Eh
	REP	MOVSW			; Transfer parameters to resident header
	MOV	DX,OFFSET RESGROUP:SAFEPATHBUFFER
	PUSH	ES
	POP	DS
	ASSUME	DS:RESGROUP
	MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
	MOV	AX,EXEC SHL 8
IF IBM
	TEST	[ROM_CALL],-1
	JZ	OK_EXEC
	JMP	ROM_EXEC
OK_EXEC:
ENDIF
;
; we are now running in free space.  anything we do from here on may get
; trashed.  Move the stack (also in free space) to allocated space because
; since EXEC restores the stack, somebody may trash what is on the stack.
;
	MOV	CX,ES
	MOV	SS,CX
	MOV	SP,OFFSET DATARES:RStack

ifdef	BETA3WARN
	%out	Take this out before we ship

	cmp	Beta3Warned, 0
	jne	NoWarning
	mov	Beta3Warned, 0ffh
	push	ax
	push	cx
	push	dx
	push	ds

	mov	ah, 2ah				; get date
	int	21h
	cmp	cx, 1991
	jb	nwx
	ja	bwarn

	cmp	dh, 4
	jb	nwx
bwarn:
	mov	ds, trnseg
	assume	ds:trangroup
	mov	dx, offset trangroup:Beta3WarnMsg
	mov	ah, 9
	int	21h

;	wait till a key is hit

@@:
	mov	ah, 6				; console I/O
	mov	dl, 0ffh			; Read
	int	21h
	jz	@b
nwx:
	pop	ds
	assume	ds:resgroup
	pop	dx
	pop	cx
	pop	ax
NoWarning:
endif
	JMP	[EXEC_ADDR]			; Jmp to the EXEC in the resident

	ASSUME	DS:TRANGROUP
BADCOM:
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET TRANGROUP:BADNAM_ptr

CERROR:
	INVOKE	std_eprintf
	JMP	TCOMMAND

;
; Prescan converts the input buffer into a canonicalized form.	All
; redirections and pipes are removed.
;
PRESCAN:					; Cook the input buffer

ASSUME	DS:TRANGROUP,ES:TRANGROUP

	XOR	CX,CX
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	MOV	DI,SI

CountQuotes:
	LODSB					; get a byte
	CMP	AL,22h				; is it a quote?
	JNZ	CountEnd			; no, try for end of road
	INC	CH				; bump count
	JMP	CountQuotes			; go get next char

CountEnd:
	CMP	AL,13				; end of road?
	JNZ	CountQuotes			; no, go back for next char

;;;;	IFDEF	DBCS		3/3/KK
	PUSH	CX				; save count
	MOV	SI,DI				; get back beginning of buffer

KanjiScan:
	LODSB					; get a byte
	INVOKE	TestKanj			; is it a leadin byte
	JZ	KanjiQuote			; no, check for quotes
ifdef NEC_98
if BUGFIX
        cmp     byte ptr [si],' '
        jb      kanjiQuote
endif
endif   ;NEC_98
	MOV	AH,AL				; save leadin
	LODSB					; get trailing byte
	CMP	AX,DB_SPACE			; is it Kanji space
	JNZ	KanjiScan			; no, go get next
	MOV	[SI-2],2020h			; replace with spaces
	JMP	KanjiScan			; go get next char

KanjiQuote:
	CMP	AL,22h				; beginning of quoted string
	JNZ	KanjiEnd			; no, check for end
	DEC	CH				; drop count
	JZ	KanjiScan			; if count is zero, no quoting

KanjiQuoteLoop:
	LODSB					; get next byte
	CMP	AL,22h				; is it another quote
	JNZ	KanjiQuoteLoop			; no, get another
	DEC	CH				; yes, drop count
	JMP	KanjiScan			; go get next char

KanjiEnd:
	CMP	AL,13				; end of line character?
	JNZ	KanjiScan			; go back to beginning
	POP	CX				; get back original count
;;;;	ENDIF		3/3/KK

	MOV	SI,DI				; restore pointer to begining

PRESCANLP:
	LODSB

;;;;	IFDEF	DBCS		3/3/KK
	INVOKE	TESTKANJ
	JZ	NOTKANJ6
ifdef NEC_98
if BUGFIX
        cmp     byte ptr [si],' '
        jb      NOTKANJ6
endif
endif   ;NEC_98
	MOV	[DI],AL
	INC	DI				; fake STOSB into DS
	LODSB					; grab second byte
	MOV	[DI],AL 			; fake stosb into DS
	INC	DI
	INC	CL
	INC	CL
	JMP	PRESCANLP

NOTKANJ6:
;;;;	ENDIF			3/3/KK

	CMP	AL,'"'                          ; " character
	JNZ	TRYGREATER
	DEC	CH
	JZ	TRYGREATER

QLOOP:
	MOV	[DI],AL
	INC	DI
	INC	CL
	LODSB
	CMP	AL,'"'                          ; " character
	JNZ	QLOOP
	DEC	CH

TRYGREATER:
	CMP	AL,rabracket
	JNZ	NOOUT
;
; We have found a ">" char.  We need to see if there is another ">"
; following it.
;
	CMP	BYTE PTR [SI],al
	JNZ	NOAPPND
	LODSB
	INC	[RE_OUT_APP]			; Flag >>

NOAPPND:
;
; Now we attempt to find the file name.  First, scan off all whitespace
;
	INVOKE	SCANOFF
	CMP	AL,labracket			;AN040; was there no filename?
	JZ	REOUT_ERRSET			;AN040; yes - set up error
	CMP	AL,0DH
	JNZ	GOTREOFIL
;
; There was no file present.  Set us up at end-of-line.
;
REOUT_ERRSET:					;AN040; set up for an error
	mov	byte ptr [di], 0dh		; Clobber first ">"
	MOV	WORD PTR [RE_OUTSTR],09H	; Cause an error later
	JMP	PRESCANEND

GOTREOFIL:
	PUSH	DI
	MOV	DI,OFFSET RESGROUP:RE_OUTSTR
	MOV	BX,DI
	PUSH	ES

SETREOUTSTR:					; Get the output redirection name

						; MSKK06 07/14/89
	push	cx				; save cx
	mov	cx,64+13			; CX = max string length

SETREOUTSTR_LOOP:

	LODSB
	CMP	AL,0DH
	JZ	GOTRESTR_J
	INVOKE	DELIM
	JZ	GOTRESTR_J
	CMP	AL,[SWITCHAR]
	JZ	GOTRESTR_J
	CMP	AL,'"'                          ;AN033; Is the character a quote?
	JZ	PIPEERRSYNJ5_J			;AN033; Yes - get out quick - or system crashes
	CMP	AL,labracket			;AN002; Is char for input redirection
	JZ	ABRACKET_TERM			;AN002; yes - end of string
	CMP	AL,rabracket			;AN002; Is char for output redirection
	JNZ	NO_ABRACKET			;AN002; no - not end of string

ABRACKET_TERM:					;AN002; have end of string by < or >
	DEC	SI				;AN002; back up over symbol
	MOV	AL,BLANK			;AN002; show delimiter as char
GOTRESTR_J:
	pop	cx				; MSKK06 07/14/89
	JMP	SHORT GOTRESTR			;AN002; go process it

NO_ABRACKET:					;AN002; NOT AT END OF STRING
	STOSB					; store it into resgroup

ifdef DBCS
	invoke	testkanj
	jz	@f				; if not lead byte of DBCS
	jcxz	gotrestr_j			; if no tail byte
	lodsb
	cmp	al,0dh
	jz	gotrestr_j			; if tail byte does't come and ends
	stosb					; copy tail byte
	dec	cx
@@:
endif

	LOOP	SETREOUTSTR_LOOP		; MSKK06 07/14/89
	jmp	GOTRESTR_j

PIPEERRSYNJ5_J:
	pop	cx				; recover CX
	jmp	short PIPEERRSYNJ5

NOOUT:
	CMP	AL,labracket
	JNZ	CHKPIPE
	mov	bx,si				; Save loc of "<"
	INVOKE	SCANOFF
	CMP	AL,rabracket			;AN040; was there no filename?
	JZ	REIN_ERRSET			;AN040; yes - set up error
	CMP	AL,0DH
	JNZ	GOTREIFIL

REIN_ERRSET:					;AN040; set up for error
	mov	byte ptr [di],0dh		; Clobber "<"
	MOV	WORD PTR [RE_INSTR],09H 	; Cause an error later
	JMP	SHORT PRESCANEND

GOTREIFIL:
	PUSH	DI
	MOV	DI,OFFSET TranGROUP:RE_INSTR
	MOV	BX,DI
	PUSH	ES
	PUSH	CS
	POP	ES				; store in TRANGROUP
	JMP	SHORT SETREOUTSTR		; Get the input redirection name

CHKPIPE:
	MOV	AH,AL
	CMP	AH,AltPipeChr
	JZ	IsPipe3
	CMP	AH,vbar
	JNZ	CONTPRESCAN

IsPipe3:
;
; Only push the echo flag if we are entering the pipe for the first time.
;
	CMP	PipeFlag,0
	JNZ	NoEchoPush
	SHL	EchoFlag,1			; push echo state and turn it off
NoEchoPush:
	INC	[PIPEFLAG]
	INVOKE	SCANOFF
	CMP	AL,0DH
	JZ	PIPEERRSYNJ5
	CMP	AL,AltPipeChr
	JZ	PIPEERRSYNJ5
	CMP	AL,vbar 			; Double '|'?
	JNZ	CONTPRESCAN

PIPEERRSYNJ5:
	PUSH	ES
	POP	DS				; DS->RESGROUP
	JMP	PIPEERRSYN

;
; Trailing :s are allowed on devices.  Check to be sure that there is more
; than just a :  in the redir string.
;
GOTRESTR:
	XCHG	AH,AL
	mov	al,':'
	SUB	BX,DI				; compute negatinve of number of chars
	CMP	BX,-1				; is there just a :?
	JZ	NotTrailCol			; yep, don't change
	CMP	BYTE PTR ES:[DI-1],al		; Trailing ':' OK on devices
	JNZ	NOTTRAILCOL
	DEC	DI				; Back up over trailing ':'

NOTTRAILCOL:
	XOR	AL,AL
	STOSB					; NUL terminate the string
	POP	ES
	POP	DI				; Remember the start

CONTPRESCAN:
	MOV	[DI],AH 			; "delete" the redirection string
	INC	DI
	CMP	AH,0DH
	JZ	PRESCANEND
	INC	CL
	JMP	PRESCANLP

PRESCANEND:
	CMP	[PIPEFLAG],0
	JZ	ISNOPIPE
	MOV	DI,OFFSET RESGROUP:PIPESTR
	MOV	[PIPEPTR],DI
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	INVOKE	SCANOFF

PIPESETLP:					; Transfer the pipe into the resident
	LODSB					; pipe buffer
	STOSB
	CMP	AL,0DH
	JNZ	PIPESETLP

ISNOPIPE:
	MOV	[COMBUF+1],CL
	CMP	[PIPEFLAG],0
	PUSH	CS
	POP	ES
	return

cmd_copy  proc near

	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	INVOKE	Scanoff 			; advance past separators...
	add	si,PathPos
	mov	di,81h
	xor	cx,cx

CmdCopy:
	lodsb
	stosb
	cmp	al,0dh
	jz	CopyDone
	inc	cx
	jmp	CmdCopy

CopyDone:
	 mov	 byte ptr ds:[80h],cl		; Store count

	 ret
cmd_copy  endp


test_append	proc near

	mov	BX,offset TRANGROUP:COMBUF	;   barry can address
	mov	SI, offset TRANGROUP:IDLEN	; address command name, DS already set
	mov	DX,-1				; set install check function
	mov	AX,0AE00H
	int	2FH				; see if loaded
	cmp	AL,00H

	ret

test_append	endp

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tmisc2.asm ===
page ,132
;	SCCSID = @(#)tmisc2.asm 4.3 85/06/25
;	SCCSID = @(#)tmisc2.asm 4.3 85/06/25
TITLE	Part7 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	More misc routines


.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include bpb.inc
	include sf.inc
	include comseg.asm
	include comequ.asm
	include ioctl.inc
.list
.cref


CODERES 	SEGMENT PUBLIC BYTE	;AC000;
CodeRes 	ENDS

DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	IFFlag:BYTE
	EXTRN	PIPEFLAG:BYTE
	EXTRN	RE_OUTSTR:BYTE
	EXTRN	RE_OUT_APP:BYTE
DATARES 	ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	AccDen_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	FULDIR_PTR:WORD
	EXTRN	msg_disp_class:byte	;AN000;
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	DESTINFO:BYTE
	EXTRN	DESTISDIR:BYTE
	EXTRN	KPARSE:BYTE		;AC000;
	EXTRN	ONE_CHAR_VAL:BYTE	;AN011;
	EXTRN	PATHCNT:WORD
	EXTRN	PATHPOS:WORD
	EXTRN	PATHSW:WORD
	EXTRN	RE_INSTR:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	SRCBUF:BYTE
	EXTRN	SWITCHAR:BYTE

	IF  IBM
	EXTRN	ROM_CALL:BYTE
	EXTRN	ROM_CS:WORD
	EXTRN	ROM_IP:WORD
	ENDIF

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	CERROR:NEAR

	IF	IBM
	EXTRN	ROM_EXEC:NEAR
	EXTRN	ROM_SCAN:NEAR
	ENDIF

	PUBLIC	IOSET
	PUBLIC	MOVE_TO_SRCBUF		;AN000;
	PUBLIC	PGETARG
	PUBLIC	SETPATH
	PUBLIC	TESTDOREIN
	PUBLIC	TESTDOREOUT


ASSUME	DS:TRANGROUP

SETPATH:
;
; ENTRY PathPos = ptr to string
;       PathCnt = length of string
;
; EXIT  PathPos = ptr to string after pathname
;       PathCnt = length of rest of string
;       DX = ptr to pathname in string, made ASCIIZ
;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
;
;       A null character is dropped at the end of the pathname.  If the
;       character in that spot previously was CR, it is copied into the
;       following byte.  So there must be at least two two character 
;       positions in the buffer following the pathname.
;
        MOV     AX,[PATHCNT]            ;AC000; get length of string
        MOV     SI,[PATHPOS]            ;AC000; get start of source buffer

GETPATH:
	MOV	[DESTINFO],0
        MOV     [DESTISDIR],0
        MOV     SI,[PATHPOS]            ; SI = ptr to string
        MOV     CX,[PATHCNT]            ; CX = string length
        MOV     DX,SI                   ; DX = ptr to string
        JCXZ    PATHDONE                ; string length is zero, we're done
        PUSH    CX                      ; save string length
        PUSH    SI                      ; save ptr to string
        INVOKE  SWITCH

;       After Switch, SI has been scanned past any switches, and
;       switches that COMMAND intrinsically recognizes are recorded in AX.

        MOV     [PATHSW],AX             ; PathSw = switch occurrence mask
        POP     BX                      ; BX = ptr to original string
        SUB     BX,SI                   ; BX = -(# chars scanned by Switch)
        POP     CX                      ; CX = string length
        ADD     CX,BX                   ; CX = string length from current SI
        MOV     DX,SI                   ; DX = ptr to current string

SKIPPATH:

;;;;	IFDEF	DBCS	3/3/KK
	MOV	[KPARSE],0

SKIPPATH2:
;;;;	ENDIF		3/3/KK

        JCXZ    PATHDONE                ; string length is zero, we're done
        DEC     CX                      ; CX = length left after next char
        LODSB                           ; AL = next char of string
                                        ; SI = ptr to char after this one

;;;;	IFDEF	DBCS	3/3/KK
	INVOKE	TESTKANJ
        JZ      TESTPPSEP               ; no Kanji, move along
	DEC	CX
	INC	SI
	INC	[KPARSE]
	JMP	SKIPPATH2

TESTPPSEP:
;;;;	ENDIF		3/3/KK

        INVOKE  PATHCHRCMP              ; compare AL to path delimiter char
        JNZ     TESTPMETA               ; it's not a path delim
        INC     [DESTISDIR]             ; DestIsDir = 1, signalling path char

TESTPMETA:
        CMP     AL,'?'
        JNZ     TESTPSTAR               ; char is not '?'
        OR      [DESTINFO],2            ; DestInfo = 2, signalling wildcard

TESTPSTAR:
        CMP     AL,star
        JNZ     TESTPDELIM              ; char is not '*'
        OR      [DESTINFO],2            ; DestInfo = 2, signalling wildcard

TESTPDELIM:
        INVOKE  DELIM                   ; compare AL to all delimiters
        JZ      PATHDONEDEC             ; delimiter found, back up & leave
        CMP     AL,[SWITCHAR]
        JNZ     SKIPPATH                ; char isn't switch, go get next char

PATHDONEDEC:
        DEC     SI                      ; SI = ptr to char after pathname

PATHDONE:
        XOR     AL,AL                   ; AL = NULL
        XCHG    AL,[SI]                 ; place NULL after pathname
        INC     SI                      ; SI = ptr to byte after NULL
        CMP     AL,0DH                  ; were we at end of line?
        JNZ     NOPSTORE                ; not EOL, finish up
        MOV     [SI],AL                 ; save EOL after NULL

NOPSTORE:
        MOV     [PATHPOS],SI            ; PathPos = ptr to char after NULL
        MOV     [PATHCNT],CX            ; PathCnt = length of string left
        return

PGETARG:
	MOV	SI,80H
	LODSB
	OR	AL,AL
	retz
	CALL	PSCANOFF
	CMP	AL,13
	return

PSCANOFF:
	LODSB
	INVOKE	DELIM
	JNZ	PSCANOFFD
	CMP	AL,';'
	JNZ	PSCANOFF			; ';' is not a delimiter

PSCANOFFD:
	DEC	SI				; Point to first non-delimiter
	return

IOSET:
;
; ALL REGISTERS PRESERVED
;
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	PUSH	DS
	PUSH	DX
	PUSH	AX
	PUSH	BX
	PUSH	CX
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP

	CMP	[PIPEFLAG],0
	JNZ	NOREDIR 			; Don't muck up the pipe
	TEST	IFFlag,-1
	JNZ	NoRedir
	CALL	TESTDOREIN
	CALL	TESTDOREOUT

NOREDIR:
	POP	CX
	POP	BX
	POP	AX
	POP	DX
	POP	DS
ASSUME	DS:NOTHING
	return

TESTDOREIN:

ASSUME	DS:RESGROUP

	CMP	[RE_INSTR],0
	retz
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET tranGROUP:RE_INSTR
	MOV	AX,(OPEN SHL 8)
	MOV	BX,AX
	INT	21h
	POP	DS
	JC	REDIRERR
	MOV	BX,AX
	MOV	AL,0FFH
;
; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
; spot.  We invalidate the new JFN we got.
;
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table],AL

	return
;
; We had some kind of error on the redirection.  Figure out what the
; appropriate message should be; BX has the system call that failed
;
REDIRERR:
	PUSH	CS
	POP	DS
	Call	TriageError
;
; At this point, we have recognized the network-generated access denied error.
; The correct message is in DX
;
	CMP	AX,65
	JZ	CERRORJ 			;AC000; just issue message returned
	CMP	BH,OPEN
	JZ	OpenError
;
; The error was for a create operation.  Report the error as a creation error.
;
	MOV	DX,OFFSET TranGroup:FULDIR_PTR

CERRORJ:
	JMP	CERROR
;
; The system call was an OPEN.	Report either file not found or path not found.
;

OpenError:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block
	JMP	CERROR

TESTDOREOUT:

ASSUME	DS:RESGROUP

	CMP	[RE_OUTSTR],0
	JNZ	REOUTEXISTS			;AN017; need long jump
	JMP	NOREOUT 			;AN017;

REOUTEXISTS:
	CMP	[RE_OUT_APP],0
	JZ	REOUTCRT
;
; The output redirection was for append.  We open for write and seek to the
; end.
;
	MOV	DX,OFFSET RESGROUP:RE_OUTSTR
	MOV	AX,(OPEN SHL 8) OR 2		;AC011; Open for read/write
	PUSH	AX
	INT	21h
	POP	BX
	JC	OpenWriteError

	MOV	BX,AX
	MOV	AX,IOCTL SHL 8			;AN035; Get attributes of handle
	INT	21h			;AN035;
	TEST	DL,devid_ISDEV			;AN035; Is it a device?
	JNZ	SET_REOUT			;AN035; Yes, don't read from it

	MOV	AX,(LSEEK SHL 8) OR 2
	MOV	CX,-1				;AC011; MOVE TO EOF -1
	MOV	DX,CX				;AC011;
	INT	21h
	PUSH	CS				;AN011; Get transient seg to DS
	POP	DS				;AN011;
	assume	DS:Trangroup			;AN011;
	MOV	AX,(READ SHL 8) 		;AN011; Read one byte from the
	MOV	CX,1				;AN011;   file into one_char_val
	MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
	INT	21h			;AN011;
	JC	OpenWriteError			;AN011; If error, exit
	cmp	ax,cx				;AN017; Did we read 1 byte?
	jnz	reout_0_length			;AN017; No - file must be 0 length

	cmp	one_char_val,01ah		;AN011; Was char an eof mark?
	mov	DS,[resseg]			;AN011; Get resident segment back
	assume	DS:Resgroup			;AN011;
	JNZ	SET_REOUT			;AN011; No, just continue
	MOV	AX,(LSEEK SHL 8) OR 1		;AN011; EOF mark found
	MOV	CX,-1				;AN011; LSEEK back one byte
	MOV	DX,CX				;AN011;
	INT	21h			;AN011;
	JMP	SHORT SET_REOUT

reout_0_length: 				;AN017; We have a 0 length file
	mov	DS,[resseg]			;AN017; Get resident segment back
	assume	DS:Resgroup			;AN017;
	MOV	AX,(LSEEK SHL 8)		;AN017; Move to beginning of file
	XOR	CX,CX				;AN017; Offset is 0
	MOV	DX,CX				;AN017;
	INT	21h			;AN017;
	JMP	SHORT SET_REOUT 		;AN017; now finish setting up redirection

OpenWriteError:
	CMP	AX,error_access_denied
	STC					; preserve error
	JNZ	REOUTCRT			;AN017; need long jump
	JMP	REDIRERR			;AN017;

REOUTCRT:
	MOV	DX,OFFSET RESGROUP:RE_OUTSTR
	XOR	CX,CX
	MOV	AH,CREAT
	PUSH	AX
	INT	21h
	POP	BX
	JNC	NOREDIRERR			;AC011;
	JMP	REDIRERR			;AC011;

NOREDIRERR:					;AN011;
	MOV	BX,AX

SET_REOUT:
;
; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
; spot.  We invalidate the new JFN we got.
;
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table+1],AL

NOREOUT:
	return

;
; Compute length of string (including NUL) in DS:SI into CX.  Change no other
; registers
;
Procedure   DSTRLEN,NEAR

	SaveReg <AX>
	XOR	CX,CX
	CLD

DLoop:	LODSB
	INC	CX
	OR	AL,AL
	JNZ	DLoop
	SUB	SI,CX
	RestoreReg  <AX>
	return

EndProc DSTRLEN

Break	<Extended error support>

;
; TriageError will examine the return from a carry-set system call and
; return the correct error if applicable.
;
;   Inputs:	outputs from a carry-settable system call
;		No system calls may be done in the interrim
;   Outputs:	If carry was set on input
;		    carry set on output
;		    DX contains trangroup offset to printf message
;		else
;		    No registers changed
;

Procedure TriageError,NEAR

	retnc					; no carry => do nothing...
	PUSHF
	SaveReg <BX,CX,SI,DI,BP,ES,DS,AX,DX>
	MOV	AH,GetExtendedError
	INT	21h
	RestoreReg  <CX,BX>			; restore original AX
	MOV	DX,OFFSET TranGroup:AccDen_PTR
	CMP	AX,65				; network access denied?
	JZ	NoMove				; Yes, return it.
	MOV	AX,BX
	MOV	DX,CX

NoMove:
	RestoreReg  <DS,ES,BP,DI,SI,CX,BX>
	popf
	return

EndProc TriageError

PUBLIC Triage_Init
Triage_Init proc FAR
	call	TriageError
	ret
Triage_Init endp


; ****************************************************************
; *
; * ROUTINE:	 MOVE_TO_SRCBUF
; *
; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
; *		 terminating 0 to 0dH.	Set PATHCNT to length of
; *		 string.  Set PATHPOS to start of SRCBUF.
; *
; * INPUT:	 DS:SI points to ASCIIZ string
; *		 ES    points to TRANGROUP
; *
; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
; *		 PATHCNT set to length of string
; *		 PATHPOS set to start of SRCBUF
; *		 CX,AX	 changed
; *
; ****************************************************************

assume	es:trangroup,ds:nothing 		;AN000;

MOVE_TO_SRCBUF	PROC	NEAR			;AN000;

	push	si				;AN000;  save si,di
	push	di				;AN000;
	push	cx				;AN000;
	mov	di,offset TRANGROUP:srcbuf	;AN000;  set ES:DI to srcbuf
	xor	cx,cx				;AN000; clear cx for counint
	mov	ax,cx				;AN000; clear ax
	push	di				;AN000; save start of srcbuf
	lodsb					;AN000; get a character from DS:SI

mts_get_chars:					;AN000;
	cmp	al,0				;AN000; was it a null char?
	jz	mts_end_string			;AN000; yes - exit
	stosb					;AN000; no - store it in srcbuf
	inc	cx				;AN000; increment length count
	lodsb					;AN000; get a character from DS:SI
	jmp	short mts_get_chars		;AN000; go check it

mts_end_string: 				;AN000; we've reached the end of line
	mov	al,end_of_line_in		;AN000; store 0dH in srcbuf
	stosb					;AN000;
	pop	di				;AN000; restore start of srcbuf

	push	cs				;AN000; set DS to local segment
	pop	ds				;AN000;
assume	ds:trangroup				;AN000;
	mov	[pathcnt],cx			;AN000; set patchcnt to length count
	mov	[pathpos],di			;AN000; set pathpos to start of srcbuf
	pop	cx				;AN000; restore cx,di,si
	pop	di				;AN000;
	pop	si				;AN000;

	RET					;AN000; exit

MOVE_TO_SRCBUF	ENDP				;AN000;

TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tcode.asm ===
page ,132
;       SCCSID = @(#)tcode.asm  1.1 85/05/14
;       SCCSID = @(#)tcode.asm  1.1 85/05/14
TITLE   Part1 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;       Revision History
;       ================
;
;       M025    SR      9/12/90         Removed calls to SetStdInOn,SetStdInOff
;                               SetStdOutOn & SetStdOutOff.
;


.xlist
.xcref
        include comsw.asm
        include dossym.inc
        include syscall.inc
        include comseg.asm
        include comequ.asm
        include cmdsvc.inc
        include mult.inc
ifdef NEC_98
        include pdb.inc
endif   ;NEC_98
        include vint.inc
.list
.cref

Prompt32        equ     1
Start16         equ     0
Return16        equ     1
DOSONLY_YES     equ     1
FOR_TSR         equ     0
FOR_SHELLOUT    equ     1


CODERES         SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   EXEC_WAIT:NEAR
CODERES ENDS

DATARES         SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   BATCH:WORD
        EXTRN   CALL_BATCH_FLAG:byte
        EXTRN   CALL_FLAG:BYTE
        EXTRN   ECHOFLAG:BYTE
        EXTRN   envirseg:word
        EXTRN   EXTCOM:BYTE
        EXTRN   FORFLAG:BYTE
        EXTRN   IFFLAG:BYTE
        EXTRN   next_batch:word
        EXTRN   nullflag:byte
        EXTRN   PIPEFILES:BYTE
        EXTRN   PIPEFLAG:BYTE
        EXTRN   RE_OUT_APP:BYTE
        EXTRN   RE_OUTSTR:BYTE
        EXTRN   RESTDIR:BYTE
        EXTRN   SINGLECOM:WORD
        EXTRN   KSWITCHFLAG:BYTE
        EXTRN   VERVAL:WORD
    EXTRN   SCS_Is_First:BYTE
    EXTRN   SCS_PAUSE:BYTE
        EXTRN   SCS_REENTERED:BYTE
        EXTRN   SCS_FIRSTCOM:BYTE
        EXTRN   SCS_CMDPROMPT:BYTE
        EXTRN   SCS_DOSONLY:BYTE
        EXTRN   SCS_PROMPT16:BYTE
        EXTRN   SCS_FIRSTTSR:BYTE
        EXTRN   RES_RDRINFO:DWORD
        EXTRN   RES_BATSTATUS:BYTE
        EXTRN   crit_msg_off:word       ;AC000;
        EXTRN   crit_msg_seg:word       ;AC000;
        EXTRN   OldTerm:DWORD
        EXTRN   PARENT:WORD
        extrn   RetCode:word
        extrn   Io_Save:word
        extrn   Io_Stderr:byte
        extrn   RES_TPA:WORD            ; YST
    extrn   LTPA:WORD       ; YST
DATARES ENDS

TRANDATA        SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   BadNam_Ptr:word         ;AC000;
        EXTRN   comspec:byte
        EXTRN   NT_INTRNL_CMND:byte
TRANDATA        ENDS

TRANSPACE       SEGMENT PUBLIC BYTE     ;AC000;
        EXTRN   APPEND_EXEC:BYTE        ;AN041;
        EXTRN   ARG1S:WORD
        EXTRN   ARG2S:WORD
        EXTRN   ARGTS:WORD
        EXTRN   BYTCNT:WORD
        EXTRN   COMBUF:BYTE
        EXTRN   COMSW:WORD
        EXTRN   CURDRV:BYTE
        EXTRN   HEADCALL:DWORD
        EXTRN   IDLEN:BYTE
        EXTRN   INTERNATVARS:BYTE
        EXTRN   PARM1:BYTE
        EXTRN   PARM2:BYTE
        EXTRN   RE_INSTR:BYTE
        EXTRN   RESSEG:WORD
        EXTRN   SPECDRV:BYTE
        EXTRN   STACK:WORD
        EXTRN   SWITCHAR:BYTE
        EXTRN   TPA:WORD
        EXTRN   UCOMBUF:BYTE
        EXTRN   USERDIR1:BYTE
        IF  IBM
        EXTRN   ROM_CALL:BYTE
        EXTRN   ROM_CS:WORD
        EXTRN   ROM_IP:WORD
        ENDIF
        EXTRN   ENV_PTR_SEG:WORD
        EXTRN   ENV_SIZE:WORD
        EXTRN   SCS_TSREXIT:WORD
        EXTRN   CMD_PTR_SEG:WORD
        EXTRN   CMD_PTR_OFF:WORD
        EXTRN   CMD_SIZE:WORD
        EXTRN   SCS_EXIT_CODE:WORD
        EXTRN   SCS_RDRINFO:DWORD
        EXTRN   SCS_BATSTATUS:DWORD
        EXTRN   SCS_NUM_DRIVES:WORD
        EXTRN   SCS_CUR_DRIVE:WORD
        EXTRN   SCS_CODEPAGE:WORD
        EXTRN   SCS_STD_HANDLE:WORD
        EXTRN   SCS_STD_BITS:BYTE
        EXTRN   EXECPATH_SEG:WORD
        EXTRN   EXECPATH_OFF:WORD
        EXTRN   EXECPATH_SIZE:WORD
        EXTRN   EXECPATH:BYTE

        EXTRN   TRAN_TPA:WORD
        extrn   transpaceend:byte       ; (YST)

TRANSPACE       ENDS

; (YST)
TAIL segment public para
extrn TranStart:word
TAIL ENDS
; End of (YST)


; ********************************************************************
; START OF TRANSIENT PORTION
; This code is loaded at the end of memory and may be overwritten by
; memory-intensive user programs.

TRANCODE        SEGMENT PUBLIC BYTE     ;AC000;

ASSUME  CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

        EXTRN   $EXIT:NEAR
        EXTRN   DRVBAD:NEAR
        EXTRN   EXTERNAL:NEAR
        EXTRN   FNDCOM:NEAR
        EXTRN   FORPROC:NEAR
        EXTRN   PIPEPROC:NEAR
        EXTRN   PIPEPROCSTRT:NEAR
        EXTRN   GETENVSIZ:near

        PUBLIC  COMMAND
        PUBLIC  DOCOM
        PUBLIC  DOCOM1
        PUBLIC  NOPIPEPROC
        PUBLIC  TCOMMAND

        IF  IBM
        PUBLIC  ROM_EXEC
        PUBLIC  ROM_SCAN
        ENDIF


; NTVDM use diff al value so we don't confuse dos 5.0
; NTVDM command.com GET_COMMAND_STATE       equ     5500h
GET_COMMAND_STATE       equ     5501h

NLSFUNC_installed       equ    0ffh
KEYB16_installed        equ    0ffh         ; (YST)
CHECK_KEYB16            equ    0AD80h       ; (YST)
set_global_cp           equ    2
get_global_cp           equ    1


        ORG     0
ZERO    =       $

        ORG     100H                            ; Allow for 100H parameter area

SETDRV:
        MOV     AH,SET_DEFAULT_DRIVE
        INT     21h
;
; TCOMMAND is the recycle point in COMMAND.  Nothing is known here.
; No registers (CS:IP) no flags, nothing.
;

TCOMMAND:
        MOV     DS,[RESSEG]
ASSUME  DS:RESGROUP
        MOV     AX,-1
        XCHG    AX,[VERVAL]
        CMP     AX,-1
        JZ      NOSETVER2
        MOV     AH,SET_VERIFY_ON_WRITE          ; AL has correct value
        INT     21h

NOSETVER2:
        CALL    [HEADCALL]                      ; Make sure header fixed
        XOR     BP,BP                           ; Flag transient not read
        CMP     [SINGLECOM],-1
        JNZ     COMMAND

$EXITPREP:
        PUSH    CS
        POP     DS
        JMP     $EXIT                           ; Have finished the single command
ASSUME  DS:NOTHING
;
; Main entry point from resident portion.
;
;   If BP <> 0, then we have just loaded transient portion otherwise we are
;   just beginning the processing of another command.
;

COMMAND:

;
; We are not always sure of the state of the world at this time.  We presume
; worst case and initialize the relevant registers: segments and stack.
;
        ASSUME  CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
        CLD
        MOV     AX,CS
        FCLI
        MOV     SS,AX
ASSUME  SS:TRANGROUP
        MOV     SP,OFFSET TRANGROUP:STACK
        FSTI
        MOV     ES,AX
        MOV     DS,AX                           ;AN000; set DS to transient
ASSUME  ES:TRANGROUP,DS:TRANGROUP               ;AC000;
        invoke  TSYSLOADMSG                     ;AN000; preload messages
        mov     append_exec,0                   ;AN041; set internal append state off

        MOV     DS,[RESSEG]
ASSUME  DS:RESGROUP

        MOV     [UCOMBUF],COMBUFLEN             ; Init UCOMBUF
        MOV     [COMBUF],COMBUFLEN              ; Init COMBUF (Autoexec doing DATE)

        mov     [EXECPATH_SIZE], 0              ; ntvdm execpath extended

;
; If we have just loaded the transient, then we do NOT need to initialize the
; command buffer.  ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????  I
; guess not:  the only circumstances in which we reload the command processor
; is after a transient program execution.  In this case, we let the current
; directory lie where it may.
;
        OR      BP,BP                           ; See if just read
        JZ      TESTRDIR                        ; Not read, check user directory
        MOV     WORD PTR [UCOMBUF+1],0D01H      ; Reset buffer
        JMP     SHORT NOSETBUF

TESTRDIR:
        CMP     [RESTDIR],0
        JZ      NOSETBUF                        ; User directory OK
        PUSH    DS
;
; We have an unusual situation to handle.  The user *may* have changed his
; directory as a result of an internal command that got aborted.  Restoring it
; twice may not help us:  the problem may never go away.  We just attempt it
; once and give up.
;
        MOV     [RESTDIR],0                     ; Flag users dirs OK
        PUSH    CS
        POP     DS
ASSUME  DS:TRANGROUP
        MOV     DX,OFFSET TRANGROUP:USERDIR1
        MOV     AH,CHDIR
        INT     21h                     ; Restore users directory
        POP     DS
ASSUME  DS:RESGROUP

NOSETBUF:
        CMP     [PIPEFILES],0
        JZ      NOPCLOSE                        ; Don't bother if they don't exist
        CMP     [PIPEFLAG],0
        JNZ     NOPCLOSE                        ; Don't del if still piping
        INVOKE  PIPEDEL

NOPCLOSE:
        MOV     [EXTCOM],0                      ; Flag internal command
        MOV     AX,CS                           ; Get segment we're in
        MOV     DS,AX
ASSUME  DS:TRANGROUP

        PUSH    AX
        MOV     DX,OFFSET TRANGROUP:INTERNATVARS
        MOV     AX,INTERNATIONAL SHL 8
        INT     21H
        POP     AX
        SUB     AX,[TPA]                        ; AX=size of TPA in paragraphs
        PUSH    BX
        MOV     BX,16
        MUL     BX                              ; DX:AX=size of TPA in bytes
        POP     BX
        OR      DX,DX                           ; See if over 64K
        JZ      SAVSIZ                          ; OK if not
        MOV     AX,-1                           ; If so, limit to 65535 bytes

SAVSIZ:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
        CMP     AX,512
        JBE     GotSize
        AND     AX,0FE00h                       ; NOT 511 = NOT 1FF

GotSize:
        MOV     [BYTCNT],AX                     ; Max no. of bytes that can be buffered
        MOV     DS,[RESSEG]                     ; All batch work must use resident seg.
ASSUME  DS:RESGROUP

        TEST    [ECHOFLAG],1
        JZ      GETCOM                          ; Don't do the CRLF
        INVOKE  SINGLETEST
        JB      GETCOM
        TEST    [PIPEFLAG],-1
        JNZ     GETCOM
        TEST    [FORFLAG],-1                    ; G  Don't print prompt in FOR
        JNZ     GETCOM                          ; G
        TEST    [BATCH], -1                     ; G  Don't print prompt if in batch
        JNZ     GETCOM                          ; G
;       INVOKE  CRLF2

GETCOM:
        MOV     CALL_FLAG,0                     ; G Reset call flags
        MOV     CALL_BATCH_FLAG,0               ; G
        MOV     AH,GET_DEFAULT_DRIVE
        INT     21h
        MOV     [CURDRV],AL
        TEST    [PIPEFLAG],-1                   ; Pipe has highest presedence
        JZ      NOPIPE
        JMP     PIPEPROC                        ; Continue the pipeline

NOPIPE:
        TEST    [ECHOFLAG],1
        JZ      NOPDRV                          ; No prompt if echo off
        INVOKE  SINGLETEST
        JB      NOPDRV
        TEST    [FORFLAG],-1                    ; G  Don't print prompt in FOR
        JNZ     NOPDRV                          ; G
        TEST    [BATCH], -1                     ; G  Don't print prompt if in batch
        JNZ     TESTFORBAT                      ; G
;       INVOKE  PRINT_PROMPT                    ; Prompt the user

NOPDRV:
        TEST    [FORFLAG],-1                    ; FOR has next highest precedence
        JZ      TESTFORbat
        JMP     FORPROC                         ; Continue the FOR

TESTFORBAT:
        MOV     [RE_INSTR],0                    ; Turn redirection back off
        MOV     [RE_OUTSTR],0
        MOV     [RE_OUT_APP],0
        MOV     IFFlag,0                        ; no more ifs...
        TEST    [BATCH],-1                      ; Batch has lowest precedence
        JZ      ISNOBAT

;       Bugbug:         MULT_SHELL_GET no longer used?
        push    es                              ;AN000; save ES
        push    ds                              ;AN000; save DS
        mov     ax,mult_shell_get               ;AN000; check to see if SHELL has command
        mov     es,[batch]                      ;AN000; get batch segment
        mov     di,batfile                      ;AN000; get batch file name
        push    cs                              ;AN000; get local segment to DS
        pop     ds                              ;AN000;
        mov     dx,offset trangroup:combuf      ;AN000; pass communications buffer
        int     2fh                             ;AN000; call the shell
        cmp     al,shell_action                 ;AN000; does shell have a commmand?
        pop     ds                              ;AN000; restore DS
        pop     es                              ;AN000; restore ES
        jz      jdocom1                         ;AN000; yes - go process command

        PUSH    DS                              ;G
        INVOKE  READBAT                         ; Continue BATCH
        POP     DS                              ;G
        mov     nullflag,0                      ;G reset no command flag
        TEST    [BATCH],-1                      ;G
        JNZ     JDOCOM1                         ;G if batch still in progress continue
        MOV     BX,NEXT_BATCH                   ;G
        CMP     BX,0                            ;G see if there is a new batch file
        JZ      JDOCOM1                         ;G no - go do command
        MOV     BATCH,BX                        ;G get segment of next batch file
        MOV     NEXT_BATCH,0                    ;G reset next batch
JDOCOM1:
        PUSH    CS                              ;G
        POP     DS                              ;G
        JMP     DoCom1                          ; echoing already done

ISNOBAT:
        CMP     [SINGLECOM],0
        JZ      REGCOM
        MOV     SI,-1
        CMP     KSWITCHFLAG,0
        JE      NO_K_SWITCH
        INC     SI
        MOV     KSWITCHFLAG,0
NO_K_SWITCH:
        XCHG    SI,[SINGLECOM]
        MOV     DI,OFFSET TRANGROUP:COMBUF + 2
        XOR     CX,CX

SINGLELOOP:
        LODSB
        STOSB
        INC     CX
        CMP     AL,0DH
        JNZ     SINGLELOOP
        DEC     CX
        PUSH    CS
        POP     DS
ASSUME  DS:TRANGROUP
        MOV     [COMBUF + 1],CL
;
; do NOT issue a trailing CRLF...
;
        JMP     DOCOM1

;
; We have a normal command.
; Printers are a bizarre quantity.  Sometimes they are a stream and
; sometimes they aren't.  At this point, we automatically close all spool
; files and turn on truncation mode.
;

REGCOM:
        MOV     AX,(ServerCall SHL 8) + 9
        INT     21h
        MOV     AX,(ServerCall SHL 8) + 8
        MOV     DL,1
        INT     21h

        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        cmp     byte ptr [SCS_FIRSTCOM],0
        jnz     first_inst                      ;this is the first instance

        jmp     DoReEnter
DRE_RET:
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        xor     ax,ax
    jmp short do_again

first_inst:
    mov [SCS_PAUSE],0           ; yst 4-5-93
        cmp     [SCS_Is_First],1
        jne     cont_scs
        mov     [SCS_Is_First],0

        SAVE    <SI,BP>
        xor     si,si
        xor     bp,bp
        mov     al,2
        mov     ah,setdpb
        int     21h                             ; resets the TSR bit
        RESTORE <BP,SI>
        xor     ax,ax
        jmp     short do_again

cont_scs:
        SAVE    <AX,SI,BP>
        xor     si,si
        xor     bp,bp
        mov     al,2
        mov     ah,setdpb
        int     21h                             ; resets the TSR bit
        RESTORE <BP,SI,AX>
        jnc     cont_scs2

cont_tsr:
        jmp     tsr_loop
tsr_loop_ret:
        jmp     short cont_scs1

cont_scs2:
        cmp     byte ptr [scs_firsttsr],1
        je      cont_scs1
        jmp     short cont_tsr

cont_scs1:
;       call    free_con

        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
    mov ax,[retcode]

do_again:
ifdef NEC_98
        jmp     ClrFky
FKY_OFF DB      1Bh,'[>1h$'                     ;ESC sequence of FKY off
Clrfky: push    ds
        push    cs
        pop     ds
        push    cx
        push    ax
        push    dx
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_OFF
        int     0DCH                            ;FKY off
        pop     dx
        pop     ax
        pop     cx
        pop     ds
endif   ;NEC_98
        MOV     DS,cs:[RESSEG]
    ASSUME  DS:RESGROUP
    push    es
    mov es,[envirseg]
    mov [ENV_PTR_SEG],es
    call    GETENVSIZ
    pop es
    push    cs
    pop ds
    ASSUME  DS:TRANGROUP
    mov [ENV_SIZE],cx

;; williamh - Jan 11 1993
;; nt expects 16bits exit code while DOS has only 8 bits
;; clear the high byte so that things won't go wrong
    xor ah, ah

        MOV     [SCS_EXIT_CODE],ax
        mov     ah,19h
        int     21h
        xor     ah,ah
        mov     [SCS_CUR_DRIVE], ax     ; a= 0 , b = 1 etc
    mov [CMD_SIZE],COMBUFLEN
    MOV DX,OFFSET TRANGROUP:UCOMBUF

if 0
;       Try to read interactive command line via DOSKey.
;       If that fails, use DOS Buffered Keyboard Input.

        mov     ax,4810h                ; AX = DOSKey Read Line function
        int     2fh
        or      ax,ax
        jz      GotCom                  ; DOSKey gave us a command line
else
        mov     [CMD_PTR_SEG],ds
        mov     [CMD_PTR_OFF],dx

        mov     dx,OFFSET TRANGROUP:EXECPATH
        mov     [EXECPATH_SEG], ds
        mov     [EXECPATH_OFF], dx
        mov     [EXECPATH_SIZE], EXECPATHLEN

        push    es
        mov     es,cs:[RESSEG]
        ASSUME  es:RESGROUP
        mov     dx,word ptr es:[RES_RDRINFO]
        mov     word ptr ds:[SCS_RDRINFO],dx
        mov     dx,word ptr es:[RES_RDRINFO+2]
        mov     word ptr ds:[SCS_RDRINFO+2],dx
        pop     es
        ASSUME  ES:TRANGROUP
        MOV     DX,OFFSET TRANGROUP:ENV_PTR_SEG


        CMDSVC  SVC_CMDGETNEXTCMD               ; DS:DX is the buffer
        jnc     run_cmd

; If carry is set that means our enviornment buffer was smaller. So get
; a big enough buffer and get the command again.
        cmp     ax,32*1024      ; Env size cannot be more than 32k.
        jae     op_fail
        push    ax              ; the new size in bytes for env in bytes
        invoke  FREE_TPA
        pop     bx
        MOV     CL,4
        SHR     BX,CL           ; Convert back to paragraphs
        inc     bx              ; an extra para
        push    es
        push    ds
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        mov     es,[envirseg]
        pop     ds
        ASSUME  DS:TRANGROUP
        MOV     CX,ES           ;AN056; Get environment segment
        ADD     CX,BX           ;AN056; Add in size of environment
        ADD     CX,020H         ;AN056; Add in some TPA
        MOV     AX,CS           ;AN056; Get the transient segment
        CMP     CX,AX           ;AN056; Are we hitting the transient?
        JNB     blk_xxx         ;AN056; Yes - don't do it!!!

        push    bx
        MOV     AH,SETBLOCK
        INT     21h
        pop     bx
        jnc     blk_xxx

        mov     ah,ALLOC
        int     21h
        jc      blk_xxx
        push    ax

        mov     ah,DEALLOC
        int     21h

        pop     ax
        push    ds
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        mov     [envirseg],ax
        pop     ds
        ASSUME  DS:TRANGROUP
        clc
blk_xxx:
        lahf
        push    ax
        MOV     ES,cs:[RESSEG]
        invoke  ALLOC_TPA
        pop     ax
        sahf
        JC      op_fail1
        pop     es
        xor     ax,ax           ; error code zero, its important
        jmp     do_again
op_fail1:
        pop     es
op_fail:
        mov     ax,error_not_enough_memory
        jmp     do_again

run_cmd:
        push    es
        mov     es,cs:[RESSEG]
        ASSUME  es:RESGROUP
        mov     ax,word ptr ds:[SCS_RDRINFO]
        mov     word ptr es:[RES_RDRINFO],ax
        mov     ax,word ptr ds:[SCS_RDRINFO+2]
        mov     word ptr es:[RES_RDRINFO+2],ax
        mov     ax,word ptr ds:[SCS_BATSTATUS]
        mov     byte ptr es:[RES_BATSTATUS],al
        pop     es
        ASSUME  ES:TRANGROUP
        test    [SCS_STD_HANDLE],ALL_HANDLES
        jz      no_rdr
        test    [SCS_STD_HANDLE],MASK_STDIN
        jz      scs_std_out
        xor     cx,cx                           ; CX = HANDLE_STDIN
        call    alloc_con
        jnc     scs_std_out
rdr_err:
        call    free_con
        mov     ax,error_not_enough_memory
        jmp     do_again

scs_std_out:
        ; Make Sure Stdout is checked before stderr. Its very important.
        test    [SCS_STD_HANDLE],MASK_STDOUT
        jz      scs_std_err
        mov     cx,HANDLE_STDOUT
        call    alloc_con
        jc      rdr_err

scs_std_err:
        test    [SCS_STD_HANDLE],MASK_STDERR
        jz      no_rdr
        mov     cx,HANDLE_STDERR
        call    alloc_con
        jc      rdr_err

no_rdr:
ifdef NEC_98
        push    ds
        push    cx
        push    ax
        push    dx

        CMDSVC  SVC_GETCURSORPOS                ;gets bios cursor position
                                                ;now dx=offset on TEXT VRAM
        mov     ax,dx
        mov     cl,160
        div     cl
        mov     dh,al
        xor     dl,dl
        mov     cl,10h
        mov     ah,03h
        int     0DCH                            ;set cursor position for DOS

        jmp     DspFky
FKY_ON  DB      1Bh,'[>1l$'                     ;ESC sequence of FKY on
Dspfky: push    cs
        pop     ds
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_ON
        int     0DCH                            ;FKY on

        pop     dx
        pop     ax
        pop     cx
        pop     ds
endif   ;NEC_98
        mov     ah,GetSetCdPg
        mov     al,1
        int     21h
        jc      cdpg_done
        cmp     bx,[SCS_CODEPAGE]
        jz      cdpg_done

        mov     ah,NLSFUNC                      ; see if NLSFUNC installed
        mov     al,0                            ;
        int     2fh                             ;
        cmp     al,NLSFUNC_installed            ;
        jnz     no_nlsf_msg                     ; NO NLSFUNC ; Print message
;       jz      got_nls                         ; Yes - continue
;       mov     dx,offset trangroup:NLSFUNC_ptr ; no - set up error message
;       jmp     short cp_error                  ; error exit

        mov     bx,[SCS_CODEPAGE]               ;SCS Code page
        mov     ah,getsetcdpg                   ;set global code page function
        mov     al,set_global_cp                ;minor - set
        int     21h
        jnc     cdpg_done                       ;no error - exit
nlsf_failed:
; BUGBUG Sudeepb 28-Apr-1992 Putup a message saying NLSFunc failed
no_nlsf_msg:
; BUGBUG Sudeepb 28-Apr-1992 Putup a message saying NLSFunc not installed

cdpg_done:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                ;;
;; (YST) 08-Jan-1993 Checking and installing  16-bit KEYB.COM ;;
;;                                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

       jmp     YST_beg

;; Data for KB16

KEY_LINE db 128 dup (0)    ; "d:\nt\system32\kb16.com", 0
YST_ARG  db 128 dup (0)    ; 32, " XX,,d:\nt\system32\keyboard.sys", 0DH


YPAR     dw     0
         dd     0
         dw     005ch, 0
         dw     006ch, 0

KEEP_SS  dw     0
KEEP_SP  dw     0

YST_beg:

      SAVE <BX, ES, DS>                ; save all regs for INT 2FH

      mov     ax, CHECK_KEYB16             ; see if KEYB16 installed
      int     2fh
      xor     dx,dx
      cmp     al, KEYB16_installed
      jne     keyb_cont                ; KEYB16 not installed, DX == 0
      inc     dx                   ; installed DX == 1

keyb_cont:
      RESTORE <DS, ES, BX>

      push    ds
      push    cs
      pop     ds

      mov     si, offset KEY_LINE          ; name of KB16.COM
      mov     cx, offset YST_ARG           ; command line

      CMDSVC    SVC_GETKBDLAYOUT    ; Call 32-bit API for checking
                    ; and installing correct layout
      or      dx,dx         ; if DX != 0 after BOP then we need
      pop     ds            ; to install 16-bit KEYB.COM
      jnz     run_keyb

      jmp     End_keyb          ; No installation of KB16.COM

run_keyb:

;; This part run KB16.COM

      SAVE    <DS, BX>

      PUSH    ES            ; free TPA for running KB16
      MOV     ES,[TRAN_TPA]
      MOV     AH,DEALLOC
      INT     21h           ; Now running in "free" space

      push    cs
      pop     ds
      push    cs
      pop     es

      mov     dx, offset KEY_LINE   ; file name
      mov     YPAR+0, 0000H     ; keep current enviroment
      mov     YPAR+2, offset YST_ARG    ; arguments (options) for KB16.COM
      mov     YPAR+4, ds
      mov     bx, offset YPAR

      mov     KEEP_SS, ss       ; Peter Norton suggests to keep
      mov     KEEP_SP, sp       ; SS and SP

      mov     ah, 4bh
      xor     al, al

      int     21h           ; RUN!

      mov     ss, cs:KEEP_SS        ; Restore SS and SP
      mov     sp, cs:KEEP_SP

      POP     ES

      SAVE  <BP>            ; We need to restore TSR bit
      xor   si,si           ; for running next app.
      xor   bp,bp           ; use "undocumented" call.
      mov   al,2
      mov   ah,setdpb
      int   21h         ; resets the TSR bit
      RESTORE   <BP>


; Allocate transient again after runnig KB16.
; Copied from TBATCH.ASM
; Modify AX,BX,DX,flags
;

        ASSUME DS:TRANGROUP,ES:RESGROUP

        PUSH    ES
        MOV     ES,cs:[RESSEG]
        MOV     BX,0FFFFH                       ; Re-allocate the transient
        MOV     AH,ALLOC
        INT     21h
        PUSH    BX                              ; Save size of block
        MOV     AH,ALLOC
        INT     21h
;
; Attempt to align TPA on 64K boundary
;
        POP     BX                              ; Restore size of block
        MOV     [RES_TPA], AX                   ; Save segment to beginning of block
        MOV     [TRAN_TPA], AX
;
; Is the segment already aligned on a 64K boundary
;
        MOV     DX, AX                          ; Save segment
        AND     AX, 0FFFH                       ; Test if above boundary
        JNZ     Calc_TPA
        MOV     AX, DX
        AND     AX, 0F000H                      ; Test if multiple of 64K
        JNZ     NOROUND

Calc_TPA:
        MOV     AX, DX
        AND     AX, 0F000H
        ADD     AX, 01000H                      ; Round up to next 64K boundary
        JC      NOROUND                         ; Memory wrap if carry set
;
; Make sure that new boundary is within allocated range
;
        MOV     DX, [RES_TPA]
        ADD     DX, BX                          ; Compute maximum address
        CMP     DX, AX                          ; Is 64K address out of range?
        JB      NOROUND
;
; Make sure that we won't overwrite the transient
;
        MOV     BX, CS                          ; CS is beginning of transient
        CMP     BX, AX
        JB      NOROUND
;
; The area from the 64K boundary to the beginning of the transient must
; be at least 64K.
;
        SUB     BX, AX
        CMP     BX, 4096                        ; Size greater than 64K?
        JAE     ROUNDDONE

NOROUND:
        MOV     AX, [RES_TPA]

ROUNDDONE:
        MOV     [LTPA],AX                       ; Re-compute everything
        MOV     [TPA],AX
        MOV     BX,AX
        MOV     AX,CS
        SUB     AX,BX
        PUSH    BX
        MOV     BX,16
        MUL     BX
        POP     BX
        OR      DX,DX
        JZ      SAVSIZ2
        MOV     AX,-1

SAVSIZ2:
;
; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1.  We round this down to a multiple of 512.
;
        CMP     AX,512
        JBE     GotSize1
        AND     AX,0FE00h                       ; NOT 511 = NOT 1FF

GotSize1:
        MOV     [BYTCNT],AX
        POP     ES


; End  Alloc_TPA


        RESTORE <BX, DS>

        CMDSVC  SVC_CMDINITCONSOLE   ; make sure console is turned on

End_keyb:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                  ;;
;; End of (YST) 08-Jan-1993 Checking and installing 16-bit KEYB.COM ;;
;;                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



        mov     dx,[SCS_CUR_DRIVE]
        mov     [curdrv],dl
        mov     ah,0eh
        int     21h
        push    cs
        pop     ds
        MOV     DX,OFFSET TRANGROUP:UCOMBUF

endif

GotCom:
        MOV     CL,[UCOMBUF]
        XOR     CH,CH
        ADD     CX,3
        MOV     SI,OFFSET TRANGROUP:UCOMBUF
        MOV     DI,OFFSET TRANGROUP:COMBUF
        REP     MOVSB                           ; Transfer it to the cooked buffer

;---------------

transpace   segment
    extrn   arg:byte                            ; the arg structure!
transpace   ends
;---------------


DOCOM:
;       INVOKE  CRLF2

DOCOM1:
        INVOKE  PRESCAN                         ; Cook the input buffer
        JZ      NOPIPEPROC
        JMP     PIPEPROCSTRT                    ; Fire up the pipe

nullcomj:
        jmp     nullcom

NOPIPEPROC:
        invoke  parseline
        jnc     OkParse                         ; user error?  or maybe we goofed?

BadParse:
        PUSH    CS
        POP     DS
        MOV     DX,OFFSET TRANGROUP:BADNAM_ptr
        INVOKE  std_eprintf
        JMP     TCOMMAND

OkParse:
        test    arg.argv[0].argflags, MASK wildcard
        jnz     BadParse                        ; ambiguous commands not allowed
        cmp     arg.argvcnt, 0                  ; there WAS a command, wasn't there?
        jz      nullcomj
        cmp     arg.argv[0].arglen, 0           ; probably an unnecessary check...
        jz      nullcomj                        ; guarantees argv[0] at least x<NULL>

        MOV     SI,OFFSET TRANGROUP:COMBUF+2
        MOV     DI,OFFSET TRANGROUP:IDLEN
        MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H ; Make FCB with blank scan-off
        INT     21h
        mov     BX, arg.argv[0].argpointer
        cmp     WORD PTR [BX], 05c5ch           ; leading "\\" means UNC name
        je      IsUncName
        cmp     BYTE PTR [BX+1],':'             ; was a drive specified?
        jne     short drvgd                     ; no, use default of zero...

        mov     DL, BYTE PTR [BX]               ; pick-up drive letter
        and     DL, NOT 20H                     ; uppercase it
        sub     DL, capital_A                   ; convert it to a drive number, A=0

        CMP     AL,-1                           ; See what PARSE said about our drive letter.
        JZ      drvbadj2                        ; It was invalid.

IsUncName:
        mov     DI, arg.argv[0].argstartel
        cmp     BYTE PTR [DI], 0                ; is there actually a command there?
        jnz     drvgd                           ; if not, we have:  "d:", "d:\", "d:/"
        jmp     setdrv                          ; and set drive to new drive spec

drvbadj2:
        jmp     drvbad

DRVGD:
        MOV     AL,[DI]
        MOV     [SPECDRV],AL
        MOV     AL,' '
        MOV     CX,9
        INC     DI
        REPNE   SCASB                           ; Count no. of letters in command name
        MOV     AL,8
        SUB     AL,CL
        MOV     [IDLEN],AL                      ; IDLEN is truly the length
        MOV     DI,81H
        PUSH    SI

        mov     si, OFFSET TRANGROUP:COMBUF+2   ; Skip over all leading delims
        invoke  scanoff
;SR;
; We are going to skip over the first char always. The logic is that the
;command tail can never start from the first character. The code below is
;trying to figure out the command tail and copy it to the command line
;buffer in the PSP. However, if the first character happens to be a switch
;character and the user given command line is a full 128 bytes, we try to
;copy 128 bytes to the PSP while it can take only 127 chars. This extra
;char overwrites the code and leads to a crash on future commands.
;

        inc     si

do_skipcom:
        lodsb                                   ; move command line pointer over
        invoke  delim                           ; pathname -- have to do it ourselves
        jz      do_skipped                      ; 'cause parse_file_descriptor is dumb
        cmp     AL, 0DH                         ; can't always depend on argv[0].arglen
        jz      do_skipped                      ; to be the same length as the user-
        cmp     AL, [SWITCHAR]                  ; specified command string
        jnz     do_skipcom

do_skipped:
        dec     SI
; jarbats 11-20-2000
; failing to decrease SI results in missing leading space for command tail
; which upsets many old dos apps which assume there is a space at the beginning and start at the second char
;do_skipped1:
        XOR     CX,CX

COMTAIL:
        LODSB
        STOSB                                   ; Move command tail to 80H
        CMP     AL,13
        LOOPNZ  COMTAIL
        DEC     DI
        MOV     BP,DI
        NOT     CL
        MOV     BYTE PTR DS:[80H],CL
        POP     SI

;-----
; Some of these comments are sadly at odds with this brave new code.
;-----
; If the command has 0 parameters must check here for
; any switches that might be present.
; SI -> first character after the command.

        mov     DI, arg.argv[0].argsw_word
        mov     [COMSW], DI                     ; ah yes, the old addressing mode problem...
        mov     SI, arg.argv[1 * SIZE argv_ele].argpointer  ; s = argv[1];
        OR      SI,SI                           ;   if (s == NULL)
        JNZ     DoParse
        MOV     SI,BP                           ;       s = bp; (buffer end)

DoParse:
        MOV     DI,FCB
        MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
        INT     21h
        MOV     [PARM1],AL                      ; Save result of parse

        mov     DI, arg.argv[1*SIZE argv_ele].argsw_word
        mov     [ARG1S], DI
        mov     SI, arg.argv[2*SIZE argv_ele].argpointer    ; s = argv[2];
        OR      SI,SI                           ;   if (s == NULL)
        JNZ     DoParse2
        MOV     SI,BP                           ;       s = bp; (bufend)1

DoParse2:
        MOV     DI,FCB+10H
        MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
        INT     21h                     ; Parse file name
        MOV     [PARM2],AL                      ; Save result

        mov     DI, arg.argv[2*SIZE argv_ele].argsw_word
        mov     [ARG2S], DI
        mov     DI, arg.argv[0].argsw_word
        not     DI                              ; ARGTS doesn't include the flags
        and     DI, arg.argswinfo               ; from COMSW...
        mov     [ARGTS], DI

        MOV     AL,[IDLEN]
        MOV     DL,[SPECDRV]
        or      DL, DL                          ; if a drive was specified...
        jnz     externalj1                      ; it MUST be external, by this time
        dec     al                              ; (I don't know why -- old code did it)
        jmp     fndcom                          ; otherwise, check internal com table

externalj1:
        jmp     external

nullcom:
        mov     [EXECPATH_SIZE], 0
        MOV     DS,cs:[RESSEG]
ASSUME  DS:RESGROUP
        TEST    [BATCH], -1                     ;G Are we in a batch file?
        JZ      nosetflag                       ;G only set flag if in batch
        mov     nullflag,nullcommand            ;G set flag to indicate no command

nosetflag:
        CMP     [SINGLECOM],-1
        JZ      EXITJ
        JMP     GETCOM

EXITJ:
        JMP     $EXITPREP

IF IBM
        include vector.inc
        include pdb.inc
        include arena.inc
        include mshalo.asm
ENDIF

std_invalid macro
        mov     ax,0ffffh
        push    ax
        push    ax
endm

std_valid macro
        push    bx
        push    cx
endm

CleanForStd macro
        add     sp,12
endm

DoReEnter:
        ASSUME  DS:RESGROUP

        cmp     byte ptr [scs_reentered],3
        jne     reent_chk

; Control comes here after command /z ran a non-dos binary and
; we re-entered. We just make scs_reentered as 2 indicating that on next
; time we need to return the exit code to 32bit side.

        mov     byte ptr [scs_reentered],2
        jmp     reent

reent_chk:
        cmp     byte ptr [scs_reentered],2
        jne     reent_cont
        jmp     retcode32

reent_cont:
        cmp     byte ptr [scs_reentered],0
        je      exec_comspec
        jmp     reent_ret

; Control comes here when we have to exec either command.com or
; cmd.exe. This decision depends on scs_cmdprompt. Here we
; mark scs_reentered state as 1 indicating on return to handle
; exit code.

exec_comspec:

        mov     byte ptr [scs_reentered],1
        cmp     byte ptr [scs_cmdprompt],Prompt32
        je      do32bitprompt
        mov     al,Start16      ; parameter to put prompt
        mov     ah,FOR_SHELLOUT
        call    Do16BitPrompt       ; ds is resseg here on return its transseg
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jz      dos_only
        jmp     reent
dos_only:
        jmp     GotCom              ; go run through int21/exec

do32BitPrompt:
        SAVE    <bp,bx,si>
        xor     bx,bx
        mov     si,bx
        mov     bp,bx
        mov     ax,5303h
        int     21h
        jnc     st_stdin
        std_invalid
        jmp     short go_stdout
st_stdin:
        std_valid
go_stdout:
        mov     bx,1
        mov     ax,5303h
        int     21h
        jnc     st_stdout
        std_invalid
        jmp     short go_stderr
st_stdout:
        std_valid
go_stderr:
        mov     bx,2
        mov     ax,5303h
        int     21h
        jnc     st_stderr
        std_invalid
        jmp     short std_done
st_stderr:
        std_valid
std_done:
        mov     bp,sp
        push    es
        mov     es,[envirseg]
        mov     ah,19h
        int     21h
        CMDSVC  SVC_EXECCOMSPEC32
        pop     es
        mov     bp,ax
        lahf
        CleanForStd
        sahf
        mov     ax,bp
        RESTORE <si,bx,bp>

        jc      reent

        jmp     reent_exit

reent_ret:
        ; ds is already set to RESSEG
        cmp     byte ptr [scs_cmdprompt],Prompt32
        je      retcode32
        mov     al,return16
        mov     ah,FOR_SHELLOUT
        call    Do16BitPrompt       ; ds = resseg , on return its transseg
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jnz     reent
        jmp     dos_only

retcode32:
        mov     dx,ds:[retcode]
        mov     ah,19h
        int     21h                             ; al = cur drive
        mov     cx,word ptr ds:[RES_RDRINFO]
        mov     bx,word ptr ds:[RES_RDRINFO+2]  ; bx:cx - rdrinfo
        CMDSVC  SVC_RETURNEXITCODE
        mov     ds:[retcode],0
        jnc     reent_exit
reent:
        push    cs
        pop     ds
        assume  ds:trangroup
        mov     [scs_tsrexit],0
        jmp     DRE_RET

reent_exit:
ASSUME  DS:RESGROUP
        push    ax
        mov     ax,(multdos shl 8 or message_2f);AN060; reset parse message pointers
        mov     dl,set_critical_msg             ;AN000; set up critical error message address
        mov     di,crit_msg_off                 ;AN000; old offset of critical messages
        mov     es,crit_msg_seg                 ;AN000; old segment of critical messages
        int     2fh                             ;AN000; go set it

        push    cs
        pop     ds
assume  ds:trangroup                            ;AN000;

; Restore user directory if the restore flag is set. RestUDir1 checks for
; this, restores user dir if flag is set and resets the flag.

        invoke  RestUDir1               ;restore user dir if needed ;M040
        MOV     ES,cs:[RESSEG]

assume  es:resgroup

        MOV     AX,[PARENT]
        MOV     WORD PTR ES:[PDB_Parent_PID],AX
        MOV     AX,WORD PTR OldTerm
        MOV     WORD PTR ES:[PDB_Exit],AX
        MOV     AX,WORD PTR OldTerm+2
        MOV     WORD PTR ES:[PDB_Exit+2],AX

        PUSH    ES
        MOV     ES,[TRAN_TPA]
        MOV     AH,DEALLOC
        INT     21h                     ; Now running in "free" space
        POP     ES

        pop     ax
        MOV     AH,Exit
        INT     21h

; Entry al = Start16 means  put the command.com prompt, get the command
;            return16 means return the exit code if needed
;       ah = FOR_SHELLOUT means came from shellout code (DoReEnter)
;       ah = FOR_TSR      means came from TSR (tsr_loop)
;
; Exit  al = 0 means run 16bit binary
;       al = 1 means do getnextvdmcommand
;       if came with FOR_TSR, then additionaly
;       ah = 1 means returning on exit command
;       ah = 0 means otherwise

Do16BitPrompt:
        push    es
        push    ax
        mov     es,cs:[RESSEG]                  ; es is resident group
        ASSUME  ES:resgroup
    PUSH    CS
        POP     DS                              ; Need local segment to point to buffer
        assume  ds:trangroup
        cmp     al,Start16
ifdef DBCS
        je      @F
        jmp     d16_ret
@@:
else ; !DBCS
        jne     d16_ret
endif ; !DBCS

d16_loop:
ifdef DBCS
;;; williamh  Sept 24 1993, removed it. Not necessary to show two line feed
;;; for every command.
;;; yasuho 12/9/93  It is necessary. for example, if previous command
;;; didn't follow CR+LF before terminate, prompt will show on the strange
;;; position.
endif ; DBCS
        INVOKE  CRLF2
        INVOKE  PRINT_PROMPT                    ; put the prompt
ifdef DBCS  ;; this should go to US build also
;; reset the title
    xor al, al
    CMDSVC  SVC_SETWINTITLE
endif ; DBCS
    MOV DX,OFFSET TRANGROUP:UCOMBUF

        mov     ah,STD_CON_STRING_INPUT         ; AH = Buffered Keyboard Input
        int     21h                             ; call DOS
ifdef DBCS_NT31J
;; special case for CR was added the original source.
;; this code doesn't need. 04/07/94 (hiroh)
    ;; #3920: CR+LFs are needed when using 32bit command
    ;; 12/9/93 yasuho
    ;; not necessary CR+LF if nothing to do
    push    bx
    mov bx, dx
    cmp byte ptr [bx + 1], 0        ; only CR ?
    pop bx
    je  @F              ; yes. no neccessary CRLF
        INVOKE  CRLF2
@@:
endif ; DBCS_NT31J

        push    si
        mov     si,dx
        inc     si
        inc     si
        INVOKE  SCANOFF                         ; eat leading delimeters

        cmp     byte ptr ds:[si],0dh            ; special case CR
        jne     d16_gotcom
        pop     si
        jmp     d16_loop

d16_gotcom:
ifdef DBCS  ;; this should go to US build also
;; update the new command to the title
    mov al, 1
    CMDSVC  SVC_SETWINTITLE
endif ; DBCS
        INVOKE  CRLF2
        call    check_command                   ; check for exit and cd
        pop     si
        jnc     d16_run

        or      al,al
ifdef DBCS
        jnz @F
    jmp d16_exit
@@:
else ; !DBCS
        jz      d16_exit
endif ; !DBCS

d16_dosonly:
        mov     byte ptr es:[scs_prompt16],0
        pop     ax
        xor     ax,ax           ; go run the command
        pop     es
        ret

d16_run:
        cmp     byte ptr es:[scs_dosonly], DOSONLY_YES
        je      d16_dosonly

        push    es
        push    bp
        push    si
        mov     ax,0ffffh
        push    ax              ; no standard handle to pass
        push    ax
        push    ax
        push    ax
        push    ax
        push    ax
        mov     bp,sp           ; ss:bp is standard handles
        mov     es,es:[envirseg]
        mov     si,dx
        add     si,2            ; first two bytes are the count, after that real command
        mov     ah,19h
        int     21h             ; al = cur drive
ifdef NEC_98
        jmp     Clrfky2
FKY_OFF2        DB      1Bh,'[>1h$'             ;ESC sequence of FKY off
Clrfky2:        push    ds
        push    cs
        pop     ds
        push    cx
        push    ax
        push    dx
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_OFF2
        int     0DCH                            ;FKY off
        pop     dx
        pop     ax
        pop     cx
        pop     ds
endif   ;NEC_98
        mov     ah,1            ; do cmd /c
        CMDSVC  SVC_CMDEXEC     ; Exec through cmd
ifdef NEC_98
        pushf
        push    ds
        push    cx
        push    ax
        push    dx

        CMDSVC  SVC_GETCURSORPOS                ;gets bios cursor position
                                                ;now dx=offset on TEXT VRAM
        mov     ax,dx
        mov     cl,160
        div     cl
        mov     dh,al
        xor     dl,dl
        mov     cl,10h
        mov     ah,03h
        int     0DCH                            ;set cursor position for DOS

        jmp     Dspfky2
FKY_ON2 DB      1Bh,'[>1l$'                     ;ESC sequence of FKY on
Dspfky2:        push    cs
        pop     ds
        mov     cl,10H
        mov     ah,01H
        mov     dx,offset FKY_ON2
        int     0DCH                            ;FKY on

        pop     dx
        pop     ax
        pop     cx
        pop     ds
        popf
endif   ;NEC_98
        lahf
        add     sp,12           ; recover std handle space
        pop     si
        pop     bp
        pop     es
        sahf

ifndef NEC_98
        jnc    d16_loop         ; command completed, go put the prompt
else    ;NEC_98
        jc      @F
        jmp     d16_loop
@@:
endif   ;NEC_98

        ; carry set means re-entered
d16_retback:
        mov     byte ptr es:[scs_prompt16],1   ; mark that on return we have
                                            ; to go to 32bit with retcode
        pop     ax
        mov     ax,1                        ; go do getnextvdmcommand
        pop     es
        ret

d16_ret:
        cmp     byte ptr es:[scs_prompt16],0   ; mark 0 to mean to come back
                                            ; and put prompt fro next command
ifdef DBCS
        jne @F
        jmp     d16_loop
@@:
else ; !DBCS
        je      d16_loop
endif ; !DBCS


d16_return32:
        push    dx
        mov     dx,es:[retcode]
        mov     ah,19h
        int     21h                             ; al = cur drive
        mov     cx,word ptr es:[RES_RDRINFO]
        mov     bx,word ptr es:[RES_RDRINFO+2]  ; bx:cx - rdrinfo
        CMDSVC  SVC_RETURNEXITCODE
        pop     dx
        mov     es:[retcode],0
        jc      d16_retback
        mov     byte ptr es:[scs_prompt16],0
        jmp     d16_loop


d16_exit:
        ; exit command was given, turn off the lights

        pop     ax
        cmp     ah,FOR_TSR
        je      d16_exittsr
        jmp     reent_exit

d16_exittsr:
        mov     ah,1
        pop     es
        ret


; check if the typed command is one of the commands in NT_INTRL_CMND, if
; so return carry set plus al = 0 if the command was "exit".
;
; input ds:si is the command buffer
; si can be trashed.

check_command:

        SAVE    <CX,DI,ES>

        cmp     byte ptr ds:[si+1],':'      ; special case drive change i.e C:
        jne     cc_0
        mov     al,byte ptr ds:[si+2]
        cmp     al,0dh                      ; DELIM for some reason does'nt
        je      ok_delim                    ; include 0d
        invoke  DELIM
        jnz     no_match
ok_delim:
        mov     al,1                        ; Not exit command
ok_xt:
        stc                                 ; Carry means command found
        jmp     short cc_ret

no_match:
        clc                                 ; Carry clear, command not found
cc_ret:
        RESTORE <ES,DI,CX>
        ret

cc_0:
        push    si
        xor     cx,cx

        ; Convert the source string to upper case and get the length
cc_1:
        mov     al,byte ptr ds:[si]
        invoke  DELIM
        jz      go_look
        invoke  MOREDELIM
        jz      go_look

        INVOKE  UPCONV
        mov     byte ptr ds:[si],al
        inc     si
        inc     cx
        jmp     short cc_1

go_look:
        pop     si
        jcxz    no_match                            ; zero length, go fail
        mov     di, OFFSET TRANGROUP:NT_INTRNL_CMND
        push    cs
        pop     es

        ; search through the commands in the table
cc_5:
        push    si
        push    di
        push    cx
        cmp     cl, byte ptr es:[di]
        jne     try_next
        inc     di
        repz    cmpsb
        jnz     try_next
        jmp     short cc_found

try_next:
        pop     cx
        pop     di
        pop     si
        mov     al,byte ptr es:[di]
        or      al,al
        jz      no_match
        xor     ah,ah
        add     ax,di
        mov     di,ax
        add     di,2
        jmp     short cc_5

cc_found:
        mov     al, byte ptr es:[di]                ; Is it exit command
        pop     cx
        pop     di
        pop     si
        jmp     short ok_xt

;
; Input:    AL is character to classify
; Output:   Z set if delimiter
;       NZ set otherwise
; Registers modified: none
;

MOREDELIM:
        cmp     al,0dh
        retz
        cmp     al,'/'
        retz
        cmp     al,'\'
        retz
        cmp     al,'.'
        retz
        cmp     al,'<'
        retz
        cmp     al,'>'
        retz
        cmp     al,'|'
        retz
        cmp     al,'"'
        retz
        cmp     al,'+'
        retz
        cmp     al,':'
        retz
        cmp     al,';'
        retz
        cmp     al,'['
        retz
        cmp     al,']'
        return



free_con:
        push    ds
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        xor     bx,bx                           ; BX = handle = 0
        mov     cx,Io_Save                      ; CX = original stdin, stdout
        mov     dx,word ptr ds:Pdb_Jfn_Table    ; DX = current stdin, stdout
        cmp     cl,dl
        je      Chk1                    ; stdin matches
        mov     ah,CLOSE
        int     21h                     ; close stdin
        mov     ds:Pdb_Jfn_Table,cl     ; restore stdin
Chk1:
        inc     bx                      ; BX = handle = 1
        cmp     ch,dh
        je      Chk2                    ; stdout matches
        mov     ah,CLOSE
        int     21h                     ; close stdout
        mov     ds:Pdb_Jfn_Table+1,ch   ; restore stdout
Chk2:
        inc     bx                      ; BX = handle = 2
        mov     dl,byte ptr ds:[Pdb_Jfn_Table+2]        ; Dl = current stderr
        mov     cl,Io_Stderr            ; Cl = original stderr
        cmp     dl,cl
        je      chk_x                   ; stderr matches
        mov     ah,CLOSE
        int     21h                     ; close stderr
        mov     ds:Pdb_Jfn_Table+2,cl   ; restore stderr
chk_x:
        pop     ds
        ret

alloc_con:
    SAVE    <DX,SI,BP,BX,DS>
        MOV     DS,cs:[RESSEG]
        ASSUME  DS:RESGROUP
        push    cx
        pop     ax
        mov     bx, offset Pdb_Jfn_Table
        add     bx,ax
        mov     al,byte ptr ds:[bx]
        push    ax
        push    bx
        mov     byte ptr ds:[bx],0ffh

        mov     bx,word ptr ds:[RES_RDRINFO]
        mov     ax,word ptr ds:[RES_RDRINFO+2]

        CMDSVC  SVC_GETSTDHANDLE                ; std hanlde in bx:cx
        jc      alloc_err
;; bx:cx  = nt file handle
;; dx:ax = file size
    push    di
    mov di, ax
        xor     si,si
        xor     bp,bp
        mov     al,0                            ; free original console
        mov     ah,setdpb
        int     21h
    pop di
        jc      alloc_err
        pop     bx
        pop     ax
    RESTORE     <DS,BX,BP,SI,DX>
        ret

alloc_err:
        pop     bx
        pop     ax
        mov     byte ptr ds:[bx],al
    RESTORE     <DS,BX,BP,SI,DX>
        ret


; ds for tsr_loop is resseg on entry on exit transseg

        ASSUME  DS:RESGROUP

tsr_loop:
        cmp     byte ptr ds:[scs_cmdprompt],Prompt32
        je      tsr_ret

        cmp     byte ptr ds:[res_batstatus],0
        je      short tsr_nobat
        cmp     byte ptr ds:[scs_firsttsr],1
        jne     short tsr_retcode
        jmp     tsr_ret

tsr_nobat:

        CMDSVC  SVC_GETSTARTINFO     ; return al = 1, if vdm has to
                                    ; terminate on app exit.
        or      al,al
        jne     tsr_ret

        cmp     byte ptr [scs_firsttsr],1
        jne     tsr_retcode

        cmp     word ptr ds:[RES_RDRINFO],0
        je      tsr_nordr
        cmp     word ptr ds:[RES_RDRINFO+2],0
        jne     tsr_ret
tsr_nordr:
        mov     byte ptr ds:[scs_firsttsr],0
        mov     al,Start16          ; parameter to put prompt
        mov     ah,FOR_TSR
        call    Do16BitPrompt       ; ds is resseg here on return its transseg
        or      ah,ah
        jnz     tsr_exit
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jz      tsr_dosonly
        jmp     tsr_ret
tsr_dosonly:
        jmp     GotCom              ; go run through int21/exec

tsr_retcode:
        mov     al,return16         ; parameter to retun exit code if needed
        mov     ah,FOR_TSR
        call    Do16BitPrompt       ; ds = resseg , on return its transseg
        or      ah,ah
        jnz     tsr_exit
        or      al,al               ; return al=0 to run 16bit binary al=1 getnextvdmcommand
        jnz     tsr_ret
        jmp     GotCom

tsr_exit:
        push    cs
        pop     ds
        assume  ds:trangroup
        mov     [scs_tsrexit],1
tsr_ret:
        jmp     tsr_loop_ret


TRANCODE        ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tfor.asm ===
page ,132
;	SCCSID = @(#)tfor.asm	4.1 85/09/17
;	SCCSID = @(#)tfor.asm	4.1 85/09/17
TITLE	Part3 COMMAND Transient Routines
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;     For loop processing routines


.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include find.inc
	include devsym.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BATCH:WORD
	EXTRN	ECHOFLAG:BYTE
	EXTRN	FORFLAG:BYTE
	EXTRN	FORPTR:WORD
	EXTRN	NEST:WORD
	EXTRN	NULLFLAG:BYTE
	EXTRN	PIPEFILES:BYTE
	EXTRN	SINGLECOM:WORD
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	Extend_buf_ptr:word	;AN000;
	extrn	fornestmes_ptr:word
	EXTRN	msg_disp_class:byte	;AN000;
	extrn	string_buf_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	extrn	arg:byte		; the arg structure!
	EXTRN	COMBUF:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near
	EXTRN	docom:near
	EXTRN	docom1:near
	EXTRN	forerror:near
	EXTRN	tcommand:near

	PUBLIC	$for
	PUBLIC	forproc


; All batch proccessing has DS set to segment of resident portion
ASSUME	DS:RESGROUP,ES:TRANGROUP


FORTERM:
	push	cs				;AN037; Get local segment into
	pop	ds				;AN037;    DS, ES
	push	cs				;AN037;
	pop	es				;AN037;
	call	ForOff
	mov	ds,ResSeg
ASSUME	DS:RESGROUP
	CMP	[SINGLECOM],0FF00H
	JNZ	BATCRLF
	CMP	NEST,0				;G See if we have nested batch files
	JNZ	BATCRLF 			;G Yes - don't exit just yet
	MOV	[SINGLECOM],-1			; Cause a terminate
	JMP	SHORT NOFORP2

BATCRLF:
	test	[ECHOFLAG],1			;G  Is echo on?
	JZ	NOFORP2 			;G  no - exit
	TEST	[BATCH], -1			;G  print CRLF if in batch
	JZ	NOFORP2 			;G
	invoke	CRLF2

NOFORP2:
	JMP	TCOMMAND


;------
;   For-loop processing.  For loops are of the form:
;	    for %<loop-variable> in (<list>) do <command>
; where <command> may contain references of the form %<variable>, which are
; later substituted with the items in <list>.  The for-loop structure is
; set-up by the procedure '$for'; successive calls to 'forproc' execute
; <command> once for each item in <list>.  All of the information needed for
; loop processing is stored on a piece of memory gotten from 'alloc'.  This
; structure is actually fairly large, on the order of 700 bytes, and includes
; a complete copy of the original command-line structure as parsed by
; 'parseline', loop control variables, and a dma buffer for the
; 'FindFirst/FindNext' expansion of wildcard filenames in <list>.  When loop
; processing has completed, this chunk of memory is returned to the system.
;
;   All of the previously defined variables, in 'datares', used for loop
; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
;
;   The error message, 'for_alloc_mes', should be moved into the file
; containing all of the other error messages.
;
;   Referencing the allocated for-loop structure is a little tricky.
; At the moment, a byte is defined as part of a new segment, 'for_segment'.
; When 'forproc' actually runs, ES and DS are set to point to the base of the
; new chunk of memory.	References to this byte, 'f', thus assemble correctly
; as offsets of ES or DS.  'f' would not be necessary, except that the
; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
; immediate move of the offset of 'for_minarg' into AX.  In other words, in
; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
;	mov	AX, #for_minarg 	; AX := 02CA (for example)
; instead of
;	mov	AX, for_minarg		; AX := [02CA] (contents of 02CA)
; By using 'f', we pretend that we are actually referencing an allocated
; structure, and the assembler coughs up the code we want.  Notice that it
; doesn't matter whether we put brackets around the location or not -- the
; assembler is "smart" enough to know that we want an address instead of the
; contents of that location.
;
;   Finally, there now exists the potential to easily implement nested loops.
; One method would be to have a link field in each for-structure pointing to
; its parent.  Variable references that couldn't be resolved in the local
; frame would cause a search of prior frames.  For-structures would still be
; allocated and released in exactly the same fashion.  The only limit on the
; number of nested loops would be memory size (although at 700 bytes a pop,
; memory wouldn't last THAT long).  Alternately, a small structure could be
; maintained in the resident data area.  This structure would be an array of
; control-variable names and pointers to for-structure blocks.	This would
; greatly speed up the resolution of non-local variable references.  However,
; since space in the resident is precious, we would have to compromise on a
; "reasonable" level of nesting -- 10, 16, 32 levels, whatever.  For-structure
; allocation and de-allocation would have to be modified slightly to take this
; new structure into account.
;
;   Oops, just one more thing.	Forbuf need not be a part of the for-structure.
; It could just as well be one structure allocated in 'transpace'.  Actually,
; it may be easier to allocate it as part of 'for_segment'.
;------

	include fordata.asm

$for_exit:
	jmp	forterm 			; exceeding maxarg means all done

forproc:
assume	DS:resgroup
	mov	AX, [ForPtr]
	mov	DS, AX
	mov	ES, AX				; operate in for-info area
assume	DS:for_segment, ES:for_segment

	mov	DX, fordma
	trap	Set_Dma
for_begin:
	cmp	f.for_expand, 0 		; non-zero for_expand equals FALSE
	je	for_begin1
	inc	f.for_minarg
for_begin1:
	mov	BX, f.for_minarg		; current item in <list> to examine
	cmp	BX, f.for_maxarg
	jg	$for_exit			; exceeding maxarg means all done
	mov	AX, for_args.argv
	invoke	argv_calc			; compute argv[x] address

	mov	CX, [BX].argstartel
	mov	DX, [BX].argpointer
	test	[bx].argflags,00000100b 	; Is there a path separator in this arg?
	jnz	forsub				; Yes, argstartel should be correct
	mov	si, [BX].argpointer
	mov	al,lparen
	cmp	byte ptr [si-1],al		; If the current token is the first
	jnz	forsub				;  one in the list and originally had
	inc	cx				;  the opening paren as its first char,
						;  the argstartel ptr needs to be
						;  advanced passed it before the prefix
						;  length is computed.
	mov	al,':'
	cmp	byte ptr [si+1],al		; If the token begins with "(d:",
	jnz	forsub				;  argstartel has to be moved over the
	add	cx,2				;  rest of the prefix as well.

forsub:
	sub	CX, DX				; compute length of pathname prefix
	cmp	f.for_expand, 0 		; are we still expanding a name?
	je	for_find_next			; if so, get next matching filename

	test	[BX].argflags, MASK wildcard
	jnz	for_find_first			; should we expand THIS (new) arg?
	mov	CX, [BX].arglen 		; else, just copy all of it directly
	jmp	short for_smoosh

for_find_first:
	PUSH	CX
	XOR	CX,CX
	trap	Find_First			; and search for first filename match
	POP	CX
	jmp	short for_result
for_find_next:
	trap	Find_Next			; search for next filename match

for_result:
	mov	AX, -1				; assume worst case
	jc	forCheck
	mov	ax,0
forCheck:					; Find* returns 0 for SUCCESS
	mov	f.FOR_EXPAND, AX		; record success of findfirst/next
	or	AX, AX				; anything out there?
	jnz	for_begin			; if not, try next arg

for_smoosh:
	mov	SI, [BX].argpointer		; copy argv[arg][0,CX] into destbuf
	mov	DI, forbuf			; some days this will be the entire
	rep	movsb				; arg, some days just the path prefix

	cmp	f.FOR_EXPAND, 0 		; if we're not expanding, we can
	jnz	for_make_com			; skip the following

	mov	SI, fordma.find_buf_pname
for_more:					; tack on matching filename
	cmp	BYTE PTR [SI], 0
	je	for_make_com
	movsb
	jnz	for_more

for_make_com:
	xor	AL, AL				; tack a null byte onto the end
	stosb					; of the substitute string

	xor	CX, CX				; character count for command line
	not	CX				; negate it -- take advantage of loopnz
	xor	BX, BX				; argpointer
	mov	DI, OFFSET TRANGROUP:COMBUF+2
	mov	bl, f.FOR_COM_START		; argindex
	mov	DH, f.FOR_VAR			; %<for-var> is replaced by [forbuf]
						; time to form the <command> string
	push	CS
	pop	ES
assume	ES:trangroup

	mov	AX, for_args			; translate offset to pointer
	invoke	argv_calc
	mov	si,[bx].arg_ocomptr
	inc	si				; mov ptr passed beginning space

for_make_loop:
	mov	al,[si] 			; the <command> arg, byte by byte
	inc	si
	cmp	AL,'%'                          ; looking for %<control-variable>
	jne	for_stosb			; no % ... add byte to string
	cmp	BYTE PTR [SI], DH		; got the right <variable>?
	jne	for_stosb			; got a %, but wrong <variable>
	inc	SI				; skip over <for-variable>

	push	SI
	mov	SI, forbuf			; substitute the <item> for <variable>
						; to make a final <command> to execute
sloop:
	lodsb					; grab all those <item> bytes, and
	stosb					; add 'em to the <command> string,
	or	AL, AL				; until we run into a null
	loopnz	sloop
	dec	DI				; adjust length and <command> pointer
	inc	CX				; so we can overwrite the null

	pop	SI
	jmp	for_make_loop			; got back for more <command> bytes
for_stosb:
	stosb					; take a byte from the <command> arg
	dec	CX				; and put it into the <command> to be
						; executed (and note length, too)
	cmp	al,0dh				; If not done, loop.
	jne	for_make_loop

for_made_com:					; finished all the <command> args
	not	CL				; compute and record command length
	mov	[COMBUF+1], CL

	mov	DS, [RESSEG]
assume	DS:resgroup

	test	[ECHOFLAG],1			; shall we echo this <command>, dearie?
	jz	noecho3
	cmp	nullflag,nullcommand		;G was there a command last time?
	jz	No_crlf_pr			;G no - don't print crlf
	invoke	CRLF2				;G  Print out prompt

no_crlf_pr:
	mov	nullflag,0			;G reset no command flag
	push	CS
	pop	DS
	assume	DS:trangroup
	push	di
	invoke	PRINT_PROMPT			;G Prompt the user
	pop	di
	mov	BYTE PTR ES:[DI-1],0		; yeah, PRINT it out...
	mov	string_ptr_2,OFFSET TRANGROUP:COMBUF+2
	mov	dx,offset trangroup:string_buf_ptr
	invoke	std_printf
	mov	BYTE PTR ES:[DI-1], 0DH
	jmp	DoCom
noecho3:					; run silent, run deep...
	assume	DS:resgroup
	mov	nullflag,0			;G reset no command flag
	push	CS
	pop	DS
	assume	DS:trangroup
	jmp	docom1


fornesterrj:					; no multi-loop processing... yet!
assume	ES:resgroup
	call	ForOff
	jmp	fornesterr

forerrorj:
	jmp	forerror

	break	$For
assume	ds:trangroup,es:trangroup

$for:
	mov	ES, [RESSEG]
assume	ES:resgroup

	cmp	ForFlag,0			; is another one already running?
	jnz	fornesterrj			; if flag is set.... boom!

;
; Turn off any pipes in progress.
;
	cmp	[PIPEFILES],0			; Only turn off if present.
	jz	NoPipe
	invoke	PipeDel
NoPipe:
	xor	DX, DX				; counter (0 <= DX < argvcnt)
	call	nextarg 			; move to next argv[n]
	jc	forerrorj			; no more args -- bad forloop
	cmp	AL,'%'                          ; next arg MUST start with '%'...
	jne	forerrorj
	mov	BP, AX				; save forloop variable
	lodsb
	or	AL, AL				; and MUST end immediately...
	jne	forerrorj

	call	nextarg 			; let's make sure the next arg is 'in'
	jc	forerrorj
	and	AX, NOT 2020H			; uppercase the letters
	cmp	AX, in_word
	jne	forerrorj
	lodsb
	or	AL, AL				; it, too, must end right away

; Compaq bug fix -- exit from this loop on error

ifndef NEC_98
	jne	forerrorj			; jump on error

;;	je	CheckLParen
else    ;NEC_98
;;      jne     forerrorj                       ; jump on error ;NEC00

        je      CheckLParen
endif   ;NEC_98
;
; Not null.  Perhaps there are no spaces between this and the (:
;   FOR %i in(foo bar...
; Check for the Lparen here
;
ifndef NEC_98
;;	CMP	AL,lparen
;;	JNZ	forerrorj
else    ;NEC_98
        CMP     AL,lparen
        JNZ     forerrorj
endif   ;NEC_98
;
; The token was in(...	We strip off the "in" part to simulate a separator
; being there in the first place.
;
ifndef NEC_98
;;	ADD	[BX].argpointer,2		; advance source pointer
;;	ADD	[BX].arg_ocomptr,2		; advance original string
;;	SUB	[BX].arglen,2			; decrement the appropriate length
else    ;NEC_98
        ADD     [BX].argpointer,2               ; advance source pointer
        ADD     [BX].arg_ocomptr,2              ; advance original string
        SUB     [BX].arglen,2                   ; decrement the appropriate length
endif   ;NEC_98
;
; SI now points past the in(.  Simulate a nextarg call that results in the
; current value.
;
ifndef NEC_98
;;	MOV	ax,[si-1]			; get lparen and next char
;;	jmp	short lpcheck
else    ;NEC_98
        MOV     ax,[si-1]                       ; get lparen and next char
        jmp     short lpcheck
endif   ;NEC_98
;
;; end of Compaq bug fix

CheckLParen:
	call	nextarg 			; lparen delimits beginning of <list>
	jc	forerrorj
lpcheck:
	cmp	al, lparen
	jne	forerrorj
	cmp	ah,0
	je	for_paren_token

	cmp	ah, rparen			; special case:  null list
	jne	for_list_not_empty
	jmp	forterm

for_list_not_empty:
	inc	[bx].argpointer 		; Advance ptr past "("
						; Adjust the rest of this argv entry
	dec	[bx].arglen			;  to agree.
	inc	si				; Inc si so check for ")" works
	jmp	short for_list

for_paren_token:
	call	nextarg 			; what have we in our <list>?
	jc	forerrorj
	cmp	ax, nullrparen			; special case:  null list
	jne	for_list
	jmp	forterm

forerrorjj:
	jmp	forerror

for_list:					; skip over rest of <list>
	mov	CX, DX				; first arg of <list>
skip_list:
	add	si,[bx].arglen
	sub	si,3				; si = ptr to last char of token
	mov	al,rparen
	cmp	byte ptr [si],al		; Is this the last element in <list>
	je	for_end_list			; Yes, exit loop.
	call	nextarg 			; No, get next arg <list>
	jc	forerrorjj			; If no more and no rparen, error.
	jmp	skip_list
for_end_list:
	mov	DI, DX				; record position of last arg in <list>
	mov	byte ptr [si],0 		; Zap the rparen
	cmp	ax,nullrparen			; Was this token only a rparen
	jz	for_do				; Yes, continue
	inc	di				; No, inc position of last arg

for_do:
	call	nextarg 			; now we had BETTER find a 'do'...
	jc	forerrorjj
	and	AX, NOT 2020H			; uppercase the letters
	cmp	AX, do_word
	jne	forerrorjj
	lodsb
	or	AL, AL				; and it had BETTER be ONLY a 'do'...
	jne	forerrorjj

	call	nextarg 			; on to the beginning of <command>
	jc	forerrorjj			; null <command> not legal

	push	AX
	push	BX
	push	CX
	push	DX				; preserve registers against disaster
	push	DI
	push	SI
	push	BP
	invoke	FREE_TPA			; need to make free memory, first
ASSUME	ES:RESGROUP
	call	ForOff
	mov	BX, SIZE for_info - SIZE arg_unit
	invoke	Save_Args			; extra bytes needed for for-info
	pushf
	mov	[ForPtr], AX
	invoke	ALLOC_TPA			; ALLOC_TPA clobbers registers...
	popf
	pop	BP
	pop	SI
	pop	DI
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	jc	for_alloc_err

	push	ES				; save resgroup seg...
	push	[ForPtr]
	pop	ES
assume	ES:for_segment				; make references to for-info segment

	dec	CX				; forproc wants min pointing before
	dec	DI				; first arg, max right at last one
	mov	f.for_minarg, CX
	mov	f.for_maxarg, DI
	mov	f.for_com_start, DL
	mov	f.for_expand, -1		; non-zero means FALSE
	mov	AX, BP
	mov	f.for_var, AH
	pop	ES
assume	ES:resgroup

	inc	[FORFLAG]
	cmp	[SINGLECOM], -1
	jnz	for_ret
	mov	[SINGLECOM], 0FF00H
for_ret:
	ret

for_alloc_err:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr     ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,error_not_enough_memory ;AN000; get message number in control block
	jmp	cerror

nextarg:
	inc	DX				; next argv[n]
	cmp	DX, arg.argvcnt 		; make sure we don't run off end
	jge	nextarg_err			; of argv[]...
	mov	BX, DX
	mov	AX, OFFSET TRANGROUP:arg.argv
	invoke	argv_calc			; convert array index to pointer
	mov	SI, [BX].argpointer		; load pointer to argstring
	lodsw					; and load first two chars
	clc
	ret
nextarg_err:
	stc
	ret


ASSUME	DS:TRANGROUP,ES:TRANGROUP

FORNESTERR:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	DX,OFFSET TRANGROUP:FORNESTMES_ptr
	CMP	[SINGLECOM],0FF00H
	JNZ	NOFORP3
	MOV	[SINGLECOM],-1			; Cause termination
NOFORP3:
	POP	DS
ASSUME	DS:TRANGROUP
	JMP	CERROR
;
; General routine called to free the for segment.  We also clear the forflag
; too.	Change no registers.
;
PUBLIC ForOff
ForOff:
	assume DS:NOTHING,ES:NOTHING
	SaveReg <AX,ES>
	mov	es,ResSeg
	assume	es:ResGroup
	mov	AX,ForPtr
	or	ax,ax
	jz	FreeDone
	push	es
	mov	es,ax
	mov	ah,dealloc
	int	21h
	pop	es
FreeDone:
	mov	ForPtr,0
	mov	ForFlag,0
	RestoreReg  <ES,AX>
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tenv2.asm ===
page ,132
;	SCCSID = @(#)tenv2.asm	1.1 85/05/14
;	SCCSID = @(#)tenv2.asm	1.1 85/05/14
TITLE	Part6 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	Environment utilities and misc. routines

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include find.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES SEGMENT PUBLIC BYTE		;AC000;
	EXTRN	pipeflag:byte
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ACRLF_PTR:WORD
	EXTRN	BadCD_Ptr:WORD
	EXTRN	Badmkd_ptr:word
	EXTRN	BADRMD_PTR:WORD
	EXTRN	Extend_buf_ptr:word	;AN000;
	EXTRN	Extend_buf_sub:byte	;AN022;
	EXTRN	MD_exists_ptr:word	;AN006;
	EXTRN	msg_disp_class:byte	;AC000;
	EXTRN	NOSPACE_PTR:WORD
	EXTRN	parse_chdir:byte	;AC000;
	EXTRN	parse_mrdir:byte	;AC000;
	EXTRN	PIPEEMES_PTR:WORD
	EXTRN	string_buf_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	CURDRV:BYTE
	EXTRN	DESTINFO:BYTE
	EXTRN	DESTTAIL:WORD
	EXTRN	DIRCHAR:BYTE
	EXTRN	dirflag:byte		;AN015;
	EXTRN	KPARSE:BYTE		;AC000;  3/3/KK
	EXTRN	msg_numb:word		;AN022;
	EXTRN	parse1_addr:dword	;AC000;
	EXTRN	parse1_type:byte	;AC000;
	EXTRN	PATHPOS:WORD
	EXTRN	RESSEG:WORD
	EXTRN	srcxname:byte		;AC000;
	EXTRN	string_ptr_2:word
	EXTRN	SWITCHAR:BYTE
	EXTRN	USERDIR1:BYTE
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC byte

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	cerror:near

	PUBLIC	$chdir
	PUBLIC	$mkdir
	PUBLIC	$rmdir
	PUBLIC	crlf2
	PUBLIC	crprint
	PUBLIC	delim
	PUBLIC	error_output
	PUBLIC	fcb_to_ascz
	PUBLIC	pathchrcmp
	PUBLIC	pathcrunch
	PUBLIC	savudir
	PUBLIC	savudir1
	PUBLIC	scanoff
	PUBLIC	strcomp

break	$Chdir

; ****************************************************************
; *
; * ROUTINE:	 $CHDIR
; *
; * FUNCTION:	 Entry point for CHDIR command. Parse the command
; *		 line. If path is found, CHDIR to path. If a drive
; *		 letter is found, get and display the current dir
; *		 of the specified drive. If nothing is found, get
; *		 and display the current dir of the default drive.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

$CHDIR:

	mov	si,81H
	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC018; call parser

	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	bwdJ				; No args
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	ChDirErr			;AC018; yes - exit

	cmp	parse1_type,result_drive	;AC000; was a drive entered?
	jnz	REALCD				; no
;
; D: was found.  See if there is anything more.
;
	mov	di,offset trangroup:parse_chdir ;AC000; get address of parse_chdir
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jnz	ChDirErr			;AC000;

bwdJ:
	invoke	build_dir_for_chdir		; Drive only specified
	call	crlf2
	return

REALCD:

	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of filespec
	invoke	move_to_srcbuf			;AN000; move to srcbuf
	pop	si				;AN000; restore position in line
	mov	di,offset trangroup:parse_chdir ;AC000; get address of parse_chdir
	xor	dx,dx				;AC000;
	invoke	parse_check_eol 		;AC000; call parser
	jnz	ChDirErr			;AC000;

	invoke	SETPATH
	TEST	[DESTINFO],2
	JNZ	BadChdir
	MOV	AH,CHDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	BadChDir			;AN022; yes - issue old message
;SR;
; We want to issue "Invalid Directory" message even if the path is valid
;but is not a directory. The extended error returns "Access denied" which
;is kind of confusing. Issue the old message if access denied error is 
;returned
;
	cmp	ax,error_access_denied
	jz	BadChDir

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short  chdirerr 		;AN022;

BadChDir:
	MOV	DX,OFFSET TRANGROUP:BADCD_ptr

ChDirErr:
	invoke	Std_Eprintf
	return

break	$Mkdir

assume	ds:trangroup,es:trangroup

$MKDIR:
	CALL	SETRMMK
	JC	MkDirErr
	MOV	AH,MKDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	MD_other_err			;AN022; yes - issue old message
	cmp	ax,error_access_denied		;AN022; access denied?
	jz	badmderr			;AN022; yes - see if file exists

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short MkDirerr			;AC022; yes - go print it

BADMDERR:
	mov	dx,offset trangroup:srcxname	;AN006; Set Disk transfer address
	mov	ah,Set_DMA			;AN006;
	int	21h			;AN006;
	MOV	AH,Find_First			;AN006; see if file/dir exists
	mov	cx,attr_directory		;AN006;   search for directory
	INT	21h			;AN006;
	jc	MD_other_err			;AN006; doesn't exist - must be something else
	mov	dl,srcxname.find_buf_attr	;AN006; we found a file/dir
	test	dl,attr_directory		;AN006; was it a directory?
	jz	MD_other_err			;AN006; no - must have been a file
	mov	dx,offset trangroup:MD_exists_ptr ;AN006; set up already exists error
	jmp	short MkDirErr			;AN006; make sure we didn't have network error
MD_other_err:					;AN006;
	MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
MkDirErr:
	invoke	Std_Eprintf
	return

Break	<Common MkDir/RmDir set up code>

;****************************************************************
;*
;* ROUTINE:	SETRMMK
;*
;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
;*		commands. Parses the command line for a required
;*		filespec.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	carry clear
;*		    DS:DX points to ASCIIZ argument
;*		carry set
;*		    DS:DX has error message pointer
;*
;****************************************************************

SETRMMK:
	mov	si,81H
	mov	di,offset trangroup:parse_mrdir ;AN000; Get adderss of PARSE_MRDIR
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	parse_with_msg			;AC000; call parser
	cmp	ax,result_no_error		;AC000; did we have an error?
	jnz	 NOARGERR			;AC000; yes - exit

	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
	push	di				;AN000; save address
	push	si				;AN000; save position in line
	lds	si,parse1_addr			;AN000; get address of path

mrdir_move_filename:				;AN000; put filespec in srcxname
	lodsb					;get a char from buffer
	stosb					;AN000; store in srcxname
	cmp	al,end_of_line_out		;AC000; it char a terminator?
	jnz	mrdir_move_filename		;AC000; no - keep moving
	pop	si				;AN000; get line position back

;
; we have scanned an argument.	See if any args beyond.
;

	mov	di,offset trangroup:parse_mrdir ;AC000; get address of parse_mrdir
	invoke	parse_check_eol 		;AC000; are we at end of line?
	pop	dx				;AC000; get address of SRCXNAME
	retz					;yes - return no error
NOARGERR:
	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
	XOR	AX,AX
	STC
	return

break	$Rmdir

assume	ds:trangroup,es:trangroup

$RMDIR:
	CALL	SETRMMK
	JC	RmDirErr
	JNZ	BADRDERR
	MOV	AH,RMDIR
	INT	21h
	retnc

	invoke	get_ext_error_number		;AN022; get the extended error
	cmp	ax,error_path_not_found 	;AN022; see if path not found
	jz	badrderr			;AN022; yes - issue old message
	cmp	ax,error_access_denied		;AN022; access denied?
	jz	badrderr			;AN022; yes - issue old message

	call	Set_Ext_Error_Subst		;AN022;
	jmp	short RmDirerr			;AC022; yes - go print it

BADRDERR:
	MOV	DX,OFFSET TRANGROUP:BADRMD_ptr

RmDirErr:
	invoke	STD_Eprintf
	return

;****************************************************************
;*
;* ROUTINE:	Set_ext_error_subst
;*
;* FUNCTION:	Sets up substitution for extended error
;*
;* INPUT:	AX - extended error number
;*		DX - offset of string
;*
;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
;*
;****************************************************************

Set_ext_error_subst  proc near			;AN022;

	mov	msg_disp_class,ext_msg_class	;AN022; set up extended error msg class
	mov	string_ptr_2,dx 		;AN022; get address of failed string
	mov	Extend_buf_sub,one_subst	;AN022; put number of subst in control block
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AN022; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN022; get message number in control block

	ret					;AN022; return

Set_ext_error_subst  endp			;AN022;





Break	<SavUDir - preserve the users current directory on a particular drive>

;
; SavUDir - move the user's current directory on a drive into UserDir1
; SavUDir1 - move the user's current directory on a drive into a specified
;   buffer
;
;   Inputs:	DL has 1-based drive number
;		ES:DI has destination buffer (SavUDir1 only)
;   Outputs:	Carry Clear
;		    DS = TranGroup
;		Carry Set
;		    AX has error code
;   Registers Modified: AX, SI
;

SAVUDIR:
	MOV	DI,OFFSET TRANGROUP:USERDIR1

SAVUDIR1:
	MOV	AL,DL
	ADD	AL,'@'
	CMP	AL,'@'
	JNZ	GOTUDRV
	ADD	AL,[CURDRV]
	INC	AL				; A = 1

GOTUDRV:
	STOSB
	MOV	AH,[DIRCHAR]
	MOV	AL,':'
	STOSW
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING

	MOV	SI,DI
	MOV	AH,CURRENT_DIR			; Get the Directory Text
	INT	21h
	retc
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP

	return


CRLF2:
	PUSH	DX
	MOV	DX,OFFSET TRANGROUP:ACRLF_ptr

PR:
	PUSH	DS
	PUSH	CS
	POP	DS
	invoke	std_printf
	POP	DS
	POP	DX

	return

;
; These routines (SCANOFF, DELIM) are called in batch processing when DS
; may NOT be TRANGROUP
;
ASSUME	DS:NOTHING,ES:NOTHING

SCANOFF:
	LODSB
	CALL	DELIM
	JZ	SCANOFF
	DEC	SI				; Point to first non-delimiter
	return

;
; Input:    AL is character to classify
; Output:   Z set if delimiter
;	    NZ set otherwise
; Registers modified: none
;

DELIM:
	CMP	AL,' '
	retz
	CMP	AL,'='
	retz
	CMP	AL,','
	retz
	CMP	AL,';'
	retz
	CMP	AL,9				; Check for TAB character
	retz
	CMP	AL,0ah				; Check for line feed character - BAS
	return


ASSUME	DS:TRANGROUP,ES:TRANGROUP


FCB_TO_ASCZ:					; Convert DS:SI to ASCIZ ES:DI
	MOV	CX,8

MAINNAME:
	LODSB
	CMP	AL,' '
	JZ	SKIPSPC
	STOSB

SKIPSPC:
	LOOP	MAINNAME
	LODSB
	CMP	AL,' '
	JZ	GOTNAME
	MOV	AH,AL
	MOV	AL,dot_chr
	STOSB
	XCHG	AL,AH
	STOSB
	MOV	CL,2

EXTNAME:
	LODSB
	CMP	AL,' '
	JZ	GOTNAME
	STOSB
	LOOP	EXTNAME

GOTNAME:
	XOR	AL,AL
	STOSB
	return

STRCOMP:
;
; Compare ASCIZ DS:SI with ES:DI.
; SI,DI destroyed.
;
	CMPSB
	retnz					; Strings not equal
	cmp	byte ptr [SI-1],0		; Hit NUL terminator?
	retz					; Yes, strings equal
	jmp	short STRCOMP			; Equal so far, keep going


CRPRINT:
	PUSH	AX
	MOV	AL,13
	PUSH	CX
	PUSH	DI
	MOV	DI,DX
	MOV	CX,-1
	PUSH	ES
	PUSH	DS
	POP	ES

	REPNZ	SCASB				; LOOK FOR TERMINATOR
	mov	byte ptr [di-1],0		; nul terminate the string
	POP	ES
	mov	string_ptr_2,dx
	mov	dx,offset trangroup:string_buf_ptr
	invoke	std_printf
	mov	ds:byte ptr [di-1],13		; now put the CR back
	JC	ERROR_OUTPUT

	POP	DI
	POP	CX
	POP	AX

	return

ERROR_OUTPUT:
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	MOV	ES,[RESSEG]
ASSUME	ES:RESGROUP

	MOV	DX,OFFSET TRANGROUP:NOSPACE_ptr
	CMP	[PIPEFLAG],0
	JZ	GO_TO_ERROR

	invoke	PipeOff
	MOV	DX,OFFSET TRANGROUP:PIPEEMES_ptr
GO_TO_ERROR:
	JMP	CERROR

ASSUME	DS:TRANGROUP,ES:TRANGROUP

PATHCHRCMP:
;---- Mod for path invocation ----
PUBLIC pathchrcmp
;----

	push	ax
	mov	ah,'/'
	CMP	[SWITCHAR],ah
	JZ	NOSLASHT
	CMP	AL,'/'
	jz	pccont

NOSLASHT:
	CMP	AL,'\'
pccont:
	pop	ax

	return

;
; PATHCRUNCH -
;
; ENTRY FCB (in PSP) contains drive # to crunch on
;       PathPos = ptr to string with pathname in it
;       PathCnt = length of string
;
; EXIT  PathPos = ptr after pathname (w/ NULL) in string
;       PathCnt = length left in string
;       DestIsDir = nonzero if pathname delimiter char's found in pathname
;       DestInfo<bit1> = set if wildcard char's found in pathname
;       If path crunched successfully,
;         CY = clear
;         Current directory is changed to directory in pathname
;         UserDir1 contains previous directory for use by RestUDir
;         RestDir = nonzero to flag later restoration of user's dir
;         DestTail = ptr to beginning of filename
;         If filename found in pathname,
;           ZR = clear
;           FCB filename fields contain filename
;         If filename not found (pure directory path),
;           ZR = set
;           FCB filename fields are wildcarded with ?'s
;       If pathcrunch failed (no ChDir's worked),
;         CY = set
;         Msg_Numb = extended error code
;
; NOTE  DIR asks PathCrunch to forego parsing the filename into the
;       FCB by setting DirFlag.  In this case, the FCB is returned
;       with the filename wildcarded.
;
PATHCRUNCH:
        mov     [msg_numb],0            ;AN022; Set up message flag
        MOV     DL,DS:[FCB]             ; DL = drive # (1 = A)
        CALL    SAVUDIR                 ; save current directory in UserDir1
        jc      pcrunch_cderrJ           ;AN022; if error on current dir - report

        invoke  SETPATH                 ; scan past switches, whitespace

;       DX = ptr to pathname, NULL-terminated
;       PathPos = ptr to byte after NULL at end of pathname

        TEST    [DESTINFO],2            ; test if wildcards (? or *) seen
        JNZ     TRYPEEL                 ; wildcard seen, peel filename

        MOV     AH,CHDIR                ; AH = DOS ChDir function code
        INT     21h             ; call DOS
        jnc     chdir_worked            ;AN022; no error - continue

        invoke  get_ext_error_number    ;AN022; get the extended error
        cmp     ax,error_path_not_found ;AN022; if path not found
        jz      trypeel                 ;AC022;     keep trying
        cmp     ax,error_access_denied  ;AN022; if access denied
        jz      trypeel                 ;AC022;     keep trying
        mov     [msg_numb],ax           ;AN022; set up message flag
        jmp     peelfail                ;AN022; exit with other error

chdir_worked:
        invoke  SETREST1                ; set 'Restore Directory' flag true
        MOV     AL,'?'                  ; if pure dir, wildcard filename in FCB
        MOV     DI,5DH
	MOV	CX,11
        REP     STOSB
        XOR     AL,AL                   ; return carry clear, zero set
        return

pcrunch_cderrj: 				;AN022; need this for long jmp
	jmp	pcrunch_cderr			;AN022;

TRYPEEL:
        MOV     SI,[PATHPOS]
        DEC     SI                      ; SI = ptr to NULL at end of pathname
        MOV     AL,[SI-1]               ; AL = last char of pathname

	CMP	[KPARSE],0
	JNZ	DELSTRT 			; Last char is second KANJI byte, might be '\'

	CALL	PATHCHRCMP
	JZ	PEELFAIL			; Trailing '/'

DELSTRT:
        MOV     CX,SI                   ; CX = ptr to NULL at end of pathname
        MOV     SI,DX                   ; SI = ptr to start of pathname
        PUSH    DX                      ; save ptr to pathname
DELLOOP:
        CMP     SI,CX
        JZ      GOTDELE                 ; no char's left, we have what we have
        LODSB                           ; AL = next char of pathname
        invoke  TESTKANJ
        JZ      NOTKANJ8                ; not Kanji, move along
        INC     SI
	JMP	DELLOOP

NOTKANJ8:
        CALL    PATHCHRCMP
        JNZ     DELLOOP                 ; not a path delimiter, keep looking
        MOV     DX,SI
        DEC     DX                      ; DX = ptr to last delimiter found
        JMP     DELLOOP                 ; go look for more

GOTDELE:
        MOV     SI,DX                   ; SI = ptr to pathname or last delim
        POP     DX                      ; DX = ptr to pathname
        CMP     SI,DX
        JZ      BADRET                  ; didn't find path delim
        MOV     CX,SI                   ; CX = ptr to last path delimiter
        MOV     SI,DX                   ; SI = ptr to pathname

DELLOOP2:                               ; Set value of KPARSE
        CMP     SI,CX
        JZ      TRYCD                   ; roll up till SI meets CX
        MOV     [KPARSE],0
	LODSB
	INVOKE	TESTKANJ
	JZ	DELLOOP2
	INC	SI
	INC	[KPARSE]
	JMP	DELLOOP2

TRYCD:
        push    ax
        mov     al,dot_chr              ; AL = '.'
        CMP     BYTE PTR [SI+1],al      ; check for '.' after path delim
					;M019; allow continuation if '. ' or 
					;M019; '..' is not found.
	jnz	@F			;M019; '.' not found
	cmp	BYTE PTR [SI+2],al	;M019; check for '..'
	jz	@F			;M019; found '..'
	cmp	BYTE PTR [SI+2],0	;M019; check for '. ' (null terminated)
@@:     pop     ax
        JZ      PEELFAIL                ; if . or .., pure cd should have worked
        mov     al,[si-1]
        CMP     al,':'                  ; Special case d:\file
        JZ      BADRET

	CMP	[KPARSE],0
	JNZ	NOTDOUBLESL			; Last char is second KANJI byte, might be '\'

	CALL	PATHCHRCMP
	JNZ	NOTDOUBLESL
PEELFAIL:
	STC					; //
	return
NOTDOUBLESL:
	MOV	BYTE PTR [SI],0
	MOV	AH,CHDIR
	INT	21h
	JNC	CDSUCC
pcrunch_cderr:
	invoke	get_ext_error_number		;AN022; get the extended error
	mov	[msg_numb],ax			;AN022; set up message flag
	or	si,si				;AN022; set up zero flag to not zero
	stc					;AN022; set up carry flag
	return

BADRET:
	MOV	AL,[SI]
	CALL	PATHCHRCMP			; Special case 'DIRCHAR'file
	STC
	retnz
	XOR	BL,BL
	XCHG	BL,[SI+1]
	MOV	AH,CHDIR
	INT	21h
	jc	pcrunch_cderr			;AN022; go to error exit
	MOV	[SI+1],BL
CDSUCC:
	invoke	SETREST1
	INC	SI				; Reset zero
	MOV	[DESTTAIL],SI
	pushf					;AN015; save flags
	cmp	dirflag,-1			;AN015; don't do parse if in DIR
	jz	pcrunch_end			;AN015;
	MOV	DI,FCB
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H ; Parse with default drive
	INT	21h
pcrunch_end:
	popf					;AN015; get flags back
	return

trancode    ends
	    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tparse.asm ===
page ,132
;	SCCSID = @(#)tparse.asm 4.1 87/04/28
;	SCCSID = @(#)tparse.asm 4.1 87/04/28
TITLE	COMMAND interface to SYSPARSE
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
.xcref
	include comsw.asm
	include comseg.asm		;an000;
.list
.cref

TRANSPACE	SEGMENT PUBLIC BYTE	;AN000;

	CmpxSW	equ	0		;AN000; do not check complex list
	KeySW	equ	0		;AN000; do not support keywords
	Val2SW	equ	0		;AN000; do not Support value definition 2
	IncSW	equ	0		;AN000; do not include psdata.inc
	QusSW	equ	0		;AN025; do not include quoted string
	LFEOLSW equ	0		;AN044; do not use 0ah as line terminator

.xlist
.xcref

include psdata.inc			;AN000;

.list
.cref

TRANSPACE	ENDS			;AN000;

TRANCODE	SEGMENT PUBLIC BYTE	;AN000;

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING	 ;AN054;

; ****************************************************************
; *
; * ROUTINE:	 CMD_PARSE
; *
; * FUNCTION:	 Interface for transient COMMAND to invoke
; *		 SYSPARSE.
; *
; * INPUT:	 inputs to SYSPARSE
; *
; * OUTPUT:	 outputs from SYSPARSE
; *
; ****************************************************************

	public	Cmd_parse		;AN000;

.xlist
.xcref
	INCLUDE parse.asm		;AN000;
.list
.cref

Cmd_parse	Proc  near		;AN000;

	call	sysparse		;AN000;

	ret				;AN000;

Cmd_parse	endp			;AN000;

	public	Append_parse		;AN010;

Append_parse	Proc  Far		;AN010;

	call	sysparse		;AN010;

	ret				;AN010;

Append_parse	endp			;AN010;

trancode    ends			;AN000;
	    end 			;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tranmsg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
include version.inc

;
;	Revision History
;	================
;
;	M016	SR 	08/09/90	Added 2 error messages for LoadHigh
;
;



;****************************************************
;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
;****************************************************

msg_disp_class	db	Util_msg_class
msg_cont_flag	db	No_cont_flag

;  extended error string output
;
Extend_Buf_ptr	dw	0				;AN000;set to no message
Extend_Buf_sub	db	0				;AN000;set to no substitutions
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
Extend_Buf_off	dw	OFFSET	TranGroup:String_ptr_2	;AN000;offset of arg
Extend_Buf_seg	dw	0				;AN000;segment of arg
		db	0				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Duplicate file name or file not found"
;
Renerr_Ptr	dw	1002				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path or file name"
;
BadCPMes_Ptr	dw	1003				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Insufficient disk space"
;
NoSpace_Ptr	dw	1004				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Out of environment space"
;
EnvErr_Ptr	dw	1007				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "File creation error"
;
FulDir_Ptr	dw	1008				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Batch file missing",13,10
;
BadBat_Ptr	dw	1009				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Insert disk with batch file",13,10
;
NeedBat_Ptr	dw	1010				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Bad command or file name",13,10
;
BadNam_Ptr	dw	1011				;AN000;message number
		db	no_subst			;AN000;number of subst


;  "Access denied",13,10
;
AccDen_Ptr	dw	1014				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "File cannot be copied onto itself",13,10
;
OverWr_Ptr	dw	1015				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Content of destination lost before copy",13,10
;
LostErr_Ptr	dw	1016				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid filename or file not found",13,10
;
InOrNot_Ptr	dw	1017				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "%1 File(s) copied",13,10
;
Copied_Ptr	dw	1018				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Copy_num	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	9				;AN000;maximum width
		db	9				;AN000;minimum width
		db	blank				;AN000;pad character

;  "%1 File(s) "
;
DirMes_Ptr	dw	1019				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Dir_num	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	9				;AN000;maximum width
		db	9				;AN000;minimum width
		db	blank				;AN000;pad character

;  "%1 bytes free",13,10
;
BytMes_Ptr	dw	1020				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Bytes_Free	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_DWord	;AN000;long binary to decimal
ifdef   KOREA
                db      11                              ; <MSCH>
                db      11                              ; <MSCH>
else
		db	28				;AN000;maximum width
		db	28				;AN000;minimum width
endif   ; KOREA
		db	blank				;AN000;pad character

;  "Invalid drive specification",13,10
;
BadDrv_Ptr	dw	1021				;AN000;message number
		db	no_subst			;AN000;number of subst


;  "Code page %1 not prepared for system",13,10
;
CP_not_set_Ptr	dw	1022				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Code page %1 not prepared for all devices",13,10
;
CP_not_all_Ptr	dw	1023				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Active code page: %1",13,10
;
CP_active_Ptr	dw	1024				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:System_cpage	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	5				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "NLSFUNC not installed",13,10
;
NLSFUNC_Ptr	dw	1025				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid code page",13,10
;
Inv_Code_Page	dw	1026				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current drive is no longer valid"
;
BadCurDrv	dw	1027				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Press any key to continue"
;
PauseMes_Ptr	dw	1028				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Label not found",13,10
;
BadLab_Ptr	dw	1029				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Syntax error",13,10
;
SyntMes_Ptr	dw	1030				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid date",13,10
;
BadDat_Ptr	dw	1031				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current date is %1 %2",13,10
;
CurDat_Ptr	dw	1032				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
IFNDEF DBCS						; MSKK03 07/14/89
		db	1				;AN000;first subst
  ELSE
    IFDEF JAPAN
		db	2				;AN000;first subst
    ELSE
		db	1				;AN000;first subst
    ENDIF
ENDIF
		db	Char_field_ASCIIZ		;AN000;character string
IFNDEF DBCS
		db	3				;AN000;maximum width
		db	3				;AN000;minimum width
  ELSE
    IFDEF JAPAN						; MSKK02 07/14/89
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
    ENDIF
    IFDEF TAIWAN
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
    ENDIF
    IFDEF KOREA
                db      2               ;3 Keyl               ;AN000;maximum width
                db      2               ;3 Keyl               ;AN000;minimum width
    ENDIF
ENDIF
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
CurDat_yr	dw	0				;AN000;year
CurDat_mo_day	dw	0				;AN000;month,day
IFNDEF DBCS						; MSKK03 07/14/89
		db	2				;AN000;second subst
  ELSE
    IFDEF JAPAN
		db	1				;AN000;second subst
    ELSE
		db	2				;AN000;second subst
    ENDIF
ENDIF

		db	DATE_MDY_4			;AN000;date
		db	10				;AN000;maximum width
		db	10				;AN000;minimum width
		db	blank				;AN000;pad character


;  "SunMonTueWedThuFriSat"
;
WeekTab 	dw	1033				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Enter new date (%1):"
;
NewDat_Ptr	dw	1034				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
NewDat_Format	dw	0				;AN000;offset of replacement
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	8				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Invalid time",13,10
;
BadTim_Ptr	dw	1035				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Current time is %1",13,10
;
CurTim_Ptr	dw	1036				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
CurTim_hr_min	dw	0				;AN000;hours,minutes
CurTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	1				;AN000;first subst
		db	Right_Align+TIME_HHMMSSHH_Cty	;AC059;time
		db	12				;AC059;maximum width
		db	12				;AC059;minimum width
		db	blank				;AN000;pad character

;  "Enter new time:"
;
NewTim_Ptr	dw	1037				;AN000;message number
		db	no_subst			;AN000;number of subst

;  ",    Delete (Y/N)?",13,10
;
Del_Y_N_Ptr	dw	1038				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "All files in directory will be deleted!",13,10
;  "Are you sure (Y/N)?",13,10
;
SureMes_Ptr	dw	1039				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Microsoft DOS Version %1.%2",13,10
;
VerMes_Ptr	dw	1040				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Major_Ver_Num ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
ifndef NEC_98
		db	2				;AN000;maximum width
else    ;NEC_98
                db      1                               ;AN000;maximum width
endif   ;NEC_98
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Minor_Ver_Num ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Right_Align+Unsgn_Bin_Word	;AN000;binary to decimal
		db	2				;AN000;maximum width
		db	2				;AN000;minimum width
		db	"0"                             ;AN000;pad character

;  "Volume in drive %1 has no label",13,10
;
VolMes_Ptr_2	dw	1041				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_drv	;AN000;offset of drive
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_Char 		;AN000;character
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Volume in drive %1 is %2",13,10
;
VolMes_Ptr	dw	1042				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_drv	;AN000;offset of drive
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	00000000b			;AN000;character
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:CHARBUF	;AN000;offset of string
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Volume Serial Number is %1-%2",13,10
;
VolSerMes_Ptr	dw	1043				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_serial+2	;AN000;offset of serial
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Bin_Hex_Word	;AN000;binary to hex
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
		db	"0"                             ;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:vol_serial	;AN000;offset of serial
		dw	0				;AN000;segment of arg
		db	2				;AN000;second subst
		db	Right_Align+Bin_Hex_Word	;AN000;binary to hex
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
		db	"0"                             ;AN000;pad character

;  "Invalid directory",13,10
;
BadCD_Ptr	dw	1044				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Unable to create directory",13,10
;
BadMkD_Ptr	dw	1045				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path, not directory,",13,10
;  "or directory not empty",13,10
;
BadRmD_Ptr	dw	1046				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Must specify ON or OFF",13,10
;
Bad_ON_OFF_Ptr	dw	1047				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Directory of %1",13,10
;
DirHead_Ptr	dw	1048				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:BWDBUF	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  "No Path",13,10
;
NulPath_Ptr	dw	1049				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid drive in search path",13,10
;
BadPMes_Ptr	dw	1050				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid device",13,10
;
BadDev_Ptr	dw	1051				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "FOR cannot be nested",13,10
;
ForNestMes_Ptr	dw	1052				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Intermediate file error during pipe",13,10
;
PipeEMes_Ptr	dw	1053				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Cannot do binary reads from a device",13,10
;
InBDev_Ptr	dw	1054				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "BREAK is %1",13,10
;
CtrlcMes_Ptr	dw	1055				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "VERIFY is %1",13,10
;
VeriMes_Ptr	dw	1056				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "ECHO is %1",13,10
;
EchoMes_Ptr	dw	1057				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	0				;AN000;offset of on/off (new)
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	1				;AN000;minimum width
		db	blank				;AN000;pad character

;  "off"
;
OffMes_Ptr	dw	1059				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "on"
;
OnMes_Ptr	dw	1060				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Error writing to device",13,10
;
DevWMes_Ptr	dw	1061				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "Invalid path",13,10
;
Inval_Path_Ptr	dw	1062				;AN000;message number
		db	no_subst			;AN000;number of subst

;  unformatted string output
;
arg_Buf_Ptr	dw	1063				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  file name output
;
File_Name_Ptr	dw	1064				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:SRCBUF	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character

;  file size output for dir
;
Disp_File_Size_Ptr dw	1065				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:File_size_low ;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Right_Align+Unsgn_Bin_DWord	;AN000;long binary to decimal
		db	10				;AN000;maximum width
		db	10				;AN000;minimum width
		db	blank				;AN000;pad character

;  unformatted string output
; %s
String_Buf_Ptr	dw	1066				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:String_ptr_2	;AN000;offset of arg
		dw	0				;AN000;segment of arg
		db	1				;AN000;first subst
		db	Char_field_ASCIIZ		;AN000;character string
		db	128				;AN000;maximum width
		db	0				;AN000;minimum width
		db	blank				;AN000;pad character
		db	0				;AN000;

;  tab character
;
Tab_ptr 	dw	1067				;AN000;message number
		db	no_subst			;AN000;number of subst

;  " <DIR>   "
;
DMes_Ptr	dw	1068				;AN000;message number
		db	no_subst			;AN000;number of subst

;  destructive back space
;
Dback_Ptr	dw	1069				;AN000;message number
		db	no_subst			;AN000;number of subst

;  carriage return / line feed
;
ACRLF_Ptr	dw	1070				;AN000;message number
		db	no_subst			;AN000;number of subst

;  output a single character
;
;One_Char_Buf_Ptr dw	 1071				 ;AN000;message number
;		 db	 1				 ;AN000;number of subst
;		 db	 parm_block_size		 ;AN000;size of sublist
;		 db	 0				 ;AN000;reserved
;		 dw	 OFFSET  TranGroup:One_Char_Val  ;AN000;offset of charcacter
;		 dw	 0				 ;AN000;segment of arg
;		 db	 1				 ;AN000;first subst
;		 db	 Char_field_Char		 ;AN000;character
;		 db	 1				 ;AN000;maximum width
;		 db	 1				 ;AN000;minimum width
;		 db	 blank				 ;AN000;pad character

;  "mm-dd-yy"
;
USADat_Ptr	dw	1072				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "dd-mm-yy"
;
EurDat_Ptr	dw	1073				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "yy-mm-dd"
;
JapDat_Ptr	dw	1074				;AN000;message number
		db	no_subst			;AN000;number of subst

;  date string for prompt
;
promptDat_Ptr	dw	1075				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
		dw	OFFSET	TranGroup:Arg_Buf	;AN000;offset of arg
		dw	0				;AN000;segment of arg
IFNDEF DBCS						; MSKK03 07/14/89
		db	1				;AN000;first subst
  ELSE
    IFDEF JAPAN
		db	2				;AN000;first subst
    ELSE
		db	1				;AN000;first subst
    ENDIF
ENDIF

		db	Char_field_ASCIIZ		;AN000;character string
IFNDEF DBCS
		db	3				;AN000;maximum width
		db	3				;AN000;minimum width
  ELSE
    IFDEF JAPAN						; MSKK02 07/14/89
		db	4				;AN000;maximum width
		db	4				;AN000;minimum width
    ENDIF
    IFDEF TAIWAN
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
    ENDIF
    IFDEF KOREA
                db      2               ;3 Keyl                ;AN000;maximum width
                db      2               ;3 Keyl                ;AN000;minimum width
    ENDIF
ENDIF
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
promptDat_yr	dw	0				;AN000;year
promptDat_moday dw	0				;AN000;month,day
IFNDEF DBCS						; MSKK03 07/14/89
		db	2				;AN000;second subst
  ELSE
    IFDEF JAPAN
		db	1				;AN000;second subst
    ELSE
		db	2				;AN000;second subst
    ENDIF
ENDIF
		db	DATE_MDY_4			;AN000;date
		db	10				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character


;  Time for prompt
;
promTim_Ptr	dw	1076				;AN000;message number
		db	1				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
PromTim_hr_min	dw	0				;AN000;hours,minutes
PromTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	1				;AN000;first subst
		db	Right_Align+TIME_HHMMSSHH_24	;AC013;time
		db	11				;AN000;maximum width
		db	11				;AC013;minimum width
		db	blank				;AN000;pad character

;  Date and time for DIR
;
DirDatTim_Ptr	dw	1077				;AN000;message number
		db	2				;AN000;number of subst
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
DirDat_yr	dw	0				;AN000;year
DirDat_mo_day	dw	0				;AN000;month,day
		db	1				;AN000;first subst
		db	Right_Align+DATE_MDY_2		;AN000;date
		db	10				;AN000;maximum width
		db	8				;AN000;minimum width
		db	blank				;AN000;pad character
		db	parm_block_size 		;AN000;size of sublist
		db	0				;AN000;reserved
DirTim_hr_min	dw	0				;AN000;hours,minutes
DirTim_Sec_hn	dw	0				;AN000;seconds,hundredths
		db	2				;AN000;second subst
		db	Right_align+TIME_HHMM_Cty	;AN000;time
		db	6				;AN000;maximum width
		db	6				;AN000;minimum width
		db	blank				;AN000;pad character

;  "Directory already exists"
;
MD_exists_ptr	dw	1078				;AN000;message number
		db	no_subst			;AN000;number of subst

;  "%1 bytes",13,10
;
Bytes_Ptr       dw      1079                            ; message number
                db      1                               ; number of subst
                db      parm_block_size                 ; size of sublist
                db      0                               ; reserved
                dw      OFFSET  TranGroup:FileSiz       ; offset of arg
                dw      0                               ; segment of arg
                db      1                               ; first subst
                db      Right_Align+Unsgn_Bin_DWord     ; long binary to decimal
                db      10                              ; maximum width
                db      10                              ; minimum width
                db      blank                           ; pad character

;  "Total:",13,10
;
Total_ptr       dw      1080                            ; message number
                db      no_subst                        ; number of subst

;  "Error parsing environment variable:",13,10
;
ErrParsEnv_ptr  dw      1081                            ; message number
                db      no_subst                        ; number of subst

;  "(continuing %1)",13,10
;
DirCont_Ptr     dw      1084                            ;AN000;message number
                db      1                               ;AN000;number of subst
                db      parm_block_size                 ;AN000;size of sublist
                db      0                               ;AN000;reserved
                dw      OFFSET  TranGroup:BWDBUF        ;AN000;offset of arg
                dw      0                               ;AN000;segment of arg
                db      1                               ;AN000;first subst
                db      Char_field_ASCIIZ               ;AN000;character string
                db      128                             ;AN000;maximum width
                db      0                               ;AN000;minimum width
                db      blank                           ;AN000;pad character

;  "Revision %1",CR,LF
;
DosRev_Ptr	dw	1090
		db	1				; one substitution
		db	PARM_BLOCK_SIZE
		db	0
		dw	offset TRANGROUP:One_Char_Val	; ptr to char
		dw	0				; segment addr?
		db	1				; 1st substitution
		db	CHAR_FIELD_CHAR			; character
		db	1				; max width
		db	1				; min width
		db	BLANK				; pad char

;  "DOS is in ROM"
;
DosRom_Ptr	dw	1091
		db	NO_SUBST

;  "DOS is in HMA"
;
DosHma_Ptr	dw	1092
		db	NO_SUBST

;  "DOS is in low memory"
;
DosLow_Ptr	dw	1093
		db	NO_SUBST

;  "Cannot Loadhigh batch file" ;M016
;
NoExecBat_Ptr	dw	1094			; M016
		db	NO_SUBST			; M016

;  "LoadHigh: Invalid filename" ; M016
;
LhInvFil_Ptr	dw	1095			; M016
		db	NO_SUBST			; M016

;  "Could not open specified country information file" ;M045
;
NoCntry_Ptr	dw	1096			;M045
		db	NO_SUBST			;M045


PATH_TEXT       DB      "PATH="
PROMPT_TEXT     DB      "PROMPT="
COMSPECSTR      DB      "COMSPEC="
DirEnvVar       DB      "DIRCMD="               ; DIR's environment variable

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tucode.asm ===
page ,132
;	SCCSID = @(#)tucode.asm 4.2 85/05/31
;	SCCSID = @(#)tucode.asm 4.2 85/05/31
Title	COMMAND Language midifiable Code Transient
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


.xlist
.xcref
	include dossym.inc
	include syscall.inc
	include comsw.asm
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ECHOFLAG:BYTE
DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BAD_ON_OFF_ptr:word
	EXTRN	ctrlcmes_ptr:word
	EXTRN	DEL_Y_N_PTR:WORD
	EXTRN	ECHOMES_ptr:word
	EXTRN	extend_buf_ptr:word	;AC000;
	EXTRN	offmes_ptr:word
	EXTRN	onmes_ptr:word
	EXTRN	PARSE_BREAK:BYTE	;AN000;
	EXTRN	promptdat_moday:word	;AC000;
	EXTRN	promptdat_ptr:word	;AC000;
	EXTRN	promptdat_yr:word	;AC000;
	EXTRN	string_buf_ptr:word
	EXTRN	SUREMES_ptr:word
	EXTRN	VERIMES_ptr:BYTE
	EXTRN	WeekTab:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	arg_buf:byte
	EXTRN	BWDBUF:BYTE
	EXTRN	DEST:BYTE
	EXTRN	destdir:byte
	EXTRN	dirchar:byte
	EXTRN	PARSE1_CODE:BYTE	;AN000;
	EXTRN	RESSEG:WORD
	EXTRN	string_ptr_2:word

TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE

	EXTRN	CERROR:NEAR
	EXTRN	CRLF2:NEAR
	EXTRN	extend_setup:near	;AN022;

	PUBLIC	CNTRLC
	PUBLIC	ECHO
	PUBLIC	GetDate
	PUBLIC	NOTEST2
	PUBLIC	PRINT_DATE
	PUBLIC	SLASHP_ERASE		;AN000;
	PUBLIC	VERIFY

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

; ****************************************************************
; *
; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
; *
; * FUNCTION:	 Delete files based on user parsed input.  Prompt
; *		 user for Y/N if necessary.  If an error occurs,
; *		 set up an error message and go to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************
;
; ARE YOU SURE prompt when deleting *.*

NOTEST2:
	MOV	CX,11
	MOV	SI,FCB+1

AMBSPEC:
	LODSB
	CMP	AL,'?'
	JNZ	ALLFIL
	LOOP	AMBSPEC

ALLFIL:
	CMP	CX,0
	JNZ	NOPRMPT

ASKAGN:
	MOV	DX,OFFSET TRANGROUP:SUREMES_ptr ; "Are you sure (Y/N)?"
	invoke	std_printf
	MOV	SI,80H
	MOV	DX,SI
	MOV	WORD PTR [SI],120		; zero length
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_STRING_INPUT
	INT	21H
	LODSW
	OR	AH,AH
	JZ	ASKAGN
	INVOKE	SCANOFF
	call	char_in_xlat			;G Convert to upper case
	retc					;AN000; return if function not supported
	CMP	AL,CAPITAL_N			;G
	retz
	CMP	AL,CAPITAL_Y			;G
	PUSHF
	CALL	CRLF2
	POPF
	JNZ	ASKAGN

NOPRMPT:
	MOV	AH,FCB_DELETE
	MOV	DX,FCB
	INT	21H
	INC	AL
	jz	eraerr
	invoke	RESTUDIR
	ret					; If no error, return

eraerr:
	invoke	set_ext_error_msg		;AN022; set up the extended error
	push	dx				;AN022; save message
	invoke	RESTUDIR
	pop	dx				;AN022; restore message

	cmp	word ptr extend_buf_ptr,error_no_more_files ;AN022; convert no more files to
	jnz	cerrorj2			;AN022; 	file not found
	mov	Extend_Buf_ptr,error_file_not_found  ;AN000; get message number in control block

cerrorj2:
	jmp	cerror


; ****************************************************************
; *
; * ROUTINE:	 SLASHP_ERASE  - execution of DEL/ERASE /P
; *
; * FUNCTION:	 Delete files based on user parsed input.  Prompt
; *		 user for Y/N where necessary.	If an error occurs
; *		 set up and error message and transfer control
; *		 to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:TRANGROUP,SS:NOTHING

SLASHP_ERASE:					;AN000; entry point
	invoke	build_dir_string		;AN000; set up current directory string for output
	mov	ah,Set_DMA			;AN000; issue set dta int 21h
	mov	dx,offset trangroup:destdir	;AN000; use Destdir for target
	int	21H				;AN000;
	mov	ah,Dir_Search_First		;AN000; do dir search first int 21h
	mov	dx,FCB				;AN000; use FCB at 5Ch for target
	int	21H				;AN000;
	inc	al				;AN000; did an error occur
	jz	eraerr				;AN022; go to error exit

delete_prompt_loop:				;AN000;
	mov	si,offset trangroup:destdir+1	;AN000; set up FCB as source
	mov	di,offset trangroup:dest	;AN000; set up dest as target
	mov	al,dirchar			;AN000; store a "\" in the first char
	stosb					;AN000;     of DEST
	invoke	fcb_to_ascz			;AN000; convert filename from FCB to ASCIIZ string

slashp_askagn:					;AN000;
	call	crlf2				;AN000; print out carriage return, line feed
	mov	dx,offset trangroup:bwdbuf	;AN000; print out current directory string
	mov	bx,dx				;AN000; get string pointer in bx
	cmp	byte ptr [bx+3],end_of_line_out ;AN000; see if only D:\,0
	jnz	not_del_root			;AN000; no continue
	mov	byte ptr [bx+2],end_of_line_out ;AN000; yes, get rid of \

Not_del_root:					;AN000;
	mov	string_ptr_2,dx 		;AN000;
	mov	dx,offset trangroup:string_buf_ptr ;AN000;
	invoke	std_printf			;AN000;
	mov	dx,offset trangroup:dest	;AN000; print out file name string
	mov	string_ptr_2,dx 		;AN000;
	mov	dx,offset trangroup:string_buf_ptr ;AN000;
	invoke	std_printf			;AN000;
	mov	dx,offset trangroup:Del_Y_N_Ptr ;AN000; issue ",    Delete (Y/N)?" message
	invoke	std_printf			;AN000;
;;M029	mov	si,80H				;AN000; set up buffer for input
;;M029	mov	dx,si				;AN000;
;;M029	mov	word ptr [si],combuflen 	;AN000;
;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	 ;AN000;
;;M029	int	21h			;AN000; get input from the user
;;M029	lodsw					;AN000;
;;M029	or	ah,ah				;AN000; was a character entered?
;;M029	jz	slashp_askagn			;AN000; no - ask again
;;M029	invoke	scanoff 			;AN000; scan off leading delimiters

;	Get a single character input.

	mov	ax,(std_con_input_flush shl 8) or std_con_input	;M029
	int	21h						;M029

	call	char_in_xlat			;AN000; yes - upper case it
	retc					;AN000; return if function not supported
	cmp	al,capital_n			;AN000; was it no?
	jz	next_del_file			;AN000; yes - don't delete file
	cmp	al,capital_y			;AN000; was it yes?
	jz	delete_this_file		;AN000; yes - delete the file
	jmp	short slashp_askagn		;AN000; it was neither - ask again

delete_this_file:				;AN000;
	mov	ah,fcb_delete			;AN000; delete the file
	mov	dx,offset trangroup:destdir	;AN000; use Destdir for target
	int	21h			;AN000;
	inc	al				;AN000; did an error occur?
	jnz	next_del_file			;AN000; no - get next file
;
;M041; Begin changes
; We got an error deleting the file. If this is access denied, we can go on
;to the next file after printing an error message.
;
	invoke	Get_ext_error_number			;see what error we got
	cmp	ax,error_access_denied		;is it access denied?
	jne	stop_del			;no, some other error
	invoke	CrLf2				;print a CR-LF
	invoke 	set_ext_error_msg			;error message
	invoke	std_eprintf			;"Access denied"
	jmp	short next_del_file			;try next file
stop_del:
;
;M041; End changes
;
	jmp	eraerr				;AN022; go to error exit - need long jmp

next_del_file:					;AN000;
;
; M050 - begin
; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
;       with /protect+ and /light+ makes it intercept all
;       deletes. This hook does not save and restore the DTA correctly.
;       They save the DWORD in a WORD by mistake! They save both the
;       segment and the offset in the SAME variable (WORD)!!!
;
	mov	ah,Set_DMA
	mov	dx,offset trangroup:destdir
	int	21H
;
; M050 - end

	mov	ah,dir_search_next		;AN000; search for another file
	mov	dx,FCB				;AN000;
	int	21h			;AN000;
	inc	al				;AN000; was a file found?
	jz	slash_p_exit			;AN000; no - exit
	jmp	delete_prompt_loop		;AN000; yes - continue (need long jump)

slash_p_exit:
	invoke	get_ext_error_number		;AN022; get the extended error number
	cmp	ax,error_no_more_files		;AN022; was error file not found?
	jz	good_erase_exit 		;AN022; yes - clean exit
	jmp	extend_setup			;AN022; go issue error message

good_erase_exit:
	invoke	restudir			;AN000; we're finished - restore user's dir
	call	crlf2				;AN000; print out carriage return, line feed
	ret					;AN000; exit


;************************************************
; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"

	break	Echo

assume	ds:trangroup,es:trangroup

ECHO:
	CALL	ON_OFF
	JC	DOEMES
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	JNZ	ECH_OFF
	OR	[ECHOFLAG],1
	RET
ECH_OFF:
	AND	[ECHOFLAG],NOT 1
	RET


CERRORJ:
	JMP	CERROR

;
; There was no discrenable ON or OFF after the ECHO.  If there is nothing but
; delimiters on the command line, we issue the ECHO is ON/OFF message.
;

ASSUME	DS:TRANGROUP

DOEMES:
	cmp	cl,0				;AC000; was anything on the line?
	jz	PEcho				; just display current state.
	MOV	DX,82H				; Skip one char after "ECHO"
	invoke	CRPRINT
	JMP	CRLF2

PECHO:
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	BL,[ECHOFLAG]
	PUSH	CS
	POP	DS
ASSUME	DS:TRANGROUP
	AND	BL,1
	MOV	DX,OFFSET TRANGROUP:ECHOMES_ptr
	JMP	SHORT PYN

	break	Break
assume	ds:trangroup,es:trangroup

CNTRLC:
	CALL	ON_OFF
	MOV	AX,(SET_CTRL_C_TRAPPING SHL 8) OR 1
	JC	PCNTRLC
	JNZ	CNTRLC_OFF
	MOV	DL,1
	INT	21H				; Set ^C
	RET

CNTRLC_OFF:
	XOR	DL,DL
	INT	21H				; Turn off ^C check
	RET

PCNTRLC:
	CMP	CL,0				;AC000; rest of line blank?
	JNZ	CERRORJ 			; no, oops!

pccont:
	XOR	AL,AL
	INT	21H
	MOV	BL,DL
	MOV	DX,OFFSET TRANGROUP:CTRLCMES_ptr

PYN:
	mov	si,offset trangroup:onmes_ptr	;AC000; get ON pointer
	OR	BL,BL
	JNZ	PRINTVAL
	mov	si,offset trangroup:offmes_ptr	;AC000; get OFF pointer

PRINTVAL:
	push	dx				;AN000; save offset of message block
	mov	bx,dx				;AN000; save offset value
	lodsw					;AN000; get message number of on or off
	mov	dh,util_msg_class		;AN000; this is a utility message
	invoke	Tsysgetmsg			;AN000; get the address of the message
	add	bx,ptr_off_pos			;AN000; point to offset of ON/OFF
	mov	word ptr [bx],si		;AN000; put the offset in the message block
	pop	dx				;AN000; get message back
	invoke	std_printf			;AC000; go print message
	mov	word ptr [bx],0 		;AN000; zero out message pointer

	ret					;AN000; exit

	break	Verify
assume	ds:trangroup,es:trangroup

VERIFY:
	CALL	ON_OFF
	MOV	AX,(SET_VERIFY_ON_WRITE SHL 8) OR 1
	JC	PVERIFY
	JNZ	VER_OFF
	INT	21H				; Set verify
	RET

VER_OFF:
	DEC	AL
	INT	21H				; Turn off verify after write
	RET

PVERIFY:
	CMP	CL,0				;AC000; is rest of line blank?
	JNZ	CERRORJ 			; nope...
	MOV	AH,GET_VERIFY_ON_WRITE
	INT	21H
	MOV	BL,AL
	MOV	DX,OFFSET TRANGROUP:VERIMES_ptr
	JMP	PYN

; ****************************************************************
; *
; * ROUTINE:	 ON_OFF
; *
; * FUNCTION:	 Parse the command line for an optional ON or
; *		 OFF string for the BREAK, VERIFY, and ECHO
; *		 routines.
; *
; * INPUT:	 command line at offset 81H
; *		 PARSE_BREAK control block
; *
; * OUTPUT:	 If carry is clear
; *		    If ON is found
; *		       Zero flag set
; *		    If OFF is found
; *		       Zero flag clear
; *		 If carry set
; *		    If nothing on command line
; *		       CL set to zero
; *		    If error
; *		       CL contains error value from parse
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

ON_OFF:
	MOV	SI,81h

scan_on_off:					;AN032; scan off leading blanks & equal
	lodsb					;AN032; get a char
	cmp	al,blank			;AN032; if whitespace
	jz	scan_on_off			;AN032;    keep scanning
	cmp	al,tab_chr			;AN032; if tab
	jz	scan_on_off			;AN032;    keep scanning
	cmp	al,equal_chr			;AN032; if equal char
	jz	parse_on_off			;AN032;    start parsing
	dec	si				;AN032; if none of above - back up

parse_on_off:					;AN032;    and start parsing
	mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
	xor	cx,cx				;AN000; clear cx,dx
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	BADONF				;AC000; yes, return error
	cmp	ax,result_no_error		;AN000; did an error occur
	jz	on_off_there			;AN000; no - continue
	mov	cx,ax				;AN000; yes - set cl to error code
	jmp	short BADONF			;AN000; return error

on_off_there:
	cmp	parse1_code,-1			;AN014; was a valid positional present?
	jnz	good_on_off			;AN014; yes - continue
	mov	cx,badparm_ptr			;AN014; something other than ON/OFF
	jmp	short BADONF			;AN014; return error

good_on_off:					;AN014;
	xor	ax,ax				;AC000; set up return code for
	or	al,parse1_code			;AC000;    ON or OFF in AX
	pushf					;AN000; save flags
	mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AN000; call parser
	cmp	ax,end_of_line			;AN000; are we at end of line?
	jnz	BADONF_flags			;AN000; NO, return error
	popf					;AN000; restore flags
	clc					;AC000; no error
	jmp	short on_off_end		;AN000; return to caller

BADONF_flags:
	mov	cx,ax
	popf

;
; No discernable ON or OFF has been found. Put an error message pointer in DX
; and return the error
;
BADONF:
	MOV	DX,OFFSET TRANGROUP:BAD_ON_OFF_ptr
	STC

ON_OFF_END:

	RET



;*************************************************************************
; print date

PRINT_DATE:
	PUSH	ES
	PUSH	DI
	PUSH	CS
	POP	ES
	CALL	GetDate 			; get date
	xchg	dh,dl				;AN000; switch month & day
	mov	promptDat_yr,cx 		;AC000; put year into message control block
	mov	promptDat_moday,dx		;AC000; put month and day into message control block
	mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
	invoke	std_printf
;AD061; mov	promptDat_yr,0			;AC000; reset year, month and day
;AD061; mov	promptDat_moday,0		;AC000;     pointers in control block
	POP	DI				;AC000; restore di,es
	POP	ES				;AC000;
	return
;
; Do GET DATE system call and set up 3 character day of week in ARG_BUF
; for output.  Date will be returned in CX,DX.
;

GetDate:
	mov	di,offset trangroup:arg_buf	;AC000; target for day of week
	MOV	AH,GET_DATE			;AC000; get current date
	INT	21h			;AC000; Get date in CX:DX
	CBW					;AC000;

	push	cx				;AN000; save date returned in
	push	dx				;AN000;      CX:DX
	MOV	SI,AX
IFNDEF DBCS
	SHL	SI,1
	ADD	SI,AX				; SI=AX*3
  ELSE
    ifdef JAPAN					; MSKK01 07/14/89
	shl	si,1
	shl	si,1				; SI=AX*4
    endif
    IFDEF TAIWAN
	SHL	SI,1
	ADD	SI,AX
	SHL	SI,1				; SI=AX*6
    ENDIF
    ifdef KOREA
        shl     si,1
    endif
ENDIF
	mov	cx,si				;AN000; save si
	mov	ax,weektab			;AN000; get message number of weektab
	mov	dh,util_msg_class		;AN000; this is a utility message
	push	di				;AN000; save argument buffer
	invoke	Tsysgetmsg			;AN000; get the address of the message
	pop	di				;AN000; retrieve argument buffer
	add	si,cx				;AC000; get day of week
IFNDEF DBCS
	MOV	CX,3
  ELSE
    ifdef JAPAN					; MSKK01 07/14/89
	mov	cx,4
    endif
    IFDEF TAIWAN
	MOV	CX,6
    ENDIF
    ifdef KOREA
        mov     cx,2                            ; MSCH 90/9/6
    endif
ENDIF
	REP	MOVSB
	mov	al,end_of_line_out		;AC000; terminate the string
	stosb
	pop	dx				;AN000; get back date
	pop	cx				;AN000;

	return
;g
;g   This routine determines whether the character in AL is a
;g   Yes or No character.  On return, if AL=0, the character is
;g   No, if AL=1, the character is Yes.
;g

assume	ds:trangroup

char_in_xlat	proc	near

	mov	dl,al				;AC000; get character into DX
	xor	dh,dh				;AC000;
	mov	ax,(getextcntry SHL 8) + 35	;AC000; Yes/No char call
	int	21h			;AC000;

	ret

char_in_xlat	endp

TRANCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tprintf.asm ===
page ,132
;	SCCSID = @(#)tprintf.asm	4.3 85/07/02
;	SCCSID = @(#)tprintf.asm	4.3 85/07/02
TITLE	COMMAND Transient Printf routine
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;


;****************************************************************
;*
;* ROUTINE:	STD_PRINTF/STD_EPRINTF
;*
;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
;*		Set up substitutions if utility message.  Make
;*		sure any changes to message variables in TDATA
;*		are reset to avoid reloading the transient.
;*
;* INPUT:	Msg_Disp_Class	-  set to message class
;*		Msg_Cont_Flag	-  set to control flags
;*		DS	points to transient segment
;*
;*		if utility message:
;*		DX	points to a block with message number
;*			(word), number of substitutions (byte),
;*			followed by substitution list if there
;*			are substitutions.  If substitutions
;*			are not in transient segment they must
;*			be set.
;*		else
;*		AX	set to message number
;*
;* OUTPUT:	none
;*
;****************************************************************

.xlist
.xcref
	INCLUDE comsw.asm		;AC000;
	INCLUDE DOSSYM.INC
	INCLUDE comseg.asm
	INCLUDE comequ.asm		;AN000;
	INCLUDE SYSMSG.INC		;AN000;
.list
.cref

datares segment public
	extrn	pipeflag:byte
datares ends

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	extend_buf_off:word	;AN000;
	EXTRN	Extend_Buf_ptr:word	;AN000;
	EXTRN	Extend_Buf_seg:word	;AN000;
	EXTRN	Msg_Cont_Flag:byte	;AN000;
	EXTRN	Msg_disp_Class:byte	;AN000;
	EXTRN	pipeemes_ptr:word
TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	msg_flag:byte		;AN022;
	EXTRN	print_err_flag:word	;AN000;
	EXTRN	RESSEG:WORD
	EXTRN	String_ptr_2:word	;AC000;
	EXTRN	Subst_buffer:byte	;AN061;
;AD061; EXTRN	String_ptr_2_sb:word	;AN000;

	; include data area for message services

	MSG_UTILNAME <COMMAND>		;AN000; define utility name

	MSG_SERVICES <MSGDATA>		;AN000;

PRINTF_HANDLE	DW  ?			;AC000;

TRANSPACE	ENDS			;AC000;

TRANCODE	SEGMENT PUBLIC BYTE	;AC000;

	EXTRN	cerror:near
	EXTRN	crlf2:near
	EXTRN	tcommand:near		;AN026;

ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING,SS:NOTHING ;AC000;

	PUBLIC	TSYSGETMSG		;AN000;
	PUBLIC	TSYSLOADMSG		;AN000;

PUBLIC Printf_Init
printf_init proc far
	call	std_printf
	ret
printf_init endp

Public	Printf_Crlf
PRINTF_CRLF:
	CALL	STD_PRINTF
	CALL	CRLF2
	RET

PUBLIC	Std_EPrintf
STD_EPRINTF:
	mov	Printf_Handle,2 		;AC000;Print to STDERR
	jmp	short NEW_PRINTF		;AC000;
PUBLIC	Std_Printf
STD_PRINTF:
	mov	Printf_Handle,1 		;AC000;Print to STDOUT

NEW_PRINTF:
	push	ax				;AN000;save registers
	push	bx				;AN000;
	push	cx				;AN000;
	push	es				;AN000;get local ES
	push	ds				;AN000;
	pop	es				;AN000;
	push	di				;AN000;
	push	si				;AN000;
	push	dx				;AN000;
	assume	es:trangroup			;AN000;
;AD061; mov	string_ptr_2_sb,0		;AN000;initialize
	mov	print_err_flag,0		;AN000;

UTILITY_SETUP:
	mov	si,dx				;AN000;Get offset of message number
	lodsw					;AN000;load message number
	push	ax				;AN000;save it
	lodsb					;AN000;get number of substitutions
	mov	cl,al				;AN000;set up CX as # of subst
	xor	ch,ch				;AN000;   SI now points to subst list
	pop	ax				;AN000;get message number back
	cmp	cx,0				;AN000;Any substitutions?
	jz	READY_TO_PRINT			;AN000;No - continue

;AD061;  add	 dx,Ptr_Seg_Pos 		 ;AN000;Point to position of first segment
;AD061;  push	 cx				 ;AN000;save substitution count

;AD061;SET_SUBST:
;AD061;  mov	 bx,dx				 ;AN000;get dx into base register
;AD061;  cmp	 word ptr [bx],0		 ;AN000;has segment been set?
;AD061;  jnz	 SUBST_SEG_SET			 ;AN000;if not 0, don't replace it
;AD061;  test	 word ptr [bx+3],date_type	 ;AN000;if date or time - don't set segment
;AD061;  jnz	 subst_seg_set			 ;AN000;yes - skip it
;AD061;  mov	 word ptr [bx],cs		 ;AN000;put segment of subst parm in list

;AD061;SUBST_SEG_SET:
;AD061;  add	 dx,Parm_Block_Size		 ;AN000;point to position of next segment
;AD061;  loop	 SET_SUBST			 ;AN000;keep replacing until complete
;AD061;  pop	 cx				 ;AN000;

;AD061;NO_REPLACEMENT:
;AD061;  mov	 bx,parm_off_pos [si]		 ;AN000;get subst offset
;AD061;  cmp	 bx,offset trangroup:string_ptr_2 ;AN000;this is used for double indirection
;AD061;  jnz	 ready_to_print 		 ;AN000;we already have address
;AD061;  mov	 dx,string_ptr_2		 ;AN000;get address in string_ptr_2
;AD061;  mov	 parm_off_pos [si],dx		 ;AN000;put proper address in table
;AD061;  mov	 string_ptr_2_sb,si		 ;AN000;save block changed

	mov	di,offset trangroup:subst_buffer;AN061; Get address of message subst buffer
	push	di				;AN061; save it
	push	cx				;AN061; save number of subst

MOVE_SUBST:
	push	cx				;AN061;save number of subst
	mov	bx,si				;AN061;save start of sublist
	mov	cx,parm_block_size		;AN061;get size of sublist
	rep	movsb				;AN061;move sublist
	test	byte ptr [bx.$M_S_FLAG],date_type ;AN061;are we doing date/time?
	jz	move_subst_cont 		;AN061;no - no need to reset
	mov	word ptr [bx.$M_S_VALUE],0	;AN061;reset original date or time to 0
	mov	word ptr [bx.$M_S_VALUE+2],0	;AN061;

MOVE_SUBST_CONT:				;AN061;
	pop	cx				;AN061;get number of subst back
	loop	move_subst			;AN061;move cx sublists

	pop	cx				;AN061;get number of subst
	push	ax				;AN061;save message number
	cmp	Msg_Disp_Class,Util_Msg_Class	;AN061;Is this a utility message
	jz	CHECK_FIX			;AN061;YES - go see if substitutions
	mov	msg_flag,ext_msg_class		;AN061;set message flag
	mov	di,offset trangroup:extend_buf_ptr ;AN061; Get address of extended message block
	xor	ax,ax				;AN061;clear ax register
	stosw					;AN061;clear out message number
	stosb					;AN061;clear out subst count

CHECK_FIX:					;AN061;
	pop	ax				;AN061;get message number back
	pop	di				;AN061;get start of sublists
	mov	si,di				;AN061;get into SI for msgserv
	mov	bx,si				;AN061;get into BX for addressing
	push	cx				;AN061;save number of subst

SET_SUBST:					;AN061;store the segment of the subst
	cmp	word ptr [bx.$M_S_VALUE+2],0	;AN061;was it set already?
	jnz	subst_seg_set			;AN061;if not 0, don't replace it
	test	byte ptr [bx.$M_S_FLAG],date_type ;AN061;don't replace if date or time
	jnz	subst_seg_set			;AN061;yes - skip it
	mov	word ptr [bx.$M_S_VALUE+2],cs	;AN061;set segment value

SUBST_SEG_SET:					;AN061;
	add	bx,parm_block_size		;AN061;go to next sublist
	loop	set_subst			;AN061;loop CX times
	pop	cx				;AN061;get number of subst back

	mov	bx,si				;AN061;get start of sublist to BX
	cmp	word ptr [bx.$M_S_VALUE],offset trangroup:string_ptr_2 ;AN061;are we using double indirection?
	jnz	ready_to_print			;AN061;no - we already have address
	mov	dx,string_ptr_2 		;AN061;get address in string_ptr_2
	mov	word ptr [bx.$M_S_VALUE],dx	;AN061;put it into the subst block

READY_TO_PRINT:
	mov	bx,Printf_Handle		;AN000;get print handle
	mov	dl,Msg_Cont_Flag		;AN000;set up control flag
	mov	dh,Msg_Disp_Class		;AN000;set up display class
	mov	Msg_Cont_Flag,No_Cont_Flag	;AN061;reset flags to avoid
	mov	Msg_Disp_Class,Util_Msg_Class	;AN061;   transient reload

;AD061; push	bx				;AN026; save registers
;AD061; push	cx				;AN026;
;AD061; push	dx				;AN026;
;AD061; push	si				;AN026;
;AD061; push	di				;AN026;
	push	ds				;AN026;
	push	es				;AN026;


	call	SYSDISPMSG			;AN000;call Rod

	pop	es				;AN026; restore registers
	pop	ds				;AN026;
;AD061; pop	di				;AN026;
;AD061; pop	si				;AN026;
;AD061; pop	dx				;AN026;
;AD061; pop	cx				;AN026;
;AD061; pop	bx				;AN026;

	jnc	Print_success			;AN000; everything went okay
	mov	print_err_flag,ax		;AN000;

print_success:
;AD061; cmp	Msg_Disp_Class,Util_Msg_Class	;AN000;Is this a utility message
;AD061; jz	CHECK_FIX			;AN000;YES - go see if substitutions
;AD061; mov	msg_flag,ext_msg_class		;AN022;set message flag
;AD061; mov	di,offset trangroup:extend_buf_ptr ;AN000; Get address of extended message block
;AD061; xor	ax,ax				;AN000;clear ax register
;AD061; stosw					;AN000;clear out message number
;AD061; stosb					;AN000;clear out subst count

;AD061;  CHECK_FIX:
;AD061;  pop	 dx				 ;AN000;restore dx
;AD061;  cmp	 cx,0				 ;AN000;Any substitutions?
;AD061;  jz	 NO_FIXUP			 ;AN000;No - leave

;AD061;  mov	 si,dx				 ;AN000;Reset changes so transient won't reload
;AD061;  add	 si,Ptr_Seg_Pos 		 ;AN000;Point to position of first segment

;AD061;FIX_SUBST:
;AD061;  mov	 word ptr [si],0		 ;AN000;reset segment to 0
;AD061;  add	 si,Parm_Block_Size		 ;AN000;point to position of next segment
;AD061;  loop	 FIX_SUBST			 ;AN000;keep replacing until complete
;AD061;  cmp	 string_ptr_2_sb,no_subst	 ;AN000;was double indirection used?
;AD061;  jz	 no_fixup			 ;AN000;no - we're finished
;AD061;  mov	 si,string_ptr_2_sb		 ;AN000;get offset changed
;AD061;  mov	 parm_off_pos [si],offset trangroup:string_ptr_2 ;AN000; set address back to string_ptr_2

;AD061;NO_FIXUP:
;AD061; mov	Msg_Cont_Flag,No_Cont_Flag	;AN000;reset flags to avoid
;AD061; mov	Msg_Disp_Class,Util_Msg_Class	;AN000;   transient reload
	pop	dx				;AN061;restore dx
	pop	si				;AN000;restore registers
	pop	di				;AN000;
	pop	es				;AN000;restore registers
	pop	cx				;AN000;
	pop	bx				;AN000;
	pop	ax				;AN000;
	cmp	print_err_flag,0		;AN000; if an error occurred - handle it
	jnz	print_err			;AN000;

	ret					;AC000;

print_err:
	push	cs
	pop	es
	cmp	Printf_Handle,2 		;AN026;Print to STDERR?
	jnz	not_stderr			;AN026;no - continue
	jmp	tcommand			;AN026;Yes - hopless - just exit

not_stderr:
	mov	ax,print_err_flag		;AN026;get extended error number back
	mov	es,[resseg]			; No, set up for error, load the
assume	es:resgroup				;  right error msg, and jmp to cerror.
	test	PipeFlag,-1
	jz	go_to_error
	invoke	PipeOff
	mov	dx,offset trangroup:pipeemes_ptr
	jmp	short print_err_exit			;AC000;

go_to_error:
	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
	mov	dx,offset TranGroup:Extend_Buf_ptr ;AC000; get extended message pointer
	mov	Extend_Buf_ptr,ax		;AN000; get message number in control block

PRINT_ERR_EXIT: 				;AC000;
	push	cs
	pop	es
	JMP	CERROR

;****************************************************************
;*
;* ROUTINE:	TSYSLOADMSG
;*
;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSLOADMSG
;*
;* OUTPUT:	Outputs from SYSLOADMSG
;*
;****************************************************************


TSYSLOADMSG	PROC	NEAR			;AN000;

	push	bx				;AN000;
	call sysloadmsg 			;AN000; call routine
	pop	bx				;AN000;
	ret					;AN000; exit

TSYSLOADMSG	ENDP				;AN000;

;****************************************************************
;*
;* ROUTINE:	TSYSGETMSG
;*
;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSGETMSG
;*
;* OUTPUT:	Outputs from SYSGETMSG
;*
;****************************************************************


TSYSGETMSG	PROC	NEAR			;AN000;

	push	cx				;AN000;
	call sysgetmsg				;AN000; call routine
	pop	cx				;AN000;
	ret					;AN000; exit

TSYSGETMSG	ENDP				;AN000;

MSG_SERVICES <COMT,NOVERCHECKmsg,NEARmsg,LOADmsg,NOCHECKSTDIN,NOCHECKSTDOUT,GETmsg> ;AC026; The message services
MSG_SERVICES <COMT,NEARmsg,SETSTDIO,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg>	    ;AC026; The message services

PRINTF_LAST LABEL   WORD

include msgdcl.inc


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\uinit.asm ===
page ,132
;   SCCSID = @(#)uinit.asm  4.5 85/12/04
;   SCCSID = @(#)uinit.asm  4.5 85/12/04
TITLE   COMMAND Initialization messages
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;   Revision History
;   ================
;   M003    SR  07/16/90    Added Lh_OffUnlink to the offset
;               patch table (Reloc_Table) for UMB
;               support
;

.XCREF
.XLIST
include comsw.asm
include comseg.asm
include ifequ.asm
.LIST
.CREF

addr macro sym,name
     public name
     ifidn <name>,<>

        dw offset resgroup:sym
     else

name        dw  offset resgroup:sym
     endif
     endm

CODERES segment

    extrn   ContC       :near
    extrn   DskErr      :near
    extrn   Int_2e      :near
    extrn   MsgInt2fHandler :near
    extrn   Exec_Ret    :near
    extrn   TRemCheck   :far
    extrn   TrnLodCom1  :near
    extrn   MsgRetriever    :near
    extrn   LodCom      :near
    extrn   THeadFix    :far
    extrn   Lh_OffUnlink    :far    ; M003

CODERES ends


;;ENVIRONMENT   SEGMENT PUBLIC PARA     ;AC000;
;;  EXTRN   ECOMSPEC:BYTE
;;ENVIRONMENT ENDS

TRANCODE    SEGMENT PUBLIC BYTE     ;AC000;
    extrn   Printf_init:FAR
    extrn   Triage_Init:FAR
    extrn   append_parse:FAR        ;AN054;
TranCode    ENDS

INIT        SEGMENT PUBLIC PARA     ;AC000;


    public  icondev
    public  BADCSPFL
    public  COMSPECT
; NTVDM not used public  AUTOBAT
    public  space
    public  PRDATTM
    public  INITADD
    public  print_add
    public  CHUCKENV
    public  scswitch
    public  skswitch
    public  ucasea
;;  public  ECOMLOC
    public  equalsign
    public  lcasea
    public  lcasez
    public  comspstring
    public  EnvSiz
    public  EnvMax
    public  initend
    public  trnsize
    public  resetenv            ;AC000;
    public  ext_msg             ;AC000;
    public  num_positionals
    public  internat_info
    public  parsemes_ptr

    PUBLIC  triage_add
    PUBLIC  oldenv
    PUBLIC  usedenv
; NTVDM not used PUBLIC  KAUTOBAT               ;AN000;  3/3/KK
    public  eswitch             ;AN018;
    public  dswitch             ;AN018;
    public  init_parse          ;AN054;
    public  old_parse_ptr           ;AN057;
    PUBLIC  pars_msg_off            ;AN060;
    PUBLIC  pars_msg_seg            ;AN060;

    public  PathString
    public  Reloc_Table
    public  ResJmpTable
    public  FirstCom

    public  DevFlag
    public  PathFlag


include resmsg.equ              ;AC000;


ICONDEV LABEL BYTE
        DB  "/DEV/"
        DB  "CON",0,0,0,0,0,0               ; Room for 8 char device
BADCSPFL    DB  0
COMSPECT    DB  "\COMMAND.COM",0,0
;NTVDM not used AUTOBAT         DB      0,":\AUTOEXEC.BAT",0,0DH              ;AC027;
;NTVDM not used KAUTOBAT        DB      0,":\KAUTOEXE.BAT",0,0DH        ;AC027;  3/3/KK

PRDATTM     DB  -1              ;Init not to prompt for date time
INITADD     DD  ?
print_add   LABEL   DWORD
        DW  OFFSET TranGroup:Printf_INIT
        DW  0
triage_add  LABEL   DWORD
        DW  OFFSET TranGroup:Triage_Init
        DW  0
CHUCKENV    DB  0
;eg ECOMLOC DW  OFFSET ENVIRONMENT:ECOMSPEC-10H
;;ECOMLOC   DW  OFFSET ENVIRONMENT:ECOMSPEC ;eg

PathString  db  "PATH=",0
ComspString db  "COMSPEC=\COMMAND.COM",0

;;COMSPSTRING   DB  "COMSPEC="

equalsign   db  "="
lcasea      db  "a"
lcasez      db  "z"
space       db  " "
scswitch    db  "C"                             ; Single command
skswitch    db  "K"                             ; Single command
ucasea      db  "A"

EnvSiz      DW  0               ; size user wants to allocate
EnvMax      DW  0               ; maximum size allowed.
oldenv      DW  0               ; envirseg at initialization
usedenv     DW  0               ; amount of envirseg used
PARS_MSG_OFF    DW  0               ;AN060;  SAVED PARSE ERROR MESSAGE OFFSET
PARS_MSG_SEG    DW  0               ;AN060;  SAVED PARSE ERROR MESSAGE SEGMENT

;Do not separate the following two words.  Used to call transient PARSE routine

init_parse  label   dword               ;AN054;
init_p      DW  TRANGROUP:APPEND_PARSE      ;AN054;
initend     DW  0               ;eg segment address of end of init

;End of data that shouldn't be separated.

trnsize     DW  0               ;eg size of transient in paragraphs
resetenv    DB  0               ;eg set if we need to setblck env at endinit
ext_msg     DB  0               ;AN000; set if /MSG switch entered
eswitch     db  0               ;AN018; set if /e was entered
dswitch     db  0               ;AN018; set if /d was entered
parsemes_ptr    dw  0           ;AN000; word to store parse error number

;
; PARSE BLOCK FOR COMMAND
;
PUBLIC  PARSE_COMMAND               ;AN000;
PUBLIC  COMND1_OUTPUT               ;AN000;
PUBLIC  COMND1_TYPE             ;AN000;
PUBLIC  COMND1_CODE             ;AN000;
PUBLIC  COMND1_SYN              ;AN000;
PUBLIC  COMND1_ADDR             ;AN000;
PUBLIC  COMMAND_F_SYN               ;AN000;
PUBLIC  COMMAND_P_SYN               ;AN000;
PUBLIC  COMMAND_C_SYN               ;AN000;
PUBLIC  COMMAND_D_SYN               ;AN000;
PUBLIC  COMMAND_E_SYN               ;AN000;
PUBLIC  COMMAND_K_SYN               ;AN000;
PUBLIC  COMMAND_L2_SYN
PUBLIC  COMMAND_L_SYN
PUBLIC  COMMAND_M_SYN               ;AN000;
PUBLIC  COMMAND_U_SYN
PUBLIC  COMMAND_?_SYN
PUBLIC  COMMAND_Y_SYN
PUBLIC  COMMAND_Z_SYN

;
;  The following parse control block is used for COMMAND.  This block is
;  used for parsing during initialization.  The sytax for COMMAND is:
;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable][/K executable]
;
;  Anything on the command line after the /C or /K switch will be passed to the
;  executable command, so if /C or /K is used, it must be specified last. The
;  /MSG switch can only be specified if the /P switch is specified.
;
;  The /? switch causes help text to be displayed.  Any other options
;  on the command line are ignored.  Command.com will not load if /?
;  is specified.
;

ENVBIG  EQU 32768               ;AN000; maximum environment size
ENVSML  EQU 160             ;AN000; minimum environment size



INTERNAT_INFO   LABEL   BYTE            ;AN000; used for country info after parsing is completed
PARSE_COMMAND   LABEL   BYTE            ;AN000;
        DW  RESGROUP:COMMAND_PARMS  ;AN000;
        DB  0           ;AN000; no extra delimiter

COMMAND_PARMS   LABEL   BYTE            ;AN000;
        DB  0,2         ;AN000; 1 positional parm
        DW  RESGROUP:COMMAND_FILE   ;AN000;
        dw  RESGROUP:Command_File
        DB  13            ;AN000; 13 switches
        DW  RESGROUP:COMMAND_SWITCH1 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH2 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH3 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH4 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH5 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH6 ;AN000;
        DW  RESGROUP:COMMAND_SWITCH7
        DW  RESGROUP:COMMAND_SWITCH8
        DW  RESGROUP:COMMAND_SWITCH9
        DW  RESGROUP:COMMAND_SWITCH10
        DW  RESGROUP:COMMAND_SWITCH11
        DW  RESGROUP:COMMAND_SWITCH12
        DW  RESGROUP:COMMAND_SWITCH13
        DB  0           ;AN000; no keywords

COMMAND_FILE    LABEL   BYTE            ;AN000;
        DW  0201H           ;AN000; filespec - optional
        DW  1           ;AN000; capitalize - file table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  0           ;AN000; no keywords

COMMAND_SWITCH1 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_P_SYN   DB  "/P",0                  ;AN000; /P switch

COMMAND_SWITCH2 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_F_SYN   DB  "/F",0                  ;AN000; /F switch

COMMAND_SWITCH3 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_D_SYN   DB  "/D",0                  ;AN000; /D switch

COMMAND_SWITCH4 LABEL   BYTE            ;AN000;
        DW  8000H           ;AN000; numeric value - required
        DW  0           ;AN000; no function flags
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:COMMAND_E_VAL  ;AN000; pointer to value list
        DB  1           ;AN000; 1 keyword
COMMAND_E_SYN   DB  "/E",0                  ;AN000; /E switch

COMMAND_E_VAL   LABEL   BYTE            ;AN000;
        DB  1           ;AN000;
        DB  1           ;AN000; 1 range
        DB  1           ;AN000; returned if result
        DD  ENVSML,ENVBIG       ;AN000; minimum & maximum value
        DB  0           ;AN000; no numeric values
        DB  0           ;AN000; no string values

COMMAND_SWITCH5 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_C_SYN   DB  "/C",0                  ;AN000; /C switch

COMMAND_SWITCH6 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_M_SYN   DB  "/MSG",0                ;AN000; /MSG switch

COMMAND_SWITCH7 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_?_SYN   DB  "/?",0                  ;AN000; /? switch

COMMAND_SWITCH8 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_Z_SYN   DB  "/Z",0          ;AN000; /Z switch

COMMAND_SWITCH9 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_K_SYN   DB  "/K",0                  ;AN000; /K switch

COMMAND_SWITCH10 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_Y_SYN   DB  "/Y",0                  ;AN000; /Y switch

COMMAND_SWITCH11 LABEL   BYTE            ;AN000;
        DW  0           ;AN000; no match flags
        DW  2           ;AN000; capitalize by char table
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:NO_VAL     ;AN000;
        DB  1           ;AN000; 1 keyword
COMMAND_L_SYN   DB  "/LOW",0                ;AN000; /LOW switch

COMMAND_SWITCH12 LABEL   BYTE            ;AN000;
        DW  8000H           ;AN000; numeric value - required
        DW  0           ;AN000; no function flags
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:COMMAND_L2_VAL  ;AN000; pointer to value list
        DB  1           ;AN000; 1 keyword
COMMAND_L2_SYN   DB  "/L",0                  ;AN000; /L switch

COMMAND_L2_VAL   LABEL   BYTE            ;AN000;
        DB  1           ;AN000;
        DB  1           ;AN000; 1 range
        DB  1           ;AN000; returned if result
        DD  0,ENVBIG       ;AN000; minimum & maximum value
        DB  0           ;AN000; no numeric values
        DB  0           ;AN000; no string values

COMMAND_SWITCH13 LABEL   BYTE            ;AN000;
        DW  8000H           ;AN000; numeric value - required
        DW  0           ;AN000; no function flags
        DW  RESGROUP:COMND1_OUTPUT  ;AN000; result buffer
        DW  RESGROUP:COMMAND_U_VAL  ;AN000; pointer to value list
        DB  1           ;AN000; 1 keyword
COMMAND_U_SYN   DB  "/U",0                  ;AN000; /U switch

COMMAND_U_VAL   LABEL   BYTE            ;AN000;
        DB  1           ;AN000;
        DB  1           ;AN000; 1 range
        DB  1           ;AN000; returned if result
        DD  0,ENVBIG       ;AN000; minimum & maximum value
        DB  0           ;AN000; no numeric values
        DB  0           ;AN000; no string values


COMND1_OUTPUT   LABEL   BYTE            ;AN000;
COMND1_TYPE DB  0           ;AN000; type
COMND1_CODE DB  0           ;AN000; return value
COMND1_SYN  DW  0           ;AN000; synonym pointer
COMND1_ADDR DD  0           ;AN000; numeric value / address
                        ;   of string value

NO_VAL      DB  0           ;AN000; no values
num_positionals DW  0           ;AN000; counter for positionals
old_parse_ptr   DW  0           ;AN057; SI position before calling parser



;***    INITIALIZATION MESSAGES

    include comimsg.inc     ;M00


;SR;
; This table of offsets is used by the init code to calculate the new offsets
;for these labels after the resident code has been relocated
;

Reloc_Table dw  offset CODERES:MsgInt2fHandler
        dw  offset CODERES:Int_2e
        dw  offset CODERES:ContC
        dw  offset CODERES:DskErr
        dw  offset CODERES:Exec_Ret
        dw  offset CODERES:TRemCheck
        dw  offset CODERES:TrnLodCom1
        dw  offset CODERES:LodCom
        dw  offset CODERES:MsgRetriever
        dw  offset CODERES:THeadFix
        dw  offset CODERES:Lh_OffUnlink ; M003

NUM_RELOC_ENTRIES   equ  ($ - Reloc_Table) / 2
public  NUM_RELOC_ENTRIES

ResJmpTable dd  ?       ;stores prev stub jump table addr
FirstCom        db  0       ;flag set if first command.com

DevFlag     db  0
PathFlag        db  0

INIT    ends

    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tpipe.asm ===
page ,132
;	SCCSID = @(#)tpipe.asm	1.1 85/05/14
;	SCCSID = @(#)tpipe.asm	1.1 85/05/14
TITLE	PART8 COMMAND Transient routines.
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M025	SR	9/12/90	Removed calls to SetStdInOn,SetStdInOff
;				SetStdOutOn & SetStdOutOff.
;

.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include syscall.inc
	include pdb.inc
	include comseg.asm
	include comequ.asm
.list
.cref


DATARES 	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	ECHOFLAG:BYTE
	EXTRN	InitFlag:byte
	EXTRN	INPIPEPTR:WORD
	EXTRN	OUTPIPEPTR:WORD
	EXTRN	PIPE1:BYTE
;;;	EXTRN	PIPE1T:BYTE
	EXTRN	PIPE2:BYTE
;;;	EXTRN	PIPE2T:BYTE
	EXTRN	PIPEFILES:BYTE
	EXTRN	PIPEFLAG:BYTE
	EXTRN	PIPEPTR:WORD
	EXTRN	RESTDIR:BYTE
	EXTRN	SINGLECOM:WORD

DATARES ENDS

TRANDATA	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	BADDAT_PTR:WORD
	EXTRN	BADTIM_PTR:WORD
	EXTRN	curdat_mo_day:word	;AN000;
	EXTRN	CURDAT_PTR:WORD
	EXTRN	curdat_yr:word		;AN000;
	EXTRN	curtim_hr_min:word	;AN000;
	EXTRN	CURTIM_PTR:WORD
	EXTRN	curtim_sec_hn:word	;AN000;
	EXTRN	eurdat_ptr:word
	EXTRN	japdat_ptr:word
	EXTRN	newdat_format:word	;AN000;
	EXTRN	NEWDAT_PTR:WORD
	EXTRN	NEWTIM_PTR:WORD
	EXTRN	parse_date:byte 	;AN000;
	EXTRN	parse_time:byte 	;AN000;
	EXTRN	PIPEEMES_PTR:WORD
	EXTRN	promtim_hr_min:word	;AN000;
	EXTRN	promtim_ptr:word	;AN000;
	EXTRN	promtim_sec_hn:word	;AN000;
	EXTRN	STRING_BUF_PTR:WORD	;AC000;
	EXTRN	SYNTMES_PTR:WORD
	EXTRN	usadat_ptr:word

	extrn	TempVarName:byte

TRANDATA	ENDS

TRANSPACE	SEGMENT PUBLIC BYTE	;AC000;
	EXTRN	COMBUF:BYTE
	EXTRN	date_day:byte		;AN000;
	EXTRN	date_month:byte 	;AN000;
	EXTRN	date_year:word		;AN000;
	EXTRN	INTERNATVARS:BYTE
	EXTRN	RESSEG:WORD
	EXTRN	time_fraction:byte	;AN000;
	EXTRN	time_hour:byte		;AN000;
	EXTRN	time_minutes:byte	;AN000;
	EXTRN	time_seconds:byte	;AN000;
TRANSPACE	ENDS

TRANCODE	SEGMENT PUBLIC BYTE
ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	EXTRN	CERROR:NEAR
	EXTRN	NOPIPEPROC:NEAR
	EXTRN	STD_PRINTF:NEAR
	EXTRN	TCOMMAND:NEAR
	EXTRN	TESTDOREIN:NEAR
	EXTRN	TESTDOREOUT:NEAR
	EXTRN	TESTKANJ:NEAR		;AN000;3/3/KK
	EXTRN	TSYSGETMSG:NEAR 	;AN000;

	extrn	Find_Name_In_Environment:near

	PUBLIC	CTIME
	PUBLIC	DATE
	PUBLIC	DATINIT
	PUBLIC	PIPEDEL
	PUBLIC	PIPEERRSYN
	PUBLIC	PIPEPROC
	PUBLIC	PIPEPROCSTRT
	PUBLIC	PRINT_TIME
	PUBLIC	SETREST
	PUBLIC	SETREST1
	PUBLIC	SINGLETEST

SINGLETEST:
	ASSUME	DS:NOTHING
	push	ds
	MOV	DS,ResSeg
	ASSUME	DS:ResGroup
	CMP	[SINGLECOM],0
	JZ	TestDone
	CMP	[SINGLECOM],0EFFFH
TestDone:
	pop	ds
	return


ASSUME	DS:TRANGROUP
SETREST1:
	MOV	AL,1
SETREST:
	PUSH	DS
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	MOV	[RESTDIR],AL
	POP	DS
ASSUME	DS:TRANGROUP
	return

ASSUME	DS:RESGROUP

;
; Note that we need to handle the same thing that RestDir handles:  the
; requirement that we try only once to restore the user's environment after
; and INT 24 or the like.  If the condition that causes the INT 24 does not
; disappear, we just give up.
;

PIPEDEL:
	assume	ds:nothing
	push	ds
	PUSH	DX
	mov	ds,ResSeg
	assume	ds:ResGroup
	mov	DX,OFFSET RESGROUP:PIPE1	; Clean up in case ^C
	MOV	AH,UNLINK
	INT	21h
	MOV	DX,OFFSET RESGROUP:PIPE2
	MOV	AH,UNLINK
	INT	21h
	POP	DX
	call	PipeOff
	mov	PipeFiles,0
	pop	ds
	return

PIPEERRSYN:
	MOV	DX,OFFSET TRANGROUP:SYNTMES_ptr
	CALL	PIPEDEL
	PUSH	CS
	POP	DS
	JMP	CERROR
PIPEERR:
	pushf
	invoke	triageError
	SaveReg    <AX,DX>			; Save results from TriageError
	MOV	DX,OFFSET TRANGROUP:PIPEEMES_ptr
	CALL	PIPEDEL
	PUSH	CS
	POP	DS
	invoke	std_eprintf
	RestoreReg <DX,AX>			; Restore results from TriageError
	popf
	cmp	ax, 65
	jnz	tcommandj
	JMP	CERROR
tcommandj:
	jmp	tcommand

PIPEPROCSTRT:
ASSUME	DS:TRANGROUP,ES:TRANGROUP
	MOV	DS,[RESSEG]
ASSUME	DS:RESGROUP
	INC	[PIPEFILES]			; Flag that the pipe files exist

	push	es
	push	di
	push	ds
	push	si

	push	ds
	push	es
	pop	ds				;ds = TRANGROUP
	mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
;
;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
;so the routine is not really general
;
	call	Find_Name_In_Environment		;es:di points at path
	pop	ds				;ds = DATARES again
	jc	no_temp_path

	push	ds
	push	es
	pop	ds
	pop	es				;swap ds and es
	mov	si,di				;ds:si points at path

	call	skip_white			;skip white space chars
;
;This copies the path into both buffers -- Pipe1 & Pipe2
;
	call	copy_pipe_path			;copy the pipe path


;
;Check if the TEMP path is valid
;
	push	es
	pop	ds				;ds = DATARES
	mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
	mov	ax, (CHMOD shl 8) or 0
	int	21h
	jc	no_temp_path

	test	cx,10h				;is it a directory?
	jnz	no_temp_path			;yes, continue (carry clear)

	stc					;no, indicate fail

no_temp_path:
	pop	si
	pop	ds
	pop	di
	pop	es
	jnc	crt_temp			;path found, create tempfiles
;;;;
;;;;Invalid or no TEMP path, default to root of current drive
;;;;

;;;	MOV	AH,Get_Default_Drive		; Get current drive
;;;	INT	21h
;;;	ADD	AL,capital_A
;;;	MOV	PIPE2,AL			; Make pipe files in root of def drv
;;;	MOV	Pipe1,AL
;;;	mov	al,':'
;;;	mov	ah,'\'
;;;	mov	word ptr Pipe1+1,ax
;;;	mov	word ptr Pipe2+1,ax			;store ':\'
;;;
;;;	xor	ah,ah				; nul terminate path names
;;;	mov	Pipe1+3,ah
;;;	mov	Pipe2+3,ah

;SR;
; We want to create temp files in the current directory rather than in the 
;root of the drive. This is because the number of files that can be present
;in the root directory is fixed, whereas it is not so in subdirectories.
;
	mov	ah,'.'
	mov	Pipe1,ah
	mov	Pipe2,ah
	xor	ah,ah
	mov	Pipe1+1,ah
	mov	Pipe2+1,ah			;create files in current dir

crt_temp:
	MOV	DX,offset DATARES:Pipe1
	XOR	CX,CX
	mov	ah,CreateTempFile		; the CreateTemp call
	INT	21h
	JnC	@f
	jmp	PIPEERR 			; Couldn't create
@@:
	MOV	BX,AX
	MOV	AH,CLOSE			; Don't proliferate handles
	INT	21h

	MOV	DX,OFFSET RESGROUP:PIPE2
	mov	ah,createTempFile		; the CreateTemp call
	INT	21h
	JnC	@f
	jmp	PIPEERR
@@:
	MOV	BX,AX
	MOV	AH,CLOSE
	INT	21h

	CALL	TESTDOREIN			; Set up a redirection if specified
	MOV	SI,[PIPEPTR]
	CMP	[SINGLECOM],-1
	JNZ	NOSINGP
	MOV	[SINGLECOM],0F000H		; Flag single command pipe
NOSINGP:
	JMP	SHORT FIRSTPIPE

PIPEPROC:
ASSUME	DS:RESGROUP
	AND	[ECHOFLAG],0FEh 		; force current echo to be off
	MOV	SI,[PIPEPTR]
	LODSB
	CMP	AL,AltPipeChr			; Alternate pipe char?
	JZ	IsPipe1 			; Yes
	CMP	AL,vbar
	jz	IsPipe1
	jmp	PIPEEND 			; Pipe done
IsPipe1:
	MOV	DX,[INPIPEPTR]			; Get the input file name
	MOV	AX,(OPEN SHL 8)
	INT	21h
PIPEERRJ:
	jnc	no_pipeerr
	JMP	PIPEERR 			; Lost the pipe file
no_pipeerr:
	MOV	BX,AX
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table],AL		; Redirect

FIRSTPIPE:
	MOV	DI,OFFSET TRANGROUP:COMBUF + 2
	XOR	CX,CX
	CMP	BYTE PTR [SI],0DH		; '|<CR>'
	JNZ	PIPEOK1
PIPEERRSYNJ:
	JMP	PIPEERRSYN
PIPEOK1:
	mov	al,vbar
	CMP	BYTE PTR [SI],al		; '||'
	JZ	PIPEERRSYNJ
	CMP	BYTE PTR [SI],AltPipeChr	; '##' or '|#'?
	JZ	PipeErrSynJ			; Yes, Error
PIPECOMLP:
	LODSB
	STOSB

;;;;	IFDEF	DBCS		3/3/KK
	CALL	TESTKANJ
	JZ	NOTKANJ5
	MOVSB
;
;  Added following 2 commands to the fix pipe bug.
;
	inc	cx				;AN000;  3/3/KK
	inc	cx				;AN000;  3/3/KK
;
	JMP	PIPECOMLP

NOTKANJ5:
;;;;	ENDIF			; 3/3/KK

	CMP	AL,0DH
	JZ	LASTPIPE
	INC	CX
	CMP	AL,AltPipeChr
	JZ	IsPipe2
	CMP	AL,vbar
	JNZ	PIPECOMLP
IsPipe2:
	MOV	BYTE PTR ES:[DI-1],0DH
	DEC	CX
	MOV	[COMBUF+1],CL
	DEC	SI
	MOV	[PIPEPTR],SI			; On to next pipe element
	MOV	DX,[OUTPIPEPTR]
	PUSH	CX
	XOR	CX,CX
	MOV	AX,(CREAT SHL 8)
	INT	21h
	POP	CX
	JC	PIPEERRJ			; Lost the file
	MOV	BX,AX
	MOV	AL,0FFH
	XCHG	AL,[BX.PDB_JFN_Table]
	MOV	DS:[PDB_JFN_Table+1],AL
	XCHG	DX,[INPIPEPTR]			; Swap for next element of pipe
	MOV	[OUTPIPEPTR],DX
	JMP	SHORT PIPECOM

LASTPIPE:
	MOV	[COMBUF+1],CL
	DEC	SI
	MOV	[PIPEPTR],SI			; Point at the CR (anything not '|' will do)
	CALL	TESTDOREOUT			; Set up the redirection if specified
PIPECOM:
	PUSH	CS
	POP	DS
	JMP	NOPIPEPROC			; Process the pipe element

PIPEEND:
	CALL	PIPEDEL
	CMP	[SINGLECOM],0F000H
	JNZ	NOSINGP2
	MOV	[SINGLECOM],-1			; Make it return
NOSINGP2:
	JMP	TCOMMAND

ASSUME	DS:TRANGROUP,ES:TRANGROUP

; Date and time are set during initialization and use
; this routines since they need to do a long return

DATINIT PROC	FAR
	mov	cs:[resseg],ds			; SetInitFlag needs resseg initialized
	PUSH	ES
	PUSH	DS				; Going to use the previous stack
	MOV	AX,CS				; Set up the appropriate segment registers
	MOV	ES,AX
	MOV	DS,AX
	invoke	TSYSLOADMSG			;AN000; preload messages
	MOV	DX,OFFSET TRANGROUP:INTERNATVARS;Set up internat vars
	MOV	AX,INTERNATIONAL SHL 8
	INT	21H
	MOV	WORD PTR DS:[81H],13		; Want to prompt for date during initialization
	MOV	[COMBUF],COMBUFLEN		; Init COMBUF
	MOV	WORD PTR [COMBUF+1],0D01H
	CALL	DATE
	CALL	CTIME
	POP	DS
	POP	ES
	RET
DATINIT ENDP

; DATE - Gets and sets the time


	break	Date


; ****************************************************************
; *
; * ROUTINE:	 DATE - Set system date
; *
; * FUNCTION:	 If a date is specified, set the system date,
; *		 otherwise display the current system date and
; *		 prompt the user for a new date.  If an invalid
; *		 date is specified, issue an error message and
; *		 prompt for a new date.  If the user enters
; *		 nothing when prompted for a date, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

DATE:
	MOV	SI,81H				; Accepting argument for date inline
	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	JZ	PRMTDAT 			;AC000; yes - go ask for date
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	daterr				;AN000; yes - go issue message
	JMP	short COMDAT			;AC000; we have a date

PRMTDAT:
	; Print "Current date is

	invoke	GetDate 			;AN000; get date  for output
	xchg	dh,dl				;AN000; switch month & day
	mov	CurDat_yr,cx			;AC000; put year into message control block
	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
	invoke	std_printf
;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block

GET_NEW_DATE:					;AN000;
	call	getdat				;AC000; prompt user for date
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	date_end			;AC000; yes - exit
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	daterr				;AN000; yes - go issue message
COMDAT:
	mov	cx,date_year			;AC000; get parts of date in
	mov	dh,date_month			;AC000;    cx and dx for set
	mov	dl,date_day			;AC000;    date function call.
	push	cx				;AC000; save date
	push	dx				;AC000;
	mov	cx,1				;AC000; set 1 positional entered
	xor	dx,dx				;AN029;
	invoke	cmd_parse			;AN029; call parser
	cmp	al,end_of_line			;AN029; Are we at end of line?
	pop	dx				;AC000; retrieve date
	pop	cx				;AC000;
	jnz	daterr				;AC000; extra stuff on line - try again
	MOV	AH,SET_DATE			;yes - set date
	INT	21h
	OR	AL,AL
	JNZ	DATERR
date_end:
	ret

DATERR:
	invoke	crlf2				;AN028; print out a blank line
	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
	invoke	std_printf
	JMP	GET_NEW_DATE			;AC000; get date again


; TIME gets and sets the time

	break	Time

; ****************************************************************
; *
; * ROUTINE:	 TIME - Set system time
; *
; * FUNCTION:	 If a time is specified, set the system time,
; *		 otherwise display the current system time and
; *		 prompt the user for a new time.  If an invalid
; *		 time is specified, issue an error message and
; *		 prompt for a new time.  If the user enters
; *		 nothing when prompted for a time, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

assume	ds:trangroup,es:trangroup

CTIME:
	MOV	SI,81H				; Accepting argument for time inline
	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser
	cmp	ax,end_of_line			;AC000; are we at end of line?
	JZ	PRMTTIM 			;AC000; yes - prompt for time
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	timerr				;AN000; yes - go issue message
	JMP	short COMTIM			;AC000; we have a time

PRMTTIM:
	;Printf "Current time is ... "

	MOV	AH,GET_TIME			;AC000; get the current time
	INT	21h			;AC000;    Get time in CX:DX
	xchg	ch,cl				;AN000; switch hours & minutes
	xchg	dh,dl				;AN000; switch seconds & hundredths
	mov	CurTim_hr_min,cx		;AC000; put hours and minutes into message subst block
	mov	CurTim_sec_hn,dx		;AC000; put seconds and hundredths into message subst block
	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
	invoke	std_printf
;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block

GET_NEW_TIME:
	call	gettim				;AC000;
	cmp	ax,end_of_line			;AC000; are we at end of line?
	jz	time_end			;AC000;
	cmp	ax,result_no_error		;AN000; did we have an error?
	jne	timerr				;AN000; yes - go issue message

COMTIM:
	mov	ch,time_hour			;AC000; get parts of time in
	mov	cl,time_minutes 		;AC000;    cx and dx for set
	mov	dh,time_seconds 		;AC000;    time function call
	mov	dl,time_fraction		;AC000;
	push	cx				;AC000; save time
	push	dx				;AC000;
	mov	cx,1				;AC000; set 1 positional parm entered
	xor	dx,dx				;AN029;
	invoke	cmd_parse			;AN029; call parser
	cmp	al,end_of_line			;AN029; Are we at end of line?
	pop	dx				;AC000; retieve time
	pop	cx				;AC000;
	jnz	timerr				;AC000; extra stuff on line - try again

SAVTIM:
	MOV	AH,SET_TIME
	INT	21h
	OR	AL,AL
	JNZ	TIMERR				;AC000; if an error occured, try again

TIME_END:

	ret

TIMERR:
	invoke	crlf2				;AN028; print out a blank line
	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
	invoke	std_printf			; Print error message
	JMP	GET_NEW_TIME			;AC000; Try again


;
; Set the special flag in the INIT flag to the value in CX.
;
SetInitFlag:
	mov	ds,[RESSEG]
assume ds:resgroup
	and	InitFlag,NOT initSpecial
	or	InitFlag,cL
	push	cs
	pop	ds
	return

Public	PipeOff
PipeOff:
	ASSUME	DS:NOTHING,ES:NOTHING
	SaveReg <DS,AX>
	MOV	DS,ResSeg
	ASSUME	DS:RESGroup
	XOR	AL,AL
	XCHG	PipeFlag,AL
	OR	AL,AL
	JZ	PipeOffDone
	SHR	EchoFlag,1
PipeOffDone:
	RestoreReg  <AX,DS>
	return


PRINT_TIME:

	MOV	AH,GET_TIME
	INT	21h			; Get time in CX:DX

	PUSH	ES
	PUSH	CS
	POP	ES
	xchg	ch,cl				;AN000; switch hours & minutes
	xchg	dh,dl				;AN000; switch seconds & hundredths
	mov	promTim_hr_min,cx		;AC000; put hours and minutes into message subst block
	mov	promTim_sec_hn,dx		;AC000; put seconds and hundredths into message subst block
	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
	invoke	std_printf
;AD061; mov	promTim_hr_min,0		;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	promTim_sec_hn,0		;AC000;     pointers in control block

	POP	ES
	return


; ****************************************************************
; *
; * ROUTINE:	 GETDAT - Prompt user for date
; *
; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new date"
; *		 message with the proper date format.  COMBUF
; *		 is reset to get a date from the command line.
; *		 The PARSE_DATE blocks are then reset and the
; *		 PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************


GETDAT	proc	near				;AC000;

	mov	ax,(International SHL 8)	; Determine what format the date
	mov	dx,5ch				;  should be entered in and
	int	21h			;  print a message describing it
	mov	si,dx
	lodsw
	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
	dec	ax
	js	printformat
	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
	jz	printformat
	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
printformat:
	mov	ax,dx				;AN000; get message number of format
	mov	dh,util_msg_class		;AN000; this is a utility message
	call	Tsysgetmsg			;AN000; get the address of the message
	mov	newdat_format,si		;AN000; put the address in subst block
	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
	invoke	std_printf
	mov	newdat_format,no_subst		;AN000; reset subst block

	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET TRANGROUP:COMBUF
	mov	cx,initSpecial			; Set bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for date.
	INT	21h			; Get input line
	xor	cx,cx				; Reset bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for date.
	invoke	CRLF2
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser

	ret

GETDAT	endp					;AC000;


; ****************************************************************
; *
; * ROUTINE:	 GETTIME - Prompt user for time
; *
; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new time"
; *		 message. COMBUF is reset to get a time from the
; *		 command line.	The PARSE_TIME blocks are then
; *		 reset and the PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************


GETTIM	proc	near				;AC000;

	XOR	CX,CX				; Initialize hours and minutes to zero
	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
	invoke	std_printf
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET TRANGROUP:COMBUF
	mov	cx,initSpecial			; Set bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for time.
	INT	21h			; Get input line
	xor	cx,cx				; Reset bit in InitFlag that indicates
	call	SetInitFlag			;  prompting for time.
	invoke	CRLF2
	MOV	SI,OFFSET TRANGROUP:COMBUF+2
	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
	xor	cx,cx				;AN000; clear counter for positionals
	xor	dx,dx				;AN000;
	invoke	cmd_parse			;AC000; call parser

	ret

GETTIM	endp					;AC000;

;
;Skip_white: Skips over the whitespace chars that could be present after
;the '=' sign in the environment variable before the actual path.
;
;	ENTRY:	ds:si = arguments of the environment variable
;
;	EXIT:	ds:si = start of the path
;
;	REGISTERS AFFECTED: ax
;

Skip_white	proc	near

	cld
skw_lp:
	lodsb
	cmp	al,' '				;blank char?
	jz	skw_lp				;yes, skip it
	cmp	al,09				;tab char?
	jz	skw_lp				;yes, skip it

	dec	si				;point at first non-white

	ret

Skip_white	endp

;
;Copy_pipe_path:	This routine copies the path from the TEMP environment
;variable into the path buffers Pipe1 & Pipe2.
;
;	ENTRY:	ds:si = path to be copied
;		es = RESGROUP
;
;	EXIT:	Path copied into Pipe1 and Pipe2.
;
;	REGISTERS AFFECTED: si, di, cx, ax
;

Copy_pipe_path	proc	near

	mov	cx,0ffffh
	xor	al,al

	mov	di,si
	push	es			;save es
	push	ds
	pop	es			;es:di = path to be copied
	
	cld
	push	di
	repnz	scasb			;look for the null char
	pop	di

	pop	es			;es = RESGROUP again

	not	cx			;length including the null

	mov	di,offset DATARES:Pipe1	
	push	di
	push	cx			
	rep	movsb			;copy path into Pipe1
	pop	cx
	pop	di

	push	ds
	push	es
	pop	ds			;ds:si = Pipe1
	mov	si,di
	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
	rep	movsb			;copy path into Pipe2
	pop	ds

	ret				;

Copy_pipe_path	endp


TRANCODE    ENDS
	    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tspc.asm ===
page ,132
;	SCCSID = @(#)tspc.asm	4.1 85/09/22
;	SCCSID = @(#)tspc.asm	4.1 85/09/22
TITLE	COMMAND Transient Uninitialized DATA
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

comment %

The TRANSPACE segment contains variable data that is considered
volatile between command cycles, and therefore is not included in the
transient checksum area.  Contents of these variables MUST be
initialized before use, and must not be relied upon from command
cycle to command cycle.

No constant data values should be stored here.

%
        



.xlist
.xcref
	include comsw.asm
	include dossym.inc
	include find.inc
	include intnat.inc
	include comequ.asm
	include comseg.asm
.list
.cref

; Uninitialized transient data
TRANSPACE	SEGMENT PUBLIC BYTE

	PUBLIC	ALLSWITCH
	PUBLIC	append_exec		;AN041;
	PUBLIC	arg
	PUBLIC	argbufptr
	PUBLIC	ARGC
	PUBLIC	ARG1S
	PUBLIC	ARG2S
	PUBLIC	ARGTS
	PUBLIC	arg_buf
	PUBLIC	ASCII
        PUBLIC  AttrSelect
        PUBLIC  AttrSpecified
	PUBLIC	BatBuf
	PUBLIC	BatBufEnd
	PUBLIC	BatBufPos
	PUBLIC	BATHAND
	PUBLIC	BINARY
	PUBLIC	BITS
	PUBLIC	BWDBUF
	PUBLIC	BYTCNT
	PUBLIC	bytes_free
	PUBLIC	CFLAG
	PUBLIC	CHARBUF
	PUBLIC	CHKDRV
	PUBLIC	COM
	PUBLIC	COMBUF
	PUBLIC	comma
	PUBLIC	comptr
	PUBLIC	COMSW
	PUBLIC	CONCAT
	PUBLIC	copy_Num
	PUBLIC	CountryPtrInfo
	PUBLIC	CountryPtrId
	PUBLIC	CountryPtr
	PUBLIC	CPDATE
	PUBLIC	CPTIME
	PUBLIC	cpyflag
	PUBLIC	CURDRV
	PUBLIC	DATE_DAY		;AN000;
	PUBLIC	DATE_MONTH		;AN000;
	PUBLIC	DATE_OUTPUT		;AN000;
	PUBLIC	DATE_TYPE		;AN000;
	PUBLIC	DATE_YEAR		;AN000;
	PUBLIC	DEST
	PUBLIC	DESTBUF
	PUBLIC	DestClosed
	PUBLIC	DESTDIR
	PUBLIC	DESTFCB
	PUBLIC	DESTFCB2
	PUBLIC	DESTHAND
	PUBLIC	DESTINFO
	PUBLIC	DESTISDEV
	PUBLIC	DESTISDIR
	PUBLIC	DESTNAME
	PUBLIC	DESTSIZ
	PUBLIC	DESTSWITCH
	PUBLIC	DESTTAIL
	PUBLIC	DESTVARS
	PUBLIC	DIRBUF
	PUBLIC	DIRCHAR
	PUBLIC	dirflag 		;AN015;
	PUBLIC	Dir_Num
	PUBLIC	display_ioctl		;AN000;
	PUBLIC	display_mode		;AN000;
	PUBLIC	display_width		;AN000;
	PUBLIC	DRIVE_NUMBER		;AN000;
	PUBLIC	DRIVE_OUTPUT		;AN000;
	PUBLIC	DRIVE_TYPE		;AN000;
	PUBLIC	DRIVE_VALUE		;AN000;
	PUBLIC	ELCNT
	PUBLIC	ELPOS
	PUBLIC	ENDDESTBUF
	PUBLIC	EXECPATH
	PUBLIC	EXEC_ADDR
	PUBLIC	EXEFCB
	PUBLIC	expand_star
	PUBLIC	ext_entered		;AN005;
	PUBLIC	FBUF
        PUBLIC  FileCnt
        PUBLIC  FileCntTotal
        PUBLIC  FileSiz
        PUBLIC  FileSizTotal
	PUBLIC	file_size_high
	PUBLIC	file_size_low
	PUBLIC	FILTYP
	PUBLIC	FIRSTDEST
	PUBLIC	FRSTSRCH
	PUBLIC	GOTOLEN
	PUBLIC	HEADCALL
	PUBLIC	ID
	PUBLIC	IDLEN
	PUBLIC	IFNOTFLAG
	PUBLIC	if_not_count
	PUBLIC	INEXACT
	PUBLIC	INTERNATVARS
	PUBLIC	KPARSE
	PUBLIC	last_arg
        PUBLIC  PerLine
        PUBLIC  LeftOnLine
        PUBLIC  LeftOnPage
	PUBLIC	linperpag		;AN000;
	PUBLIC	major_ver_num
	PUBLIC	MELCOPY
	PUBLIC	MELSTART
	PUBLIC	minor_ver_num
	PUBLIC	msg_flag		;AN022;
	PUBLIC	msg_numb		;AN022;
	PUBLIC	NOWRITE
	PUBLIC	NXTADD
	PUBLIC	objcnt
	PUBLIC	OCtrlZ
	PUBLIC	OFilePtr_Hi
	PUBLIC	OFilePtr_Lo
	PUBLIC	OldCtrlCHandler
	PUBLIC	one_char_val
	PUBLIC	PARM1
	PUBLIC	PARM2
	PUBLIC	parse_last		;AN018;
	PUBLIC	PARSE1_ADDR		;AN000;
	PUBLIC	PARSE1_CODE		;AN000;
	PUBLIC	PARSE1_OUTPUT		;AN000;
	PUBLIC	PARSE1_SYN		;AN000;
	PUBLIC	PARSE1_TYPE		;AN000;
	PUBLIC	PATHCNT
	PUBLIC	pathinfo
	PUBLIC	PATHPOS
	PUBLIC	PATHSW
	PUBLIC	PLUS
	PUBLIC	plus_comma
	PUBLIC	print_err_flag		;AN000;
	PUBLIC	psep_char
	PUBLIC	RCH_ADDR
	PUBLIC	RDEOF
	PUBLIC	RE_INSTR
	PUBLIC	RESSEG
	PUBLIC	SCANBUF
	PUBLIC	SDIRBUF
	PUBLIC	search_best
	PUBLIC	search_best_buf
	PUBLIC	search_curdir_buf
	PUBLIC	search_error
	PUBLIC	SKPDEL
	PUBLIC	SOURCE
	PUBLIC	SPECDRV
	PUBLIC	SRCBUF
	PUBLIC	SRCHAND
	PUBLIC	SRCINFO
	PUBLIC	SRCISDEV
	PUBLIC	SRCISDIR
	PUBLIC	SRCPT
	PUBLIC	SRCSIZ
	PUBLIC	SRCTAIL
	PUBLIC	SRCVARS
	PUBLIC	srcxname
	PUBLIC	STACK
	PUBLIC	STARTEL
	PUBLIC	string_ptr_2
;AD061; PUBLIC	string_ptr_2_sb 	;AN000;
	PUBLIC	subst_buffer		;AN061;
	PUBLIC	SWITCHAR
	PUBLIC	system_cpage
	PUBLIC	TERMREAD
	PUBLIC	TIME_FRACTION		;AN000;
	PUBLIC	TIME_HOUR		;AN000;
	PUBLIC	TIME_MINUTES		;AN000;
	PUBLIC	TIME_OUTPUT		;AN000;
	PUBLIC	TIME_SECONDS		;AN000;
	PUBLIC	TIME_TYPE		;AN000;
	PUBLIC	TPA
	PUBLIC	tpbuf
	PUBLIC	TRANSPACEEND
	PUBLIC	TRAN_TPA
	PUBLIC	trgxname
	PUBLIC	UCOMBUF
	PUBLIC	USERDIR1
	PUBLIC	vol_drv
	PUBLIC	vol_ioctl_buf		;AC030;
	PUBLIC	vol_serial		;AC030;
	PUBLIC	vol_label		;AC030;
	PUBLIC	WRITTEN
	PUBLIC	zflag
	PUBLIC	ENV_PTR_SEG
	PUBLIC	ENV_SIZE
	PUBLIC	CMD_PTR_SEG
	PUBLIC	CMD_PTR_OFF
        PUBLIC  CMD_SIZE
        PUBLIC  SCS_EXIT_CODE
	PUBLIC	SCS_CUR_DRIVE
	PUBLIC	SCS_NUM_DRIVES
	PUBLIC	SCS_STD_HANDLE
	PUBLIC	SCS_STD_BITS
        PUBLIC  SCS_CODEPAGE
        PUBLIC  SCS_TSREXIT
        PUBLIC  SCS_BATSTATUS
        PUBLIC  SCS_RDRINFO
        PUBLIC  EXECPATH_SEG
        PUBLIC  EXECPATH_OFF
        PUBLIC  EXECPATH_SIZE
	PUBLIC	EXECEXT_TYPE

	Public	TypeFilSiz		;stores size of file to be typed

	IF  IBM
	PUBLIC	ROM_CALL
	PUBLIC	ROM_CS
	PUBLIC	ROM_IP
	ENDIF


	ORG	0
ZERO	=	$
SRCXNAME	DB	DIRSTRLEN + 20 DUP (?)	;g buffer for name translate
TRGXNAME	DB	DIRSTRLEN + 20 DUP (?)	;g buffer for name translate
JUNK1		DB	2(?)
FOO_JUNK	DB	2 (?)
UCOMBUF 	DB	COMBUFLEN+3 DUP(?)	; Raw console buffer
COMBUF		DB	COMBUFLEN+3 DUP(?)	; Cooked console buffer
USERDIR1	DB	DIRSTRLEN+3 DUP(?)	; Storage for users current directory
;EXECPATH        DB      COMBUFLEN+3 DUP(?)      ; Path for external command
EXECPATH        DB      EXECPATHLEN DUP(?)       ; ntvdm MAX_PATH+13 extended
RE_INSTR        DB      DIRSTRLEN+3+13 DUP (?)  ; path for input to redirection


; sudeepb - start of cmdinfo structure (it should always match cmdsvc.h
; definition of cmdinfo.

ENV_PTR_SEG	DW	?
ENV_SIZE	DW	?
SCS_CUR_DRIVE	DW	?
SCS_NUM_DRIVES	DW	?
CMD_PTR_SEG	DW	?
CMD_PTR_OFF	DW	?
CMD_SIZE        DW      ?
SCS_EXIT_CODE   DW      ?
SCS_STD_HANDLE	DW	0
SCS_RDRINFO     DD      0
SCS_CODEPAGE    DW      ?
SCS_TSREXIT     DW      0
SCS_BATSTATUS   DW      0
EXECPATH_SEG    DW      0
EXECPATH_OFF    DW      0
EXECPATH_SIZE   DW      0
EXECEXT_TYPE	DW	0

; end of cmdinfo

SCS_STD_BITS    DB      0

; Variables passed up from resident
HEADCALL	LABEL	DWORD
		DW	?
RESSEG		DW	?
TPA		DW	?
SWITCHAR	DB	?
DIRCHAR 	DB	?
EXEC_ADDR	DD	?
RCH_ADDR	DD	?
fTest		DW	?
TRAN_TPA	DW	?

CHKDRV		DB	?
RDEOF		LABEL	BYTE			; Misc flags
IFNOTFLAG	LABEL	BYTE
FILTYP		DB	?
CURDRV		DB	?
CONCAT		LABEL	BYTE
PARM1		DB	?
ARGC		LABEL	BYTE
PARM2		DB	?
COMSW		DW	?			; Switches between command and 1st arg
ARG1S		DW	?			; Switches between 1st and 2nd arg
DESTSWITCH	LABEL	WORD
ARG2S		DW	?			; Switches after 2nd arg
ALLSWITCH	LABEL	WORD
ARGTS		DW	?			; ALL switches except for COMSW
CFLAG		DB	?
DESTCLOSED	LABEL	BYTE
SPECDRV 	DB	?
BYTCNT		DW	?			; Size of buffer between RES and TRANS
NXTADD		DW	?
FRSTSRCH	DB	?
LeftOnLine      DB      ?                       ; entries left on line u.b. DIR
PerLine         DB      ?                       ; entries/line u.b. DIR
LeftOnPage      DW      ?                       ; lines left on page u.b. DIR
FileCnt         DW      ?                       ; file count u.b. DIR
FileSiz         DD      ?                       ; file size u.b. DIR

;               Note:  keep FileCntTotal & FileSizTotal adjacent.

FileCntTotal    DD      ?                       ; total file count u.b. DIR
FileSizTotal    DD      ?                       ; total file size u.b. DIR
CHARBUF 	DB	80 DUP (?)		;line byte character buffer for xenix write
DESTFCB2	LABEL	BYTE
IDLEN		DB	?
ID		DB	8 DUP(?)
COM		DB	3 DUP(?)
DEST		DB	37 DUP(?)
DESTNAME	DB	11 DUP(?)
DESTFCB 	LABEL	BYTE
DESTDIR 	DB	DIRSTRLEN DUP(?)	; Directory for PATH searches
GOTOLEN 	LABEL	WORD
BWDBUF		LABEL	BYTE
EXEFCB		LABEL	WORD
DIRBUF		DB	DIRSTRLEN+3 DUP(?)
SDIRBUF 	DB	12 DUP(?)
BITS		DW	?
PATHCNT 	DW	?
PATHPOS 	DW	?
PATHSW		DW	?
AttrSpecified   db      ?                       ; attribute bits u.b. DIR
AttrSelect      db      ?                       ; attribute bits u.b. DIR
comma		db	0			;g flag set if +,, occurs
plus_comma	db	0			;g flag set if +,, occurs
dirflag 	db	0			;AN015; set when pathcrunch called from DIR
parse_last	dw	0			;AN018; used to hold parsing position

system_cpage	DW	0			;AC001; used for CHCP variable



arg_buf 	db	128 dup (?)
file_size_low	dw	?			;AC000;
file_size_high	dw	?			;AC000;
string_ptr_2	dw	?
;AD061;string_ptr_2_sb dw      ?
copy_Num	dw	?
cpyflag 	db	?
Dir_Num 	DW	?
bytes_free	dw	?
		dw	?
major_ver_num	dw	?
minor_ver_num	dw	?
one_char_val	db	?,0
vol_drv 	db	?

IF  IBM
ROM_CALL	DB	?			; flag for rom function
ROM_IP		DW	?
ROM_CS		DW	?
ENDIF

DESTVARS	LABEL	BYTE
DESTISDIR	DB	?
DESTSIZ 	DB	?
DESTTAIL	DW	?
DESTINFO	DB	?
DESTBUF 	DB	DIRSTRLEN + 20 DUP (?)
ENDDESTBUF	LABEL	BYTE

DESTHAND	DW	?
DESTISDEV	DB	?
FIRSTDEST	DB	?
MELCOPY 	DB	?
MELSTART	DW	?

SRCVARS 	LABEL	BYTE
SRCISDIR	DB	?
SRCSIZ		DB	?
SRCTAIL 	DW	?
SRCINFO 	DB	?
SRCBUF		DB	DIRSTRLEN + 20 DUP (?)

SRCHAND 	DW	?
SRCISDEV	DB	?

SCANBUF 	DB	DIRSTRLEN + 20 DUP (?)

SRCPT		DW	?
INEXACT 	DB	?
NOWRITE 	DB	?
BINARY		DB	?
WRITTEN 	DW	?
TERMREAD	DB	?
ASCII		DB	?
PLUS		DB	?
objcnt		db	?		; Used in copy
CPDATE		DW	?
CPTIME		DW	?

OFilePtr_Lo	DW	?		; original file ptr for COPY when
OFilePtr_Hi	DW	?		; 1st source is also destination
OCtrlZ		DB	?		; original ctrl+Z for COPY when ditto

BATHAND 	DW	?		; Batch handle
STARTEL 	DW	?
ELCNT		DB	?
ELPOS		DB	?
SKPDEL		DB	?
SOURCE		DB	11 DUP(?)

ext_entered	db	0			;AN005;

display_ioctl	db	0			;AN000; info level
		db	0			;AN000; reserved
		dw	crt_ioctl_ln		;AN000; length of data
		dw	?			;AN000; control flags
display_mode	db	?			;AN000; display mode, colors
		db	0			;AN000; reserved
		dw	?			;AN023; colors
		dw	?			;AN000; display width (PELS)
		dw	?			;AN000; display length (PELS)
display_width	dw	?			;AN000; display width
linperpag	dw	linesperpage		;AN000; display length (default to linesperpage)

vol_ioctl_buf	label	byte			;AN000; buffer for ioctl volume label/serial call
		dw	0			;AN000; info level
vol_serial	dd	0			;AN000; volume serial number
vol_label	db	11 dup (" ")            ;AN000; volume label - init to blanks
		db	8  dup (" ")            ;AN000; file system type

expand_star	db	?
msg_flag	db	?			;AN022; flag set if non-utility message issued
msg_numb	dw	0			;AN022; set with extended error message issued
append_exec	db	0			;AN041; set if internal append executed
print_err_flag	dw	0			;AN000; flag set if error during sysdispmsg
subst_buffer	db	parm_block_size*2 dup (0);AN061;

;;;;	IFDEF	DBCS		3/3/KK
KPARSE		DB	?
;;;;	ENDIF			3/3/KK

; Data declarations taken out of parse.asm

arg	arg_unit	<>			; pointers, arg count, string buffer
argbufptr	DW	?			; index for argv[].argpointer
tpbuf		DB	128   DUP (?)		; temporary buffer
LAST_ARG	DW	?			; point at which to accumulate switch info
comptr		dw	?			; ptr into combuf

; Data declarations taken out of path.asm
fbuf	find_buf	<>			; dma buffer for findfirst/findnext
pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
psep_char	DB	?			; '/' or '\'
search_best	DB	(?)			; best code, best filename so far
fname_max_len	equ	13
search_best_buf DB	fname_max_len DUP (?)
search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
search_error	DW	(?)			; address of error message to be printed

; Data declarations taken out of tbatch.asm
if_not_count	DW	?

zflag		db	?			; Used by typefil to indicate ^Z's

		DW	80H DUP(0)		; Init to 0 to make sure the linker is not fooled
STACK		LABEL	WORD

INTERNATVARS	internat_block <>
		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)

;		Buffer for DOS function 64h (Get extended country information)
;		subfunctions 2, 4, 6, or 7:

CountryPtrInfo	label	byte
CountryPtrId	db	?
CountryPtr	dd	?
		.erre	(($ - CountryPtrInfo) GE 5)

OldCtrlCHandler	dd	?			; previous int 23 vector


BatBufPos	DW	?			; integer position in buffer of next byte
BatBuf		DB	BatLen DUP (?)
BatBufEnd	DW	?

TypeFilSiz	dd	?		;stores size of file to be typed

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************
;
; COMMON PARSE OUTPUT BLOCKS
;


;
; Common output blocks for PARSE number, complex, or string values.
;

PARSE1_OUTPUT	LABEL	BYTE			;AN000;
PARSE1_TYPE	DB	0			;AN000;  type
PARSE1_CODE	DB	0			;AN000;  return value
PARSE1_SYN	DW	0			;AN000;  es offset of synonym
PARSE1_ADDR	DD	0			;AN000;  numeric value / address
						;	 of string value

;
;  Common output block for PARSE date strings.
;

DATE_OUTPUT	LABEL	BYTE			;AN000;
DATE_TYPE	DB	0			;AN000;  type
		DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
DATE_YEAR	DW	0			;AN000;  year
DATE_MONTH	DB	0			;AN000;  month
DATE_DAY	DB	0			;AN000;  day

;
;  Common output block for PARSE time strings.
;

TIME_OUTPUT	LABEL	BYTE			;AN000;
TIME_TYPE	DB	0			;AN000;  type
		DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
TIME_HOUR	DB	0			;AN000;  hour
TIME_MINUTES	DB	0			;AN000;  minutes
TIME_SECONDS	DB	0			;AN000;  seconds
TIME_FRACTION	DB	0			;AN000;  hundredths

;
;  Common output block for PARSE drive specifier (one based drive number).
;

DRIVE_OUTPUT	LABEL	BYTE			;AN000;
DRIVE_TYPE	DB	0			;AN000;  type
DRIVE_VALUE	DB	0			;AN000;  return value
		DW	0			;AN000;  es offset of synonym
DRIVE_NUMBER	DB	0			;AN000;  drive number
		DB	0,0,0			;AN000;  reserved

TRANSPACEEND	LABEL	BYTE

TRANSPACE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\br\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Erro de anlise %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Erro estendido %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Erro estendido %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Erro de anlise %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\cht\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\da\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Parsefejl %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Udvidet fejl %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Udvidet fejl %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Parsefejl %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\chp\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\chs\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\cs\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Chyba pi rozboru %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Chyba %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Chyba %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Chyba pi rozboru %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\el\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"  %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"  %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"  %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"   %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\es\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Error de anlisis %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Error extendido %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Error extendido %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Error de anlisis %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\fi\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Lausevirhe %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Laajennettu virhe %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Laajennettu virhe %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Lausevirhe %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\jpn\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\kor\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\ger\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parserfehler %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Erweiterter Fehler %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Erweiterter Fehler %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parserfehler %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\hu\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Feldolgozsi hiba: %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Kiterjesztett hiba: %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Feldolgozsi hiba: %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Kiterjesztett hiba: %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\fr\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Erreur d'analyse %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Erreur tendue %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Erreur tendue %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Erreur d'analyse %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\psu\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\it\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Errore di analisi %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Errore esteso %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Errore esteso %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Errore di analisi %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\nl\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Parseringsfout %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Uitgebreide fout %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Uitgebreide fout %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Parseringsfout %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\pl\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Bd analizy skadni %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Bd rozszerzony %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Bd rozszerzony %1\"";     /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Bd analizy skadni %1\"";   /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tst\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\no\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"Parsefeil %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"Tilleggsfeil %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"Tilleggsfeil %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"Parsefeil %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

command.skl : ..\usa\command.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\usa\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Parse Error %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Extended Error %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Extended Error %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Parse Error %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\ru\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR       "        DB      \"  %%1\"\x0d\x0a"
#define EXTENDED_STR    "        DB      \"  %%1\"\x0d\x0a"
char    *ExtendedErrorText999 =  "\"  %1\"";       /* Mar 88, SWN */
char    *ParserErrorText999 =  "\"  %1\"";    /* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\pt\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Erro de anlise %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Erro de extenso %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Erro de extenso %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Erro de anlise %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\tr\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"zmleme Hatas %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Uzatlm Hata %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\" Uzatlm Hata %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\" zmleme Hatas %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\command\sv\bldmsg.h ===
/*
Message file for COMMAND.COM BUILDMSG.EXE
*/

#define PARSE_STR	"        DB      \"Syntaxfel %%1\"\x0d\x0a"
#define EXTENDED_STR	"        DB      \"Utkat fel %%1\"\x0d\x0a"
char	*ExtendedErrorText999 =  "\"Utkat fel %1\"";	/* Mar 88, SWN */
char	*ParserErrorText999 =  "\"Syntaxfel %1\"";	/* Mar 88, SWN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debasm.asm ===
PAGE	80,132 ;
	TITLE	DEBASM.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; CODE FOR THE ASSEMBLE COMMAND IN THE DEBUGGER

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBASM
	ENDIF
.XLIST
.XCREF
	include	version.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE

	EXTRN	DBMN:BYTE,CSSAVE:WORD,REG8:BYTE,REG16:BYTE,SIZ8:BYTE
	EXTRN	SYNERR_PTR:BYTE,OPTAB:BYTE,MAXOP:ABS

CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

	EXTRN	HINUM:WORD,LOWNUM:WORD,ASSEM_CNT:BYTE
	EXTRN	ASSEM1:BYTE,ASSEM2:BYTE,ASSEM3:BYTE,ASSEM4:BYTE,ASSEM5:BYTE
	EXTRN	ASSEM6:BYTE,OPBUF:BYTE,OPCODE:WORD,REGMEM:BYTE,INDEX:WORD
	EXTRN	ASMADD:BYTE,ASMSP:WORD,MOVFLG:BYTE,SEGFLG:BYTE,TSTFLG:BYTE
	EXTRN	NUMFLG:BYTE,DIRFLG:BYTE,BYTEBUF:BYTE,F8087:BYTE,DIFLG:BYTE
	EXTRN	SIFLG:BYTE,BXFLG:BYTE,BPFLG:BYTE,NEGFLG:BYTE,MEMFLG:BYTE
	EXTRN	REGFLG:BYTE,AWORD:BYTE,MIDFLD:BYTE,MODE:BYTE
	EXTRN	ARG_BUF:BYTE,HEX_PTR:BYTE

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	PUBLIC	ASSEM
	PUBLIC	DB_OPER,DW_OPER,ASSEMLOOP,GROUP2,AA_OPER,DCINC_OPER
	PUBLIC	GROUP1,ESC_OPER,FGROUPP,FGROUPX,FDE_OPER,FGROUPZ
	PUBLIC	FD9_OPER,FGROUP,FDB_OPER,FGROUPB,FGROUP3,FGROUP3W
	PUBLIC	FGROUPDS,INT_OPER,IN_OPER,DISP8_OPER,JMP_OPER,NO_OPER
	PUBLIC	OUT_OPER,L_OPER,MOV_OPER,POP_OPER,PUSH_OPER,ROTOP
	PUBLIC	TST_OPER,EX_OPER,GET_DATA16,CALL_OPER, DOORG

	EXTRN	INBUF:NEAR,SCANB:NEAR,SCANP:NEAR,GETHX:NEAR,GET_ADDRESS:NEAR
	EXTRN	DEFAULT:NEAR,OUTDI:NEAR,BLANK:NEAR,TAB:NEAR
	EXTRN	STD_PRINTF:NEAR,PRINTF_CRLF:NEAR

;	Line by line assembler

MASKMOD EQU	11000000B
SHMOD	EQU	6
MASKREG EQU	00111000B
SHREG	EQU	3
MASKRM	EQU	00000111B
SHRM	EQU	0

ASSEM:
	MOV	BP,[CSSAVE]		; Default code segment
	MOV	DI,OFFSET DG:ASMADD	; Default address
	CALL	DEFAULT
	MOV	WORD PTR [ASMADD],DX	; Displacement of disassembly
	MOV	WORD PTR [ASMADD+2],AX	; Segment
	MOV	[ASMSP],SP		; Save sp in case of error

ASSEMLOOP:
	MOV	SP,[ASMSP]		; Restore sp in case of error
	LES	DI,DWORD PTR ASMADD	; GET PC
	CALL	OUTDI			; OUTPUT ADDRESS
	PUSH	CS
	POP	ES
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
; No spacing is needed.  The format string already has one.
;	CALL	BLANK			; SKIP A SPACE
	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:HEX_PTR
	CALL	STD_PRINTF
	POP	DI
	CALL	INBUF			; GET A BUFFER
	CALL	SCANB
	JNZ	OPLOOK
	RET				; if empty just return

;  At this point ds:si points to the opcode mnemonic...
OPLOOK:
	XOR	CX,CX			; OP-CODE COUNT = 0
	MOV	DI,OFFSET DG:DBMN
OPSCAN:
	XOR	BX,BX
OPLOOP:
	MOV	AL,[DI+BX]
	CMP	AL,[SI+BX]
	JZ	OPMATCH
	INC	CX			; INCREMENT OP-CODE COUNT
	CMP	CX,MAXOP		; CHECK FOR END OF LIST
	JB	OP1
	JMP	ASMERR
OP1:
	INC	DI			; SCAN FOR NEXT OP-CODE...
	CMP	BYTE PTR [DI-1],0
	JNZ	OP1
	JMP	OPSCAN

OPMATCH:
	INC	BX			; COMPARE NEXT CHAR
	CMP	BYTE PTR [DI+BX],0	; ARE WE DONE?
	JNZ	OPLOOP			; ..IF NOT KEEP COMPARING
	XCHG	BX,CX
	MOV	AX,BX
	SHL	AX,1
	ADD	AX,BX
	ADD	AX,OFFSET DG:OPTAB
	MOV	BX,AX

; CX = COUNT OF CHARS IN OPCODE
; BX = POINTER INTO OPCODE TABLE

	XOR	AX,AX
	MOV	BYTE PTR [AWORD],AL
	MOV	WORD PTR [MOVFLG],AX	; MOVFLG + TSTFLG
	MOV	BYTE PTR [SEGFLG],AL	; ZERO SEGMENT REGISTER FLAG
	MOV	AH,00001010B		; SET UP FOR AA_OPER
	MOV	AL,BYTE PTR [BX]
	MOV	WORD PTR [ASSEM1],AX
	MOV	BYTE PTR [ASSEM_CNT],1

	ADD	SI,CX			; SI POINTS TO OPERAND
	JMP	WORD PTR [BX+1]

; 8087 INSTRUCTIONS WITH NO OPERANDS

FDE_OPER:
	MOV	AH,0DEH
	JMP	SHORT FDX_OPER
FDB_OPER:
	MOV	AH,0DBH
	JMP	SHORT FDX_OPER
FD9_OPER:
	MOV	AH,0D9H
FDX_OPER:
	XCHG	AL,AH
	MOV	WORD PTR [ASSEM1],AX

;  AAD AND AAM INSTRUCIONS

AA_OPER:
	INC	BYTE PTR [ASSEM_CNT]

;  INSTRUCTIONS WITH NO OPERANDS

NO_OPER:
	CALL	STUFF_BYTES
	CALL	SCANP
	PUSH	CS
	POP	ES
	JNZ	OPLOOK
	JMP	ASSEMLOOP

;  PUSH INSTRUCTION

PUSH_OPER:
	MOV	AH,11111111B
	JMP	SHORT POP1

;  POP INSTRUCTION

POP_OPER:
	MOV	AH,10001111B
POP1:
	MOV	[ASSEM1],AH
	MOV	[MIDFLD],AL
	INC	BYTE PTR [MOVFLG]	; ALLOW SEGMENT REGISTERS
	MOV	BYTE PTR [AWORD],2	; MUST BE 16 BITS
	CALL	GETREGMEM
	CALL	BUILDIT
	MOV	AL,[DI+2]
	CMP	AL,11000000B
	JB	DATRET
	MOV	BYTE PTR [DI],1
	CMP	BYTE PTR [MOVFLG],2
	JNZ	POP2
	AND	AL,00011000B
	OR	AL,00000110B
	CMP	BYTE PTR [MIDFLD],0
	JNZ	POP3
	OR	AL,00000001B
	JMP	SHORT POP3

POP2:
	AND	AL,MASKRM
	OR	AL,01010000B
	CMP	BYTE PTR [MIDFLD],0
	JNZ	POP3
	OR	AL,01011000B
POP3:
	MOV	BYTE PTR [DI+1],AL
	JMP	ASSEM_EXIT

; RET AND RETF INSTRUCTIONS

GET_DATA16:
	CALL	SCANB
	MOV	CX,4
	CALL	GETHX
	JC	DATRET
	DEC	BYTE PTR [ASSEM1]	; CHANGE OP-CODE
	ADD	BYTE PTR [ASSEM_CNT],2	; UPDATE LENGTH
	MOV	WORD PTR [ASSEM2],DX	; SAVE OFFSET
DATRET:
	JMP	ASSEM_EXIT


;  INT INSTRUCTION

INT_OPER:
	CALL	SCANB
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	MOV	AL,DL
	CMP	AL,3
	JZ	DATRET
	INC	BYTE PTR [ASSEM1]
	JMP	DISPX

;  IN INSTRUCTION

IN_OPER:
	CALL	SCANB
	LODSW
	CMP	AX,'A'+4C00H            ; "AL"
	JZ	IN_1
	CMP	AX,'A'+5800H            ; "AX"
	JZ	IN_0
ERRV1:
	JMP	ASMERR
IN_0:
	INC	BYTE PTR [ASSEM1]
IN_1:
	CALL	SCANP
	CMP	WORD PTR [SI],'D'+5800H ; "DX"
	JZ	DATRET
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	AND	BYTE PTR [ASSEM1],11110111B
	MOV	AL,DL
	JMP	DISPX

;  OUT INSTRUCTION

OUT_OPER:
	CALL	SCANB
	CMP	WORD PTR [SI],'D'+5800H ; "DX"
	JNZ	OUT_0
	INC	SI
	INC	SI
	JMP	SHORT OUT_1
OUT_0:
	AND	BYTE PTR [ASSEM1],11110111B
	MOV	CX,2
	CALL	GETHX
	JC	ERRV1
	INC	BYTE PTR [ASSEM_CNT]
	MOV	BYTE PTR [ASSEM2],DL
OUT_1:
	CALL	SCANP
	LODSW
	CMP	AX,'A'+4C00H            ; "AL"
	JZ	DATRET
	CMP	AX,'A'+5800H            ; "AX"
	JNZ	ERRV1
	INC	BYTE PTR [ASSEM1]
	JMP	DATRET


;  JUMP INSTRUCTION

JMP_OPER:
	INC	BYTE PTR [TSTFLG]

;  CALL INSTRUCTION

CALL_OPER:
	MOV	BYTE PTR [ASSEM1],11111111B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILD3
	CMP	BYTE PTR [MEMFLG],0
	JNZ	CALLJ1
	CMP	BYTE PTR [REGMEM],-1
	JZ	CALLJ2

;  INDIRECT JUMPS OR CALLS

CALLJ1:
	CMP	BYTE PTR [AWORD],1
ERRZ4:
	JZ	ERRV1
	CMP	BYTE PTR [AWORD],4
	JNZ	ASMEX4
	OR	BYTE PTR [DI+2],1000B
	JMP	SHORT ASMEX4

;   DIRECT JUMPS OR CALLS

CALLJ2:
	MOV	AX,[LOWNUM]
	MOV	DX,[HINUM]
	MOV	BL,[AWORD]
	CMP	BYTE PTR [NUMFLG],0
	JZ	ERRZ4

;  BL = NUMBER OF BYTES IN JUMP
;  DX = OFFSET
;  AX = SEGMENT

CALLJ3:
	MOV	BYTE PTR [DI],5
	MOV	[DI+2],AX
	MOV	[DI+4],DX

	MOV	AL,10011010B		; SET UP INTER SEGMENT CALL
	CMP	BYTE PTR [TSTFLG],0
	JZ	CALLJ5
	MOV	AL,11101010B		; FIX UP FOR JUMP
CALLJ5:
	MOV	BYTE PTR [DI+1],AL
	CMP	BL,4			; FAR SPECIFIED?
	JZ	ASMEX4
	OR	BL,BL
	JNZ	CALLJ6
	CMP	DX,WORD PTR [ASMADD+2]	; DIFFERENT SEGMENT?
	JNZ	ASMEX4

CALLJ6:
	MOV	BYTE PTR [DI],3
	MOV	AL,11101000B		; SET UP FOR INTRASEGMENT
	OR	AL,[TSTFLG]
	MOV	BYTE PTR [DI+1],AL

	MOV	AX,[LOWNUM]
	SUB	AX,WORD PTR [ASMADD]
	SUB	AX,3
	MOV	[DI+2],AX
	CMP	BYTE PTR [TSTFLG],0
	JZ	ASMEX4
	CMP	BL,2
	JZ	ASMEX4

	INC	AX
	MOV	CX,AX
	CBW
	CMP	AX,CX
	JNZ	ASMEX3
	MOV	BYTE PTR [DI+1],11101011B
	MOV	[DI+2],AX
	DEC	BYTE PTR [DI]
ASMEX4:
	JMP	ASSEM_EXIT

;  CONDITIONAL JUMPS AND LOOP INSTRUCTIONS

DISP8_OPER:
	MOV	BP,WORD PTR [ASMADD+2]	; GET DEFAULT DISPLACEMENT
	CALL	GET_ADDRESS
	SUB	DX,WORD PTR [ASMADD]
	DEC	DX
	DEC	DX
	CALL	CHKSIZ
	CMP	CL,1
	JNZ	ERRV2
DISPX:
	INC	[ASSEM_CNT]
	MOV	BYTE PTR [ASSEM2],AL
ASMEX3:
	JMP	ASSEM_EXIT

;  LDS, LES, AND LEA INSTRUCTIONS

L_OPER:
	CALL	SCANB
	LODSW
	MOV	CX,8
	MOV	DI,OFFSET DG:REG16
	CALL	CHKREG
	JZ	ERRV2			; CX = 0 MEANS NO REGISTER
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	MOV	BYTE PTR [MIDFLD],AL
	CALL	SCANP
	CALL	GETREGMEM
	CMP	BYTE PTR [AWORD],0
	JNZ	ERRV2
	CALL	BUILD2
	JMP	SHORT ASEXV

;  DEC AND INC INSTRUCTIONS

DCINC_OPER:
	MOV	BYTE PTR [ASSEM1],11111110B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	TEST	BYTE PTR [DI+1],1
	JZ	ASEXV
	MOV	AL,[DI+2]
	CMP	AL,MASKMOD
	JB	ASEXV
	AND	AL,1111B
	OR	AL,01000000B
	MOV	[DI+1],AL
	DEC	BYTE PTR [DI]
ASEXV:
	JMP	ASSEM_EXIT

ERRV2:
	JMP	ASMERR

; ESC INSTRUCTION

ESC_OPER:
	INC	BYTE PTR [AWORD]
	CALL	SCANB
	MOV	CX,2
	CALL	GETHX
	CMP	DX,64
	JAE	ERRV2
	CALL	SCANP
	MOV	AX,DX
	MOV	CL,3
	SHR	DX,CL
	OR	[ASSEM1],DL
	AND	AL,111B
	SHL	AL,CL
	JMP	GROUPE

; 8087 ARITHMETIC INSTUCTIONS

;  OPERANDS THAT ALLOW THE REVERSE BIT

FGROUPDS:
	CALL	SETMID
	CALL	GETREGMEM2
	CALL	BUILD3
	CMP	BYTE PTR [MODE],11000000B
	JNZ	FGROUP1
	MOV	AL,[DIRFLG]
	OR	AL,AL
	JZ	FEXIT
	OR	[DI+1],AL		; IF D=1...
	XOR	BYTE PTR [DI+2],00001000B ; ...REVERSE THE SENSE OF R
	JMP	SHORT FEXIT

;  HERE WHEN INSTRUCTION COULD HAVE MEMORY OR REGISTER OPERAND

FGROUPX:
	CALL	SETMID			; THIS ENTRY POINT FOR 1 MEM OPER
	MOV	BYTE PTR [DIRFLG],0
	JMP	SHORT FGRP2
FGROUP:
	CALL	SETMID
FGRP2:
	CALL	GETREGMEM2
	CALL	BUILD3
	CMP	BYTE PTR [MODE],11000000B
	JNZ	FGROUP1
	MOV	AL,[DIRFLG]
	OR	[DI+1],AL
	JMP	SHORT FEXIT
FGROUP1:
	CALL	SETMF
FEXIT:
	JMP	ASSEM_EXIT

; THESE 8087 INSTRUCTIONS REQUIRE A MEMORY OPERAND
FGROUPB:
	MOV	AH,5			; MUST BE TBYTE
	JMP	SHORT FGROUP3E
FGROUP3W:
	MOV	AH,2			; MUST BE WORD
	JMP	SHORT FGROUP3E
FGROUP3:
	MOV	AH,-1			; SIZE CANNOT BE SPECIFIED
FGROUP3E:
	MOV	[AWORD],AH
	CALL	SETMID
	CALL	GETREGMEM
	CMP	BYTE PTR [MODE],11000000B
	JZ	FGRPERR
FGRP:
	CALL	BUILD3
	JMP	FEXIT

; THESE 8087 INSTRUCTIONS REQUIRE A REGISTER OPERAND
FGROUPP:				; 8087 POP OPERANDS
	MOV	BYTE PTR [AWORD],-1
	CALL	SETMID
	CALL	GETREGMEM2
	CMP	BYTE PTR [DIRFLG],0
	JNZ	FGRP
FGRPERR:
	JMP	ASMERR

FGROUPZ:				; ENTRY POINT WHERE ARG MUST BE MEM
	CALL	SETMID
	MOV	BYTE PTR [DIRFLG],0
	CALL	GETREGMEM
	CMP	BYTE PTR [MODE],11000000B
	JZ	FGRPERR
	CALL	BUILD3
	CALL	SETMF
	JMP	FEXIT

; NOT, NEG, MUL, IMUL, DIV, AND IDIV INSTRUCTIONS

GROUP1:
	MOV	[ASSEM1],11110110B
GROUPE:
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	JMP	FEXIT

;  SHIFT AND ROTATE INSTRUCTIONS

ROTOP:
	MOV	[ASSEM1],11010000B
	MOV	BYTE PTR [MIDFLD],AL
	CALL	GETREGMEM
	CALL	BUILDIT
	CALL	SCANP
	CMP	BYTE PTR [SI],'1'
	JZ	ASMEXV1
	CMP	WORD PTR [SI],"LC"      ; CL
	JZ	ROTOP1
ROTERR:
	JMP	ASMERR
ROTOP1:
	OR	BYTE PTR [ASSEM1],10B
ASMEXV1:
	JMP	ASSEM_EXIT

;  XCHG INSTRUCTION

EX_OPER:
	INC	BYTE PTR [TSTFLG]

;   TEST INSTRUCTION

TST_OPER:
	INC	BYTE PTR [TSTFLG]
	JMP	SHORT MOVOP

;    MOV INSTRUCTION

MOV_OPER:
	INC	BYTE PTR [MOVFLG]
MOVOP:
	XOR	AX,AX
	JMP	SHORT GROUPM

;   ADD, ADC, SUB, SBB, CMP, AND, OR, XOR instructions

GROUP2:
	MOV	BYTE PTR [ASSEM1],10000000B
GROUPM:
	MOV	BYTE PTR [MIDFLD],AL

	PUSH	AX
	CALL	GETREGMEM
	CALL	BUILD2
	CALL	SCANP			; POINT TO NEXT OPERAND
	MOV	AL,BYTE PTR [ASSEM_CNT]
	PUSH	AX
	CALL	GETREGMEM
	POP	AX
	MOV	BYTE PTR [DI],AL
	POP	AX
	MOV	BL,BYTE PTR [AWORD]
	OR	BL,BL
	JZ	ERRV5
	DEC	BL
	AND	BL,1
	OR	BYTE PTR [DI+1],BL

	CMP	BYTE PTR [MEMFLG],0
	JNZ	G21V
	CMP	BYTE PTR [NUMFLG],0	; TEST FOR IMMEDIATE DATA
	JZ	G21V
	CMP	BYTE PTR [SEGFLG],0
	JNZ	ERRV5
	CMP	BYTE PTR [TSTFLG],2	; XCHG?
	JNZ	IMMED1
ERRV5:
	JMP	ASMERR
G21V:
	JMP	GRP21

;  SECOND OPERAND WAS IMMEDIATE

IMMED1:
	MOV	AL,BYTE PTR [DI+2]
	CMP	BYTE PTR [MOVFLG],0
	JZ	NOTMOV1
	AND	AL,11000000B
	CMP	AL,11000000B
	JNZ	GRP23			; not to a register
					; MOVE IMMEDIATE TO REGISTER
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,1			; SET SIZE
	PUSHF
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	AL,BYTE PTR [DI+2]	; SET REGISTER
	AND	AL,00001111B
	OR	AL,10110000B
	MOV	BYTE PTR [DI+1],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+2],AX
	POPF
	JZ	EXVEC
	INC	BYTE PTR [DI]
EXVEC:
	JMP	GRPEX

NOTMOV1:
	AND	AL,11000111B
	CMP	AL,11000000B
	JZ	IMMACC			; IMMEDIATE TO ACC

	CMP	BYTE PTR [TSTFLG],0
	JNZ	GRP23
	CMP	BYTE PTR [MIDFLD],1*8	; OR?
	JZ	GRP23
	CMP	BYTE PTR [MIDFLD],4*8	; AND?
	JZ	GRP23
	CMP	BYTE PTR [MIDFLD],6*8	; XOR?
	JZ	GRP23
	TEST	BYTE PTR [DI+1],1	; TEST IF BYTE OPCODE
	JZ	GRP23

	MOV	AX,[LOWNUM]
	MOV	BX,AX
	CBW
	CMP	AX,BX
	JNZ	GRP23			; SMALL ENOUGH?

	MOV	BL,[DI]
	DEC	BYTE PTR [DI]
	OR	BYTE PTR [DI+1],10B
	JMP	SHORT GRP23X

IMMACC:
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,1
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOTTST
	OR	AL,10101000B
	JMP	SHORT TEST1
NOTTST:
	OR	AL,BYTE PTR [MIDFLD]
	OR	AL,100B
TEST1:
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]

GRP23:
	MOV	BL,BYTE PTR [DI]
GRP23X:
	XOR	BH,BH
	ADD	BX,DI
	INC	BX
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [BX],AX
	INC	BYTE PTR [DI]
	TEST	BYTE PTR [DI+1],1
	JZ	GRPEX1
	INC	BYTE PTR [DI]
GRPEX1:
	JMP	GRPEX

;	SECOND OPERAND WAS MEMORY OR REGISTER

GRP21:
	CMP	BYTE PTR [SEGFLG],0
	JZ	GRP28			; FIRST OPERAND WAS A SEGMENT REG
	MOV	AL,BYTE PTR [REGMEM]
	TEST	AL,10000B
	JZ	NOTSEG1
ERRV3:
	JMP	ASMERR
NOTSEG1:
	AND	AL,111B
	OR	BYTE PTR [DI+2],AL
	AND	BYTE PTR [DI+1],11111110B
	CMP	BYTE PTR [MEMFLG],0
	JNZ	G22V
	JMP	GRPEX

GRP28:
	AND	BYTE PTR [DI+2],11000111B
	MOV	AL,BYTE PTR [DI+1]	; GET FIRST OPCODE
	AND	AL,1B
	CMP	BYTE PTR [MOVFLG],0
	JZ	NOTMOV2
	OR	AL,10001000B
	JMP	SHORT MOV1
NOTMOV2:
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOTTST2
	OR	AL,10000100B
	CMP	BYTE PTR [TSTFLG],2
	JNZ	NOTTST2
	OR	AL,10B
NOTTST2:
	OR	AL,BYTE PTR [MIDFLD]	; MIDFLD IS ZERO FOR TST
MOV1:
	MOV	BYTE PTR [DI+1],AL
	CMP	BYTE PTR [MEMFLG],0
G22V:
	JZ	NotGRP22
	JMP	GRP22
NotGRP22:

;	SECOND OPERAND WAS A REGISTER

	MOV	AL,BYTE PTR [REGMEM]
	TEST	AL,10000B		; SEGMENT REGISTER?
	JZ	NOTSEG
	CMP	BYTE PTR [MOVFLG],0
	JZ	ERRV3
	MOV	BYTE PTR [DI+1],10001100B

NOTSEG:
	AND	AL,111B
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	BYTE PTR [DI+2],AL
; ARR 2.4
; In the case of the XCHG reg,reg and TEST reg,reg we have just built the
; instruction backwards.  This is because these two instructions do not have
; the D bit.  We need to switch R/S and REG
;
; Good comment Aaron, except that we do NOT switch if a memory operand was
; present for precisely the reason that the D bit is not present
;
	CMP	BYTE PTR [TSTFLG],0
	JZ	NOSWITCH		; Not XCHG or TEST
;
; See if there is a memory operand specified.  If the MOD field is 11, then
; we do perform the exchange.
;
	MOV	AH,[DI+2]
	AND	AH,MASKMOD
	CMP	AH,MASKMOD
	JNZ	NOSWITCH
	MOV	AH,BYTE PTR [DI+2]
	AND	AH,MASKRM
	SHL	AH,1			; Low three bits to middle three
	SHL	AH,1
	SHL	AH,1
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,MASKREG
	SHR	AL,1			; Middle three to low three
	SHR	AL,1
	SHR	AL,1
	OR	AL,AH			; Re combine
	AND	BYTE PTR [DI+2],MASKMOD ; Zap original
	OR	BYTE PTR [DI+2],AL	; New low 6 bits
NOSWITCH:


; SPECIAL FORM OF THE EXCHANGE COMMAND

	CMP	BYTE PTR [TSTFLG],2
	JNZ	GRPEX
	TEST	BYTE PTR [DI+1],1
	JZ	GRPEX
	PUSH	AX
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,MASKMOD
	CMP	AL,MASKMOD		; MUST BE REGISTER TO REGISTER
	POP	AX
	JB	GRPEX
	OR	AL,AL
	JZ	SPECX
	MOV	AL,[DI+2]
	AND	AL,MASKRM
	JNZ	GRPEX
	MOV	CL,3
	SHR	BYTE PTR [DI+2],CL
SPECX:
	MOV	AL,[DI+2]
	AND	AL,MASKRM
	OR	AL,10010000B
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]
	JMP	SHORT GRPEX

;  SECOND OPERAND WAS A MEMORY REFERENCE

GRP22:
	CMP	BYTE PTR [TSTFLG],0
	JNZ	TST2
	OR	BYTE PTR [DI+1],10B
TST2:
	MOV	AL,BYTE PTR [DI+2]
	CMP	AL,MASKMOD		; MUST BE A REGISTER
	JB	ASMERR
	CMP	BYTE PTR [SEGFLG],0
	JZ	GRP223
	AND	AL,00011000B
	JMP	SHORT GRP222
GRP223:
	AND	AL,MASKRM
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
GRP222:
	OR	AL,BYTE PTR [MODE]
	OR	AL,BYTE PTR [REGMEM]
	MOV	BYTE PTR [DI+2],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+3],AX
GRPSIZ:
	MOV	BYTE PTR [DI],2
	MOV	AL,BYTE PTR [DI+2]
	AND	AL,11000111B
	CMP	AL,00000110B
	JZ	GRP24
	AND	AL,MASKMOD
	CMP	AL,01000000B
	JZ	GRP25
	CMP	AL,10000000B
	JNZ	GRPEX
GRP24:
	INC	BYTE PTR [DI]
GRP25:
	INC	BYTE PTR [DI]

GRPEX:
	CMP	BYTE PTR [MOVFLG],0
	JZ	ASSEM_EXIT

;	TEST FOR SPECIAL FORM OF MOV AX,[MEM] OR MOV [MEM],AX

	MOV	AL,[DI+1]		; GET OP-CODE
	AND	AL,11111100B
	CMP	AL,10001000B
	JNZ	ASSEM_EXIT
	CMP	BYTE PTR [DI+2],00000110B ; MEM TO AX OR AX TO MEM
	JNZ	ASSEM_EXIT
	MOV	AL,BYTE PTR [DI+1]
	AND	AL,11B
	XOR	AL,10B
	OR	AL,10100000B
	MOV	BYTE PTR [DI+1],AL
	DEC	BYTE PTR [DI]
	MOV	AX,[DI+3]
	MOV	WORD PTR [DI+2],AX

ASSEM_EXIT:
	CALL	STUFF_BYTES
	JMP	ASSEMLOOP

; Assem error. SI points to character in the input buffer
; which caused error. By subtracting from start of buffer,
; we will know how far to tab over to appear directly below
; it on the terminal. Then print "^ Error".

ASMERR:
	SUB	SI,OFFSET DG:(BYTEBUF-10) ; How many char processed so far?
	MOV	CX,SI			; Parameter for TAB in CX
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	TAB			; Directly below bad char
	MOV	BYTE PTR [DI],0
	MOV	DX,OFFSET DG:SYNERR_PTR ; Error message
	CALL	PRINTF_CRLF
	JMP	ASSEMLOOP
;
;  assemble the different parts into an instruction
;
BUILDIT:
	MOV	AL,BYTE PTR [AWORD]
	OR	AL,AL
	JNZ	BUILD1
BLDERR:
	JMP	ASMERR

BUILD1:
	DEC	AL
	OR	BYTE PTR [DI+1],AL	; SET THE SIZE

BUILD2:
	CMP	BYTE PTR [NUMFLG],0	; TEST FOR IMMEDIATE DATA
	JZ	BUILD3
	CMP	BYTE PTR [MEMFLG],0
	JZ	BLDERR

BUILD3:
	MOV	AL,BYTE PTR [REGMEM]
	CMP	AL,-1
	JZ	BLD1
	TEST	AL,10000B		; TEST IF SEGMENT REGISTER
	JZ	BLD1
	CMP	BYTE PTR [MOVFLG],0
	JZ	BLDERR
	MOV	WORD PTR [DI+1],10001110B
	INC	BYTE PTR [MOVFLG]
	INC	BYTE PTR [SEGFLG]
	AND	AL,00000011B
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	OR	AL,MASKMOD
	MOV	BYTE PTR [DI+2],AL
	RET

BLD1:
	AND	AL,00000111B
BLD4:
	OR	AL,BYTE PTR [MODE]
	OR	AL,BYTE PTR [MIDFLD]
	MOV	BYTE PTR [DI+2],AL
	MOV	AX,WORD PTR [LOWNUM]
	MOV	WORD PTR [DI+3],AX
	RET

GETREGMEM:
	MOV	BYTE PTR [F8087],0
GETREGMEM2:
	CALL	SCANP
	XOR	AX,AX
	MOV	WORD PTR [LOWNUM],AX	; OFFSET
	MOV	WORD PTR [DIFLG],AX	; DIFLG+SIFLG
	MOV	WORD PTR [BXFLG],AX	; BXFLG+BPFLG
	MOV	WORD PTR [NEGFLG],AX	; NEGFLG+NUMFLG
	MOV	WORD PTR [MEMFLG],AX	; MEMFLG+REGFLG
	DEC	AL
	CMP	BYTE PTR [F8087],0
	JZ	PUTREG
	MOV	AL,1			; DEFAULT 8087 REG IS 1
PUTREG:
	MOV	BYTE PTR [REGMEM],AL

GETLOOP:
	MOV	BYTE PTR [NEGFLG],0
GETLOOP1:
	MOV	AX,WORD PTR [SI]
	CMP	AL,','
	JZ	GOMODE
	CMP	AL,13
	JZ	GOMODE
	CMP	AL,';'
	JZ	GOMODE
	CMP	AL,9
	JZ	GETTB
	CMP	AL,' '
	JNZ	GOGET
GETTB:
	INC	SI
	JMP	GETLOOP1
GOGET:
	JMP	GETINFO

;  DETERMINE THE MODE BITS

GOMODE:
	MOV	DI,OFFSET DG:ASSEM_CNT
	MOV	BYTE PTR [MODE],11000000B
	MOV	BYTE PTR [ASSEM_CNT],2
	CMP	BYTE PTR [MEMFLG],0
	JNZ	GOMODE1
	MOV	AL,[NUMFLG]
	OR	AL,[REGFLG]
	JNZ	MORET
	OR	AL,[F8087]
	JZ	ERRET
	MOV	AL,[DI+1]
	OR	AL,[DIRFLG]
	CMP	AL,0DCH 		; ARITHMETIC?
	JNZ	MORET
	MOV	BYTE PTR [DI+1],0DEH	; ADD POP TO NULL ARG 8087
MORET:
	RET
ERRET:
	JMP	ASMERR

GOMODE1:
	MOV	BYTE PTR [MODE],0
	CMP	BYTE PTR [NUMFLG],0
	JZ	GOREGMEM

	MOV	BYTE PTR [DI],4
	MOV	AX,WORD PTR [DIFLG]
	OR	AX,WORD PTR [BXFLG]
	JNZ	GOMODE2
	MOV	BYTE PTR [REGMEM],00000110B
	RET

GOMODE2:
	MOV	BYTE PTR [MODE],10000000B
	CALL	CHKSIZ1
	CMP	CL,2
	JZ	GOREGMEM
	DEC	BYTE PTR [DI]
	MOV	BYTE PTR [MODE],01000000B

;  DETERMINE THE REG-MEM BITS

GOREGMEM:
	MOV	BX,WORD PTR [BXFLG]
	MOV	CX,WORD PTR [DIFLG]
	XOR	DX,DX
GOREG0:
	MOV	AL,BL			; BX
	ADD	AL,CH			; SI
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BL
	ADD	AL,CL
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BH
	ADD	AL,CH
	CMP	AL,2
	JZ	GOGO
	INC	DL
	MOV	AL,BH
	ADD	AL,CL
	CMP	AL,2
	JZ	GOGO
	INC	DL
	OR	CH,CH
	JNZ	GOGO
	INC	DL
	OR	CL,CL
	JNZ	GOGO
	INC	DL			; BP+DISP
	OR	BH,BH
	JZ	GOREG1
	CMP	BYTE PTR [MODE],0
	JNZ	GOGO
	MOV	BYTE PTR [MODE],01000000B
	INC	BYTE PTR [DI]
	DEC	DL
GOREG1:
	INC	DL			; BX+DISP
GOGO:
	MOV	BYTE PTR [REGMEM],DL
	RET

GETINFO:
	CMP	AX,'EN'                 ; NEAR
	JNZ	GETREG3
GETREG0:
	MOV	DL,2
GETRG01:
	CALL	SETSIZ1
GETREG1:
	CALL	SCANS
	MOV	AX,WORD PTR [SI]
	CMP	AX,"TP"                 ; PTR
	JZ	GETREG1
	JMP	GETLOOP

GETREG3:
	MOV	CX,5
	MOV	DI,OFFSET DG:SIZ8
	CALL	CHKREG			; LOOK FOR BYTE, WORD, DWORD, ETC.
	JZ	GETREG41
	INC	AL
	MOV	DL,AL
	JMP	GETRG01

GETREG41:
	MOV	AX,[SI]
	CMP	BYTE PTR [F8087],0
	JZ	GETREG5
	CMP	AX,"TS"                 ; 8087 STACK OPERAND
	JNZ	GETREG5
	CMP	BYTE PTR [SI+2],','
	JNZ	GETREG5
	MOV	BYTE PTR [DIRFLG],0
	ADD	SI,3
	JMP	GETLOOP

GETREG5:
	CMP	AX,"HS"                 ; SHORT
	JZ	GETREG1

	CMP	AX,"AF"                 ; FAR
	JNZ	GETRG51
	CMP	BYTE PTR [SI+2],'R'
	JNZ	GETRG51
	ADD	SI,3
	MOV	DL,4
	JMP	GETRG01

GETRG51:
	CMP	AL,'['
	JNZ	GETREG7
GETREG6:
	INC	BYTE PTR [MEMFLG]
GETREGADD:
	INC	SI
	JMP	GETLOOP

GETREG7:
	CMP	AL,']'
	JZ	GETREG6
	CMP	AL,'.'
	JZ	GETREG6
	CMP	AL,'+'
	JZ	GETREGAdd
	CMP	AL,'-'
	JNZ	GETREG8
	INC	BYTE PTR [NEGFLG]
	INC	SI
	JMP	GETLOOP1

GETREG8:				; LOOK FOR A REGISTER
	CMP	BYTE PTR [F8087],0
	JZ	GETREGREG
	CMP	AX,"TS"
	JNZ	GETREGREG
	CMP	BYTE PTR [SI+2],'('
	JNZ	GETREGREG
	CMP	BYTE PTR [SI+4],')'
	JNZ	ASMPOP
	MOV	AL,[SI+3]
	SUB	AL,'0'
	JB	ASMPOP
	CMP	AL,7
	JA	ASMPOP
	MOV	[REGMEM],AL
	INC	BYTE PTR [REGFLG]
	ADD	SI,5
	CMP	WORD PTR [SI],"S,"
	JNZ	ZLOOP
	CMP	BYTE PTR [SI+2],'T'
	JNZ	ZLOOP
	ADD	SI,3
ZLOOP:
	JMP	GETLOOP

GETREGREG:
	MOV	CX,20
	MOV	DI,OFFSET DG:REG8
	CALL	CHKREG
	JZ	GETREG12		; CX = 0 MEANS NO REGISTER
	MOV	BYTE PTR [REGMEM],AL
	INC	BYTE PTR [REGFLG]	; TELL EVERYONE WE FOUND A REG
	CMP	BYTE PTR [MEMFLG],0
	JNZ	NOSIZE
	CALL	SETSIZ
INCSI2:
	ADD	SI,2
	JMP	GETLOOP

NOSIZE:
	CMP	AL,11			; BX REGISTER?
	JNZ	GETREG9
	CMP	WORD PTR [BXFLG],0
	JZ	GETOK
ASMPOP:
	JMP	ASMERR

GETOK:
	INC	BYTE PTR [BXFLG]
	JMP	INCSI2
GETREG9:
	CMP	AL,13			; BP REGISTER?
	JNZ	GETREG10
	CMP	WORD PTR [BXFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [BPFLG]
	JMP	INCSI2
GETREG10:
	CMP	AL,14			; SI REGISTER?
	JNZ	GETREG11
	CMP	WORD PTR [DIFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [SIFLG]
	JMP	INCSI2
GETREG11:
	CMP	AL,15			; DI REGISTER?
	JNZ	ASMPOP			; *** error
	CMP	WORD PTR [DIFLG],0
	JNZ	ASMPOP
	INC	BYTE PTR [DIFLG]
	JMP	INCSI2

GETREG12:				; BETTER BE A NUMBER!
	MOV	BP,WORD PTR [ASMADD+2]
	CMP	BYTE PTR [MEMFLG],0
	JZ	GTRG121
GTRG119:
	MOV	CX,4
GTRG120:
	CALL	GETHX
	JMP	SHORT GTRG122
GTRG121:
	MOV	CX,2
	CMP	BYTE PTR [AWORD],1
	JZ	GTRG120
	CMP	BYTE PTR [AWORD],CL
	JZ	GTRG119
	CALL	GET_ADDRESS
GTRG122:
	JC	ASMPOP
	MOV	[HINUM],AX
	CMP	BYTE PTR [NEGFLG],0
	JZ	GETREG13
	NEG	DX
GETREG13:
	ADD	WORD PTR [LOWNUM],DX
	INC	BYTE PTR [NUMFLG]
GETLOOPV:
	JMP	GETLOOP

CHKREG:
	PUSH	CX
	INC	CX
	REPNZ	SCASW
	POP	AX
	SUB	AX,CX
	OR	CX,CX
	RET

STUFF_BYTES:
	PUSH	SI
	LES	DI,DWORD PTR ASMADD
	MOV	SI,OFFSET DG:ASSEM_CNT
	XOR	AX,AX
	LODSB
	MOV	CX,AX
	JCXZ	STUFFRET
	REP	MOVSB
	MOV	WORD PTR [ASMADD],DI
STUFFRET:
	POP	SI
	RET

SETSIZ:
	MOV	DL,1
	TEST	AL,11000B		; 16 BIT OR SEGMENT REGISTER?
	JZ	SETSIZ1
	INC	DL
SETSIZ1:
	CMP	BYTE PTR [AWORD],0
	JZ	SETSIZ2
	CMP	BYTE PTR [AWORD],DL
	JZ	SETSIZ2
SETERR:
	POP	DX
	JMP	ASMPOP
SETSIZ2:
	MOV	BYTE PTR [AWORD],DL
	RET

;  DETERMINE IF NUMBER IN AX:DX IS 8 BITS, 16 BITS, OR 32 BITS

CHKSIZ:
	MOV	CL,4
	CMP	AX,BP
	JNZ	RETCHK
CHKSIZ1:
	MOV	CL,2
	MOV	AX,DX
	CBW
	CMP	AX,DX
	JNZ	RETCHK
	DEC	CL
RETCHK:
	RET

;  get first character after first space

SCANS:
	CMP	BYTE PTR [SI],13
	JZ	RETCHK
	CMP	BYTE PTR [SI],'['
	JZ	RETCHK
	LODSB
	CMP	AL,' '
	JZ	SCANBV
	CMP	AL,9
	JNZ	SCANS
SCANBV:
	JMP	SCANB

; Set up for 8087 op-codes

SETMID:
	MOV	BYTE PTR [ASSEM1],0D8H
	MOV	AH,AL
	AND	AL,111B 		; SET MIDDLE BITS OF SECOND BYTE
	SHL	AL,1
	SHL	AL,1
	SHL	AL,1
	MOV	[MIDFLD],AL
	MOV	AL,AH			; SET LOWER BITS OF FIRST BYTE
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	OR	[ASSEM1],AL
	MOV	BYTE PTR [F8087],1	; INDICATE 8087 OPERAND
	MOV	BYTE PTR [DIRFLG],100B
	RET

; Set MF bits for 8087 op-codes

SETMF:
	MOV	AL,[AWORD]
	TEST	BYTE PTR [DI+1],10B
	JNZ	SETMFI
	AND	BYTE PTR [DI+1],11111001B ; CLEAR MF BITS
	CMP	AL,3			; DWORD?
	JZ	SETMFRET
	CMP	AL,4			; QWORD?
	JZ	SETMFRET2
	TEST	BYTE PTR [DI+1],1
	JZ	SETMFERR
	CMP	AL,5			; TBYTE?
	JZ	SETMFRET3
	JMP	SHORT SETMFERR

SETMFI:
	CMP	AL,3			; DWORD?
	JZ	SETMFRET
	CMP	AL,2			; WORD?
	JZ	SETMFRET2
	TEST	BYTE PTR [DI+1],1
	JZ	SETMFERR
	CMP	AL,4			; QWORD?
	JNZ	SETMFERR
	OR	BYTE PTR [DI+1],111B
SETMFRET3:
	OR	BYTE PTR [DI+1],011B
	OR	BYTE PTR [DI+2],101000B
	JMP	SHORT SETMFRET
SETMFRET2:
	OR	BYTE PTR [DI+1],100B
SETMFRET:
	RET

SETMFERR:
	JMP	ASMPOP


DW_OPER:
	MOV	BP,1
	JMP	SHORT DBEN

DB_OPER:
	XOR	BP,BP
DBEN:
	MOV	DI,OFFSET DG:ASSEM_CNT
	DEC	BYTE PTR [DI]
	INC	DI
DB0:
	XOR	BL,BL
	CALL	SCANP
	JNZ	DB1
DBEX:
	JMP	ASSEM_EXIT
DB1:
	OR	BL,BL
	JNZ	DB3
	MOV	BH,BYTE PTR [SI]
	CMP	BH,"'"
	JZ	DB2
	CMP	BH,'"'
	JNZ	DB4
DB2:
	INC	SI
	INC	BL
DB3:
	LODSB
	CMP	AL,13
	JZ	DBEX
	CMP	AL,BH
	JZ	DB0
	STOSB
	INC	BYTE PTR [ASSEM_CNT]
	JMP	DB3
DB4:
	MOV	CX,2
	CMP	BP,0
	JZ	DB41
	MOV	CL,4
DB41:
	PUSH	BX
	CALL	GETHX
	POP	BX
	JNC	DB5
	JMP	ASMERR
DB5:
	MOV	AX,DX
	CMP	BP,0
	JZ	DB6
	STOSW
	INC	BYTE PTR [ASSEM_CNT]
	JMP	SHORT DB7
DB6:
	STOSB
DB7:
	INC	BYTE PTR [ASSEM_CNT]
	JMP	DB0

; ORG pseudo op

DOORG:
	MOV	BP,WORD PTR ASMADD+2
	CALL	GET_ADDRESS
	MOV	WORD PTR ASMADD,DX
	MOV	WORD PTR ASMADD+2,AX
	JMP	ASSEMLOOP

CODE	ENDS
	END	ASSEM

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debcom2.asm ===
PAGE	60,132 ;
	TITLE	DEBCOM2.ASM - PART2 DEBUGGER COMMANDS	PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DECOM2.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM1 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;	AC000	VERSION 4.00 -
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- IMPLEMENT > 32MB SUPPORT	DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;	Change Log:
;
;     Date    WHO   #		  Description
;   --------  ---  ---	----------------------------------------------------
;   04/01/90  DIC  C01	Problem fixed - When writing a file to a full disk,
;			file would be deleted if there wasn't enough space.
;			Fix checks to make sure there is enough space.
;			(Compaq STR #1889) (Microsoft Bug #774)
;
;   05/25/90  AKM  C08	Problem fixed - Added code to limit the file size
;                       for the write command.  Size check code changed
;                       because of divide overflow error.
;			(Microsoft Bug #1157)
;
;   07/31/90  AKM  C09	Problem fixed - The fix for C08 broke C01.  Took out
;                       C08 and changed to two divides to a multiply and
;                       a divide (divide by BytesPerClust).  Also, the
;                       volume freee space was not added to the file free
;                       space when overwriting a file.
;
;===========================================================================
; Routines to perform debugger commands except ASSEMble and UASSEMble

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBCOM2
	ENDIF
.XLIST
.XCREF
	include syscall.inc		; cas -- missing equates
	include version.inc		; cas -- missing equates
	include pdb.inc 		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST
CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	NOTFND_PTR:BYTE,NOROOM_PTR:BYTE,DRVLET:BYTE,ERRMES_PTR:BYTE
	EXTRN	NAMBAD_PTR:BYTE,NOSPACE_PTR:BYTE,TOOBIG_PTR:BYTE
	EXTRN	HEXERR_PTR:BYTE,HEXWRT_PTR:BYTE,ACCMES_PTR:BYTE
	EXTRN	EXEBAD_PTR:BYTE,EXEWRT_PTR:BYTE
	EXTRN	EXECEMES_PTR:BYTE,NONAMESPEC_PTR:BYTE

	EXTRN	FLAGTAB:WORD,EXEC_BLOCK:BYTE,COM_LINE:DWORD,COM_FCB1:DWORD
	EXTRN	COM_FCB2:DWORD,COM_SSSP:DWORD,COM_CSIP:DWORD,RETSAVE:WORD
	EXTRN	NEWEXEC:BYTE,HEADSAVE:WORD
	EXTRN	REGTAB:BYTE,TOTREG:BYTE,NOREGL:BYTE
	EXTRN	USER_PROC_PDB:WORD,STACK:BYTE,RSTACK:WORD,AXSAVE:WORD
	EXTRN	BXSAVE:WORD,DSSAVE:WORD,ESSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD
	EXTRN	SSSAVE:WORD,CXSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	EXTRN	SREG:BYTE,SEGTAB:WORD,REGDIF:ABS,RDFLG:BYTE
	EXTRN	REGTABEND:WORD
	EXTRN	NAMESPEC:BYTE

	EXTRN	FileSizeLB:WORD,FileSizeHB:WORD,TempHB:WORD,TempLB:WORD   ;C01
	EXTRN	DriveOfFile:WORD					  ;C01

CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	DEFDUMP:BYTE,TRANSADD:DWORD,INDEX:WORD,BUFFER:BYTE
	EXTRN	ASMADD:BYTE,DISADD:BYTE,NSEG:WORD
	EXTRN	SWITCHAR:BYTE,XNXCMD:BYTE,XNXOPT:BYTE
	EXTRN	AWORD:BYTE,EXTPTR:WORD,HANDLE:WORD,PARSERR:BYTE
	EXTRN	REG_NAME:WORD,REG_CONTENTS:WORD,REGISTER_PTR:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE,LOC_ADD:WORD,LOC_PTR:BYTE
	EXTRN	BIG_CONTENTS:WORD,BIG_PTR:BYTE,LITTLE_CONTENTS:WORD,LITTLE_PTR:BYTE
	EXTRN	SINGLE_REG_ARG:WORD,CHANGE_FLAG_PTR:BYTE,DF_ERROR:BYTE
	EXTRN	BR_ERROR:BYTE,BF_ERROR:BYTE,SINGLE_REG_PTR:WORD
	EXTRN	WRT_ARG1:WORD,WRT_ARG2:WORD,WRTMES_PTR:BYTE,BEGSEG:WORD
	EXTRN	FILESTRT:WORD,FILEEND:WORD
	EXTRN	ERR_TYPE:BYTE			;ac000;converted to buffer

	extrn	rel_read_write_tab:dword		;an000;primitive I/O
	extrn	rel_rw_add:dword			;an000;transfer address
	extrn	rel_low_sec:word			;an000;low sector word
	extrn	rel_high_sec:word			;an000;high sector word
	extrn	rel_sec_num:word			;an000;# of sectors

fnd_dbcs db    0
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	DEFIO,PREPNAME,DEBUG_FOUND
	PUBLIC	REG,LOAD
	PUBLIC	NAMED,DWRITE
	PUBLIC	DISPREG,ERR,DELIM1,DELIM2,delim0
	public	getchrup,open1,open2,open3,open4,oc_file,opnret 		;an001;bgb
	public	delete_a_file, parse_a_file, exec_a_file, open_a_file, create_a_file ;an001;bgb
	public	gcur,ifhex							;an001;bgb
	public	comtail 							;an001;bgb
	extrn	test_lead:near							;an001;bgb
	EXTRN	OUTSI:NEAR,OUTDI:NEAR,INBUF:NEAR,SCANB:NEAR,SCANP:NEAR
	EXTRN	COMMAND:NEAR,DISASLN:NEAR,SET_TERMINATE_VECTOR:NEAR
	EXTRN	RESTART:NEAR,TERMINATE:NEAR,DRVERR:NEAR
	EXTRN	GETHEX:NEAR,GETEOL:NEAR,SKIP_FILE:NEAR
	EXTRN	HEXCHK:NEAR,GETHEX1:NEAR,PRINT:NEAR
	EXTRN	CRLF:NEAR,BLANK:NEAR
	EXTRN	HEX:NEAR,DIGIT:NEAR
	EXTRN	FIND_DEBUG:NEAR
	EXTRN	ADDRESS:NEAR,PERROR:NEAR
	EXTRN	STD_PRINTF:NEAR,PRINTF_CRLF:NEAR
DEBCOM2:
DISPLAY_LINE:
	mov	ax,word ptr [si]		;an000;move reg name to ax
	MOV	[REG_NAME],ax			;ac000;save it in reg_name
	ADD	SI,3
	MOV	AX,[BX]
	ADD	BX,2
	MOV	[REG_CONTENTS],AX
	MOV	DX,OFFSET DG:REGISTER_PTR
	CALL	STD_PRINTF

	LOOP	DISPLAY_LINE

	RETURN

DISPLAY_FLAGS:
	MOV	DI,OFFSET DG:ARG_BUF
	MOV	AL,CHAR_BLANK
	STOSB
DISPLAY_FLAGS_2:
	MOV	SI,OFFSET DG:FLAGTAB
	MOV	CX,16
	MOV	DX,[FLSAVE]
DFLAGS:
	LODS	CS:WORD PTR [SI]
	SHL	DX,1
	JC	FLAGSET

	MOV	AX,CS:[SI+30]
FLAGSET:
	OR	AX,AX
	JZ	NEXT_FLAG

	STOSW
	MOV	AL,CHAR_BLANK
	STOSB
NEXT_FLAG:
	LOOP	DFLAGS
	XOR	AL,AL
	STOSB
	RETURN

DISPREG:
	MOV	SI,OFFSET DG:REGTAB
	MOV	DI,OFFSET DG:ARG_BUF
	MOV	BX,OFFSET DG:AXSAVE
	MOV	BYTE PTR TOTREG,CR
	MOV	CH,0
	MOV	CL,NOREGL
SET_DISPLAY:
REPEAT_DISPLAY:
	SUB	TOTREG,CL
	CALL	DISPLAY_LINE

	CALL	CRLF

	XOR	CH,CH
	MOV	CL,NOREGL
	CMP	CL,TOTREG
	JB	REPEAT_DISPLAY

	MOV	CL,TOTREG
	CALL	DISPLAY_LINE

	CALL	DISPLAY_FLAGS

	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	PRINTF_CRLF

	MOV	AX,[IPSAVE]
	MOV	WORD PTR [DISADD],AX
	PUSH	AX
	MOV	AX,[CSSAVE]
	MOV	WORD PTR [DISADD+WORD],AX
	PUSH	AX
	MOV	[NSEG],-1
	CALL	DISASLN

	POP	WORD PTR DISADD+WORD
	POP	WORD PTR DISADD
	MOV	AX,[NSEG]
	CMP	AL,-1
	JNZ	ASSEM_LIN_CONT

	JMP	CRLF

ASSEM_LIN_CONT:
	CMP	AH,-1
	JZ	NOOVER

	XCHG	AL,AH
NOOVER:
	CBW
	MOV	BX,AX
	SHL	BX,1
	MOV	AX,WORD PTR [BX+SREG]
	MOV	DI,OFFSET DG:ARG_BUF
	STOSB
	XCHG	AL,AH
	STOSB
	XOR	AL,AL
	STOSB
	MOV	DX,[INDEX]
	MOV	LOC_ADD,DX
	MOV	DX,OFFSET DG:LOC_PTR
	CALL	STD_PRINTF

	MOV	BX,[BX+SEGTAB]
	PUSH	DS
	MOV	DS,[BX]
	MOV	BX,CS:[INDEX]

;	M000 -- begin changes.
;
;	  When we're running a '386 CPU, fetching from word [ffff] causes
;	  a CPU fault, which causes a fatal fault on Win 3 enhanced or EMM386,
;	  and on some machines (like COMPAQs) even in real mode.  Therefore,
;	  we'll replace the word fetch with a byte fetch.  Notice that the
;	  new code trashes AL.  The subroutines in the vicinity preserve
;	  it, it was left zeroed when most recently used, and does not have
;	  a guaranteed value on return from this subroutine.
;
;	  Notice that the ACTUAL value we display on word [ffff]
;	  references will be the same as an 8088 would use for that
;	  operation.  If the user goes ahead and executes said
;	  instruction on a 386, it will fault!
;
;	MOV	BX,[BX]			; old code used word fetch

	mov	al,[bx]			; get low byte
	mov	bh,1[bx]		; get high byte
	mov	bl,al			; get both into bx

;	M000 -- end changes.

	POP	DS
	MOV	BIG_CONTENTS,BX
	MOV	DX,OFFSET DG:BIG_PTR
	TEST	BYTE PTR [AWORD],-1
	JNZ	SHOW_CHARS

	XOR	BH,BH
	MOV	LITTLE_CONTENTS,BX
	MOV	DX,OFFSET DG:LITTLE_PTR
SHOW_CHARS:
	CALL	PRINTF_CRLF

	RETURN

DISPREGJ:
	JMP	DISPREG

; Perform register dump if no parameters or set register if a
; register designation is a parameter.
REG:
	CALL	SCANP

	JZ	DISPREGJ

	MOV	DL,[SI]
	INC	SI
	MOV	DH,[SI]
	CMP	DH,CR
	JZ	FLAG

	INC	SI
	CALL	GETEOL

	CMP	DH,CHAR_BLANK
	JZ	FLAG

	MOV	DI,OFFSET DG:REGTAB
	XCHG	AX,DX
	PUSH	CS
	POP	ES
	XOR	CX,CX
CHECK_NEXT_REG:
	CMP	AX,WORD PTR[ DI]
	JZ	REG_FOUND

	ADD	DI,3
	INC	CX
	CMP	DI,OFFSET DG:REGTABEND
	JB	CHECK_NEXT_REG

	JMP	short BADREG

REG_FOUND:
	CMP	DI,OFFSET DG:REGTABEND
	JNZ	NOTPC

	DEC	DI
	DEC	DI
	DEC	DI
	MOV	AX,CS:[DI-WORD]
NOTPC:
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
	STOSB
	XCHG	AL,AH
	STOSB
	XOR	AL,AL
	STOSB
	POP	DI
	PUSH	DS
	POP	ES
	LEA	BX,[DI+REGDIF]
	SUB	BX,CX
	MOV	DX,[BX]
	MOV	SINGLE_REG_ARG,DX
	MOV	DX,OFFSET DG:SINGLE_REG_PTR
	CALL	STD_PRINTF

	CALL	INBUF

	CALL	SCANB

	RETZ

	push	bx				;an000;save bx - we stomp it
	MOV	CX,4
	CALL	GETHEX1
	pop	bx				;an000;restore it

	CALL	GETEOL

	MOV	[BX],DX
	RETURN
BADREG:
	MOV	DX,OFFSET DG:BR_ERROR	; BR ERROR
	JMP	short ERR

FLAG:
	CMP	DL,UPPER_F
	JNZ	BADREG

	MOV	DI,OFFSET DG:ARG_BUF
	CALL	DISPLAY_FLAGS_2

	MOV	DX,OFFSET DG:CHANGE_FLAG_PTR
	CALL	STD_PRINTF

	CALL	INBUF

	CALL	SCANB

	XOR	BX,BX
	MOV	DX,[FLSAVE]
GETFLG:
	LODSW
	CMP	AL,CR
	JZ	SAVCHG

	CMP	AH,CR
	JZ	FLGERR

	MOV	DI,OFFSET DG:FLAGTAB
	MOV	CX,32
	PUSH	CS
	POP	ES
	REPNE	SCASW
	JNZ	FLGERR

	MOV	CH,CL
	AND	CL,0FH
	MOV	AX,1
	ROL	AX,CL
	TEST	AX,BX
	JNZ	REPFLG

	OR	BX,AX
	OR	DX,AX
	TEST	CH,16
	JNZ	NEXFLG

	XOR	DX,AX
NEXFLG:
	CALL	SCANP

	JMP	SHORT GETFLG

REPFLG:
	MOV	DX,OFFSET DG:DF_ERROR	; DF ERROR
FERR:
	CALL	SAVCHG
ERR:
	push	si				;an000;save affected registers
	push	di				;an000;
	push	cx				;an000;
	mov	cx,03h				;an000;move only three bytes
	mov	di,offset dg:err_type		;an000;point to buffer
	mov	si,dx				;an000;dx holds the string
	rep	movsb				;an000;fill up the buffer
	pop	cx				;an000;restore registers
	pop	di				;an000;
	pop	si				;an000;
	MOV	DX,OFFSET DG:ERRMES_PTR
	JMP	PRINT

SAVCHG:
	MOV	[FLSAVE],DX
	RETURN

FLGERR:
	MOV	DX,OFFSET DG:BF_ERROR	; BF ERROR
	JMP	SHORT FERR

PREPNAME:
	MOV	ES,DSSAVE
	PUSH	SI
	MOV	DI,81H
COMTAIL:
	LODSB
	STOSB
	CMP	AL,CR
	JNZ	COMTAIL

	SUB	DI,82H
	XCHG	AX,DI
	MOV	ES:(BYTE PTR [80H]),AL
	POP	SI
	MOV	DI,FCB			;05cH
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION ;AL=01H
	INT	21H

	MOV	BYTE PTR [AXSAVE],AL	; Indicate analysis of first parm
	CALL	SKIP_FILE

	MOV	DI,6CH
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION ;AL=01H
	INT	21H

	MOV	BYTE PTR [AXSAVE+1],AL	; Indicate analysis of second parm
	RETURN

;  OPENS A XENIX PATHNAME SPECIFIED IN THE UNFORMATTED PARAMETERS
;  VARIABLE [XNXCMD] SPECIFIES WHICH COMMAND TO OPEN IT WITH

;  VARIABLE [HANDLE] CONTAINS THE HANDLE
;  VARIABLE [EXTPTR] POINTS TO THE FILES EXTENSION
DELETE_A_FILE:
	MOV	BYTE PTR [XNXCMD],UNLINK
	JMP	SHORT OC_FILE

PARSE_A_FILE:
	MOV	BYTE PTR [XNXCMD],0
	JMP	SHORT OC_FILE

EXEC_A_FILE:
	MOV	BYTE PTR CS:[XNXCMD],EXEC
	MOV	BYTE PTR CS:[XNXOPT],1
	JMP	SHORT OC_FILE

OPEN_A_FILE:
	MOV	BYTE PTR [XNXCMD],OPEN
	MOV	BYTE PTR [XNXOPT],2	; Try read write
	CALL	OC_FILE

	RETNC
	MOV	BYTE PTR [XNXCMD],OPEN
	MOV	BYTE PTR [XNXOPT],0	; Try read only
	JMP	SHORT OC_FILE

CREATE_A_FILE:
	MOV	BYTE PTR [XNXCMD],CREAT
OC_FILE:
	PUSH	DS
	PUSH	ES
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	XOR	AX,AX
	MOV	CS:[EXTPTR],AX		; INITIALIZE POINTER TO EXTENSIONS
	MOV	AH,CHAR_OPER
	INT	21H

	MOV	CS:[SWITCHAR],DL	; GET THE CURRENT SWITCH CHARACTER
	MOV	SI,81H

open1:	CALL	GETCHRUP		;convert 1 byte to uppercase
	CALL	DELIM2			; END OF LINE?
	JZ	OPEN4

	CALL	DELIM1			; SKIP LEADING DELIMITERS
	JZ	OPEN1

	MOV	DX,SI			; SAVE POINTER TO BEGINNING
	cmp	fnd_dbcs,1
;	$if	z
	JNZ $$IF1
	    dec   dx			;dec it twice if dbcs
;	$endif
$$IF1:
	DEC	DX
open2:	CMP	AL,CHAR_PERIOD		; LAST CHAR A "."?
	JNZ	OPEN3

	MOV	CS:[EXTPTR],SI		; SAVE POINTER TO THE EXTENSION
OPEN3:
	CALL	GETCHRUP

	CALL	DELIM1			; LOOK FOR END OF PATHNAME

	JZ	OPEN4

	CALL	DELIM2

	JNZ	OPEN2

OPEN4:	DEC	SI			; POINT BACK TO LAST CHAR
	PUSH	[SI]			; SAVE TERMINATION CHAR
	MOV	BYTE PTR [SI],0 	; NULL TERMINATE THE STRING
	MOV	AL,CS:[XNXOPT]
	MOV	AH,CS:[XNXCMD]		; OPEN OR CREATE FILE
	OR	AH,AH
	JZ	OPNRET

	MOV	CS:[FILESTRT],DX	; Set values for later call on this file
	MOV	CS:[FILEEND],SI
	PUSH	CS
	POP	ES			; Set ES seg for EXEC_BLOCK
	MOV	BX,OFFSET DG:EXEC_BLOCK
	XOR	CX,CX
	INT	21H

	MOV	CS:[HANDLE],AX		; SAVE ERROR CODE OR HANDLE
OPNRET:
	POP	[SI]
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	POP	AX			; blow away error code...
	POP	ES
	POP	DS
	RETURN

GETCHRUP:									;an001;bgb
	lodsb				;get the character from [si]		;an001;bgb
	call	test_lead		;is it a dbcs lead byte?		;an001;bgb
;	$IF	C			;yes					;an001;bgb
	JNC $$IF3
	    inc     si			;bump ptr to past 2nd dbcs byte 	;an001;bgb
	    mov     fnd_dbcs,1		;found a dbcs char
	    jmp     short gcur		;dont capitalize it			;an001;bgb
;	$ENDIF									;an001;bgb
$$IF3:
					;					;an001;bgb
	mov	fnd_dbcs,0		;did not find a dbcs char
	cmp	al,lower_a		;is it >= "a" ? 			;an001;bgb
	jb	gcur			;no - exit				;an001;bgb
										;an001;bgb
	cmp	al,lower_z		;is it =< "z" ? 			;an001;bgb
	ja	gcur			;no - exit				;an001;bgb
										;an001;bgb
;if we get here, the char is lowercase, so change it				;an001;bgb
	sub	al,32			;convert to uppercase			;an001;bgb
	mov	[si-1],al		;move it back (si points 1 past)	;an001;bgb
gcur:	return									;an001;bgb

DELIM0:
	CMP	AL,CHAR_LEFT_BRACKET
	RETZ
DELIM1:
	CMP	AL,CHAR_BLANK		; SKIP THESE GUYS
	RETZ

	CMP	AL,CHAR_SEMICOLON
	RETZ

	CMP	AL,CHAR_EQUAL
	RETZ

	CMP	AL,CHAR_TAB
	RETZ

	CMP	AL,CHAR_COMMA
	RETURN

DELIM2:
	CMP	AL,CS:[SWITCHAR]	; STOP ON THESE GUYS
	RETZ

	CMP	AL,CR
	RETURN

NAMED:
	OR	[NAMESPEC],1		; Flag a name command executed
	CALL	PREPNAME

	MOV	AL,BYTE PTR AXSAVE
	MOV	PARSERR,AL
	PUSH	ES
	POP	DS
	PUSH	CS
	POP	ES
	MOV	SI,FCB			; DS:SI points to user FCB
	MOV	DI,SI			; ES:DI points to DEBUG FCB
	MOV	CX,82
	REP	MOVSW
	RETURN

BADNAM:
	MOV	DX,OFFSET DG:NAMBAD_PTR
	JMP	RESTART

IFHEX:
	CMP	BYTE PTR [PARSERR],-1	; Invalid drive specification?
	JZ	BADNAM

	CALL	PARSE_A_FILE

	MOV	BX,[EXTPTR]
	CMP	WORD PTR DS:[BX],"EH"	; "HE"
	RETNZ

	CMP	BYTE PTR DS:[BX+WORD],UPPER_X
	RETURN

IFEXE:
	PUSH	BX
	MOV	BX,[EXTPTR]
	CMP	WORD PTR DS:[BX],"XE"	; "EX"
	JNZ	RETIF

	CMP	BYTE PTR DS:[BX+WORD],UPPER_E
RETIF:
	POP	BX
	RETURN

LOAD:
	MOV	BYTE PTR [RDFLG],READ
	JMP	SHORT DSKIO

DWRITE:
	MOV	BYTE PTR [RDFLG],WRITE
DSKIO:
	MOV	BP,[CSSAVE]
	CALL	SCANB

	jz	DEFIO

	CALL	ADDRESS

	CALL	SCANB

	jz	FILEIO

;=========================================================================
; PRMIO:	This routine builds the necessary table for the new
;		generic IOCtl primitive read/write logical sector function.
;
;	Inputs : Binary addresses and values converted by GETHEX
;
;	Outputs: REL_READ_WRITE_TAB -	Table needed by IOCtl function to
;					perform 32 bit sector addressing.
;
;	Date	   : 6/17/87
;=========================================================================

	mov	word ptr dg:[rel_rw_add],dx	;ac000;save transfer address
						;      in table
	mov	word ptr dg:[rel_rw_add+2],ax	;ac000;save segment of transfer
						;      address
	MOV	CX,2
	CALL	GETHEX			; Drive number must be 2 digits or less

	PUSH	DX			;save drive number
	MOV	CX,8			;ac000;allow 32 bit addressibilty
	CALL	GETHEX			; Logical record number
	mov	word ptr dg:[rel_low_sec],dx	;ac000;save low word of logical
						;      sector address
	mov	word ptr dg:[rel_high_sec],bx	;ac000;save high word of
						;      logical sector address

	MOV	CX,3
	CALL	GETHEX			; Number of records
	mov	word ptr dg:[rel_sec_num],dx	;ac000;save number of sectors
						;      to read/write

	CALL	GETEOL

	POP	BX			;ac000;drive number
	CBW				; Turn off verify after write
	MOV	BYTE PTR DRVLET,bl	;ac000;save drive in case of error
	PUSH	BX
	MOV	DL,bL			;ac000;move drive to dl
; Clean off the buffer cache for physical I/O
	push	ds
	MOV	AH,DISK_RESET
	INT	21H

	INC	DL
	MOV	AH,GET_DPB
	INT	21H
	pop	ds

	or	al,al			;ac000;see if an error occurred
	pop	ax			;ac000;restore drive

	JNZ	DRVERRJ

	CMP	CS:BYTE PTR [RDFLG],WRITE
;	$if	z			;an000;we will write to sector(s)
	JNZ $$IF5
		call ABSWRT		;an000;logical sector write
;	$else				;an000;
	JMP SHORT $$EN5
$$IF5:
		call ABSREAD		;an000;we will read sector(s)
;	$endif				;an000;
$$EN5:


ENDABS:
	JNC	RET0

DRVERRJ:
	JMP	DRVERR

RET0:
; Clean cache again...
	MOV	AH,DISK_RESET
	INT	21H

	RETURN


;called from debug.asm
DEFIO:
	MOV	AX,[CSSAVE]		; Default segment
	MOV	DX,100H 		; Default file I/O offset
	CALL	IFHEX
	JNZ	EXECHK
	XOR	DX,DX			; If HEX file, default OFFSET is zero
HEX2BINJ:
	JMP	HEX2BIN

FILEIO:
; AX and DX have segment and offset of transfer, respectively
	CALL	IFHEX
	JZ	HEX2BINJ

EXECHK:
	CALL	IFEXE
	JNZ	BINFIL
	CMP	BYTE PTR [RDFLG],READ
	JZ	EXELJ
	MOV	DX,OFFSET DG:EXEWRT_PTR
	JMP	RESTART 		; Can't write .EXE files

BINFIL:
	CMP	BYTE PTR [RDFLG],WRITE
	JZ	BINLOAD
	CMP	WORD PTR DS:[BX],4F00H + UPPER_C ;"CO"
	JNZ	BINLOAD
	CMP	BYTE PTR DS:[BX+WORD],UPPER_M
	JNZ	BINLOAD

EXELJ:
	DEC	SI
	CMP	DX,100H
	JNZ	PRER

	CMP	AX,[CSSAVE]
	JZ	OAF

PRER:
	JMP	PERROR

OAF:
	CALL	OPEN_A_FILE

	JNC	GDOPEN

	MOV	AX,ERROR_FILE_NOT_FOUND
	JMP	EXECERR

GDOPEN:
	XOR	DX,DX
	XOR	CX,CX
	MOV	BX,[HANDLE]
	MOV	AL,2
	MOV	AH,LSEEK
	INT	21H

	CALL	IFEXE			; SUBTRACT 512 BYTES FOR EXE

	JNZ	BIN2			; FILE LENGTH BECAUSE OF

	SUB	AX,512			; THE HEADER
	SBB	DX,0			; reflect borrow, if any

BIN2:
	MOV	[BXSAVE],DX		; SET UP FILE SIZE IN DX:AX
	MOV	[CXSAVE],AX
	MOV	AH,CLOSE
	INT	21H

	JMP	EXELOAD

NO_MEM_ERR:
	MOV	DX,OFFSET DG:TOOBIG_PTR
	CALL	PRINTF_CRLF

	JMP	COMMAND

WRTFILEJ:
	JMP	WRTFILE
NOFILEJ:
	MOV	FileSizeLB,0		;save low value of file size   ;C01
	MOV	FileSizeHB,0		;save high value of file size  ;C01
	JMP	NOFILE

BINLOAD:
	PUSH	AX
	PUSH	DX
	CMP	BYTE PTR [RDFLG],WRITE
	JZ	WRTFILEJ

	CALL	OPEN_A_FILE

	JC	NOFILEJ

	MOV	BX,[HANDLE]
	MOV	AX,(LSEEK SHL 8) OR LSEEK_EOF_OPTION
	XOR	DX,DX			;CX:DX=DISTANCE (OFFSET) TO MOVE IN BYTES
	MOV	CX,DX
	INT	21H			; GET SIZE OF FILE

	MOV	FileSizeLB,ax		; save low value of file size	;C01
	MOV	FileSizeHB,dx		; save high value of file size	;C01
	MOV	TempLB,ax		; save low value of file size	;C01
	MOV	TempHB,dx		; save high value of file size	;C01

	MOV	SI,DX
	MOV	DI,AX			; SIZE TO SI:DI
	MOV	AX,(LSEEK SHL 8) OR LSEEK_FROM_START
	XOR	DX,DX
	MOV	CX,DX
	INT	21H			; RESET POINTER BACK TO BEGINNING

	POP	AX
	POP	BX
	PUSH	BX
	PUSH	AX			; TRANS ADDR TO BX:AX
	ADD	AX,15
	RCR	AX,1
	MOV	CL,3
	MOV	CL,4
	SHR	AX,CL
	ADD	BX,AX			; Start of transfer rounded up to seg
	MOV	DX,SI
	MOV	AX,DI			; DX:AX is size
	cmp	dx,10h
	jnc	no_mem_err
	MOV	CX,16
	DIV	CX
	OR	DX,DX
	JZ	NOREM

	INC	AX
NOREM:					; AX is number of paras in transfer
	ADD	AX,BX			; AX is first seg that need not exist
	jc	no_mem_err
	CMP	AX,CS:[PDB_BLOCK_LEN]
	JA	NO_MEM_ERR

	MOV	CXSAVE,DI
	MOV	BXSAVE,SI
	POP	DX
	POP	AX
; AX:DX is disk transfer address (segment:offset)
; SI:DI is length (32-bit number)
RDWR:
RDWRLOOP:
	MOV	BX,DX			; Make a copy of the offset
	AND	DX,000FH		; Establish the offset in 0H-FH range
	MOV	CL,4
	SHR	BX,CL			; Shift offset and
	ADD	AX,BX			; Add to segment register to get new Seg:offset
	PUSH	AX
	PUSH	DX			; Save AX,DX register pair
	MOV	WORD PTR [TRANSADD],DX
	MOV	WORD PTR [TRANSADD+WORD],AX
	MOV	CX,0FFF0H		; Keep request in segment
	OR	SI,SI			; Need > 64K?
	JNZ	BIGRDWR

	MOV	CX,DI			; Limit to amount requested
BIGRDWR:
	PUSH	DS
	PUSH	BX
	MOV	BX,[HANDLE]
	MOV	AH,[RDFLG]
	LDS	DX,[TRANSADD]
	INT	21H			; Perform read or write

	POP	BX
	POP	DS
	JC	BADWR

	CMP	BYTE PTR [RDFLG],WRITE
	JNZ	GOODR

	CMP	CX,AX
	JZ	GOODR

BADWR:
	MOV	CX,AX
	STC
	POP	DX			; READ OR WRITE BOMBED OUT
	POP	AX
	RETURN

GOODR:
	MOV	CX,AX
	SUB	DI,CX			; Request minus amount transferred
	SBB	SI,0			; Ripple carry
	OR	CX,CX			; End-of-file?

	mov	ax,TempHB		; new file size value high byte  ;C01
	mov	FileSizeHB,ax		; if write was successful	 ;C01
	mov	ax,TempLB		; new file size value low byte	 ;C01
	mov	FileSizeLB,ax		; if write was successful	 ;C01

	POP	DX			; Restore DMA address
	POP	AX
	JZ	DOCLOSE

	ADD	DX,CX			; Bump DMA address by transfer length
	MOV	BX,SI
	OR	BX,DI			; Finished with request
	JNZ	RDWRLOOP

DOCLOSE:
	SAVEREG <AX,BX>
	MOV	BX,HANDLE
	MOV	AH,CLOSE
	INT	21H

	RESTOREREG <BX,AX>
	RETURN

NOFILE:
	MOV	DX,OFFSET DG:NOTFND_PTR
	JMP	RESTART

NO_NAME_GIVEN:
	MOV	DX,OFFSET DG:NONAMESPEC_PTR
RESTARTJMP:
	JMP	RESTART

WRTFILE:
	CMP	[NAMESPEC],0
	JZ	NO_NAME_GIVEN		; Hey User, you forgot to specify a name

	CALL	ChkFileSz		;C01

	CALL	CREATE_A_FILE		; Create file we want to write to

	JC	CHECKREADONLY		; ARR 2.4

	MOV	SI,BXSAVE		; Get high order number of bytes to transfer
;C08    CMP	SI,000FH
;C08    JLE	WRTSIZE 		; Is bx less than or equal to FH
;C08
;C08    XOR	SI,SI			; Ignore BX if greater than FH - set to zero
	MOV	DI,CXSAVE                                                 ;C08
	CMP	SI,7FFFH                                                  ;C08
	JBE	WRTSIZE 		; Is bx less than or equal to 7FFF;C08
                                        ; Limit fsize to 2GB              ;C08
        MOV     SI,7FFFH                ; Setup maximum file size.        ;C08
        MOV     DI,0FFFFH                                                 ;C08
WRTSIZE:
	MOV	WRT_ARG2,SI
;C08    MOV	DI,CXSAVE
	MOV	WRT_ARG1,DI
	MOV	DX,OFFSET DG:WRTMES_PTR
	CALL	PRINTF_CRLF

	POP	DX
	POP	AX
	CALL	RDWR

	JNC	CLSFLE

	CALL	CLSFLE

	CALL	DELETE_A_FILE

	MOV	DX,OFFSET DG:NOSPACE_PTR
	JMP	RESTARTJMP

	CALL	CLSFLE			;is this dead code? - edk

	JMP	COMMAND

CHECKREADONLY:				; ARR 2.4
	MOV	DX,[FILESTRT]
	MOV	SI,[FILEEND]
	PUSH	[SI]
	MOV	BYTE PTR [SI],0
	MOV	AX,CHMOD SHL 8		;AL=0,REQUEST FILE'S CURRENT
					;  ATTRIBUTE BE RETURNED IN CX
	INT	21H

	POP	[SI]
	MOV	DX,OFFSET DG:NOROOM_PTR ; Creation error - report error
	JC	RESTARTJMP

	TEST	CX,ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM
	JZ	RESTARTJMP

	MOV	DX,OFFSET DG:ACCMES_PTR ; Write on read only file
	JMP	RESTARTJMP

CLSFLE:
	MOV	AH,CLOSE
	MOV	BX,[HANDLE]
	INT	21H

	RETURN

EXELOAD:
	POP	[RETSAVE]		; pull up return addr
	INC	BYTE PTR [NEWEXEC]
	MOV	BX,[USER_PROC_PDB]
	MOV	AX,BEGSEG
	MOV	DS,AX
	ASSUME	DS:NOTHING

	CMP	AX,BX
	JZ	DEBUG_CURRENT

	JMP	FIND_DEBUG

DEBUG_CURRENT:
	MOV	AX,CS:[DSSAVE]
DEBUG_FOUND:
	MOV	CS:BYTE PTR [NEWEXEC],0
	MOV	CS:[HEADSAVE],AX
	PUSH	CS:[RETSAVE]		; Get the return address back
	PUSH	AX
	MOV	BX,CS
	SUB	AX,BX
	PUSH	ES
	MOV	ES,CS:BEGSEG
	ASSUME	ES:NOTHING

	MOV	BX,AX			; size of debug in para.
	ADD	BX,10H
	MOV	AX,CS			; and the size of printf in para.
	SUB	AX,CS:BEGSEG
	ADD	BX,AX
	MOV	AH,SETBLOCK
	INT	21H

	POP	ES
	POP	AX
	MOV	CS:WORD PTR [COM_LINE+WORD],AX
	MOV	CS:WORD PTR [COM_FCB1+WORD],AX
	MOV	CS:WORD PTR [COM_FCB2+WORD],AX
	PUSH	DS
	PUSH	CS
	POP	DS
	CALL	EXEC_A_FILE

	POP	DS
	MOV	AX,CS:[HANDLE]
	JC	EXECERR

	CALL	SET_TERMINATE_VECTOR	; Reset int 22

	MOV	AH,GET_CURRENT_PDB
	INT	21H

	MOV	CS:[USER_PROC_PDB],BX
	MOV	CS:[DSSAVE],BX
	MOV	CS:[ESSAVE],BX
	MOV	ES,BX
	MOV	WORD PTR ES:[PDB_EXIT],OFFSET DG:TERMINATE
	MOV	WORD PTR ES:[PDB_EXIT+WORD],CS
	LES	DI,CS:[COM_CSIP]
	MOV	CS:[CSSAVE],ES
	MOV	CS:[IPSAVE],DI
	MOV	CS:WORD PTR [DISADD+WORD],ES
	MOV	CS:WORD PTR [DISADD],DI
	MOV	CS:WORD PTR [ASMADD+WORD],ES
	MOV	CS:WORD PTR [ASMADD],DI
	MOV	CS:WORD PTR [DEFDUMP+WORD],ES
	MOV	CS:WORD PTR [DEFDUMP],DI
	MOV	BX,DS
	MOV	AH,SET_CURRENT_PDB
	INT	21H

	LES	DI,CS:[COM_SSSP]
	MOV	AX,ES:[DI]
	INC	DI
	INC	DI
	MOV	CS:[AXSAVE],AX
	MOV	CS:[SSSAVE],ES
	MOV	CS:[SPSAVE],DI
	RETURN

EXECERR:
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET DG:NOTFND_PTR
	CMP	AX,ERROR_FILE_NOT_FOUND
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:ACCMES_PTR
	CMP	AX,ERROR_ACCESS_DENIED
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:TOOBIG_PTR
	CMP	AX,ERROR_NOT_ENOUGH_MEMORY
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:EXEBAD_PTR
	CMP	AX,ERROR_BAD_FORMAT
	JZ	GOTEXECEMES

	MOV	DX,OFFSET DG:EXECEMES_PTR
GOTEXECEMES:
	CALL	PRINTF_CRLF

	JMP	COMMAND

HEX2BIN:
	MOV	[INDEX],DX
	MOV	DX,OFFSET DG:HEXWRT_PTR
	CMP	BYTE PTR [RDFLG],WRITE
	JNZ	RDHEX

	JMP	RESTARTJ2

RDHEX:
	MOV	ES,AX
	CALL	OPEN_A_FILE

	MOV	DX,OFFSET DG:NOTFND_PTR
	JNC	HEXFND

	JMP	RESTART

HEXFND:
	XOR	BP,BP
	MOV	SI,OFFSET DG:(BUFFER+BUFSIZ) ; Flag input buffer as empty
READHEX:
	CALL	GETCH

	CMP	AL,CHAR_COLON		; Search for : to start line
	JNZ	READHEX

	CALL	GETBYT			; Get byte count

	MOV	CL,AL
	MOV	CH,0
	JCXZ	HEXDONE

	CALL	GETBYT			; Get high byte of load address

	MOV	BH,AL
	CALL	GETBYT			; Get low byte of load address

	MOV	BL,AL
	ADD	BX,[INDEX]		; Add in offset
	MOV	DI,BX
	CALL	GETBYT			; Throw away type byte

READLN:
	CALL	GETBYT			; Get data byte

	STOSB
	CMP	DI,BP			; Check if this is the largest address so far
	JBE	HAVBIG

	MOV	BP,DI			; Save new largest
HAVBIG:
	LOOP	READLN

	JMP	SHORT READHEX

GETCH:
	CMP	SI,OFFSET DG:(BUFFER+BUFSIZ)
	JNZ	NOREAD

	MOV	DX,OFFSET DG:BUFFER
	MOV	SI,DX
	MOV	AH,READ
	PUSH	BX
	PUSH	CX
	MOV	CX,BUFSIZ
	MOV	BX,cs:[HANDLE]
	INT	21H

	POP	CX
	POP	BX
	OR	AX,AX
	JZ	HEXDONE

NOREAD:
	LODSB
	CMP	AL,CHAR_EOF
	JZ	HEXDONE

	OR	AL,AL
	RETNZ

HEXDONE:
	MOV	[CXSAVE],BP
	MOV	BXSAVE,0
	RETURN

HEXDIG:
	CALL	GETCH

	CALL	HEXCHK

	RETNC

	MOV	DX,OFFSET DG:HEXERR_PTR
RESTARTJ2:
	JMP	RESTART

GETBYT:
	CALL	HEXDIG

	MOV	BL,AL
	CALL	HEXDIG

	SHL	BL,1
	SHL	BL,1
	SHL	BL,1
	SHL	BL,1
	OR	AL,BL
	RETURN

;=========================================================================
; ABSREAD:	This routine performs a primitive logical sector read of
;		the specified drive.  This routine replaces the old
;		INT 25h function which only allowed 16 bit addressibility.
;		The new generic IOCtl logical sector read will permit
;		32 bit addressibility on a disk device.
;
;	Inputs : REL_READ_WRITE_TAB	- Table provides dword sector
;					  addressibility.
;
;	Outputs: Data located at specified transfer address.
;
;	Error  : Carry is set on error.
;
;	Date	  : 6/17/87
;=========================================================================

ABSREAD 	proc	near		;an000;read logical sector(s)

	push	ds			;an000;save affected regs
	push	cx			;an000;save affected regs
	push	bx			;an000;

	mov	cx,-1			;an000;extended format
	mov	bx,offset dg:rel_read_write_tab  ;an000;point to read/write table
	int	25h			;an000;invoke relative sector read
	pop	bx			;an000;discard stack word

	pop	bx			;an000;restore regs
	pop	cx			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

ABSREAD 	endp			;an000;end proc


;=========================================================================
; ABSWRT:	This routine performs a primitive logical sector write of
;		the specified drive.  This routine replaces the old
;		INT 26h function which only allowed 16 bit addressibility.
;		The new generic IOCtl logical sector write will permit
;		32 bit addressibility on a disk device.
;
;	Inputs : REL_READ_WRITE_TAB	- Table provides dword sector
;					  addressibility.
;
;	Outputs: Data moved from transfer address to applicable sector(s).
;
;	Error  : Carry is set on error.
;
;	Date	  : 6/17/87
;=========================================================================

ABSWRT		proc	near		;an000;write logical sector(s)

	push	ds			;an000;save affected regs
	push	cx			;an000;
	push	bx			;an000;

	mov	cx,-1			;an000;extended format
	mov	bx,offset dg:rel_read_write_tab  ;an000;point to read/write table
	int	26h			;an000;invoke relative sector write
	pop	bx			;an000;discard stack word

	pop	bx			;an000;restore regs
	pop	cx			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

ABSWRT		endp			;an000;end proc

;*************************************************************************;C01
;This function is designed to test the size of any file being written to  ;C01
;disk or diskette.  If the file wanting to be written is larger than space;C01
;available on disk or diskette then the write will not occur.  This will  ;C01
;prevent the file from being deleted when "insufficient memory" is present;C01
									  ;C01
ChkFileSz   PROC    NEAR						  ;C01
	mov	bx,DriveOfFile		;get drive number of file	  ;C01
	mov	dl,bl			;				  ;C01
	mov	ah,36h			;DOS Function call		  ;C01
	int	21h			;get drive allocation information ;C01
	cmp	ax,0FFFFh		;Q: Was there an error?		  ;C01
	je	RSJMP			;  Y: yes			  ;C01
	mov	cs:AvailClusts,bx	;save # of avail. clusters	  ;C01
	mov	cs:SectsPerClust,ax	;save sectors per cluster	  ;C01
	mov	cs:BytesPerSect,cx	;save bytes per sector		  ;C01

	mul	cs:BytesPerSect						  ;C09
	mov	cs:BytesPerClust,ax	;Compute & save bytes per cluster ;C09

									  ;C01
;Determine how many clusters the new file would have to use.  This value  ;C01
;must be less than the number of available clusters, AvailClusts, or	  ;C01
;the write will have further tests made before executing.		  ;C01
									  ;C01
	mov	dx,BXSAVE	     ;get high order file size		  ;C01
	mov	TempHB,dx						  ;C01
	mov	ax,CXSAVE	     ;get low order file size		  ;C01
	mov	TempLB,ax						  ;C01

;C09	mov	ax,cs:SectsPerClust					  ;C08
;C09	mul	cs:BytesPerSect		;dx:ax = max file size available  ;C08
;C09	mul	cs:AvailClusts						  ;C08
;C09	cmp	dx,cs:TempHB		;Q: Is high word of free space	  ;C08
;C09					;  > size of file?		  ;C08
;C09	ja	CONT5			;  Y: yes, do write		  ;C08
;C09	je	TRY_LOW			;Q: Equal? Y: Try lower word	  ;C08
;C09	jmp	RSJMP			; must be greater, issue error	  ;C08
;C09TRY_LOW:								  ;C08
;C09	cmp	ax,cs:TempLB		;Q: Is low word of free space	  ;C08
;C09					;  > size of file?		  ;C08
;C09	jae	CONT5			;  Y: yes, don't write		  ;C08
;C09RSJMP:								  ;C08
;C09	mov	dx,OFFSET DG:NOSPACE_PTR				  ;C08
;C09	jmp	RESTARTJMP						  ;C08
;C09cont5	label	near						  ;C08
;C09		ret							  ;C08


;C09	div	cs:BytesPerSect		;compute # of sects. for new file ;C01
;C09	cmp	dx,0			;Q: Was there a remainder?	  ;C01
;C09	je	cont1			;  A:no, don't do anything	  ;C01
;C09	inc	ax			;    yes, incr. # of sectors	  ;C01
;C09	xor	dx,dx			;prepare for next divide	  ;C01
;C09cont1	label	near						  ;C01
;C09	div	cs:SectsPerClust	;compute # of clusts for new file ;C01

;	if the count is absurdly large (# clusters > 0ffffh), then
;	  we have to check for the overflow as a special case before
;	  doing the divide.  This is actually quite likely when
;	  people do this command without knowing that the user bx register
;	  contains one of the parameters.

	cmp	dx,cs:BytesPerClust	; see if we're going to get an overflow
	jnb	RSJMP			;  give error if we would've

	div	cs:BytesPerClust	;compute # of clusts for new file ;C09
	or	dx,dx			;Q: Was there a remainder?
	je	cont2			;  A: no, don't do anything	  ;C01
	inc	ax			;     yes, incr. # of clusters	  ;C01
	jz	RSJMP			; give error if rounded to 0
cont2	label	near							  ;C01
	cmp	cs:AvailClusts,ax	;Q: Are there enough disk clusts  ;C01
					;  for the write to occur	  ;C01
	jae	cont5			;  A: yes, write to disk	  ;C01
	mov	cs:FileSzInClusts,ax	;save # of clusters of new file	  ;C01
									  ;C01
;Determine how many clusters the given file now occupies on the disk or	  ;C01
;diskette for comparison with the # of clusters of the new file		  ;C01
									  ;C01
	mov	dx,FileSizeHB	     ;Set up DX:AX with current file	  ;C01
	mov	ax,FileSizeLB	     ;	size				  ;C01
;C09	div	cs:BytesPerSect		;compute # of sects. used by file ;C01
;C09	cmp	dx,0			;Q: Was there a remainder?	  ;C01
;C09	je	cont3			;  A:no, don't do anything	  ;C01
;C09	inc	ax			;    yes, incr. # of sectors	  ;C01
;C09	xor	dx,dx			;prepare for next divide	  ;C01
;C09cont3	label	near						  ;C01
	div	cs:BytesPerClust	;compute # of clusts used by file ;C09
	cmp	dx,0			;Q: Was there a remainder?	  ;C01
	je	cont4			;  A: no, don't do anything	  ;C01
	inc	ax			;     yes, incr. # of clusters	  ;C01
cont4	label	near							  ;C01
	add	ax,cs:AvailClusts	;Get total of file and available  ;C09
	cmp	cs:FileSzInClusts,ax	;Q: Is cluster size of new file	  ;C01
					;  > cluster size of file?	  ;C01
	jna	cont5			;  A: no, go ahead and write
									  ;C01
RSJMP:									  ;C01
	mov	dx,OFFSET DG:NOSPACE_PTR				  ;C01
	jmp	RESTARTJMP						  ;C01
cont5	label	near							  ;C01
		ret							  ;C01
									  ;C01
;   These variables used to determine if the file is larger than the	  ;C01
;   amount of disk space available whenever a write occurs.		  ;C01
									  ;C01
AvailClusts	    DW	?						  ;C01
SectsPerClust	    DW	?						  ;C01
BytesPerSect	    DW	?						  ;C01
FileSzInClusts	    DW	?						  ;C01
MaxBytesInFClust    DW	?						  ;C01
BytesPerClust	    DW	?						  ;C09
ChkFileSz endp								  ;C01

CODE	ENDS
	END	DEBCOM2

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debems.asm ===
PAGE	60,132 ;
	TITLE	DEBEMS.ASM - EMS DEBUGGER COMMANDS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBEMS.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH ACCESS TO RUDIMENTARY EMS FACILITIES.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT EMS FUNCTIONS	DSM:6/24/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/21/90  DIC  C04	Fixed Microsoft Bug #744 - A problem involving a
;                   			limitation on the total number of requested EMS memory
;                   			pages to 255.  This limit is now a 4-digit hexadecimal
;                   			number.
;   04/05/90  DIC  C05 MSFT #990 - "XS" command in debug always displays the
;                      default total handle of "FF" instead of the actual
;                      number.  This fix uses  func-54h, sub-func: 02h via
;                      EMS V4.0.
;   04/30/90  DIC  C06 MSFT # 994 - Debug does not use the "approved" means
;                      of checking EMS status.  This version uses a more
;                      traditional method of: (1) Attempting an OPEN on the
;                      guaranteed resource name of: EMMXXXX0 and (2) using
;                      IOCTL sub-functions (0) and (7) to determine if the
;                      name EMMXXXX0 actually represents a file or not.
;
;==============================================================================
INCLUDE DOSSYM.INC
include version.inc		; cas -- missing equates
include debug.inc


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

	extrn xm_page:word		   ;an000;page count to allocate  ;C04
		      ; allow max of 64K pages to allocate.		  ;C04
		      ; "xm_page" was an 8-bit quantity.		  ;C04

	extrn xm_log:byte			;an000;log. page to map
	extrn xm_phy:byte			;an000;phy. page to map
	extrn xm_handle:word			;an000;handle to map
	extrn xm_handle_ret:word		;an000;handle created

	extrn xm_page_cnt:word			;an000;page count
	extrn xm_handle_pages_buf:byte		;an000;holds handles and pages
	extrn xm_frame:word			;an000;EMS frame value
	extrn xm_deall_han:word 		;an000;handle to deallocate
	extrn xm_alloc_pg:word			;an000;pages allocated
	extrn xm_total_pg:word			;an000;total pages possible
	extrn xm_han_alloc:word 		;an000;handles allocated
	extrn xm_han_total:word 		;an000;total handles possible

	extrn	  xm_han_ret_ptr:word		;an000;prints handle created
	extrn	  xm_mapped_ptr:word		;an000;prints log/phy pages
	extrn	  xm_page_seg_ptr:word		;an000;Frame seg status
	extrn	  xm_deall_ptr:word		;an000;Handle deallocation
	extrn	  xm_unall_ptr:word		;an000;prints page status
	extrn	  xm_han_alloc_ptr:word 	;an000;print handle status

	extrn	  xm_err80_ptr:word		;an000;ems error message
	extrn	  xm_err83_ptr:word		;an000;ems error message
	extrn	  xm_err84_ptr:word		;an000;ems error message
	extrn	  xm_err85_ptr:word		;an000;ems error message
	extrn	  xm_err86_ptr:word		;an000;ems error message
	extrn	  xm_err87_ptr:word		;an000;ems error message
	extrn	  xm_err88_ptr:word		;an000;ems error message
	extrn	  xm_err89_ptr:word		;an000;ems error message
	extrn	  xm_err8a_ptr:word		;an000;ems error message
	extrn	  xm_err8b_ptr:word		;an000;ems error message
	extrn	  xm_err8d_ptr:word		;an000;ems error message
	extrn	  xm_err8e_ptr:word		;an000;ems error message
	extrn	  xm_errff_ptr:word		;an000;ems error message
	extrn	  xm_err_gen_ptr:word		;an000;ems error message
	extrn	  xm_parse_err_ptr:word 	;an000;input error message
	extrn	  xm_status_ptr:word		;an000;prints status of EMS

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	public	  debems			;an000;entry point
	extrn	  std_printf:near		;an000;message retriever
	extrn	  gethx:near			;an000;ASCII to bin conversion
	extrn	  inbuf:near			;an000;input command line
	extrn	  scanb:near			;an000;scan off blanks
	extrn	  scanp:near			;an000;scan for parm
	extrn	  perr:near			;an000;print ^ error
	extrn	  geteol:near
	extrn	  crlf:near			;an000;prints a cr,lf

	IF	SYSVER
	ENDIF

DEBEMS: 					;an000;entry to module

	call SCANP				;an000;scan for M or S parm
;	$if  z					;an000;no parms found
	JNZ $$IF1
	     call XM_PARSE_ERROR		;an000;tell user of error
;	$else					;an000;
	JMP SHORT $$EN1
$$IF1:
	     mov  al,[si]			;an000;grab parm
	     cmp  al,"M"			;an000;is it MAP?
;	     $if  e				;an000;yes
	     JNE $$IF3
		  inc  si			;an000;point to next byte
		  call XM_EMS_MAP		;an000;
;	     $else				;an000;
	     JMP SHORT $$EN3
$$IF3:
		  cmp  al,"S"			;an000;is it a status check?
;		  $if  e			;an000;yes
		  JNE $$IF5
		       inc  si			;an000;point to next byte
		       call XM_EMS_STATUS	;an000;
;		  $else 			;an000;
		  JMP SHORT $$EN5
$$IF5:
		       cmp  al,"D"		;an000;Deallocate pages?
;		       $if  e			;an000;yes
		       JNE $$IF7
			    inc   si		;an000;point to next byte
			    call  XM_EMS_DEALL	;an000;
;		       $else			;an000;
		       JMP SHORT $$EN7
$$IF7:
			    cmp  al,"A" 	;an000;Allocate pages?
;			    $if  e		;an000;yes
			    JNE $$IF9
				 inc  si	;an000;point to next byte
				 call XM_EMS_ALLOC    ;an000;
;			    $else		;an000;
			    JMP SHORT $$EN9
$$IF9:
				call GETEOL	;an000;check out parm
;			    $endif		;an000;
$$EN9:
;		       $endif			;an000;
$$EN7:
;		  $endif			;an000;
$$EN5:
;	    $endif				;an000;
$$EN3:
;	$endif					;an000;
$$EN1:

	ret					;an000;return to caller



;=========================================================================
; XM_EMS_ALLOC	  :    This function will provide the user the
;		       capability to set and change EMS logical and
;		       physical pages within page frame 0.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_ALLOC	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF16
	     call XM_PAGE_PROMPT		;an000;get pages to allocate
	     call XM_GET_HAN_ALLOC		;an000;allocate pages
	     mov  dg:XM_HANDLE_RET,dx		;an000;save handle returned
;	     $if  z				;an000;good return
	     JNZ $$IF17
		  pushf 			;an000;save our flags
		  call XM_DISP1 		;an000;tell user results
		  popf				;an000;restore our flags
;	     $else				;an000;
	     JMP SHORT $$EN17
$$IF17:
		  call XM_ERROR 		;an000;print error message
;	     $endif				;an000;
$$EN17:
;	$else					;an000;EMS not active
	JMP SHORT $$EN16
$$IF16:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN16:

	ret					;an000;return to caller

XM_EMS_ALLOC	  endp				;an000;


;=========================================================================
; XM_EMS_MAP	  :    This function will provide the user the
;		       capability to set and change EMS logical and
;		       physical pages within page frame 0.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_MAP	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF22
	     call XM_LOG_PROMPT 		;an000;get logical page
	     call XM_PHY_PROMPT 		;an000;get physical page
	     call XM_HAN_PROMPT 		;an000;get handle
	     call XM_MAP_MEMORY 		;an000;map the page
;	     $if  z				;an000;good return
	     JNZ $$IF23
		  pushf 			;an000;save our flags
		  call XM_DISP2 		;an000;tell user results
		  popf				;an000;restore our flags
;	     $else				;an000;
	     JMP SHORT $$EN23
$$IF23:
		   call XM_ERROR		;an000;tell error
;	     $endif				;an000;
$$EN23:
;	$else					;an000;EMS not active
	JMP SHORT $$EN22
$$IF22:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN22:

	ret					;an000;return to caller

XM_EMS_MAP	  endp				;an000;

;=========================================================================
; XM_GET_MAN_STATUS :  This routine will determine if EMS is active for
;		       this session.
;
;	Called Procs:  none
;
;	Inputs:        none
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       AH - error message number
;
;	Date:	       6/24/87
; C06 - DIC    4/30/90 This routine has been updated in order to employ
;                      a slightly more traditional method to determine the
;                      existence or absence of EMS.
;=========================================================================

std_emm_name   db      "EMMXXXX0",0     ;  C06 - Standard device name for the
                                        ;  C06 - Expanded Memory Manager.

XM_GET_MAN_STATUS proc near			;an000;see if EMS active

;   C06   	push	ds				;an000;save ds - we stomp it
;   C06   	mov	ax,00h				;an000;set ax to 0
;   C06   	mov	ds,ax				;an000;set ds to 0
;   C06   	cmp	ds:word ptr[067h*4+0],0 	;an000;see if int 67h is there
;   C06   	pop	ds				;an000;restore ds
;   C06   ;	$if	e				;an000;EMS not installed
;   C06   	JNE $$IF28
;   C06   		stc				;an000;flag no ems
;   C06   		mov	ah,XM_NOT_INST		;an000;signal EMS not installed
;   C06   ;	$else					;an000;
;   C06   	JMP SHORT $$EN28
;   C06   $$IF28:
;   C06   		call	XM_INSTALL_CHECK	;an000;see if EMS installed
;   C06   ;		$if	z			;AN000;IS EMS INSTALLED
;   C06   		JNZ $$IF30
;   C06   			clc			;AN000;EMS INSTALLED - FLAG IT
;   C06   ;		$else				;an000;
;   C06   		JMP SHORT $$EN30
;   C06   $$IF30:
;   C06   			stc			;AN000;FLAG EMS NOT INSTALLED
;   C06   			mov  ah,XM_NOT_INST	;an000;signal EMS not installed
;   C06   ;		$endif				;an000;
;   C06   $$EN30:
;   C06   ;	$endif					;an000;
;   C06   $$EN28:
;   C06   
;   C06   	RET					;AN000;RETURN TO CALLER

           push    ds                        ;  C06
           push    cs                        ;  C06
           pop     ds                        ;  C06
           mov     dx,offset std_emm_name    ;  C06 - Attempt to OPEN the 
           mov     ax,3d00h                  ;  C06 - Standard (guaranteed) EMM driver
           int     21h                       ;  C06 - name.  It might actually be a file.
           jc      emm_not_present           ;  C06 - If EMM driver is not present.
           
           ;  Otherwise, the name: EMMXXXX0 does exist, but it might turn out   C06
           ;  to be a file instead of the name of a device driver.              C06

           mov     bx,ax                     ;  C06 - Handle from the OPEN operation.
           mov     ax,4400h                  ;  C06 - Get device information
           int     21h                       ;  C06 - using traditional MSDOS method.
           jc      emm_not_present           ;  C06 - If error, then assume EMM does not exist.
           and     dx,80h                    ;  C06 - Is it a character device ?
           jz      emm_not_present           ;  C06 - NO--> Assume EMM is not present
           mov     ax,4407h                  ;  C06 - Request OUTPUT status
           int     21h                       ;  C06 - via traditional MSDOS method.
           jc      emm_not_present           ;  C06 - interpret as EMM-not-present.
           or      al,al                     ;  C06 - Device status ?
           jz      emm_not_present           ;  C06 - if EMM is not available
           
           ; since these tests have been passed, we can assume            C06
           ; that the EMMXXXX0 drive does indeed exist.                   C06

           mov     ah,03eh                   ;  C06 - Close out the EMM device handle
           int     21h                       ;  C06
           jc      emm_not_present           ;  C06 - Failure here is interpreted as:
                                             ;  C06 - EMM not available.
           call    XM_INSTALL_CHECK          ;  C06 - Do std EMS installation check.
           jnz     emm_not_present           ;  C06 - If EMS does not exist.
           clc                               ;  C06 - Successful return
           pop     ds                        ;  C06 - He gets restored.
           ret                               ;  C06

emm_not_present:

           stc                               ;  C06
           mov     ah,XM_NOT_INST            ;  C06 - error number
           pop     ds                        ;  C06
           ret                               ;  C06

XM_GET_MAN_STATUS endp				;an000;

;=========================================================================
; XM_PAGE_PROMPT :     This routine prompts the user for the number of
;		       pages to be allocated, if he desires a new handle.
;		       This routine will determine whether or not the other
;		       prompt messages will be displayed.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_PAGE_FLAG
;		       XM_PAGE_BUF
;		       XM_PAGE
;
;	Date:	       6/24/87
;=========================================================================

XM_PAGE_PROMPT	  proc near			;an000;prompt user for number
						;      of pages to allocate
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;if parm found
	JZ $$IF34
;C04	     mov  cx,02 			;an000;bytes to parse
	     mov  cx,04 			;an000;bytes to parse	   ;C04
						;   (maximum entry of 64K) ;C04
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF35
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN35
$$IF35:
;C04		  mov  dg:XM_PAGE,dl		;an000;save page count
		  mov  word ptr dg:XM_PAGE,dx	;save page cnt (max=64K)  ;C04
;	     $endif				;an000;
$$EN35:
;	$else					;an000;
	JMP SHORT $$EN34
$$IF34:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN34:

	ret					;an000;return to caller

XM_PAGE_PROMPT	  endp				;an000;


;=========================================================================
; XM_LOG_PROMPT :      This routine prompts the user for the number of the
;		       logical page that is to be mapped in EMS.  This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_LOG_BUF
;		       XM_LOG
;
;	Date:	       6/24/87
;=========================================================================


XM_LOG_PROMPT	  proc near			;an000;prompt user for the
						;      logical page to be
						;      mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm entered
	JZ $$IF40
	     mov  cx,02 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF41
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN41
$$IF41:
		  mov  dg:XM_LOG,dl		;an000;save logical page
;	     $endif				;an000;
$$EN41:
;	$else					;an000;
	JMP SHORT $$EN40
$$IF40:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN40:

	ret					;an000;return to caller

XM_LOG_PROMPT	  endp				;an000;


;=========================================================================
; XM_PHY_PROMPT :      This routine prompts the user for the number of the
;		       physical page that is to be mapped in EMS.  This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_PHY_BUF
;		       XM_PHY
;
;	Date:	       6/24/87
;=========================================================================


XM_PHY_PROMPT	  proc near			;an000;prompt user for the
						;      physical page to be
						;      mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm found
	JZ $$IF46
	     mov  cx,02 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF47
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN47
$$IF47:
		  mov  dg:XM_PHY,dl		;an000;save logical page
;	     $endif				;an000;
$$EN47:
;	$else					;an000;
	JMP SHORT $$EN46
$$IF46:
	     call PERR				;an000;
;	$endif					;an000;
$$EN46:

	ret					;an000;return to caller

XM_PHY_PROMPT	  endp				;an000;


;=========================================================================
; XM_HAN_PROMPT :      This routine prompts the user for the number of the
;		       handle that the mapping is to occur on. This
;		       routine will not be performed if a page count
;		       was specified.
;
;	Called Procs:  STD_PRINTF
;		       XM_PARSE
;
;	Inputs:        none
;
;	Outputs:       XM_HAN_BUF
;		       XM_HAN
;
;	Date:	       6/24/87
;=========================================================================


XM_HAN_PROMPT	  proc near			;an000;prompt user for the
						;      handle to be mapped
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;prompt found
	JZ $$IF52
	     mov  cx,04 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF53
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN53
$$IF53:
		  mov  dg:XM_HANDLE,dx		;an000;save logical page
;	     $endif				;an000;
$$EN53:
;	$else					;an000;
	JMP SHORT $$EN52
$$IF52:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN52:

	ret					;an000;return to caller

XM_HAN_PROMPT	  endp				;an000;



;=========================================================================
; XM_GET_HAN_ALLOC :   This routine will get a handle and allocate the
;		       requested number of pages to that handle.
;
;	Called Procs:  none
;
;	Inputs:        XM_PAGE - number of pages to allocate to handle
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       DX - handle allocated
;
;	Date:	       6/24/87
;=========================================================================

XM_GET_HAN_ALLOC  proc near			;an000;create handle and alloc.
						;      requested pages.
	push bx 				;an000;save regs.
	mov  ah,EMS_HAN_ALLOC			;an000;function 43h
;C04	xor  bh,bh				;an000;clear byte
;C04	mov  bl,dg:XM_PAGE			;an000;number of pages to
	mov  bx,word ptr dg:XM_PAGE		;num of pages (64K limit) to;C04
						;      allocate
	int  67h				;an000;call EMS
	or   ah,ah				;an000;was there an error
	pop  bx 				;an000;restore regs.

	ret					;an000;return to caller

XM_GET_HAN_ALLOC  endp				;an000;

;=========================================================================
; XM_MAP_MEMORY :      This routine will map the requested logical page
;		       to the requested physical page in EMS.
;
;	Called Procs:  none
;
;	Inputs:        XM_PHY - physical page to map to
;		       XM_HAN - logical page to map
;
;	Outputs:       Z  - no error
;		       NZ - error
;		       page mapped
;
;	Date:	       6/24/87
;=========================================================================

XM_MAP_MEMORY	  proc near			;an000;map a logical page to
						;      a physical page in
						;      EMS
	push bx 				;an000;save regs.
	push dx 				;an000;
	mov  ah,EMS_MAP_MEMORY			;an000;function 44h
	mov  al,dg:XM_PHY			;an000;physical page to map
	xor  bh,bh				;an000;zero byte
	mov  bl,dg:XM_LOG			;an000;logical page to map
	mov  dx,dg:XM_HANDLE			;an000;handle to map page to
	int  67h				;an000;call EMS
	or   ah,ah				;an000;was there an error
	pop  dx 				;an000;restore regs.
	pop  bx 				;an000;

	ret					;an000;return to caller

XM_MAP_MEMORY	  endp				;an000;


;=========================================================================
; XM_DISP1 :	       This routine displays the current page frame and
;		       the handle created as a result of the allocate pages.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_FRAME_SEG	- page frame segment
;		       XM_HANDLE_RET	- created handle
;		       XM_PG_FRAME_PTR	- pointer to message
;		       XM_HAN_RET_PTR	- pointer to message
;
;	Outputs:       "Page Frame Segment : %1",0d,0a
;		       "Handle Created     : %1",0d,0a
;
;	Date:	       6/24/87
;=========================================================================

XM_DISP1	  proc near			;an000;display messages

	mov  dx,offset dg:XM_HAN_RET_PTR	;an000;"Handle Created    : "
	call STD_PRINTF 			;an000;call message ret.

	ret					;an000;return to caller

XM_DISP1	  endp				;an000;


;=========================================================================
; XM_DISP2 :	       This routine displays the logical page mapped and
;		       the physical page it was mapped to.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_MAPPED_PTR	- pointer to message
;		       XM_LOG		- logical page mapped
;		       XM_PHY		- physical page mapped
;
;	Outputs:       "Logical page %1 mapped to physical page %2",0d0a
;
;	Date:	       6/24/87
;=========================================================================

XM_DISP2	  proc near			;an000;display messages

	mov  dx,offset dg:XM_MAPPED_PTR 	;an000;"Logical page %1 mapped
						;	to physical page %2"
	call STD_PRINTF 			;an000;call message ret.

	ret					;an000;return to caller

XM_DISP2	  endp				;an000;

;=========================================================================
; XM_ERROR:	  This routine will determine what error we have by
;		  querying the result in the AH register.  It will then
;		  report the error to the user through STD_PRINTF
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        AH - error code
;
;	Outputs:       error message
;
;	Date:	       6/24/87
;=========================================================================

XM_ERROR	  proc near			;an000;error message printer

	mov	dx,offset dg:XM_ERR80_PTR	;an000;point to message
	cmp	ah,XM_ERR80			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR83_PTR	;an000;point to message
	cmp	ah,XM_ERR83			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR84_PTR	;an000;point to message
	cmp	ah,XM_ERR84			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR85_PTR	;an000;point to message
	cmp	ah,XM_ERR85			;an000;error message
	je	XM_ERROR_CONT			; print error


	mov	dx,offset dg:XM_ERR86_PTR	;an000;point to message
	cmp	ah,XM_ERR86			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR87_PTR	;an000;point to message
	cmp	ah,XM_ERR87			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR88_PTR	;an000;point to message
	cmp	ah,XM_ERR88			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR89_PTR	;an000;point to message
	cmp	ah,XM_ERR89			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8A_PTR	;an000;point to message
	cmp	ah,XM_ERR8A			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8B_PTR	;an000;point to message
	cmp	ah,XM_ERR8B			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8D_PTR	;an000;point to message
	cmp	ah,XM_ERR8D			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR8E_PTR	;an000;point to message
	cmp	ah,XM_ERR8E			;an000;error message
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERRFF_PTR	;an000;point to message
	cmp	ah,XM_NOT_INST			;an000;EMS not installed
	je	XM_ERROR_CONT			; print error

	mov	dx,offset dg:XM_ERR_GEN_PTR	;an000;general error message

XM_ERROR_CONT:

	jmp STD_PRINTF 				;an000;call message ret.


XM_ERROR	  endp				;an000;

;=========================================================================
; XM_PARSE_ERROR :     This routine will display that an error has occurred
;		       on the input of the requested data.
;
;	Called Procs:  STD_PRINTF
;
;	Inputs:        XM_PARSE_ERR_PTR - error message
;
;	Outputs:       "Invalid value for parameter",0d,0a
;
;	Date:	       6/24/87
;=========================================================================

XM_PARSE_ERROR	  proc near			;an000;input error message

	mov  dx,offset dg:XM_PARSE_ERR_PTR	;an000;error message
	call STD_PRINTF 			;an000;call message ret.
	ret					;an000;return to caller

XM_PARSE_ERROR	  endp				;an000;



;=========================================================================
; XM_EMS_STATUS   :    This function will provide the user with
;		       a report the the current status of EMS.
;
;	Inputs:   none
;
;	Outputs:  EMS page frames set or altered
;
;	Date:	  6/24/87
;=========================================================================

XM_EMS_STATUS	proc	near			;an000;XM functions

	call XM_GET_MAN_STATUS			;an000;see if EMS active
;	$if  nc 				;an000;EMS active
	JC $$IF84
	     call XM_CURR_STATUS		;an000;current status of EMS
;	$else					;an000;EMS not active
	JMP SHORT $$EN84
$$IF84:
	     call XM_ERROR			;an000;say why not active
;	$endif					;an000;
$$EN84:

	ret					;an000;return to caller

XM_EMS_STATUS	  endp				;an000;


;=========================================================================
; XM_CURR_STATUS :	This routine will display the current status of
;			all active EMS handles.
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of all active EMS handles
;			"Handle %1 has %2 pages allocated"
;
;			Physical page with it associated frame segment
;			"Physical page %1 = Frame segment %2"
;
;	Date:	       8/05/86
;=========================================================================

XM_CURR_STATUS		proc	near		;an000;current EMS status

	mov  ah,EMS_HANDLE_PAGES		;an000;get handle pages
	mov  di,offset dg:XM_HANDLE_PAGES_BUF	;an000;point to the buffer
	int  67h				;an000;

	or   ah,ah				;an000;see if an error occurred
;	$if  z					;an000;no error
	JNZ $$IF87
;	     $do				;an000;do while data in buffer
$$DO88:
		  cmp  bx,0			;an000;end of buffer?
;		  $leave  e			;an000;yes
		  JE $$EN88
		       mov  ax,word ptr es:[di] ;an000;page handle
		       mov  dg:XM_HANDLE_RET,ax ;an000;save in var
		       mov  ax,word ptr es:[di+02];an000;page count
		       mov  dg:XM_PAGE_CNT,ax	;an000;save in var
		       mov  dx,offset dg:XM_STATUS_PTR ;an000;point to message
		       call STD_PRINTF		;an000;print it
		       add  di,04h		;an000;next record
		       dec  bx			;an000;decrement counter
;	     $enddo				;an000;
	     JMP SHORT $$DO88
$$EN88:

	     call  CRLF 			;an000;place a blank line
						;      between reports

	     call  XM_FRAME_BUFFER		;an000;get frame buffer
						;ES:DI points to frame buffer
;	     $do				;an000;while cx not = 0
$$DO91:
		  cmp  cx,00			;an000;at end?
;		  $leave e			;an000;yes
		  JE $$EN91
		       call  XM_GET_FRAME_SEG	;an000;obtain page and seg
		       mov   dx,offset dg:XM_PAGE_SEG_PTR  ;an000;message
		       call  STD_PRINTF 	;an000;print it
		       dec   cx 		;an000;decrease counter
		       add   di,04		;an000;adjust pointer
;	     $enddo				;an000;
	     JMP SHORT $$DO91
$$EN91:

	     call  XM_UNALL_COUNT		;an000;display page status
	     call  XM_HANDLE_COUNT		;an000;display handle status

;	$else
	JMP SHORT $$EN87
$$IF87:
	     call  XM_ERROR			;an000;display the error
;	$endif					;an000;
$$EN87:
	ret					;an000;

XM_CURR_STATUS		endp			;an000;

;=========================================================================
; XM_UNALL_COUNT :	This routine generates a line of the status report
;			displaying the number of pages allocated out of
;			the total possible
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of allocated pages
;			"%1 of a total %2 EMS pages have been allocated"
;
;	Date:	       8/05/86
;=========================================================================

XM_UNALL_COUNT		proc	near		;an000;

	mov	ah,EMS_UNALL_PG_CNT		;an000;see how many pages
						;      remaining
	int	67h				;an000;
	or	ah,ah				;an000;see if error

;	$if	z				;an000;no error
	JNZ $$IF96
		push	bx			;an000;save bx
		push	dx			;an000;save dx
		call	CRLF			;an000;
		pop	dx			;an000;restore dx
		pop	bx			;an000;restore bx
		mov	ax,dx			;an000;total page count
		sub	ax,bx			;an000;get pages allocated
		mov	dg:XM_ALLOC_PG,ax	;an000;save allocated pages
		mov	dg:XM_TOTAL_PG,dx	;an000;save total page count
		mov	dx,offset dg:XM_UNALL_PTR ;an000;"%1 of a total %2 EMS
						;      pages have been allocated",cr,lf
		call	STD_PRINTF		;an000;print it
;	$endif					;an000;
$$IF96:

	ret					;an000;

XM_UNALL_COUNT		endp			;an000;


;=========================================================================
; XM_HANDLE_COUNT:	This routine generates a line of the status report
;			displaying the number of handles allocated out of
;			the total possible.
;
;	Inputs	 :	none
;
;	Outputs  :	Current status of allocated pages
;			"%1 of a total %2 EMS handles have been allocated"
;
;	Date:	       8/05/86
;=========================================================================

XM_HANDLE_COUNT 	proc	near		;an000;

	mov	ah,EMS_HANDLE_CNT		;an000;see how many handles
                  						;      possible
 int 67h                ; C05 - Request total currently allocated.
 or  ah,ah              ; C05 - 
 jnz $$IF98             ; C05 - If error
 mov word ptr dg:XM_HAN_ALLOC,bx ; C05 - save total number of active handles.
 mov ax,EMS_TOT_HANDLES         ; C05 - Request total handles possible for
                                ; C05 - EMS 4.0
	int	67h				;an000;
	or	ah,ah				;an000;see if error

;	$if	z				;an000;no error
	JNZ $$IF98
;C05      		mov	ax,EMS_HANDLE_TOTAL	;an000;total possible handles
  mov ax,bx                     ;C05 - Total possible handles for EMS 4.0

		mov	dg:XM_HAN_TOTAL,ax	;an000;save total page count
;C05      		mov	dg:XM_HAN_ALLOC,bx	;an000;save allocated pages
  mov bx,dg:XM_HAN_ALLOC           ; C05 - This may not be needed.
		mov	dx,offset dg:XM_HAN_ALLOC_PTR
						;an000;"%1 of a total %2 EMS
						;      handles have been allocated",cr,lf
		call	STD_PRINTF		;an000;print it
;	$endif					;an000;
$$IF98:

	ret					;an000;

XM_HANDLE_COUNT 	endp			;an000;


;=========================================================================
; XM_FRAME_SEG	 :	This routine accesses the vector created by
;			function 58h, int 67h.	It obtains a physical
;			page of EMS and its segment from this vector
;
;	Inputs	 :	ES:DI - points to frame buffer
;
;	Outputs  :	XM_PHY - a physical page in EMS
;			XM_FRAME - segment corresponding to the physical page
;
;	Date:	       8/05/86
;=========================================================================


XM_GET_FRAME_SEG	proc	near		;an000;find the frame segment

	mov	al,byte ptr es:[di+2]		;an000;get physical page
	mov	dg:XM_PHY,al			;an000;place in print var
	mov	ax,word ptr es:[di]		;an000;get frame segment
	mov	dg:XM_FRAME,ax			;an000;place in print var

	ret					;an000;

XM_GET_FRAME_SEG	endp			;an000;

;=========================================================================
; XM_INSTALL_CHECK:	This routine performs function 51h, int 67h to
;			determine if EMS is indeed active.
;
;	Inputs	 :	XM_FRAME_BUFFER - used to receive physical page
;					  and segment data for EMS.
;
;	Outputs  :	XM_FRAME_BUFFER - buffer holds physical page
;					  and segment data for EMS.
;
;	Date:	       8/05/86
;=========================================================================

XM_INSTALL_CHECK	proc	near		;an000;see if EMS installed

	MOV	AH,EMS_GET_MAN_STAT		;AN000;GET EMS STATUS
	XOR	AL,AL				;an000;clear low byte
	INT	67h				;an000;
	OR	AH,AH				;an000;check for error
;	$IF	Z				;an000;no error
	JNZ $$IF100
		MOV	AH,EMS_VERSION		;an000;get version number
		INT	67h			;an000;
		CMP	AL,EMS_LIM_40		;an000;LIM 4.0 ?
;		$IF	AE			;an000;4.0 or greater
		JNAE $$IF101
			MOV	AH,00h		;an000;set up for flag pass
			OR	AH,AH		;an000;set flag to ZR
;		$ELSE				;an000;below 4.0
		JMP SHORT $$EN101
$$IF101:
			MOV	AH,01h		;an000;set up for flag pass
			OR	AH,AH		;an000;set flag to NZ
;		$ENDIF				;an000;
$$EN101:
;	$ENDIF					;an000;
$$IF100:

	ret					;an000;

XM_INSTALL_CHECK	endp			;an000;




;=========================================================================
; XM_EMS_DEALL	:	This routine deallocates handles from EMS.
;
;	Inputs	 :	DX - Handle supplied by XM_DEALL_PROMPT
;
;	Outputs  :	Good return - "Handle %1 deallocated"
;			Bad return  - message describing error
;
;	Date:	       8/05/86
;=========================================================================

XM_EMS_DEALL		proc	near		;an000;deallocate EMS pages

	call XM_GET_MAN_STATUS			;an000;see if EMS installed
;	$if  nc 				;an000;error?
	JC $$IF105
	     call XM_DEALL_PROMPT		;an000;prompt user for handle
	     mov  ah,EMS_PAGE_DEALL		;an000;function 45h, int 67h
	     int  67h				;an000;

	     or   ah,ah 			;an000;error?
;	     $if  nz				;an000;yes
	     JZ $$IF106
		  call XM_ERROR 		;an000;say why
;	     $else				;an000;
	     JMP SHORT $$EN106
$$IF106:
		  mov  dx,offset dg:XM_DEALL_PTR;an000;"Handle %1 deallocated"
		  call STD_PRINTF		;an000;print message
;	     $endif				;an000;
$$EN106:
;	$else					;an000;
	JMP SHORT $$EN105
$$IF105:
	     call XM_ERROR			;an000;print type of error
;	$endif					;an000;
$$EN105:

	ret					;an000;

XM_EMS_DEALL		endp			;an000;

;=========================================================================
; XM_DEALL_PROMPT :	This routine prompts the user for the handle to be
;			deallocated.  It converts the handle entered to
;			binary and passes it back to the caller in DX.
;
;	Inputs	 :	none
;
;	Outputs  :	DX - Handle to be deallocated.
;
;	Date:	       8/05/86
;=========================================================================

XM_DEALL_PROMPT 	proc	near		;an000;prompt user for handle
						;      to deallocate
	call SCANB				;an000;see if parm entered
;	$if  nz 				;an000;parm found
	JZ $$IF111
	     mov  cx,04 			;an000;bytes to parse
	     call GETHX 			;an000;get hex value
;	     $if  c				;an000;no an error occurred
	     JNC $$IF112
		  call PERR			;an000;display ^ error
;	     $else				;an000;
	     JMP SHORT $$EN112
$$IF112:
		  mov  dg:XM_DEALL_HAN,dx	;an000;save handle to deallocate
;	     $endif				;an000;
$$EN112:
;	$else					;an000;
	JMP SHORT $$EN111
$$IF111:
	     call PERR				;an000;display ^ error
;	$endif					;an000;
$$EN111:

	ret					;an000;return to caller

XM_DEALL_PROMPT 	endp			;an000;


;=========================================================================
; XM_FRAME_BUFFER	:	This routine obtains the frame buffer
;				of EMS pages.
;
;	Inputs	:	none
;
;	Outputs :	ES:DI - Pointer to frame array
;			CX    - Number of elements in array
;=========================================================================

XM_FRAME_BUFFER 	proc	near		;an000;

	mov	ax,EMS_PG_FRAME 		;an000;get frame buffer
	int	67h				;an000;

	ret					;an000;

XM_FRAME_BUFFER 	endp			;an000;


CODE	ENDS
	END	DEBEMS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debcom3.asm ===
PAGE	80,132 ;
	TITLE	DEBCOM3.ASM - PART3 DEBUGGER COMMANDS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; ROUTINES TO PERFORM DEBUGGER COMMANDS

	IF1
	    %OUT COMPONENT=DEBUG, MODULE=DEBCOM3
	ENDIF
.XLIST
.XCREF
	include	mi.inc			; cas -- missing equates
	include	version.inc		; cas -- missing equates
	include	syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
	INCLUDE DPL.ASM
.CREF
.LIST
CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	USER_PROC_PDB:WORD,RSTACK:WORD,STACK:BYTE
	EXTRN	DSSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD,axSAVE:WORD,dxSAVE:WORD
	EXTRN	SSSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	EXTRN	NEXTCS:WORD,NEXTIP:WORD, RSETFLAG:BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	BRKCNT:WORD,TCOUNT:WORD,SWITCHAR:BYTE,BPTAB:BYTE
	EXTRN	BP_ERROR:BYTE,COMP_ARG1:WORD,COMP_ARG2:WORD,COMP_ARG3:WORD
	EXTRN	COMP_ARG4:WORD,COMP_ARG5:WORD,COMP_ARG6:WORD,COMP_PTR:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE
	EXTRN	FZTRACE:BYTE, SYNERR_PTR:BYTE
	EXTRN	BEGSEG:WORD
	IF	IBMVER
	    EXTRN   cpu_not_8088:byte
	    EXTRN   OLD_MASK:BYTE
	ENDIF
	EXTRN	SAVESTATE:BYTE
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	COMPARE,INPUT,OUTPUT,GO
	PUBLIC	TRACE,ZTRACE,SKIP_FILE
	EXTRN	GETHEX:NEAR,GETEOL:NEAR,CRLF:NEAR,ERR:NEAR, PERR:NEAR
	EXTRN	HEX:NEAR,DIGIT:NEAR,SCANP:NEAR,DISPREG:NEAR
	EXTRN	COMMAND:NEAR,DABORT:NEAR,DELIM1:NEAR,DELIM2:NEAR
	EXTRN	NMIINT:NEAR,NMIINTEND:NEAR,PRINTF_CRLF:NEAR
	EXTRN	ADDRESS:NEAR,HEXIN:NEAR,DSRANGE:NEAR
; just like trace except skips OVER next INT or CALL.
DEBCOM3:
ZTRACE:
	MOV	FZTRACE,-1
	CALL	SETADD
	CALL	SCANP
	CALL	HEXIN
	MOV	DX,1
	JC	ZSTOCNT
	MOV	CX,4
	CALL	GETHEX
	CALL	CHECKNONE
ZSTOCNT:
	MOV	[TCOUNT],DX
	CALL	GETEOL
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
ZSTEP:
	MOV	ES,[CSSAVE]		; point to instruction to execute
	MOV	DI,[IPSAVE]		; include offset in segment
	XOR	DX,DX			; where to place breakpoint
get_opcode:
	MOV	AL,ES:[DI]		; get the opcode
	cmp	al,0f0h 		; lock
	je	is_override
	cmp	al,26h			; es:
	je	is_override
	cmp	al,2eh			; cs:
	je	is_override
	cmp	al,36h			; ss:
	je	is_override
	cmp	al,3eh			; ds:
	jne	not_override
Is_override:
;	inc	dx			; this seemed to put us in an endless
	inc	di			; loop, try this.
	jmp	get_opcode
Not_override:
	CMP	AL,11101000B		; direct intra call
	JZ	ZTRACE3 		; yes, 3 bytes
	CMP	AL,10011010B		; direct inter call
	JZ	ZTRACE5 		; yes, 5 bytes
	CMP	AL,11111111B		; indirect?
	JZ	ZTRACEMODRM		; yes, go figure length
	CMP	AL,11001100B		; short interrupt?
	JZ	ZTRACE1 		; yes, 1 byte
	CMP	AL,11001101B		; long interrupt?
	JZ	ZTRACE2 		; yes, 2 bytes
	CMP	AL,11100010B		; loop
	JZ	ZTRACE2 		; 2 byter
	CMP	AL,11100001B		; loopz/loope
	JZ	ZTRACE2 		; 2 byter
	CMP	AL,11100000B		; loopnz/loopne
	JZ	ZTRACE2 		; 2 byter
	AND	AL,11111110B		; check for rep
	CMP	AL,11110010B		; perhaps?
	JZ	FOO1
	JMP	STEP			; can't do anything special, step
FOO1:
	MOV	AL,ES:[DI+1]		; next instruction
	AND	AL,11111110B		; ignore w bit
	CMP	AL,10100100B		; MOVS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10100110B		; CMPS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101110B		; SCAS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101100B		; LODS
	JZ	ZTRACE2 		; two byte
	CMP	AL,10101010B		; STOS
	JZ	ZTRACE2 		; two byte
	JMP	short STEP		; bogus, do single step

ZTRACEMODRM:
	MOV	AL,ES:[DI+1]		; get next byte
	AND	AL,11111000B		; get mod and type
	CMP	AL,01010000B		; indirect intra 8 bit offset?
	JZ	ZTRACE3 		; yes, three byte whammy
	CMP	AL,01011000B		; indirect inter 8 bit offset
	JZ	ZTRACE3 		; yes, three byte guy
	CMP	AL,10010000B		; indirect intra 16 bit offset?
	JZ	ZTRACE4 		; four byte offset
	CMP	AL,10011000B		; indirect inter 16 bit offset?
	JZ	ZTRACE4 		; four bytes
	CMP	AL,11010000B		; indirect through reg?
	JZ	ZTRACE2 		; two byte instruction
	JMP	short STEP		; can't figger out what this is!
ZTRACE5:
	INC	DX
ZTRACE4:
	INC	DX
ZTRACE3:
	INC	DX
ZTRACE2:
	INC	DX
ZTRACE1:
	INC	DX
	ADD	DI,DX			; offset to breakpoint instruction
	MOV	WORD PTR [BPTAB],DI	; save offset
	MOV	WORD PTR [BPTAB+2],ES	; save segment
	MOV	AL,ES:[DI]		; get next opcode byte
	MOV	BYTE PTR [BPTAB+4],AL	; save it
	MOV	BYTE PTR ES:[DI],0CCH	; break point it
	MOV	[BRKCNT],1		; only this breakpoint
	JMP	DEXIT			; start the operation!

; Trace 1 instruction or the number of instruction specified
; by the parameter using 8086 trace mode. Registers are all
; set according to values in save area
TRACE:
	MOV	FZTRACE,0
	CALL	SETADD
	CALL	SCANP
	CALL	HEXIN
	MOV	DX,1
	JC	STOCNT
	MOV	CX,4
	CALL	GETHEX
	CALL	CHECKNONE
STOCNT:
	MOV	[TCOUNT],DX
	CALL	GETEOL
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
STEP:
	MOV	[BRKCNT],0
; The 286 has a problem with trace mode and software interrupt instructions;
; it treats them as atomic operations.	We simulate the operation in software.
	MOV	ES,[CSSAVE]		; Get next instruction pointer
	MOV	DI,[IPSAVE]
	MOV	AL,ES:[DI]		; get next opcode
	cmp	al,0e4h 		; check for 'IN' opcode
	jne	not_inal_op
	cmp	es:byte ptr[di+1],21h
	jne	not_mask_op
	add	[ipsave],2
	JMP	short SETalmask

not_inal_op:
	cmp	al,0ech 		; in al,DX ?
	jne	not_mask_op
	cmp	dxsave,21h
	jne	not_mask_op
	add	[ipsave],1
SETalmask:
	mov	ax,[axsave]
	in	al,21h
	mov	[axsave],ax
	JMP	SETENVIRON

not_mask_op:
	CMP	AL,0CDH 		; trace over an interrupt?
	JZ	DOINT			; no, check for other special cases
	CMP	AL,0CEH 		; how about int overflow
	JNZ	CHECKCC
	TEST	FLSAVE,F_OVERFLOW	 ; see it overflow is present
	JZ	CHECKOP
	MOV	BX,4			; INTO = INT 4
	DEC	IPSAVE			; INTO is a singel byte
	JMP	SHORT DOVAL
CHECKCC:
	CMP	AL,0CCH
	JNZ	CHECKOP
	MOV	BX,3			; INT 3 = CC
	DEC	IPSAVE
	JMP	SHORT DOVAL
DOINT:
; We have a software interrupt.  Get destination vector
	MOV	BL,BYTE PTR ES:[DI+1]	; get vector number
	XOR	BH,BH			; clear out upper
DOVAL:
	SHL	BX,1			; word index
	SHL	BX,1			; dword index
	XOR	DI,DI			; interrupt table
	MOV	ES,DI
	MOV	AX,ES:[BX]		; point to vector
	MOV	BX,ES:[BX+2]		; point to vector
; AX:BX is the vector.	Swap it with currect CS:IP
	XCHG	AX,IPSAVE		; new CS:IP
	XCHG	BX,CSSAVE
; AX:BX is old CS:IP.  We 'PUSH' flags,