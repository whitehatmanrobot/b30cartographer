ervice(pTuneRequest,
						 csCallLetters.GetBuffer(ssfStatChanFieldInfo[StatChanRec_CallLetters].nWidth),
						 csStationNumStr.GetBuffer(ssfStatChanFieldInfo[StatChanRec_Num].nWidth),
						 csName.GetBuffer(ssfStatChanFieldInfo[StatChanRec_Name].nWidth),
						 csNetwork.GetBuffer(ssfStatChanFieldInfo[StatChanRec_NetworkID].nWidth),
						 0,    
						 0);   

				}
			}
        }


	#ifdef _DUMP_LOADER
		ChannelCnt++;
	#endif

		long lChannelNumber = _ttol(csChannelNumStr);

		if (NULL != pTMSService)
		{
			// Add the channel
			//
			pTMSChannel = ctmsLoapApp->m_pgsChannels.AddChannel(pTMSService, 
					csStationNumStr.GetBuffer(ssfStatChanFieldInfo[StatChanRec_Num].nWidth),
					csChannelNumStr.GetBuffer(ssfStatChanFieldInfo[StatChanRec_ChannelNumber].nWidth), 
					lChannelNumber);
		}
		else
			return ERROR_UPDATE_ADD;

		if (NULL != pTMSChannel)
		{
			// Add the "channel + service" data for use by ScheduleEntries
			//
			m_ChannelIDMap[csChannelNumStr.GetBuffer(ssfStatChanFieldInfo[StatChanRec_ChannelNumber].nWidth)] = 
				_ltot(pTMSService->GetID(), ConvBuffer, 10);

			CString csChannelID(_ltot(pTMSService->GetID(), ConvBuffer, 10));
			CString csStatChan = csStationNumStr + "," + csChannelNumStr;

			// Make the corresponding Hash table entry
			//
			m_ChannelIDMap.SetAt(csStatChan, csChannelID);
	#ifdef _DUMP_LOADER
			wsprintf(szDiagBuff, "Saving #%d Channel ID for %s : %d\r\n", ChannelCnt, csStatChan, cct.ChannelID());
			if (NULL != hDiagFile)
			{
				::WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
			}
    #endif

			iRet = UPDATE_SUCCEEDED; 
		}
		else
			return ERROR_UPDATE_ADD;
	}

	return iRet; 
}

long CStatChanRecordProcessor::m_GetChannelID(LPCTSTR lpChannelNum)
{
	CString csChannelID;

	m_ChannelIDMap.Lookup(lpChannelNum, csChannelID);
    return _ttol(csChannelID);
}

int CStatChanRecordProcessor::m_GetState()
{
	return m_nState;
}

int CStatChanRecordProcessor::m_GetError()
{
	return m_nError;
}

int CStatChanRecordProcessor::m_GetErrorString(CString& csErrStr)
{
	if (m_nError)
	{
		// If there is an error to return 
		//
        return csErrStr.LoadString(m_nError);

	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\services.h ===
#ifndef _SERVICES_H_
#define _SERVICES_H_

#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#if 0
#include <bdaiface.h>
#endif
#include <uuids.h>      
#if 0
#include <tuner.h>      
#else
#pragma warning(disable : 4192)
//#import <tuner.tlb> no_namespace raw_method_prefix("") high_method_prefix("_")
#import <tuner.tlb> no_namespace raw_method_prefix("") raw_interfaces_only
#endif

ULONG TestServices(IServicesPtr  pServices, IMetaPropertySetsPtr pPropSets);


// gsServices - The gsServices class manages the services 
//              collection associated with the Guide Store
//
class gsServices
{
public:
    gsServices()
	{
		m_pServices = NULL;
        m_pStationNumProp = NULL;
		m_pLatestStartTime = NULL;
	}
    ~gsServices(){}

	ULONG  Init(IGuideStorePtr  pGuideStore);

	IServicePtr AddService( ITuneRequest* pTuneRequest,
						    _bstr_t bstrProviderName,
							_bstr_t bstrStationNum,
							_bstr_t bstrProviderDescription,
							_bstr_t bstrProviderNetworkName,
							DATE dtStart,
							DATE dtEnd );

    IServicePtr GetService(long lServiceID);

	BOOL        DoesServiceExist(_bstr_t bstrStationNum);

    ULONG       RemoveService(IServicePtr pServiceToRemove){};

	DATE        GetLatestStartTime(IServicePtr pService){};
	DATE        SetLatestStartTime(IServicePtr pService, DATE dtStartTime){};

private:
	IMetaPropertyTypePtr AddStationNumProp(IMetaPropertySetsPtr pPropSets);

	// the services collection 
	//
	IServicesPtr     m_pServices;

	// Station Number MetaProperty type pointer
	//
    IMetaPropertyTypePtr m_pStationNumProp;
    IMetaPropertyTypePtr m_pLatestStartTime;
};


#endif // _SERVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\tmsparse.cpp ===
#include "stdafx.h"
#include <Afxtempl.h>
#include <crtdbg.h>
#include <fstream.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include "errcodes.h"
#include "guidestore.h"
#include "services.h"
#include "channels.h"
#include "programs.h"
#include "schedules.h"
#include "wtmsload.h"
#include "tmsparse.h"
#include "servchan.h"
#include "progschd.h"


#ifdef _DUMP_LOADER
CString csDiagMil;
extern HANDLE hDiagFile;
extern char szDiagBuff[1024];
int         ChannelCnt = 0;
int         TimeSlotCnt = 0;
extern DWORD dwBytesWritten;
#endif


SDataFileFields ssfHeaderFieldInfo[EPGHeader_Fields] = 
{ 
  TRUE, 10,
  TRUE, 36,
  TRUE, 10
};


// CStatChanRecordProcessor
//
CHeaderRecordProcessor::CHeaderRecordProcessor(int nNumFields, 
												 SDataFileFields ssfFieldsInfo[])
{
    m_Init();
	m_pFieldsDesc = ssfFieldsInfo;
	m_nNumFields  = nNumFields;
}

CHeaderRecordProcessor::CHeaderRecordProcessor()
{
    m_Init();
	m_pFieldsDesc = ssfHeaderFieldInfo;
    m_nNumFields  = EPGHeader_Fields;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: m_Process
//
//  PARAMETERS: [IN] lpData    - Data to be processed
//              [IN] nDataSize - Size of data
//
//  PURPOSE: Processes the Data stream for Channel records
//           Once Channel records have been parsed and
//           prepared for table updation signals end of channel records
//           to the file processor
//
/////////////////////////////////////////////////////////////////////////
//
int CHeaderRecordProcessor::m_Process(LPCTSTR lpData, int nDataSize, int* pBytesProcessed)
{
    int nFields = 0;
	int nFieldSize = 0;
	int nParsePos = 0;
	int nBytesProcessed = 0;

	// Parameter validation
	//
	if (NULL == lpData || 0 == nDataSize)
	{
        return ERROR_INVALID_ARGS;
	}
    else
	{
		 *pBytesProcessed = 0;

         // Data Integrity Check
         //
         ASSERT( _CrtIsValidPointer((const void *)lpData, nDataSize, FALSE) );
		 
		 {
             // Data is valid - Start processing
			 //
             do
			 {
	 			 if (STATE_RECORD_INCOMPLETE == m_nState)
				 {
				     nFields = m_nCurrField;
					 nFieldSize = m_nCurrFieldSize;
				 }

                 for(;nParsePos < nDataSize; nParsePos++)
				 {
                     if (lpData[nParsePos] == EOC)
					 {
						 // End of field
						 //
                         if (nParsePos > 0 && (lpData[nParsePos-1] != EOC))
						 {
							 // TODO ASSERT(nFields <= StationRec_Fields);
                             
							 m_szValidField[nFieldSize] = '\0';
					         m_cmRecordMap[nFields] =  m_szValidField;
							 nFieldSize = 0;
						 }
						 else
						 {
                             //nFieldDataPos = nParsePos;
							 nFieldSize = 0;
							 m_nCurrFieldSize = 0;
						 }

						 nFields++;        
						 m_nCurrField++;
	 				 }
                     else if (lpData[nParsePos] == EOR)
					 {
						 // End of the record
						 //
						 m_UpdateDatabase(m_cmRecordMap);
						 m_cmRecordMap.RemoveAll();
						 m_nCurrField = nFields = 0;
						 m_nCurrFieldSize = nFieldSize = 0;
					     continue;
	 				 }
                     else if (lpData[nParsePos] == EOT)
					 {
						 // End of the table
						 //
			             m_nState = STATE_RECORDS_PROCESSED;
						 nParsePos += 2*sizeof(TCHAR);
						 break;
	 				 }
					 else
					 {
						 // Valid field data
						 //
						 m_szValidField[nFieldSize] =  lpData[nParsePos];
                         nFieldSize++;
						 m_nCurrFieldSize++;
					 }
				 }

			 } while ((nParsePos < nDataSize) && (m_nState != STATE_RECORDS_PROCESSED));


			 *pBytesProcessed = nParsePos;

			 if (m_nState != STATE_RECORDS_PROCESSED)
			 {
				 if (lpData[--nParsePos] == EOR)
				 {
                     // More records
					 //
			         m_nState = STATE_RECORDS_INCOMPLETE;                      
				 }
				 else
				 {
                     // record incomplete
					 //
			         m_nState = STATE_RECORD_INCOMPLETE;                      					 
				 }
                  
			 }
		 }
         
	}
	
	return m_nState;

}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: m_UpdateDatabase
//
//  PARAMETERS: [IN] cmRecord  - map containing record fields
//
//  PURPOSE: Updates the Registry Database
//
/////////////////////////////////////////////////////////////////////////
//
int CHeaderRecordProcessor::m_UpdateDatabase(CRecordMap& cmRecord)
{
	CString csUserID, csHeadEndID;
	unsigned char szPrevHeadEndID[20+1]={0};
	CWtmsloadApp* ctmsLoapApp = (CWtmsloadApp*) AfxGetApp();
    DWORD dwHeadEndIDLen = sizeof(szPrevHeadEndID);
    IChannelLineupPtr pChannelLineup = NULL;

	// Lookup the UserID entry in the StationRecord Map
	//
    cmRecord.Lookup(EPGHeader_UserID, csUserID);
	csUserID.TrimLeft();
	csUserID.TrimRight();

	// Lookup the HeadEndID entry in the StationRecord Map
	//
    cmRecord.Lookup(EPGHeader_HeadEndID, csHeadEndID);
	csHeadEndID.TrimLeft();
	csHeadEndID.TrimRight();

	// Does this lineup exist in the store
	//
	pChannelLineup = ctmsLoapApp->m_pgsChannelLineups.GetChannelLineup(csHeadEndID.GetBuffer(ssfHeaderFieldInfo[EPGHeader_HeadEndID].nWidth));

    if (NULL == pChannelLineup)
	{
		// Add this lineup - Must ensure that the correct lineup is available when adding channels
		//
        pChannelLineup = ctmsLoapApp->m_pgsChannelLineups.AddChannelLineup(csHeadEndID.GetBuffer(ssfHeaderFieldInfo[EPGHeader_HeadEndID].nWidth));

	}

	if (NULL != pChannelLineup)
	{
		// Initialize the loader lineup and Channel collections
		//
		IGuideStorePtr pGuideStore = ctmsLoapApp->m_gsp.GetGuideStorePtr();

		if (NULL != pGuideStore)
		{
			ctmsLoapApp->m_pgsChannelLineup.Init(pChannelLineup, csHeadEndID);
			ctmsLoapApp->m_pgsChannels.Init(pGuideStore, pChannelLineup);
		}
	}


	return TRUE;
}


int CHeaderRecordProcessor::m_GetState()
{
	return m_nState;
}

int CHeaderRecordProcessor::m_GetError()
{
	return m_nError;
}

int CHeaderRecordProcessor::m_GetErrorString(CString& csErrStr)
{
	if (m_nError)
	{
		// If there is an error to return 
		//
        return csErrStr.LoadString(m_nError);

	}

	return FALSE;
}



// CRecordProcessor 
//
CDataFileProcessor::CDataFileProcessor()
{
	m_nState = DATA_PROCESS_INIT;
}

int CDataFileProcessor::m_Process(LPCTSTR lpData, int nDataSize)
{
	CWtmsloadApp* ctmsLoapApp  = (CWtmsloadApp*) AfxGetApp();
	int           iProcessRet = STATE_RECORDS_INIT; 

	// Parameter validation
	//
	if (NULL == lpData || 0 == nDataSize)
	{
        return ERROR_INVALID_ARGS;
	}
    else
	{
         // Data Integrity Check
         //
         ASSERT( _CrtIsValidPointer((const void *)lpData, nDataSize, FALSE) );
		 
		 {
				int nBytesProcessed = 0;
                int nTotalBytesProcessed = 0;
             // Process Station records
			 //
             
			 do
			 {
				MSG msg;
				while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
				{
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}

				 switch(m_nState)
				 {
					 case DATA_PROCESS_INIT:
						  // Initialize guide data processing by parsing the headers
						  //
						  iProcessRet = ctmsLoapApp->m_srpHeaders->m_Process(lpData+nTotalBytesProcessed, nDataSize-nTotalBytesProcessed, &nBytesProcessed);
						  if (STATE_RECORDS_PROCESSED == iProcessRet)
						  {
							  m_nState =  DATA_CHAREC_PROCESS;
							  break;
						  }
						  else if (STATE_RECORDS_FAIL == iProcessRet)
						  {
							  m_nState =  DATA_UPDATE_ERROR;
							  break;
						  }
                       
					 case DATA_CHAREC_PROCESS:
						  // Guide data processing continues with the channel and station records
						  //
						  iProcessRet = ctmsLoapApp->m_scrpStatChans->m_Process(lpData+nTotalBytesProcessed, nDataSize-nTotalBytesProcessed, &nBytesProcessed);
						  if (STATE_RECORDS_PROCESSED == iProcessRet)
						  {
							  m_nState =  DATA_TIMREC_PROCESS;
							  break;
						  }
						  else if (STATE_RECORDS_FAIL == iProcessRet)
						  {
							  m_nState =  DATA_UPDATE_ERROR;
							  break;
						  }

					case DATA_TIMREC_PROCESS:
						  // Guide data processing continues with the program and schedule records
						  //
						  iProcessRet = ctmsLoapApp->m_etEpTs->m_Process(lpData+nTotalBytesProcessed, nDataSize-nTotalBytesProcessed, &nBytesProcessed);
						  if (STATE_RECORDS_PROCESSED == iProcessRet)
						  {
							  m_nState =  DATA_PROCESSED;
							  break;
						  }
						  else if (STATE_RECORDS_FAIL == iProcessRet)
						  {
							  m_nState =  DATA_UPDATE_ERROR;
							  break;
						  }

						 break;
                     default:
						 ASSERT(FALSE);
						 break;
				 }

				 if (DATA_UPDATE_ERROR == m_nState)
					 break;

				 nTotalBytesProcessed += nBytesProcessed;
			 }
			 while ((nTotalBytesProcessed < nDataSize) && m_nState !=  DATA_PROCESSED);
		 }
    }
	return m_nState;
}


int CDataFileProcessor::m_GetState()
{
	return m_nState;
}


int CDataFileProcessor::m_GetError()
{
	return m_nError;
}


int CDataFileProcessor::m_GetErrorString(CString& csErrStr)
{
	if (m_nError)
	{
		// If there is an error to return 
		//
        return csErrStr.LoadString(m_nError);

	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\wtmsload.h ===
// wtmsload.h : main header file for the WTMSLOAD DLL
//

#if !defined(AFX_WTMSLOAD_H__3CFC191E_5236_4C05_8A37_A80C246BA6AC__INCLUDED_)
#define AFX_WTMSLOAD_H__3CFC191E_5236_4C05_8A37_A80C246BA6AC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWtmsloadApp
// See wtmsload.cpp for the implementation of this class
//


class CWtmsloadApp : public CWinApp
{
public:
	CWtmsloadApp();
	~CWtmsloadApp(){}

    ULONG InitImport(LPCTSTR lpGuideStoreDB);
    ULONG ProcessInput(LPCTSTR lpGuideDataFile);
    void  ExitImport(void);
protected:
	// Guide time related data members
	//
    COleVariant      m_covNow;
    COleDateTimeSpan m_odtsTimeZoneAdjust;
    COleDateTime	 m_codtGuideStartTime, m_codtGuideEndTime;

	// Guide Store objects
	gsGuideStore       m_gsp;
	gsServices         m_pgsServices;
	gsChannelLineups   m_pgsChannelLineups;
	gsChannelLineup    m_pgsChannelLineup;
	gsChannels         m_pgsChannels;
	gsPrograms         m_pgsPrograms;
	gsScheduleEntries  m_pgsScheduleEntries;

	// Processors
    friend          class CDataFileProcessor;
    friend          class CStatChanRecordProcessor;
    friend          class CEpisodeTimeSlotRecordProcessor;
    friend          class CHeaderRecordProcessor;


	// Processors
    CDataFileProcessor              *m_DataFile;
    CStatChanRecordProcessor        *m_scrpStatChans; 
    CEpisodeTimeSlotRecordProcessor *m_etEpTs;
	CHeaderRecordProcessor          *m_srpHeaders;

	ULONG   InitProcessors(VOID);
    ULONG   OpenGuideStore(LPCTSTR lpGuideStoreDB);  
    ULONG   GetGuideStoreInterfaces(VOID);

	void    CloseProcessors(VOID);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWtmsloadApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CWtmsloadApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WTMSLOAD_H__3CFC191E_5236_4C05_8A37_A80C246BA6AC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\ambase.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for streams architecture, December 1994

//=====================================================================
//=====================================================================
// The following classes are declared in this header:
//
//
// CBaseMediaFilter            Basic IMediaFilter support (abstract class)
// CBaseFilter                 Support for IBaseFilter (incl. IMediaFilter)
// CEnumPins                   Enumerate input and output pins
// CEnumMediaTypes             Enumerate the preferred pin formats
// CBasePin                    Abstract base class for IPin interface
//    CBaseOutputPin           Adds data provider member functions
//    CBaseInputPin            Implements IMemInputPin interface
// CMediaSample                Basic transport unit for IMemInputPin
// CBaseAllocator<_F>              General list guff for most allocators
//    CMemAllocator            Implements memory buffer allocation
//
//=====================================================================
//=====================================================================

void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource)
{
    *pmtTarget = *pmtSource;
    if (pmtSource->cbFormat != 0) {
        _ASSERTE(pmtSource->pbFormat != NULL);
        pmtTarget->pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource->cbFormat);
        if (pmtTarget->pbFormat == NULL) {
            pmtTarget->cbFormat = 0;
        } else {
            CopyMemory((PVOID)pmtTarget->pbFormat, (PVOID)pmtSource->pbFormat,
                       pmtTarget->cbFormat);
        }
    }
    if (pmtTarget->pUnk != NULL) {
        pmtTarget->pUnk->AddRef();
    }
}

AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE *pSrc)
{
    _ASSERTE(pSrc);

    // Allocate a block of memory for the media type

    AM_MEDIA_TYPE *pMediaType =
        (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType == NULL) {
        return NULL;
    }
    // Copy the variable length format block

    CopyMediaType(pMediaType,pSrc);

    return pMediaType;
}

void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    FreeMediaType(*pmt);
    CoTaskMemFree((PVOID)pmt);
}


//  HACK to make sure the right functions get created for our
//  concrete objects
void MyCreateHackAllocator()
{
    new CComObject<CAMMemAllocator>;
    new CComAggObject<CAMMemAllocator>(NULL);
    new CAMMediaSample<CAMMemAllocator>;
}

#if 0
#define CONNECT_TRACE_LEVEL 3

//=====================================================================
//=====================================================================
// Implements CBaseMediaFilter
//=====================================================================
//=====================================================================


/* Constructor */

CBaseMediaFilter::CBaseMediaFilter(const TCHAR	*pName,
				   LPUNKNOWN	pUnk,
				   CCritSec	*pLock,
				   REFCLSID	clsid) :
    CUnknown(pName, pUnk),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL)
{
}


/* Destructor */

CBaseMediaFilter::~CBaseMediaFilter()
{
    // must be stopped, but can't call Stop here since
    // our critsec has been destroyed.

    /* Release any clock we were using */

    if (m_pClock) {
	m_pClock->Release();
	m_pClock = NULL;
    }
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CBaseMediaFilter::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    if (riid == IID_IMediaFilter) {
	    return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IPersist) {
	    return GetInterface((IPersist *) this, ppv);
    } else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

/* Return the filter's clsid */
STDMETHODIMP
CBaseMediaFilter::GetClassID(CLSID *pClsID)
{
    CheckPointer(pClsID,E_POINTER);
    ValidateReadWritePtr(pClsID,sizeof(CLSID));
    *pClsID = m_clsid;
    return NOERROR;
}

/* Override this if your state changes are not done synchronously */

STDMETHODIMP
CBaseMediaFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    return S_OK;
}


/* Set the clock we will use for synchronisation */

STDMETHODIMP
CBaseMediaFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock cObjectLock(m_pLock);

    // Ensure the new one does not go away - even if the same as the old
    if (pClock) {
	pClock->AddRef();
    }

    // if we have a clock, release it
    if (m_pClock) {
	m_pClock->Release();
    }

    // Set the new reference clock (might be NULL)
    // Should we query it to ensure it is a clock?  Consider for a debug build.
    m_pClock = pClock;

    return NOERROR;
}

/* Return the clock we are using for synchronisation */
STDMETHODIMP
CBaseMediaFilter::GetSyncSource(IReferenceClock **pClock)
{
    CheckPointer(pClock,E_POINTER);
    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pClock) {
	// returning an interface... addref it...
	m_pClock->AddRef();
    }
    *pClock = (IReferenceClock*)m_pClock;
    return NOERROR;
}


/* Put the filter into a stopped state */

STDMETHODIMP
CBaseMediaFilter::Stop()
{
    CAutoLock cObjectLock(m_pLock);

    m_State = State_Stopped;
    return S_OK;
}


/* Put the filter into a paused state */

STDMETHODIMP
CBaseMediaFilter::Pause()
{
    CAutoLock cObjectLock(m_pLock);

    m_State = State_Paused;
    return S_OK;
}


// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseMediaFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP
CBaseMediaFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);

    // remember the stream time offset
    m_tStart = tStart;

    if (m_State == State_Stopped){
	HRESULT hr = Pause();

	if (FAILED(hr)) {
	    return hr;
	}
    }
    m_State = State_Running;
    return S_OK;
}


//
// return the current stream time - samples with start timestamps of this
// time or before should be rendered by now
HRESULT
CBaseMediaFilter::StreamTime(CRefTime& rtStream)
{
    // Caller must lock for synchronization
    // We can't grab the filter lock because we want to be able to call
    // this from worker threads without deadlocking

    if (m_pClock == NULL) {
	return VFW_E_NO_CLOCK;
    }

    // get the current reference time
    HRESULT hr = m_pClock->GetTime((REFERENCE_TIME*)&rtStream);
    if (FAILED(hr)) {
	return hr;
    }

    // subtract the stream offset to get stream time
    rtStream -= m_tStart;

    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CBaseFilter
//=====================================================================
//=====================================================================


/* Override this to say what interfaces we support and where */

STDMETHODIMP CBaseFilter::NonDelegatingQueryInterface(REFIID riid,
                                                      void **ppv)
{
    /* Do we have this interface */

    if (riid == IID_IBaseFilter) {
	    return GetInterface((IBaseFilter *) this, ppv);
    } else if (riid == IID_IMediaFilter) {
	    return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IPersist) {
	    return GetInterface((IPersist *) this, ppv);
    } else if (riid == IID_IAMovieSetup) {
	    return GetInterface((IAMovieSetup *) this, ppv);
    } else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* Constructor */

CBaseFilter::CBaseFilter(const TCHAR	*pName,
			 LPUNKNOWN	pUnk,
			 CCritSec	*pLock,
			 REFCLSID	clsid) :
    CUnknown( pName, pUnk ),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL),
    m_pGraph(NULL),
    m_pSink(NULL),
    m_pName(NULL),
    m_PinVersion(1)
{
    _ASSERTE(pLock != NULL);
}

/* Passes in a redundant HRESULT argument */

CBaseFilter::CBaseFilter(TCHAR     *pName,
                         LPUNKNOWN  pUnk,
                         CCritSec  *pLock,
                         REFCLSID   clsid,
                         HRESULT   *phr) :
    CUnknown( pName, pUnk ),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL),
    m_pGraph(NULL),
    m_pSink(NULL),
    m_pName(NULL),
    m_PinVersion(1)
{
    _ASSERTE(pLock != NULL);
    UNREFERENCED_PARAMETER(phr);
}


/* Destructor */

CBaseFilter::~CBaseFilter()
{
// NOTE we do NOT hold references on the filtergraph for m_pGraph or m_pSink
// When we did we had the circular reference problem.  Nothing would go away.

    if (m_pName)
	delete[] m_pName;

    // must be stopped, but can't call Stop here since
    // our critsec has been destroyed.

    /* Release any clock we were using */
    if (m_pClock) {
	m_pClock->Release();
	m_pClock = NULL;
    }
}

/* Return the filter's clsid */
STDMETHODIMP
CBaseFilter::GetClassID(CLSID *pClsID)
{
    CheckPointer(pClsID,E_POINTER);
    ValidateReadWritePtr(pClsID,sizeof(CLSID));
    *pClsID = m_clsid;
    return NOERROR;
}

/* Override this if your state changes are not done synchronously */
STDMETHODIMP
CBaseFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    return S_OK;
}


/* Set the clock we will use for synchronisation */

STDMETHODIMP
CBaseFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock cObjectLock(m_pLock);

    // Ensure the new one does not go away - even if the same as the old
    if (pClock) {
	pClock->AddRef();
    }

    // if we have a clock, release it
    if (m_pClock) {
	m_pClock->Release();
    }

    // Set the new reference clock (might be NULL)
    // Should we query it to ensure it is a clock?  Consider for a debug build.
    m_pClock = pClock;

    return NOERROR;
}

/* Return the clock we are using for synchronisation */
STDMETHODIMP
CBaseFilter::GetSyncSource(IReferenceClock **pClock)
{
    CheckPointer(pClock,E_POINTER);
    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pClock) {
	// returning an interface... addref it...
	m_pClock->AddRef();
    }
    *pClock = (IReferenceClock*)m_pClock;
    return NOERROR;
}



// override CBaseMediaFilter Stop method, to deactivate any pins this
// filter has.
STDMETHODIMP
CBaseFilter::Stop()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = NOERROR;

    // notify all pins of the state change
    if (m_State != State_Stopped) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins worrying
            // about this state themselves. We ignore the return code to make
            // sure everyone is inactivated regardless. The base input pin
            // class can return an error if it has no allocator but Stop can
            // be used to resync the graph state after something has gone bad

            if (pPin->IsConnected()) {
                HRESULT hrTmp = pPin->Inactive();
                if (FAILED(hrTmp) && SUCCEEDED(hr)) {
                    hr = hrTmp;
                }
            }
	}
    }
    m_State = State_Stopped;
    return hr;
}


// override CBaseMediaFilter Pause method to activate any pins
// this filter has (also called from Run)

STDMETHODIMP
CBaseFilter::Pause()
{
    CAutoLock cObjectLock(m_pLock);

    // notify all pins of the change to active state
    if (m_State == State_Stopped) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Active();
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }
    m_State = State_Paused;
    return S_OK;
}

// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP
CBaseFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);

    // remember the stream time offset
    m_tStart = tStart;

    if (m_State == State_Stopped){
	HRESULT hr = Pause();

	if (FAILED(hr)) {
	    return hr;
	}
    }
    // notify all pins of the change to active state
    if (m_State != State_Running) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Run(tStart);
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }
    m_State = State_Running;
    return S_OK;
}

//
// return the current stream time - samples with start timestamps of this
// time or before should be rendered by now
HRESULT
CBaseFilter::StreamTime(CRefTime& rtStream)
{
    // Caller must lock for synchronization
    // We can't grab the filter lock because we want to be able to call
    // this from worker threads without deadlocking

    if (m_pClock == NULL) {
	return VFW_E_NO_CLOCK;
    }

    // get the current reference time
    HRESULT hr = m_pClock->GetTime((REFERENCE_TIME*)&rtStream);
    if (FAILED(hr)) {
	return hr;
    }

    // subtract the stream offset to get stream time
    rtStream -= m_tStart;

    return S_OK;
}


/* Create an enumerator for the pins attached to this filter */

STDMETHODIMP
CBaseFilter::EnumPins(IEnumPins **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *));

    /* Create a new ref counted enumerator */

    *ppEnum = new CEnumPins(this,
	                    NULL);

    return *ppEnum == NULL ? E_OUTOFMEMORY : NOERROR;
}


// default behaviour of FindPin is to assume pins are named
// by their pin names
STDMETHODIMP
CBaseFilter::FindPin(
    LPCWSTR Id,
    IPin ** ppPin
)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));

    //  We're going to search the pin list so maintain integrity
    CAutoLock lck(m_pLock);
    int iCount = GetPinCount();
    for (int i = 0; i < iCount; i++) {
        CBasePin *pPin = GetPin(i);
        _ASSERTE(pPin != NULL);

        if (0 == lstrcmpW(pPin->Name(), Id)) {
            //  Found one that matches
            //
            //  AddRef() and return it
            *ppPin = pPin;
            pPin->AddRef();
            return S_OK;
        }
    }
    *ppPin = NULL;
    return VFW_E_NOT_FOUND;
}

/* Return information about this filter */

STDMETHODIMP
CBaseFilter::QueryFilterInfo(FILTER_INFO * pInfo)
{
    CheckPointer(pInfo,E_POINTER);
    ValidateReadWritePtr(pInfo,sizeof(FILTER_INFO));

    if (m_pName) {
    	lstrcpynW(pInfo->achName, m_pName, sizeof(pInfo->achName)/sizeof(WCHAR));
    } else {
	pInfo->achName[0] = L'\0';
    }
    pInfo->pGraph = m_pGraph;
    if (m_pGraph)
	m_pGraph->AddRef();
    return NOERROR;
}


/* Provide the filter with a filter graph */

STDMETHODIMP
CBaseFilter::JoinFilterGraph(
    IFilterGraph * pGraph,
    LPCWSTR pName)
{
    CAutoLock cObjectLock(m_pLock);

    // NOTE: we no longer hold references on the graph (m_pGraph, m_pSink)

    m_pGraph = pGraph;
    if (m_pGraph) {
	HRESULT hr = m_pGraph->QueryInterface(IID_IMediaEventSink,
					(void**) &m_pSink);
	if (FAILED(hr)) {
	    _ASSERTE(m_pSink == NULL);
	}
        else m_pSink->Release();        // we do NOT keep a reference on it.
    } else {
        // if graph pointer is null, then we should
        // also release the IMediaEventSink on the same object - we don't
        // refcount it, so just set it to null
        m_pSink = NULL;
    }


    if (m_pName) {
        delete[] m_pName;
	m_pName = NULL;
    }

    if (pName) {
	DWORD nameLen = lstrlenW(pName)+1;
	m_pName = new WCHAR[nameLen];
	if (m_pName) {
	    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
	} else {
	    // !!! error here?
	}
    }
    return NOERROR;
}


// return a Vendor information string. Optional - may return E_NOTIMPL.
// memory returned should be freed using CoTaskMemFree
// default implementation returns E_NOTIMPL
STDMETHODIMP
CBaseFilter::QueryVendorInfo(
    LPWSTR* pVendorInfo)
{
    UNREFERENCED_PARAMETER(pVendorInfo);
    return E_NOTIMPL;
}


// send an event notification to the filter graph if we know about it.
// returns S_OK if delivered, S_FALSE if the filter graph does not sink
// events, or an error otherwise.
HRESULT
CBaseFilter::NotifyEvent(
    long EventCode,
    long EventParam1,
    long EventParam2)
{
    // Snapshot so we don't have to lock up
    IMediaEventSink *pSink = m_pSink;
    if (pSink) {
	return pSink->Notify(EventCode, EventParam1, EventParam2);
    } else {
	return E_NOTIMPL;
    }
}




/* This is the same idea as the media type version does for type enumeration
   on pins but for the list of pins available. So if the list of pins you
   provide changes dynamically then either override this virtual function
   to provide the version number, or more simply call IncrementPinVersion */

LONG CBaseFilter::GetPinVersion()
{
    return m_PinVersion;
}


/* Increment the current pin version cookie */

void CBaseFilter::IncrementPinVersion()
{
    InterlockedIncrement(&m_PinVersion);
}

/* register filter */

HRESULT CBaseFilter::Register()
{
    // get setup data, if it exists
    //
    LPAMOVIESETUP_FILTER psetupdata = GetSetupData();

    // check we've got data
    //
    if( NULL == psetupdata ) return S_FALSE;

    // init is ref counted so call just in case
    // we're being called cold.
    //
    HRESULT hr = CoInitialize( (LPVOID)NULL );
    _ASSERTE( SUCCEEDED(hr) );

    // get hold of IFilterMapper
    //
    IFilterMapper *pIFM;
    hr = CoCreateInstance( CLSID_FilterMapper
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IFilterMapper
                             , (void **)&pIFM       );
    if( SUCCEEDED(hr) )
    {
      // register filter
      //
      hr = pIFM->RegisterFilter( *(psetupdata->clsID)
                               , psetupdata->strName
                               , psetupdata->dwMerit    );
      if( SUCCEEDED(hr) )
      {
        // all its pins
        //
        for( UINT m1=0; m1 < psetupdata->nPins; m1++ )
        {
          hr = pIFM->RegisterPin( *(psetupdata->clsID)
                                , psetupdata->lpPin[m1].strName
                                , psetupdata->lpPin[m1].bRendered
                                , psetupdata->lpPin[m1].bOutput
                                , psetupdata->lpPin[m1].bZero
                                , psetupdata->lpPin[m1].bMany
                                , *(psetupdata->lpPin[m1].clsConnectsToFilter)
                                , psetupdata->lpPin[m1].strConnectsToPin );

          if( SUCCEEDED(hr) )
          {
            // and each pin's media types
            //
            for( UINT m2=0; m2 < psetupdata->lpPin[m1].nMediaTypes; m2++ )
            {
              hr = pIFM->RegisterPinType( *(psetupdata->clsID)
                                        , psetupdata->lpPin[m1].strName
                                        , *(psetupdata->lpPin[m1].lpMediaType[m2].clsMajorType)
                                        , *(psetupdata->lpPin[m1].lpMediaType[m2].clsMinorType) );
              if( FAILED(hr) ) break;
            }
            if( FAILED(hr) ) break;
          }
          if( FAILED(hr) ) break;
        }
      }

      // free server
      //
      pIFM->Release();
    }

    // and clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();

    return NOERROR;
}


/* unregister filter */

HRESULT CBaseFilter::Unregister()
{
    // get setup data, if it exists
    //
    LPAMOVIESETUP_FILTER psetupdata = GetSetupData();

    // check we've got data
    //
    if( NULL == psetupdata ) return S_FALSE;

    // OLE init is ref counted so call
    // just in case we're being called cold.
    //
    HRESULT hr = CoInitialize( (LPVOID)NULL );
    _ASSERTE( SUCCEEDED(hr) );

    // get hold of IFilterMapper
    //
    IFilterMapper *pIFM;
    hr = CoCreateInstance( CLSID_FilterMapper
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IFilterMapper
                             , (void **)&pIFM       );
    if( SUCCEEDED(hr) )
    {
      // unregister filter
      // (as pins are subkeys of filter's CLSID key
      // they do not need to be removed separately).
      //
      hr = pIFM->UnregisterFilter( *(psetupdata->clsID) );

      // release interface
      //
      pIFM->Release();
    }

    // clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();

    // handle one acceptable "error" - that
    // of filter not being registered!
    // (couldn't find a suitable #define'd
    // name for the error!)
    //
    if( 0x80070002 == hr)
      return NOERROR;
    else
      return hr;
}


//=====================================================================
//=====================================================================
// Implements CEnumPins
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor
   with a NULL unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

CEnumPins::CEnumPins(CBaseFilter *pFilter,
		     CEnumPins *pEnumPins) :
    m_Position(0),
    m_PinCount(0),
    m_pFilter(pFilter),
    m_cRef(1)               // Already ref counted
{

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumPins"));
#endif

    /* We must be owned by a filter derived from CBaseFilter */

    _ASSERTE(pFilter != NULL);

    /* Hold a reference count on our filter */
    m_pFilter->AddRef();

    /* Are we creating a new enumerator */

    if (pEnumPins == NULL) {
	m_Version = m_pFilter->GetPinVersion();
	m_PinCount = m_pFilter->GetPinCount();
    } else {
        _ASSERTE(m_Position <= m_PinCount);
        m_Position = pEnumPins->m_Position;
        m_PinCount = pEnumPins->m_PinCount;
        m_Version = pEnumPins->m_Version;
    }
}


/* Destructor releases the reference count on our filter NOTE since we hold
   a reference count on the filter who created us we know it is safe to
   release it, no access can be made to it afterwards though as we have just
   caused the last reference count to go and the object to be deleted */

CEnumPins::~CEnumPins()
{
    m_pFilter->Release();
#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
}


/* Override this to say what interfaces we support where */

STDMETHODIMP
CEnumPins::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv, E_POINTER);

    /* Do we have this interface */

    if (riid == IID_IEnumPins || riid == IID_IUnknown) {
	return GetInterface((IEnumPins *) this, ppv);
    } else {
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CEnumPins::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEnumPins::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0) {
        delete this;
    }
    return cRef;
}

/* One of an enumerator's basic member functions allows us to create a cloned
   interface that initially has the same state. Since we are taking a snapshot
   of an object (current position and all) we must lock access at the start */

STDMETHODIMP
CEnumPins::Clone(IEnumPins **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *));
    HRESULT hr = NOERROR;

    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
        *ppEnum = NULL;
        hr =  VFW_E_ENUM_OUT_OF_SYNC;
    } else {

        *ppEnum = new CEnumPins(m_pFilter,
    	                        this);
        if (*ppEnum == NULL) {
    	    hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


/* Return the next pin after the current position */

STDMETHODIMP
CEnumPins::Next(ULONG cPins,        // place this many pins...
		IPin **ppPins,      // ...in this array
		ULONG *pcFetched)   // actual count passed returned here
{
    CheckPointer(ppPins,E_POINTER);
    ValidateReadWritePtr(ppPins,cPins * sizeof(IPin *));

    _ASSERTE(ppPins);

    if (pcFetched!=NULL) {
        ValidateWritePtr(pcFetched, sizeof(ULONG));
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cPins>1) {	  // pcFetched == NULL
        return E_INVALIDARG;
    }
    ULONG cFetched = 0;           // increment as we get each one.

    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    /* Calculate the number of available pins */

    int cRealPins = min(m_PinCount - m_Position, (int) cPins);
    if (cRealPins == 0) {
	return S_FALSE;
    }

    /* Return each pin interface NOTE GetPin returns CBasePin * not addrefed
       so we must QI for the IPin (which increments its reference count)
       If while we are retrieving a pin from the filter an error occurs we
       assume that our internal state is stale with respect to the filter
       (for example someone has deleted a pin) so we
       return VFW_E_ENUM_OUT_OF_SYNC                            */

    while (cRealPins--) {

	/* Get the next pin object from the filter */

	CBasePin *pPin = m_pFilter->GetPin(m_Position++);
	if (pPin == NULL) {
            // If this happend, and it's not the first time through, then we've got a problem,
            // since we should really go back and release the iPins, which we have previously
            // AddRef'ed.
            _ASSERTE( cFetched==0 );
            return VFW_E_ENUM_OUT_OF_SYNC;
	}

	/* From the object get an IPin interface */

        *ppPins = pPin;
        pPin->AddRef();

	cFetched++;
	ppPins++;
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return (cPins==cFetched ? NOERROR : S_FALSE);
}


/* Skip over one or more entries in the enumerator */

STDMETHODIMP
CEnumPins::Skip(ULONG cPins)
{
    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    /* Work out how many pins are left to skip over */
    /* We could position at the end if we are asked to skip too many... */
    /* ..which would match the base implementation for CEnumMediaTypes::Skip */

    ULONG PinsLeft = m_PinCount - m_Position;
    if (cPins > PinsLeft) {
	return S_FALSE;
    }
    m_Position += cPins;
    return NOERROR;
}


/* Set the current position back to the start */
/* Reset has 3 simple steps:
 *
 * Set position to head of list
 * Sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP
CEnumPins::Reset()
{
    m_Version = m_pFilter->GetPinVersion();

    m_Position = 0;
    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CEnumMediaTypes
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor
   with a NULL unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

CEnumMediaTypes::CEnumMediaTypes(CBasePin *pPin,
				 CEnumMediaTypes *pEnumMediaTypes) :
    m_Position(0),
    m_pPin(pPin),
    m_cRef(1)
{

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumMediaTypes"));
#endif

    /* We must be owned by a pin derived from CBasePin */

    _ASSERTE(pPin != NULL);

    /* Hold a reference count on our pin */
    m_pPin->AddRef();

    /* Are we creating a new enumerator */

    if (pEnumMediaTypes == NULL) {
	m_Version = m_pPin->GetMediaTypeVersion();
	return;
    }

    m_Position = pEnumMediaTypes->m_Position;
    m_Version = pEnumMediaTypes->m_Version;
}


/* Destructor releases the reference count on our base pin. NOTE since we hold
   a reference count on the pin who created us we know it is safe to release
   it, no access can be made to it afterwards though as we might have just
   caused the last reference count to go and the object to be deleted */

CEnumMediaTypes::~CEnumMediaTypes()
{
#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
    m_pPin->Release();
}


/* Override this to say what interfaces we support where */

STDMETHODIMP
CEnumMediaTypes::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv, E_POINTER);

    /* Do we have this interface */

    if (riid == IID_IEnumMediaTypes || riid == IID_IUnknown) {
	return GetInterface((IEnumMediaTypes *) this, ppv);
    } else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CEnumMediaTypes::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEnumMediaTypes::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0) {
        delete this;
    }
    return cRef;
}

/* One of an enumerator's basic member functions allows us to create a cloned
   interface that initially has the same state. Since we are taking a snapshot
   of an object (current position and all) we must lock access at the start */

STDMETHODIMP
CEnumMediaTypes::Clone(IEnumMediaTypes **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *));
    HRESULT hr = NOERROR;

    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        *ppEnum = NULL;
        hr = VFW_E_ENUM_OUT_OF_SYNC;
    } else {

        *ppEnum = new CEnumMediaTypes(m_pPin,
    	                              this);

        if (*ppEnum == NULL) {
    	    hr =  E_OUTOFMEMORY;
        }
    }
    return hr;
}


/* Enumerate the next pin(s) after the current position. The client using this
   interface passes in a pointer to an array of pointers each of which will
   be filled in with a pointer to a fully initialised media type format
   Return NOERROR if it all works,
          S_FALSE if fewer than cMediaTypes were enumerated.
          VFW_E_ENUM_OUT_OF_SYNC if the enumerator has been broken by
                                 state changes in the filter
   The actual count always correctly reflects the number of types in the array.
*/

STDMETHODIMP
CEnumMediaTypes::Next(ULONG cMediaTypes,          // place this many types...
		      AM_MEDIA_TYPE **ppMediaTypes,   // ...in this array
		      ULONG *pcFetched)           // actual count passed
{
    CheckPointer(ppMediaTypes,E_POINTER);
    ValidateReadWritePtr(ppMediaTypes,cMediaTypes * sizeof(AM_MEDIA_TYPE *));
    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    if (pcFetched!=NULL) {
        ValidateWritePtr(pcFetched, sizeof(ULONG));
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cMediaTypes>1) {	  // pcFetched == NULL
        return E_INVALIDARG;
    }
    ULONG cFetched = 0;           // increment as we get each one.

    /* Return each media type by asking the filter for them in turn - If we
       have an error code retured to us while we are retrieving a media type
       we assume that our internal state is stale with respect to the filter
       (for example the window size changing) so we return
       VFW_E_ENUM_OUT_OF_SYNC */

    while (cMediaTypes) {

    	CMediaType cmt;

	HRESULT hr = m_pPin->GetMediaType(m_Position++, &cmt);
        if (S_OK != hr) {
            break;
        }

    	/* We now have a CMediaType object that contains the next media type
    	   but when we assign it to the array position we CANNOT just assign
    	   the AM_MEDIA_TYPE structure because as soon as the object goes out of
    	   scope it will delete the memory we have just copied. The function
    	   we use is CreateMediaType which allocates a task memory block */

        /*  Transfer across the format block manually to save an allocate
            and free on the format block and generally go faster */

    	*ppMediaTypes = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    	if (*ppMediaTypes == NULL) {
            break;
    	}

        /*  Do a regular copy */
        **ppMediaTypes = (AM_MEDIA_TYPE)cmt;

        /*  Make sure the destructor doesn't free these */
        cmt.pbFormat = NULL;
        cmt.cbFormat = NULL;
        cmt.pUnk     = NULL;


    	ppMediaTypes++;
    	cFetched++;
    	cMediaTypes--;
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return ( cMediaTypes==0 ? NOERROR : S_FALSE );
}


/* Skip over one or more entries in the enumerator */

STDMETHODIMP
CEnumMediaTypes::Skip(ULONG cMediaTypes)
{
    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    m_Position += cMediaTypes;

    /*  See if we're over the end */
    CMediaType cmt;
    return S_OK == m_pPin->GetMediaType(m_Position - 1, &cmt) ? S_OK : S_FALSE;
}


/* Set the current position back to the start */
/* Reset has 3 simple steps:
 *
 * set position to head of list
 * sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP
CEnumMediaTypes::Reset()
{
    m_Position = 0;

    // Bring the enumerator back into step with the current state.  This
    // may be a noop but ensures that the enumerator will be valid on the
    // next call.
    m_Version = m_pPin->GetMediaTypeVersion();
    return NOERROR;
}


//=====================================================================
//=====================================================================
// Implements CBasePin
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor with
   a NULL outer unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants its lifetime controlled by the external object */

/* Constructor */

CBasePin::CBasePin(TCHAR *pObjectName,
		   CBaseFilter *pFilter,
		   CCritSec *pLock,
		   HRESULT *phr,
		   LPCWSTR pName,
		   PIN_DIRECTION dir) :
    CUnknown( pObjectName, NULL ),
    m_pFilter(pFilter),
    m_pLock(pLock),
    m_pName(NULL),
    m_Connected(NULL),
    m_dir(dir),
    m_bRunTimeError(FALSE),
    m_pQSink(NULL),
    m_TypeVersion(1),
    m_tStart(),
    m_tStop(MAX_TIME),
    m_dRate(1.0)
{
    /*  WARNING - pFilter is often not a properly constituted object at
        this state (in particular QueryInterface may not work) - this
        is because its owner is often its containing object and we
        have been called from the containing object's constructor so
        the filter's owner has not yet had its CUnknown constructor
        called
    */
    _ASSERTE(pFilter != NULL);
    _ASSERTE(pLock != NULL);

    if (pName) {
	DWORD nameLen = lstrlenW(pName)+1;
	m_pName = new WCHAR[nameLen];
	if (m_pName) {
	    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
	}
    }

#ifdef DEBUG
    m_cRef = 0;
#endif
}


/* Destructor since a connected pin holds a reference count on us there is
   no way that we can be deleted unless we are not currently connected */

CBasePin::~CBasePin()
{
    //  We don't call disconnect because if the filter is going away
    //  all the pins must have a reference count of zero so they must
    //  have been disconnected anyway - (but check the assumption)
    _ASSERTE(m_Connected == FALSE);

    if (m_pName)
	delete[] m_pName;

    // check the internal reference count is consistent
    _ASSERTE(m_cRef == 0);
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CBasePin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    /* Do we have this interface */

    if (riid == IID_IPin) {
	return GetInterface((IPin *) this, ppv);
    } else if (riid == IID_IQualityControl) {
        return GetInterface((IQualityControl *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* Override to increment the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBasePin::NonDelegatingAddRef()
{
    _ASSERTE(InterlockedIncrement(&m_cRef) > 0);
    return m_pFilter->AddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBasePin::NonDelegatingRelease()
{
    _ASSERTE(InterlockedDecrement(&m_cRef) >= 0);
    return m_pFilter->Release();
}


/* Displays pin connection information */

#ifdef DEBUG
void
CBasePin::DisplayPinInfo(IPin *pReceivePin)
{

    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) {
	PIN_INFO ConnectPinInfo;
	PIN_INFO ReceivePinInfo;

	if (FAILED(QueryPinInfo(&ConnectPinInfo))) {
	    lstrcpyW(ConnectPinInfo.achName, L"Bad Pin");
	} else {
	    QueryPinInfoReleaseFilter(ConnectPinInfo);
	}

	if (FAILED(pReceivePin->QueryPinInfo(&ReceivePinInfo))) {
	    lstrcpyW(ReceivePinInfo.achName, L"Bad Pin");
	} else {
	    QueryPinInfoReleaseFilter(ReceivePinInfo);
	}

	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying to connect Pins :")));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    <%ls>"), ConnectPinInfo.achName));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    <%ls>"), ReceivePinInfo.achName));
    }
}
#endif


/* Displays general information on the pin media type */

#ifdef DEBUG
void CBasePin::DisplayTypeInfo(IPin *pPin, const CMediaType *pmt)
{
    UNREFERENCED_PARAMETER(pPin);
    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying media type:")));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    major type:  %s"),
	       GuidNames[*pmt->Type()]));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    sub type  :  %s"),
	       GuidNames[*pmt->Subtype()]));
    }
}
#endif

/* Asked to connect to a pin. A pin is always attached to an owning filter
   object so we always delegate our locking to that object. We first of all
   retrieve a media type enumerator for the input pin and see if we accept
   any of the formats that it would ideally like, failing that we retrieve
   our enumerator and see if it will accept any of our preferred types */

STDMETHODIMP
CBasePin::Connect(
    IPin * pReceivePin,
    const AM_MEDIA_TYPE *pmt   // optional media type
)
{
    CheckPointer(pReceivePin,E_POINTER);
    ValidateReadPtr(pReceivePin,sizeof(IPin));
    CAutoLock cObjectLock(m_pLock);
    DisplayPinInfo(pReceivePin);

    /* See if we are already connected */

    if (m_Connected) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Already connected")));
	return VFW_E_ALREADY_CONNECTED;
    }

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }


    // Find a mutually agreeable media type -
    // Pass in the template media type. If this is partially specified,
    // each of the enumerated media types will need to be checked against
    // it. If it is non-null and fully specified, we will just try to connect
    // with this.

    const CMediaType * ptype = (CMediaType*)pmt;
    HRESULT hr = AgreeMediaType(pReceivePin, ptype);
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to agree type")));
	BreakConnect();
	return hr;
    }

    DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Connection succeeded")));
    return NOERROR;
}

// given a specific media type, attempt a connection (includes
// checking that the type is acceptable to this pin)
HRESULT
CBasePin::AttemptConnection(
    IPin* pReceivePin,      // connect to this pin
    const CMediaType* pmt   // using this type
)
{
    // Check that the connection is valid  -- need to do this for every
    // connect attempt since BreakConnect will undo it.
    HRESULT hr = CheckConnect(pReceivePin);
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("CheckConnect failed")));
	BreakConnect();
	return hr;
    }

    DisplayTypeInfo(pReceivePin, pmt);

    /* Check we will accept this media type */

    hr = CheckMediaType(pmt);
    if (hr == NOERROR) {

        /*  Make ourselves look connected otherwise ReceiveConnection
            may not be able to complete the connection
        */
        m_Connected = pReceivePin;
        m_Connected->AddRef();
        SetMediaType(pmt);

        /* See if the other pin will accept this type */

        hr = pReceivePin->ReceiveConnection((IPin *)this, pmt);
        if (SUCCEEDED(hr)) {
            /* Complete the connection */

            hr = CompleteConnect(pReceivePin);
            if (SUCCEEDED(hr)) {
                return hr;
            } else {
                DbgLog((LOG_TRACE,
                        CONNECT_TRACE_LEVEL,
                        TEXT("Failed to complete connection")));
                pReceivePin->Disconnect();
            }
        }
    } else {
	// we cannot use this media type

	// return a specific media type error if there is one
	// or map a general failure code to something more helpful
	// (in particular S_FALSE gets changed to an error code)
	if (SUCCEEDED(hr) ||
	    (hr == E_FAIL) ||
	    (hr == E_INVALIDARG)) {
		hr = VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    // BreakConnect and release any connection here in case CheckMediaType
    // failed, or if we set anything up during a call back during
    // ReceiveConnection.
    BreakConnect();

    /*  If failed then undo our state */
    if (m_Connected) {
        m_Connected->Release();
        m_Connected = NULL;
    }

    return hr;
}

/* Given an enumerator we cycle through all the media types it proposes and
   firstly suggest them to our derived pin class and if that succeeds try
   them with the pin in a ReceiveConnection call. This means that if our pin
   proposes a media type we still check in here that we can support it. This
   is deliberate so that in simple cases the enumerator can hold all of the
   media types even if some of them are not really currently available */

HRESULT CBasePin::TryMediaTypes(
    IPin *pReceivePin,
    const CMediaType *pmt,
    IEnumMediaTypes *pEnum)
{
    /* Reset the current enumerator position */

    HRESULT hr = pEnum->Reset();
    if (FAILED(hr)) {
	return hr;
    }

    CMediaType *pMediaType = NULL;
    ULONG ulMediaCount = 0;

    // attempt to remember a specific error code if there is one
    HRESULT hrFailure = S_OK;

    for (;;) {

	/* Retrieve the next media type NOTE each time round the loop the
	   enumerator interface will allocate another AM_MEDIA_TYPE structure
	   If we are successful then we copy it into our output object, if
	   not then we must delete the memory allocated before returning */

	hr = pEnum->Next(1, (AM_MEDIA_TYPE**)&pMediaType,&ulMediaCount);
	if (hr != S_OK) {
	    if (S_OK == hrFailure) {
		hrFailure = VFW_E_NO_ACCEPTABLE_TYPES;
	    }
	    return hrFailure;
	}


	_ASSERTE(ulMediaCount == 1);
	_ASSERTE(pMediaType);

        // check that this matches the partial type (if any)

        if ((pmt == NULL) ||
            pMediaType->MatchesPartial(pmt)) {

            hr = AttemptConnection(pReceivePin, pMediaType);

	    // attempt to remember a specific error code
	    if (FAILED(hr) &&
		SUCCEEDED(hrFailure) &&
		(hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
        } else {
            hr = VFW_E_NO_ACCEPTABLE_TYPES;
        }

        DeleteMediaType(pMediaType);

        if (S_OK == hr) {
            return hr;
        }
    }
}


/* This is called to make the connection, including the taask of finding
   a media type for the pin connection. pmt is the proposed media type
   from the Connect call: if this is fully specified, we will try that.
   Otherwise we enumerate and try all the input pin's types first and
   if that fails we then enumerate and try all our preferred media types.
   For each media type we check it against pmt (if non-null and partially
   specified) as well as checking that both pins will accept it.
 */

HRESULT CBasePin::AgreeMediaType(
    IPin *pReceivePin,
    const CMediaType *pmt)
{
    _ASSERTE(pReceivePin);
    IEnumMediaTypes *pEnumMediaTypes = NULL;

    // if the media type is fully specified then use that
    if ( (pmt != NULL) && (!pmt->IsPartiallySpecified())) {

        // if this media type fails, then we must fail the connection
        // since if pmt is nonnull we are only allowed to connect
        // using a type that matches it.

        return AttemptConnection(pReceivePin, pmt);
    }


    /* Try the other pin's enumerator */

    HRESULT hrFailure = VFW_E_NO_ACCEPTABLE_TYPES;

    HRESULT hr = pReceivePin->EnumMediaTypes(&pEnumMediaTypes);
    if (SUCCEEDED(hr)) {
	_ASSERTE(pEnumMediaTypes);
	hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes);
	pEnumMediaTypes->Release();
	if (SUCCEEDED(hr)) {
	    return NOERROR;
	} else {
	    // try to remember specific error codes if there are any
	    if ((hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
	}
    }

    /* Having failed with that try our enumerator */

    hr = EnumMediaTypes(&pEnumMediaTypes);
    if (SUCCEEDED(hr)) {
	_ASSERTE(pEnumMediaTypes);
	hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes);
	pEnumMediaTypes->Release();
	if (SUCCEEDED(hr)) {
	    return NOERROR;
	} else {
	    // try to remember specific error codes if there are any
	    if ((hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
	}
    }
    return hrFailure;
}


/* Called when we want to complete a connection to another filter. Failing
   this will also fail the connection and disconnect the other pin as well */

HRESULT
CBasePin::CompleteConnect(IPin *pReceivePin)
{
    UNREFERENCED_PARAMETER(pReceivePin);
    return NOERROR;
}


/* This is called to set the format for a pin connection - CheckMediaType
   will have been called to check the connection format and if it didn't
   return an error code then this (virtual) function will be invoked */

HRESULT
CBasePin::SetMediaType(const CMediaType *pmt)
{
    m_mt = *pmt;
    return NOERROR;
}


/* This is called during Connect() to provide a virtual method that can do
   any specific check needed for connection such as QueryInterface. This
   base class method just checks that the pin directions don't match */

HRESULT
CBasePin::CheckConnect(IPin * pPin)
{
    /* Check that pin directions DONT match */

    PIN_DIRECTION pd;
    pPin->QueryDirection(&pd);

    _ASSERTE((pd == PINDIR_OUTPUT) || (pd == PINDIR_INPUT));
    _ASSERTE((m_dir == PINDIR_OUTPUT) || (m_dir == PINDIR_INPUT));

    // we should allow for non-input and non-output connections?
    if (pd == m_dir) {
	return VFW_E_INVALID_DIRECTION;
    }
    return NOERROR;
}


/* This is called when we realise we can't make a connection to the pin and
   must undo anything we did in CheckConnect - override to release QIs done */

HRESULT
CBasePin::BreakConnect()
{
    return NOERROR;
}


/* Called normally by an output pin on an input pin to try and establish a
   connection.
*/

STDMETHODIMP
CBasePin::ReceiveConnection(
    IPin * pConnector,      // this is the pin who we will connect to
    const AM_MEDIA_TYPE *pmt    // this is the media type we will exchange
)
{
    CheckPointer(pConnector,E_POINTER);
    CheckPointer(pmt,E_POINTER);
    ValidateReadPtr(pConnector,sizeof(IPin));
    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cObjectLock(m_pLock);

    /* Are we already connected */
    if (m_Connected) {
	return VFW_E_ALREADY_CONNECTED;
    }

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }

    HRESULT hr = CheckConnect(pConnector);
    if (FAILED(hr)) {
	BreakConnect();
	return hr;
    }

    /* Ask derived class if this media type is ok */

    CMediaType * pcmt = (CMediaType*) pmt;
    hr = CheckMediaType(pcmt);
    if (hr != NOERROR) {
	// no -we don't support this media type
	BreakConnect();

	// return a specific media type error if there is one
	// or map a general failure code to something more helpful
	// (in particular S_FALSE gets changed to an error code)
	if (SUCCEEDED(hr) ||
	    (hr == E_FAIL) ||
	    (hr == E_INVALIDARG)) {
		hr = VFW_E_TYPE_NOT_ACCEPTED;
	}
	return hr;
    }

    /* Complete the connection */

    m_Connected = pConnector;
    m_Connected->AddRef();
    SetMediaType(pcmt);

    hr = CompleteConnect(pConnector);
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to complete connection")));
        m_Connected->Release();
        m_Connected = NULL;
        BreakConnect();
        return hr;
    }
    return NOERROR;
}


/* Called when we want to terminate a pin connection */

STDMETHODIMP
CBasePin::Disconnect()
{
    CAutoLock cObjectLock(m_pLock);

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }		

    if (m_Connected) {
	BreakConnect();
	m_Connected->Release();
	m_Connected = NULL;
	return S_OK;
    } else {
	// no connection - not an error
	return S_FALSE;
    }
}


/* Return an AddRef()'d pointer to the connected pin if there is one */
STDMETHODIMP
CBasePin::ConnectedTo(
    IPin **ppPin
)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));
    //
    //  It's pointless to lock here.
    //  The caller should ensure integrity.
    //

    IPin *pPin = m_Connected;
    *ppPin = pPin;
    if (pPin != NULL) {
        pPin->AddRef();
        return S_OK;
    } else {
        _ASSERTE(*ppPin == NULL);
        return VFW_E_NOT_CONNECTED;
    }
}

/* Return the media type of the connection */
STDMETHODIMP
CBasePin::ConnectionMediaType(
    AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(pmt,E_POINTER);
    ValidateReadWritePtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cObjectLock(m_pLock);

    /*  Copy constructor of m_mt allocates the memory */
    if (IsConnected()) {
        CopyMediaType( pmt, &m_mt );
        return S_OK;
    } else {
        ((CMediaType *)pmt)->InitMediaType();
        return VFW_E_NOT_CONNECTED;
    }
}

/* Return information about the filter we are connect to */

STDMETHODIMP
CBasePin::QueryPinInfo(
    PIN_INFO * pInfo
)
{
    CheckPointer(pInfo,E_POINTER);
    ValidateReadWritePtr(pInfo,sizeof(PIN_INFO));

    pInfo->pFilter = m_pFilter;
    if (m_pFilter) {
	m_pFilter->AddRef();
    }

    if (m_pName) {
	lstrcpyW(pInfo->achName, m_pName);
    } else {
	pInfo->achName[0] = L'\0';
    }

    pInfo->dir = m_dir;

    return NOERROR;
}

STDMETHODIMP
CBasePin::QueryDirection(
    PIN_DIRECTION * pPinDir
)
{
    CheckPointer(pPinDir,E_POINTER);
    ValidateReadWritePtr(pPinDir,sizeof(PIN_DIRECTION));

    *pPinDir = m_dir;
    return NOERROR;
}

// Default QueryId to return the pin's name
STDMETHODIMP
CBasePin::QueryId(
    LPWSTR * Id
)
{
    //  We're not going away because someone's got a pointer to us
    //  so there's no need to lock

    return AMGetWideString(Name(), Id);
}

/* Does this pin support this media type WARNING this interface function does
   not lock the main object as it is meant to be asynchronous by nature - if
   the media types you support depend on some internal state that is updated
   dynamically then you will need to implement locking in a derived class */

STDMETHODIMP
CBasePin::QueryAccept(
    const AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(pmt,E_POINTER);
    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE));

    /* The CheckMediaType method is valid to return error codes if the media
       type is horrible, an example might be E_INVALIDARG. What we do here
       is map all the error codes into either S_OK or S_FALSE regardless */

    HRESULT hr = CheckMediaType((CMediaType*)pmt);
    if (FAILED(hr)) {
        return S_FALSE;
    }
    // note that the only defined success codes should be S_OK and S_FALSE...
    return hr;
}


/* This can be called to return an enumerator for the pin's list of preferred
   media types. An input pin is not obliged to have any preferred formats
   although it can do. For example, the window renderer has a preferred type
   which describes a video image that matches the current window size. All
   output pins should expose at least one preferred format otherwise it is
   possible that neither pin has any types and so no connection is possible */

STDMETHODIMP
CBasePin::EnumMediaTypes(
    IEnumMediaTypes **ppEnum
)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *));

    /* Create a new ref counted enumerator */

    *ppEnum = new CEnumMediaTypes(this,
	                          NULL);

    if (*ppEnum == NULL) {
	return E_OUTOFMEMORY;
    }

    return NOERROR;
}



/* This is a virtual function that returns a media type corresponding with
   place iPosition in the list. This base class simply returns an error as
   we support no media types by default but derived classes should override */

HRESULT CBasePin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    UNREFERENCED_PARAMETER(iPosition);
    UNREFERENCED_PARAMETER(pMediaType);
    return E_UNEXPECTED;
}


/* This is a virtual function that returns the current media type version.
   The base class initialises the media type enumerators with the value 1
   By default we always returns that same value. A Derived class may change
   the list of media types available and after doing so it should increment
   the version either in a method derived from this, or more simply by just
   incrementing the m_TypeVersion base pin variable. The type enumerators
   call this when they want to see if their enumerations are out of date */

LONG CBasePin::GetMediaTypeVersion()
{
    return m_TypeVersion;
}


/* Increment the cookie representing the current media type version */

void CBasePin::IncrementTypeVersion()
{
    InterlockedIncrement(&m_TypeVersion);
}


/* Called by IMediaFilter implementation when the state changes from Stopped
   to either paused or running and in derived classes could do things like
   commit memory and grab hardware resource (the default is to do nothing) */

HRESULT
CBasePin::Active(void)
{
    return NOERROR;
}

/* Called by IMediaFilter implementation when the state changes from
   to either paused to running and in derived classes could do things like
   commit memory and grab hardware resource (the default is to do nothing) */

HRESULT
CBasePin::Run(REFERENCE_TIME tStart)
{
    UNREFERENCED_PARAMETER(tStart);
    return NOERROR;
}


/* Also called by the IMediaFilter implementation when the state changes to
   Stopped at which point you should decommit allocators and free hardware
   resources you grabbed in the Active call (default is also to do nothing) */

HRESULT
CBasePin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    return NOERROR;
}


// Called when no more data will arrive
STDMETHODIMP
CBasePin::EndOfStream(void)
{
    return S_FALSE;
}


STDMETHODIMP
CBasePin::SetSink(IQualityControl * piqc)
{
    CAutoLock cObjectLock(m_pLock);
    if (piqc) ValidateReadPtr(piqc,sizeof(IQualityControl));
    m_pQSink = piqc;
    return NOERROR;
} // SetSink


STDMETHODIMP
CBasePin::Notify(IBaseFilter * pSender, Quality q)
{
    UNREFERENCED_PARAMETER(q);
    CheckPointer(pSender,E_POINTER);
    ValidateReadPtr(pSender,sizeof(IBaseFilter));
    DbgBreak("IQualityControl::Notify not over-ridden from CBasePin.  (IGNORE is OK)");
    return E_FAIL;
} //Notify


// NewSegment notifies of the start/stop/rate applying to the data
// about to be received. Default implementation records data and
// returns S_OK.
// Override this to pass downstream.
STDMETHODIMP
CBasePin::NewSegment(
                REFERENCE_TIME tStart,
                REFERENCE_TIME tStop,
                double dRate)
{
    m_tStart = tStart;
    m_tStop = tStop;
    m_dRate = dRate;

    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CBaseOutputPin
//=====================================================================
//=====================================================================


CBaseOutputPin::CBaseOutputPin(TCHAR *pObjectName,
			       CBaseFilter *pFilter,
			       CCritSec *pLock,
			       HRESULT *phr,
			       LPCWSTR pName) :
    CBasePin(pObjectName, pFilter, pLock, phr, pName, PINDIR_OUTPUT),
    m_pAllocator(NULL),
    m_pInputPin(NULL)
{
    _ASSERTE(pFilter);
}


/* Since an input pin connected to us holds a reference count on us we will
   never be deleted unless all connections have already been terminated */

CBaseOutputPin::~CBaseOutputPin()
{
}

/*   This is called after a media type has been proposed

     Try to complete the connection by agreeing the allocator
*/
HRESULT
CBaseOutputPin::CompleteConnect(IPin *pReceivePin)
{
    UNREFERENCED_PARAMETER(pReceivePin);
    return DecideAllocator(m_pInputPin, &m_pAllocator);
}


/* This method is called when the output pin is about to try and connect to
   an input pin. It is at this point that you should try and grab any extra
   interfaces that you need, in this case IMemInputPin. Because this is
   only called if we are not currently connected we do NOT need to call
   BreakConnect. This also makes it easier to derive classes from us as
   BreakConnect is only called when we actually have to break a connection
   (or a partly made connection) and not when we are checking a connection */

/* Overriden from CBasePin */

HRESULT
CBaseOutputPin::CheckConnect(IPin * pPin)
{
    HRESULT hr = CBasePin::CheckConnect(pPin);
    if (FAILED(hr)) {
	return hr;
    }

    // get an input pin and an allocator interface
    hr = pPin->QueryInterface(IID_IMemInputPin, (void **) &m_pInputPin);
    if (FAILED(hr)) {
	return hr;
    }
    return NOERROR;
}


/* Overriden from CBasePin */

HRESULT
CBaseOutputPin::BreakConnect()
{
    /* Release any allocator we hold */

    if (m_pAllocator) {
	m_pAllocator->Release();
	m_pAllocator = NULL;
    }

    /* Release any input pin interface we hold */

    if (m_pInputPin) {
	m_pInputPin->Release();
	m_pInputPin = NULL;
    }
    return NOERROR;
}


/* This is called when the input pin didn't give us a valid allocator */

HRESULT
CBaseOutputPin::InitAllocator(IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;
    CMemAllocator *pMemObject = NULL;

    /* Create a default memory allocator */

    pMemObject = new CMemAllocator(NAME("Base memory allocator"),NULL, &hr);
    if (pMemObject == NULL) {
	return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
	delete pMemObject;
	return hr;
    }

    /* Get a reference counted IID_IMemAllocator interface */

    EXECUTE_ASSERT(SUCCEEDED(pMemObject->QueryInterface(IID_IMemAllocator,(void **)ppAlloc)));

    _ASSERTE(*ppAlloc != NULL);
    return NOERROR;
}


/* Decide on an allocator, override this if you want to use your own allocator
   Override DecideBufferSize to call SetProperties. If the input pin fails
   the GetAllocator call then this will construct a CMemAllocator and call
   DecideBufferSize on that, and if that fails then we are completely hosed.
   If the you succeed the DecideBufferSize call, we will notify the input
   pin of the selected allocator. NOTE this is called during Connect() which
   therefore looks after grabbing and locking the object's critical section */

// We query the input pin for its requested properties and pass this to
// DecideBufferSize to allow it to fulfill requests that it is happy
// with (eg most people don't care about alignment and are thus happy to
// use the downstream pin's alignment request).

HRESULT
CBaseOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}


/* This returns an empty sample buffer from the allocator WARNING the same
   dangers and restrictions apply here as described below for Deliver() */

HRESULT
CBaseOutputPin::GetDeliveryBuffer(IMediaSample ** ppSample,
                                  REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime,
                                  DWORD dwFlags)
{
    if (m_pAllocator != NULL) {
        return m_pAllocator->GetBuffer(ppSample,pStartTime,pEndTime,dwFlags);
    } else {
        return E_NOINTERFACE;
    }
}


/* Deliver a filled-in sample to the connected input pin. NOTE the object must
   have locked itself before calling us otherwise we may get halfway through
   executing this method only to find the filter graph has got in and
   disconnected us from the input pin. If the filter has no worker threads
   then the lock is best applied on Receive(), otherwise it should be done
   when the worker thread is ready to deliver. There is a wee snag to worker
   threads that this shows up. The worker thread must lock the object when
   it is ready to deliver a sample, but it may have to wait until a state
   change has completed, but that may never complete because the state change
   is waiting for the worker thread to complete. The way to handle this is for
   the state change code to grab the critical section, then set an abort event
   for the worker thread, then release the critical section and wait for the
   worker thread to see the event we set and then signal that it has finished
   (with another event). At which point the state change code can complete */

// note (if you've still got any breath left after reading that) that you
// need to release the sample yourself after this call. if the connected
// input pin needs to hold onto the sample beyond the call, it will addref
// the sample itself.

// of course you must release this one and call GetDeliveryBuffer for the
// next. You cannot reuse it directly.

HRESULT
CBaseOutputPin::Deliver(IMediaSample * pSample)
{
    if (m_pInputPin == NULL) {
	return VFW_E_NOT_CONNECTED;
    }
    return m_pInputPin->Receive(pSample);
}


// called from elsewhere in our filter to pass EOS downstream to
// our connected input pin
HRESULT
CBaseOutputPin::DeliverEndOfStream(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->EndOfStream();
}


/* Commit the allocator's memory, this is called through IMediaFilter
   which is responsible for locking the object before calling us */

HRESULT
CBaseOutputPin::Active(void)
{
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }
    return m_pAllocator->Commit();
}


/* Free up or unprepare allocator's memory, this is called through
   IMediaFilter which is responsible for locking the object first */

HRESULT
CBaseOutputPin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }
    return m_pAllocator->Decommit();
}

// we have a default handling of EndOfStream which is to return
// an error, since this should be called on input pins only
STDMETHODIMP
CBaseOutputPin::EndOfStream(void)
{
    return E_UNEXPECTED;
}


// BeginFlush should be called on input pins only
STDMETHODIMP
CBaseOutputPin::BeginFlush(void)
{
    return E_UNEXPECTED;
}

// EndFlush should be called on input pins only
STDMETHODIMP
CBaseOutputPin::EndFlush(void)
{
    return E_UNEXPECTED;
}

// call BeginFlush on the connected input pin
HRESULT
CBaseOutputPin::DeliverBeginFlush(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->BeginFlush();
}

// call EndFlush on the connected input pin
HRESULT
CBaseOutputPin::DeliverEndFlush(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->EndFlush();
}
// deliver NewSegment to connected pin
HRESULT
CBaseOutputPin::DeliverNewSegment(
    REFERENCE_TIME tStart,
    REFERENCE_TIME tStop,
    double dRate)
{
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->NewSegment(tStart, tStop, dRate);
}


//=====================================================================
//=====================================================================
// Implements CBaseInputPin
//=====================================================================
//=====================================================================


/* Constructor creates a default allocator object */

CBaseInputPin::CBaseInputPin(TCHAR *pObjectName,
			     CBaseFilter *pFilter,
			     CCritSec *pLock,
			     HRESULT *phr,
			     LPCWSTR pPinName) :
    CBasePin(pObjectName, pFilter, pLock, phr, pPinName, PINDIR_INPUT),
    m_pAllocator(NULL),
    m_bReadOnly(FALSE),
    m_bFlushing(FALSE)
{
    ZeroMemory(&m_SampleProps, sizeof(m_SampleProps));
}

/* Destructor releases it's reference count on the default allocator */

CBaseInputPin::~CBaseInputPin()
{
    if (m_pAllocator != NULL) {
	m_pAllocator->Release();
	m_pAllocator = NULL;
    }
    if (m_SampleProps.pMediaType) {
        DeleteMediaType(m_SampleProps.pMediaType);
    }
}


// override this to publicise our interfaces
STDMETHODIMP
CBaseInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we know about this interface */

    if (riid == IID_IMemInputPin) {
	return GetInterface((IMemInputPin *) this, ppv);
    } else {
	return CBasePin::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* Return the allocator interface that this input pin would like the output
   pin to use. NOTE subsequent calls to GetAllocator should all return an
   interface onto the SAME object so we create one object at the start

   Note:
       The allocator is Release()'d on disconnect and replaced on
       NotifyAllocator().

   Override this to provide your own allocator.
*/

STDMETHODIMP
CBaseInputPin::GetAllocator(
    IMemAllocator **ppAllocator)
{
    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pAllocator == NULL) {
	HRESULT hr = S_OK;

	/* Create the new allocator object */

	CMemAllocator *pMemObject = new CMemAllocator(NAME("Default memory allocator"),
						      NULL, &hr);
	if (pMemObject == NULL) {
	    return E_OUTOFMEMORY;
	}

	if (FAILED(hr)) {
	    _ASSERTE(pMemObject);
	    delete pMemObject;
	    return hr;
	}

        m_pAllocator = pMemObject;

        /*  We AddRef() our own allocator */
        m_pAllocator->AddRef();
    }
    _ASSERTE(m_pAllocator != NULL);
    *ppAllocator = m_pAllocator;
    m_pAllocator->AddRef();
    return NOERROR;
}


/* Tell the input pin which allocator the output pin is actually going to use
   Override this if you care - NOTE the locking we do both here and also in
   GetAllocator is unnecessary but derived classes that do something useful
   will undoubtedly have to lock the object so this might help remind people */

STDMETHODIMP
CBaseInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    CheckPointer(pAllocator,E_POINTER);
    ValidateReadPtr(pAllocator,sizeof(IMemAllocator));
    CAutoLock cObjectLock(m_pLock);

    IMemAllocator *pOldAllocator = m_pAllocator;
    pAllocator->AddRef();
    m_pAllocator = pAllocator;

    if (pOldAllocator != NULL) {
	pOldAllocator->Release();
    }

    // the readonly flag indicates whether samples from this allocator should
    // be regarded as readonly - if true, then inplace transforms will not be
    // allowed.
    m_bReadOnly = bReadOnly;
    return NOERROR;
}


/*  Disconnect */

STDMETHODIMP CBaseInputPin::Disconnect()
{
    CAutoLock cObjectLock(m_pLock);

    /*  Call base class first because it calls Inactive() for us */
    HRESULT hr = CBasePin::Disconnect();

    if (S_OK == hr) {
        /* We don't need our allocator any more */
        if (m_pAllocator) {
            m_pAllocator->Release();
            m_pAllocator = NULL;
        }
    }
    return hr;
}


/* Do something with this media sample - this base class checks to see if the
   format has changed with this media sample and if so checks that the filter
   will accept it, generating a run time error if not. Once we have raised a
   run time error we set a flag so that no more samples will be accepted

   It is important that any filter should override this method and implement
   synchronization so that samples are not processed when the pin is
   disconnected etc
*/

STDMETHODIMP
CBaseInputPin::Receive(IMediaSample *pSample)
{
    CheckPointer(pSample,E_POINTER);
    ValidateReadPtr(pSample,sizeof(IMediaSample));
    AM_MEDIA_TYPE *pmt = NULL;
    _ASSERTE(pSample);

    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    /* Check for IMediaSample2 */
    if (m_SampleProps.pMediaType) {
        DeleteMediaType(m_SampleProps.pMediaType);
    }
    IMediaSample2 *pSample2;
    if (SUCCEEDED(pSample->QueryInterface(IID_IMediaSample2, (void **)&pSample2))) {
        hr = pSample2->GetProperties(sizeof(m_SampleProps), (PBYTE)&m_SampleProps);
        pSample2->Release();
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        /*  Get the properties the hard way */
        m_SampleProps.cbData = sizeof(m_SampleProps);
        m_SampleProps.dwTypeSpecificFlags = 0;
        m_SampleProps.dwSampleFlags = 0;
        if (S_OK == pSample->IsDiscontinuity()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_DATADISCONTINUITY;
        }
        if (S_OK == pSample->IsPreroll()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_PREROLL;
        }
        if (S_OK == pSample->IsSyncPoint()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_SPLICEPOINT;
        }
        if (S_OK == pSample->GetTime(&m_SampleProps.tStart,
                                     &m_SampleProps.tStop)) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TIMEVALID |
                                           AM_SAMPLE_STOPVALID;
        }
        if (S_OK == pSample->GetMediaType(&m_SampleProps.pMediaType)) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TYPECHANGED;
        }
        pSample->GetPointer(&m_SampleProps.pbBuffer);
        m_SampleProps.lActual = pSample->GetActualDataLength();
        m_SampleProps.cbBuffer = pSample->GetSize();
    }

    /* Has the format changed in this sample */

    if (!(m_SampleProps.dwSampleFlags & AM_SAMPLE_TYPECHANGED)) {
	return NOERROR;
    }

    /* Check the derived class accepts this format */
    /* This shouldn't fail as the source must call QueryAccept first */

    hr = CheckMediaType((CMediaType *)m_SampleProps.pMediaType);

    if (hr == NOERROR) {
        return NOERROR;
    }

    /* Raise a runtime error if we fail the media type */

    m_bRunTimeError = TRUE;
    EndOfStream();
    m_pFilter->NotifyEvent(EC_ERRORABORT,VFW_E_TYPE_NOT_ACCEPTED,0);
    return VFW_E_INVALIDMEDIATYPE;
}


/*  Receive multiple samples */
STDMETHODIMP
CBaseInputPin::ReceiveMultiple (
    IMediaSample **pSamples,
    long nSamples,
    long *nSamplesProcessed)
{
    CheckPointer(pSamples,E_POINTER);
    ValidateReadPtr(pSamples,nSamples * sizeof(IMediaSample *));

    HRESULT hr = S_OK;
    *nSamplesProcessed = 0;
    while (nSamples-- > 0) {
         hr = Receive(pSamples[*nSamplesProcessed]);

         /*  S_FALSE means don't send any more */
         if (hr != S_OK) {
             break;
         }
         (*nSamplesProcessed)++;
    }
    return hr;
}

/*  See if Receive() might block */
STDMETHODIMP
CBaseInputPin::ReceiveCanBlock()
{
    /*  Ask all the output pins if they block
        If there are no output pin assume we do block
    */
    int cPins = m_pFilter->GetPinCount();
    int cOutputPins = 0;
    for (int c = 0; c < cPins; c++) {
        CBasePin *pPin = m_pFilter->GetPin(c);
        PIN_DIRECTION pd;
        HRESULT hr = pPin->QueryDirection(&pd);
        if (FAILED(hr)) {
            return hr;
        }

        if (pd == PINDIR_OUTPUT) {
            IPin *pConnected;
            hr = pPin->ConnectedTo(&pConnected);
            if (SUCCEEDED(hr)) {
                _ASSERTE(pConnected != NULL);
                cOutputPins++;
                IMemInputPin *pInputPin;
                hr = pConnected->QueryInterface(
                                              IID_IMemInputPin,
                                              (void **)&pInputPin);
                pConnected->Release();
                if (SUCCEEDED(hr)) {
                    hr = pInputPin->ReceiveCanBlock();
                    pInputPin->Release();
                    if (hr != S_FALSE) {
                        return S_OK;
                    }
                } else {
                    /*  There's a transport we don't understand here */
                    return S_OK;
                }
            }
        }
    }
    return cOutputPins == 0 ? S_OK : S_FALSE;
}

// Default handling for BeginFlush - call at the beginning
// of your implementation (makes sure that all Receive calls
// fail). After calling this, you need to free any queued data
// and then call downstream.
STDMETHODIMP
CBaseInputPin::BeginFlush(void)
{
    //  BeginFlush is NOT synchronized with streaming but is part of
    //  a control action - hence we synchronize with the filter
    CAutoLock lck(m_pLock);

    // if we are already in mid-flush, this is probably a mistake
    // though not harmful - try to pick it up for now so I can think about it
    _ASSERTE(!m_bFlushing);

    // first thing to do is ensure that no further Receive calls succeed
    m_bFlushing = TRUE;

    // now discard any data and call downstream - must do that
    // in derived classes
    return S_OK;
}

// default handling for EndFlush - call at end of your implementation
// - before calling this, ensure that there is no queued data and no thread
// pushing any more without a further receive, then call downstream,
// then call this method to clear the m_bFlushing flag and re-enable
// receives
STDMETHODIMP
CBaseInputPin::EndFlush(void)
{
    //  Endlush is NOT synchronized with streaming but is part of
    //  a control action - hence we synchronize with the filter
    CAutoLock lck(m_pLock);

    // almost certainly a mistake if we are not in mid-flush
    _ASSERTE(m_bFlushing);

    // before calling, sync with pushing thread and ensure
    // no more data is going downstream, then call EndFlush on
    // downstream pins.

    // now re-enable Receives
    m_bFlushing = FALSE;

    return S_OK;
}


STDMETHODIMP
CBaseInputPin::Notify(IBaseFilter * pSender, Quality q)
{
    UNREFERENCED_PARAMETER(q);
    CheckPointer(pSender,E_POINTER);
    ValidateReadPtr(pSender,sizeof(IBaseFilter));
    DbgBreak("IQuality::Notify called on an input pin");
    return NOERROR;
} // Notify

/* Free up or unprepare allocator's memory, this is called through
   IMediaFilter which is responsible for locking the object first */

HRESULT
CBaseInputPin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }

    m_bFlushing = FALSE;

    return m_pAllocator->Decommit();
}

// what requirements do we have of the allocator - override if you want
// to support other people's allocators but need a specific alignment
// or prefix.
STDMETHODIMP
CBaseInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    UNREFERENCED_PARAMETER(pProps);
    return E_NOTIMPL;
}

//  Check if it's OK to process data
//
HRESULT
CBaseInputPin::CheckStreaming()
{
    //  Shouldn't be able to get any data if we're not connected!
    _ASSERTE(IsConnected());

    //  Don't process stuff in Stopped state
    if (IsStopped()) {
        return VFW_E_WRONG_STATE;
    }
    if (m_bFlushing) {
        return S_FALSE;
    }
    if (m_bRunTimeError) {
	return VFW_E_RUNTIME_ERROR;
    }
    return S_OK;
}
#endif

//=====================================================================
//=====================================================================
// Memory allocation class, implements CMediaSampleImpl
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor with
   a NULL outer unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

/* The last two parameters have default values of NULL and zero */

template <class _S, class _A>
CAMMediaSampleImpl<_S, _A>::CAMMediaSampleImpl() :
    m_pBuffer(NULL),                // Initialise the buffer
    m_cbBuffer(0),                  // And it's length
    m_lActual(0),                   // By default, actual = length
    m_pMediaType(NULL),             // No media type change
    m_dwFlags(0),                   // Nothing set
    m_cRef(0),                      // 0 ref count
    m_pAllocator(NULL)              // Allocator
{
}


#if 0
/* Destructor deletes the media type memory */

template <class _S, class _A>
CAMMediaSampleImpl<_S, _A>::~CAMMediaSampleImpl()
{
    if (m_pMediaType) {
	DeleteMediaType(m_pMediaType);
    }
}
#endif

/* Override this to publicise our interfaces */

template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::QueryInterface(REFIID riid, void **ppv)
{
    if (ppv == NULL) {
        return E_POINTER;
    }
    if (riid == IID_IMediaSample ||
        riid == IID_IMediaSample2 ||
        riid == IID_IUnknown) {
        *ppv = (IMediaSample *)this;
        AddRef();
        return S_OK;
    } else {
	return E_NOINTERFACE;
    }
}

template <class _S, class _A>
STDMETHODIMP_(ULONG)
CAMMediaSampleImpl<_S, _A>::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// --  CMediaSample lifetimes --
//
// On final release of this sample buffer it is not deleted but
// returned to the freelist of the owning memory allocator
//
// The allocator may be waiting for the last buffer to be placed on the free
// list in order to decommit all the memory, so the ReleaseBuffer() call may
// result in this sample being deleted. We also need to hold a refcount on
// the allocator to stop that going away until we have finished with this.
// However, we cannot release the allocator before the ReleaseBuffer, as the
// release may cause us to be deleted. Similarly we can't do it afterwards.
//
// Thus we must leave it to the allocator to hold an addref on our behalf.
// When he issues us in GetBuffer, he addref's himself. When ReleaseBuffer
// is called, he releases himself, possibly causing us and him to be deleted.


template <class _S, class _A>
STDMETHODIMP_(ULONG)
CAMMediaSampleImpl<_S, _A>::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    _ASSERTE(lRef >= 0);

    //DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
    //	    this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        /* Free all resources */
        if (m_dwFlags & Sample_TypeChanged) {
            SetMediaType(NULL);
        }
        _ASSERTE(m_pMediaType == NULL);
        m_dwFlags = 0;

        /* This may cause us to be deleted */
        // Our refcount is reliably 0 thus no-one will mess with us
        m_pAllocator->ReleaseBuffer(this);
    }
    return (ULONG)lRef;
}


#if 0
// set the buffer pointer and length. Used by allocators that
// want variable sized pointers or pointers into already-read data.
// This is only available through a CMediaSample* not an IMediaSample*
// and so cannot be changed by clients.
template <class _S, class _A>
HRESULT
CAMMediaSampleImpl<_S, _A>::SetPointer(BYTE * ptr, LONG cBytes)
{
    m_pBuffer = ptr;            // new buffer area (could be null)
    m_cbBuffer = cBytes;        // length of buffer
    m_lActual = cBytes;         // length of data in buffer (assume full)

    return S_OK;
}
#endif


// get me a read/write pointer to this buffer's memory. I will actually
// want to use sizeUsed bytes.
template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::GetPointer(BYTE ** ppBuffer)
{
    //ValidateReadWritePtr(ppBuffer,sizeof(BYTE *));

    // creator must have set pointer either during
    // constructor or by SetPointer
    _ASSERTE(m_pBuffer);

    *ppBuffer = m_pBuffer;
    return NOERROR;
}


// return the size in bytes of this buffer
template <class _S, class _A>
STDMETHODIMP_(LONG)
CAMMediaSampleImpl<_S, _A>::GetSize(void)
{
    return m_cbBuffer;
}


// get the stream time at which this sample should start and finish.
template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::GetTime(
    REFERENCE_TIME * pTimeStart,     // put time here
    REFERENCE_TIME * pTimeEnd
)
{
    //ValidateReadWritePtr(pTimeStart,sizeof(REFERENCE_TIME));
    //ValidateReadWritePtr(pTimeEnd,sizeof(REFERENCE_TIME));

    if (!(m_dwFlags & Sample_TimeValid)) {
        return VFW_E_SAMPLE_TIME_NOT_SET;
    }

    *pTimeStart = m_Start;
    *pTimeEnd = m_End;
    return NOERROR;
}


// Set the stream time at which this sample should start and finish.
// NULL pointers means the time is reset
template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::SetTime(
    REFERENCE_TIME * pTimeStart,
    REFERENCE_TIME * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        _ASSERTE(pTimeEnd == NULL);
        m_dwFlags &= ~(Sample_TimeValid | Sample_StopValid);
    } else {
        //ValidateReadPtr(pTimeStart,sizeof(REFERENCE_TIME));
        //ValidateReadPtr(pTimeEnd,sizeof(REFERENCE_TIME));
        _ASSERTE(*pTimeEnd >= *pTimeStart);

        m_Start = *pTimeStart;
        m_End = *pTimeEnd;
        m_dwFlags |= Sample_TimeValid | Sample_StopValid;
    }
    return NOERROR;
}


// get the media times (eg bytes) for this sample
template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::GetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    //ValidateReadWritePtr(pTimeStart,sizeof(LONGLONG));
    //ValidateReadWritePtr(pTimeEnd,sizeof(LONGLONG));

    if (!(m_dwFlags & Sample_MediaTimeValid)) {
        return VFW_E_MEDIA_TIME_NOT_SET;
    }

    *pTimeStart = m_MediaStart;
    *pTimeEnd = (m_MediaStart + m_MediaEnd);
    return NOERROR;
}


// Set the media times for this sample
template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::SetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        _ASSERTE(pTimeEnd == NULL);
        m_dwFlags &= ~Sample_MediaTimeValid;
    } else {
        //ValidateReadPtr(pTimeStart,sizeof(LONGLONG));
        //ValidateReadPtr(pTimeEnd,sizeof(LONGLONG));
	_ASSERTE(*pTimeEnd >= *pTimeStart);

        m_MediaStart = *pTimeStart;
        m_MediaEnd = (LONG)(*pTimeEnd - *pTimeStart);
        m_dwFlags |= Sample_MediaTimeValid;
    }
    return NOERROR;
}


template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::IsSyncPoint(void)
{
    if (m_dwFlags & Sample_SyncPoint) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}


template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
        m_dwFlags |= Sample_SyncPoint;
    } else {
        m_dwFlags &= ~Sample_SyncPoint;
    }
    return NOERROR;
}

// returns S_OK if there is a discontinuity in the data (this same is
// not a continuation of the previous stream of data
// - there has been a seek).
template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::IsDiscontinuity(void)
{
    if (m_dwFlags & Sample_Discontinuity) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}

// set the discontinuity property - TRUE if this sample is not a
// continuation, but a new sample after a seek.
template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::SetDiscontinuity(BOOL bDiscont)
{
    // should be TRUE or FALSE
    if (bDiscont) {
        m_dwFlags |= Sample_Discontinuity;
    } else {
        m_dwFlags &= ~Sample_Discontinuity;
    }
    return S_OK;
}

template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::IsPreroll(void)
{
    if (m_dwFlags & Sample_Preroll) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}


template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::SetPreroll(BOOL bIsPreroll)
{
    if (bIsPreroll) {
        m_dwFlags |= Sample_Preroll;
    } else {
        m_dwFlags &= ~Sample_Preroll;
    }
    return NOERROR;
}

template <class _S, class _A>
STDMETHODIMP_(LONG)
CAMMediaSampleImpl<_S, _A>::GetActualDataLength(void)
{
    return m_lActual;
}


template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::SetActualDataLength(LONG lActual)
{
    if (lActual > m_cbBuffer) {
        _ASSERTE(lActual <= GetSize());
	return VFW_E_BUFFER_OVERFLOW;
    }
    m_lActual = lActual;
    return NOERROR;
}


/* These allow for limited format changes in band */

template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    //ValidateReadWritePtr(ppMediaType,sizeof(AM_MEDIA_TYPE *));
    _ASSERTE(ppMediaType);

    /* Do we have a new media type for them */

    if (!(m_dwFlags & Sample_TypeChanged)) {
	_ASSERTE(m_pMediaType == NULL);
	*ppMediaType = NULL;
	return S_FALSE;
    }

    _ASSERTE(m_pMediaType);

    /* Create a copy of our media type */

    *ppMediaType = CreateMediaType(m_pMediaType);
    if (*ppMediaType == NULL) {
	return E_OUTOFMEMORY;
    }
    return NOERROR;
}


/* Mark this sample as having a different format type */

template <class _S, class _A>
STDMETHODIMP
CAMMediaSampleImpl<_S, _A>::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    /* Delete the current media type */

    if (m_pMediaType) {
	DeleteMediaType(m_pMediaType);
	m_pMediaType = NULL;
    }

    /* Mechanism for resetting the format type */

    if (pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
	return NOERROR;
    }

    _ASSERTE(pMediaType);
    //ValidateReadPtr(pMediaType,sizeof(AM_MEDIA_TYPE));

    /* Take a copy of the media type */

    m_pMediaType = CreateMediaType(pMediaType);
    if (m_pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
	return E_OUTOFMEMORY;
    }

    m_dwFlags |= Sample_TypeChanged;
    return NOERROR;
}

// Set and get properties (IMediaSample2)
template <class _S, class _A>
STDMETHODIMP CAMMediaSampleImpl<_S, _A>::GetProperties(
    DWORD cbProperties,
    BYTE * pbProperties
)
{
    if (0 != cbProperties) {
        if (pbProperties == NULL) {
            return E_POINTER;
        }
        //  Return generic stuff up to the length
        AM_SAMPLE2_PROPERTIES Props;
        Props.cbData     = min(cbProperties, sizeof(Props));
        Props.dwSampleFlags = m_dwFlags & ~Sample_MediaTimeValid;
        Props.dwTypeSpecificFlags = m_dwTypeSpecificFlags;
        Props.pbBuffer   = m_pBuffer;
        Props.cbBuffer   = m_cbBuffer;
        Props.lActual    = m_lActual;
        Props.tStart     = m_Start;
        Props.tStop      = m_End;
        if (m_dwFlags & AM_SAMPLE_TYPECHANGED) {
            Props.pMediaType = m_pMediaType;
        } else {
            Props.pMediaType = NULL;
        }
        CopyMemory(pbProperties, &Props, Props.cbData);
    }
    return S_OK;
}

#define CONTAINS_FIELD(type, field, offset) \
    ((FIELD_OFFSET(type, field) + sizeof(((type *)0)->field)) <= offset)

template <class _S, class _A>
HRESULT CAMMediaSampleImpl<_S, _A>::SetProperties(
    DWORD cbProperties,
    const BYTE * pbProperties
)
{

    /*  Generic properties */
    AM_MEDIA_TYPE *pMediaType = NULL;

    if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbData, cbProperties)) {
        if (pbProperties == NULL) {
            return E_POINTER;
        }
        AM_SAMPLE2_PROPERTIES *pProps =
            (AM_SAMPLE2_PROPERTIES *)pbProperties;

        /*  Don't use more data than is actually there */
        if (pProps->cbData < cbProperties) {
            cbProperties = pProps->cbData;
        }
        /*  We only handle IMediaSample2 */
        if (cbProperties > sizeof(*pProps) ||
            pProps->cbData > sizeof(*pProps)) {
            return E_INVALIDARG;
        }
        /*  Do checks first, the assignments (for backout) */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Check the flags */
            if (pProps->dwSampleFlags &
                    (~Sample_ValidFlags | Sample_MediaTimeValid)) {
                return E_INVALIDARG;
            }
            /*  Check a flag isn't being set for a property
                not being provided
            */
            if ((pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID) &&
                 !(m_dwFlags & AM_SAMPLE_TIMEVALID) &&
                 !CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {
                 return E_INVALIDARG;
            }
        }
        /*  NB - can't SET the pointer or size */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pbBuffer, cbProperties)) {

            /*  Check pbBuffer */
            if (pProps->pbBuffer != 0 && pProps->pbBuffer != m_pBuffer) {
                return E_INVALIDARG;
            }
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties)) {

            /*  Check cbBuffer */
            if (pProps->cbBuffer != 0 && pProps->cbBuffer != m_cbBuffer) {
                return E_INVALIDARG;
            }
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties) &&
            CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {

            /*  Check lActual */
            if (pProps->cbBuffer < pProps->lActual) {
                return E_INVALIDARG;
            }
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {

            /*  Check pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                if (pProps->pMediaType == NULL) {
                    return E_POINTER;
                }
                pMediaType = CreateMediaType(pProps->pMediaType);
                if (pMediaType == NULL) {
                    return E_OUTOFMEMORY;
                }
            }
        }

        /*  Now do the assignments */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Set the flags */
            m_dwFlags = pProps->dwSampleFlags |
                                (m_dwFlags & Sample_MediaTimeValid);
            m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
        } else {
            if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwTypeSpecificFlags, cbProperties)) {
                m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
            }
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {
            /*  Set lActual */
            m_lActual = pProps->lActual;
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {

            /*  Set the times */
            m_End   = pProps->tStop;
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStart, cbProperties)) {

            /*  Set the times */
            m_Start = pProps->tStart;
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {
            /*  Set pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                if (m_pMediaType != NULL) {
                    DeleteMediaType(m_pMediaType);
                }
                m_pMediaType = pMediaType;
            }
        }
    }

    return S_OK;
}

//=====================================================================
//=====================================================================
// Implements CAMBaseAllocator
//=====================================================================
//=====================================================================


/* Constructor overrides the default settings for the free list to request
   that it be alertable (ie the list can be cast to a handle which can be
   passed to WaitForSingleObject). Both of the allocator lists also ask for
   object locking, the all list matches the object default settings but I
   have included them here just so it is obvious what kind of list it is */

template <class _A, class _S>
CAMBaseAllocator<_A, _S>::CAMBaseAllocator() :
    m_lAllocated(0),
    m_bChanged(FALSE),
    m_bCommitted(FALSE),
    m_bDecommitInProgress(FALSE),
    m_lSize(0),
    m_lCount(0),
    m_lAlignment(0),
    m_lPrefix(0),
    m_hSem(NULL),
    m_lWaiting(0)
{
}

template <class _A, class _S>
HRESULT CAMBaseAllocator<_A, _S>::FinalConstruct()
{
    HRESULT hr = CComObjectRoot::FinalConstruct();
    if (FAILED(hr)) {
        return hr;
    }
    m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
    if (m_hSem == NULL) {
        return E_OUTOFMEMORY;
    } else {
        return S_OK;
    }
}


/* Destructor */

template <class _A, class _S>
CAMBaseAllocator<_A, _S>::~CAMBaseAllocator()
{
    // we can't call Decommit here since that would mean a call to a
    // pure virtual in destructor.
    // We must assume that the derived class has gone into decommit state in
    // its destructor.
    _ASSERTE(!m_bCommitted);
    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}


/* This sets the size and count of the required samples. The memory isn't
   actually allocated until Commit() is called, if memory has already been
   allocated then assuming no samples are outstanding the user may call us
   to change the buffering, the memory will be released in Commit() */

template <class _A, class _S>
STDMETHODIMP
CAMBaseAllocator<_A, _S>::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    if (pRequest == NULL || pActual == NULL) {
        return E_POINTER;
    }
    // ValidateReadWritePtr(pActual, sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(&m_Lock);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    _ASSERTE(pRequest->cbBuffer > 0);

    /*  Check the alignment requested */
    if (pRequest->cbAlign != 1) {
#if 0 //  No decent logging macros in ATL
	DbgLog((LOG_ERROR, 2, TEXT("Alignment requested was 0x%x, not 1"),
	       pRequest->cbAlign));
#endif
	return VFW_E_BADALIGN;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted) {
	return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lAllocated != m_lFree.GetCount()) {
	return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}

template <class _A, class _S>
STDMETHODIMP
CAMBaseAllocator<_A, _S>::GetProperties(
    ALLOCATOR_PROPERTIES * pActual)
{
    if (pActual == NULL) {
        return E_POINTER;
    }
    // ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));

    CAutoLock cObjectLock(&m_Lock);
    pActual->cbBuffer = m_lSize;
    pActual->cBuffers = m_lCount;
    pActual->cbAlign = m_lAlignment;
    pActual->cbPrefix = m_lPrefix;
    return NOERROR;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct.

template <class _A, class _S>
HRESULT CAMBaseAllocator<_A, _S>::GetBuffer(IMediaSample **ppBuffer,
                                  REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime,
                                  DWORD dwFlags
                                  )
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(dwFlags);
    _S *pSample;

    *ppBuffer = NULL;
    for (;;)
    {
        {  // scope for lock
            CAutoLock cObjectLock(&m_Lock);

            /* Check we are committed */
            if (!m_bCommitted) {
                return VFW_E_NOT_COMMITTED;
            }
            pSample = (_S *)m_lFree.RemoveHead();
            if (pSample == NULL) {
                SetWaiting();
            }
        }

        /* If we didn't get a sample then wait for the list to signal */

        if (pSample) {
            break;
        }
        _ASSERTE(m_hSem != NULL);
        WaitForSingleObject(m_hSem, INFINITE);
    }

    /* Addref the buffer up to one. On release
       back to zero instead of being deleted, it will requeue itself by
       calling the ReleaseBuffer member function. NOTE the owner of a
       media sample must always be derived from CAMBaseAllocator */


    _ASSERTE(pSample->m_cRef == 0);
    pSample->m_cRef = 1;
    *ppBuffer = pSample;

    return NOERROR;
}


/* Final release of a CAMMediaSampleImpl<CAMMediaSampleImpl, _F> will call this */

template <class _A, class _S>
STDMETHODIMP
CAMBaseAllocator<_A, _S>::ReleaseBuffer(IMediaSample * pSample)
{
    if (pSample == NULL) {
        return E_POINTER;
    }
    //ValidateReadPtr(pSample,sizeof(IMediaSample));
    BOOL bRelease = FALSE;
    {
        CAutoLock cal(&m_Lock);

        /* Put back on the free list */

        m_lFree.Add((_S *)pSample);
        if (m_lWaiting != 0) {
            NotifySample();
        }

        // if there is a pending Decommit, then we need to complete it by
        // calling Free() when the last buffer is placed on the free list

    	LONG l1 = m_lFree.GetCount();
    	if (m_bDecommitInProgress && (l1 == m_lAllocated)) {
    	    Free();
    	    m_bDecommitInProgress = FALSE;
            bRelease = TRUE;
    	}
    }

    /* For each buffer there is one AddRef, made in GetBuffer and released
       here. This may cause the allocator and all samples to be deleted */

    if (bRelease) {
        Release();
    }
    return NOERROR;
}

template <class _A, class _S>
void
CAMBaseAllocator<_A, _S>::NotifySample()
{
    if (m_lWaiting != 0) {
        _ASSERTE(m_hSem != NULL);
        ReleaseSemaphore(m_hSem, m_lWaiting, 0);
        m_lWaiting = 0;
    }
}

template <class _A, class _S>
STDMETHODIMP
CAMBaseAllocator<_A, _S>::Commit()
{
    /* Check we are not decommitted */
    CAutoLock cObjectLock(&m_Lock);

    // cannot need to alloc or re-alloc if we are committed
    if (m_bCommitted) {
        return NOERROR;
    }

    /* Allow GetBuffer calls */

    m_bCommitted = TRUE;

    // is there a pending decommit ? if so, just cancel it
    if (m_bDecommitInProgress) {
        m_bDecommitInProgress = FALSE;

        // don't call Alloc at this point. He cannot allow SetProperties
        // between Decommit and the last free, so the buffer size cannot have
        // changed. And because some of the buffers are not free yet, he
        // cannot re-alloc anyway.
        return NOERROR;
    }

    // DbgLog((LOG_MEMORY, 1, TEXT("Allocating: %ldx%ld"), m_lCount, m_lSize));

    // actually need to allocate the samples
    HRESULT hr = Alloc();
    if (FAILED(hr)) {
        m_bCommitted = FALSE;
        return hr;
    }
    AddRef();
    return NOERROR;
}


template <class _A, class _S>
STDMETHODIMP
CAMBaseAllocator<_A, _S>::Decommit()
{
    BOOL bRelease = FALSE;
    {
        /* Check we are not already decommitted */
        CAutoLock cObjectLock(&m_Lock);
        if (m_bCommitted == FALSE) {
            if (m_bDecommitInProgress == FALSE) {
                return NOERROR;
            }
        }

        /* No more GetBuffer calls will succeed */
        m_bCommitted = FALSE;

        // are any buffers outstanding?
        if (m_lFree.GetCount() < m_lAllocated) {
            // please complete the decommit when last buffer is freed
            m_bDecommitInProgress = TRUE;
        } else {
            m_bDecommitInProgress = FALSE;

            // need to complete the decommit here as there are no
            // outstanding buffers

            Free();
            bRelease = TRUE;
        }

        // Tell anyone waiting that they can go now so we can
        // reject their call
        NotifySample();
    }

    if (bRelease) {
        Release();
    }
    return NOERROR;
}


/* Base definition of allocation which checks we are ok to go ahead and do
   the full allocation. We return S_FALSE if the requirements are the same */

template <class _A, class _S>
HRESULT
CAMBaseAllocator<_A, _S>::Alloc(void)
{
    /* Error if he hasn't set the size yet */
    if (m_lCount <= 0 || m_lSize <= 0 || m_lAlignment <= 0) {
	return VFW_E_SIZENOTSET;
    }

    /* should never get here while buffers outstanding */
    _ASSERTE(m_lFree.GetCount() == m_lAllocated);

    /* If the requirements haven't changed then don't reallocate */
    if (m_bChanged == FALSE) {
	return S_FALSE;
    }

    return NOERROR;
}

/*  Implement CAMBaseAllocator::CSampleList::Remove(pSample)
    Removes pSample from the list
*/
template <class _A, class _S>
void
CAMBaseAllocator<_A, _S>::CSampleList::Remove(_S * pSample)
{
    _S **pSearch;
    for (pSearch = &m_List;
         *pSearch != NULL;
         pSearch = &(NextSample(*pSearch))) {
       if (*pSearch == pSample) {
           *pSearch = NextSample(pSample);
           NextSample(pSample) = NULL;
           m_nOnList--;
           return;
       }
    }
    DbgBreak("Couldn't find sample in list");
}

//=====================================================================
//=====================================================================
// Implements CMemAllocator
//=====================================================================
//=====================================================================


CAMMemAllocator::CAMMemAllocator() : m_pBuffer(NULL)
{
}

/* This sets the size and count of the required samples. The memory isn't
   actually allocated until Commit() is called, if memory has already been
   allocated then assuming no samples are outstanding the user may call us
   to change the buffering, the memory will be released in Commit() */
STDMETHODIMP
CAMMemAllocator::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    if (pActual == NULL) {
        return E_POINTER;
    }
    // ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(&m_Lock);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    _ASSERTE(pRequest->cbBuffer > 0);

    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    /*  Check the alignment request is a power of 2 */
    if ((-pRequest->cbAlign & pRequest->cbAlign) != pRequest->cbAlign) {
#if 0
	DbgLog((LOG_ERROR, 1, TEXT("Alignment requested 0x%x not a power of 2!"),
	       pRequest->cbAlign));
#endif
    }
    /*  Check the alignment requested */
    if (pRequest->cbAlign == 0 ||
	SysInfo.dwAllocationGranularity & (pRequest->cbAlign - 1) != 0) {
#if 0
	DbgLog((LOG_ERROR, 1, TEXT("Invalid alignment 0x%x requested - granularity = 0x%x"),
	       pRequest->cbAlign, SysInfo.dwAllocationGranularity));
#endif
	return VFW_E_BADALIGN;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted == TRUE) {
	return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lFree.GetCount() < m_lAllocated) {
	return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    // round length up to alignment - remember that prefix is included in
    // the alignment
    LONG lSize = pRequest->cbBuffer + pRequest->cbPrefix;
    LONG lRemainder = lSize % pRequest->cbAlign;
    if (lRemainder != 0) {
	lSize = lSize - lRemainder + pRequest->cbAlign;
    }
    pActual->cbBuffer = m_lSize = (lSize - pRequest->cbPrefix);

    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}

// override this to allocate our resources when Commit is called.
//
// note that our resources may be already allocated when this is called,
// since we don't free them on Decommit. We will only be called when in
// decommit state with all buffers free.
//
// object locked by caller
HRESULT
CAMMemAllocator::Alloc(void)
{
    CAutoLock lck(&m_Lock);

    /* Check he has called SetProperties */
    HRESULT hr = _BaseAllocator::Alloc();
    if (FAILED(hr)) {
	return hr;
    }

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
	_ASSERTE(m_pBuffer);
	return NOERROR;
    }
    _ASSERTE(hr == S_OK); // we use this fact in the loop below

    /* Free the old resources */
    if (m_pBuffer) {
	ReallyFree();
    }

    /* Create the contiguous memory block for the samples
       making sure it's properly aligned (64K should be enough!)
    */
    _ASSERTE(m_lAlignment != 0 &&
	   (m_lSize + m_lPrefix) % m_lAlignment == 0);

    m_pBuffer = (PBYTE)VirtualAlloc(NULL,
				    m_lCount * (m_lSize + m_lPrefix),
				    MEM_COMMIT,
				    PAGE_READWRITE);

    if (m_pBuffer == NULL) {
	return E_OUTOFMEMORY;
    }

    LPBYTE pNext = m_pBuffer;
    CAMMediaSample<CAMMemAllocator> *pSample;

    _ASSERTE(m_lAllocated == 0);

    // Create the new samples - we have allocated m_lSize bytes for each sample
    // plus m_lPrefix bytes per sample as a prefix. We set the pointer to
    // the memory after the prefix - so that GetPointer() will return a pointer
    // to m_lSize bytes.
    for (; m_lAllocated < m_lCount; m_lAllocated++, pNext += (m_lSize + m_lPrefix)) {


	pSample = new CAMMediaSample<CAMMemAllocator>;

        _ASSERTE(SUCCEEDED(hr));
	if (pSample == NULL) {
	    return E_OUTOFMEMORY;
	}

        pSample->Init(this);
        pSample->SetPointer(pNext + m_lPrefix, m_lSize);

	// This CANNOT fail
	m_lFree.Add(pSample);
    }

    m_bChanged = FALSE;
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()
void
CAMMemAllocator::Free(void)
{
    return;
}


// called from the destructor (and from Alloc if changing size/count) to
// actually free up the memory
void
CAMMemAllocator::ReallyFree(void)
{
    /* Should never be deleting this unless all buffers are freed */

    _ASSERTE(m_lAllocated == m_lFree.GetCount());

    /* Free up all the CAMMediaSamples */

    CAMMediaSample<CAMMemAllocator> *pSample;
    for (;;) {
        pSample = m_lFree.RemoveHead();
        if (pSample != NULL) {
            delete pSample;
        } else {
            break;
        }
    }

    m_lAllocated = 0;

    // free the block of buffer memory
    if (m_pBuffer) {
	EXECUTE_ASSERT(VirtualFree(m_pBuffer, 0, MEM_RELEASE));
	m_pBuffer = NULL;
    }
}


/* Destructor frees our memory resources */

CAMMemAllocator::~CAMMemAllocator()
{
    Decommit();
    ReallyFree();
}

//  Remove warnings about unreferenced inline functions
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\ambase.h ===
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.

//  Media type stuff
void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt);
void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt);
void WINAPI InitMediaType(AM_MEDIA_TYPE *mt);

/*  Base class objects for ActiveMovie in ATL */

/*  Allocators */

//=====================================================================
//=====================================================================
// Memory allocators
//
// the shared memory transport between pins requires the input pin
// to provide a memory allocator that can provide sample objects. A
// sample object supports the IMediaSample interface.
//
// CAMBaseAllocator handles the management of free and busy samples. It
// allocates CAMMediaSample objects. CAMBaseAllocator is an abstract class:
// in particular it has no method of initializing the list of free
// samples. CAMMemAllocator is derived from CAMBaseAllocator and initializes
// the list of samples using memory from the standard IMalloc interface.
//
// If you want your buffers to live in some special area of memory,
// derive your allocator object from CAMBaseAllocator. If you derive your
// IMemInputPin interface object from CAMBaseMemInputPin, you will get
// CAMMemAllocator-based allocation etc for free and will just need to
// supply the Receive handling, and media type / format negotiation.
//=====================================================================
//=====================================================================

//
//  The inhertiance tree for allocators and samples looks like
//
//  CAMImplMediaSample<_S, _A>
//
//  CAMImplMediaSample< CMediaSample< _A >, _A >
//           |
//           V
//  CAMMediaSample<_A>
//
//
//  CAMBaseAllocator<_A, _S>
//
//  CAMBaseAllocator< CAMMemAllocator, CAMMediaSample< CAMMemAllocator > >                >
//          |
//          V
//  CAMMemAllocator

//=====================================================================
//=====================================================================
// Defines CAMMediaSample
//
// an object of this class supports IMediaSample and represents a buffer
// for media data with some associated properties. Releasing it returns
// it to a freelist managed by a CAMBaseAllocator derived object.
//=====================================================================
//=====================================================================

template <class _S, class _A>
class CAMMediaSampleImpl : public IMediaSample2    // The interface we support
{
protected:

    friend class _A;

    /*  Values for dwFlags - these are used for backward compatiblity
        only now - use AM_SAMPLE_xxx
    */
    enum { Sample_SyncPoint       = 0x01,   /* Is this a sync point */
           Sample_Preroll         = 0x02,   /* Is this a preroll sample */
           Sample_Discontinuity   = 0x04,   /* Set if start of new segment */
           Sample_TypeChanged     = 0x08,   /* Has the type changed */
           Sample_TimeValid       = 0x10,   /* Set if time is valid */
           Sample_MediaTimeValid  = 0x20,   /* Is the media time valid */
           Sample_TimeDiscontinuity = 0x40, /* Time discontinuity */
           Sample_StopValid       = 0x100,  /* Stop time valid */
           Sample_ValidFlags      = 0x1FF
         };

    /* Properties, the media sample class can be a container for a format
       change in which case we take a copy of a type through the SetMediaType
       interface function and then return it when GetMediaType is called. As
       we do no internal processing on it we leave it as a pointer */

    DWORD            m_dwFlags;         /* Flags for this sample */
                                        /* Type specific flags are packed
                                           into the top word
                                        */
    DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
    LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
    LONG             m_lActual;         /* Length of data in this sample */
    LONG             m_cbBuffer;        /* Size of the buffer */
    _A              *m_pAllocator;      /* The allocator who owns us */
    REFERENCE_TIME   m_Start;           /* Start sample time */
    REFERENCE_TIME   m_End;             /* End sample time */
    LONGLONG         m_MediaStart;      /* Real media start position */
    LONG             m_MediaEnd;        /* A difference to get the end */
    AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */

public:
    LONG             m_cRef;            /* Reference count */
    _S              *m_pNext;           /* Chaining in free list */


public:

    CAMMediaSampleImpl();

    ~CAMMediaSampleImpl()
    {
        if (m_pMediaType) {
    	    DeleteMediaType(m_pMediaType);
        }
    }

    /* Note the media sample does not delegate to its owner */

    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    void Init(_A *pAllocator)
    {
        m_pAllocator = pAllocator;
    }
    // set the buffer pointer and length. Used by allocators that
    // want variable sized pointers or pointers into already-read data.
    // This is only available through a CAMMediaSampleImpl* not an IMediaSample*
    // and so cannot be changed by clients.
    HRESULT SetPointer(BYTE * ptr, LONG cBytes)
    {
        m_pBuffer = ptr;            // new buffer area (could be null)
        m_cbBuffer = cBytes;        // length of buffer
        m_lActual = cBytes;         // length of data in buffer (assume full)

        return S_OK;
    }

    // Get me a read/write pointer to this buffer's memory.
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);

    STDMETHODIMP_(LONG) GetSize(void);

    // get the stream time at which this sample should start and finish.
    STDMETHODIMP GetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );

    // Set the stream time at which this sample should start and finish.
    STDMETHODIMP SetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);

    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);

    // these allow for limited format changes in band

    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);

    // returns S_OK if there is a discontinuity in the data (this same is
    // not a continuation of the previous stream of data
    // - there has been a seek).
    STDMETHODIMP IsDiscontinuity(void);
    // set the discontinuity property - TRUE if this sample is not a
    // continuation, but a new sample after a seek.
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);

    // get the media times for this sample
    STDMETHODIMP GetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set the media times for this sample
    STDMETHODIMP SetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set and get properties (IMediaSample2)
    STDMETHODIMP GetProperties(
        DWORD cbProperties,
        BYTE * pbProperties
    );

    STDMETHODIMP SetProperties(
        DWORD cbProperties,
        const BYTE * pbProperties
    );
};


//=====================================================================
//=====================================================================
// Defines CAMBaseAllocator
//
// Abstract base class that manages a list of media samples
//
// This class provides support for getting buffers from the free list,
// including handling of commit and (asynchronous) decommit.
//
// Derive from this class and override the Alloc and Free functions to
// allocate your CAMMediaSampleImpl (or derived) objects and add them to the
// free list, preparing them as necessary.
//=====================================================================
//=====================================================================

template <class _A, class _S>
class CAMBaseAllocator :
    public CComObjectRoot,
    public IMemAllocator     // The interface we support
{
protected:
    CCritSec m_Lock;

    friend class _A;
    typedef CAMBaseAllocator<_A, _S> _BaseAllocator;

    class CSampleList;
    friend class CSampleList;

    /*  Hack to get at protected member in _S */
    static _S *
        &NextSample(_S *pSample)
    {
        return pSample->m_pNext;
    }

    /*  Mini list class for the free list */
    class CSampleList
    {
    public:
        CSampleList() : m_List(NULL), m_nOnList(0) {};
#ifdef DEBUG
        ~CSampleList()
        {
            _ASSERTE(m_nOnList == 0);
        };
#endif
        _S *Head() const { return m_List; };
        _S *Next(_S *pSample) const { return NextSample(pSample); };
        int GetCount() const { return m_nOnList; };
        void Add(_S *pSample)
        {
            _ASSERTE(pSample != NULL);
            NextSample(pSample) = m_List;
            m_List = pSample;
            m_nOnList++;
        };
        _S *RemoveHead()
        {
            _S *pSample = m_List;
            if (pSample != NULL) {
                m_List = NextSample(m_List);
                m_nOnList--;
            }
            return pSample;
        };
        void Remove(_S *pSample);

    public:
        _S           *m_List;
        int           m_nOnList;
    };
protected:

    CSampleList m_lFree;        // Free list

    /*  Note to overriders of CAMBaseAllocator.

        We use a lazy signalling mechanism for waiting for samples.
        This means we don't call the OS if no waits occur.

        In order to implement this:

        1. When a new sample is added to m_lFree call NotifySample() which
           calls ReleaseSemaphore on m_hSem with a count of m_lWaiting and
           sets m_lWaiting to 0.
           This must all be done holding the allocator's critical section.

        2. When waiting for a sample call SetWaiting() which increments
           m_lWaiting BEFORE leaving the allocator's critical section.

        3. Actually wait by calling WaitForSingleObject(m_hSem, INFINITE)
           having left the allocator's critical section.  The effect of
           this is to remove 1 from the semaphore's count.  You MUST call
           this once having incremented m_lWaiting.

        The following are then true when the critical section is not held :
            (let nWaiting = number about to wait or waiting)

            (1) if (m_lFree.GetCount() != 0) then (m_lWaiting == 0)
            (2) m_lWaiting + Semaphore count == nWaiting

        We would deadlock if
           nWaiting != 0 &&
           m_lFree.GetCount() != 0 &&
           Semaphore count == 0

           But from (1) if m_lFree.GetCount() != 0 then m_lWaiting == 0 so
           from (2) Semaphore count == nWaiting (which is non-0) so the
           deadlock can't happen.
    */

    HANDLE m_hSem;              // For signalling
    long m_lWaiting;            // Waiting for a free element
    long m_lCount;              // how many buffers we have agreed to provide
    long m_lAllocated;          // how many buffers are currently allocated
    long m_lSize;               // agreed size of each buffer
    long m_lAlignment;          // agreed alignment
    long m_lPrefix;             // agreed prefix (preceeds GetPointer() value)
    BOOL m_bChanged;            // Have the buffer requirements changed

    // if true, we are decommitted and can't allocate memory
    BOOL m_bCommitted;
    // if true, the decommit has happened, but we haven't called Free yet
    // as there are still outstanding buffers
    BOOL m_bDecommitInProgress;

    // override to free the memory when decommit completes
    // - we actually do nothing, and save the memory until deletion.
    virtual void Free(void) = 0;

    // override to allocate the memory when commit called
    virtual HRESULT Alloc(void);

public:

    CAMBaseAllocator();
    ~CAMBaseAllocator();
    HRESULT FinalConstruct();

    BEGIN_COM_MAP(CAMBaseAllocator)
        COM_INTERFACE_ENTRY(IMemAllocator)
    END_COM_MAP()


    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    // return the properties actually being used on this allocator
    STDMETHODIMP GetProperties(
		    ALLOCATOR_PROPERTIES* pProps);

    // override Commit to allocate memory. We handle the GetBuffer
    //state changes
    STDMETHODIMP Commit();

    // override this to handle the memory freeing. We handle any outstanding
    // GetBuffer calls
    STDMETHODIMP Decommit();

    // get container for a sample. Blocking, synchronous call to get the
    // next free buffer (as represented by an IMediaSample interface).
    // on return, the time etc properties will be invalid, but the buffer
    // pointer and size will be correct. The two time parameters are
    // optional and either may be NULL, they may alternatively be set to
    // the start and end times the sample will have attached to it
    // bPrevFramesSkipped is not used (used only by the video renderer's
    // allocator where it affects quality management in direct draw).

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME * pStartTime,
                           REFERENCE_TIME * pEndTime,
                           DWORD dwFlags);

    // final release of a _SampleClass will call this
    STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);
    // obsolete:: virtual void PutOnFreeList(_SampleClass * pSample);

    // Notify that a sample is available
    void NotifySample();

    // Notify that we're waiting for a sample
    void SetWaiting() { m_lWaiting++; };
};

template < class _A >
class CAMMediaSample : public CAMMediaSampleImpl< CAMMediaSample<_A>, _A >
{
public:
    CAMMediaSample() {}
};

//=====================================================================
//=====================================================================
// Defines CAMMemAllocator
//
// this is an allocator based on CAMBaseAllocator that allocates sample
// buffers in main memory (from 'new'). You must call SetProperties
// before calling Commit.
//
// we don't free the memory when going into Decommit state. The simplest
// way to implement this without complicating CAMBaseAllocator is to
// have a Free() function, called to go into decommit state, that does
// nothing and a ReallyFree function called from our destructor that
// actually frees the memory.
//=====================================================================
//=====================================================================

class CAMMemAllocator :
    public CAMBaseAllocator< CAMMemAllocator,
                             CAMMediaSample<CAMMemAllocator> >
{
protected:

    LPBYTE m_pBuffer;   // combined memory for all buffers

    // override to free the memory when decommit completes
    // - we actually do nothing, and save the memory until deletion.
    void Free(void);

    // called from the destructor (and from Alloc if changing size/count) to
    // actually free up the memory
    void ReallyFree(void);

    // overriden to allocate the memory when commit called
    HRESULT Alloc(void);

public:

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    CAMMemAllocator();
    ~CAMMemAllocator();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\tmsparse.h ===
#ifndef _TMSPARSE_H_
#define _TMSPARSE_H_

// Delimiters in the TMS file format
//
#define BOH '<'
#define EOH '>'
#define EOC 0x7C
#define EOR 0x0A
#define EOT 0x0D
#define EOL 0x2C
#define ENC 0x22


#define MAX_FIELD_SIZE   255
#define MAX_RECORD_SIZE  32535 
#define VerifyRange(APos, BPos)   (APos < BPos)


#define MAX_STATIONS 9999
#define MAX_CHANNELS 999


typedef struct SDataFileFields
{
   BOOL bRequired;
   int  nWidth;
} *PSDataFileFields;


enum MSEPGHeader
{
EPGHeader_Date,
EPGHeader_UserID,
EPGHeader_HeadEndID,
EPGHeader_Fields
};

// Different states of record processing
//
#define STATE_RECORDS_INIT       0x0000
#define STATE_RECORD_INCOMPLETE  0x0001
#define STATE_RECORDS_INCOMPLETE 0x0002
#define STATE_RECORDS_PROCESSED  0x0004
#define STATE_RECORDS_NONE       0x0008
#define STATE_RECORD_ERROR       0x0010
#define STATE_RECORDS_FAIL       0x0020 

typedef CMap<int, int, CString, CString> CRecordMap;
typedef CMap<long, long, CString, CString> CGenreIDMap;


// CRecordProcessor: Abstract base class for record processing; Manages parsing
//                   of file records and insertion into the database
//
class CRecordProcessor
{
public:

    //CRecordProcessor(int nNumFields, SDataFileFields ssfFieldsInfo[], int nBulk=0);
    //CRecordProcessor(int nBulk=0);
    
	virtual void     m_Init()
	{
        m_nState = STATE_RECORDS_INIT;
        m_nError = 0;
        m_nMaxRecordSize = 0;
        m_nCurrField = 0;
        m_nCurrFieldSize = 0;
        m_nCurrRecord = 0;
        m_nNumFields = 0;

	}
    virtual int      m_Process(LPCTSTR lpData, int nDataSize, int* pBytesProcessed) = 0;
	virtual int      m_UpdateDatabase(CRecordMap& cmRecord) = 0;
	virtual int      m_GetState() = 0;
    virtual int      m_GetError() = 0;
	virtual int      m_GetErrorString(CString&) = 0;

protected:
	
	void             m_SetState(int nState) { m_nState = nState; }

	int              m_nState;
	int              m_nError;
	int              m_nMaxRecordSize;
	int              m_nCurrField;
	int              m_nCurrFieldSize;
	int              m_nCurrRecord;
	int              m_nNumFields;
	TCHAR            m_szValidField[MAX_FIELD_SIZE];
    
	PSDataFileFields m_pFieldsDesc;
	CRecordMap  m_cmRecordMap;
};


class CHeaderRecordProcessor : public CRecordProcessor
{
public:

    CHeaderRecordProcessor(int nNumFields, 
		                    SDataFileFields ssfFieldsInfo[]);
    CHeaderRecordProcessor();

    int      m_Process(LPCTSTR lpData, int nDataSize, int* pBytesProcessed);
	int      m_UpdateDatabase(CRecordMap& cmRecord);
	int      m_GetState();
    int      m_GetError();
	int      m_GetErrorString(CString&);
};


#define DATA_PROCESS_INIT      0x0001
#define DATA_STATREC_PROCESS   0x0002
#define DATA_CHAREC_PROCESS    0x0003
#define DATA_EPIREC_PROCESS    0x0004  
#define DATA_TIMREC_PROCESS    0x0005
#define DATA_UPDATE_ERROR      0x0006
#define DATA_PROCESSED         0x0007

// CRecordProcessor: Handles the processing of the MS guide data file
//                   Maintains current state and bytes processed
//
class CDataFileProcessor
{
public:

    CDataFileProcessor();

    int      m_Process(LPCTSTR lpData, int nDataSize);
	int      m_GetState();
    int      m_GetError();
	int      m_GetErrorString(CString&);

private:

	int                       m_nState;
	int                       m_nError; 
	int                       m_nCurrBlockSize;
	int                       m_nBytesProceesed;

	//CStationRecordProcessor   m_srpStations;
    //CChannelRecordProcessor   m_crpChannels;
    //CEpisodeRecordProcessor   m_erpEpisodes;
    //CTimeSlotRecordProcessor  m_trpTimeSlots;
};

#endif // _TMSPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\checkbmi.h ===
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _CHECKBMI_H_
#define _CHECKBMI_H_

#ifdef __cplusplus
extern "C" {
#endif

//  Helper
inline BOOL MultiplyCheckOverflow(DWORD a, DWORD b, DWORD *pab) {
    *pab = a * b;
    if ((a == 0) || (((*pab) / a) == b)) {
        return TRUE;
    }
    return FALSE;
}


//  Checks if the fields in a BITMAPINFOHEADER won't generate
//  overlows and buffer overruns
//  This is not a complete check and does not guarantee code using this structure will be secure
//  from attack
//  Bugs this is guarding against:
//        1.  Total structure size calculation overflowing
//        2.  biClrUsed > 256 for 8-bit palettized content
//        3.  Total bitmap size in bytes overflowing
//        4.  biSize < size of the base structure leading to accessessing random memory
//        5.  Total structure size exceeding know size of data
//

inline BOOL ValidateBitmapInfoHeader(
    const BITMAPINFOHEADER *pbmi,   // pointer to structure to check
    DWORD cbSize                    // size of memory block containing structure
)
{
    DWORD dwWidthInBytes;
    DWORD dwBpp;
    DWORD dwWidthInBits;
    DWORD dwHeight;
    DWORD dwSizeImage;
    DWORD dwClrUsed;

    // Reject bad parameters - do the size check first to avoid reading bad memory
    if (cbSize < sizeof(BITMAPINFOHEADER) ||
        pbmi->biSize < sizeof(BITMAPINFOHEADER) ||
        pbmi->biSize > 4096) {
        return FALSE;
    }

    // Use bpp of 32 for validating against further overflows if not set for compressed format
    dwBpp = 32;

    // Strictly speaking abs can overflow so cast explicitly to DWORD
    dwHeight = (DWORD)abs(pbmi->biHeight);

    if (!MultiplyCheckOverflow(dwBpp, (DWORD)pbmi->biWidth, &dwWidthInBits)) {
        return FALSE;
    }

    //  Compute correct width in bytes - rounding up to 4 bytes
    dwWidthInBytes = (dwWidthInBits / 8 + 3) & ~3;

    if (!MultiplyCheckOverflow(dwWidthInBytes, dwHeight, &dwSizeImage)) {
        return FALSE;
    }

    // Fail if total size is 0 - this catches indivual quantities being 0
    // Also don't allow huge values > 1GB which might cause arithmetic
    // errors for users
    if (dwSizeImage > 0x40000000 ||
        pbmi->biSizeImage > 0x40000000) {
        return FALSE;
    }

    //  Fail if biClrUsed looks bad
    if (pbmi->biClrUsed > 256) {
        return FALSE;
    }

    if (pbmi->biClrUsed == 0 && dwBpp <= 8) {
        dwClrUsed = (1 << dwBpp);
    } else {
        dwClrUsed = pbmi->biClrUsed;
    }

    //  Check total size
    if (cbSize < pbmi->biSize + dwClrUsed * sizeof(RGBQUAD) +
                 (pbmi->biCompression == BI_BITFIELDS ? 3 * sizeof(DWORD) : 0)) {
        return FALSE;
    }

    return TRUE;
}

#ifdef __cplusplus
}
#endif

#endif // _CHECKBMI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\amutil.h ===
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
/*  Dynamic arrays */

#ifndef __AMUTIL_H__
#define __AMUTIL_H__

/*  Dynamic array support */
template <class _TInterface, class _TArray>
class CDynamicArray
{
public:
    CDynamicArray(int iIncrement) : m_pArray(NULL),
                      m_nElements(0),
                      m_iIncrement(iIncrement),
                      m_nSize(0) {}
    CDynamicArray() : m_pArray(NULL),
                      m_nElements(0),
                      m_iIncrement(4),
                      m_nSize(0) {}
    ~CDynamicArray() { delete [] m_pArray; }

    _TInterface Element(int i) const {
        _ASSERTE(i < m_nElements);
        return m_pArray[i];
    }

    _TInterface operator [] (int i)
    {
        return m_pArray[i];
    }

    int Size() const {
        return m_nElements;
    }

    BOOL Add(_TInterface Element)
    {
        _ASSERTE(m_nSize >= m_nElements);
        if (m_nSize == m_nElements) {
            _TArray *pNewArray = new _TArray[m_nSize + m_iIncrement];
            if (pNewArray == NULL) {
                return FALSE;
            }
            for (int i = 0; i < m_nElements; i++) {
                pNewArray[i] = m_pArray[i];
            }
            delete [] m_pArray;
            m_pArray = pNewArray;
            m_nSize = m_nSize + m_iIncrement;
        }
        m_pArray[m_nElements++] = Element;
        return TRUE;
    }
    BOOL Remove(_TInterface Element)
    {
        for (int i = 0; m_pArray[i] != Element; i++ ) {
            if (i >= m_nElements) {
                return FALSE;
            }
        }
        Remove(i);
        return TRUE;
    }
    void Remove(int i)
    {
        _ASSERTE(i < m_nElements);
        m_nElements--;
        for (; i < m_nElements; i++) {
            m_pArray[i] = m_pArray[i + 1];
        }
        m_pArray[m_nElements] = NULL;
    }
    void RemoveAll()
    {
        for (int i = 0; i < m_nElements; i++) {
            m_pArray[i] = NULL;
        }
        m_nElements = 0;
    }

private:
    _TArray   *m_pArray;
    int       m_nSize;
    int       m_nElements;
    const int m_iIncrement;
};

template <class Base, const IID *piid, class T>
class CAMEnumInterfaceImpl :
    public Base,
    public CDynamicArray<T*, CComPtr<T> >
{
public:
    CAMEnumInterfaceImpl() : m_iter(0) {}

    /*  The actual interface we support */
    STDMETHOD(Next)(ULONG celt, T** rgelt, ULONG* pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)(void){m_iter = 0;return S_OK;}
    STDMETHOD(Clone)(Base** ppEnum);

    int m_iter;
};

template <class Base, const IID* piid, class T>
STDMETHODIMP CAMEnumInterfaceImpl<Base, piid, T>::Next(ULONG celt, T** rgelt,
    ULONG* pceltFetched)
{
    if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
        return E_POINTER;
    ULONG nRem = (ULONG)(Size() - m_iter);
    HRESULT hRes = S_OK;
    if (nRem < celt)
        hRes = S_FALSE;
    ULONG nMin = min(celt, nRem);
    if (pceltFetched != NULL)
        *pceltFetched = nMin;
    while(nMin--) {
        Element(m_iter)->AddRef();
        *(rgelt++) = Element(m_iter++);
    }
    return hRes;
}

template <class Base, const IID* piid, class T>
STDMETHODIMP CAMEnumInterfaceImpl<Base, piid, T>::Skip(ULONG celt)
{
    m_iter += celt;
    if (m_iter < Size())
        return S_OK;
    m_iter = Size();
    return S_FALSE;
}

template <class Base, const IID* piid, class T>
STDMETHODIMP CAMEnumInterfaceImpl<Base, piid, T>::Clone(Base** ppEnum)
{
    typedef CComObject<CAMEnumInterface<Base, piid, T> > _class;
    HRESULT hRes = E_POINTER;
    if (ppEnum != NULL)
    {
        _class* p = NULL;
        ATLTRY(p = new _class)
        if (p == NULL)
        {
            *ppEnum = NULL;
            hRes = E_OUTOFMEMORY;
        }
        else
        {
            for (int i = 0; i < Size(); i++) {
                if (!p->Add(Element(i))) {
                    break;
                }
            }
            if (i != Size()) {
                delete p;
                hRes = E_OUTOFMEMORY;
                *ppEnum = NULL;
            }
            else
            {
                p->m_iter = m_iter;
                hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
                if (FAILED(hRes))
                    delete p;
            }
        }
    }
    return hRes;
}

template <class Base, const IID* piid, class T>
class CAMEnumInterface : public CAMEnumInterfaceImpl<Base, piid, T>, public CComObjectRoot
{
public:
    typedef CComObjectRoot _BaseClass ;
    typedef CAMEnumInterface<Base, piid, T> _CComEnum;
    typedef CAMEnumInterfaceImpl<Base, piid, T> _CComEnumBase;

#ifdef DEBUG
    ULONG InternalAddRef()
    {
        return _BaseClass::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return _BaseClass::InternalRelease();
    }
#endif
    BEGIN_COM_MAP(_CComEnum)
        COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
    END_COM_MAP()
};

#ifndef __WXUTIL__

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

public:
    CCritSec() {
	InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
	DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
	EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
	LeaveCriticalSection(&m_CritSec);
    };
};

// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};

// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoObjectLock {

    // make copy constructor and assignment operator inaccessible

    CAutoObjectLock(const CAutoObjectLock &refAutoLock);
    CAutoObjectLock &operator=(const CAutoObjectLock &refAutoLock);

protected:
    CComObjectRoot * m_pObject;

public:
    CAutoObjectLock(CComObjectRoot * pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define AUTO_CRIT_LOCK CAutoObjectLock lck(this);

#ifdef _DEBUG
#define EXECUTE_ASSERT(_x_) _ASSERTE(_x_)
#else
#define EXECUTE_ASSERT(_x_) _x_
#endif


#endif

#endif // __AMUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\comint.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
//
// comint.h
//

#ifndef __CCOMINT__
#define __CCOMINT__

#pragma warning( disable : 4290 )	// warning C4290: C++ Exception Specification ignored


// CCOMInt
//
// A class to manage COM interfaces - AddRef's in its constructor
// and releases in the destructor.
// It is intended to provide the same automatic releasing that CAutoLock
// provides for critical sections.
//
// Provides an overloaded dereferenceing operator for calling interface members.
//
// a typical use would be:
// CCOMInt<IMediaControl> IMC(IID_IMediaContol, punk);
//
// IMC->Run();
//
// I don't think this class is useful as a _complete_ replacement of
// interface pointers, for two reasons:
//   - using heap allocated objects (if you want a lifetime longer than the scope)
//     has some ugly syntax:
//     CCOMInt<IPersist> *pIPer = new CCOMInt<IPersist>(IID_IPersist, pSomeInt);
//
//     (*pIPer)->GetClassID()	// YUK!
//
//     In this context I'm not sure how useful the CoCreate'ing constructor is...
//
//   - constructing these objects from functions that give you addref'd interfcaces
//     is inconvienent
//
//     IStream *pStrm;
//     hr = pStorage->CreateStream(, , , &pStrm);
//     if (FAILED(hr)) {
//         // do something appropriate
//     }
//     CCOMInt<IStream> IStrm(pStrm);
//     pStrm->Release();
//
//     [...use IStrm...]
//
//
//   If you want to use this you need to add the following to you compiler
//   options:
//
//   you must #define:	 _INC_EXCPT
//   and add the switch: -GX
//
//   NB: this file uses the exception classes defined in hrExcept.h


//
// CCOMInt
//
template<class I>
class CCOMInt {
public:

    // -- Constructors --

    // CoCreate
    CCOMInt<I>( REFIID    riid					// get this interface
              , REFCLSID  rclsid				// get the interface
    								// from this object
	      , LPUNKNOWN pUnkOuter    = NULL			// controlling unknown
              , DWORD     dwClsContext = CLSCTX_INPROC_SERVER	// CoCreate options
               							// default is suitable
               							// for dll servers
              )
              throw (CHRESULTException) {
#ifdef NOCOMLITE
        HRESULT hr = CoCreateInstance( rclsid
	                             , pUnkOuter
                                     , dwClsContext
                                     , riid
                                     , (void **) &m_pInt
                                     );
#else
        HRESULT hr = QzCreateFilterObject( rclsid
	                             , pUnkOuter
                                     , dwClsContext
                                     , riid
                                     , (void **) &m_pInt
                                     );
#endif
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // QueryInterface
    CCOMInt<I>( REFIID   riid	// get this interface
              , IUnknown *punk	// from this interface
              )
              throw (CHRESULTException) {

        HRESULT hr = punk->QueryInterface(riid, (void **) &m_pInt);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // copy
    CCOMInt<I>(const CCOMInt<I> &com)
        throw () {

// #ifdef USE_MSVC20
         m_pInt = com;
// #else
//          m_pInt = const_cast<I*>(com);   // new ANSI C++ in VC40
// #endif
         (*this)->AddRef();
    }

    // existing pointer.
    CCOMInt<I>(I *pInt)
        throw (CHRESULTException) {
        if (pInt == NULL) {
            throw CHRESULTException(E_NOINTERFACE);
        }

        m_pInt = pInt;

	(*this)->AddRef();
    }


    // assignment operator
    CCOMInt<I>& operator = (const CCOMInt<I> &com)
        throw () {

        if (this != &com) { 	// not i = i

	    (*this)->Release();
// #ifdef USE_MSVC20
            m_pInt = com;
// #else
//             m_pInt = const_cast<I*>(com); // new ANSI C++ in VC40
// #endif
            (*this)->AddRef();
	}

        return *this;
    }


    // destructor
    ~CCOMInt<I>()
        throw () {
        m_pInt->Release();
    }


    // -- comparison operators --
    BOOL operator == (IUnknown *punk)

#ifdef USE_MSVC20
        throw(CHRESULTException) const
#else
        const throw (CHRESULTException)
#endif
    {
        CCOMInt<IUnknown> IUnk1(IID_IUnknown, punk);
        CCOMInt<IUnknown> IUnk2(IID_IUnknown, *this);

        return ( ((IUnknown *)IUnk1) == ((IUnknown *)IUnk2) );
    }

    BOOL operator != (IUnknown *punk)
#ifdef USE_MSVC20
        throw(CHRESULTException) const
#else
        const throw (CHRESULTException)
#endif
    {
        return !(*this == punk);
    }


    // cast to interface pointer
    operator I *()
#ifdef USE_MSVC20
        throw() const
#else
        const throw ()
#endif
        {
            return m_pInt;
        }


    // dereference
    I *operator->()
#ifdef USE_MSVC20
        throw() const
#else
        const throw ()
#endif
    {
        return m_pInt;
    }

    I &operator*()
#ifdef USE_MSVC20
        throw() const
#else
        const throw ()
#endif
    {
        return *m_pInt;
    }

private:

    I *m_pInt;

    // array dereferencing seems to make no sense.
    I &operator[] (int i)

#ifdef USE_MSVC20
        throw(CHRESULTException) const
#else
        const throw (CHRESULTException)
#endif
    {
        throw CHRESULTException();
        return *m_pInt;
    }
};


#endif // __CCOMINT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\wtmsload.cpp ===
// wtmsload.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "errcodes.h"
#include <Afxtempl.h>
#include "guidestore.h"
#include "services.h"
#include "channels.h"
#include "programs.h"
#include "schedules.h"
#include "tmsparse.h"
#include "servchan.h"
#include "progschd.h"
#include "wtmsload.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CWtmsloadApp

BEGIN_MESSAGE_MAP(CWtmsloadApp, CWinApp)
	//{{AFX_MSG_MAP(CWtmsloadApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWtmsloadApp construction

CWtmsloadApp::CWtmsloadApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWtmsloadApp object

CWtmsloadApp theApp;


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: InitProcessors
//
//  PARAMETERS: [IN] VOID
//
//  PURPOSE: Instantiates the guide data record processors (parsers)
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG CWtmsloadApp::InitProcessors(VOID)
{
	ULONG ulRet = ERROR_FAIL;
	// Open the processors
	//
	// TODO: Exeception handler
	//
	m_DataFile      = new CDataFileProcessor;
	if (NULL == m_DataFile)
	{
		goto Open_Exit;
	}

	m_srpHeaders    = new CHeaderRecordProcessor;
	if (NULL == m_srpHeaders)
	{
		goto Open_Exit;
	}


    m_scrpStatChans = new CStatChanRecordProcessor;
	if (NULL == m_scrpStatChans)
	{
		goto Open_Exit;
	}


	m_etEpTs = new CEpisodeTimeSlotRecordProcessor;
	if (NULL == m_etEpTs)
	{
		goto Open_Exit;
	}

    ulRet = INIT_SUCCEEDED;

Open_Exit:

	return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: CloseProcessors
//
//  PARAMETERS: [IN] VOID
//
//  PURPOSE: Frees the guide data record processors (parsers)
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
void CWtmsloadApp::CloseProcessors(VOID)
{
	// close the processors
	//
	// TODO: Exeception handler
	//
	
	if (NULL != m_DataFile)
	{
		delete m_DataFile;      
		m_DataFile = NULL;
	}

	if (NULL != m_scrpStatChans)
	{
		delete m_scrpStatChans; 
		m_scrpStatChans = NULL;
	}

	if (NULL != m_srpHeaders)
	{
		delete	m_srpHeaders;
		m_srpHeaders = NULL;
	}

	if (NULL != m_etEpTs)
	{
		delete m_etEpTs;
		m_etEpTs = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: OpenGuideStore
//
//  PARAMETERS: [IN] lpGuideStoreDB - the Guide Store DB File
//
//  PURPOSE: Opens the Guide Store - 
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG CWtmsloadApp::OpenGuideStore(LPCTSTR lpGuideStoreDB)
{
	return m_gsp.Init(lpGuideStoreDB);
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: GetGuideStoreInterfaces
//
//  PARAMETERS: [IN] VOID
//
//  PURPOSE: Gets all the Guide Store Interfaces needed by the loader 
//           to import guide data into the store
//           1. Initializes Services collection and related props
//           2. Initializes ChannelLineups collection and related props
//           3. Initializes Programs collection and related props
//           4. Initializes ScheduleEntries collection and related props
//           NOTE: The Channels collection and related properties 
//           are initialized afer the ChannelLineup has been set 
//           (tmsparse.cpp)
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG CWtmsloadApp::GetGuideStoreInterfaces(VOID)
{
	IGuideStorePtr pGuideStore = m_gsp.GetGuideStorePtr();
    ULONG          ulRet       = ERROR_FAIL;
	

    if (NULL != pGuideStore)
	{
		// Initialize the services collection
		//
        ulRet = m_pgsServices.Init(pGuideStore);
		if (INIT_SUCCEEDED != ulRet)
		{
            goto Get_Exit;
		}

		// Initialize the ChannelLineups collection
		//
        ulRet = m_pgsChannelLineups.Init(pGuideStore);
		if (INIT_SUCCEEDED != ulRet)
		{
            goto Get_Exit;
		}

		// Initialize the Programs collection
		//
        ulRet = m_pgsPrograms.Init(pGuideStore);
		if (INIT_SUCCEEDED != ulRet)
		{
            goto Get_Exit;
		}

		// Initialize the ScheduleEntries collection
		//
        ulRet = m_pgsScheduleEntries.Init(pGuideStore);
		if (INIT_SUCCEEDED != ulRet)
		{
            goto Get_Exit;
		}
	}

Get_Exit:

	return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: Init
//
//  PARAMETERS: [IN] lpGuideStoreDB - Guide Store DB File
//
//  PURPOSE: Performs initializations for the import 
//           1. Setups the timezone adjustments
//           2. Opens the Guide data file processors (parsers)
//           3. Opens the guide store 
//           4. Sets the Guide store interfaces
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG CWtmsloadApp::InitImport(LPCTSTR lpGuideStoreDB)
{
    ULONG                 ulRet = ERROR_FAIL;
    TIME_ZONE_INFORMATION tzi;
    DWORD                 tzrc;

    // incoming data is all gmt. set up app class time info
    // for conversions
	//
    tzrc = ::GetTimeZoneInformation(&tzi);

    CTimeSpan bias(0, 0, tzi.Bias, 0);
    switch (tzrc)
	{
    case TIME_ZONE_ID_UNKNOWN:
#ifdef _DEBUG
            afxDump << "Time Zone Info not set on this machine.\r\nAll db times will be in UTC\r\n";
#endif
        break;
    case TIME_ZONE_ID_DAYLIGHT:
        {
           CTimeSpan temp(0, 0, tzi.DaylightBias, 0);
           bias += temp;
        }
        break;
    case TIME_ZONE_ID_STANDARD:
        {
            CTimeSpan temp(0, 0, tzi.StandardBias, 0);
            bias += temp;
        }
        break;
    default:
    	return 1; 
        break;
    }

	// Set the time zone adjustments
	//
    m_odtsTimeZoneAdjust.SetDateTimeSpan(bias.GetDays(), bias.GetHours(), bias.GetMinutes(), bias.GetSeconds());

	// Guide store Start time - init to invalid
	//
	m_codtGuideStartTime.SetStatus(COleDateTime::invalid);

	// Guide store End time - init to invalid
	//
	m_codtGuideEndTime.SetStatus(COleDateTime::invalid);

	// Open the guide data file parsers
	//
    ulRet = InitProcessors();
    if (INIT_SUCCEEDED != ulRet)
	{
		goto INIT_EXIT;
	}

	// Open the guide store
	//
    ulRet = OpenGuideStore(lpGuideStoreDB);
    if (INIT_SUCCEEDED == ulRet)
	{
		// Get the guide store interfaces
		//
	    ulRet = GetGuideStoreInterfaces();
	}

INIT_EXIT:

	return ulRet;
}


void CWtmsloadApp::ExitImport(void)
{
	// Cleanup Processing data objects
	//
    CloseProcessors();
}


ULONG CWtmsloadApp::ProcessInput(LPCTSTR lpGuideDataFile)
{
	ULONG  ulRet = IMPORT_SUCCEEDED;
    CDataFileProcessor cdfGuideDataProcessor;

// TODO: Profile
    COleDateTime m_odtStart(COleDateTime::GetCurrentTime());
    m_covNow = m_odtStart + m_odtsTimeZoneAdjust;
	

	HANDLE hFile = CreateFile(lpGuideDataFile, GENERIC_READ, 0,
								NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN,	NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
#ifdef _DEBUG
		afxDump << "\r\nCreateFile failed: " << GetLastError() << "\r\n";
#endif
		return ERROR_FILE_OPEN; 
	}
		
	// Try to get the file's modification time.  If we can't then just use
	// the current time
	FILETIME ftModificationTime;
	if (GetFileTime(hFile, NULL, NULL, &ftModificationTime))
	{
		CTime ctModificationTime = CTime(ftModificationTime);
	}
	else
	{
		CTime ctCurrentTime = CTime::GetCurrentTime();

#ifdef _DEBUG
		afxDump << "\r\nGetFileTime failed: " << GetLastError() << "\r\n";
#endif
	}

	HANDLE hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

	SYSTEM_INFO si;
	GetSystemInfo(&si);

	BYTE *pbFile         = NULL;
	DWORD dwBytesInBlock = 0;
    int     nUpdateErr   = ERROR_FAIL;
// TODO: Profile
	if (hFileMapping == NULL)
	{
		// do regular I/O
		BOOL	fReadResult;

		pbFile = new BYTE[si.dwAllocationGranularity];

		do
		{
           
			// Attempt to read the file
			//
			fReadResult = ReadFile(hFile, pbFile,
									si.dwAllocationGranularity, &dwBytesInBlock, NULL);

#ifdef _DUMP_LOADER
			wsprintf(szDiagBuff, "Writing Guide Data: %d\r\n", dwBytesInBlock);
			if (NULL != hDiagFile)
			{
				WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
			}
#endif
			if (0 < dwBytesInBlock)
			{
	            // Parse the guide data file and update the store
	            //
			    nUpdateErr = cdfGuideDataProcessor.m_Process((LPCTSTR) pbFile, dwBytesInBlock);

				if (STATE_RECORDS_FAIL == nUpdateErr)
				{
					ulRet = ERROR_STORE_UPDATE;
					break;
				}
			}
		}
		while (fReadResult && dwBytesInBlock);

		delete[] pbFile;
	}
	else
	{
		// do memory-mapped file I/O
		
		DWORD dwFileSizeHigh;
		__int64 qwFileSize = GetFileSize(hFile, &dwFileSizeHigh);
		qwFileSize += (((__int64) dwFileSizeHigh) << 32);

		__int64 qwFileOffset = 0;

		while (0 < qwFileSize)
		{

			if (qwFileSize < si.dwAllocationGranularity)
				dwBytesInBlock = (DWORD) qwFileSize;
			else
				dwBytesInBlock = si.dwAllocationGranularity;

			pbFile = (BYTE *) MapViewOfFile(hFileMapping, FILE_MAP_READ,
										(DWORD) (qwFileOffset >> 32),
										(DWORD) (qwFileOffset & 0xFFFFFFFF),
										dwBytesInBlock);

			if (NULL != pbFile)
			{
#ifdef _DUMP_LOADER
				wsprintf(szDiagBuff, "Writing Guide Data: %d\r\n", dwBytesInBlock);
				if (NULL != hDiagFile)
				{
					WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
				}
#endif
	            // Parse the guide data file and update the store
	            //
                nUpdateErr = cdfGuideDataProcessor.m_Process((LPCTSTR) pbFile, dwBytesInBlock);

				if (STATE_RECORDS_FAIL == nUpdateErr)
				{
					ulRet = ERROR_STORE_UPDATE;
					break;
				}

				UnmapViewOfFile(pbFile);
			} 

			qwFileOffset += dwBytesInBlock;
			qwFileSize -= dwBytesInBlock;
		}

		CloseHandle(hFileMapping);
	}
// TODO: Profile

	CloseHandle(hFile);

// TODO: Profile
	return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: ImportProgramListings 
//
//  PARAMETERS: [IN] lpGuideDataFile - The input guide data file
//              [IN] lpGuideStoreDB  - The Guide Store DB file
//
//  PURPOSE: ImportProgramListings Performs the following tasks:
//           1. Initializes the import by opening the GuideStore 
//              and setting up all the primary interfaces
//           2. Starting the import of the guide data file into the
//              GuideStore
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG ImportProgramListings(LPCTSTR lpGuideDataFile, LPCTSTR lpGuideStoreDB)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ULONG      ulRet = S_OK;

    if (NULL == lpGuideDataFile)
	{
        return ERROR_INVALID_PARAMETER;
	}

	// Initialize the import
	//
    ulRet = theApp.InitImport(lpGuideStoreDB);

	if (INIT_SUCCEEDED == ulRet)
	{
		// Import all the program guide records into the
		// guide store
		//
		ulRet = theApp.ProcessInput(lpGuideDataFile);
	}

	return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\decibels.h ===
//--------------------------------------------------------------------------;
//
//  File: decibels.cpp
//
//  Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//       utilities for converting volume/pan in decibel units to/from
//       the 0-0xffff (0-1000) range used by waveOutSetVolume (MCI) etc
//
//  Contents:
//
//  History:
//      06/15/95	SteveDav    plagiarised from Direct Sound
//
//--------------------------------------------------------------------------;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef _AMOVIE_DB_
#define AMOVIEAPI_DB   DECLSPEC_IMPORT
#else
#define AMOVIEAPI_DB
#endif

AMOVIEAPI_DB LONG WINAPI AmpFactorToDB( DWORD dwFactor );
AMOVIEAPI_DB DWORD WINAPI DBToAmpFactor( LONG lDB );

#ifdef __cplusplus
}
#endif // __cplusplus

#define AX_MIN_VOLUME -10000
#define AX_QUARTER_VOLUME -1200
#define AX_HALF_VOLUME -600
#define AX_THREEQUARTERS_VOLUME -240
#define AX_MAX_VOLUME 0

#define AX_BALANCE_LEFT -10000
#define AX_BALANCE_RIGHT 10000
#define AX_BALANCE_NEUTRAL 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\dynlink.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef __DYNLINK_H__
#define __DYNLINK_H__

// Add DYNLINKAVI to the class definition statement
// for all classes that use AVI/VFW function
// to enable dynamic linking to AVI.  That, and #includ'ing this file
// should be the only thing you need to do
//
// For example:
//    class CAVIDec : public CTransformFilter   DYNLINKAVI   DYNLINKVFW
//
// In the case where the filter is being built into its own DLL dynamic
// linking is not enabled and DYNLINKAVI is #define'd to nothing.
//
// If the class in which you want to use dynamic linking does not
// inherit from anything else use _DYNLINKAVI or _DYNLINKVFW
//
// For example:
//    class CNoInherit : _DYNLINKAVI
// or
//    class CNoInherit : _DYNLINKVFW
// or
//    class CNoInterit : _DYNLINKVFW    DYNLINKAVI  //etc...
//

#define NODRAWDIB
#define NOAVIFMT
#include <vfw.h>		// we need the avi definitions
#include <urlmon.h>

#ifdef FILTER_DLL

#define DYNLINKAVI
#define DYNLINKVFW
#define DYNLINKACM
#define DYNLINKURLMON
#define _DYNLINKAVI
#define _DYNLINKVFW
#define _DYNLINKACM
#define _DYNLINKURLMON
#else

// Add DYNLINKAVI at the end of the class definition statement
// for all classes that use AVI/VFW function
// to enable dynamic linking to AVI.  That, and #includ'ing this file
// should be the only thing you need to do

// define string that will bind dynamic linking to the class definition
#define DYNLINKAVI  , CAVIDynLink
#define DYNLINKVFW  , CVFWDynLink
#define DYNLINKACM  , CACMDynLink
#define DYNLINKURLMON , CURLMonDynLink

// for those classes that have no inheritance and still want dynamic linking
#define _DYNLINKAVI  CAVIDynLink
#define _DYNLINKVFW  CVFWDynLink
#define _DYNLINKACM  CACMDynLink
#define _DYNLINKURLMON CURLMonDynLink

//
// typedef the AVIFILE API set that we redirect
//

typedef HRESULT  (STDAPICALLTYPE *pAVIFileOpenW )(PAVIFILE FAR * ppfile, LPCWSTR szFile, UINT uMode, LPCLSID lpHandler);
typedef HRESULT  (STDAPICALLTYPE *pAVIStreamRead)(PAVISTREAM pavi, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, LONG FAR * plBytes, LONG FAR * plSamples);
typedef LONG     (STDAPICALLTYPE *pAVIStreamStart)       (PAVISTREAM pavi);
typedef LONG     (STDAPICALLTYPE *pAVIStreamLength)      (PAVISTREAM pavi);
typedef LONG     (STDAPICALLTYPE *pAVIStreamTimeToSample)(PAVISTREAM pavi, LONG lTime);
typedef LONG     (STDAPICALLTYPE *pAVIStreamSampleToTime)(PAVISTREAM pavi, LONG lSample);
typedef HRESULT  (STDAPICALLTYPE *pAVIStreamBeginStreaming)(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate);
typedef HRESULT  (STDAPICALLTYPE *pAVIStreamEndStreaming)(PAVISTREAM pavi);
typedef LONG     (STDAPICALLTYPE *pAVIStreamFindSample)(PAVISTREAM pavi, LONG lPos, LONG lFlags);

#undef AVIStreamEnd  // sigh... nasty AVI macro

//
// Class to link dynamically to AVIFIL32.DLL entry points
//

class CAVIDynLink {

private:
    static HMODULE m_hAVIFile32;  	// handle to AVIFIL32
    static LONG    m_dynlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadAVILock;      // serialise constructor/destructor

public:
    static  void  CAVIDynLinkLoad() {
	InitializeCriticalSection(&CAVIDynLink::m_LoadAVILock);      // serialise constructor/destructor
    }
    static  void  CAVIDynLinkUnload() {
	DeleteCriticalSection(&CAVIDynLink::m_LoadAVILock);      // serialise constructor/destructor
    }

    static  void  AVIFileInit(void);
    static  void  AVIFileExit(void);
    static  HRESULT  AVIFileOpenW       (PAVIFILE FAR * ppfile, LPCWSTR szFile,
			  UINT uMode, LPCLSID lpHandler);

    static HRESULT  AVIStreamRead(PAVISTREAM pavi,
    		      LONG lStart,
    		      LONG lSamples,
    		      LPVOID lpBuffer,
    		      LONG cbBuffer,
    		      LONG FAR * plBytes,
    		      LONG FAR * plSamples)
    {
    return(pavi->Read(lStart, lSamples, lpBuffer, cbBuffer, plBytes, plSamples));
    }

    static LONG  AVIStreamStart(PAVISTREAM pavi)
    {
        AVISTREAMINFOW aviStreamInfo;
        HRESULT hr;
        hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));
        if (hr!=NOERROR) {
	    aviStreamInfo.dwStart=0;
        }
        return(LONG)aviStreamInfo.dwStart;
        //return(((pAVIStreamStart)aAVIEntries[indxAVIStreamStart])(pavi));
    }

    static LONG  AVIStreamLength(PAVISTREAM pavi)
    {
        AVISTREAMINFOW	aviStreamInfo;
        HRESULT		hr;
        hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));
        if (hr!=NOERROR) {
	    aviStreamInfo.dwLength=1;
        }
        return (LONG)aviStreamInfo.dwLength;
        //return(((pAVIStreamLength)aAVIEntries[indxAVIStreamLength])(pavi));
    }

    /*static*/  LONG  AVIStreamTimeToSample (PAVISTREAM pavi, LONG lTime);
    /*static*/  LONG  AVIStreamSampleToTime (PAVISTREAM pavi, LONG lSample);
    /*static*/  HRESULT  AVIStreamBeginStreaming(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate);
    /*static*/  HRESULT  AVIStreamEndStreaming(PAVISTREAM pavi);

    static LONG  AVIStreamFindSample(PAVISTREAM pavi, LONG lPos, LONG lFlags)
    {
        // The use of AVIStreamFindSample within Quartz ALWAYS set the type
        // and direction
        ASSERT(lFlags & FIND_TYPE);
        ASSERT(lFlags & FIND_DIR);

        return(pavi->FindSample(lPos, lFlags));
        //return(((pAVIStreamFindSample)aAVIEntries[indxAVIStreamFindSample])(pavi));
    }

    static LONG AVIStreamEnd(PAVISTREAM pavi)
    {
        AVISTREAMINFOW aviStreamInfo;
        HRESULT hr;
        hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));
        if (hr!=NOERROR) {
	    aviStreamInfo.dwStart=0;
	    aviStreamInfo.dwLength=1;
        }
        return (LONG)aviStreamInfo.dwLength + (LONG)aviStreamInfo.dwStart;
        //return(((pAVIStreamStart)aAVIEntries[indxAVIStreamStart])(pavi)
        //    + ((pAVIStreamLength)aAVIEntries[indxAVIStreamLength])(pavi));
    }


    CAVIDynLink();
    ~CAVIDynLink();

private:

    // make copy and assignment inaccessible
    CAVIDynLink(const CAVIDynLink &refAVIDynLink);
    CAVIDynLink &operator=(const CAVIDynLink &refAVIDynLink);
};

//
// Class for dynamic linking to MSVFW32.DLL
//
// Most of the IC API set are macros that call ICSendMessage.  There are
// a couple of awkward ones that we expand inline.
//


//
// Dynamically loaded array of entry points
//
extern FARPROC aVFWEntries[];

//
// List of index entries into the array for each redirected API
//
#define indxICClose                  0
#define indxICSendMessage            1
#define indxICLocate                 2
#define indxICOpen                   3
#define indxICInfo		     4
#define indxICGetInfo		     5


//
// typedef the API set that we redirect
//

typedef LRESULT (WINAPI *pICClose)(HIC hic);
typedef HIC     (WINAPI *pICLocate)(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags);
typedef LRESULT (WINAPI *pICSendMessage)(HIC hic, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2);
typedef HIC     (VFWAPI *pICOpen)(DWORD fccType, DWORD fccHandler, UINT wMode);
typedef BOOL    (VFWAPI *pICInfo)(DWORD fccType, DWORD fccHandler, ICINFO FAR* lpicinfo);
typedef BOOL    (VFWAPI *pICGetInfo)(HIC hic, ICINFO FAR* lpicinfo, DWORD cb);

class CVFWDynLink {

private:
    static HMODULE m_hVFW;        	// handle to MSVFW32
    static LONG    m_vfwlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadVFWLock;      // serialise constructor/destructor

public:
    static void CVFWDynLinkLoad()
    {
	InitializeCriticalSection(&m_LoadVFWLock);      // serialise constructor/destructor
    }
    static void CVFWDynLinkUnload()
    {
	DeleteCriticalSection(&m_LoadVFWLock);      // serialise constructor/destructor
    }

    static DWORD_PTR ICDecompress(
	HIC                 hic,
	DWORD               dwFlags,    // flags (from AVI index...)
	LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
					// biSizeImage has the chunk size
					// biCompression has the ckid (AVI only)
	LPVOID              lpData,     // data
	LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
	LPVOID              lpBits)
    {
	ICDECOMPRESS icd;
	icd.dwFlags    = dwFlags;
	icd.lpbiInput  = lpbiFormat;
	icd.lpInput    = lpData;

	icd.lpbiOutput = lpbi;
	icd.lpOutput   = lpBits;
	icd.ckid       = 0;	
	return ICSendMessage(hic, ICM_DECOMPRESS, (DWORD_PTR)(LPVOID)&icd, sizeof(ICDECOMPRESS));
    }

    static LRESULT CVFWDynLink::ICClose(HIC hic)
    {
        return((((pICClose)aVFWEntries[indxICClose]))(hic));
    }

    static HIC ICLocate(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags)
    {
        return((((pICLocate)aVFWEntries[indxICLocate]))(fccType, fccHandler, lpbiIn, lpbiOut, wFlags));
    }


    static LRESULT ICSendMessage(HIC hic, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
    {
        return((((pICSendMessage)aVFWEntries[indxICSendMessage]))(hic, msg, dw1, dw2));
    }

    static HIC     ICOpen(DWORD fccType, DWORD fccHandler, UINT wMode)
    {
        return((((pICOpen)aVFWEntries[indxICOpen]))(fccType, fccHandler, wMode));
    }

    static BOOL    ICInfo(DWORD fccType, DWORD fccHandler, ICINFO* lpicinfo)
    {
        return((((pICInfo)aVFWEntries[indxICInfo]))(fccType, fccHandler, lpicinfo));
    }

    static BOOL    ICGetInfo(HIC hic, ICINFO* lpicinfo, DWORD cb)
    {
        return((((pICGetInfo)aVFWEntries[indxICGetInfo]))(hic, lpicinfo, cb));
    }

    static LRESULT ICDecompressEx(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,int ySrc,int dxSrc,int dySrc,LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,int yDst,int dxDst,int dyDst)
    {
        ICDECOMPRESSEX ic;

        ic.dwFlags = dwFlags;
        ic.lpbiSrc = lpbiSrc;
        ic.lpSrc = lpSrc;
        ic.xSrc = xSrc;
        ic.ySrc = ySrc;
        ic.dxSrc = dxSrc;
        ic.dySrc = dySrc;
        ic.lpbiDst = lpbiDst;
        ic.lpDst = lpDst;
        ic.xDst = xDst;
        ic.yDst = yDst;
        ic.dxDst = dxDst;
        ic.dyDst = dyDst;

        // note that ICM swaps round the length and pointer
        // length in lparam2, pointer in lparam1
        return ICSendMessage(hic, ICM_DECOMPRESSEX, (DWORD_PTR)&ic, sizeof(ic));
    }

    static LRESULT ICDecompressExQuery(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,int ySrc,int dxSrc,int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,int yDst,int dxDst,int dyDst)
    {
        ICDECOMPRESSEX ic;

        ic.dwFlags = dwFlags;
        ic.lpbiSrc = lpbiSrc;
        ic.lpSrc = lpSrc;
        ic.xSrc = xSrc;
        ic.ySrc = ySrc;
        ic.dxSrc = dxSrc;
        ic.dySrc = dySrc;
        ic.lpbiDst = lpbiDst;
        ic.lpDst = lpDst;
        ic.xDst = xDst;
        ic.yDst = yDst;
        ic.dxDst = dxDst;
        ic.dyDst = dyDst;

        // note that ICM swaps round the length and pointer
        // length in lparam2, pointer in lparam1
        return ICSendMessage(hic, ICM_DECOMPRESSEX_QUERY, (DWORD_PTR)&ic, sizeof(ic));
    }

    static LRESULT ICDecompressExBegin(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,int ySrc,int dxSrc,int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,int yDst,int dxDst,int dyDst)
    {
        ICDECOMPRESSEX ic;

        ic.dwFlags = dwFlags;
        ic.lpbiSrc = lpbiSrc;
        ic.lpSrc = lpSrc;
        ic.xSrc = xSrc;
        ic.ySrc = ySrc;
        ic.dxSrc = dxSrc;
        ic.dySrc = dySrc;
        ic.lpbiDst = lpbiDst;
        ic.lpDst = lpDst;
        ic.xDst = xDst;
        ic.yDst = yDst;
        ic.dxDst = dxDst;
        ic.dyDst = dyDst;

        // note that ICM swaps round the length and pointer
        // length in lparam2, pointer in lparam1
        return ICSendMessage(hic, ICM_DECOMPRESSEX_BEGIN, (DWORD_PTR)&ic, sizeof(ic));
    }

    static DWORD_PTR VFWAPIV ICDrawBegin(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        HPALETTE            hpal,           // palette to draw with
        HWND                hwnd,           // window to draw to
        HDC                 hdc,            // HDC to draw to
        int                 xDst,           // destination rectangle
        int                 yDst,
        int                 dxDst,
        int                 dyDst,
        LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
        int                 xSrc,           // source rectangle
        int                 ySrc,
        int                 dxSrc,
        int                 dySrc,
        DWORD               dwRate,         // frames/second = (dwRate/dwScale)
        DWORD               dwScale)
    {
        ICDRAWBEGIN icdraw;
        icdraw.dwFlags   =  dwFlags;
        icdraw.hpal      =  hpal;
        icdraw.hwnd      =  hwnd;
        icdraw.hdc       =  hdc;
        icdraw.xDst      =  xDst;
        icdraw.yDst      =  yDst;
        icdraw.dxDst     =  dxDst;
        icdraw.dyDst     =  dyDst;
        icdraw.lpbi      =  lpbi;
        icdraw.xSrc      =  xSrc;
        icdraw.ySrc      =  ySrc;
        icdraw.dxSrc     =  dxSrc;
        icdraw.dySrc     =  dySrc;
        icdraw.dwRate    =  dwRate;
        icdraw.dwScale   =  dwScale;

        return ICSendMessage(hic, ICM_DRAW_BEGIN, (DWORD_PTR)(LPVOID)&icdraw, sizeof(ICDRAWBEGIN));
    }

    static DWORD_PTR VFWAPIV ICDraw(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        LPVOID	            lpFormat,       // format of frame to decompress
        LPVOID              lpData,         // frame data to decompress
        DWORD               cbData,         // size in bytes of data
        LONG                lTime)          // time to draw this frame (see drawbegin dwRate and dwScale)
    {
        ICDRAW  icdraw;
        icdraw.dwFlags  =   dwFlags;
        icdraw.lpFormat =   lpFormat;
        icdraw.lpData   =   lpData;
        icdraw.cbData   =   cbData;
        icdraw.lTime    =   lTime;

        return ICSendMessage(hic, ICM_DRAW, (DWORD_PTR)(LPVOID)&icdraw, sizeof(ICDRAW));
    }

    CVFWDynLink();
    ~CVFWDynLink();

private:

    // make copy and assignment inaccessible
    CVFWDynLink(const CVFWDynLink &refVFWDynLink);
    CVFWDynLink &operator=(const CVFWDynLink &refVFWDynLink);
};


//
// Class for dynamic linking to MSACM32.DLL
//


//
// Dynamically loaded array of entry points
//
extern FARPROC aACMEntries[];

//
// List of index entries into the array for each redirected API
//
#define indxacmStreamConvert		0
#define indxacmStreamSize		1
#define indxacmStreamPrepareHeader	2
#define indxacmMetrics			3
#define indxacmStreamUnprepareHeader	4
#define indxacmStreamOpen		5
#define indxacmFormatSuggest		6
#define indxacmStreamClose		7
#ifdef UNICODE
# define indxacmFormatEnumW		8
#else
# define indxacmFormatEnumA		8
#endif


//
// typedef the API set that we redirect
//

typedef MMRESULT (ACMAPI *pacmStreamConvert)(HACMSTREAM has, LPACMSTREAMHEADER pash, DWORD fdwConvert);
typedef MMRESULT (ACMAPI *pacmStreamSize)
(
    HACMSTREAM              has,
    DWORD                   cbInput,
    LPDWORD                 pdwOutputBytes,
    DWORD                   fdwSize
);
typedef MMRESULT (ACMAPI *pacmStreamPrepareHeader)
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwPrepare
);
typedef MMRESULT (ACMAPI *pacmMetrics)
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
);
typedef MMRESULT (ACMAPI *pacmStreamUnprepareHeader)
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwUnprepare
);
typedef MMRESULT (ACMAPI *pacmStreamOpen)
(
    LPHACMSTREAM            phas,       // pointer to stream handle
    HACMDRIVER              had,        // optional driver handle
    LPWAVEFORMATEX          pwfxSrc,    // source format to convert
    LPWAVEFORMATEX          pwfxDst,    // required destination format
    LPWAVEFILTER            pwfltr,     // optional filter
    DWORD_PTR               dwCallback, // callback
    DWORD_PTR               dwInstance, // callback instance data
    DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
);
typedef MMRESULT (ACMAPI *pacmFormatSuggest)
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    DWORD               cbwfxDst,
    DWORD               fdwSuggest
);
typedef MMRESULT (ACMAPI *pacmStreamClose)
(
    HACMSTREAM              has,
    DWORD                   fdwClose
);
typedef MMRESULT (ACMAPI *pacmFormatEnumA)
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef MMRESULT (ACMAPI *pacmFormatEnumW)
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    ACMFORMATENUMCBW        fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
);


class CACMDynLink {

private:
    static HMODULE m_hACM;        	// handle to MSVFW32
    static LONG    m_ACMlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadACMLock;      // serialise constructor/destructor

public:
    static void CACMDynLinkLoad()
    {
	InitializeCriticalSection(&m_LoadACMLock);      // serialise constructor/destructor
    }
    static void CACMDynLinkUnload()
    {
	DeleteCriticalSection(&m_LoadACMLock);      // serialise constructor/destructor
    }

    static MMRESULT ACMAPI acmStreamConvert(HACMSTREAM has, LPACMSTREAMHEADER pash, DWORD fdwConvert)
    {
        return((((pacmStreamConvert)aACMEntries[indxacmStreamConvert]))(has, pash, fdwConvert));
    }

    static MMRESULT ACMAPI acmStreamSize
    (
        HACMSTREAM              has,
        DWORD                   cbInput,
        LPDWORD                 pdwOutputBytes,
        DWORD                   fdwSize
    )
    {
        return((((pacmStreamSize)aACMEntries[indxacmStreamSize]))(has, cbInput, pdwOutputBytes, fdwSize));
    }


    static MMRESULT ACMAPI acmStreamPrepareHeader
    (
        HACMSTREAM          has,
        LPACMSTREAMHEADER   pash,
        DWORD               fdwPrepare
    )
    {
        return((((pacmStreamPrepareHeader)aACMEntries[indxacmStreamPrepareHeader]))(has, pash, fdwPrepare));
    }

    static MMRESULT ACMAPI acmMetrics
    (
        HACMOBJ                 hao,
        UINT                    uMetric,
        LPVOID                  pMetric
    )
    {
        return((((pacmMetrics)aACMEntries[indxacmMetrics]))(hao, uMetric, pMetric));
    }

    static MMRESULT ACMAPI acmStreamUnprepareHeader
    (
        HACMSTREAM          has,
        LPACMSTREAMHEADER   pash,
        DWORD               fdwUnprepare
    )
    {
        return((((pacmStreamUnprepareHeader)aACMEntries[indxacmStreamUnprepareHeader]))(has, pash, fdwUnprepare));
    }

    static MMRESULT ACMAPI acmStreamOpen
    (
        LPHACMSTREAM            phas,       // pointer to stream handle
        HACMDRIVER              had,        // optional driver handle
        LPWAVEFORMATEX          pwfxSrc,    // source format to convert
        LPWAVEFORMATEX          pwfxDst,    // required destination format
        LPWAVEFILTER            pwfltr,     // optional filter
        DWORD_PTR               dwCallback, // callback
        DWORD_PTR               dwInstance, // callback instance data
        DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
    )
    {
        return((((pacmStreamOpen)aACMEntries[indxacmStreamOpen]))(phas,had,pwfxSrc,pwfxDst,pwfltr,dwCallback,dwInstance,fdwOpen));
    }

    static MMRESULT ACMAPI acmFormatSuggest
    (
        HACMDRIVER          had,
        LPWAVEFORMATEX      pwfxSrc,
        LPWAVEFORMATEX      pwfxDst,
        DWORD               cbwfxDst,
        DWORD               fdwSuggest
    )
    {
        return((((pacmFormatSuggest)aACMEntries[indxacmFormatSuggest]))(had, pwfxSrc, pwfxDst, cbwfxDst, fdwSuggest));
    }

    static MMRESULT ACMAPI acmStreamClose
    (
        HACMSTREAM              has,
        DWORD                   fdwClose
    )
    {
        return((((pacmStreamClose)aACMEntries[indxacmStreamClose]))(has, fdwClose));
    }

#ifdef UNICODE
    static MMRESULT ACMAPI acmFormatEnumW
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSW     pafd,
        ACMFORMATENUMCBW        fnCallback,
        DWORD_PTR               dwInstance,
        DWORD                   fdwEnum
    )
    {
        return((((pacmFormatEnumW)aACMEntries[indxacmFormatEnumW]))(had,pafd,fnCallback,dwInstance,fdwEnum));
    }
#else
    static MMRESULT ACMAPI acmFormatEnumA
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSA     pafd,
        ACMFORMATENUMCBA        fnCallback,
        DWORD_PTR               dwInstance, 
        DWORD                   fdwEnum
    )
    {
        return((((pacmFormatEnumA)aACMEntries[indxacmFormatEnumA]))(had,pafd,fnCallback,dwInstance,fdwEnum));
    }
#endif

    CACMDynLink();
    ~CACMDynLink();

private:

    // make copy and assignment inaccessible
    CACMDynLink(const CVFWDynLink &refVFWDynLink);
    CACMDynLink &operator=(const CVFWDynLink &refVFWDynLink);
};


//
// Class for dynamic linking to URLMON.DLL
//
//
// Dynamically loaded array of entry points
//
extern FARPROC aURLMonEntries[];

//
// List of index entries into the array for each redirected API
//
#define indxurlmonCreateURLMoniker	0
#define indxurlmonRegisterCallback	1
#define indxurlmonRevokeCallback	2

//
// typedef the API set that we redirect
//


typedef HRESULT (STDAPICALLTYPE * pCreateURLMoniker) (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);             
typedef HRESULT (STDAPICALLTYPE * pRegisterBindStatusCallback)(LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       
typedef HRESULT (STDAPICALLTYPE * pRevokeBindStatusCallback)(LPBC pBC, IBindStatusCallback *pBSCb);                      


class CURLMonDynLink {

private:
    static HMODULE m_hURLMon;	        	// handle to URLMON
    static LONG    m_URLMonlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadURLMonLock;   // serialise constructor/destructor

public:
    static void CURLMonDynLinkLoad()
    {
	InitializeCriticalSection(&m_LoadURLMonLock);      // serialise constructor/destructor
    }
    static void CURLMonDynLinkUnload()
    {
	DeleteCriticalSection(&m_LoadURLMonLock);      // serialise constructor/destructor
    }

    static HRESULT STDAPICALLTYPE CreateURLMoniker (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk)
    {
        return((((pCreateURLMoniker)aURLMonEntries[indxurlmonCreateURLMoniker]))
	       (pMkCtx, szURL, ppmk));
    }
	    
    static HRESULT STDAPICALLTYPE RegisterBindStatusCallback (LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved)
    {
        return((((pRegisterBindStatusCallback)aURLMonEntries[indxurlmonRegisterCallback]))
	       (pBC, pBSCb, ppBSCBPrev, dwReserved));
    }
    static HRESULT STDAPICALLTYPE RevokeBindStatusCallback (LPBC pBC, IBindStatusCallback *pBSCb)
    {
        return((((pRevokeBindStatusCallback)aURLMonEntries[indxurlmonRevokeCallback]))
	       (pBC, pBSCb));
    }

    CURLMonDynLink();
    ~CURLMonDynLink();

private:

    // make copy and assignment inaccessible
    CURLMonDynLink(const CVFWDynLink &refVFWDynLink);
    CURLMonDynLink &operator=(const CVFWDynLink &refVFWDynLink);
};

#endif //  FILTER_DLL
#endif //  __DYNLINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\fastfile.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fastfile.h
 *  Content:    Definitions for fastfile access.
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTBILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 ***************************************************************************/

typedef LPVOID  HFASTFILE;

extern BOOL __cdecl FastFileInit( LPSTR fname, int max_handles );
extern void __cdecl FastFileFini( void );
extern HFASTFILE __cdecl FastFileOpen( LPSTR name );
extern BOOL __cdecl FastFileClose( HFASTFILE pfe );
extern BOOL __cdecl FastFileRead( HFASTFILE pfh, LPVOID ptr, int size );
extern BOOL __cdecl FastFileSeek( HFASTFILE pfe, int off, int how );
extern long __cdecl FastFileTell( HFASTFILE pfe );
extern LPVOID __cdecl FastFileLock( HFASTFILE pfe, int off, int len );
extern BOOL __cdecl FastFileUnlock( HFASTFILE pfe, int off, int len );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\fil_data_i.c ===
/* Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved. */
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sat Oct 23 12:28:23 1999
 */
/* Compiler settings for fil_data.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IAMFilterData = {0x97f7c4d4,0x547b,0x4a5f,{0x83,0x32,0x53,0x64,0x30,0xad,0x2e,0x4d}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\evcodei.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// list of additional (perhaps standard someday) Quartz event codes
// and the expected params
//

#define EC_SKIP_FRAMES                      0x25
// ( nFramesToSkip, IFrameSkipResultCallback) : internal
// Get the filter graph to seek accuratley.

#define EC_PLEASE_REOPEN		    0x40
// (void, void) : application
// Something has changed enough that the graph should be re-rendered.

#define EC_STATUS	                    0x41
// ( BSTR, BSTR) : application
// Two arbitrary strings, a short one and a long one.

#define EC_MARKER_HIT			    0x42
// (int, void) : application
// The specified "marker #" has just been passed

#define EC_LOADSTATUS			    0x43
// (int, void) : application
// Sent when various points during the loading of a network file are reached

#define EC_FILE_CLOSED			    0x44
// (void, void) : application
// Sent when the file is involuntarily closed, i.e. by a network server shutdown

#define EC_ERRORABORTEX			    0x45
// ( HRESULT, BSTR ) : application
// Operation aborted because of error.  Additional information available.

// status codes for EC_LOADSTATUS....
#define AM_LOADSTATUS_CLOSED	        0x0000
#define AM_LOADSTATUS_LOADINGDESCR      0x0001
#define AM_LOADSTATUS_LOADINGMCAST      0x0002
#define AM_LOADSTATUS_LOCATING		0x0003
#define AM_LOADSTATUS_CONNECTING	0x0004
#define AM_LOADSTATUS_OPENING		0x0005
#define AM_LOADSTATUS_OPEN		0x0006


#define EC_NEW_PIN			    0x20
#define	EC_RENDER_FINISHED		    0x21


#define EC_EOS_SOON			   0x046
// (void, void) : application
// sent when the source filter is about to deliver an EOS downstream....

#define EC_CONTENTPROPERTY_CHANGED   0x47
// (ULONG, void) 
// Sent when a streaming media filter recieves a change in stream description information.
// the UI is expected to re-query for the changed property in response
#define AM_CONTENTPROPERTY_TITLE     0x0001
#define AM_CONTENTPROPERTY_AUTHOR    0x0002
#define AM_CONTENTPROPERTY_COPYRIGHT 0x0004
#define AM_CONTENTPROPERTY_DESCRIPTION 0x0008


#define EC_BANDWIDTHCHANGE		    0x48
// (WORD, long) : application
// sent when the bandwidth of the streaming data has changed.  First parameter
// is the new level of bandwidth. Second is the MAX number of levels. Second
// parameter may be 0, if the max levels could not be determined.

#define EC_VIDEOFRAMEREADY		    0x49
// (void, void) : application
// sent to notify the application that the first video frame is about to be drawn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\fil_data.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sat Oct 23 12:28:23 1999
 */
/* Compiler settings for fil_data.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fil_data_h__
#define __fil_data_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAMFilterData_FWD_DEFINED__
#define __IAMFilterData_FWD_DEFINED__
typedef interface IAMFilterData IAMFilterData;
#endif 	/* __IAMFilterData_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_fil_data_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_s_ifspec;

#ifndef __IAMFilterData_INTERFACE_DEFINED__
#define __IAMFilterData_INTERFACE_DEFINED__

/* interface IAMFilterData */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMFilterData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97f7c4d4-547b-4a5f-8332-536430ad2e4d")
    IAMFilterData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseFilterData( 
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFilterData( 
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMFilterDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAMFilterData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAMFilterData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        END_INTERFACE
    } IAMFilterDataVtbl;

    interface IAMFilterData
    {
        CONST_VTBL struct IAMFilterDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMFilterData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMFilterData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMFilterData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMFilterData_ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2)	\
    (This)->lpVtbl -> ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2)

#define IAMFilterData_CreateFilterData(This,prf2,prgbFilterData,pcb)	\
    (This)->lpVtbl -> CreateFilterData(This,prf2,prgbFilterData,pcb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMFilterData_ParseFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
    /* [in] */ ULONG cb,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);


void __RPC_STUB IAMFilterData_ParseFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMFilterData_CreateFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [in] */ REGFILTER2 __RPC_FAR *prf2,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IAMFilterData_CreateFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMFilterData_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\enumif.h ===
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\fgcallb.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
EXTERN_GUID(IID_IAMFilterGraphCallback,0x56a868fd,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);

interface IAMFilterGraphCallback : IUnknown
{
    // S_OK means rendering complete, S_FALSE means "retry now".
    virtual HRESULT UnableToRender(IPin *pPin) = 0;

    // other methods?
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\hrexcept.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// hrExcept.h
//

#ifndef __HREXCEPT__
#define __HREXCEPT__


// A hierarchy of classes intended to be used
// as exceptions.
// Based around the common HRESULT error code.

//
// CHRESULTException
//
// the root exception. the HRESULT stored provides more 
// information as to why the exception was thrown
class CHRESULTException {
public:

    CHRESULTException(const HRESULT hrReason = E_FAIL) { m_hrReason = hrReason; }
    
    HRESULT Reason(void) const { return m_hrReason; }

private:

    HRESULT m_hrReason;	// the reason for throwing the exception
};


//
// The following sub classes are provided as short cuts for their respective
// HRESULT codes.

//
// CE_OUTOFMEMORY
//
class CE_OUTOFMEMORY : public CHRESULTException {
public:
    CE_OUTOFMEMORY() : CHRESULTException(E_OUTOFMEMORY) {}
};


//
// CE_UNEXPECTED
//
class CE_UNEXPECTED : public CHRESULTException {
public:
    CE_UNEXPECTED() : CHRESULTException(E_UNEXPECTED) {}
};


//
// CE_FAIL
//
class CE_FAIL : public CHRESULTException {
public:
    CE_FAIL() : CHRESULTException(E_FAIL) {}
};


//
// CE_INVALIDARG
//
class CE_INVALIDARG : public CHRESULTException {
public:
    CE_INVALIDARG() : CHRESULTException(E_INVALIDARG) {}
};

#endif // __HREXCEPT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\modcount.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
void RecordModuleUsage (LPCTSTR, LPCTSTR);
BOOL RemoveModuleUsage (LPCTSTR, LPCTSTR);
DWORD ExecuteSynchCmdLine (LPTSTR, LPTSTR);
void ParseTokens (LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);
void ReverseSlashes (LPTSTR);
DWORD GetReferenceCount (LPTSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\multmon.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifdef COMPILE_MULTIMON_STUBS
#define COMPILE_MULTIMON_STUBS2
#endif


#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)

#include <multimon.h>

//=============================================================================
//
// MULTIMON
// stub module that fakes multiple monitor apis on pre Memphis Win32 OSes
//
// By using this header your code will work unchanged on Win95,
// you will get back default values from GetSystemMetrics() for new metrics
// and the new APIs will act like only one display is present.
//
// exactly one source must include this with COMPILE_MULTIMON_STUBS defined
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#undef ChangeDisplaySettingsEx

//
// define this to compile the stubs
// otherwise you get the declarations
//
#ifdef COMPILE_MULTIMON_STUBS2

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

BOOL (WINAPI* g_pfnChangeDisplaySettingsEx)(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);

BOOL InitMultipleMonitorStubs2(void)
{
    HMODULE hUser32;
    static BOOL fInitDone;

    if (fInitDone)
    {
        return g_pfnGetMonitorInfo != NULL;
    }

    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &&
#ifdef UNICODE
        (*(FARPROC*)&g_pfnChangeDisplaySettingsEx = GetProcAddress(hUser32,"ChangeDisplaySettingsExW")) &&
#else
        (*(FARPROC*)&g_pfnChangeDisplaySettingsEx = GetProcAddress(hUser32,"ChangeDisplaySettingsExA")) &&
#endif
        //
        // Old builds of Memphis had different indices for these metrics, and
        // some of the APIs and structs have changed since then, so validate that
        // the returned metrics are not totally messed up.  (for example on an old
        // Memphis build, the new index for SM_CYVIRTUALSCREEN will fetch 0)
        //
        // If this is preventing you from using the shell on secondary monitors
        // under Memphis then upgrade to a new Memphis build that is in sync with
        // the current version of the multi-monitor APIs.
        //
        (GetSystemMetrics(SM_CXVIRTUALSCREEN) >= GetSystemMetrics(SM_CXSCREEN)) &&
        (GetSystemMetrics(SM_CYVIRTUALSCREEN) >= GetSystemMetrics(SM_CYSCREEN)) )
    {
        fInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnChangeDisplaySettingsEx = NULL ;

        fInitDone = TRUE;
        return FALSE;
    }
}

#ifdef UNICODE

LONG WINAPI
xChangeDisplaySettingsExW(LPCSTR lpszDeviceName, LPDEVMODEW lpDevMode,
                          HWND hwnd, DWORD dwflags, LPVOID lParam)
{
    if (InitMultipleMonitorStubs2())
        return g_pfnChangeDisplaySettingsEx(lpszDeviceName, lpDevMode, hwnd,
                                            dwflags, lParam) ;

    // Otherwise return DISP_CHANGE_SUCCESSFUL, because OS doesn't support it
    return DISP_CHANGE_SUCCESSFUL ;  // what else?
}

#else

LONG WINAPI
xChangeDisplaySettingsExA(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode,
                          HWND hwnd, DWORD dwflags, LPVOID lParam)
{
    if (InitMultipleMonitorStubs2())
        return g_pfnChangeDisplaySettingsEx(lpszDeviceName, lpDevMode, hwnd,
                                            dwflags, lParam) ;

    // Otherwise return DISP_CHANGE_SUCCESSFUL, because OS doesn't support it
    return DISP_CHANGE_SUCCESSFUL ;  // what else?
}

#endif // UNICODE

#undef COMPILE_MULTIMON_STUBS2

#else   // COMPILE_MULTIMON_STUBS2

#ifdef UNICODE
extern LONG WINAPI xChangeDisplaySettingsExW(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);
#else
extern LONG WINAPI xChangeDisplaySettingsExA(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);
#endif

#endif  // COMPILE_MULTIMON_STUBS2

//
// build defines that replace the regular APIs with our versions
//
#ifdef UNICODE
#define ChangeDisplaySettingsEx xChangeDisplaySettingsExW
#else
#define ChangeDisplaySettingsEx xChangeDisplaySettingsExA
#define ChangeDisplaySettingsExA xChangeDisplaySettingsExA
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\intset.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __IntSet_h__
#define __IntSet_h__

#include <stdlib.h>
#include <memory.h>

// To test this class, copy this file into a .cpp,
// load into Dev Studio, define self_test and run.
#ifdef self_test
    #include <iostream.h>
    #include <assert.h>
    #define ASSERT assert
#endif

// Class denoting a set of integers within the range [min..max]
// A number may be added to the set by +=,
// removed from the set by -=,
// and tested by [number].

class IntSet
{
protected:
    const int m_min, m_max;
    unsigned * m_pBits;
    enum { bit_width = 8 * sizeof(unsigned), low_mask = bit_width - 1, high_shift = 5 };

public:
    ~IntSet();
    IntSet( int min, int max );

    int Max() const { return m_max; }
    int Min() const { return m_min; }

    void Clear()
    {
        memset( m_pBits, 0, ((m_max - m_min) / bit_width + 1) * sizeof(unsigned) );
    }

    void operator += ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_pBits[elmt >> high_shift] |= 1 << (elmt & low_mask);
    }

    void operator -= ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_pBits[elmt >> high_shift] &= ~(1 << (elmt & low_mask));
    }

    int operator[] ( int elmt ) const
    {
        if (elmt < m_min) return 0;
        if (elmt > m_max) return 0;
        elmt -= m_min;
        return (m_pBits[elmt >> high_shift] >> (elmt & low_mask)) & 1;
    }

#ifdef self_test
    void COut() const
    {
        for (int i = m_min; i <= m_max; i++) cout << ( (*this)[i] ? 'Y' : 'n' );
        cout << endl;
    }
#endif
};

inline IntSet::~IntSet()
{
    delete [] m_pBits;
}

inline IntSet::IntSet( int min, int max )
: m_min(min), m_max(max)
{
    m_pBits = new unsigned [(max-min)/bit_width + 1];
    Clear();
}


// Variation that can only hold objects [0..31].
// An initial value can be specified on creation.
// Appart from its construction, this object should
// look like an IntSet.

class IntSmallSet
{
protected:
    enum { m_min = 0, m_max = 63 };
    unsigned __int64 m_Bits;

public:
    static const __int64 One;

    IntSmallSet( unsigned __int64 init = 0 )
    : m_Bits(init)
    {}

    int Max() const { return m_max; }
    int Min() const { return m_min; }

    void Clear()
    {
        m_Bits = 0;
    }

    void operator += ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_Bits |= One << elmt;
    }

    void operator -= ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_Bits &= ~(One << elmt);
    }

    int operator[] ( int elmt ) const
    {
        if (elmt < m_min) return 0;
        if (elmt > m_max) return 0;
        elmt -= m_min;

        // Eliminate compiler warning: The conditional expression is an
        // _int64, convert it to an int
        return ((m_Bits >> elmt) & 1)? 1 : 0;
    }

    IntSmallSet operator | ( const IntSmallSet & s ) const
    { return IntSmallSet( m_Bits | s.m_Bits ); }

    IntSmallSet operator & ( const IntSmallSet & s ) const
    { return IntSmallSet( m_Bits & s.m_Bits ); }

    IntSmallSet operator ~ () const
    { return IntSmallSet( ~m_Bits ); }


    int operator == ( const IntSmallSet & s ) const
    { return m_Bits == s.m_Bits; }

    int operator == ( unsigned i ) const
    { return m_Bits == i; }

#ifdef self_test
    void COut() const
    {
        for (int i = m_min; i <= m_max; i++) cout << ( (*this)[i] ? 'Y' : 'n' );
        cout << endl;
    }
#endif
};


#ifdef self_test
void main()
{
    // IntSet Set1(-30,+102);
    IntSmallSet Set1;

    int i;

    for ( i = Set1.Min(); i <= Set1.Max(); i++ )
    {
        Set1 += i;
        Set1.COut();
    }

    for ( i = Set1.Max(); i >= Set1.Min(); i-- )
    {
        Set1 -= i;
        Set1.COut();
    }
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\ovmixpos.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __OVMIXPOS__
#define __OVMIXPOS__

EXTERN_GUID(IID_IAMOverlayMixerPosition,0x56a868fc,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);

interface DECLSPEC_UUID("56a868fc-0ad4-11ce-b03a-0020af0ba770")
IAMOverlayMixerPosition : IUnknown
{
   virtual HRESULT STDMETHODCALLTYPE GetScaledDest(RECT *prcSrc, RECT* prcDst) = 0;

   // other methods?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\multistr.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
//
// CMultiByteStr
//
// Quick and dirty converter from TSTR to WSTR.
// note that in the UNICODE case no copy is performed,
// so the lifetime of the string pointed to must be longer 
// than this object.
class CMultiByteStr {
public:

    CMultiByteStr(LPCTSTR szString) {

#ifdef UNICODE
    
        m_wszString = szString;

#else
        int iLen = MultiByteToWideChar(CP_ACP, 0,
                                       szString, -1,
	  		               m_wszString, 0);
        m_wszString = new WCHAR[iLen];
	if (m_wszString == NULL) {
	    throw CHRESULTException(E_OUTOFMEMORY);
	}
        MultiByteToWideChar(CP_ACP, 0,
                            szString, -1,
	                    m_wszString, iLen);
#endif
    }

    ~CMultiByteStr() {

#ifndef UNICODE
         delete[] m_wszString;
#endif
    }

    operator LPCWSTR() { return m_wszString; }

private:

#ifdef UNICODE
    LPCWSTR	m_wszString;	// const if UNICODE
#else
    LPWSTR	m_wszString;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\skipfrm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __skipfrm_h__
#define __skipfrm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFrameSkipResultCallback_FWD_DEFINED__
#define __IFrameSkipResultCallback_FWD_DEFINED__
typedef interface IFrameSkipResultCallback IFrameSkipResultCallback;
#endif 	/* __IFrameSkipResultCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IFrameSkipResultCallback_INTERFACE_DEFINED__
#define __IFrameSkipResultCallback_INTERFACE_DEFINED__

/* interface IFrameSkipResultCallback */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFrameSkipResultCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7536960D-1977-4807-98EA-485F6C842A54")
    IFrameSkipResultCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE FrameSkipStarted( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual void STDMETHODCALLTYPE FrameSkipFinished( 
            /* [in] */ HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFrameSkipResultCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFrameSkipResultCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFrameSkipResultCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFrameSkipResultCallback * This);
        
        void ( STDMETHODCALLTYPE *FrameSkipStarted )( 
            IFrameSkipResultCallback * This,
            /* [in] */ HRESULT hr);
        
        void ( STDMETHODCALLTYPE *FrameSkipFinished )( 
            IFrameSkipResultCallback * This,
            /* [in] */ HRESULT hr);
        
        END_INTERFACE
    } IFrameSkipResultCallbackVtbl;

    interface IFrameSkipResultCallback
    {
        CONST_VTBL struct IFrameSkipResultCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFrameSkipResultCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFrameSkipResultCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFrameSkipResultCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFrameSkipResultCallback_FrameSkipStarted(This,hr)	\
    (This)->lpVtbl -> FrameSkipStarted(This,hr)

#define IFrameSkipResultCallback_FrameSkipFinished(This,hr)	\
    (This)->lpVtbl -> FrameSkipFinished(This,hr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IFrameSkipResultCallback_FrameSkipStarted_Proxy( 
    IFrameSkipResultCallback * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB IFrameSkipResultCallback_FrameSkipStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IFrameSkipResultCallback_FrameSkipFinished_Proxy( 
    IFrameSkipResultCallback * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB IFrameSkipResultCallback_FrameSkipFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFrameSkipResultCallback_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\skipfrm_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IFrameSkipResultCallback,0x7536960D,0x1977,0x4807,0x98,0xEA,0x48,0x5F,0x6C,0x84,0x2A,0x54);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IFrameSkipResultCallback,0x7536960D,0x1977,0x4807,0x98,0xEA,0x48,0x5F,0x6C,0x84,0x2A,0x54);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\h\skipfrm_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "skipfrm.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IFrameSkipResultCallback, ver. 0.0,
   GUID={0x7536960D,0x1977,0x4807,{0x98,0xEA,0x48,0x5F,0x6C,0x84,0x2A,0x54}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _skipfrm_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _skipfrm_StubVtblList[] = 
{
    0
};

PCInterfaceName const _skipfrm_InterfaceNamesList[] = 
{
    0
};


#define _skipfrm_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _skipfrm, pIID, n)

int __stdcall _skipfrm_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo skipfrm_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _skipfrm_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _skipfrm_StubVtblList,
    (const PCInterfaceName * ) & _skipfrm_InterfaceNamesList,
    0, // no delegation
    & _skipfrm_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "skipfrm.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IFrameSkipResultCallback, ver. 0.0,
   GUID={0x7536960D,0x1977,0x4807,{0x98,0xEA,0x48,0x5F,0x6C,0x84,0x2A,0x54}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _skipfrm_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _skipfrm_StubVtblList[] = 
{
    0
};

PCInterfaceName const _skipfrm_InterfaceNamesList[] = 
{
    0
};


#define _skipfrm_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _skipfrm, pIID, n)

int __stdcall _skipfrm_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo skipfrm_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _skipfrm_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _skipfrm_StubVtblList,
    (const PCInterfaceName * ) & _skipfrm_InterfaceNamesList,
    0, // no delegation
    & _skipfrm_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\makesdk\dshow.h ===
///////////////////////////////////////////////////////////////////////////
// Copyright (C) 2000 Microsoft Corporation.  All Right Reserved.
//
// File:		dshow.h
// Content:     DirectShow top-level include file
///////////////////////////////////////////////////////////////////////////

#ifndef __DSHOW_INCLUDED__
#define __DSHOW_INCLUDED__

///////////////////////////////////////////////////////////////////////////
// Set up constants & pragmas for the compiler
///////////////////////////////////////////////////////////////////////////
#ifdef	_MSC_VER
// disable some level-4 warnings, use #pragma warning(enable:###) to re-enable
#pragma warning(disable:4100) // warning C4100: unreferenced formal parameter
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4511) // warning C4511: copy constructor could not be generated
#pragma warning(disable:4512) // warning C4512: assignment operator could not be generated
#pragma warning(disable:4514) // warning C4514: "unreferenced inline function has been removed"

#if _MSC_VER>=1100
#define AM_NOVTABLE __declspec(novtable)
#else
#define AM_NOVTABLE
#endif
#endif	// MSC_VER

///////////////////////////////////////////////////////////////////////////
// Include standard Windows files
///////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include <olectl.h>
#include <ddraw.h>
#include <mmsystem.h>

#ifndef NUMELMS
   #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

///////////////////////////////////////////////////////////////////////////
// Include DirectShow include files
///////////////////////////////////////////////////////////////////////////
#include <strmif.h>     // Generated IDL header file for streams interfaces
#include <amvideo.h>    // ActiveMovie video interfaces and definitions
#include <amaudio.h>    // ActiveMovie audio interfaces and definitions
#include <control.h>    // generated from control.odl
#include <evcode.h>     // event code definitions
#include <uuids.h>      // declaration of type GUIDs and well-known clsids
#include <errors.h>     // HRESULT status and error definitions
#include <edevdefs.h>   // External device control interface defines
#include <audevcod.h>   // audio filter device error event codes
#include <dvdevcod.h>   // DVD error event codes

///////////////////////////////////////////////////////////////////////////
// Define OLE Automation constants
///////////////////////////////////////////////////////////////////////////
#ifndef OATRUE
#define OATRUE (-1)
#endif // OATRUE
#ifndef OAFALSE
#define OAFALSE (0)
#endif // OAFALSE

///////////////////////////////////////////////////////////////////////////
// Define Win64 interfaces if not already defined
///////////////////////////////////////////////////////////////////////////

// InterlockedExchangePointer
#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))
#endif 


#endif // __DSHOW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\dvdplay\dvdplay.h ===
#if !defined(AFX_DVDPLAY_H__98661C6D_9D6F_430C_82EA_D7E23174A5E9__INCLUDED_)
#define AFX_DVDPLAY_H__98661C6D_9D6F_430C_82EA_D7E23174A5E9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_DVDPLAY_H__98661C6D_9D6F_430C_82EA_D7E23174A5E9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\dvdplay\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dvdplay.rc
//
#define IDS_APP_TITLE                   103
#define IDI_DVDPLAY                     107
#define IDI_SMALL                       108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\dvdplay\dvdplay.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: dvdplay.cpp                                                     */
/* Description: Implementation of WinMain for hosting DLL container.     */
/* This is simple stub exe, that contains resources and startups an      */
/* OLE container.                                                        */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "tchar.h"
#include <stdio.h>
#include "resource.h"
#include "..\MSMFCnt\MSMFCnt.h"
#include "..\MSMFCnt\MSMFCnt_i.c"

/*************************************************************************/
/* Function: AnotherInstanceRunning                                      */
/* Description: Trys to figure out if we have another instance of this   */
/* app running. If so brings it to foregraound and exits.                */
/*************************************************************************/
BOOL AnotherInstanceRunning(){

    HWND hwnd = ::FindWindow(TEXT("MSMFVideoClass"), TEXT("DVDPlay"));

    if(NULL == hwnd){

        return(FALSE);
    }/* end of if statement */

   // OK we have something running
    HWND hwndFirstChild = ::GetLastActivePopup(hwnd);

    if(::IsIconic(hwnd)){

        ::OpenIcon(hwnd);
    }/* end of if statement */

    ::SetForegroundWindow(hwnd);

    if(hwndFirstChild != hwnd){

        if(::IsIconic(hwndFirstChild)){

            ::OpenIcon(hwndFirstChild);
        }/* end of if statement */

        ::SetForegroundWindow(hwndFirstChild);
    }/* end of if statement */

    return(TRUE);
}/* end of function AnotherInstanceRunning */

/*************************************************************************/
/* Function: FindOneOf                                                   */
/*************************************************************************/
LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2){

    while (p1 != NULL && *p1 != NULL){

        LPCTSTR p = p2;
        while (p != NULL && *p != NULL){

            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }/* end of while loop */
        p1 = CharNext(p1);
    }/* end of while loop */
    return NULL;
}/* end of function FindOnOf */

/*************************************************************************/
/* Function: WinMain                                                     */
/* Description: Initializes the object, and sets the script to it        */
/*************************************************************************/
#if 0
extern "C" int WINAPI _tWinMain(HINSTANCE /* hInstance */, 
                                HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/){

#else
int APIENTRY WinMain(HINSTANCE /* hInst */,
                     HINSTANCE /*hPrevInstance*/,
                     LPSTR     /*lpCmdLine*/,
                     int       /*nCmdShow*/){
#endif

    try {
        BSTR strFileName = NULL;
        BSTR strScriptFile = ::SysAllocString(L"dvdlayout.js");

        if(AnotherInstanceRunning()){
            // only one instance at a time
            return(-1);
        }/* end of if statement */

         TCHAR szTokens[] = _T("-/ ");

        LPTSTR lpCmdLine = ::GetCommandLine();
        LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
        while (lpszToken != NULL)
        {
            // Read the command line argument
            TCHAR opt[MAX_PATH];

#ifdef _UNICODE
            _stscanf(lpszToken, TEXT("%ws"), opt);
#else
            _stscanf(lpszToken, TEXT("%s"), opt);
#endif
                
            // Set run the default directory name
            if (lstrcmpi(opt, _T("play"))==0) {
                lpszToken = FindOneOf(lpszToken, szTokens);
                TCHAR fileName[MAX_PATH];

                

    #ifdef _UNICODE
                _stscanf(lpszToken, TEXT("%ws"), fileName);
                //*( _tcsrchr( fileName, '\\' ) + 1 ) = TEXT('\0');

                strFileName = SysAllocString(fileName);
    #else                
                _stscanf(lpszToken, "%s", fileName);

#ifdef _DEBUG
                ::MessageBox(::GetFocus(), TEXT("test"), fileName, MB_OK);
#endif
               // *( _tcsrchr( fileName, '\\' ) + 1 ) = TEXT('\0');


                WCHAR strTmpFileName[MAX_PATH];

                LONG lLength = _tcslen(fileName) + 1;
                 
                ::MultiByteToWideChar(CP_ACP, 0, fileName, lLength, strTmpFileName, MAX_PATH); 

                strFileName = ::SysAllocString(strTmpFileName);
    #endif
            }/* end of if statement */

             if (lstrcmpi(opt, _T("script"))==0) {
                lpszToken = FindOneOf(lpszToken, szTokens);
                TCHAR scriptFile[MAX_PATH];

            

    #ifdef _UNICODE
                _stscanf(lpszToken, TEXT("%ws"), scriptFile);           

                if(NULL != strFileName){

                    ::SysFreeString(strFileName);
                }/* end of if statement */

                strScriptFile = ::SysAllocString(scriptFile);
    #else                
                _stscanf(lpszToken, "%s", scriptFile);

                WCHAR strTmpFileName[MAX_PATH];

                LONG lLength = _tcslen(scriptFile) + 1;
             
                ::MultiByteToWideChar(CP_ACP, 0, scriptFile, lLength, strTmpFileName, MAX_PATH); 

                if(NULL != strFileName){

                    ::SysFreeString(strFileName);
                }/* end of if statement */

                strScriptFile = SysAllocString(strTmpFileName);
        #endif
                }/* end of if statement */

            lpszToken = FindOneOf(lpszToken, szTokens);
        }/* end of if statement */

        HRESULT hr = ::CoInitialize(NULL);

#ifdef _DEBUG
        bool fReload;

        do {
            fReload = false;
#endif

            IMSMFBar* pIMFBar = NULL;

            hr = ::CoCreateInstance(
                CLSID_MSMFBar,
                NULL,
                CLSCTX_SERVER,
                IID_IMSMFBar,
                (LPVOID*) &pIMFBar);

            if(FAILED(hr)){

                return (-2);
            }/* end of if statement */
            
            hr = pIMFBar->put_CmdLine(strFileName);

            if(SUCCEEDED(hr)){

                hr = pIMFBar->put_ScriptFile(strScriptFile);
            }/* end of if statement */

            if(SUCCEEDED(hr)){
                
                MSG msg;
                while (::GetMessage(&msg, 0, 0, 0)){
                    
#ifdef _DEBUG
                    // enable restarting of the app via F6 key
                    // did not use F5 since that is overused and if debugging could trigger unvanted behavior
                    if(WM_KEYUP == msg.message && VK_F6 == msg.wParam){
                        
                        fReload = true;
                        ::PostMessage(msg.hwnd, WM_CLOSE, NULL, NULL); // tell our container to close
                    }/* end of if statement */
#endif
                    //ATLTRACE2(atlTraceHosting, 20, TEXT("Message = %x \n"), msg.message);
                    ::DispatchMessage(&msg);
                }/* end of while loop */
            }/* end of if statement */
            
            // release the site
            if(NULL != pIMFBar){

                pIMFBar->Release();
                pIMFBar = NULL;
            }/* end of if statement */

            if(NULL != strFileName){

                ::SysFreeString(strFileName);
            }/* end of if statement */

            if(NULL != strScriptFile){

                ::SysFreeString(strScriptFile);
            }/* end of if statement */
#ifdef _DEBUG
        }
        while (fReload);
#endif

    ::CoUninitialize();
   }
   catch(...){
       return(-1);
   }/* end of catch statement */

    return 0;
}/* end of function WinMain */

/*************************************************************************/
/* End of file: dvdplay.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\dvdplay\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	dvdplay.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\dvdplay\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>
#include <objbase.h>

// C RunTime Header Files
//#include <stdlib.h>
//#include <malloc.h>
//#include <memory.h>
//#include <tchar.h>

// Local Header Files



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\coptdlg.cpp ===
// COptionsDlg.cpp : Declaration of the COptionsDlg class
//
// Copyright (C) 1999 Microsoft Corporation
// All rights reserved.


#include "stdafx.h"
#include "COptDlg.h"
#include "resource.hm"

extern CComModule _Module;
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

int g_helpIDArraySize = 42;
DWORD g_helpIDArray[][2] = {
    {IDOK, HIDOK},
    {IDCANCEL, HIDCANCEL},
    {IDC_APPLY, HIDAPPLY},
    {IDC_AUDIO_LIST, HIDC_AUDIO_LIST},
    {IDC_STATIC_AUDIO_LIST, HIDC_AUDIO_LIST},
    {IDC_STATIC_CHAN_CONTENT, HIDC_CHECK_CHAN2},
    {IDC_CHECK_CHAN2, HIDC_CHECK_CHAN2},
    {IDC_CHECK_CHAN3, HIDC_CHECK_CHAN2},
    {IDC_CHECK_CHAN4, HIDC_CHECK_CHAN2},
    {IDC_BOOKMARK_STOP, HIDC_BOOKMARK_STOP},
    {IDC_BOOKMARK_CLOSE, HIDC_BOOKMARK_CLOSE},
    {IDC_SUBPIC_LANG, HIDC_SUBPIC_LANG},
    {IDC_AUDIO_LANG, HIDC_AUDIO_LANG},
    {IDC_MENU_LANG, HIDC_MENU_LANG},
    {IDC_STATIC_SUBPIC_LANG, HIDC_SUBPIC_LANG},
    {IDC_STATIC_AUDIO_LANG, HIDC_AUDIO_LANG},
    {IDC_STATIC_MENU_LANG, HIDC_MENU_LANG},
    {IDC_EDIT_PASSWORD, HIDC_EDIT_PASSWORD},
    {IDC_STATIC_PASSWORD, HIDC_EDIT_PASSWORD},
    {IDC_EDIT_NEW_PASSWORD, HIDC_EDIT_NEW_PASSWORD},
    {IDC_STATIC_NEW_PASSWORD, HIDC_EDIT_NEW_PASSWORD},
    {IDC_EDIT_CONFIRM_NEW, HIDC_EDIT_CONFIRM_NEW},
    {IDC_STATIC_CONFIRM_NEW, HIDC_EDIT_CONFIRM_NEW},
    {IDC_COMBO_RATE, HIDC_COMBO_RATE},
    {IDC_STATIC_CURRENT_RATE, HIDC_COMBO_RATE},
    {IDC_BUTTON_CHANGE_PASSWORD, HIDC_BUTTON_CHANGE_PASSWORD},
    {IDC_DISABLE_PARENT, HIDC_DISABLE_PARENT},
    {IDC_DISABLE_SCREENSAVER, HIDC_DISABLE_SCREENSAVER},
    {IDC_LIST_TITLES, HIDC_LIST_TITLES},
    {IDC_LIST_CHAPS, HIDC_LIST_CHAPS},
    {IDC_STATIC_LIST_TITLES, HIDC_LIST_TITLES},
    {IDC_STATIC_LIST_CHAPS, HIDC_LIST_CHAPS},
};

/*************************************************************/
/* Name: Constructor
/* Description: 
/*************************************************************/
COptionsDlg::COptionsDlg(IMSWebDVD* pDvd)   
{ 
    m_pDvd = pDvd; 
    m_dFFSpeed = 16.0; 
    m_dBWSpeed = 16.0;
    m_dPlaySpeed = 1.0;
    m_bChapDirty = FALSE;
    m_bDirty = FALSE;
    m_pDvdOpt = NULL;
    m_pPasswordDlg = NULL;

    for (int i=0; i<C_PAGES; i++) {
        m_hwndDisplay[i] = NULL;
    }
}

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
COptionsDlg::~COptionsDlg() {
    if (m_pDvd) {
        m_pDvd.Release(); 
        m_pDvd = NULL;
    }

    if (m_pPasswordDlg) {
        delete m_pPasswordDlg;
        m_pPasswordDlg = NULL;
    }
}

/*************************************************************/
/* Name: IsNewAdmin
/* Description: TRUE if no admin password hasn't been enter
/*  FALSE otherwise
/*************************************************************/
BOOL COptionsDlg::IsNewAdmin()
{
    BOOL bNewAdmin = TRUE;
    TCHAR szSavedPasswd[MAX_PASSWD+PRE_PASSWD];
    DWORD dwLen = MAX_PASSWD+PRE_PASSWD;
    BOOL bFound = GetRegistryString(g_szPassword, szSavedPasswd, &dwLen, TEXT(""));

    if (bFound && dwLen != 0)
        bNewAdmin = FALSE;	

    return bNewAdmin;
}
/*************************************************************/
/* Name: OnInitDialog
/* Description: Create tab control
/*************************************************************/
LRESULT COptionsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_pDvdOpt->Fire_OnOpen();
    m_bChapDirty = FALSE;
    m_bDirty = FALSE;
    ::EnableWindow(GetDlgItem(IDC_APPLY), FALSE);

    // Save itself in the window user data
    // so that child dialog proc can use it
    ::SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (LONG_PTR)this);

	SetFont((HFONT) GetStockObject(ANSI_FIXED_FONT), TRUE);
	DWORD dwDlgBase = GetDialogBaseUnits(); 
	int cxMargin = LOWORD(dwDlgBase) / 4; 
	int cyMargin = HIWORD(dwDlgBase) / 8; 
    cxMargin *= 2;
    cyMargin *= 2;
	
	m_hwndTab = GetDlgItem(IDC_TABCTRL);
	TabCtrl_DeleteAllItems(m_hwndTab);
    for (int i=C_PAGES-1; i>=0; i--) {
        m_hwndDisplay[i] = NULL;
    }

	TCITEM tie; 
	// Add a tab for each of the three child dialog boxes. 
	tie.mask = TCIF_TEXT | TCIF_IMAGE; 
	tie.iImage = -1; 

    RECT rcTab;
	SetRectEmpty(&rcTab); 

    for (i=0; i<C_PAGES; i++) {
	    tie.pszText = LoadStringFromRes(IDS_SEARCH+i);
	    TabCtrl_InsertItem(m_hwndTab, i, &tie); 
	    // Lock the resources for the child dialog boxes. 
	    m_apRes[i] = DoLockDlgRes(MAKEINTRESOURCE(IDD_SEARCH+i)); 

	    // Determine the bounding rectangle for all child dialog boxes. 
		SIZE size;
		AtlGetDialogSize(m_apRes[i], &size);
		if (size.cx > rcTab.right) 
			rcTab.right = size.cx; 
		if (size.cy > rcTab.bottom) 
			rcTab.bottom = size.cy; 
	} 
	
	// Calculate how large to make the tab control, so 
	// the display area can accommodate all the child dialog boxes. 
	TabCtrl_AdjustRect(m_hwndTab, TRUE, &rcTab); 
	OffsetRect(&rcTab, 
        GetSystemMetrics(SM_CXDLGFRAME) + cxMargin - rcTab.left, 
        GetSystemMetrics(SM_CYDLGFRAME) + cyMargin - rcTab.top); 
	
	// Calculate the display rectangle.
    RECT rcDisplay;
	CopyRect(&rcDisplay, &rcTab); 
	TabCtrl_AdjustRect(m_hwndTab, FALSE, &rcDisplay); 
	OffsetRect(&rcDisplay, cxMargin, cyMargin);
	
	// Set the size and position of the tab control, buttons, 
	// and dialog box. 
    ::MoveWindow(m_hwndTab, 
        rcTab.left, rcTab.top, 
		RECTWIDTH(&rcTab) + 2*cxMargin, 
        RECTHEIGHT(&rcTab) + 2*cyMargin,
        TRUE);
	
	// Size the dialog box. 
    RECT rcButton = {0, 0, 50, 14};
    HWND hWndButton = GetDlgItem(IDC_APPLY);
    if (hWndButton) {
        ::GetClientRect(hWndButton, &rcButton);
    }

    RECT rcDialog;
    GetWindowRect(&rcDialog);
	MoveWindow(rcDialog.left, rcDialog.top, 
		rcTab.right + 4*cxMargin + 2*GetSystemMetrics(SM_CXDLGFRAME), 
        rcTab.bottom + 6*cyMargin + 2*GetSystemMetrics(SM_CYDLGFRAME) 
        + RECTHEIGHT(&rcButton) + GetSystemMetrics(SM_CYCAPTION), 
        TRUE);

    // Move the apply, cancel and ok buttons
    GetClientRect(&rcDialog);

    // apply button
    if (hWndButton) {
        ::MoveWindow(hWndButton, 
            RECTWIDTH(&rcDialog)-2*cxMargin-RECTWIDTH(&rcButton),
            RECTHEIGHT(&rcDialog)-2*cyMargin-RECTHEIGHT(&rcButton),
            RECTWIDTH(&rcButton),
            RECTHEIGHT(&rcButton), 
            TRUE);
    }
        
    // cancel button
    hWndButton = GetDlgItem(IDCANCEL);
    if (hWndButton) {
        ::MoveWindow(hWndButton, 
            RECTWIDTH(&rcDialog)-3*cxMargin-2*RECTWIDTH(&rcButton),
            RECTHEIGHT(&rcDialog)-2*cyMargin-RECTHEIGHT(&rcButton),
            RECTWIDTH(&rcButton),
            RECTHEIGHT(&rcButton), 
            TRUE);
    }

    // ok button
    hWndButton = GetDlgItem(IDOK);
    if (hWndButton) {
        ::MoveWindow(hWndButton, 
            RECTWIDTH(&rcDialog)-4*cxMargin-3*RECTWIDTH(&rcButton),
            RECTHEIGHT(&rcDialog)-2*cyMargin-RECTHEIGHT(&rcButton),
            RECTWIDTH(&rcButton),
            RECTHEIGHT(&rcButton), 
            TRUE);
    }

    // Create individual pages
    for (i=C_PAGES-1; i>=0; i--) {
        m_hwndDisplay[i] = CreateDialogIndirect(_Module.GetModuleInstance(), 
            m_apRes[i], m_hWnd, ChildDialogProc); 
        ::MoveWindow(m_hwndDisplay[i],
            rcDisplay.left, 
            rcDisplay.top, 
            RECTWIDTH(&rcDisplay), 
            RECTHEIGHT(&rcDisplay), 
            TRUE);
    }

	// Simulate selection of the first item. 
    m_currentSel = 0;
	OnSelChanged(); 
	
	return 0;
} 

/*************************************************************/
/* Name: OnNotify
/* Description: Tab control selection has changed
/*************************************************************/
LRESULT COptionsDlg::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	NMHDR *lpnmhdr = (LPNMHDR) lParam;
	switch (lpnmhdr->code) { 	
	case TCN_SELCHANGE:
		OnSelChanged();
		break;
	}
	return 0;
}

/*************************************************************/
/* Name: DoLockDlgRes                                        */
/* Description: loads and locks a dialog template resource.  */
/* 	Returns the address of the locked resource.              */
/* 	lpszResName - name of the resource                       */
/*************************************************************/
DLGTEMPLATE * WINAPI COptionsDlg::DoLockDlgRes(LPCTSTR lpszResName){ 

	HRSRC hrsrc = FindResource(_Module.GetModuleInstance(), lpszResName, RT_DIALOG); 

    if(NULL == hrsrc){

        ATLASSERT(FALSE);
        return(NULL);
    }/* end of if statement */

	HGLOBAL hglb = LoadResource(_Module.GetModuleInstance(), hrsrc); 
	return (DLGTEMPLATE *) LockResource(hglb); 
} /* end of function DoLockDlgRes */

/*************************************************************/
/* Name: OnSelChanged
/* Description: processes the TCN_SELCHANGE notification. 
	hwndDlg - handle to the parent dialog box. 
/*************************************************************/
VOID WINAPI COptionsDlg::OnSelChanged() 
{ 
	int iSel = TabCtrl_GetCurSel(m_hwndTab); 
	
    // hide current dialog box
    ::ShowWindow(m_hwndDisplay[m_currentSel], SW_HIDE);
    ::ShowWindow(m_hwndDisplay[iSel], SW_SHOW);

	if(iSel == PAGE_PG && IsNewAdmin())  //first time login
	{
        OnDoPasswordDlg(CPasswordDlg::PASSWORDDLG_CHANGE);
    }

    m_currentSel = iSel;
} 

/*************************************************************/
/* Name: OnHelp
/* Description: Display help message for a control
/*************************************************************/
LRESULT COptionsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) 
{
    HELPINFO *lphi = (LPHELPINFO) lParam;

    HWND hwnd = (HWND) lphi->hItemHandle;
    DWORD_PTR contextId = lphi->dwContextId;

    if (contextId != 0) {
        if (contextId >= HIDOK)
            ::WinHelp(m_hWnd, TEXT("windows.hlp"), HELP_CONTEXTPOPUP, contextId);
        else
            ::WinHelp(m_hWnd, TEXT("dvdplay.hlp"), HELP_CONTEXTPOPUP, contextId);

    }
    return 0;
}

/*************************************************************/
/* Name: OnContextMenu
/* Description: Display help message for a control
/*************************************************************/
LRESULT COptionsDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) 
{
    HWND hwnd = (HWND) wParam; 
    DWORD controlId = ::GetDlgCtrlID(hwnd);

    POINT pt;
    pt.x = GET_X_LPARAM(lParam); 
    pt.y = GET_Y_LPARAM(lParam); 

    if (controlId == 0) { 
        ::ScreenToClient(hwnd, &pt);
        hwnd = ::ChildWindowFromPoint(hwnd, pt);
        controlId = ::GetDlgCtrlID(hwnd);
    }

    for (int i=0; i<g_helpIDArraySize; i++) {
        if (controlId && controlId == g_helpIDArray[i][0]) {
            if (controlId <= IDC_APPLY) {
                ::WinHelp(hwnd, TEXT("windows.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)g_helpIDArray);
                return 0;
            }
            else {
                ::WinHelp(hwnd, TEXT("dvdplay.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)g_helpIDArray);
                return 0;
            }
        }
    }

    return 0;
}

/*************************************************************/
/* Name: OnApply
/* Description: 
/*************************************************************/
LRESULT COptionsDlg::OnApply(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    bHandled = FALSE;

    // apply changes in all pages
    if (m_hwndDisplay[PAGE_CHAP])
        chapSrch_OnApply(m_hwndDisplay[PAGE_CHAP]);
    
    if (m_hwndDisplay[PAGE_SPRM])
        sprm_OnApply(m_hwndDisplay[PAGE_SPRM]);

    if (m_hwndDisplay[PAGE_PG])
        pg_OnApply(m_hwndDisplay[PAGE_PG]);

    if (m_hwndDisplay[PAGE_KARAOKE])
        karaoke_OnApply(m_hwndDisplay[PAGE_KARAOKE]);

    otherPage_Dirty(FALSE);
    ::EnableWindow(GetDlgItem(IDC_APPLY), FALSE);

    return 1;
}

/*************************************************************/
/* Name: OnOK
/* Description: 
/*************************************************************/
LRESULT COptionsDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    OnApply(wNotifyCode, wID, hWndCtl, bHandled);

    m_pDvdOpt->Fire_OnClose();
	EndDialog(wID);
    return 0;
}

/*************************************************************/
/* Name: OnEndDialog
/* Description: 
/*************************************************************/
LRESULT COptionsDlg::OnEndDialog(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_pDvdOpt->Fire_OnClose();
	EndDialog(wID);
	return 0;
} 

/*************************************************************/
/* Name: OnActivate
/* Description: called when the change/verify password dlg dimisses
/*************************************************************/
LRESULT COptionsDlg::OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) 
{
    if (WA_ACTIVE != LOWORD(wParam))
        return 0;

    HWND tabControl = GetDlgItem(IDC_TABCTRL);
    if (!tabControl) 
        return 0;

	int iSel = TabCtrl_GetCurSel(m_hwndTab);
    if (iSel == PAGE_PG) {
        if (!m_pPasswordDlg)
            return 0;

        if ( m_pPasswordDlg->GetReason() == CPasswordDlg::PASSWORDDLG_VERIFY) {

            // If password verification succeded
            if (m_pPasswordDlg->IsVerified())
                ShowRestartWarning(m_hwndDisplay[PAGE_PG]);
            else
                pg_OnInitDialog(m_hwndDisplay[PAGE_PG]);
        }
    }

    return 0;
}

/*************************************************************/
/* Name: ShowRestartWarning
/* Description: 
/*************************************************************/
void COptionsDlg::ShowRestartWarning(HWND hwndDlg)
{
    HWND staticWarning = ::GetDlgItem(hwndDlg, IDC_WARNING_RESTART);
    if (!staticWarning) return;
    ::ShowWindow(staticWarning, SW_SHOW);
}

/*************************************************************/
/* Name: OnChangePassword
/* Description: 
/*************************************************************/
HRESULT COptionsDlg::OnDoPasswordDlg(CPasswordDlg::PASSWORDDLG_REASON reason)
{
    HRESULT hr = S_OK;
    if (!m_pPasswordDlg) {
        CComPtr<IMSDVDAdm> pDvdAdm;
        hr = GetDvdAdm((LPVOID*) &pDvdAdm);
        if (FAILED(hr) || !pDvdAdm) return hr;
        
        m_pPasswordDlg = new CPasswordDlg(pDvdAdm);
    }

    m_pPasswordDlg->SetReason(reason);
    m_pPasswordDlg->DoModal(m_hwndDisplay[PAGE_PG]); 
    return hr;
}

/*************************************************************/
/* Name: ChildDialogProc
/* Description: DialogProc for the control tabs
/*************************************************************/
INT_PTR CALLBACK ChildDialogProc(
						HWND hwndDlg,  // handle to the child dialog box
						UINT uMsg,     // message
						WPARAM wParam, // first message parameter
						LPARAM lParam  // second message parameter
						)
{
    HWND hwndParent = GetParent(hwndDlg);
    COptionsDlg *pDlgOpt = (COptionsDlg *)::GetWindowLongPtr
        (hwndParent, GWLP_USERDATA);

	switch(uMsg) {
	case WM_INITDIALOG: 
        {
        pDlgOpt->chapSrch_OnInitDialog(hwndDlg);
        pDlgOpt->sprm_OnInitDialog(hwndDlg);
        pDlgOpt->pg_OnInitDialog(hwndDlg);
        if (FAILED(pDlgOpt->karaoke_OnInitDialog(hwndDlg))) {

            HWND hwndTab = ::GetDlgItem(hwndParent, IDC_TABCTRL);
            TabCtrl_DeleteItem(hwndTab, PAGE_ABOUT); 
            TabCtrl_DeleteItem(hwndTab, PAGE_KARAOKE); 
            
            // Add back the about page 
            TCITEM tie; 
            tie.mask = TCIF_TEXT | TCIF_IMAGE; 
            tie.iImage = -1;             
            tie.pszText = LoadStringFromRes(IDS_ABOUT);
            TabCtrl_InsertItem(hwndTab, PAGE_KARAOKE, &tie); 

            pDlgOpt->m_hwndDisplay[PAGE_KARAOKE] = pDlgOpt->m_hwndDisplay[PAGE_ABOUT];
        }
        return TRUE;
        }


    case WM_COMMAND: {
        CComPtr<IMSWebDVD> pDvd;
        HRESULT hr = pDlgOpt->GetDvd(&pDvd);
        if (FAILED(hr) || !pDvd)
            return FALSE;

        switch (HIWORD(wParam)) {
        case BN_CLICKED:
            switch(LOWORD(wParam)) {
            case IDC_BUTTON_CHANGE_PASSWORD:
                pDlgOpt->OnDoPasswordDlg(CPasswordDlg::PASSWORDDLG_CHANGE);
                break;
            case IDC_DISABLE_PARENT: {
                // Return value < 32 bits. Easier to cast than to change to LRESULT
                // all over the code.
                BOOL disableParent = (BOOL)::SendMessage((HWND)lParam, BM_GETCHECK, 0, 0);
                ::EnableWindow(::GetDlgItem(hwndDlg, IDC_COMBO_RATE), !disableParent);
                pDlgOpt->OnDoPasswordDlg(CPasswordDlg::PASSWORDDLG_VERIFY);
                }
                // Fall through
            default:
                pDlgOpt->otherPage_Dirty(TRUE);
                ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), TRUE);
                break;
            }
            break;

        case LBN_SELCHANGE:
            switch(LOWORD(wParam)) {
                case IDC_SUBPIC_LANG:
                case IDC_AUDIO_LANG:
                case IDC_MENU_LANG:
                    pDlgOpt->ShowRestartWarning(hwndDlg);
                    pDlgOpt->otherPage_Dirty(TRUE);
                    ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), TRUE);
                    break;
                case IDC_COMBO_RATE:
                    pDlgOpt->OnDoPasswordDlg(CPasswordDlg::PASSWORDDLG_VERIFY);
                    pDlgOpt->otherPage_Dirty(TRUE);
                    ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), TRUE);
                    break;
                case IDC_AUDIO_LIST:
                    pDlgOpt->karaoke_InitChannelList(hwndDlg);
                    ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), TRUE);
                    break;
                case IDC_LIST_TITLES:
                    pDlgOpt->chapSrch_InitChapList(hwndDlg);
                    // Fall through
                case IDC_LIST_CHAPS:
                    pDlgOpt->chapSrch_Dirty(TRUE);
                    ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), TRUE);
                    break;
                default:
                    pDlgOpt->otherPage_Dirty(TRUE);
                    ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), TRUE);
                    break;
            }
            break;
 
        case LBN_DBLCLK: 
            switch(LOWORD(wParam)) {
            case IDC_LIST_TITLES:
                ::SendMessage(::GetDlgItem(hwndDlg, IDC_LIST_CHAPS), LB_SETCURSEL, (WPARAM)-1, 0);
                // Fall through
            case IDC_LIST_CHAPS:
                pDlgOpt->chapSrch_Dirty(TRUE);
                pDlgOpt->chapSrch_OnApply(hwndDlg);

                // If no other page is dirty, disable the apply button
                if (!pDlgOpt->otherPage_Dirty())
                    ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), FALSE);
                break;
            case IDC_AUDIO_LIST:
                pDlgOpt->karaoke_OnApply(hwndDlg);

                // If no other page is dirty, disable the apply button
                if (!pDlgOpt->otherPage_Dirty())
                    ::EnableWindow(::GetDlgItem(hwndParent, IDC_APPLY), FALSE);
                break;
            }
            break;

        }
        return FALSE;

        }
    }

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\callback.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/*************************************************************/
/* Name: callback.cpp
/* Description: 
/*************************************************************/

#include "stdafx.h"
#include <streams.h>
#include <stdio.h>
#include "COptDlg.h"

const TCHAR g_szRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\DVD");

/*************************************************************/
/* Name: GetRegistryDword
/* Description: 
/*************************************************************/
BOOL GetRegistryDword(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)) 
            *dwRet = dwDefault;

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryString
/* Description: 
/*************************************************************/
BOOL GetRegistryString(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    lstrcpy(szRet, szDefault);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            lstrcpy(szRet, szDefault);
            *dwLen = 0;
        }
        *dwLen = *dwLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: LoadBSTRFromRes
/* Description: load string from resource and convert to wchar
/* if necessary, return the BSTR pointer if successful, NULL
/* otherwise
/*************************************************************/
CComBSTR LoadBSTRFromRes(DWORD resId)
{
    CComBSTR pBSTR;
    if (pBSTR.LoadString( _Module.GetModuleInstance(), resId))
        return pBSTR;
    else
        return NULL;
}

/*************************************************************/
/* Name: LoadStringFromRes
/* Description: load a string from resource
/*************************************************************/
LPTSTR LoadStringFromRes(DWORD redId)
{
    TCHAR *string = new TCHAR[MAX_PATH];
    LoadString(_Module.GetModuleInstance(), redId, string, MAX_PATH);
    return string;
}

/*************************************************************/
/* Function: lstrlenWInternal                                */
/*************************************************************/
int WINAPI lstrlenWInternal(LPCWSTR lpString){

    int length = 0;
    while (*lpString++ != L'\0')
        length++;
    return length;
}/* end of function lstrlenWInternal */

/*************************************************************/
/* Name: chapSrch_OnInitDialog
/* Description: OnInitDialog for Chapter Search page
/*************************************************************/
HRESULT COptionsDlg::chapSrch_OnInitDialog(HWND hwndDlg)
{
    HWND titleWnd = ::GetDlgItem(hwndDlg, IDC_LIST_TITLES);
    HWND chapWnd = ::GetDlgItem(hwndDlg, IDC_LIST_CHAPS);
	if (!titleWnd || !chapWnd) 
        return S_FALSE;

    ::EnableWindow(titleWnd, TRUE);
    ::EnableWindow(chapWnd, TRUE);

	ATLTRACE(TEXT("WM_INITDIALOG\n"));

	HRESULT hr = S_OK;
    try {
        
        LONG nTitles;
        hr = m_pDvd->get_TitlesAvailable(&nTitles);
        if (FAILED(hr)) 
            throw(hr);
        
        LONG currentTitle = 0;
        HRESULT hr = m_pDvd->get_CurrentTitle(&currentTitle);

        for (long i=0; i<nTitles; i++) {
            TCHAR name[32];
            LPTSTR szTitleNo = LoadStringFromRes(IDS_INI_TITLE_NO);
            wsprintf(name, szTitleNo, i+1);
            delete[] szTitleNo;

            ::SendMessage(titleWnd, LB_INSERTSTRING, (UINT)-1, (LPARAM)name);
            if (i+1 == currentTitle) {
                ::SendMessage(titleWnd, LB_SETCURSEL, (WPARAM)i, 0);
            }
        }

        chapSrch_InitChapList(hwndDlg);
    }
    catch (HRESULT hr) {
        ::EnableWindow(titleWnd, FALSE);
        ::EnableWindow(chapWnd, FALSE);
        return hr;
    }

	return hr;
}

/*************************************************************/
/* Name: chapSrch_InitChapList
/* Description: 
/*************************************************************/
HRESULT COptionsDlg::chapSrch_InitChapList(HWND hwndDlg) 
{
    HWND titleWnd = ::GetDlgItem(hwndDlg, IDC_LIST_TITLES);
    HWND chapWnd = ::GetDlgItem(hwndDlg, IDC_LIST_CHAPS);
	if (!titleWnd || !chapWnd) 
        return S_FALSE;

    ::SendMessage(chapWnd, LB_RESETCONTENT, 0, 0);

    LONG nTitle = (LONG) ::SendMessage(titleWnd, LB_GETCURSEL, 0, 0);

    LONG nChaps;
    HRESULT hr = m_pDvd->GetNumberOfChapters(nTitle+1, &nChaps);
    if (FAILED(hr))
        return hr;

    long currentChap = 0;

    hr = m_pDvd->get_CurrentChapter(&currentChap);
    for (int j=0; j<nChaps; j++) {
        TCHAR name[32];
        LPTSTR szChapNo = LoadStringFromRes(IDS_INI_CHAP_NO);
        wsprintf(name, szChapNo, j+1);
        delete[] szChapNo;

        ::SendMessage(chapWnd, LB_INSERTSTRING, (UINT)-1, (LPARAM)name);
        if (currentChap ==j+1)
            ::SendMessage(chapWnd, LB_SETCURSEL, (WPARAM)j, 0);        
    }

    if (LB_ERR == ::SendMessage(chapWnd, LB_GETCURSEL, 0, 0))
        ::SendMessage(chapWnd, LB_SETCURSEL, (WPARAM)0, 0);        

    return hr;
}

/*************************************************************/
/* Name: chapSrch_OnApply
/* Description: OnApply for Chapter Search page
/*************************************************************/
HRESULT COptionsDlg::chapSrch_OnApply(HWND hwndDlg) 
{
    if (!m_bChapDirty)
        return S_OK;

    HWND titleWnd = ::GetDlgItem(hwndDlg, IDC_LIST_TITLES);
    HWND chapWnd = ::GetDlgItem(hwndDlg, IDC_LIST_CHAPS);
	if (!titleWnd || !chapWnd) 
        return S_FALSE;

    LONG nTitle = (LONG) ::SendMessage(titleWnd, LB_GETCURSEL, 0, 0);
    LONG nChapter = (LONG) ::SendMessage(chapWnd, LB_GETCURSEL, 0, 0);

    if (nTitle == LB_ERR)
        return S_FALSE;

    HRESULT hr = S_OK;
    if (nChapter == LB_ERR) {
	    hr = m_pDvd->PlayTitle(nTitle+1);

        // if Title_Play is inhibited by UOP
        if (hr == VFW_E_DVD_OPERATION_INHIBITED) {

	        hr = m_pDvd->PlayChapterInTitle(nTitle+1, 1);
        }
    }
    else {
	    hr = m_pDvd->PlayChapterInTitle(nTitle+1, nChapter+1);
    } /* end if statement */

    // Play at the right speed
    if (SUCCEEDED(hr)) {
        double playSpeed;
        GetDvdOpt()->get_PlaySpeed(&playSpeed);
        hr = m_pDvd->PlayForwards(playSpeed, VARIANT_TRUE);
    }
    else {
        DVDMessageBox(hwndDlg, IDS_INI_CANNOT_PLAYCHAP);
    }

    m_bChapDirty = FALSE;
	return hr;
}

/*************************************************************/
/* Name: karaoke_OnInitDialog
/* Description: OnApply for Chapter Search page
/*************************************************************/
HRESULT COptionsDlg::karaoke_OnInitDialog(HWND hwnd) 
{
    if (!karaoke_HasKaraokeContent())
        return E_FAIL;

    USES_CONVERSION;
	HWND audioList = ::GetDlgItem(hwnd, IDC_AUDIO_LIST);
	if (!audioList) 
        return S_FALSE;

    ::SendMessage(audioList, LB_RESETCONTENT, 0, 0);

    long nAudio;
    HRESULT hr = m_pDvd->get_AudioStreamsAvailable(&nAudio);
    if (FAILED(hr) || nAudio == 0)
        return S_FALSE;

    for (int i=0; i<nAudio; i++) {
        CComBSTR strAudio;
        hr = m_pDvd->GetAudioLanguage(i, VARIANT_TRUE, &strAudio);
        if (SUCCEEDED(hr)) {
            ::SendMessage(audioList, LB_INSERTSTRING, (UINT)-1, (LPARAM)OLE2T(strAudio));
            ::SysFreeString(strAudio);
        }
    }

    long nCurrentAudio = 0;
    m_pDvd->get_CurrentAudioStream(&nCurrentAudio);

    ::SendMessage(audioList, LB_SETCURSEL, (WPARAM)nCurrentAudio, 0);

    karaoke_InitChannelList(hwnd);
    return S_OK;
}

/*************************************************************/
/* Name: karaoke_OnApply
/* Description: OnApply for Chapter Search page
/*************************************************************/
HRESULT COptionsDlg::karaoke_OnApply(HWND hwnd) 
{
	HWND audioList = ::GetDlgItem(hwnd, IDC_AUDIO_LIST);
	if (!audioList) 
        return S_FALSE;

    // Check if audio stream selection has changed
    long nAudio = 0;
    HRESULT hr = m_pDvd->get_CurrentAudioStream(&nAudio);
    if(SUCCEEDED(hr) && nAudio != (long)::SendMessage(audioList, LB_GETCURSEL, 0, 0)) {

        hr = VFW_E_DVD_INVALIDDOMAIN;
        long nDomain;
        HRESULT hrTmp = m_pDvd->get_CurrentDomain(&nDomain);
        
        // Only allow it in title domain
        if (SUCCEEDED(hrTmp) && nDomain == DVD_DOMAIN_Title) {
            nAudio = (long)::SendMessage(audioList, LB_GETCURSEL, 0, 0);
            hr = m_pDvd->put_CurrentAudioStream(nAudio);
        }
        
        if (!SUCCEEDED(hr)) {
            LPTSTR strMsg = NULL;
            switch(hr) {
            case VFW_E_DVD_OPERATION_INHIBITED:
                strMsg = LoadStringFromRes(IDS_INI_INVALIDEUOP);
                break;
            case VFW_E_DVD_INVALIDDOMAIN:
                strMsg = LoadStringFromRes(IDS_INI_INVALIDEDOMAIN);
                break;                
            }

            if (strMsg) {
                ::MessageBox(hwnd, strMsg, NULL, MB_OK);
                delete[] strMsg;
            }

            karaoke_OnInitDialog(hwnd);            
        }
    }

	HWND enableChan2 = ::GetDlgItem(hwnd, IDC_CHECK_CHAN2);
	HWND enableChan3 = ::GetDlgItem(hwnd, IDC_CHECK_CHAN3);
	HWND enableChan4 = ::GetDlgItem(hwnd, IDC_CHECK_CHAN4);
	if (!enableChan2 || !enableChan3 || !enableChan4) 
        return S_FALSE;

    // No no check box is enabled
    if (!(::IsWindowEnabled(enableChan2) ||
          ::IsWindowEnabled(enableChan3) ||
          ::IsWindowEnabled(enableChan4) ))
        return S_FALSE;


    BOOL bEnableChan2 = (BOOL) ::SendMessage(enableChan2, BM_GETCHECK, 0, 0);
    BOOL bEnableChan3 = (BOOL) ::SendMessage(enableChan3, BM_GETCHECK, 0, 0);
    BOOL bEnableChan4 = (BOOL) ::SendMessage(enableChan4, BM_GETCHECK, 0, 0);

    long mixMode = 0;

    if (bEnableChan2)
        mixMode |= DVD_Mix_2to0 | DVD_Mix_2to1;
    if (bEnableChan3)
        mixMode |= DVD_Mix_3to0 | DVD_Mix_3to1;
    if (bEnableChan4)
        mixMode |= DVD_Mix_4to0 | DVD_Mix_4to1;

    long mixModeSaved = 0;
    hr = m_pDvd->get_KaraokeAudioPresentationMode(&mixModeSaved);
    if (mixMode == mixModeSaved)
        return hr;

    hr = m_pDvd->put_KaraokeAudioPresentationMode(mixMode);
    if (SUCCEEDED(hr))
        return hr;

    LPTSTR strMsg = NULL;
    switch(hr) {
    case VFW_E_DVD_OPERATION_INHIBITED:
        strMsg = LoadStringFromRes(IDS_INI_INVALIDEUOP);
        break;
    case VFW_E_DVD_INVALIDDOMAIN:
        strMsg = LoadStringFromRes(IDS_INI_INVALIDEDOMAIN);
        break;
    case E_PROP_SET_UNSUPPORTED:
    default:
        strMsg = LoadStringFromRes(IDS_INI_NOKARAOKESUPPORT);
        break;
    }

    if (strMsg) {
        ::MessageBox(hwnd, strMsg, NULL, MB_OK);
        delete[] strMsg;
    }

    karaoke_InitChannelList(hwnd);

    HWND hwndParent = ::GetParent(hwnd);
    ::SetFocus(::GetDlgItem(hwndParent, IDCANCEL));
    return hr;
}

/*************************************************************/
/* Name: karaoke_InitChannelList
/* Description: 
/*************************************************************/
HRESULT COptionsDlg::karaoke_InitChannelList(HWND hwnd) 
{
	HWND audioList = ::GetDlgItem(hwnd, IDC_AUDIO_LIST);
	if (!audioList) 
        return S_FALSE;
	
    HWND enableChan2 = ::GetDlgItem(hwnd, IDC_CHECK_CHAN2);
	HWND enableChan3 = ::GetDlgItem(hwnd, IDC_CHECK_CHAN3);
	HWND enableChan4 = ::GetDlgItem(hwnd, IDC_CHECK_CHAN4);
	if (!enableChan2 || !enableChan3 || !enableChan4) 
        return S_FALSE;

    // hide all check boxes first
    ::ShowWindow(enableChan2, SW_HIDE);
    ::ShowWindow(enableChan3, SW_HIDE);
    ::ShowWindow(enableChan4, SW_HIDE);

    HRESULT hr = S_OK;
    try {
        long mixMode = 0;
        hr = m_pDvd->get_KaraokeAudioPresentationMode(&mixMode);
        if (FAILED(hr))
            return hr;
        
        ::SendMessage(enableChan2, BM_SETCHECK, (mixMode & (DVD_Mix_2to0 | DVD_Mix_2to1))? 
            BST_CHECKED:BST_UNCHECKED, 0);
        ::SendMessage(enableChan3, BM_SETCHECK, (mixMode & (DVD_Mix_3to0 | DVD_Mix_3to1))? 
            BST_CHECKED:BST_UNCHECKED, 0);
        ::SendMessage(enableChan4, BM_SETCHECK, (mixMode & (DVD_Mix_4to0 | DVD_Mix_4to1))? 
            BST_CHECKED:BST_UNCHECKED, 0);
        
        long nAudio = (long) ::SendMessage(audioList, LB_GETCURSEL, 0, 0);
        long nAssignment = 0;
        hr = m_pDvd->GetKaraokeChannelAssignment(nAudio, &nAssignment);
        if (FAILED(hr)) {
            throw(hr);
        }
        
        for (int i=2; i<5; i++) {

            long nContent;
            hr = m_pDvd->GetKaraokeChannelContent(nAudio, i, &nContent);
            if (FAILED(hr)) {
                throw(hr);
            }

            LPTSTR strContent = karaoke_InitContentString(nContent);
            if (lstrlen(strContent) > 0) {
                ::SetWindowText(::GetDlgItem(hwnd, IDC_CHECK_CHAN2+i-2), strContent);
                ::ShowWindow(::GetDlgItem(hwnd, IDC_CHECK_CHAN2+i-2), SW_SHOW);
            }

            delete[] strContent;
        }
    }
    catch (...) {
    }

    return hr;
}

/*************************************************************/
/* Name: karaoke_InitContentString
/* Description: 
/*************************************************************/
LPTSTR COptionsDlg::karaoke_InitContentString(long nContent) 
{
    TCHAR* strAllContent = new TCHAR[MAX_PATH];
    strAllContent[0] = TEXT('\0');

    if (nContent&DVD_Karaoke_GuideVocal1 &&
        nContent&DVD_Karaoke_GuideVocal2) {
        LPTSTR strContent = LoadStringFromRes(IDS_INI_GUIDEVOCAL12);
        _stprintf(strAllContent, TEXT("%s "), strContent);
        delete[] strContent;
    }
    else if (nContent&DVD_Karaoke_GuideVocal1) {
        LPTSTR strContent = LoadStringFromRes(IDS_INI_GUIDEVOCAL1);
        _stprintf(strAllContent, TEXT("%s "), strContent);
        delete[] strContent;
    }
    else if (nContent&DVD_Karaoke_GuideVocal2) {
        LPTSTR strContent = LoadStringFromRes(IDS_INI_GUIDEVOCAL2);
        _stprintf(strAllContent+lstrlen(strAllContent),TEXT("%s "), strContent);
        delete[] strContent;
    }

    if (nContent&DVD_Karaoke_GuideMelody1 ||
        nContent&DVD_Karaoke_GuideMelody2 ||
        nContent&DVD_Karaoke_GuideMelodyA ||
        nContent&DVD_Karaoke_GuideMelodyB) {
        LPTSTR strContent = LoadStringFromRes(IDS_INI_GUIDEMELODY);
        _stprintf(strAllContent+lstrlen(strAllContent), TEXT("%s "), strContent);
        delete[] strContent;
    }

    if (nContent&DVD_Karaoke_SoundEffectA ||
        nContent&DVD_Karaoke_SoundEffectB) {
        LPTSTR strContent = LoadStringFromRes(IDS_INI_SOUNDEFFECT);
        _stprintf(strAllContent+lstrlen(strAllContent), TEXT("%s "), strContent);
        delete[] strContent;
    }

    return strAllContent;
}

/*************************************************************/
/* Name: karaoke_HasKaraokeContent
/* Description: 
/*************************************************************/
BOOL COptionsDlg::karaoke_HasKaraokeContent() {

    // Only allow it in title domain
    long nDomain;    
    HRESULT hr = m_pDvd->get_CurrentDomain(&nDomain);
    if (FAILED(hr) || nDomain != DVD_DOMAIN_Title) 
        return FALSE;
    
    long nAudio;
    hr = m_pDvd->get_AudioStreamsAvailable(&nAudio);
    if (FAILED(hr) || nAudio == 0)
        return FALSE;
    
    long nAssignment = 0;
    for (int i=0; i<nAudio; i++) {
        hr = m_pDvd->GetKaraokeChannelAssignment(i, &nAssignment);
        if (SUCCEEDED(hr) && nAssignment >= DVD_Assignment_LR) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\coptdlg.h ===
// COptDlg.h : Declaration of the COptionsDlg class
//
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
// All rights reserved.


#include <commctrl.h>
#include "resource.h"
#include "Msdvdopt.h"
#include "dvdopt.h"
#include "password.h"

#define C_PAGES         5  
#define PAGE_CHAP       0
#define PAGE_SPRM       1
#define PAGE_PG         2
#define PAGE_KARAOKE    3
#define PAGE_ABOUT      4

#define MAX_SCAN_SPEED  4
#define MIN_SCAN_SPEED  1
#define MAX_PLAY_SPEED  0
#define MIN_PLAY_SPEED -3 

#define LEVEL_G		    1
#define LEVEL_G_PG      2  
#define LEVEL_PG	    3
#define LEVEL_PG13	    4
#define LEVEL_PG_R      5
#define LEVEL_R		    6
#define LEVEL_NC17	    7
#define LEVEL_ADULT	    8
#define LEVEL_DISABLED  -1

#define GET_X_LPARAM(lp)   ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)   ((int)(short)HIWORD(lp))

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg

class COptionsDlg : public CDialogImpl<COptionsDlg>
{
	BEGIN_MSG_MAP(COptionsDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
		MESSAGE_HANDLER(WM_HELP, OnHelp)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
		COMMAND_ID_HANDLER(IDOK, OnOK)
		COMMAND_ID_HANDLER(IDCANCEL, OnEndDialog)
		COMMAND_ID_HANDLER(IDC_APPLY, OnApply)
	END_MSG_MAP()
		
    static HRESULT pg_InitRateList(HWND ctlList, long level);
    static LPTSTR karaoke_InitContentString(long nContent);
    static long pg_GetLevel(LPTSTR szRate);
    static BOOL IsNewAdmin();

    HRESULT GetDvdAdm(LPVOID* ppAdmin);
    HRESULT GetDvd(IMSWebDVD** ppDvd);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnActivate  (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnApply(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEndDialog(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT OnDoPasswordDlg(CPasswordDlg::PASSWORDDLG_REASON reason);
    HRESULT chapSrch_InitChapList(HWND chapList);
    HRESULT chapSrch_OnInitDialog(HWND hwndDlg);
    HRESULT chapSrch_OnApply(HWND hwnd);
    void    chapSrch_Dirty(BOOL bDirty) {m_bChapDirty = bDirty;}
    BOOL    chapSrch_Dirty() {return m_bChapDirty;}
    void    otherPage_Dirty(BOOL bDirty) {m_bDirty = bDirty;}
    BOOL    otherPage_Dirty() {return m_bDirty;}
    
    HRESULT karaoke_OnInitDialog(HWND hwnd);
    HRESULT karaoke_OnApply(HWND hwnd);
    HRESULT karaoke_InitChannelList(HWND hwnd);
    BOOL    karaoke_HasKaraokeContent();

    HRESULT sprm_InitLangList(HWND cList, WORD id);
    HRESULT sprm_OnInitDialog(HWND hwndDlg);
    HRESULT sprm_OnApply(HWND hwnd);
    HRESULT pg_OnInitDialog(HWND hwndDlg);
    HRESULT pg_OnApply(HWND hwndDlg);

    void    ShowRestartWarning(HWND hwndDlg);

    enum { IDD = IDD_OPTIONS };
	double m_dFFSpeed;
	double m_dBWSpeed;
	double m_dPlaySpeed;

    COptionsDlg(IMSWebDVD* pDvd = NULL);
    virtual ~COptionsDlg(); 

    void SetDvd(IMSWebDVD *pDvd)  { m_pDvd = pDvd; }
    void SetDvdOpt(Cdvdopt *pDvdOpt)  { m_pDvdOpt = pDvdOpt; }
    Cdvdopt* GetDvdOpt()          { return m_pDvdOpt; }
    HWND m_hwndDisplay[C_PAGES];   // child dialog boxs

private:
	DLGTEMPLATE * WINAPI DoLockDlgRes(LPCTSTR lpszResName);
	VOID WINAPI OnSelChanged();

    HWND m_hwndTab;       // tab control 
    DLGTEMPLATE *m_apRes[C_PAGES]; 
    UINT m_currentSel;
    CComPtr<IMSWebDVD> m_pDvd;
    Cdvdopt *m_pDvdOpt;
    CPasswordDlg *m_pPasswordDlg;

    BOOL m_bChapDirty;  // If the chapter search page is dirty
    BOOL m_bDirty;      // If any other page is dirty
};

INT_PTR CALLBACK ChildDialogProc(
						HWND hwndDlg,  // handle to the child dialog box
						UINT uMsg,     // message
						WPARAM wParam, // first message parameter
						LPARAM lParam  // second message parameter
						);

CComBSTR LoadBSTRFromRes(DWORD resId);
LPTSTR LoadStringFromRes(DWORD redId);

BOOL GetRegistryDword(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault);
BOOL GetRegistryString(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault);

extern "C"  const TCHAR g_szPassword[];
extern "C"  const TCHAR g_szPlayerLevel[];
extern "C"  const TCHAR g_szDisableParent[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\dvdopt.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// dvdopt.cpp : Implementation of Cdvdopt

#include "stdafx.h"
#include "Msdvdopt.h"
#include "dvdopt.h"
#include "COptDlg.h"
#include "override.h"

extern LPTSTR LoadStringFromRes(DWORD redId);

/////////////////////////////////////////////////////////////////////////////
// Cdvdopt

/*************************************************************/
/* Name: Cdvdopt
/* Description: Constructor
/*************************************************************/
Cdvdopt::Cdvdopt()  
{ 
    m_pDlgOpt = NULL; 

    m_pDvd = NULL; 
    m_hParentWnd = NULL; 
}

/*************************************************************/
/* Name: ~Cdvdopt
/* Description: destructor
/*************************************************************/
Cdvdopt::~Cdvdopt(){ 

    ATLTRACE(TEXT("In the destructor of the CDVDOPT !\n"));
    CleanUp();
#ifdef _DEBUG
    m_pDvd.Release();
#endif
}/* end of function Cdvdopt */

/*************************************************************/
/* Name: CleanUp
/* Description: Delete all dialogs
/*************************************************************/
void Cdvdopt::CleanUp()
{
    if (m_pDlgOpt) {
        delete m_pDlgOpt;
        m_pDlgOpt = NULL;
    }
}

/*************************************************************/
/* Name: get_WebDVD
/* Description: Get IDispatch of the IMSWebDVD that the options
/*  dialog is controling
/*************************************************************/
STDMETHODIMP Cdvdopt::get_WebDVD(IDispatch **pVal){

    HRESULT hr = E_FAIL;

    if(!m_pDvd){

        return(hr);
    }/* end of if statement */

    hr  = m_pDvd->QueryInterface(IID_IDispatch, (LPVOID*) pVal);
    
	return hr;
}

/*************************************************************/
/* Name: put_WebDVD
/* Description: Set IDispatch of a IMSWebDVD that the options
/*  dialog is going to control
/*************************************************************/
STDMETHODIMP Cdvdopt::put_WebDVD(IDispatch *newVal){

   HRESULT hr = newVal->QueryInterface(IID_IMSWebDVD, (LPVOID*) &m_pDvd);

#ifdef _DEBUG2
    IFilterGraph* pGraph = NULL;
    hr = pDvd->QueryInterface(IID_IFilterGraph, (LPVOID*) &pGraph);
    ATLASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
        pGraph->Release();
#endif

    CleanUp();
    
    m_pDlgOpt = new COptionsDlg(m_pDvd);
    m_pDlgOpt->SetDvdOpt(this);
    
    return S_OK;
}

/*************************************************************/
/* Name: get_ParentWindow
/* Description: Get parent window of the options dialog
/*************************************************************/
STDMETHODIMP Cdvdopt::get_ParentWindow(VARIANT *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    /*
     * BUGBUG: If pVal was a properly initialized variant, we should
     * call VariantClear to free any pointers. If it wasn't initialized
     * VariantInit is the right thing to call instead. I prefer a leak 
     * to a crash so I'll use VariantInit below
     */

    VariantInit(pVal);

#ifdef _WIN64
    pVal->vt = VT_I8;
    pVal->llVal = (LONG_PTR)m_hParentWnd;
#else
    pVal->vt = VT_I4;
    pVal->lVal  = (LONG_PTR)m_hParentWnd;
#endif

	return S_OK;
}

/*************************************************************/
/* Name: put_ParentWindow
/* Description: Set parent window of the options dialog
/*************************************************************/
STDMETHODIMP Cdvdopt::put_ParentWindow(VARIANT newVal)
{
    VARIANT dest;
    VariantInit(&dest);
    HRESULT hr = S_OK;
#ifdef _WIN64
    hr = VariantChangeTypeEx(&dest, &newVal, 0, 0, VT_I8);
    if (FAILED(hr))
        return hr;
    m_hParentWnd = (HWND) dest.llVal;
#else
    hr = VariantChangeTypeEx(&dest, &newVal, 0, 0, VT_I4);
    if (FAILED(hr))
        return hr;
    m_hParentWnd = (HWND) dest.lVal;
#endif

	return hr;
}

/*************************************************************/
/* Name: Show
/* Description: Show the options dialog 
/*************************************************************/
STDMETHODIMP Cdvdopt::Show()
{
    m_pDlgOpt->DoModal(m_hParentWnd);
	return S_OK;
}

/*************************************************************/
/* Name: Close
/* Description: Close the options dialog
/*************************************************************/
STDMETHODIMP Cdvdopt::Close()
{
    m_pDlgOpt->EndDialog(0);
	return S_OK;
}

/*************************************************************/
/* Name: Power
/* Description: Raise a number to a power
/*************************************************************/
double Power(LONG n, LONG p)
{
    double result = 1;
    if (p==0) return result;
    if (p>0) {
        while (p--)
            result *= n;
        return result;
    }
    else {
        while (p++)
            result *= n;
        return 1/result;
    }
}

/*************************************************************/
/* Name: get_ForwardScanSpeed
/* Description: return the forward scan speed
/*************************************************************/
STDMETHODIMP Cdvdopt::get_ForwardScanSpeed(double *pVal)
{
    *pVal = m_pDlgOpt->m_dFFSpeed;
	return S_OK;
}

/*************************************************************/
/* Name: put_ForwardScanSpeed
/* Description: return the forward scan speed
/*************************************************************/
STDMETHODIMP Cdvdopt::put_ForwardScanSpeed(double newVal)
{
    m_pDlgOpt->m_dFFSpeed = newVal;
	return S_OK;
}

/*************************************************************/
/* Name: get_BackwardScanSpeed
/* Description: return backward scan speed
/*************************************************************/
STDMETHODIMP Cdvdopt::get_BackwardScanSpeed(double *pVal)
{
    *pVal = m_pDlgOpt->m_dBWSpeed;
	return S_OK;
}

/*************************************************************/
/* Name: put_BackwardScanSpeed
/* Description: return play speed
/*************************************************************/
STDMETHODIMP Cdvdopt::put_BackwardScanSpeed(double newVal)
{
    m_pDlgOpt->m_dBWSpeed = newVal;
	return S_OK;
}

/*************************************************************/
/* Name: get_PlaySpeed
/* Description: return play speed
/*************************************************************/
STDMETHODIMP Cdvdopt::get_PlaySpeed(double *pVal)
{
    *pVal = m_pDlgOpt->m_dPlaySpeed;
	return S_OK;
}

/*************************************************************/
/* Name: put_PlaySpeed
/* Description: return play speed
/*************************************************************/
STDMETHODIMP Cdvdopt::put_PlaySpeed(double newVal)
{
    m_pDlgOpt->m_dPlaySpeed = newVal;
	return S_OK;
}

/*************************************************************/
/* Name: ParentalLevelOverride
/* Description: 
/*************************************************************/
STDMETHODIMP Cdvdopt::ParentalLevelOverride(PG_OVERRIDE_REASON reason)
{
    COverrideDlg dlg(m_pDvd);
    dlg.SetReason(reason);
    dlg.DoModal();

	return S_OK;
}

int DVDMessageBox(HWND hWnd, LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
{
	LPTSTR csCaption;	
	if(lpszCaption == NULL)
	{
		csCaption = LoadStringFromRes(IDS_MSGBOX_TITLE);
		MessageBox(hWnd, lpszText, csCaption, nType );
        delete[] csCaption;
        return 0;
	}
	else
		return MessageBox(hWnd, lpszText, lpszCaption, nType );
}

int DVDMessageBox(HWND hWnd, UINT nID, LPCTSTR lpszCaption, UINT nType)
{
	LPTSTR csMsgString, csCaption;
	csMsgString = LoadStringFromRes(nID);
	if(lpszCaption == NULL)
	{
		csCaption = LoadStringFromRes(IDS_MSGBOX_TITLE);
		MessageBox(hWnd, csMsgString, csCaption, nType );
        delete[] csCaption;
	}
    else {
		MessageBox(hWnd, csMsgString, lpszCaption, nType );
    }

    delete[] csMsgString;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\dvdopt.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// dvdopt.h : Declaration of the Cdvdopt

#ifndef __DVDOPT_H_
#define __DVDOPT_H_

#include "dvdoptCP.h"
#include "resource.h"       // main symbols
#include <atlctl.h>

#define MAX_PASSWD      20
#define PRE_PASSWD      20
#define MAX_RATE        10

class COptionsDlg;

/////////////////////////////////////////////////////////////////////////////
// Cdvdopt
class ATL_NO_VTABLE Cdvdopt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<Idvdopt, &IID_Idvdopt, &LIBID_MSDVDOPTLib>,
	public CComControl<Cdvdopt>,
	public IPersistStreamInitImpl<Cdvdopt>,
	public IOleControlImpl<Cdvdopt>,
	public IOleObjectImpl<Cdvdopt>,
	public IOleInPlaceActiveObjectImpl<Cdvdopt>,
	public IViewObjectExImpl<Cdvdopt>,
	public IOleInPlaceObjectWindowlessImpl<Cdvdopt>,
	public IPersistStorageImpl<Cdvdopt>,
	public ISpecifyPropertyPagesImpl<Cdvdopt>,
	public IQuickActivateImpl<Cdvdopt>,
	public IDataObjectImpl<Cdvdopt>,
	public IProvideClassInfo2Impl<&CLSID_dvdopt, &DIID__IDVDOpt, &LIBID_MSDVDOPTLib>,
	public CComCoClass<Cdvdopt, &CLSID_dvdopt>,
    public CProxy_IDVDOpt< Cdvdopt >,
    public IConnectionPointContainerImpl<Cdvdopt>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DVDOPT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(Cdvdopt)
	COM_INTERFACE_ENTRY(Idvdopt)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(Cdvdopt)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(Cdvdopt)
	CONNECTION_POINT_ENTRY(DIID__IDVDOpt)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(Cdvdopt)
	CHAIN_MSG_MAP(CComControl<Cdvdopt>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

    COptionsDlg *m_pDlgOpt;

    CComPtr<IMSWebDVD> m_pDvd;
    HWND m_hParentWnd;

// Idvdopt
public:
	STDMETHOD(ParentalLevelOverride)(/*[in]*/ PG_OVERRIDE_REASON reason);
	STDMETHOD(get_PlaySpeed)(/*[out, retval]*/ double *pVal);
	STDMETHOD(put_PlaySpeed)(/*[in]*/ double newVal);
	STDMETHOD(get_BackwardScanSpeed)(/*[out, retval]*/ double *pVal);
	STDMETHOD(put_BackwardScanSpeed)(/*[in]*/ double newVal);
	STDMETHOD(get_ForwardScanSpeed)(/*[out, retval]*/ double *pVal);
	STDMETHOD(put_ForwardScanSpeed)(/*[in]*/ double newVal);
    Cdvdopt();
    virtual ~Cdvdopt();

    STDMETHOD(Close)();
	STDMETHOD(Show)();
	STDMETHOD(get_ParentWindow)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_ParentWindow)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_WebDVD)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(put_WebDVD)(/*[in]*/ IDispatch* newVal);

    HRESULT OnDraw(ATL_DRAWINFO& di) { return S_OK;	}

private:
    void CleanUp();
};

int DVDMessageBox(HWND hWnd, LPCTSTR lpszText, LPCTSTR lpszCaption=NULL, UINT nType=MB_OK | MB_ICONEXCLAMATION);
int DVDMessageBox(HWND hWnd, UINT nID, LPCTSTR lpszCaption=NULL, UINT nType=MB_OK | MB_ICONEXCLAMATION);

#endif //__DVDOPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\dvdoptcp.h ===
#ifndef _MSDVDOPTCP_H_
#define _MSDVDOPTCP_H_

template <class T>
class CProxy_IDVDOpt : public IConnectionPointImpl<T, &DIID__IDVDOpt, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnOpen()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnClose()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\msdvdopt.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// msdvdopt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f msdvdoptps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "msdvdopt.h"

#include "msdvdopt_i.c"
#include "COptDlg.h"
#include "dvdopt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_dvdopt, Cdvdopt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSDVDOPTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\override.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_ADMINDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_)
#define AFX_ADMINDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AdminDlg.h : header file
//

#include <atlctl.h>
#include <strmif.h>
#include "resource.h"
#include "msdvdopt.h"
#include "dvdopt.h"

/////////////////////////////////////////////////////////////////////////////
// CAdminDlg dialog

class COverrideDlg : public CDialogImpl<COverrideDlg>
{
// Construction
public:
	COverrideDlg(IMSWebDVD* pDvd = NULL);   // standard constructor

    BEGIN_MSG_MAP(COverrideDlg)
   		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_HELP, OnHelp)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	END_MSG_MAP()

	enum { IDD = IDD_PARENT_OVERRIDE };

    void SetDvd(IMSWebDVD *pDvd)  { m_pDvd = pDvd; }
    void SetReason(PG_OVERRIDE_REASON reason) {m_reason = reason; }

// Implementation
protected:
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    long GetPlayerLevelRequired(long contentLevels);

    CComPtr<IMSWebDVD> m_pDvd;
    PG_OVERRIDE_REASON m_reason;
};


#endif // !defined(AFX_ADMINDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\override.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// AdminDlg.cpp : implementation file
//

#include "stdafx.h"
#include "override.h"
#include "COptDlg.h"
#include "resource.hm"

extern DWORD g_helpIDArray[][2];
extern int g_helpIDArraySize;

/////////////////////////////////////////////////////////////////////////////
// COverrideDlg dialog


COverrideDlg::COverrideDlg(IMSWebDVD* pDvd)
{
    m_pDvd = pDvd; 
}


/////////////////////////////////////////////////////////////////////////////
// CAdminDlg message handlers

LRESULT COverrideDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND ctlAdminPasswd = GetDlgItem(IDC_EDIT_PASSWORD);
    ::SendMessage(ctlAdminPasswd, EM_LIMITTEXT, MAX_PASSWD, 0);

    HWND staticRateHigh = GetDlgItem(IDC_STATIC_RATE_HIGH);
    long lPlayerLevel = -1;
    HRESULT hr = m_pDvd->GetPlayerParentalLevel(&lPlayerLevel);

    if (SUCCEEDED(hr)) {
        TCHAR strRateHigh[MAX_PATH];
        LPTSTR strRateHighTmp = LoadStringFromRes(IDS_INI_RATE_HIGH);
        LPTSTR strPlayerLevel = NULL;
        switch (lPlayerLevel) {
        case LEVEL_G:
            strPlayerLevel = LoadStringFromRes(IDS_INI_RATE_G);
            break;
        case LEVEL_PG:
            strPlayerLevel = LoadStringFromRes(IDS_INI_RATE_PG);
            break;
        case LEVEL_PG13:
            strPlayerLevel = LoadStringFromRes(IDS_INI_RATE_PG13);
            break;
        case LEVEL_R:
            strPlayerLevel = LoadStringFromRes(IDS_INI_RATE_R);
            break;
        default:
            strPlayerLevel = LoadStringFromRes(IDS_INI_RATE_ADULT);
            break;
        }
        wsprintf(strRateHigh, strRateHighTmp, strPlayerLevel);
        delete[] strRateHighTmp;
        delete[] strPlayerLevel;
        ::SetWindowText(staticRateHigh, strRateHigh);
    }

    HWND ctlList = GetDlgItem(IDC_COMBO_RATE);
    if (m_reason == PG_OVERRIDE_CONTENT) {
        ::EnableWindow(ctlList, FALSE);
    }

    else if (m_reason == PG_OVERRIDE_DVDNAV) {
#if 0
        long contentLevels;
        HRESULT hr = m_pDvd->GetTitleParentalLevels(1, &contentLevels);
        if (SUCCEEDED(hr)) {
            lPlayerLevel = GetPlayerLevelRequired(contentLevels);
        }
        else 
#endif
        {
            lPlayerLevel = LEVEL_ADULT;
        }
    }

    COptionsDlg::pg_InitRateList(ctlList, lPlayerLevel);

    return TRUE;
}


LRESULT COverrideDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    USES_CONVERSION;

    if (!m_pDvd)
        return 0;

    HWND ctlPassword = GetDlgItem(IDC_EDIT_PASSWORD);
    TCHAR szPassword[MAX_PASSWD];
    ::GetWindowText(ctlPassword, szPassword, MAX_PASSWD);

    HRESULT hr = S_OK;
    if (m_reason == PG_OVERRIDE_CONTENT) {
        hr = m_pDvd->AcceptParentalLevelChange(VARIANT_TRUE, NULL, T2OLE(szPassword));
        if (hr == E_ACCESSDENIED){
            DVDMessageBox(m_hWnd, IDS_PASSWORD_INCORRECT);
            ::SetWindowText(ctlPassword, _T(""));
            ::SetFocus(ctlPassword);
            return 1;
        }
    }

    else if (m_reason == PG_OVERRIDE_DVDNAV) {
        HWND ctlList = GetDlgItem(IDC_COMBO_RATE);
        long level = (long) ::SendMessage(ctlList, CB_GETCURSEL, 0, 0) ;
        TCHAR szRate[MAX_RATE];
        ::SendMessage(ctlList, CB_GETLBTEXT, level, (LPARAM)szRate);
        
        // Setting the player level without saving in the ini file
        m_pDvd->Stop();
        HRESULT hr = m_pDvd->SelectParentalLevel(COptionsDlg::pg_GetLevel(szRate), NULL, T2OLE(szPassword));
        if (hr == E_ACCESSDENIED){
            DVDMessageBox(m_hWnd, IDS_PASSWORD_INCORRECT);
            ::SetWindowText(ctlPassword, _T(""));
            ::SetFocus(ctlPassword);
            return hr;
        }
        if (FAILED(hr)) {
            ::SetWindowText(ctlPassword, _T(""));
            ::SetFocus(ctlPassword);
            DVDMessageBox(m_hWnd, IDS_RATE_CHANGE_FAIL);
            return hr;
        }
        m_pDvd->Play();
    }

	EndDialog(wID);

    return 0;
}

/*************************************************************/
/* Name: OnHelp
/* Description: Display help message for a control
/*************************************************************/
LRESULT COverrideDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) 
{
    HELPINFO *lphi = (LPHELPINFO) lParam;

    HWND hwnd = (HWND) lphi->hItemHandle;
    DWORD_PTR contextId = lphi->dwContextId;

    if (contextId != 0) {
        if (contextId >= HIDOK)
            ::WinHelp(m_hWnd, TEXT("windows.hlp"), HELP_CONTEXTPOPUP, contextId);
        else
            ::WinHelp(m_hWnd, TEXT("dvdplay.hlp"), HELP_CONTEXTPOPUP, contextId);

    }
    return 0;
}

/*************************************************************/
/* Name: OnContextMenu
/* Description: Display help message for a control
/*************************************************************/
LRESULT COverrideDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) 
{
    bHandled = TRUE;
    HWND hwnd = (HWND) wParam; 
    DWORD controlId = ::GetDlgCtrlID(hwnd);

    POINT pt;
    pt.x = GET_X_LPARAM(lParam); 
    pt.y = GET_Y_LPARAM(lParam); 

    if (controlId == 0) { 
        ::ScreenToClient(hwnd, &pt);
        hwnd = ::ChildWindowFromPoint(hwnd, pt);
        controlId = ::GetDlgCtrlID(hwnd);
    }

    for (int i=0; i<g_helpIDArraySize; i++) {
        if (controlId && controlId == g_helpIDArray[i][0]) {
            if (controlId <= IDC_APPLY)
                ::WinHelp(hwnd, TEXT("windows.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)g_helpIDArray);
            else
                ::WinHelp(hwnd, TEXT("dvdplay.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)g_helpIDArray);
        }
    }

    return 0;
}

LRESULT COverrideDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (m_pDvd)
        m_pDvd->AcceptParentalLevelChange(VARIANT_FALSE, NULL, L"");

	EndDialog(wID);
    DVDMessageBox(m_hWnd, IDS_RATE_TOO_LOW, NULL, MB_OK|MB_HELP);
    return 0;
}

long COverrideDlg::GetPlayerLevelRequired(long contentLevels)
{
    if (contentLevels & DVD_PARENTAL_LEVEL_8)
        return LEVEL_ADULT;
    else if (contentLevels & DVD_PARENTAL_LEVEL_7)
        return LEVEL_NC17;
    else if (contentLevels & DVD_PARENTAL_LEVEL_6)
        return LEVEL_R;
    else if (contentLevels & DVD_PARENTAL_LEVEL_5)
        return LEVEL_R;
    else if (contentLevels & DVD_PARENTAL_LEVEL_4)
        return LEVEL_PG13;
    else if (contentLevels & DVD_PARENTAL_LEVEL_3)
        return LEVEL_PG;
    else if (contentLevels & DVD_PARENTAL_LEVEL_2)
        return LEVEL_PG;
    else 
        return LEVEL_G;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\password.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_PASSDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_)
#define AFX_PASSDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AdminDlg.h : header file
//

#include <atlctl.h>
#include <strmif.h>
#include "resource.h"
#include "msdvdopt.h"
#include "dvdopt.h"

class COptionsDlg;

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog

class CPasswordDlg : public CDialogImpl<CPasswordDlg>
{
// Construction
public:
    BEGIN_MSG_MAP(CPasswordDlg)
   		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	END_MSG_MAP()

    CPasswordDlg(IMSDVDAdm* pDvdAdm);
	enum { IDD = IDD_CHANGEPASSWD };

    typedef enum { PASSWORDDLG_CHANGE=0, PASSWORDDLG_VERIFY} PASSWORDDLG_REASON;

    void SetReason(PASSWORDDLG_REASON reason)   {m_reason = reason; }
    PASSWORDDLG_REASON GetReason()              {return m_reason; }
    BOOL IsVerified()                           {return m_bVerified; }
    LPTSTR GetPassword()                        {return m_szPassword; }

// Implementation
protected:
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    CComPtr<IMSDVDAdm> m_pDvdAdm;
    PASSWORDDLG_REASON m_reason;
    BOOL m_bVerified;
    TCHAR m_szPassword[MAX_PASSWD];
};


#endif // !defined(AFX_PASSDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\password.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// AdminDlg.cpp : implementation file
//

#include "stdafx.h"
#include "coptdlg.h"
#include "password.h"

extern DWORD g_helpIDArray[][2];
extern int g_helpIDArraySize;

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog


CPasswordDlg::CPasswordDlg(IMSDVDAdm* pDvdAdm)
{
    m_pDvdAdm = pDvdAdm;
    m_reason = PASSWORDDLG_CHANGE;
    m_bVerified = FALSE;
    m_szPassword[0] = TEXT('\0');
}

/*************************************************************/
/* Name: OnInitDialog
/* Description: 
/*************************************************************/
LRESULT CPasswordDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND ctlNewPassword = GetDlgItem(IDC_EDIT_NEW_PASSWORD);
	HWND ctlConfirmNew = GetDlgItem(IDC_EDIT_CONFIRM_NEW);
    HWND ctlPassword = GetDlgItem(IDC_EDIT_PASSWORD);

    HWND staticNewPassword = GetDlgItem(IDC_STATIC_NEW_PASSWORD);
	HWND staticConfirmNew = GetDlgItem(IDC_STATIC_CONFIRM_NEW);
    HWND staticPassword = GetDlgItem(IDC_STATIC_PASSWORD);

    if (!ctlNewPassword || !ctlConfirmNew || !ctlPassword)
        return S_FALSE;

    if (!staticNewPassword || !staticConfirmNew || !staticPassword)
        return S_FALSE;

    ::SendMessage(ctlNewPassword, EM_LIMITTEXT, MAX_PASSWD, 0);
    ::SendMessage(ctlConfirmNew, EM_LIMITTEXT, MAX_PASSWD, 0);
    ::SendMessage(ctlPassword, EM_LIMITTEXT, MAX_PASSWD, 0);

    ::SetWindowText(ctlNewPassword, _T(""));
    ::SetWindowText(ctlConfirmNew, _T(""));
    ::SetWindowText(ctlPassword, _T(""));

    if (m_reason == PASSWORDDLG_VERIFY) {
        ::ShowWindow(ctlNewPassword, SW_HIDE);
        ::ShowWindow(staticNewPassword, SW_HIDE);
        ::ShowWindow(ctlConfirmNew, SW_HIDE);
        ::ShowWindow(staticConfirmNew, SW_HIDE);
    }

    else if (m_reason == PASSWORDDLG_CHANGE) {
        ::ShowWindow(ctlNewPassword, SW_SHOW);
        ::ShowWindow(staticNewPassword, SW_SHOW);
        ::ShowWindow(ctlConfirmNew, SW_SHOW);
        ::ShowWindow(staticConfirmNew, SW_SHOW);
        
        if(COptionsDlg::IsNewAdmin())  { //New Admin people
            ::ShowWindow(ctlPassword, SW_HIDE);
            ::ShowWindow(staticPassword, SW_HIDE);
        }
        else {
            ::ShowWindow(ctlPassword, SW_SHOW);
            ::ShowWindow(staticPassword, SW_SHOW);
        }
    }
    return TRUE;
}

/*************************************************************/
/* Name: OnContextMenu
/* Description: Display help message for a control
/*************************************************************/
LRESULT CPasswordDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) 
{
    HWND hwnd = (HWND) wParam; 
    DWORD controlId = ::GetDlgCtrlID(hwnd);

    POINT pt;
    pt.x = GET_X_LPARAM(lParam); 
    pt.y = GET_Y_LPARAM(lParam); 

    if (controlId == 0) { 
        ::ScreenToClient(hwnd, &pt);
        hwnd = ::ChildWindowFromPoint(hwnd, pt);
        controlId = ::GetDlgCtrlID(hwnd);
    }

    for (int i=0; i<g_helpIDArraySize; i++) {
        if (controlId && controlId == g_helpIDArray[i][0]) {
            if (controlId <= IDC_APPLY)
                ::WinHelp(hwnd, TEXT("windows.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)g_helpIDArray);
            else
                ::WinHelp(hwnd, TEXT("dvdplay.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)g_helpIDArray);
        }
    }

    return 0;
}

/*************************************************************/
/* Name: OnOK
/* Description: password change requested
/*************************************************************/
LRESULT CPasswordDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    USES_CONVERSION;
    HWND ctlPassword = GetDlgItem(IDC_EDIT_PASSWORD);
    TCHAR szPassword[MAX_PASSWD];
    ::GetWindowText(ctlPassword, szPassword, MAX_PASSWD);

    HWND ctlNewPassword = GetDlgItem(IDC_EDIT_NEW_PASSWORD);
    TCHAR szNewPassword[MAX_PASSWD];
    ::GetWindowText(ctlNewPassword, szNewPassword, MAX_PASSWD);

	HWND ctlConfirmNew = GetDlgItem(IDC_EDIT_CONFIRM_NEW);
    TCHAR szConfirmNew[MAX_PASSWD];
    ::GetWindowText(ctlConfirmNew, szConfirmNew, MAX_PASSWD);

    HRESULT hr = S_OK;
    if (m_reason == PASSWORDDLG_CHANGE) {
        if(lstrcmp(szNewPassword, szConfirmNew) != 0)
        {
            DVDMessageBox(hWndCtl, IDS_PASSOWRD_CONFIRM_WRONG);
            ::SetWindowText(ctlConfirmNew, _T(""));
            ::SetFocus(ctlConfirmNew);
            return FALSE;
        }
        
        if(COptionsDlg::IsNewAdmin())  //New Admin people
        {
            hr = m_pDvdAdm->ChangePassword(L"", L"", T2OLE(szNewPassword));
        }
        else   //Old Admin people
        {
            hr = m_pDvdAdm->ChangePassword(L"", T2OLE(szPassword), T2OLE(szNewPassword));
            if (hr == E_ACCESSDENIED) {
                DVDMessageBox(hWndCtl, IDS_PASSWORD_INCORRECT);
                ::SetWindowText(ctlPassword, _T(""));
                ::SetFocus(ctlPassword);
                return FALSE;
            }
        }
        if (FAILED(hr)) {
            DVDMessageBox(hWndCtl, IDS_PASSWORD_CHANGE_FAIL);
            ::SetWindowText(ctlPassword, _T(""));
            ::SetFocus(ctlPassword);
            return FALSE;
        }                
    }

    else if (m_reason == PASSWORDDLG_VERIFY) {
        VARIANT_BOOL fRight;
        hr = m_pDvdAdm->ConfirmPassword(L"", T2OLE(szPassword), &fRight);
        if (fRight == VARIANT_FALSE) {
            DVDMessageBox(hWndCtl, IDS_PASSWORD_INCORRECT);
            ::SetFocus(ctlPassword);
            lstrcpy(m_szPassword, szPassword);
            m_bVerified = FALSE;
            return FALSE;
        }
        else {
            lstrcpy(m_szPassword, szPassword);
            m_bVerified = TRUE;
        }
    }

	EndDialog(wID);
    return 0;
}

/*************************************************************/
/* Name: OnCancel
/* Description: 
/*************************************************************/
LRESULT CPasswordDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bVerified = FALSE;
	EndDialog(wID);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\pgcallbk.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/*************************************************************/
/* Name: pgcallbk.cpp
/* Description: 
/*************************************************************/

#include "stdafx.h"
#include "password.h"
#include "COptDlg.h"

const TCHAR g_szPassword[] = TEXT("DVDAdmin.password");
const TCHAR g_szPlayerLevel[] = TEXT("DVDAdmin.rate");
const TCHAR g_szDisableParent[] = TEXT("DVDAdmin.disableParentalControl");

/*************************************************************/
/* Name: GetDvd
/* Description:  
/*************************************************************/
HRESULT COptionsDlg::GetDvd(IMSWebDVD** ppDvd) {

    return m_pDvd.CopyTo(ppDvd);
}

/*************************************************************/
/* Name: GetDvdAdm
/* Description: Use CComPtr to receive the returned interface,
/*  so that reference count will be added and released accordingly
/*************************************************************/
HRESULT COptionsDlg::GetDvdAdm(LPVOID* ppAdmin){

    *ppAdmin = NULL;

    IDispatch* pDvdAdmDisp;
    HRESULT hr = m_pDvd->get_DVDAdm(&pDvdAdmDisp);
    
    if (FAILED(hr)) return NULL;

    hr = pDvdAdmDisp->QueryInterface(IID_IMSDVDAdm, (LPVOID*) ppAdmin);
    pDvdAdmDisp->Release();

    return(hr);
}/* end of function GetDvdAdm */

/*************************************************************/
/* Name: pg_GetLevel
/* Description: return the parental level number
/*************************************************************/
long COptionsDlg::pg_GetLevel(LPTSTR szRate) 
{
    long lLevel = LEVEL_ADULT;

    LPTSTR csStr = LoadStringFromRes(IDS_INI_RATE_G);
   	if(lstrcmp(szRate, csStr) == 0)
		lLevel = LEVEL_G;

    delete[] csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_PG);
	if(lstrcmp(szRate, csStr) == 0)
		lLevel = LEVEL_PG;

    delete[] csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_PG13);
	if(lstrcmp(szRate, csStr) == 0)
        lLevel = LEVEL_PG13;

    delete[] csStr;
    csStr = LoadStringFromRes(IDS_INI_RATE_R);
	if(lstrcmp(szRate, csStr) == 0)
		lLevel = LEVEL_R;

    delete[] csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_NC17);
	if(lstrcmp(szRate, csStr) == 0)
		lLevel = LEVEL_NC17;

    delete[] csStr;
    csStr = LoadStringFromRes(IDS_INI_RATE_ADULT);
	if(lstrcmp(szRate, csStr) == 0)
		lLevel =  LEVEL_ADULT;

    delete[] csStr;
    return lLevel;
}

/*************************************************************/
/* Name: pg_InitRateList
/* Description: Initialize parental level combo list
/*************************************************************/
HRESULT COptionsDlg::pg_InitRateList(HWND ctlList, long level)
{

    ::SendMessage(ctlList, CB_RESETCONTENT, 0, 0);

    LPTSTR csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_G);
    ::SendMessage(ctlList, CB_INSERTSTRING, (UINT)-1, (LPARAM) csStr);
    delete csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_PG);
    ::SendMessage(ctlList, CB_INSERTSTRING, (UINT)-1, (LPARAM) csStr);
    delete csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_PG13);
    ::SendMessage(ctlList, CB_INSERTSTRING, (UINT)-1, (LPARAM) csStr);
    delete csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_R);
    ::SendMessage(ctlList, CB_INSERTSTRING, (UINT)-1, (LPARAM) csStr);
    delete csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_NC17);	
    ::SendMessage(ctlList, CB_INSERTSTRING, (UINT)-1, (LPARAM) csStr);
    delete csStr;
	csStr = LoadStringFromRes(IDS_INI_RATE_ADULT);
    ::SendMessage(ctlList, CB_INSERTSTRING, (UINT)-1, (LPARAM) csStr);
    delete csStr;

    switch (level) {
    case LEVEL_G:
    case LEVEL_G_PG:
        SendMessage(ctlList, CB_SETCURSEL, (WPARAM) 0, 0);
        break;
    case LEVEL_PG:
        SendMessage(ctlList, CB_SETCURSEL, (WPARAM) 1, 0);
        break;
    case LEVEL_PG13:
    case LEVEL_PG_R:
        SendMessage(ctlList, CB_SETCURSEL, (WPARAM) 2, 0);
        break;
    case LEVEL_R:
        SendMessage(ctlList, CB_SETCURSEL, (WPARAM) 3, 0);
        break;
    case LEVEL_NC17:
        SendMessage(ctlList, CB_SETCURSEL, (WPARAM) 4, 0);
        break;
    case LEVEL_ADULT:
    default:
        SendMessage(ctlList, CB_SETCURSEL, (WPARAM) 5, 0);
        break;
    }
    return S_OK;
}

/*************************************************************/
/* Name: pg_OnInitDialog
/* Description: OnInitDialog for the parental control page
/*************************************************************/
HRESULT COptionsDlg::pg_OnInitDialog(HWND hwndDlg)
{
    HWND ctlList = ::GetDlgItem(hwndDlg, IDC_COMBO_RATE);
    HWND checkBox = ::GetDlgItem(hwndDlg, IDC_DISABLE_PARENT);
    if (!IDC_COMBO_RATE || !checkBox)
        return S_FALSE;

    HRESULT hr = S_OK;
    CComPtr<IMSDVDAdm> pDvdAdm;
    hr = GetDvdAdm((LPVOID*) &pDvdAdm);
    if (FAILED(hr) || !pDvdAdm) return S_FALSE;

    long level = 0;
    hr = pDvdAdm->GetParentalLevel(&level);
    pg_InitRateList(ctlList, level);

    BOOL fDisabled = (level == LEVEL_DISABLED);
    ::SendMessage(checkBox, BM_SETCHECK, fDisabled, 0);
    ::EnableWindow(ctlList, !fDisabled);
    
    return S_OK;
}

/*************************************************************/
/* Name: pg_OnApply
/* Description: Apply the parental control setting changes
/*************************************************************/
HRESULT COptionsDlg::pg_OnApply(HWND hwndDlg)
{
    USES_CONVERSION;

    HWND ctlList = ::GetDlgItem(hwndDlg, IDC_COMBO_RATE);
    HWND checkBox = ::GetDlgItem(hwndDlg, IDC_DISABLE_PARENT);
    if (!IDC_COMBO_RATE || !checkBox)
        return S_FALSE;

    if (!m_pPasswordDlg)
        return E_UNEXPECTED;

    BOOL disableParent = (BOOL) ::SendMessage(checkBox, BM_GETCHECK, 0, 0);

    HRESULT hr = S_OK;
    CComPtr<IMSDVDAdm> pDvdAdm;
    hr = GetDvdAdm((LPVOID*) &pDvdAdm);
    if (FAILED(hr) || !pDvdAdm) return S_FALSE;

    // Get the saved settings
    long lLevelSaved;
    pDvdAdm->GetParentalLevel(&lLevelSaved);
    BOOL bChangePG = FALSE;
    
    // Get the selected level in the rate list box
    long level = (long) ::SendMessage(ctlList, CB_GETCURSEL, 0, 0) ;
    TCHAR szRate[MAX_RATE];
    ::SendMessage(ctlList, CB_GETLBTEXT, level, (LPARAM)szRate);
    long lLevel = pg_GetLevel(szRate);

    // If a different parental level is selected from the saved level
    if (!disableParent && lLevel!=lLevelSaved) {
        bChangePG = TRUE;
    }

    // If the disable parental control option is changed from the saved setting
    else if (disableParent && lLevelSaved != LEVEL_DISABLED) {
        // Set parental level to -1 when parental control is disabled
        lLevel = LEVEL_DISABLED;
        bChangePG = TRUE;
    }

    // Get the verified password from the password dialog
    LPTSTR szPassword = m_pPasswordDlg->GetPassword();
    if (bChangePG) {

        try {

            HRESULT hr = pDvdAdm->SaveParentalLevel(lLevel, NULL, T2OLE(szPassword));
            if (hr == E_ACCESSDENIED){
                DVDMessageBox(hwndDlg, IDS_PASSWORD_INCORRECT);
                pg_OnInitDialog(hwndDlg);
                return hr;
            }

            // Actually setting the player level
            hr = m_pDvd->GetPlayerParentalLevel(&lLevelSaved);
            if (lLevel!=lLevelSaved) {
                hr = m_pDvd->Stop();
                if (FAILED(hr))
                    throw (hr);
                
                hr = m_pDvd->SelectParentalLevel(lLevel, NULL, T2OLE(szPassword));
                if (hr == E_ACCESSDENIED){
                    DVDMessageBox(hwndDlg, IDS_PASSWORD_INCORRECT);
                    pg_OnInitDialog(hwndDlg);
                    return hr;
                }
                if (FAILED(hr)) {
                    DVDMessageBox(hwndDlg, IDS_RATE_CHANGE_FAIL);
                    pg_OnInitDialog(hwndDlg);
                    return hr;
                }
                
                hr = m_pDvd->Play();
                if (FAILED(hr))
                    throw hr;
            }
        }
        catch (HRESULT hrTmp) {
            DVDMessageBox(hwndDlg, IDS_STOP_PLAY_FAIL);
            pg_OnInitDialog(hwndDlg);
            hr = hrTmp;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\sprmclbk.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/*************************************************************/
/* Name: sprm_OnInitDialog
/* Description: OnInitDialog for the Viewing Options page
/*************************************************************/
#include "stdafx.h"
#include "COptDlg.h"

// Language ID's supported by DVD Nav
WORD langIDs[] = {
LANG_AFRIKAANS ,
LANG_ALBANIAN ,
LANG_ARABIC ,
LANG_BASQUE ,
LANG_BELARUSIAN ,
LANG_BULGARIAN ,
LANG_CATALAN ,
LANG_CHINESE ,
LANG_CROATIAN ,
LANG_CZECH ,
LANG_DANISH ,
LANG_DUTCH ,
LANG_ENGLISH ,
LANG_ESTONIAN ,
LANG_FAEROESE ,
LANG_FARSI ,
LANG_FINNISH ,
LANG_FRENCH ,
LANG_GERMAN ,
LANG_GREEK ,
LANG_HEBREW ,
LANG_HUNGARIAN ,
LANG_ICELANDIC ,
LANG_INDONESIAN ,
LANG_ITALIAN ,
LANG_JAPANESE ,
LANG_KOREAN ,
LANG_LATVIAN ,
LANG_LITHUANIAN ,
LANG_MALAY ,
LANG_NORWEGIAN ,
LANG_POLISH ,
LANG_PORTUGUESE ,
LANG_ROMANIAN ,
LANG_RUSSIAN ,
LANG_SERBIAN ,
LANG_SLOVAK ,
LANG_SLOVENIAN ,
LANG_SPANISH ,
LANG_SWAHILI ,
LANG_SWEDISH ,
LANG_THAI ,
LANG_TURKISH ,
LANG_UKRAINIAN
};

/*************************************************************/
/* Name: sprm_InitLangList
/* Description: Initial a combo box with available languages
/*  highlight the one with LCID equal to id
/*************************************************************/
HRESULT COptionsDlg::sprm_InitLangList(HWND cList, WORD id)
{
    USES_CONVERSION;
    ::SendMessage(cList, CB_RESETCONTENT, 0, 0);

    LPTSTR pszDefault = LoadStringFromRes(IDS_INI_TITLE_DEFAULT);
    ::SendMessage(cList, CB_INSERTSTRING, 0, (LPARAM)pszDefault);
    ::SendMessage(cList, CB_SETCURSEL, 0, 0);
    delete pszDefault;

    if (id == LANG_NEUTRAL) {
        id = PRIMARYLANGID(::GetUserDefaultLangID());
    }

    for (int i=0; i<sizeof(langIDs)/sizeof(WORD); i++) {
        CComBSTR strLang;
        m_pDvd->GetLangFromLangID(long(langIDs[i]), &strLang);
        ::SendMessage(cList, CB_INSERTSTRING, (UINT)-1, (LPARAM)OLE2T(strLang));
        if (langIDs[i] == id)
            // First item in list is "Title Default"
            ::SendMessage(cList, CB_SETCURSEL, i+1, 0);
    }

    return S_OK;    
}

/*************************************************************/
/* Name: sprm_OnInitDialog
/* Description: 
/*************************************************************/
HRESULT COptionsDlg::sprm_OnInitDialog(HWND hwndDlg)
{
	HWND hwndAudList = ::GetDlgItem(hwndDlg, IDC_AUDIO_LANG);
	HWND hwndSPList = ::GetDlgItem(hwndDlg, IDC_SUBPIC_LANG);
	HWND hwndMenuList = ::GetDlgItem(hwndDlg, IDC_MENU_LANG);
    HWND screenSaverCheck = ::GetDlgItem(hwndDlg, IDC_DISABLE_SCREENSAVER);
    HWND bookmarkOnStopCheck = ::GetDlgItem(hwndDlg, IDC_BOOKMARK_STOP);
    HWND bookmarkOnCloseCheck = ::GetDlgItem(hwndDlg, IDC_BOOKMARK_CLOSE);

    if (!hwndAudList || !hwndSPList || !hwndMenuList)
        return S_FALSE;
    
    try {

        HRESULT hr = S_OK;
        CComPtr<IMSDVDAdm> pDvdAdm;
        hr = GetDvdAdm((LPVOID*) &pDvdAdm);
        if (FAILED(hr) || !pDvdAdm)
            throw(hr);

        VARIANT_BOOL temp;
        LCID audioLCID;
        LCID subpictureLCID;
        LCID menuLCID;
            
        pDvdAdm->get_DisableScreenSaver(&temp);
        BOOL fDisabled = (temp == VARIANT_FALSE? FALSE:TRUE);
        ::SendMessage(screenSaverCheck, BM_SETCHECK, fDisabled, 0);

        pDvdAdm->get_BookmarkOnStop(&temp);
        fDisabled = (temp == VARIANT_FALSE? FALSE:TRUE);
        ::SendMessage(bookmarkOnStopCheck, BM_SETCHECK, fDisabled, 0);

        pDvdAdm->get_BookmarkOnClose(&temp);
        fDisabled = (temp == VARIANT_FALSE? FALSE:TRUE);
        ::SendMessage(bookmarkOnCloseCheck, BM_SETCHECK, fDisabled, 0);

        pDvdAdm->get_DefaultAudioLCID((long*)&audioLCID);
        pDvdAdm->get_DefaultSubpictureLCID((long*)&subpictureLCID);
        pDvdAdm->get_DefaultMenuLCID((long*)&menuLCID);
        
        sprm_InitLangList(hwndAudList, PRIMARYLANGID(LANGIDFROMLCID(audioLCID)));
        sprm_InitLangList(hwndSPList, PRIMARYLANGID(LANGIDFROMLCID(subpictureLCID)));       
        sprm_InitLangList(hwndMenuList, PRIMARYLANGID(LANGIDFROMLCID(menuLCID)));

    }
    catch (HRESULT hr) {
        DVDMessageBox(hwndDlg, IDS_SPRM_FAIL);
        sprm_OnInitDialog(hwndDlg);
        return hr;
    }

    return S_OK;
}

/*************************************************************/
/* Name: sprm_OnApply
/* Description: OnApply for Viewing Options page
/*************************************************************/
HRESULT COptionsDlg::sprm_OnApply(HWND hwnd)
{
	HWND hwndMenuList = ::GetDlgItem(hwnd, IDC_MENU_LANG);
	HWND hwndSPList = ::GetDlgItem(hwnd, IDC_SUBPIC_LANG);
	HWND hwndAudList = ::GetDlgItem(hwnd, IDC_AUDIO_LANG);
    HWND screenSaverCheck = ::GetDlgItem(hwnd, IDC_DISABLE_SCREENSAVER);
    HWND bookmarkOnStopCheck = ::GetDlgItem(hwnd, IDC_BOOKMARK_STOP);
    HWND bookmarkOnCloseCheck = ::GetDlgItem(hwnd, IDC_BOOKMARK_CLOSE);
    
    // Get current selections;
    INT nAudioCurSel = (INT) SendMessage(hwndAudList, CB_GETCURSEL, 0, 0);
    INT nMenuCurSel = (INT) SendMessage(hwndMenuList, CB_GETCURSEL, 0, 0);
    INT nSPCurSel = (INT) SendMessage(hwndSPList, CB_GETCURSEL, 0, 0);

    try {
        HRESULT hr = S_OK;
        CComPtr<IMSDVDAdm> pDvdAdm;
        hr = GetDvdAdm((LPVOID*) &pDvdAdm);
        if (FAILED(hr) || !pDvdAdm)
            throw(hr);
        

        if (nAudioCurSel>=0 || nMenuCurSel>=0 || nSPCurSel>=0) {
            
            BOOL bSubpictureLCIDChanged = FALSE;
            BOOL bAudioLCIDChanged = FALSE;
            BOOL bMenuLCIDChanged = FALSE;
            
            // Title default
            LCID subpictureLCID = (LCID)-1;
            LCID audioLCID = (LCID)-1;
            LCID menuLCID = (LCID)-1;
            LCID savedLCID;
            
            if (nAudioCurSel>0) {
                audioLCID = MAKELCID(MAKELANGID(langIDs[nAudioCurSel-1], SUBLANG_DEFAULT), SORT_DEFAULT);
            }
            pDvdAdm->get_DefaultAudioLCID((long*)&savedLCID);
            if (audioLCID != savedLCID) {
                bAudioLCIDChanged = TRUE;
            }
            
            if (nSPCurSel>0) {
                subpictureLCID = MAKELCID(MAKELANGID(langIDs[nSPCurSel-1], SUBLANG_DEFAULT), SORT_DEFAULT);
            }
            pDvdAdm->get_DefaultSubpictureLCID((long*)&savedLCID);
            if (subpictureLCID != savedLCID) {
                bSubpictureLCIDChanged = TRUE;
            }
            
            if (nMenuCurSel>0) {
                menuLCID = MAKELCID(MAKELANGID(langIDs[nMenuCurSel-1], SUBLANG_DEFAULT), SORT_DEFAULT);
            }
            pDvdAdm->get_DefaultMenuLCID((long*)&savedLCID);
            if (menuLCID != savedLCID) {
                bMenuLCIDChanged = TRUE;
            }

            if (bAudioLCIDChanged || bSubpictureLCIDChanged || bMenuLCIDChanged) {
                //m_pDvd->SaveState();
                hr = m_pDvd->Stop();
                if (FAILED(hr))
                    throw (hr);
         
                if (bAudioLCIDChanged) {
                    if (::IsValidLocale(audioLCID, LCID_SUPPORTED)){
                        hr = m_pDvd->SelectDefaultAudioLanguage(audioLCID, 0);
                        if (FAILED(hr))
                            throw (hr);
                    }
                    hr = pDvdAdm->put_DefaultAudioLCID(audioLCID);
                }
                if (bSubpictureLCIDChanged) {
                    if (::IsValidLocale(subpictureLCID, LCID_SUPPORTED)){
                        hr = m_pDvd->SelectDefaultSubpictureLanguage(subpictureLCID, dvdSPExt_NotSpecified);
                        if (FAILED(hr))
                            throw (hr);
                    }
                    hr = pDvdAdm->put_DefaultSubpictureLCID(subpictureLCID);
                }
                if (bMenuLCIDChanged) {
                    if (::IsValidLocale(menuLCID, LCID_SUPPORTED)){
                        hr = m_pDvd->put_DefaultMenuLanguage(menuLCID);                
                        if (FAILED(hr))
                            throw (hr);
                    }
                    hr = pDvdAdm->put_DefaultMenuLCID(menuLCID);
                }

                hr = m_pDvd->Play();
                if (FAILED(hr))
                    throw (hr);
                //m_pDvd->RestoreState();
            }
        }

        BOOL fDisabled = (BOOL) SendMessage(screenSaverCheck, BM_GETCHECK, 0, 0);
        VARIANT_BOOL temp = (fDisabled==FALSE? VARIANT_FALSE:VARIANT_TRUE);
        hr = pDvdAdm->put_DisableScreenSaver(temp);
        if (FAILED(hr))
            throw (hr);

        BOOL fEnabled = (BOOL) SendMessage(bookmarkOnStopCheck, BM_GETCHECK, 0, 0);
        temp = (fEnabled==FALSE? VARIANT_FALSE:VARIANT_TRUE);
        hr = pDvdAdm->put_BookmarkOnStop(temp);
        if (FAILED(hr))
            throw (hr);

        fEnabled = (BOOL) SendMessage(bookmarkOnCloseCheck, BM_GETCHECK, 0, 0);
        temp = (fEnabled==FALSE? VARIANT_FALSE:VARIANT_TRUE);
        hr = pDvdAdm->put_BookmarkOnClose(temp);
        if (FAILED(hr))
            throw (hr);

    }
    catch (HRESULT hr) {
        DVDMessageBox(hwnd, IDS_SPRM_FAIL);
        sprm_OnInitDialog(hwnd);
        return hr;
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msdvdopt.rc
//
#define IDR_DVDOPT                      100
#define IDB_DVDOPT                      101
#define IDS_PROJNAME                    102
#define IDD_OPTIONS                     201
#define IDD_SEARCH                      204
#define IDD_VIEWOPT                     205
#define IDD_PARENT_CONTROL              206
#define IDD_KARAOKE                     207
#define IDD_ABOUT                       208
#define IDD_PARENT_OVERRIDE             209
#define IDD_CHANGEPASSWD                210
#define IDI_PASSWORD                    211
#define IDI_DVDPLAY                     212
#define IDC_TABCTRL                     213
#define IDC_APPLY                       214
#define IDS_SEARCH                      228
#define IDS_VIEWOPT                     229
#define IDS_PARENTCTL                   230
#define IDS_KARAOKE                     231
#define IDS_ABOUT                       232

#define IDC_BOOKMARK_STOP               305
#define IDC_BOOKMARK_CLOSE              306
#define IDC_SUBPIC_LANG                 307
#define IDC_AUDIO_LANG                  309
#define IDC_MENU_LANG                   310
#define IDC_STATIC_SUBPIC_LANG          311
#define IDC_STATIC_AUDIO_LANG           312
#define IDC_STATIC_MENU_LANG            313

#define IDC_EDIT_PASSWORD               333
#define IDC_EDIT_NEW_PASSWORD           334
#define IDC_EDIT_CONFIRM_NEW            335
#define IDC_STATIC_PASSWORD             336
#define IDC_STATIC_NEW_PASSWORD         337
#define IDC_STATIC_CONFIRM_NEW          338
#define IDC_COMBO_RATE                  339
#define IDC_STATIC_CURRENT_RATE         340
#define IDC_BUTTON_CHANGE_PASSWORD      341
#define IDC_DISABLE_PARENT              342
#define IDC_DISABLE_SCREENSAVER         343
#define IDC_STATIC_RATE_HIGH            344
#define IDC_LIST_TITLES                 345
#define IDC_LIST_CHAPS                  346
#define IDC_STATIC_LIST_TITLES          347
#define IDC_STATIC_LIST_CHAPS           348
#define IDC_WARNING_RESTART             349
#define IDC_AUDIO_LIST                  350
#define IDC_STATIC_AUDIO_LIST           351
#define IDC_CHECK_CHAN2                 352
#define IDC_CHECK_CHAN3                 353
#define IDC_CHECK_CHAN4                 354
#define IDC_STATIC_CHAN_CONTENT         355

#define IDS_CONFIRM_NEW_PASSWORD        61213
#define IDS_PASSOWRD_CONFIRM_WRONG      61214
#define IDS_PASSWORD_INCORRECT          61215
#define IDS_TYPE_A_NEW_PASSWORD         61216
#define IDS_MSGBOX_TITLE                61223
#define IDS_INI_RATE                    61258
#define IDS_INI_RATE_G                  61259
#define IDS_INI_RATE_PG                 61260
#define IDS_INI_RATE_PG13               61262
#define IDS_INI_RATE_R                  61263
#define IDS_INI_RATE_NC17               61264
#define IDS_INI_RATE_ADULT              61265
#define IDS_RATE_TOO_LOW                61267
#define IDS_RATE_CHANGE_FAIL            61278
#define IDS_PASSWORD_CHANGE_FAIL        61279
#define IDS_SPRM_FAIL                   61315
#define IDS_STOP_PLAY_FAIL              61316
#define IDS_INI_TITLE_DEFAULT           61317
#define IDS_INI_GUIDEVOCAL1             61318
#define IDS_INI_GUIDEVOCAL2             61319
#define IDS_INI_GUIDEVOCAL12            61320
#define IDS_INI_GUIDEMELODY             61321
#define IDS_INI_SOUNDEFFECT             61324
#define IDS_INI_NOKARAOKESUPPORT        61326
#define IDS_INI_INVALIDEDOMAIN          61327
#define IDS_INI_INVALIDEUOP             61328
#define IDS_INI_NOKARAOKECONTENT        61329
#define IDS_INI_KARAOKECHAN             61330
#define IDS_INI_CANNOT_PLAYCHAP         61331
#define IDS_INI_TITLE_NO                61332
#define IDS_INI_CHAP_NO                 61333
#define IDS_INI_RATE_HIGH               61334

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        649
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1084
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msdvdopt\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__81E89BB6_32F9_4537_BD95_2BC45CCEE0BF__INCLUDED_)
#define AFX_STDAFX_H__81E89BB6_32F9_4537_BD95_2BC45CCEE0BF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#import "mswebdvd.tlb" raw_interfaces_only, no_namespace, named_guids
#pragma warning( disable: 4100 )  /*unreferenced formal parameter*/

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__81E89BB6_32F9_4537_BD95_2BC45CCEE0BF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\bmplist.h ===
#ifndef _BMPLIST_H
#define _BMPLIST_H

// This file is automatically generated. You should never edit it directly!
// Instead, you may edit bmplist.txt and run mosaicbm.exe. It will create
// this file (bmplist.h) as well as the bitmap file mosaicbm.bmp.

typedef struct {char *strIDR; RECT rect;} BmpRectRef;
BmpRectRef gBmpRectList[] = {
{"IDR_STATIC_RECT", {0,0,75,15}},
{"IDR_DOWN_RECT", {75,0,150,15}},
{"IDR_STATIC_OVAL", {150,0,227,19}},
{"IDR_DOWN_OVAL", {227,0,305,19}},
{"IDR_FULLSTATIC_OVAL", {305,0,381,18}},
{"IDR_FULLDOWN_OVAL", {381,0,457,18}},
{"IDR_STATIC_EXPAND", {457,0,471,15}},
{"IDR_STATIC_SHRINK", {471,0,485,15}},
{"IDR_STATIC_SP", {485,0,531,15}},
{"IDR_STATIC_LAN", {531,0,577,15}},
{"IDR_STATIC_ANGLE", {577,0,623,15}},
{"IDR_STATIC_UP", {623,0,637,9}},
{"IDR_STATIC_DOWN", {0,19,14,28}},
{"IDR_STATIC_HELP", {14,19,30,33}},
{"IDR_STATIC_HELPB", {30,19,76,34}},
{"IDR_STATIC_CLOSE", {76,19,92,33}},
{"IDR_STATIC_MAX", {92,19,108,33}},
{"IDR_STATIC_MIN", {108,19,124,33}},
{"IDR_STATIC_RESTORE", {124,19,140,33}},
{"IDR_STATIC_OPT", {140,19,185,34}},
{"IDR_STATIC_RIGHT", {185,19,194,33}},
{"IDR_STATIC_LEFT", {194,19,203,33}},
{"IDR_STATIC_TIMESLIDER", {203,19,286,39}},
{"IDR_STATIC_TIMETHUMB", {286,19,293,39}},
{"IDR_FULLSTATIC_TIMETHUMB", {293,19,300,39}},
{"IDR_STATIC_ENCC", {300,19,346,34}},
{"IDR_STATIC_DICC", {346,19,392,34}},
{"IDR_HOVER_EXPAND", {392,19,406,34}},
{"IDR_HOVER_SHRINK", {406,19,420,34}},
{"IDR_HOVER_SP", {420,19,466,34}},
{"IDR_HOVER_LAN", {466,19,512,34}},
{"IDR_HOVER_ANGLE", {512,19,558,34}},
{"IDR_HOVER_OPT", {558,19,603,34}},
{"IDR_HOVER_RIGHT", {603,19,612,33}},
{"IDR_HOVER_LEFT", {612,19,621,33}},
{"IDR_HOVER_UP", {621,19,635,28}},
{"IDR_HOVER_DOWN", {0,39,14,48}},
{"IDR_HOVER_HELP", {14,39,30,53}},
{"IDR_HOVER_HELPB", {30,39,76,54}},
{"IDR_HOVER_CLOSE", {76,39,92,53}},
{"IDR_HOVER_MAX", {92,39,108,53}},
{"IDR_HOVER_MIN", {108,39,124,53}},
{"IDR_HOVER_RESTORE", {124,39,140,53}},
{"IDR_HOVER_ENCC", {140,39,186,54}},
{"IDR_HOVER_DICC", {186,39,232,54}},
{"IDR_DOWN_EXPAND", {232,39,246,53}},
{"IDR_DOWN_SHRINK", {246,39,260,53}},
{"IDR_DOWN_SP", {260,39,306,54}},
{"IDR_DOWN_LAN", {306,39,352,54}},
{"IDR_DOWN_ANGLE", {352,39,397,54}},
{"IDR_DOWN_OPT", {397,39,442,54}},
{"IDR_DOWN_RIGHT", {442,39,451,53}},
{"IDR_DOWN_LEFT", {451,39,460,53}},
{"IDR_DOWN_UP", {460,39,474,48}},
{"IDR_DOWN_DOWN", {474,39,488,48}},
{"IDR_DOWN_HELP", {488,39,504,53}},
{"IDR_DOWN_HELPB", {504,39,549,54}},
{"IDR_DOWN_CLOSE", {549,39,565,53}},
{"IDR_DOWN_MAX", {565,39,581,53}},
{"IDR_DOWN_MIN", {581,39,597,53}},
{"IDR_DOWN_RESTORE", {597,39,613,53}},
{"IDR_DOWN_ENCC", {0,54,46,69}},
{"IDR_DOWN_DICC", {46,54,92,69}},
{"IDR_DISABLED_EXPAND", {92,54,106,69}},
{"IDR_DISABLED_SHRINK", {106,54,120,69}},
{"IDR_DISABLED_SP", {120,54,166,69}},
{"IDR_DISABLED_LAN", {166,54,212,69}},
{"IDR_DISABLED_ANGLE", {212,54,258,69}},
{"IDR_DISABLED_OPT", {258,54,303,69}},
{"IDR_DISABLED_RIGHT", {303,54,312,68}},
{"IDR_DISABLED_LEFT", {312,54,321,68}},
{"IDR_DISABLED_TIMESLIDER", {321,54,404,74}},
{"IDR_DISABLED_TIMETHUMB", {404,54,411,74}},
{"IDR_DISABLED_UP", {411,54,425,63}},
{"IDR_DISABLED_DOWN", {425,54,439,63}},
{"IDR_DISABLED_HELP", {439,54,455,68}},
{"IDR_DISABLED_HELPB", {455,54,501,69}},
{"IDR_DISABLED_CLOSE", {501,54,517,68}},
{"IDR_DISABLED_MAX", {517,54,533,68}},
{"IDR_DISABLED_MIN", {533,54,549,68}},
{"IDR_DISABLED_RESTORE", {549,54,565,68}},
{"IDR_DISABLED_ENCC", {565,54,611,69}},
{"IDR_DISABLED_DICC", {0,74,46,89}},
{"IDR_ACTIVE_EXPAND", {46,74,60,89}},
{"IDR_ACTIVE_SHRINK", {60,74,74,89}},
{"IDR_ACTIVE_SP", {74,74,120,89}},
{"IDR_ACTIVE_LAN", {120,74,166,89}},
{"IDR_ACTIVE_ANGLE", {166,74,212,89}},
{"IDR_ACTIVE_OPT", {212,74,257,89}},
{"IDR_ACTIVE_RIGHT", {257,74,266,88}},
{"IDR_ACTIVE_LEFT", {266,74,275,88}},
{"IDR_ACTIVE_UP", {275,74,289,83}},
{"IDR_ACTIVE_DOWN", {289,74,303,83}},
{"IDR_ACTIVE_HELP", {303,74,319,88}},
{"IDR_ACTIVE_HELPB", {319,74,365,89}},
{"IDR_ACTIVE_CLOSE", {365,74,381,88}},
{"IDR_ACTIVE_MAX", {381,74,397,88}},
{"IDR_ACTIVE_MIN", {397,74,413,88}},
{"IDR_ACTIVE_RESTORE", {413,74,429,88}},
{"IDR_ACTIVE_ENCC", {429,74,475,89}},
{"IDR_ACTIVE_DICC", {475,74,521,89}},
{"IDR_STATIC_PAUSE", {521,74,540,93}},
{"IDR_STATIC_PLAY", {540,74,564,99}},
{"IDR_STATIC_FF", {564,74,590,93}},
{"IDR_STATIC_RW", {590,74,616,93}},
{"IDR_STATIC_MUTE", {616,74,633,89}},
{"IDR_STATIC_SOUND", {0,99,17,114}},
{"IDR_STATIC_MENU", {17,99,64,118}},
{"IDR_STATIC_RESUME", {64,99,111,118}},
{"IDR_STATIC_PREV", {111,99,137,118}},
{"IDR_STATIC_NEXT", {137,99,163,118}},
{"IDR_STATIC_ZOOMIN", {163,99,181,117}},
{"IDR_STATIC_ZOOMOUT", {181,99,199,117}},
{"IDR_STATIC_CAPTURE", {199,99,218,118}},
{"IDR_STATIC_NEXTFRAME", {218,99,244,118}},
{"IDR_STATIC_PREVFRAME", {244,99,270,118}},
{"IDR_STATIC_EJECT", {270,99,289,118}},
{"IDR_STATIC_STOP", {289,99,308,118}},
{"IDR_STATIC_ENTER", {308,99,323,114}},
{"IDR_STATIC_TITLEMENU", {323,99,370,118}},
{"IDR_STATIC_VOLSLIDER", {370,99,436,118}},
{"IDR_STATIC_VOLTHUMB", {436,99,444,114}},
{"IDR_STATIC_SPEEDSLIDER", {444,99,555,119}},
{"IDR_STATIC_SPEEDTHUMB", {555,99,561,116}},
{"IDR_HOVER_PAUSE", {561,99,580,118}},
{"IDR_HOVER_PLAY", {580,99,604,124}},
{"IDR_HOVER_FF", {604,99,630,118}},
{"IDR_HOVER_RW", {0,124,26,143}},
{"IDR_HOVER_MUTE", {26,124,43,139}},
{"IDR_HOVER_SOUND", {43,124,60,139}},
{"IDR_HOVER_MENU", {60,124,107,143}},
{"IDR_HOVER_RESUME", {107,124,154,143}},
{"IDR_HOVER_PREV", {154,124,180,143}},
{"IDR_HOVER_NEXT", {180,124,206,143}},
{"IDR_HOVER_ENTER", {206,124,221,139}},
{"IDR_HOVER_ZOOMIN", {221,124,239,142}},
{"IDR_HOVER_ZOOMOUT", {239,124,257,142}},
{"IDR_HOVER_CAPTURE", {257,124,276,143}},
{"IDR_HOVER_NEXTFRAME", {276,124,302,143}},
{"IDR_HOVER_PREVFRAME", {302,124,328,143}},
{"IDR_HOVER_EJECT", {328,124,347,143}},
{"IDR_HOVER_STOP", {347,124,366,143}},
{"IDR_HOVER_TITLEMENU", {366,124,413,143}},
{"IDR_DOWN_PAUSE", {413,124,432,143}},
{"IDR_DOWN_PLAY", {432,124,456,149}},
{"IDR_DOWN_FF", {456,124,482,143}},
{"IDR_DOWN_RW", {482,124,508,143}},
{"IDR_DOWN_MUTE", {508,124,525,139}},
{"IDR_DOWN_SOUND", {525,124,542,139}},
{"IDR_DOWN_MENU", {542,124,589,143}},
{"IDR_DOWN_RESUME", {589,124,636,143}},
{"IDR_DOWN_PREV", {0,149,26,168}},
{"IDR_DOWN_NEXT", {26,149,52,168}},
{"IDR_DOWN_ENTER", {52,149,67,164}},
{"IDR_DOWN_ZOOMIN", {67,149,85,167}},
{"IDR_DOWN_ZOOMOUT", {85,149,104,167}},
{"IDR_DOWN_CAPTURE", {104,149,123,168}},
{"IDR_DOWN_NEXTFRAME", {123,149,149,168}},
{"IDR_DOWN_PREVFRAME", {149,149,175,168}},
{"IDR_DOWN_EJECT", {175,149,194,168}},
{"IDR_DOWN_STOP", {194,149,213,168}},
{"IDR_DOWN_TITLEMENU", {213,149,260,168}},
{"IDR_DISABLED_PAUSE", {260,149,279,168}},
{"IDR_DISABLED_PLAY", {279,149,303,174}},
{"IDR_DISABLED_FF", {303,149,329,168}},
{"IDR_DISABLED_RW", {329,149,355,168}},
{"IDR_DISABLED_MUTE", {355,149,372,164}},
{"IDR_DISABLED_SOUND", {372,149,389,164}},
{"IDR_DISABLED_MENU", {389,149,436,168}},
{"IDR_DISABLED_RESUME", {436,149,483,167}},
{"IDR_DISABLED_PREV", {483,149,509,168}},
{"IDR_DISABLED_NEXT", {509,149,535,168}},
{"IDR_DISABLED_ENTER", {535,149,550,164}},
{"IDR_DISABLED_ZOOMIN", {550,149,568,167}},
{"IDR_DISABLED_ZOOMOUT", {568,149,586,167}},
{"IDR_DISABLED_CAPTURE", {586,149,605,168}},
{"IDR_DISABLED_NEXTFRAME", {605,149,631,168}},
{"IDR_DISABLED_PREVFRAME", {0,174,26,193}},
{"IDR_DISABLED_EJECT", {26,174,45,193}},
{"IDR_DISABLED_STOP", {45,174,64,193}},
{"IDR_DISABLED_TITLEMENU", {64,174,111,193}},
{"IDR_DISABLED_VOLSLIDER", {111,174,177,193}},
{"IDR_DISABLED_VOLTHUMB", {177,174,185,189}},
{"IDR_DISABLED_SPEEDSLIDER", {185,174,296,194}},
{"IDR_DISABLED_SPEEDTHUMB", {296,174,302,191}},
{"IDR_ACTIVE_PAUSE", {302,174,321,193}},
{"IDR_ACTIVE_PLAY", {321,174,345,199}},
{"IDR_ACTIVE_FF", {345,174,371,193}},
{"IDR_ACTIVE_RW", {371,174,397,193}},
{"IDR_ACTIVE_MUTE", {397,174,414,189}},
{"IDR_ACTIVE_SOUND", {414,174,431,189}},
{"IDR_ACTIVE_MENU", {431,174,478,193}},
{"IDR_ACTIVE_RESUME", {478,174,525,193}},
{"IDR_ACTIVE_PREV", {525,174,551,193}},
{"IDR_ACTIVE_NEXT", {551,174,577,193}},
{"IDR_ACTIVE_ENTER", {577,174,592,189}},
{"IDR_ACTIVE_ZOOMIN", {592,174,610,192}},
{"IDR_ACTIVE_ZOOMOUT", {610,174,628,192}},
{"IDR_ACTIVE_CAPTURE", {0,199,19,218}},
{"IDR_ACTIVE_NEXTFRAME", {19,199,45,218}},
{"IDR_ACTIVE_PREVFRAME", {45,199,71,218}},
{"IDR_ACTIVE_EJECT", {71,199,90,218}},
{"IDR_ACTIVE_STOP", {90,199,109,218}},
{"IDR_ACTIVE_TITLEMENU", {109,199,156,218}},
{"IDR_FULLSTATIC_PAUSE", {156,199,173,216}},
{"IDR_FULLSTATIC_PLAY", {173,199,196,222}},
{"IDR_FULLSTATIC_FF", {196,199,221,217}},
{"IDR_FULLSTATIC_RW", {221,199,246,217}},
{"IDR_FULLSTATIC_MUTE", {246,199,261,213}},
{"IDR_FULLSTATIC_SOUND", {261,199,276,213}},
{"IDR_FULLSTATIC_MENU", {276,199,319,216}},
{"IDR_FULLSTATIC_RESUME", {319,199,362,216}},
{"IDR_FULLSTATIC_PREV", {362,199,387,217}},
{"IDR_FULLSTATIC_NEXT", {387,199,412,217}},
{"IDR_FULLSTATIC_ZOOMIN", {412,199,428,215}},
{"IDR_FULLSTATIC_ZOOMOUT", {428,199,444,215}},
{"IDR_FULLSTATIC_CAPTURE", {444,199,461,216}},
{"IDR_FULLSTATIC_NEXTFRAME", {461,199,486,217}},
{"IDR_FULLSTATIC_PREVFRAME", {486,199,511,217}},
{"IDR_FULLSTATIC_EJECT", {511,199,528,216}},
{"IDR_FULLSTATIC_STOP", {528,199,545,216}},
{"IDR_FULLSTATIC_UP", {545,199,559,208}},
{"IDR_FULLSTATIC_DOWN", {559,199,573,208}},
{"IDR_FULLSTATIC_LEFT", {573,199,582,213}},
{"IDR_FULLSTATIC_RIGHT", {582,199,591,213}},
{"IDR_FULLSTATIC_ENTER", {591,199,605,213}},
{"IDR_FULLSTATIC_TITLEMENU", {0,222,43,239}},
{"IDR_FULLSTATIC_VOLSLIDER", {43,222,109,241}},
{"IDR_FULLSTATIC_VOLTHUMB", {109,222,117,237}},
{"IDR_FULLSTATIC_SPEEDSLIDER", {117,222,228,242}},
{"IDR_FULLSTATIC_SPEEDTHUMB", {228,222,234,239}},
{"IDR_FULLHOVER_PAUSE", {234,222,251,239}},
{"IDR_FULLHOVER_PLAY", {251,222,274,245}},
{"IDR_FULLHOVER_FF", {274,222,299,240}},
{"IDR_FULLHOVER_RW", {299,222,324,240}},
{"IDR_FULLHOVER_MUTE", {324,222,339,236}},
{"IDR_FULLHOVER_SOUND", {339,222,354,236}},
{"IDR_FULLHOVER_MENU", {354,222,397,239}},
{"IDR_FULLHOVER_RESUME", {397,222,440,239}},
{"IDR_FULLHOVER_PREV", {440,222,465,240}},
{"IDR_FULLHOVER_NEXT", {465,222,490,240}},
{"IDR_FULLHOVER_ENTER", {490,222,504,236}},
{"IDR_FULLHOVER_ZOOMIN", {504,222,520,238}},
{"IDR_FULLHOVER_ZOOMOUT", {520,222,536,238}},
{"IDR_FULLHOVER_CAPTURE", {536,222,553,239}},
{"IDR_FULLHOVER_NEXTFRAME", {553,222,578,240}},
{"IDR_FULLHOVER_PREVFRAME", {578,222,603,240}},
{"IDR_FULLHOVER_EJECT", {603,222,620,239}},
{"IDR_FULLHOVER_STOP", {620,222,637,239}},
{"IDR_FULLHOVER_TITLEMENU", {0,245,43,262}},
{"IDR_FULLDOWN_PAUSE", {43,245,60,262}},
{"IDR_FULLDOWN_PLAY", {60,245,83,268}},
{"IDR_FULLDOWN_FF", {83,245,108,263}},
{"IDR_FULLDOWN_RW", {108,245,133,263}},
{"IDR_FULLDOWN_MUTE", {133,245,148,259}},
{"IDR_FULLDOWN_SOUND", {148,245,163,259}},
{"IDR_FULLDOWN_MENU", {163,245,206,262}},
{"IDR_FULLDOWN_RESUME", {206,245,249,261}},
{"IDR_FULLDOWN_PREV", {249,245,274,263}},
{"IDR_FULLDOWN_NEXT", {274,245,299,263}},
{"IDR_FULLDOWN_ENTER", {299,245,313,259}},
{"IDR_FULLDOWN_ZOOMIN", {313,245,329,261}},
{"IDR_FULLDOWN_ZOOMOUT", {329,245,345,261}},
{"IDR_FULLDOWN_CAPTURE", {345,245,362,262}},
{"IDR_FULLDOWN_NEXTFRAME", {362,245,387,263}},
{"IDR_FULLDOWN_PREVFRAME", {387,245,412,263}},
{"IDR_FULLDOWN_EJECT", {412,245,429,262}},
{"IDR_FULLDOWN_STOP", {429,245,446,262}},
{"IDR_FULLDOWN_TITLEMENU", {446,245,489,261}},
{"IDR_FULLDISABLED_PAUSE", {489,245,506,262}},
{"IDR_FULLDISABLED_PLAY", {506,245,529,268}},
{"IDR_FULLDISABLED_FF", {529,245,554,263}},
{"IDR_FULLDISABLED_RW", {554,245,579,263}},
{"IDR_FULLDISABLED_MUTE", {579,245,594,259}},
{"IDR_FULLDISABLED_SOUND", {594,245,609,259}},
{"IDR_FULLDISABLED_MENU", {0,268,43,285}},
{"IDR_FULLDISABLED_RESUME", {43,268,86,285}},
{"IDR_FULLDISABLED_PREV", {86,268,111,286}},
{"IDR_FULLDISABLED_NEXT", {111,268,136,286}},
{"IDR_FULLDISABLED_ENTER", {136,268,150,282}},
{"IDR_FULLDISABLED_ZOOMIN", {150,268,166,284}},
{"IDR_FULLDISABLED_ZOOMOUT", {166,268,182,284}},
{"IDR_FULLDISABLED_CAPTURE", {182,268,225,285}},
{"IDR_FULLDISABLED_NEXTFRAME", {225,268,250,286}},
{"IDR_FULLDISABLED_PREVFRAME", {250,268,275,286}},
{"IDR_FULLDISABLED_EJECT", {275,268,292,285}},
{"IDR_FULLDISABLED_STOP", {292,268,309,285}},
{"IDR_FULLDISABLED_TITLEMENU", {309,268,352,285}},
{"IDR_FULLDISABLED_VOLSLIDER", {352,268,418,287}},
{"IDR_FULLDISABLED_VOLTHUMB", {418,268,426,283}},
{"IDR_FULLDISABLED_SPEEDSLIDER", {426,268,537,288}},
{"IDR_FULLDISABLED_SPEEDTHUMB", {537,268,543,285}},
{"IDR_FULLACTIVE_PAUSE", {543,268,560,285}},
{"IDR_FULLACTIVE_PLAY", {560,268,583,291}},
{"IDR_FULLACTIVE_FF", {583,268,608,286}},
{"IDR_FULLACTIVE_RW", {608,268,633,286}},
{"IDR_FULLACTIVE_MUTE", {0,291,15,305}},
{"IDR_FULLACTIVE_SOUND", {15,291,30,305}},
{"IDR_FULLACTIVE_MENU", {30,291,73,308}},
{"IDR_FULLACTIVE_RESUME", {73,291,116,308}},
{"IDR_FULLACTIVE_PREV", {116,291,141,309}},
{"IDR_FULLACTIVE_NEXT", {141,291,166,309}},
{"IDR_FULLACTIVE_ENTER", {166,291,180,305}},
{"IDR_FULLACTIVE_ZOOMIN", {180,291,196,307}},
{"IDR_FULLACTIVE_ZOOMOUT", {196,291,212,307}},
{"IDR_FULLACTIVE_CAPTURE", {212,291,229,308}},
{"IDR_FULLACTIVE_NEXTFRAME", {229,291,254,309}},
{"IDR_FULLACTIVE_PREVFRAME", {254,291,279,309}},
{"IDR_FULLACTIVE_EJECT", {279,291,296,308}},
{"IDR_FULLACTIVE_STOP", {296,291,313,308}},
{"IDR_FULLACTIVE_TITLEMENU", {313,291,356,308}},
{NULL, {0,0,0,0}}};

// Important: do not edit this file!
#endif //!_BMPLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\cbitmap.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CBitmap.h                                                       */
/* Description: Bitmap control which supports drawing bitmaps for        */
/*              buttons, images, etc.               phillu 11/16/99      */
/*************************************************************************/

#ifndef _INC_CBITMAP
#define _INC_CBITMAP

#include "MSMFCnt.h" // for definitions of the blit types

#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)


class CBitmap {

public:
    /* Function prototypes */

    CBitmap(){ Init();}
    virtual ~CBitmap() {CleanUp();}
    void Init();
    void CleanUp();
    bool IsEmpty();
    HPALETTE GetPal() { return NULL == m_hPal? m_hMosaicPAL : m_hPal;}
    static HPALETTE GetSuperPal() { return m_hMosaicPAL;}
    RECT GetDIBRect() {return m_rc;}
    BOOL CreateMemDC(HDC, LPRECT);
    BOOL DeleteMemDC();
    BOOL CreateSrcDC(HDC hDC);
    BOOL LookupBitmapRect(LPTSTR, LPRECT);
    BOOL CustomContainerStretch(HDC hDc, LPRECT lpRect);
    BOOL StretchKeepAspectRatio(HDC hDC, LPRECT lpRect);
    BOOL StretchPaint(HDC, LPRECT, COLORREF);
    COLORREF GetTransparentColor();
    BOOL PaintTransparentDIB(HDC, LPRECT, LPRECT);
    HRESULT PutImage(BSTR strFilename, HINSTANCE hRes = NULL, BOOL bFromMosaic = FALSE, TransparentBlitType=DISABLE, StretchType=NORMAL);
    void LoadPalette(bool fLoadPalette){m_fLoadPalette = fLoadPalette;};
    HRESULT LoadPalette(TCHAR* strFilename, HINSTANCE hRes);
    void OnDispChange(long cBitsPerPixel, long cxScreen, long cyScreen);
    static HRESULT SelectRelizePalette(HDC hdc, HPALETTE hPal, HPALETTE *hPalOld = NULL);
    static void FinalRelease();
    static void DeleteMosaicDC();

protected:
    HRESULT LoadPalette(TCHAR* strFilename, HINSTANCE hRes, HPALETTE *phPal);
    HANDLE LoadImage(HINSTANCE hInst, LPCTSTR lpszName, UINT uType,
        int cxDesired, int cyDesired, UINT fuLoad,HPALETTE *phPal = NULL);
    HRESULT InitilizeMosaic(HINSTANCE hRes);
    HRESULT LoadImageFromRes(BSTR strFileName, HINSTANCE hRes);


protected:

    static HBITMAP   m_hMosaicBMP;
    static HBITMAP   m_hMosaicBMPOld;
    static HPALETTE  m_hMosaicPAL;
    static HPALETTE  m_hMosaicPALOld;
    static HDC       m_hMosaicDC;
    static bool      m_fLoadMosaic; // flag to see if we should try to reload mosaic
    static long      m_cBitsPerPixel;
    static long      m_cxScreen;
    static long      m_cyScreen;

    BOOL      m_bUseMosaicBitmap;
    HBITMAP   m_hBitmap;
    HBITMAP   m_hBitmapOld;
    HDC       m_hSrcDC;
    HPALETTE  m_hPal;
    HPALETTE  m_hPalOld;
    RECT      m_rc;
    HDC       m_hMemDC;
    HBITMAP   m_hMemBMP;
    HBITMAP   m_hMemBMPOld;
    HPALETTE  m_hMemPALOld;
    LONG      m_iMemDCWidth;
    LONG      m_iMemDCHeight;
    bool      m_fLoadPalette;
    TransparentBlitType m_blitType;
    StretchType m_stretchType;
    HINSTANCE m_hInstanceRes;
    CComBSTR  m_strFileName;
};

#endif //!_INC_CBITMAP
/*************************************************************************/
/* End of file: CBitmap.h                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\cbitmap.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CBitmap.cpp                                                     */
/* Description: Bitmap control which supports drawing bitmaps for        */
/*              buttons, images, etc.               phillu 11/16/99      */
/*************************************************************************/

#include "stdafx.h"
#include "CBitmap.h"

// automatically generated list of bmp names and corresponding rect's.
#include "bmplist.h"

// initialization of static variables
HBITMAP CBitmap::m_hMosaicBMP = NULL;
HBITMAP CBitmap::m_hMosaicBMPOld = NULL;
HPALETTE CBitmap::m_hMosaicPAL = NULL;
HPALETTE CBitmap::m_hMosaicPALOld = NULL;
HDC CBitmap::m_hMosaicDC = NULL;
bool CBitmap::m_fLoadMosaic = true;
long CBitmap::m_cBitsPerPixel = 0;
long CBitmap::m_cxScreen = 0;
long CBitmap::m_cyScreen = 0;

// seems we need a DIB section for palettte handeling, but the Millenium one acts up
#if 1
#define DIB_FLAG LR_CREATEDIBSECTION
#else
#define DIB_FLAG 0
#endif

//#define USE_LOADIMAGE LoadImage does not seem to work on palette base devices

#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

/*************************************************************************/
/* Function: Init                                                        */
/*************************************************************************/
void CBitmap::Init(){

    m_hBitmap = NULL;
    m_hBitmapOld = NULL;
    m_hSrcDC = NULL;
    m_hPal = NULL;
    m_hPalOld = NULL;
    m_hMemDC = NULL;
    m_hMemBMP = NULL;
    m_hMemBMPOld = NULL;
    m_hMemPALOld = NULL;
    m_iMemDCWidth = 0;
    m_iMemDCHeight = 0;
    m_blitType = DISABLE;
    m_stretchType = NORMAL;
    m_fLoadPalette = false;
    ::SetRect(&m_rc, 0, 0, 0, 0);

    m_bUseMosaicBitmap = FALSE;
    m_hInstanceRes = NULL;
}/* end of function Init */

bool CBitmap::IsEmpty()
{
    return (m_rc.top == m_rc.bottom && m_rc.left == m_rc.right);
}

/*************************************************************************/
/* Function: CleanUp                                                     */
/* Description: Destroys the objects.                                    */
/*************************************************************************/
void CBitmap::CleanUp() {

    try {
        // cleanup the background image resources
        if (m_hBitmap){
        
            ::DeleteObject(m_hBitmap);
            m_hBitmap = NULL;
        }/* end of if statement */
    }
    catch(...){
         ATLASSERT(FALSE);
    }

    try {

        if (m_hSrcDC && !m_bUseMosaicBitmap){
        
            ::DeleteDC(m_hSrcDC);
            m_hSrcDC = NULL;
        }/* end of if statement */
    }
    catch(...){
         ATLASSERT(FALSE);
    }

    try {
        // cleanup the palette if applicable
        if (m_hPal){
    
            ::DeleteObject(m_hPal);
            m_hPal = NULL;
        }/* end of if statement */

    }
    catch(...){
        ATLASSERT(FALSE);
    }

    try {

        DeleteMemDC();
    }
    catch(...){
        ATLASSERT(FALSE);
    }

    bool fLoadPalette = m_fLoadPalette;
    Init();
    m_fLoadPalette = fLoadPalette;
}/* end of function Cleanup */


// this function is to clean up the mosaic bitmap
// after all objects are destroyed.

void CBitmap::FinalRelease()
{
    try {
        if (m_hMosaicBMP){
        
            ::DeleteObject(m_hMosaicBMP);
            m_hMosaicBMP = NULL;
        }/* end of if statement */
    }
    catch(...){
         ATLASSERT(FALSE);
    }

    try {
        if (m_hMosaicDC){
        
            ::DeleteDC(m_hMosaicDC);
            m_hMosaicDC = NULL;
        }
    }
    catch(...){
         ATLASSERT(FALSE);
    }

    try {
        if (m_hMosaicPAL){
        
            ::DeleteObject(m_hMosaicPAL);
            m_hMosaicPAL = NULL;
        }
    }
    catch(...){
         ATLASSERT(FALSE);
    }

    return;
}

/*************************************************************/
/* Name: CreateMemDC
/* Description: Create a Mem DC
/*************************************************************/
BOOL CBitmap::CreateMemDC(HDC hDC, LPRECT lpDCRect)
{
    LONG lWidth = RECTWIDTH(lpDCRect);
    LONG lHeight = RECTHEIGHT(lpDCRect);

    // clean up the old DC before we make a new one
    DeleteMemDC();

    m_hMemDC = ::CreateCompatibleDC(hDC);
    
    if(m_hMemDC == NULL)
    {
        return(FALSE);
    }
    
    m_iMemDCWidth  = lWidth;
    m_iMemDCHeight = lHeight;
    
    m_hMemBMP = ::CreateCompatibleBitmap(hDC, m_iMemDCWidth, m_iMemDCHeight);
    
    if(m_hMemBMP == NULL)
    {
        ::DeleteDC(m_hMemDC);
        return(FALSE);
    }
    
    m_hMemBMPOld = (HBITMAP)::SelectObject(m_hMemDC, m_hMemBMP);

    HPALETTE hPal = GetPal();
    SelectRelizePalette(m_hMemDC, hPal, &m_hMemPALOld);
    
    // stretch and blit the src DC onto the Mem DC

    return TRUE;
}

/*************************************************************/
/* Function: SelectRelizePalette                             */
/* Description: Selects and relizes palette into a dc.       */
/*************************************************************/
HRESULT CBitmap::SelectRelizePalette(HDC hdc, HPALETTE hPal, HPALETTE* hPalOld){

    if(NULL == hdc){

        return (E_INVALIDARG);
    }/* end of if statement */

    if(NULL == hPal){

        return (E_INVALIDARG);
    }/* end of if statement */

    if((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE){

        HPALETTE hPalTmp = ::SelectPalette(hdc, hPal, FALSE);
        if (hPalOld) {
            *hPalOld = hPalTmp;
        }

        ::RealizePalette(hdc);    
    }/* end of if statement */

    return S_OK;
}/* end of function SelectRelizePalette */

/*************************************************************/
/* Name: DeleteMosaicDC
/* Description: 
/*************************************************************/
void CBitmap::DeleteMosaicDC(){
    try {
        
        if (m_hMosaicDC){
            if (m_hMosaicBMPOld)
                ::SelectObject(m_hMosaicDC, m_hMosaicBMPOld);

            if (m_hMosaicPALOld)
                ::SelectPalette(m_hMosaicDC, m_hMosaicPALOld, FALSE);
        }/* end of if statement */
        
        if (m_hMosaicBMP){
            
            ::DeleteObject(m_hMosaicBMP);
            m_hMosaicBMP = NULL;
        }/* end of if statement */

        if (m_hMosaicDC){

            ::DeleteDC(m_hMosaicDC);
            m_hMosaicDC = NULL;
        }/* end of if statement */
    }

    catch(...){
         ATLASSERT(FALSE);
    }
}

/*************************************************************/
/* Name: OnDispChange
/* Description: 
/*************************************************************/
void CBitmap::OnDispChange(long cBitsPerPixel, long cxScreen, long cyScreen){
    try {
        
        if (cBitsPerPixel != m_cBitsPerPixel ||
            cxScreen != m_cxScreen ||
            cyScreen != m_cyScreen ) {

            m_cBitsPerPixel = cBitsPerPixel;
            m_cxScreen = cxScreen;
            m_cyScreen = cyScreen;

            DeleteMosaicDC();
        }

        if (m_bUseMosaicBitmap){
            
            m_hSrcDC = NULL;
        }
        
        else {
            if (m_hSrcDC) { 
                if (NULL != m_hBitmapOld) 
                    ::SelectObject(m_hSrcDC, m_hBitmapOld);
                
                if (NULL != m_hPalOld) 
                    ::SelectPalette(m_hSrcDC, m_hPalOld, FALSE);                
            }/* end of if statement */
            
            if (m_hBitmap) {
                ::DeleteObject(m_hBitmap);
                m_hBitmap = NULL;
            }/* end of if statement */

            if (m_hSrcDC) { 

                ::DeleteDC(m_hSrcDC);
                m_hSrcDC = NULL;
                
            }/* end of if statement */
        } /* end of if statement */

        DeleteMemDC();
    }
    
    catch(...){
        ATLASSERT(FALSE);
    }
}
    
/*************************************************************/
/* Name: DeleteMemDC
/* Description: 
/*************************************************************/
BOOL CBitmap::DeleteMemDC(){
    if (m_hMemDC) {

        if (m_hMemBMPOld) 
            ::SelectObject(m_hMemDC, m_hMemBMPOld);        

        if (m_hMemPALOld) 
            ::SelectPalette(m_hMemDC, m_hMemPALOld, FALSE);
    } /* end of if statement */

    if (m_hMemBMP) {
        ::DeleteObject(m_hMemBMP);
        m_hMemBMP = NULL;
    } /* end of if statement */
    
    if (m_hMemDC) {

        ::DeleteDC(m_hMemDC);
        m_hMemDC = NULL;
    } /* end of if statement */

    m_iMemDCWidth  = 0;
    m_iMemDCHeight = 0;

    return TRUE;
}/* end of function DeleteMemDC */


/*************************************************************************

This is a special stretching method for stretching the backgound bitmap
of container. The goal is to enlarge the bitmap without stretching, so as
to maintain the border width of the container. This is accomplished
by replicating portions of the bitmap on the 4 sides.

************************************************************************/

BOOL CBitmap::CustomContainerStretch(HDC hDC, RECT* lpRect)
{
    LONG lSectionWidth = (min(RECTWIDTH(lpRect), RECTWIDTH(&m_rc)) + 1)/2;
    LONG lSectionHeight = (min(RECTHEIGHT(lpRect), RECTHEIGHT(&m_rc)) + 1)/2;

    // copy upper left quadrant
    ::BitBlt(hDC,
        lpRect->left,
        lpRect->top,
        lSectionWidth,
        lSectionHeight,
        m_hSrcDC,
        m_rc.left,
        m_rc.top,
        SRCCOPY);

    // copy upper right quadrant
    ::BitBlt(hDC,
        lpRect->right - lSectionWidth,
        lpRect->top,
        lSectionWidth,
        lSectionHeight,
        m_hSrcDC,
        m_rc.right - lSectionWidth,
        m_rc.top,
        SRCCOPY);

    // copy lower left quadrant
    ::BitBlt(hDC,
        lpRect->left,
        lpRect->bottom - lSectionHeight,
        lSectionWidth,
        lSectionHeight,
        m_hSrcDC,
        m_rc.left,
        m_rc.bottom - lSectionHeight,
        SRCCOPY);

    // copy lower right quadrant
    ::BitBlt(hDC,
        lpRect->right - lSectionWidth,
        lpRect->bottom - lSectionHeight,
        lSectionWidth,
        lSectionHeight,
        m_hSrcDC,
        m_rc.right - lSectionWidth,
        m_rc.bottom - lSectionHeight,
        SRCCOPY);

    // fill in the middle section

    LONG lGapWidth = RECTWIDTH(lpRect) - 2*lSectionWidth;
    LONG lGapHeight = RECTHEIGHT(lpRect) - 2*lSectionHeight;
    LONG lHorizFillStart = lpRect->left + lSectionWidth;
    LONG lVertFillStart = lpRect->top + lSectionHeight;

    // define a chunk of bitmap that can be used to fill the gap
    const LONG lSrcXOffset = 60;
    const LONG lSrcYOffset = 60;
    const LONG lMaxHorizontalFill = RECTWIDTH(&m_rc) - 2*lSrcXOffset;
    const LONG lMaxVerticalFill = RECTHEIGHT(&m_rc) - 3*lSrcYOffset; // twice room at bottom
    
    while (lGapWidth > 0)
    {
        // upper middle section

        LONG lFillWidth = min(lGapWidth, lMaxHorizontalFill);

        ::BitBlt(hDC,
            lHorizFillStart,
            lpRect->top,
            lFillWidth,
            lSectionHeight,
            m_hSrcDC,
            m_rc.left + lSrcXOffset,
            m_rc.top,
            SRCCOPY);

        // bottom middle section

        ::BitBlt(hDC,
            lHorizFillStart,
            lpRect->bottom - lSectionHeight,
            lFillWidth,
            lSectionHeight,
            m_hSrcDC,
            m_rc.left + lSrcXOffset,
            m_rc.bottom - lSectionHeight,
            SRCCOPY);

        lGapWidth -= lFillWidth;
        lHorizFillStart += lFillWidth;
    }

    while (lGapHeight > 0)
    {
        // left middle section

        LONG lFillHeight = min(lGapHeight, lMaxVerticalFill);

        ::BitBlt(hDC,
            lpRect->left,
            lVertFillStart,
            lSectionWidth,
            lFillHeight,
            m_hSrcDC,
            m_rc.left,
            m_rc.top + lSrcYOffset,
            SRCCOPY);

        // right middle section

        ::BitBlt(hDC,
            lpRect->right - lSectionWidth,
            lVertFillStart,
            lSectionWidth,
            lFillHeight,
            m_hSrcDC,
            m_rc.right - lSectionWidth,
            m_rc.top + lSrcYOffset,
            SRCCOPY);

        lGapHeight -= lFillHeight;
        lVertFillStart += lFillHeight;
    }

    return TRUE;
}/* end of function SpecialStretch */

/*************************************************************************

This stretching methods maintains the aspect ratio of the original bitmap.
The unoccupied portion of the dest DC will be filled with BackColor.

**************************************************************************/

BOOL CBitmap::StretchKeepAspectRatio(HDC hDC, LPRECT lpRect)
{
    BOOL bSuccess = TRUE;
    LONG lWidth = RECTWIDTH(lpRect);
    LONG lHeight = RECTHEIGHT(lpRect);
    LONG lWidthSrc = RECTWIDTH(&m_rc);
    LONG lHeightSrc = RECTHEIGHT(&m_rc);

    HBRUSH hbrBack = (HBRUSH)::GetStockObject(BLACK_BRUSH);            

    if(NULL == hbrBack){

        return(FALSE);
    }/* end of if statement */

    ::FillRect(hDC, lpRect, hbrBack);
    ::DeleteObject(hbrBack);

    if (lWidth*lHeightSrc < lHeight*lWidthSrc)
    {
        LONG lStretchHeight = (LONG)((float)lHeightSrc*lWidth/lWidthSrc + 0.5f);
        LONG lGapHeight = (lHeight - lStretchHeight)/2;

        bSuccess = ::StretchBlt(hDC,
            lpRect->left,                 // DestX
            lpRect->top + lGapHeight,     // DestY
            lWidth,                       // nDestWidth
            lStretchHeight,               // nDestHeight
            m_hSrcDC,
            m_rc.left,                      // SrcX
            m_rc.top,                       // SrcY
            lWidthSrc,                      // nSrcWidth
            lHeightSrc,                     // nSrcHeight
            SRCCOPY                         
            );
    }
    else
    {
        LONG lStretchWidth = (LONG)((float)lWidthSrc*lHeight/lHeightSrc + 0.5f);
        LONG lGapWidth = (lWidth - lStretchWidth)/2;

        bSuccess = ::StretchBlt(hDC,
            lpRect->left + lGapWidth,     // DestX
            lpRect->top,                  // DestY
            lStretchWidth,                // nDestWidth
            lHeight,                      // nDestHeight
            m_hSrcDC,
            m_rc.left,                      // SrcX
            m_rc.top,                       // SrcY
            lWidthSrc,                      // nSrcWidth
            lHeightSrc,                     // nSrcHeight
            SRCCOPY                         
            );
    }

    return bSuccess;
}

/*************************************************************************
    This is the entry point to stretch paint the bitmap

    m_stretchType indicates the type of stretching method to use:

        NORMAL = 0   :           normal stretching
        CUSTOM_CONTAINER = 1   : special stretching method for container
        MAINTAIN_ASPECT_RATIO =2 : stretching while maintaing aspect ratio

**************************************************************************/

BOOL CBitmap::StretchPaint(HDC hDC, LPRECT lpRect, COLORREF clrTrans)
{
    BOOL bSuccess = TRUE;

    LONG lWidth = RECTWIDTH(lpRect);
    LONG lHeight = RECTHEIGHT(lpRect);
    LONG lWidthSrc = RECTWIDTH(&m_rc);
    LONG lHeightSrc = RECTHEIGHT(&m_rc);

    // special case, src and dest rects are the same, just copy it
    if (lWidth == lWidthSrc && lHeight == lHeightSrc)
    {
        bSuccess = ::BitBlt(hDC,
            lpRect->left,             // DestX
            lpRect->top,              // DestY
            lWidth,                   // nDestWidth
            lHeight,                  // nDestHeight
            m_hSrcDC,
            m_rc.left,                      // SrcX
            m_rc.top,                       // SrcY
            SRCCOPY                         
            );
    }
    else if (m_stretchType == CUSTOM_CONTAINER)
    {
        bSuccess = CustomContainerStretch(hDC, lpRect);
    }
    else if (m_stretchType == MAINTAIN_ASPECT_RATIO)
    {
        bSuccess = StretchKeepAspectRatio(hDC, lpRect);
    }
    else // normal stretch
    {
#if 1
        // to ensure the transparent color is maintained, we first
        // fill the DC with the transparent color, and then do a
        // TransparentBlit. The resulting bitmap can be used for
        // transparent blting again.

        HBRUSH hbrTrans = ::CreateSolidBrush(clrTrans);

        if(NULL == hbrTrans){

            bSuccess = FALSE;
            return(bSuccess);
        }/* end of if statement */

        ::FillRect(hDC, lpRect, hbrTrans);
        ::DeleteObject(hbrTrans);
#endif
        bSuccess = ::TransparentBlt(hDC,
            lpRect->left,                 // DestX
            lpRect->top,                  // DestY
            lWidth,                       // nDestWidth
            lHeight,                      // nDestHeight
            m_hSrcDC,
            m_rc.left,                      // SrcX
            m_rc.top,                       // SrcY
            lWidthSrc,                      // nSrcWidth
            lHeightSrc,                     // nSrcHeight
            clrTrans
            );
    }

    return bSuccess;
}

/*******************************************************************
   Create the Src DC if it has not been done so before.

   If the current object uses the mosaic, the src DC is just a copy
   of the mosaic DC.
********************************************************************/
BOOL CBitmap::CreateSrcDC(HDC hDC)
{
    // Src DC is already created from a previous call

    if (m_hSrcDC != NULL)
    {
        return TRUE;
    }

    if (m_bUseMosaicBitmap)
    {
        if (m_hMosaicDC == NULL)
        {
            if (m_hMosaicBMP == NULL)
            {

                HRESULT hr = InitilizeMosaic(m_hInstanceRes);
                if (FAILED(hr) || m_hMosaicBMP == NULL)                
                    return FALSE;
            }

            m_hMosaicDC = ::CreateCompatibleDC(hDC);

            if(NULL == m_hMosaicDC){

                return(FALSE);
            }/* end of if statement */

            m_hMosaicBMPOld = (HBITMAP)::SelectObject(m_hMosaicDC, m_hMosaicBMP);

            HPALETTE hPal = GetPal();

            SelectRelizePalette(m_hMosaicDC, hPal, &m_hMosaicPALOld);
        }

        m_hSrcDC = m_hMosaicDC;
    }
    else
    {
        if (m_hBitmap == NULL){
            HRESULT hr = LoadImageFromRes(m_strFileName, m_hInstanceRes);
            if (FAILED(hr) || m_hBitmap == NULL)
                return FALSE;
        }/* end of if statement */

        m_hSrcDC = ::CreateCompatibleDC(hDC);

        if(NULL == m_hSrcDC){

            return FALSE;
        }/* end of if statement */

        m_hBitmapOld = (HBITMAP)::SelectObject(m_hSrcDC, m_hBitmap);

        HPALETTE hPal = GetPal();
        SelectRelizePalette(m_hSrcDC, hPal, &m_hPalOld);
    }

    if (m_hSrcDC == NULL)
    {
        return FALSE;
    }

    return TRUE;
}

/*************************************************************************
  GetTransparentColor()
**************************************************************************/
COLORREF CBitmap::GetTransparentColor()
{
    // retrieve transparent color according to type, default is magenta
    COLORREF clrTrans = RGB(255, 0, 255);
   
    if(TRANSPARENT_TOP_LEFT == m_blitType ||
        TOP_LEFT_WITH_BACKCOLOR == m_blitType ||
        TOP_LEFT_WINDOW_REGION == m_blitType )
    {
        clrTrans = ::GetPixel(m_hSrcDC, m_rc.left, m_rc.top);
    }
    else if(TRANSPARENT_BOTTOM_RIGHT  == m_blitType ||
        BOTTOM_RIGHT_WITH_BACKCOLOR == m_blitType ||
        BOTTOM_RIGHT_WINDOW_REGION == m_blitType )
    {
        clrTrans = ::GetPixel(m_hSrcDC, m_rc.right-1, m_rc.bottom-1);
    }
#if 0
    // in case we are pallete capable device find the color in our palette
    HPALETTE hPal = GetPal();

    if(hPal){
        HWND hwnd = ::GetDesktopWindow();
        HDC hdc = ::GetWindowDC(hwnd);

        if((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE){
            
            UINT clrTmp = GetNearestPaletteIndex(hPal, clrTrans);

            if(CLR_INVALID != clrTmp){

                clrTrans = PALETTEINDEX(clrTmp);
            }/* end of if statement */
        }/* end of if statement */

        ::ReleaseDC(hwnd, hdc);
    }/* end of if statement */
#endif
    return clrTrans;
}


/*************************************************************************

  PaintTransparentDIB is the main function call to draw the bitmap control.

  Before PaintTransparentDIB is called, the bitmap should have been loaded by
  PutImage(). Also the blitType and stretchType should have been set during 
  the PutImage call.

  Input parameters:

  hDC is the DC to paint the bitmap to

  lpDCWRect is the rect of the entire control window. We should privide that
     for buttons as well as container.

  lpDCRect is the current rect to paint to. For container, it could be a sub
     region of the lpDCWRect. For buttons, it is probably the same as
     the lpDCWRect. (However this function does not rely on this assumption.)

  Important data structures:

  m_hSrcDC is the DC that contains the original bitmap (unstretched).
  If the current object uses the mosaic bitmap, m_hSrcDC is just a copy
  of the m_hMosaicDC while m_rc keeps the location of the bitmap within
  the mosaic.

  m_hMemDC caches a copy of the bitmap that is stretched to the window size.
  This is used for quickly refreshing display if only portion of the screen 
  needs to be painted.

 ************************************************************************/

BOOL CBitmap::PaintTransparentDIB(HDC hDC,
                                 LPRECT lpDCWRect,
                                 LPRECT lpDCRect)
{
    BOOL bSuccess = TRUE;

    // create the src DC if we are first time here.
    // But we should already have the bitmap in memory

    if (!CreateSrcDC(hDC))
    {
        return FALSE;
    }

    // Color in the bitmap that indicates transparent pixel
    COLORREF clrTrans = GetTransparentColor();

    // check if we already have the stretched bitmap cached in mem DC
    // if not, create the MemDC and paint the stretched bitmap in it

    LONG lWidth = RECTWIDTH(lpDCWRect);
    LONG lHeight = RECTHEIGHT(lpDCWRect);
    RECT rc = {0, 0, lWidth, lHeight};

    if (!m_hMemDC || lWidth != m_iMemDCWidth || lHeight != m_iMemDCHeight)
    {
        if (!CreateMemDC(hDC, &rc))
        {
            return FALSE;
        }

        if (!StretchPaint(m_hMemDC, &rc, clrTrans))
        {
            return FALSE;
        }
    }

    // blit MemDC to screen DC with transparency.
    // Only the required DC Rect is painted (it could be a subregion of DCWRect)

    LONG lPaintWidth = RECTWIDTH(lpDCRect);
    LONG lPaintHeight = RECTHEIGHT(lpDCRect);

    if (m_blitType != DISABLE)
    {
        bSuccess = ::TransparentBlt(hDC, 
            lpDCRect->left,             // DestX
            lpDCRect->top,              // DestY
            lPaintWidth,                // nDestWidth
            lPaintHeight,               // nDestHeight
            m_hMemDC,
            lpDCRect->left - lpDCWRect->left, // SrcX
            lpDCRect->top - lpDCWRect->top,   // SrcY
            lPaintWidth,                   // nSrcWidth
            lPaintHeight,                  // nSrcHeight
            clrTrans                       // transparent color
        );
    }
    else  // disabled, no transparency
    {
        bSuccess = ::BitBlt(hDC,
            lpDCRect->left,             // DestX
            lpDCRect->top,              // DestY
            lPaintWidth,                // nDestWidth
            lPaintHeight,               // nDestHeight
            m_hMemDC,
            lpDCRect->left - lpDCWRect->left, // SrcX
            lpDCRect->top - lpDCWRect->top,   // SrcY
            SRCCOPY
        );
    }

    return bSuccess;
}


/*************************************************************************

  PutImage()

    If bFromMosaic is FALSE, it loads a bitmap from either a disk BMP file
    or from a BITMAP resource (depending on if hRes is NULL or not).

    If bFromMosaic is TRUE, it records a rect region of a mosaic bitmap as
    the bitmap for the current object. The mosaic bitmap itself can be loaded
    from a disk BMP file or from a BITMAP resource (depending on if hRes is
    NULL or not). But this mosaic bitmap is loaded only once for all the 
    objects that are sharing the mosaic. Loading from file or resource must
    be consistent among all those objects.

    The resource tag name or file name of the mosaic bitmap is currently
    hard coded (as IDR_MOSAIC_BMP or mosaicbm.bmp).

    This call also record the blit type and stretch type which indicate how 
    the bitmap is to be painted.

    blitType: 		
        DISABLE = 0   :                  Disabled, no transparency
		TRANSPARENT_TOP_LEFT = 1:        use clr of top left pix as transparent color
		TRANSPARENT_BOTTOM_RIGHT = 2:    use clr of bottom right as transparent color
		TOP_LEFT_WINDOW_REGION = 3:      currently treated as the same as 1 
		BOTTOM_RIGHT_WINDOW_REGION = 4:  currently treated as the same as 2
		TOP_LEFT_WITH_BACKCOLOR = 5:     currently treated as the same as 1
		BOTTOM_RIGHT_WITH_BACKCOLOR = 6: currently treated as the same as 2

    stretchType:
        NORMAL = 0   :           normal stretching
        CUSTOM_CONTAINER = 1   : special stretching method for container
        MAINTAIN_ASPECT_RATIO :  stretching while maintaing aspect ratio


*************************************************************************/
HRESULT CBitmap::PutImage(BSTR strFilename, HINSTANCE hRes, 
                          BOOL bFromMosaic, // the bitmap is in Mosaic bitmap
                          TransparentBlitType blitType,
                          StretchType stretchType
                          )
{
	USES_CONVERSION;
    HRESULT hr = S_OK;

    CleanUp();

    // save the blit and stretch types

    m_blitType = blitType;
    m_stretchType = stretchType;
    m_bUseMosaicBitmap = bFromMosaic;
    m_strFileName = strFilename;
    m_hInstanceRes = hRes;

    // initialize the mosaic file
    HRESULT hrTmp = InitilizeMosaic(hRes);

    if(FAILED(hrTmp)){

        // try to load up the file as a normal file or resource since mosaic load failed
        m_bUseMosaicBitmap = FALSE;
    }/* end of if statement */

    if (!LookupBitmapRect(OLE2T(strFilename), &m_rc))
    {
        // load individual bitmap from resource or file

        m_bUseMosaicBitmap = FALSE;
    }

    if (!m_bUseMosaicBitmap) {
        hr = LoadImageFromRes(m_strFileName, m_hInstanceRes);
    }

    return hr;
}/* end of function PutImage */

/*************************************************************/
/* Name: LoadImageFromRes
/* Description: 
/*************************************************************/
HRESULT CBitmap::LoadImageFromRes(BSTR strFileName, HINSTANCE hRes) {
    
	USES_CONVERSION;
    HRESULT hr = S_OK;
    BITMAP bm;

    TCHAR* strTmpFileName = TEXT("");
    strTmpFileName = OLE2T(strFileName);

    m_hBitmap = (HBITMAP)LoadImage(hRes, strTmpFileName, IMAGE_BITMAP, 0, 0,
        DIB_FLAG | LR_DEFAULTSIZE | (hRes?0:LR_LOADFROMFILE));
    
    if(NULL == m_hBitmap)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
    }
    
    ::GetObject(m_hBitmap, sizeof(BITMAP), (LPVOID) &bm);
    ::SetRect(&m_rc, 0, 0, bm.bmWidth, bm.bmHeight);

    return hr;
}/* end of function LoadImageFromRes */

/************************************************************************/
/* Function: InitilizeMosaic                                            */
/* Description: Trys to load up the mosaic bitmap, which contains a     */
/* collection of bitmaps.                                               */
/************************************************************************/
HRESULT CBitmap::InitilizeMosaic(HINSTANCE hRes){

    HRESULT hr = S_OK;

    TCHAR* strTmpFileName = TEXT("");

    // use a rectangular region of Mosaic bitmap
    // make sure the mosaic only loads once for all the objects    
    
    if (m_hMosaicBMP == NULL){

        if(!m_fLoadMosaic){

            hr = E_FAIL; // we already failed before to load the mosaic file do not
                         //try it again
            return(hr);
        }/* end of if statement */

        if (hRes)
        {
            // load mosaic bitmap
            strTmpFileName = TEXT("IDR_MOSAIC_BMP");

            hr = LoadPalette(strTmpFileName, hRes, &m_hMosaicPAL);

            if(FAILED(hr)){
                
                m_fLoadMosaic = false; 
                return(hr);
            }/* end of if statement */

            m_hMosaicBMP = (HBITMAP)LoadImage(hRes, strTmpFileName, IMAGE_BITMAP, 0, 0, 
                                                DIB_FLAG| LR_DEFAULTSIZE);
        }
        else
        {
            strTmpFileName = TEXT("mosaicbm.bmp");

            hr = LoadPalette(strTmpFileName, hRes, &m_hMosaicPAL);

            if(FAILED(hr)){
                
                m_fLoadMosaic = false; 
                return(hr);
            }/* end of if statement */

            m_hMosaicBMP = (HBITMAP)LoadImage(hRes, strTmpFileName, IMAGE_BITMAP, 0, 0, 
                                                DIB_FLAG| LR_LOADFROMFILE);
        }

        if(NULL == m_hMosaicBMP)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            m_fLoadMosaic = false; // do not attempt to reload the mosaic file
            return hr;
        }
    }/* end of if statement */

    return(hr);
}/* function InitilizeMosaic */



/************************************************************************/
/* Function: LoadPalette                                                */
/* Description: Loads a palette from a bitmap.                          */
/************************************************************************/
HRESULT CBitmap::LoadPalette(TCHAR* strFilename, HINSTANCE hRes){

    return(LoadPalette(strFilename, hRes, &m_hPal));
}/* end of function LoadPalette */

/************************************************************************/
/* Function: LoadPalette                                                */
/* Description: Loads a palette from a bitmap.                          */
/************************************************************************/
HRESULT CBitmap::LoadPalette(TCHAR* strFilename, HINSTANCE hInst, HPALETTE *phPal){
     
     HRESULT hr = S_OK;

     if(NULL == phPal){

         hr = E_POINTER;
         return(hr);
     }/* end of if statement */

     if (*phPal){
    
        ::DeleteObject(*phPal);
        *phPal = NULL;
     }/* end of if statement */

#ifdef USE_LOADIMAGE

     BITMAP  bm;

     // Use LoadImage() to get the image loaded into a DIBSection
     HBITMAP hBitmap = (HBITMAP) ::LoadImage( hInst,  strFilename, IMAGE_BITMAP, 0, 0,
                 LR_CREATEDIBSECTION| LR_DEFAULTSIZE | (hInst?LR_DEFAULTCOLOR:LR_LOADFROMFILE) );

     if( hBitmap == NULL ){

          hr = HRESULT_FROM_WIN32(::GetLastError());
          return hr;
     }/* end of if statement */

     // Get the color depth of the DIBSection
     ::GetObject(hBitmap, sizeof(BITMAP), &bm );
     // If the DIBSection is 256 color or less, it has a color table
     if( ( bm.bmBitsPixel * bm.bmPlanes ) <= 8 ){

       HDC           hMemDC;
       HBITMAP       hOldBitmap;
       RGBQUAD       rgb[256];
       LPLOGPALETTE  pLogPal;
       WORD          i;

       // Create a memory DC and select the DIBSection into it
       hMemDC = ::CreateCompatibleDC( NULL );
       hOldBitmap = (HBITMAP)::SelectObject( hMemDC, hBitmap );
       // Get the DIBSection's color table
       UINT ulNumEntries =::GetDIBColorTable( hMemDC, 0, 256, rgb );
       // Create a palette from the color table
       LPLOGPALETTE  pLogPal = (LPLOGPALETTE) new BYTE[( sizeof(LOGPALETTE) + (ncolors*sizeof(PALETTEENTRY)))];
       //pLogPal = (LPLOGPALETTE) malloc( sizeof(LOGPALETTE) + (ulNumEntries*sizeof(PALETTEENTRY)) );

       if(NULL == pLogPal){

           return(E_OUTOFMEMORY);
       }/* end of if statement */

       pLogPal->palVersion = 0x300;
       pLogPal->palNumEntries = (WORD) ulNumEntries;
       for(i=0;i<ulNumEntries;i++){

         pLogPal->palPalEntry[i].peRed = rgb[i].rgbRed;
         pLogPal->palPalEntry[i].peGreen = rgb[i].rgbGreen;
         pLogPal->palPalEntry[i].peBlue = rgb[i].rgbBlue;
         pLogPal->palPalEntry[i].peFlags = 0; /* PC_RESERVED */ /* 0 */
       }/* end of for loop */

       *phPal = ::CreatePalette( pLogPal );

       if( *phPal == NULL ){

          hr = HRESULT_FROM_WIN32(::GetLastError());          
       }/* end of if statement */

       // Clean up
       delete[] pLogPal;
       ::SelectObject( hMemDC, hOldBitmap );
       ::DeleteObject(hBitmap);
       ::DeleteDC( hMemDC );
     }
     else   // It has no color table, so use a halftone palette
     {
        hr = S_FALSE;
     }/* end of if statement */
#else
    // use our internal load image so we do not duplicate the code
     LoadImage(hInst, strFilename, IMAGE_BITMAP, 0, 0, (hInst?LR_DEFAULTCOLOR:LR_LOADFROMFILE), phPal);

     if(NULL == *phPal){
         
         hr = E_FAIL;
     }/* end of if statement */       
                              
#endif
     return(hr);
}/* end of function LoadPalette */

/************************************************************************

    Lookup the rectangle coordinates of a bitmap which is subregion of 
    the mosaic. The list of coordinates and associated names are compiled
    at the same time as the mosaic bitmap.

*************************************************************************/

BOOL CBitmap::LookupBitmapRect(LPTSTR szName, LPRECT rect)
{
	USES_CONVERSION;
    char *strIDR = T2A(szName);

    BmpRectRef *p = gBmpRectList;
    while (p->strIDR)
    {
        if (strcmp(p->strIDR, strIDR) == 0)
        {
            *rect = p->rect;
            return TRUE;
        }

        p++;
    }

    return FALSE;
}

/*************************************************************************/
/* Function: LoadImage                                                   */
/* Description: Either uses our load image or the OS LoadImage           */
/*************************************************************************/
HANDLE CBitmap::LoadImage(HINSTANCE hInst, LPCTSTR lpszName, UINT uType,
                          int cxDesired, int cyDesired, UINT fuLoad,
                          HPALETTE *phPal){

    HANDLE hBitmap = NULL;
    HGLOBAL hBmpFile = NULL;
    HANDLE  hFile = NULL;
    BYTE* lpCurrent = NULL;
    BYTE* lpDelete = NULL;
        
    try {
    #ifdef USE_LOADIMAGE
        hBitmap = ::LoadImage(hInst, lpszName, uType, cxDesired, cyDesired,
                                                fuLoad);                                             
    #else
        bool fPaletteOnly = false;

        if(NULL != phPal){

            fPaletteOnly = true;
            *phPal = NULL;
        }/* end of if statement */

        UINT ncolors = 0;
        DWORD dwBitsSize = 0;
        DWORD dwOffset = 0;
        
        if(fuLoad & LR_LOADFROMFILE){

            hFile =  ::CreateFile(
	        lpszName,    // pointer to name of the file
	        GENERIC_READ,   // access (read-write) mode
	        FILE_SHARE_READ,    // share mode
	        NULL,   // pointer to security descriptor
	        OPEN_EXISTING,  // how to create
	        FILE_ATTRIBUTE_NORMAL,  // file attributes
	        NULL    // handle to file with attributes to copy
            );

            if(hFile == INVALID_HANDLE_VALUE){
                #if _DEBUG
                if(!fPaletteOnly){
    
                    TCHAR strBuffer[MAX_PATH + 25];
                    wsprintf(strBuffer, TEXT("Failed to download %s"), lpszName);
                    ::MessageBox(::GetFocus(), strBuffer, TEXT("Error"), MB_OK);
                }/* end of if statement */
                #endif
                throw (NULL);
            }/* end of if statement */

            dwBitsSize = GetFileSize(hFile,NULL);

            if(0 >= dwBitsSize){

                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */

            BITMAPFILEHEADER bmfHeader;
            DWORD nBytesRead;

            if(! ReadFile(hFile, (LPSTR)&bmfHeader, sizeof(bmfHeader), &nBytesRead, NULL)){

                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */

            if(sizeof(bmfHeader) != nBytesRead){

                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */
    
            if (bmfHeader.bfType != DIB_HEADER_MARKER){

                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */

            dwBitsSize -= sizeof(BITMAPFILEHEADER);

            lpCurrent = lpDelete = new BYTE[dwBitsSize];
            
            if(NULL == lpDelete){

                ATLASSERT(FALSE);
                throw(NULL);
            }/* end of if stament */
          
            if(!ReadFile(hFile, (LPSTR)lpCurrent, dwBitsSize, &nBytesRead, NULL)){
                
                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */

            if(nBytesRead != dwBitsSize){

                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */

            ::CloseHandle(hFile);
            hFile = NULL;
        }        
        else {
            // loading from resources
    
            // Find the Bitmap
            HRSRC hRes = ::FindResource(hInst, lpszName, RT_BITMAP);
            if (!hRes){

                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */

            // Load the BMP from the resource file.
            hBmpFile = ::LoadResource(hInst, hRes);
            if ((!hBmpFile)){
            
                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */
        
            dwBitsSize = ::SizeofResource(hInst, hRes);

            // copy out the appropriate info from the bitmap
            lpCurrent = (BYTE *)::LockResource(hBmpFile);
        }/* end of if statement */

                                
        // The BITMAPFILEHEADER is striped for us, so we just start with a BITMAPINFOHEADER
        BITMAPINFOHEADER* lpbmih = (BITMAPINFOHEADER *)lpCurrent;
        lpCurrent += sizeof(BITMAPINFOHEADER);
        dwOffset = sizeof(BITMAPINFOHEADER);

        // Compute some usefull information from the bitmap
        if (lpbmih->biPlanes != 1){

            ATLASSERT(FALSE);
            throw (NULL);
        }/* end of if statement */

        if (    lpbmih->biBitCount != 1
            &&  lpbmih->biBitCount != 4
            &&  lpbmih->biBitCount != 8
            &&  lpbmih->biBitCount != 16
            &&  lpbmih->biBitCount != 24
            &&  lpbmih->biBitCount != 32){

            ATLASSERT(FALSE);
            throw (NULL);
        }/* end of if statement */
    
        if (lpbmih->biBitCount <= 8){

            ncolors = 1 << lpbmih->biBitCount;

            if (lpbmih->biClrUsed > 0 && lpbmih->biClrUsed < ncolors){

                ncolors = lpbmih->biClrUsed;
            }/* end of if statement */
        }/* end of if statemet */

        RGBQUAD* lprgb = NULL;
        //HPALETTE m_hPal = NULL;

        if (ncolors){

            bool fLoadPalette = m_fLoadPalette || fPaletteOnly;

            if(fLoadPalette){
            
               WORD          i;       
               LPLOGPALETTE  pLogPal = (LPLOGPALETTE) new BYTE[( sizeof(LOGPALETTE) + (ncolors*sizeof(PALETTEENTRY)))];

               if(NULL == pLogPal){

                   ATLASSERT(FALSE);
                   throw (NULL);
               }/* end of if statement */

               pLogPal->palVersion = 0x300;
               pLogPal->palNumEntries = (WORD) ncolors;

               lprgb = (RGBQUAD *)lpCurrent;

               for(i=0;i<ncolors;i++){

                 pLogPal->palPalEntry[i].peRed = lprgb[i].rgbRed;
                 pLogPal->palPalEntry[i].peGreen = lprgb[i].rgbGreen;
                 pLogPal->palPalEntry[i].peBlue = lprgb[i].rgbBlue;
                 pLogPal->palPalEntry[i].peFlags = 0; /* PC_RESERVED */ /* 0 */
               }/* end of for loop */

               if(!fPaletteOnly){

                    m_hPal = ::CreatePalette( pLogPal );
               }
               else {

                    *phPal = ::CreatePalette( pLogPal );
               }/* end of if statement */

               // Clean up
               delete[] pLogPal;               
            }/* end of if statement */

            // here is the place to load up palette more eficiently                
            lpCurrent += ncolors * sizeof(RGBQUAD);
            dwOffset += ncolors * sizeof(RGBQUAD);
        }/* end of if statement */

        if(!fPaletteOnly){

            BYTE* pBits = NULL;

            typedef struct tagBITMAPINFOMAX {
                BITMAPINFOHEADER    bmiHeader;
                RGBQUAD             bmiColors[256];
            } BITMAPINFOMAX;


            BITMAPINFOMAX bmi; // temporary bitmap info header so we can modify it a bit
            ::CopyMemory(&bmi, lpbmih, sizeof(BITMAPINFOHEADER) + ncolors * sizeof(RGBQUAD));

            DWORD dwCompression = lpbmih->biCompression;

            bmi.bmiHeader.biCompression = BI_RGB; // DIB Section does not like RLE
            //bmi.bmiHeader.biBitCount = 32; 

            // update to DIB_RGB_COLORS or DIB_PAL_COLORS Colors            
            HDC hdcScreen = ::GetDC(NULL);

            hBitmap = ::CreateDIBSection(hdcScreen, (BITMAPINFO*)&bmi, DIB_RGB_COLORS, (LPVOID*) &pBits, NULL, 0);                       
            //hBitmap = ::CreateDIBSection(hdc, (BITMAPINFO*)lpbmih, DIB_RGB_COLORS, (LPVOID*) &pBits, NULL, 0);                       

            if(hBitmap){

                // now use the orginal bmih
                ::SetDIBits(hdcScreen, (HBITMAP) hBitmap, 0, lpbmih->biHeight, lpCurrent, (BITMAPINFO*)lpbmih, DIB_RGB_COLORS);
            }
            else {

                DWORD dwError =::GetLastError();
                ::ReleaseDC(NULL, hdcScreen);
                ATLASSERT(FALSE);
                throw (NULL);
            }/* end of if statement */

            ::ReleaseDC(NULL, hdcScreen);

        }/* end of if statement */

        
        
        if(lpDelete){

            delete[] lpDelete; // cleanup the bits if we had to allocate them
            lpDelete = NULL;
        }/* end of if statement */

        if(hBmpFile){

            UnlockResource(hBmpFile);
            ::FreeResource(hBmpFile);
            hBmpFile = NULL;
        }/* end of if statement */
    }/* end of try statement */
       
#endif
    catch(...){

        if(hBmpFile){

            UnlockResource(hBmpFile);
            ::FreeResource(hBmpFile);
        }/* end of if statement */

        if(hFile){

            ::CloseHandle(hFile);
            hFile = NULL;
        }/* end of if statement */

        if(lpDelete){

            delete[] lpDelete; // cleanup the bits if we had to allocate them
            lpDelete = NULL;
        }/* end of if statement */
            
        hBitmap = NULL;
    }/* end of catch statement */

    return(hBitmap);
}/* end of function LoadImage */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\ccobj.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CCObj.h                                                         */
/* Description: Contains holder for container objects.                   */
/*************************************************************************/
#ifndef __CCOBJ_H
#define __CCOBJ_H

//#include "chobj.h"

class CHostedObject;
/*************************************************************************/
/* Class: CContainerObject                                               */
/* Description: Object that contains container. This is a simple wrapper */
/* inorder to have really just one cobtainer site, but at the same time  */
/* support the windowless activation. We pass in this object instead of  */
/* the real site, so we can track which windowless object has focus and  */
/* or capture.                                                           */
/*************************************************************************/
class CContainerObject:	
    public IOleClientSite,    
    public IOleInPlaceSiteWindowless,
    public IOleContainer,
    public IObjectWithSite,
    public IPropertyBag,
    public IOleControlSite,
    public IOleInPlaceFrame 
{
    protected:
        
        CContainerObject(){Init();};
    public:
        virtual ~CContainerObject(){ATLTRACE2(atlTraceHosting, 0, TEXT("In the CContainerObject object destructor \n")); ;};
        CContainerObject(IUnknown* pUnknown, CHostedObject* pObj);
    
        STDMETHOD(QueryInterface)(const IID& iid, void**ppv);
        STDMETHOD_(ULONG,AddRef)( void);
        STDMETHOD_(ULONG,Release)( void);

        // needed to initialize this object
        HRESULT SetObjects(IUnknown* pUnknown, CHostedObject* pObj);
        HRESULT InvalidateObjectRect();

        // IOleClientSite
        STDMETHOD(SaveObject)(){ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));}
        STDMETHOD(GetMoniker)(DWORD /*dwAssign*/, DWORD /*dwWhichMoniker*/, IMoniker** /*ppmk*/){ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));}
        STDMETHOD(GetContainer)(IOleContainer** ppContainer);
        STDMETHOD(ShowObject)();	        
        STDMETHOD(OnShowWindow)(BOOL fShow);
        STDMETHOD(RequestNewObjectLayout)(){ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));}        
        // IOleWindow
        STDMETHOD(GetWindow)(HWND *phwnd);
        STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);
        //IOleInPlaceSite
        STDMETHOD(CanInPlaceActivate)();
        STDMETHOD(OnUIActivate)();
        STDMETHOD(OnInPlaceActivate)();
        STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo);
        STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
	    STDMETHOD(OnInPlaceDeactivate)();
    	STDMETHOD(DiscardUndoState)();
	    STDMETHOD(DeactivateAndUndo)();
	    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);	
        STDMETHOD(Scroll)(SIZE scrollExtant);
        //IOleInPlaceSiteEx
	    STDMETHOD(OnInPlaceActivateEx)(BOOL* pfNoRedraw, DWORD dwFlags);
	    STDMETHOD(OnInPlaceDeactivateEx)(BOOL fNoRedraw);
	    STDMETHOD(RequestUIActivate)();
        STDMETHOD(CanWindowlessActivate)();
	    STDMETHOD(GetCapture)();
	    STDMETHOD(SetCapture)(BOOL fCapture);
	    STDMETHOD(GetFocus)();
	    STDMETHOD(SetFocus)(BOOL fFocus);
	    STDMETHOD(GetDC)(LPCRECT /*pRect*/, DWORD /*grfFlags*/, HDC* phDC);
	    STDMETHOD(ReleaseDC)(HDC hDC);
	    STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase);
	    STDMETHOD(InvalidateRgn)(HRGN hRGN = NULL, BOOL fErase = FALSE);	
	    STDMETHOD(ScrollRect)(INT /*dx*/, INT /*dy*/, LPCRECT /*pRectScroll*/, LPCRECT /*pRectClip*/);
	    STDMETHOD(AdjustRect)(LPRECT /*prc*/);
	    STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);  
        // IOleContainer
        STDMETHOD(ParseDisplayName)(IBindCtx* /*pbc*/, LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/);
	    STDMETHOD(EnumObjects)(DWORD /*grfFlags*/, IEnumUnknown** ppenum);
	    STDMETHOD(LockContainer)(BOOL fLock);
	    //IObjectWithSite
        STDMETHOD(SetSite)(IUnknown *pUnkSite){ATLTRACENOTIMPL(_T("IObjectWithSite::SetSite"));}
        STDMETHOD(GetSite)(REFIID riid, void  **ppvSite);
        //IPropertyBag
        STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog* pErrorLog);
        STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT* pVar){ATLTRACENOTIMPL(_T("IPropertyBag::Write"));}        

        // IOleControlSite
	    STDMETHOD(OnControlInfoChanged)(){
            ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::OnControlInfoChanged\n"));
		    return S_OK;
	    }
	    STDMETHOD(LockInPlaceActive)(BOOL /*fLock*/)
	    {
            ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::LockInPlaceActive\n"));
		    return S_OK;
	    }
	    STDMETHOD(GetExtendedControl)(IDispatch** ppDisp);
	    STDMETHOD(TransformCoords)(POINTL* /*pPtlHimetric*/, POINTF* /*pPtfContainer*/, DWORD /*dwFlags*/)
	    {
            ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::TransformCoords\n"));
		    return S_OK;
	    }
	    STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, DWORD /*grfModifiers*/)
	    {
            ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::TranslateAccelerator\n"));
		    return S_FALSE;
	    }
	    STDMETHOD(OnFocus)(BOOL /*fGotFocus*/)
	    {
            ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::OnFocus\n"));
		    return S_OK;
	    }
	    STDMETHOD(ShowPropertyFrame)()
	    {
            ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::ShowPropertyFrame\n"));
		    return E_NOTIMPL;
	    }

        STDMETHOD(InsertMenus)(HMENU /*hmenuShared*/, LPOLEMENUGROUPWIDTHS /*lpMenuWidths*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::InsertMenus\n"));
		return S_OK;
	}

	STDMETHOD(SetMenu)(HMENU /*hmenuShared*/, HOLEMENU /*holemenu*/, HWND /*hwndActiveObject*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::SetMenu\n"));
		return S_OK;
	}

	STDMETHOD(RemoveMenus)(HMENU /*hmenuShared*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::RemoveMenus\n"));
		return S_OK;
	}

	STDMETHOD(SetStatusText)(LPCOLESTR /*pszStatusText*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::SetStatusText\n"));
		return S_OK;
	}

    /********** Implemented somewhere Else ***/
	STDMETHOD(EnableModeless)(BOOL /*fEnable*/)
	{
		return S_OK;
	}


	STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, WORD /*wID*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::TranslateAccelerator\n"));
		return S_FALSE;
	}


    // IOleWindow
#if 0 // implemented somwhere else, but implementation might need to be revised
	STDMETHOD(GetWindow)(HWND* phwnd){
        
		*phwnd = m_hWnd;
		return S_OK;
	}


	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::ContextSensitiveHelp\n"));
        return S_OK;
	}
#endif
// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(LPRECT lprectBorder);
	STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS pborderwidths);
	STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS pborderwidths);
	STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR pszObjName);

    protected: // helper functions
        void Init();
        inline HRESULT GetWindowlessSite(CComPtr<IOleInPlaceSiteWindowless>& pSite);
        inline HRESULT GetContainer(CComPtr<IOleContainer>& pContainer);
        HRESULT ParsePropertyBag(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog*  pErrorLog);

    private: // private member variables
        CHostedObject* m_pObj; // object which we are hosting
        CComPtr<IUnknown> m_pUnkContainer; // pointer to our container
        CComPtr<IOleInPlaceFrame> m_spInPlaceFrame; // cached up pointer
        CComPtr<IOleInPlaceUIWindow> m_spInPlaceUIWindow; // cached up pointer
        long m_lRefCount;
        unsigned long m_bLocked:1;
};/* end of class CContainerObject */

#endif // end of __CCOBJ_H
/*************************************************************************/
/* End of file: CCObj.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\chobj.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CHObj.h                                                         */
/* Description: Contains object that is the contained ActiveX controls   */
/*************************************************************************/

#ifndef __CHOBJ_H
#define __CHOBJ_H

#include "ccobj.h"

/*************************************************************************/
/* Class: CHostedObject                                                  */
/* Description: Object that contains the contained control.              */
/*************************************************************************/
class CHostedObject{

public:        
    CHostedObject(){Init();};
    CHostedObject(BSTR strID, BSTR strPropBag, IUnknown* pUnknown);
    virtual ~CHostedObject(){Cleanup();};

    static HRESULT CreateObject(BSTR strObjectID, BSTR strProgID, BSTR strPropBag, CHostedObject** ppObj);
    static HRESULT CHostedObject::AddObject(BSTR strObjectID, BSTR strPropBag, LPUNKNOWN pUnknown, CHostedObject** ppObj);

    BSTR GetID(); // Gets the ID of the ActiveX Object
    BSTR GetPropBag(); // Gets the string to the property bag
    IUnknown* GetUnknown(); // gets the IUnknown of the ActiveX object
    HRESULT GetViewObject(IViewObjectEx** pIViewObject);
    HRESULT GetOleObject(IOleObject** pIOleObject);
    HRESULT InitViewObject(); // initializes the internal view object
    HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    HRESULT GetPos(RECT *rc);  
    HRESULT SetRawPos(const RECT *rc);    
    HRESULT SetObjectRects(RECT *rc = NULL);
    bool    IsWindowless(){return(m_bWindowless);};
    void    SetWindowless(bool bWindowless){m_bWindowless = bWindowless;};
    bool    IsActive(){return(m_fActive);};
    HRESULT SetActive(bool fActive);
    bool    IsInputEnabled();
    HRESULT SetInputEnabled(bool fEnabled);

    bool    HasCapture(){return(m_fCapture);};
    void    SetCapture(bool fCapture){m_fCapture = fCapture;};
    bool    HasFocus(){return(m_fFocus);};
    void    SetFocus(bool fFocus){m_fFocus = fFocus;};
    HRESULT GetContainerObject(CContainerObject** ppCnt){*ppCnt = m_pContainerObject; if(*ppCnt) return(S_OK); else return(E_UNEXPECTED);}
    HRESULT SetContainerObject(CContainerObject* pCnt){m_pContainerObject = pCnt; return(S_OK);};
    HRESULT GetWindow(HWND* pHwnd);
    HRESULT SetCookie(VARIANT v){m_vCookie = v; return(S_OK);};
    HRESULT GetCookie(VARIANT* pv){*pv = m_vCookie; return(S_OK);};
        
    // TODO: DISABLE COPY CONSTRUCTOR !!!
protected:
    void Init();
    void Cleanup();

private:    
    CComBSTR m_strID; // ID of the hosted control object (assigned by user)
    CComBSTR m_strPropBag; // Property bag info
    CComPtr<IUnknown> m_pUnknown; // pointer to IUnknown of the contained object
    CComPtr<IViewObjectEx> m_spViewObject; // pointer to IViewObject
    CComPtr<IOleObject> m_pOleObject; // pointer to this IOleObject
    CContainerObject* m_pContainerObject;    
    RECT m_rcRawPos; // position without the adjustment for offset    
    bool m_bWindowless;
    bool m_fActive;
    bool m_fCapture;
    bool m_fFocus;    
    bool m_fInputEnabled;
    CComVariant m_vCookie;
};/* end of class CHostedObject */

#endif __CHOBJ_H
/*************************************************************************/
/* End of file: CHObj.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\chobj.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CHObj.cpp                                                       */
/*************************************************************************/
#include "stdafx.h"
#include "chobj.h"

/*************************************************************************/
/* Implemntation of Class: CHostedObject                                 */
/*************************************************************************/

/*************************************************************************/
/* Function: CHostedObject                                               */
/* Description: Constructor that initializes member variables of the     */
/* object.                                                               */
/*************************************************************************/
CHostedObject::CHostedObject(BSTR strID, BSTR strPropBag, IUnknown* pUnknown){

    Init();
    m_strID = strID;
    m_strPropBag = strPropBag;
    m_pUnknown = pUnknown;
    ::ZeroMemory(&m_rcRawPos, sizeof(RECT));
}/* end of function CHostedObject */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes the member variables                         */
/*************************************************************************/
void CHostedObject::Init(){

    m_pContainerObject = NULL;    
    m_bWindowless = false;
    //m_fActive = false;
    m_fActive = true;
    m_fCapture = false;
    m_fFocus = false;
    m_fInputEnabled = true;
    ::ZeroMemory(&m_rcRawPos, sizeof(RECT));    
}/* end of function Init */

/*************************************************************************/
/* Function: Cleanup                                                     */
/* Description: Cleans up the member variables                           */
/*************************************************************************/
void CHostedObject::Cleanup(){

    try {
        ATLTRACE2(atlTraceHosting, 0, TEXT("In the cleanup of the CHostedObject %ws\n"), GetID());

#if 0  // cannot kill the container before its control is destructed
        if(NULL != m_pContainerObject){
            
            delete m_pContainerObject;
        }/* end of if statement */
#endif                              
        Init();
    }
    catch(...){
        ATLTRACE(TEXT("Reference counting is off \n"));
        return;
    }/* end of if statement */
}/* end of function Cleanup */

/*************************************************************************/
/* Function: CreateObject                                                */
/* Description: Creates the ActiveX Object via CoCreateInstance and      */
/* initializes it. If everything went OK the return the newly allocate   */
/* pObj.                                                                 */
/*************************************************************************/
HRESULT CHostedObject::CreateObject(BSTR strObjectID, BSTR strProgID, BSTR strPropBag, CHostedObject** ppObj){

    HRESULT hr;
    CLSID  tmpCLSID;

    if(NULL == ppObj){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *ppObj = NULL; // set the return value to NULL

    hr = ::CLSIDFromProgID(strProgID, &tmpCLSID);

    if (FAILED(hr)){

        // Try to get CLSID from string if not prog ID
        HRESULT hrTmp = CLSIDFromString(strProgID, &tmpCLSID);

        if(FAILED(hrTmp)){

            if (hr == CO_E_CLASSSTRING) {
                // BUG#101663
                // We can not use %1!ls! for Win95.
                return DISP_E_EXCEPTION;
            }/* end of if statement */
        
            return hr;
        }/* end of if statement */
    }/* end of if statement */

    CComPtr<IUnknown> pUnknown;

    hr = pUnknown.CoCreateInstance(tmpCLSID);        

    if (FAILED(hr)) {

        return(hr);
    }/* end of if statement */

    // everything went OK now allocate the object and set the variables to it
    *ppObj =  new  CHostedObject(strObjectID, strPropBag, pUnknown);

    if(NULL == *ppObj){ // in case we do not support exception handling

        hr =  E_OUTOFMEMORY;
    }/* end of if statement */

    return (hr);
}/* end of function CreateObject */

/*************************************************************************/
/* Function: AddObject                                                   */
/* Description: Simmilar to create object, but does not create on. Takes */
/* an existing IUnknown and wraps it, in the object structure.           */
/*************************************************************************/
HRESULT CHostedObject::AddObject(BSTR strObjectID, BSTR strPropBag, LPUNKNOWN pUnknown, 
                                 CHostedObject** ppObj){

    HRESULT hr = S_OK;
    
    if(NULL == ppObj){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    if(NULL == pUnknown){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *ppObj = NULL; // set the return value to NULL
    
    // everything went OK now allocate the object and set the variables to it
    *ppObj =  new  CHostedObject(strObjectID, strPropBag, pUnknown);

    if(NULL == *ppObj){ // in case we do not support exception handling

        hr =  E_OUTOFMEMORY;
    }/* end of if statement */

    return (hr);
}/* end of function AddObject */

/*************************************************************************/
/* Function: GetID                                                       */
/* Description: Returns the ID of the object                             */
/*************************************************************************/
BSTR CHostedObject::GetID(){

    return(m_strID);
}/* end of function GetID */

/*************************************************************************/
/* Function: GetPropBag                                                  */
/* Description: Returns the textual information that represents property */
/* bag and is associate with the object.                                 */
/*************************************************************************/
BSTR CHostedObject::GetPropBag(){

    return(m_strPropBag);
}/* end of function GetPropBag */

/*************************************************************************/
/* Function: GetUnknown                                                  */
/* Description: Gets the IUnknown stored in this object.                 */
/*************************************************************************/
IUnknown* CHostedObject::GetUnknown(){
    
    return(m_pUnknown);
}/* end of function GetUnknown */

/*************************************************************************/
/* Function: GetViewObject                                               */
/* Description: Gets the IViewObject cached for this object.             */
/*************************************************************************/
HRESULT CHostedObject::GetViewObject(IViewObjectEx** pIViewObject){

    HRESULT hr = S_OK;

    try {
        if(NULL == pIViewObject){

            throw(E_POINTER);
        }/* end of if statement */

        if(!m_spViewObject){

            hr = InitViewObject();

            if(FAILED(hr)){

                throw(hr);        
            }/* end of if statement */
        }/* end of if statement */

        if(!m_spViewObject){

            *pIViewObject = NULL;
            hr = E_FAIL;
            throw(hr);
        }/* end of if statement */

        *pIViewObject = m_spViewObject;
        (*pIViewObject)->AddRef(); // giving it out have add reff
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statemenmt */

	return(hr);	    
}/* end of function GetViewObject */

/*************************************************************************/
/* Function: GetOleObject                                                */
/* Description: Gets the IOleObject cached for this object.              */
/*************************************************************************/
HRESULT CHostedObject::GetOleObject(IOleObject** ppIOleObject){

    HRESULT hr = S_OK;

    try {
        if(NULL == ppIOleObject){

            throw(E_POINTER);
        }/* end of if statement */

        if(!m_pOleObject){

            if(!m_pUnknown){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            // cache up the IOleObject
            hr = m_pUnknown->QueryInterface(&m_pOleObject);

            if(FAILED(hr)){

                throw(hr);        
            }/* end of if statement */
        }/* end of if statement */

#ifdef _DEBUG
        if(!m_pOleObject){ // sometimes we get OK from QI but IOleObject is NULL

            *ppIOleObject = NULL;            
            throw(E_FAIL);
        }/* end of if statement */
#endif

        *ppIOleObject = m_pOleObject;        
        (*ppIOleObject)->AddRef();
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statemenmt */

	return(hr);	    
}/* end of function GetOleObject */

/*************************************************************************/
/* Function: GetTypeInfo                                                 */
/* Description: Calls the IDispatch object TypeInfo                      */
/*************************************************************************/
HRESULT CHostedObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo){

    HRESULT hr = S_OK;

    try {

        if(!m_pUnknown){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        CComPtr<IDispatch> pDispatch;

        hr = m_pUnknown->QueryInterface(&pDispatch);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = pDispatch->GetTypeInfo(itinfo,  lcid,  pptinfo);        

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statemenmt */
	return(hr);	
}/* end of funciton GetTypeInfo */

/*************************************************************************/
/* Function: GetPos                                                      */
/* Description: Accessor to the position of the embedded object.         */
/*************************************************************************/
HRESULT CHostedObject::GetPos(RECT* pRcPos){

    HRESULT hr = S_OK;

    if(NULL == pRcPos){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */
    
    // Get the raw rect for this object and then adjust it for the 
    // offset of the container

    *pRcPos = m_rcRawPos; 
   
    if(IsWindowless()){
        
        return(hr);
    }/* end of if statement */


    HWND hwnd = NULL;

    hr = GetWindow(&hwnd);

    if(FAILED(hr)){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    ::GetWindowRect(hwnd, pRcPos);  

    m_rcRawPos = *pRcPos; // update our cached value

    return(hr);
}/* end of function GetPos */

/*************************************************************************/
/* Function: SetRawPos                                                   */
/* Description: We set the RawPosition, which is location relative to the*/
/* container. Adjustment for the offset is done in GetPos function.      */
/*************************************************************************/
HRESULT CHostedObject::SetRawPos(const RECT* pRcPos){

    HRESULT hr = S_OK;

    if(NULL == pRcPos){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    m_rcRawPos = *pRcPos;
  
    return(hr);
}/* end of function SetRawPos */

/*************************************************************************/
/* Function: SetObjectRects                                              */
/* Description: Notififies the Controls about chaning rects, so they     */
/* will update their positions.                                          */
/*************************************************************************/
HRESULT CHostedObject::SetObjectRects(RECT* prcPos){

    HRESULT hr = S_OK;

    RECT rc;

    if(NULL == prcPos){
    
        hr = GetPos(&rc);
    }
    else {

        rc = *prcPos;
    }/* end of if statement */

    if(FAILED(hr)){

        throw(hr);
    }/* end of if statement */
    
    CComPtr<IOleInPlaceObject> pIOlePlace;

    if(!m_pUnknown){
        
        hr = S_FALSE;
        return(hr); // do not have the object yet no way to set it
    }/* end of if statement */

    hr = m_pUnknown->QueryInterface(&pIOlePlace);

    if(FAILED(hr)){
        
        hr = S_FALSE;
        return(hr); // do not have the IOleInPlaceObject in other words not activated
                    // object yet no way to set it, so lets not complain that
                    // much, since the ATL would break on 
    }/* end of if statement */

    // TODO: Pass down the clip rects evntaully, but right not used 
    // in our controls

    hr = pIOlePlace->SetObjectRects(&rc, &rc);
    
    return(hr);
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: InitViewObject                                              */
/* Description: Initializes the ViewObject.                              */
/*************************************************************************/
HRESULT CHostedObject::InitViewObject(){

    HRESULT hr = S_OK;

    if(!m_pUnknown){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

	hr = m_pUnknown->QueryInterface(IID_IViewObjectEx, (void**) &m_spViewObject);
    if (FAILED(hr)){

		hr = m_pUnknown->QueryInterface(IID_IViewObject2, (void**) &m_spViewObject);

        if (FAILED(hr)){

			hr = m_pUnknown->QueryInterface(IID_IViewObject, (void**) &m_spViewObject);			
		}/* end of if statement */
	}/* end of if statement */

    return(hr);
}/* end of function InitViewObject */

/*************************************************************************/
/* Function: SetActive                                                   */
/* Description: Sets the control flag to be active or not.               */
/* This disables it drawing in the container.                            */
/*************************************************************************/
HRESULT CHostedObject::SetActive(bool fActivate){

    HRESULT hr = S_OK;

    m_fActive = fActivate; // this might seem like a bug, but flag is important
                         // even if we do not get to hide the windowed control
    if(IsWindowless()){

        return(hr); // do not have to deal with hiding and showing of the window
        // we just do not draw the nonactive objects in the container
    }/* end of if statement */

    HWND hwnd = NULL;

    hr = GetWindow(&hwnd);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(::IsWindow(hwnd)){

        INT nShow = fActivate ? SW_SHOW : SW_HIDE;
        ::ShowWindow(hwnd, nShow);
    }/* end of if statement */

    return(hr);
}/* end of function SetActive */

/*************************************************************************/
/* Function: GetWindow                                                   */
/* Description: Gets the control window.                                 */
/*************************************************************************/
HRESULT CHostedObject::GetWindow(HWND* pHwnd){

    HRESULT hr = S_OK;

    // now try to 
    if(!m_pUnknown){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IOleInPlaceObject> pOleInPObject;
    hr = m_pUnknown->QueryInterface(&pOleInPObject);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */
    
    hr = pOleInPObject->GetWindow(pHwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    return(hr);
}/* end of if statement */

/*************************************************************************/
/* Function: IsInputEnabled                                              */
/* Description: Function that lets us know if the input is enabled or not*/
/*************************************************************************/
bool CHostedObject::IsInputEnabled(){

    if(IsActive()){

        return m_fInputEnabled;
    }/* end of if statement */

    return false;
}/* end of function IsInputEnabled */


/*************************************************************************/
/* Function: SetInputEnabled                                             */
/* Description: Sets the control flag to to disable or enable mouse and  */
/* keyboard input to a windowless controll.                              */
/*************************************************************************/
HRESULT CHostedObject::SetInputEnabled(bool fInputEnabled){

    HRESULT hr = E_FAIL;

    m_fInputEnabled = fInputEnabled; // this might seem like a bug, but flag is important
                         // even if we do not get to hide the windowed control
    if(IsWindowless()){

        hr = S_OK;       
        // we just do not draw the nonactive objects in the container
    }/* end of if statement */

    return(hr); // do not handle the windowed case
}/* end of function SetInputEnabled */

    
/*************************************************************************/
/* End of file: CHObj.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\ccobj.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CCObj.cpp                                                       */
/* Description: Contains holder for container objects.                   */
/*************************************************************************/
#include "stdafx.h"
#include "ccobj.h"
#include "chobj.h"

#define GET_SITE CComPtr<IOleInPlaceSiteWindowless> pSite;  \
                    HRESULT hr = GetWindowlessSite(pSite);   \
                    if(FAILED(hr)) return(hr);

#define GET_CONTAINER CComPtr<IOleContainer> pContainer;  \
                    HRESULT hr = GetContainer(pContainer);   \
                    if(FAILED(hr)) return(hr);

#define GET_INPLACEUIWINDOW CComPtr<IOleContainer> pContainer;  \
                    HRESULT hr = GetContainer(pContainer);   \
                    if(FAILED(hr)) return(hr); \
                    CComPtr<IOleInPlaceUIWindow> pUIWindow; \
                    hr = pContainer->QueryInterface(IID_IOleInPlaceUIWindow, (void**) &pUIWindow); \
                    if(FAILED(hr)) return(hr); 

/*************************************************************************/
/* Function: CContainerObject                                            */
/* Description: Constructor that should set needed objects.              */
/*************************************************************************/
CContainerObject::CContainerObject(IUnknown* pUnknown, CHostedObject* pObj){

    Init();
    SetObjects(pUnknown, pObj);
}/* end of function CContainerObject */
    
/*************************************************************************/
/* Function: SetObjects                                                  */
/* Description: Sets the internal objects.                               */
/*************************************************************************/
HRESULT CContainerObject::SetObjects(IUnknown* pUnknown, CHostedObject* pObj){
    
    m_pUnkContainer = pUnknown;
    m_pObj = pObj;
    return(S_OK);
}/* end of function SetObjects */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes the member variables                         */
/*************************************************************************/
void CContainerObject::Init(){

    //m_pUnkContainer = NULL; // using smart pointer
    m_pObj = NULL;
    m_lRefCount = 1;
    m_bLocked = 0;
}/* end of function Init */

/*************************************************************************/
/* Function: QueryInterface                                              */
/* Description: Gets the supported interface rest sends to the aggregated*/
/* object                                                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::QueryInterface(const IID& iid, void**ppv){

    if(iid == IID_IUnknown){

        *ppv = static_cast<CContainerObject*>(this);
    }
    else if(iid == IID_IOleInPlaceSiteWindowless){

        *ppv = static_cast<IOleInPlaceSiteWindowless*>(this);
    }
    else if(iid == IID_IOleInPlaceSiteEx){

        *ppv = static_cast<IOleInPlaceSiteEx*>(this);
    }
    else if(iid == IID_IOleClientSite){

        *ppv = static_cast<IOleClientSite*>(this);
    }        
    else if(iid == IID_IOleContainer){

        *ppv = static_cast<IOleContainer*>(this);
    }        
    else if(iid == IID_IOleInPlaceSite){

        *ppv = static_cast<IOleInPlaceSite*>(this);
    }        
    else if(iid == IID_IObjectWithSite){

        *ppv = static_cast<IObjectWithSite*>(this);
    }        
    else if(iid == IID_IPropertyBag){

        *ppv = static_cast<IPropertyBag*>(this);
    }
    else if(iid == IID_IOleControlSite){

        *ppv = static_cast<IOleControlSite*>(this);
    }
    else if(iid == IID_IOleInPlaceFrame){

        *ppv = static_cast<IOleInPlaceFrame*>(this);
    }
    else if(iid == IID_IOleInPlaceUIWindow){

        *ppv = static_cast<IOleInPlaceUIWindow*>(this);
    }
    else if(iid == IID_IOleWindow){
        
        IOleInPlaceSiteWindowless* ppTmp = static_cast<IOleInPlaceSiteWindowless*>(this);    
        *ppv = static_cast<IOleWindow*>(ppTmp);
    }
   else { 
       ATLTRACE2(atlTraceHosting, 0, _T("QI Failed\n"));              
       *ppv = NULL;
        return (E_NOINTERFACE);
    }/* end of if statement */

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return(S_OK);
}/* end of function QueryInterface */

/*************************************************************************/
/* Function: AddRef                                                      */
/* Description: Adds the reference count.                                */
/*************************************************************************/
STDMETHODIMP_(ULONG) CContainerObject::AddRef ( void){

    return(InterlockedIncrement(&m_lRefCount));
}/* end of function AddRef */

/*************************************************************************/
/* Function: Release                                                     */
/* Description: Decrements the reference count and the possibly releases */
/*************************************************************************/
STDMETHODIMP_(ULONG) CContainerObject::Release( void){

    if(InterlockedIncrement(&m_lRefCount) <=0){

        delete this;
        return 0;
    }/* end of if statement */

    return (m_lRefCount);
}/* end of function Release */

/*************************************************************************/
/* Helper functions                                                      */
/*************************************************************************/

/*************************************************************************/
/* Function: GetWindowlessSite                                           */
/* Description: Returns an interface for windowless site.                */
/*************************************************************************/
inline HRESULT CContainerObject::GetWindowlessSite(CComPtr<IOleInPlaceSiteWindowless>& pSite){ 

    if(!m_pUnkContainer){ 

        return(E_UNEXPECTED);
    }/* end of if statement */

    return(m_pUnkContainer->QueryInterface(&pSite));
}/* end of function GetWindowlessSite */

/*************************************************************************/
/* Function: GetContainer                                                */
/* Description: Returns an interface for windowless site.                */
/*************************************************************************/
inline HRESULT CContainerObject::GetContainer(CComPtr<IOleContainer>& pContainer){ 

    if(!m_pUnkContainer){ 

        return(E_UNEXPECTED);
    }/* end of if statement */

    return(m_pUnkContainer->QueryInterface(&pContainer));
}/* end of function GetContainer */

/*************************************************************************/
/* IOleContainer Implementation                                          */
/*************************************************************************/

/*************************************************************************/
/* Function: ParseDisplayName                                            */
/*************************************************************************/
STDMETHODIMP CContainerObject::ParseDisplayName(IBindCtx* /*pbc*/, 
                                                LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/){

    ATLTRACENOTIMPL(_T("IOleClientSite::ParseDisplayName"));		
}/* end of function ParseDisplayName */

/*************************************************************************/
/* Function: EnumObjects                                                 */
/*************************************************************************/
STDMETHODIMP CContainerObject::EnumObjects(DWORD grfFlags, IEnumUnknown** ppenum){

    GET_CONTAINER
    return(pContainer->EnumObjects(grfFlags, ppenum));	
}/* end of function EnumObjects */

/*************************************************************************/
/* Function: LockContainer                                               */
/* Description: Sets the container locked so it does not go away.        */
/*************************************************************************/
STDMETHODIMP CContainerObject::LockContainer(BOOL fLock){

    // TODO: Actually do use the m_bLocked flag
	m_bLocked = fLock;
	return S_OK;
}/* end of function LockContainer */

/*************************************************************************/
/* IOleClientSite Implementation                                         */
/*************************************************************************/

/*************************************************************************/
/* Function: GetContainer                                                */
/* Description: Basically returns our self                               */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetContainer(IOleContainer** ppContainer){

    ATLTRACE2(atlTraceHosting, 0, _T("IOleClientSite::GetContainer\n"));
    HRESULT hr = E_POINTER;

    if (NULL == ppContainer){

        return(hr);
    }/* end of if statement */

    if (m_pUnkContainer){
	
	    (*ppContainer) = NULL;		         
	    hr = QueryInterface(IID_IOleContainer, (void**)ppContainer); // return our selfs
    }/* end of if statement */

    return hr;
}/* end of function GetContainer */

/*************************************************************************/
/* Function: ShowObject                                                  */
/* Description: Redraws the object.                                      */
/*************************************************************************/
STDMETHODIMP CContainerObject::ShowObject(){

    HRESULT hr = S_OK;

    ATLTRACE2(atlTraceHosting, 0, _T("IOleClientSite::ShowObject\r\n"));

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = InvalidateObjectRect();
    
    return (hr);
}/* end of function ShowObject */

/*************************************************************************/
/* Function: OnShowWindow                                                */
/* Description: Shows or hides the window. If no window to show or hide  */
/* we deactivate it.                                                     */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnShowWindow(BOOL fShow){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = m_pObj->SetActive(fShow ? true: false);

    return(hr);
}/* end of function OnShowWindow */

/*************************************************************************/
/* IOleInPlaceSiteEx Implementation                                      */
/* Just pass throw in most cases, in some do some extra house keeping    */
/* since we know which object we are containing.                         */
/*************************************************************************/

// IOleWindow
/*************************************************************************/
/* Function: GetWindow                                                   */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetWindow(HWND *phwnd){

    GET_SITE
    return(pSite->GetWindow(phwnd));
}/* end of function GetWindow */

/*************************************************************************/
/* Function: ContextSensitiveHelp                                        */
/*************************************************************************/
STDMETHODIMP CContainerObject::ContextSensitiveHelp(BOOL fEnterMode){

    GET_SITE
    return(pSite->ContextSensitiveHelp(fEnterMode));
}/* end of function ContextSensitiveHelp */

//IOleInPlaceSite
/*************************************************************************/
/* Function: CanInPlaceActivate                                          */
/*************************************************************************/
STDMETHODIMP CContainerObject::CanInPlaceActivate(){

    GET_SITE
    return(pSite->CanInPlaceActivate());
}/* end of function CanInPlaceActivate */

/*************************************************************************/
/* Function: OnUIActivate                                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnUIActivate(){

    GET_SITE
    return(pSite->OnUIActivate());
}/* end of function OnUIActivate */

/*************************************************************************/
/* Function: OnInPlaceActivate                                           */
/* Description: Activates non windowless object.                         */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceActivate(){

    ATLTRACE(TEXT("CContainerObject::OnInPlaceActivate \n"));

    HRESULT hr = E_FAIL;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IUnknown> pUnk = m_pObj->GetUnknown(); // get the control object that is being inserted

    if(!pUnk){

        return(E_UNEXPECTED);
    }/* end of if statement */

	//OleLockRunning(pUnk, TRUE, FALSE); // not sure if needed here

    m_pObj->SetWindowless(false);
	//m_pObj->SetActive(true);

    return(hr);
}/* end of function OnInPlaceActivate */

/*************************************************************************/
/* Function: OnUIDeactivate                                              */
/* Description: Deactivates the object.                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnUIDeactivate(BOOL fUndoable){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    m_pObj->SetActive(false);

    return(hr);
}/* end of function OnUIDeactivate */

/*************************************************************************/
/* Function: OnInPlaceDeactivate                                         */
/* Description: Deactivates the object.                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceDeactivate(){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    m_pObj->SetActive(false);

    return(hr);
}/* end of function OnInPlaceDeactivate */

/*************************************************************************/
/* Function: DiscardUndoState                                            */
/*************************************************************************/
STDMETHODIMP CContainerObject::DiscardUndoState(){

    GET_SITE
    return(pSite->DiscardUndoState());    
}/* end of function DiscardUndoState */

/*************************************************************************/
/* Function: DeactivateAndUndo                                           */
/*************************************************************************/
STDMETHODIMP CContainerObject::DeactivateAndUndo(){

    GET_SITE
    return(pSite->DeactivateAndUndo());
    // TODO: Handle specific container
}/* end of function DeactivateAndUndo */

/*************************************************************************/
/* Function: OnPosRectChange                                             */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnPosRectChange(LPCRECT lprcPosRect){

    GET_SITE
    return(pSite->OnPosRectChange(lprcPosRect));
    // TODO: Handle specific container
}/* end of function OnPosRectChange */

/*************************************************************************/
/* Function: Scroll                                                      */
/*************************************************************************/
STDMETHODIMP CContainerObject::Scroll(SIZE scrollExtent){

    GET_SITE
    return(pSite->Scroll(scrollExtent));
    // TODO: Handle specific container
}/* end of function OnPosRectChange */

/*************************************************************************/
/* Function: GetWindowContext                                            */
/* Description: Finish this function to be container specific.           */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetWindowContext(IOleInPlaceFrame** ppFrame, 
                           IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, 
                           LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo){

	HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL){

		hr = E_POINTER;
        return(hr);
    }/* end of if statement */
		
	if (!m_spInPlaceFrame){

		//CComObject<CAxFrameWindow>* pFrameWindow;
		//CComObject<CAxFrameWindow>::CreateInstance(&pFrameWindow);
        // ?? MODS DJ
		QueryInterface(IID_IOleInPlaceFrame, (void**) &m_spInPlaceFrame);
		ATLASSERT(m_spInPlaceFrame);
	}/* end of if statement */

	if (!m_spInPlaceUIWindow){
        // ?? MODS DJ
		//CComObject<CAxUIWindow>* pUIWindow;
		//CComObject<CAxUIWindow>::CreateInstance(&pUIWindow);
		QueryInterface(IID_IOleInPlaceUIWindow, (void**) &m_spInPlaceUIWindow);
		ATLASSERT(m_spInPlaceUIWindow);
	}/* end of if statement */

	m_spInPlaceFrame.CopyTo(ppFrame);
	m_spInPlaceUIWindow.CopyTo(ppDoc);

    RECT rc;
    hr = m_pObj->GetPos(&rc);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    *lprcPosRect = rc;
    *lprcClipRect = rc;

    HWND hwnd;
    hr = GetWindow(&hwnd);

    if(FAILED(hr)){

        hr = S_FALSE;
        //return(hr);
    }/* end of if statement */

    HWND hParent = NULL;

    if(NULL != hwnd){
        
        hParent = ::GetParent(hwnd);
    }/* end of function GetParent */

	ACCEL ac = { 0,0,0 };
    HACCEL hac = ::CreateAcceleratorTable(&ac, 1);
	pFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
	pFrameInfo->fMDIApp = 0;
	pFrameInfo->hwndFrame =  hParent;
	pFrameInfo->haccel = hac;
	pFrameInfo->cAccelEntries = 1;

	return hr;
}/* end of function GetWindowContext */

/*************************************************************************/
/* Function: GetSite                                                     */
/* Description: Returns pretty much QI, client sets the site and then    */
/* container is using it.                                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetSite(REFIID riid, void  **ppvSite){

    return(QueryInterface(riid, ppvSite));
}/* end of function GetSite */

//IOleInPlaceSiteEx

/*************************************************************************/
/* Function: OnInPlaceActivateEx                                         */
/* Description: Checks what way we shall instantiate the control.        */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceActivateEx(BOOL* /*pfNoRedraw*/, DWORD dwFlags){

    HRESULT hr = E_FAIL;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IUnknown> pUnk = m_pObj->GetUnknown(); // get the control object that is being inserted

    if(!pUnk){

        return(E_UNEXPECTED);
    }/* end of if statement */

	//OleLockRunning(pUnk, TRUE, FALSE);

    CComPtr<IOleInPlaceObjectWindowless> spInPlaceObjectWindowless;

    bool bWindowless = false;

	if (dwFlags & ACTIVATE_WINDOWLESS){
		
        m_pObj->SetWindowless(true);
		hr = pUnk->QueryInterface(IID_IOleInPlaceObjectWindowless,(void**) &spInPlaceObjectWindowless);
	}/* end of if statement */

	if (FAILED(hr)){

		m_pObj->SetWindowless(false);
		hr = pUnk->QueryInterface(IID_IOleInPlaceObject, (void**) &spInPlaceObjectWindowless);
	}/* end of if statement */

    if (SUCCEEDED(hr)){

        RECT rcPos;
        hr = m_pObj->GetPos(&rcPos);
        
        if (FAILED(hr)){

            return(hr);
        }/* end of if statement */

        if(m_pObj->IsWindowless()){

		    spInPlaceObjectWindowless->SetObjectRects(&rcPos, &rcPos);            
            ATLTRACE(TEXT("Windowless object is contained object with ID %ls Rect left = %d top %d right %d bottom %d\n"), 
                m_pObj->GetID(), rcPos.left, rcPos.top, rcPos.right, rcPos.bottom);
        }/* end of if statement */        
    }/* end of if statement */
    
    //m_pObj->SetActive(true);
   
	return S_OK;
}/* end of function OnInPlaceActivateEx */

/*************************************************************************/
/* Function: OnInPlaceDeactivateEx                                       */
/* Description: Deactivates the object.                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceDeactivateEx(BOOL fNoRedraw){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    m_pObj->SetActive(false);

    return(hr);
}/* end of function OnInPlaceDeactivateEx */

/*************************************************************************/
/* Function: RequestUIActivate                                           */
/*************************************************************************/
STDMETHODIMP CContainerObject::RequestUIActivate(){

    GET_SITE
    return(pSite->RequestUIActivate());
}/* end of function RequestUIActivate */

/*************************************************************************/
/* Function: CanWindowlessActivate                                       */
/*************************************************************************/
STDMETHODIMP CContainerObject::CanWindowlessActivate(){

    GET_SITE
    return(pSite->CanWindowlessActivate());
}/* end of function CanWindowlessActivate */

/*************************************************************************/
/* Function: GetDC                                                       */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetDC(LPCRECT pRect, DWORD grfFlags, HDC* phDC){

    GET_SITE
    return(pSite->GetDC(pRect, grfFlags, phDC));
}/* end of function GetDC */

/*************************************************************************/
/* Function: ReleaseDC                                                   */
/*************************************************************************/
STDMETHODIMP CContainerObject::ReleaseDC(HDC hDC){

    GET_SITE
    return(pSite->ReleaseDC(hDC));
}/* end of function ReleaseDC */

/*************************************************************************/
/* Function: InvalidateRect                                              */
/*************************************************************************/
STDMETHODIMP CContainerObject::InvalidateRect(LPCRECT pRect, BOOL fErase){

    GET_SITE
    return(pSite->InvalidateRect(pRect, fErase));
}/* end of function InvalidateRect */

/*************************************************************************/
/* Function: InvalidateObjectRect                                        */
/* Description: Invalidates the whole control.                           */
/*************************************************************************/
HRESULT CContainerObject::InvalidateObjectRect(){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */
    
    RECT rc;
    hr = m_pObj->GetPos(&rc);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    hr = InvalidateRect(&rc, FALSE); // invalidate the region instead 
                                    // of drawing the object directly
    return(hr);
}/* end of function InvalidateRect */    

/*************************************************************************/
/* Function: InvalidateRgn                                               */
/*************************************************************************/
STDMETHODIMP CContainerObject::InvalidateRgn(HRGN hRGN, BOOL fErase){

    GET_SITE
    return(pSite->InvalidateRgn(hRGN, fErase));
}/* end of function InvalidateRgn */

/*************************************************************************/
/* Function: ScrollRect                                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::ScrollRect(INT dx, INT dy, LPCRECT pRectScroll, LPCRECT pRectClip){

    GET_SITE
    return(pSite->ScrollRect(dx, dy, pRectScroll, pRectClip));
}/* end of function ScrollRect */

/*************************************************************************/
/* Function: AdjustRect                                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::AdjustRect(LPRECT prc){

    GET_SITE
    return(pSite->AdjustRect(prc));
}/* end of function AdjustRect */

/*************************************************************************/
/* Function: OnDefWindowMessage                                          */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult){

    GET_SITE
    return(pSite->OnDefWindowMessage(msg, wParam, lParam, plResult));
}/* end of function OnDefWindowMessage */

/*************************************************************************/
/* Function: GetCapture                                                  */
/* Description: Used to determine if we have a cupature or not           */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetCapture(){

    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = pSite->GetCapture();

    if(SUCCEEDED(hr)){

        // we checked with the container if we
        // have a capture

        if(m_pObj->HasCapture() == false){

            hr = S_FALSE;
        } 
        else {

            if(hr == S_FALSE){ 
                // case when the container say we do not have
                // the capture any more
                // but the object thinks it has a capture
                // we better reset the flag
                m_pObj->SetCapture(false);
                // and say that we do not have capture
                hr = S_FALSE;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    return(hr);    
}/* end of function GetCapture */

/*************************************************************************/
/* Function: SetCapture                                                  */
/* Description: Used to set the capture for mouse events                 */
/*************************************************************************/
STDMETHODIMP CContainerObject::SetCapture(BOOL fCapture){

    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */
    
    if(fCapture && !m_pObj->IsInputEnabled()){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    if(m_pObj->HasCapture() == (fCapture ? true: false)){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    // Call our "real" container object for count keeping
    // and signaling to its window or another container   
    hr = pSite->SetCapture(fCapture);

    if(SUCCEEDED(hr)){

        m_pObj->SetCapture(fCapture? true: false); // set the capture on the object
    }/* end of if statement */

    return (hr);
}/* end of function SetCapture */

/*************************************************************************/
/* Function: GetFocus                                                    */
/* Description: Determine if we have a focus or not.                     */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetFocus(){

    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = pSite->GetFocus();

    if(SUCCEEDED(hr)){

        if(m_pObj->HasFocus() == false){

            hr = S_FALSE;
        } 
        else {

            if(S_FALSE == hr){ 
                m_pObj->SetFocus(false);
                hr = S_FALSE;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    return(hr);    
}/* end of function GetFocus */

/*************************************************************************/
/* Function: SetFocus                                                    */
/* Description: Sets focus to the control                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::SetFocus(BOOL fFocus){
    
    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    if(fFocus && !m_pObj->IsInputEnabled()){

        // can't set focus to not active objects
        // but can take away focus from non active ones
        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    if(m_pObj->HasFocus() == (fFocus ? true: false)){

        // we are not chaning focus state so do not bother calling container
        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    // Call our "real" container object for count keeping
    // and signaling to its window or another container   
    hr = pSite->SetFocus(fFocus);

    if(SUCCEEDED(hr)){                  

        m_pObj->SetFocus(fFocus ? true: false); // set the capture on the object
    }/* end of if statement */

    InvalidateObjectRect();

    return (hr);
}/* end of function SetFocus */



/*************************************************************************/
/* IPropertyBag                                                          */
/*************************************************************************/

/*************************************************************************/
/* Function: Read                                                        */
/* Description: Reads a specific control property from a bag.            */
/* The bag looks like IE compatible <PARAM NAME="PropName" VALUE="value">*/
/*************************************************************************/
STDMETHODIMP CContainerObject::Read(LPCOLESTR pszPropName, VARIANT* pVar, 
                                    IErrorLog* pErrorLog){

    HRESULT hr = S_OK;

    try {

        ATLTRACE2(atlTraceHosting, 0, _T("IPropertyBag::Read\r\n"));

        if(NULL == m_pObj){

            throw(E_UNEXPECTED);            
        }/* end of if statement */

        if (NULL == pVar){

            throw(E_POINTER);            
        }/* end of if statement */

        hr = ParsePropertyBag(pszPropName, pVar, pErrorLog);

    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function Read */

/*************************************************************************/
/* Function: MyIsWhiteSpace                                              */
/* Local function implementation, since we do not have standart C lib    */
/* support                                                               */
/*************************************************************************/
static bool MyIsWhiteSpace( WCHAR c ){

    return  c == L' ' ||
            c == L'\t' ||
            c == L'\r' ||
            c == L'\n';
}/* end of function MyIsWhiteSpace */

/*************************************************************************/
/* Function: MyStrToDouble                                               */
/* Description: Reads in string and converts it to double                */
/* Returns  E_INVALIDARG if there is alpah or some other undesired string*/
/* S_OK if we got some string, S_FALSE if no number string (empty or spac*/
/*************************************************************************/
static HRESULT MyStrToDouble(WCHAR* pstr, double &n)
{
    HRESULT hr = S_FALSE;

    int Sign = 1;
    n = 0;                // result wil be n*Sign
    bool bBeforeDecimalPoint = true;
    double k = 10;

    // eat whitespace at start
    while( *pstr != L'\n' && MyIsWhiteSpace( *pstr ) ) {
        pstr++;
    }

    while( pstr[lstrlenW(pstr)-1]!= L'\n' && MyIsWhiteSpace( *pstr ) ) {
        pstr[lstrlenW(pstr)-1] = L'\0';
    }

    //lstrcmpiW is not implemented on 98 need to use STDLIB
    // TODO: eventaully replace the below  _wcsicmp with our own so we can remove support
    // on standard C library
    if (_wcsicmp(pstr, L"true") == 0) {
        n = -1;
        return S_OK;
    }

    if (_wcsicmp(pstr, L"false") == 0) {
        n = 0;
        return S_OK;
    }

    if (pstr[0]==L'-'){
        Sign = -1;
        ++pstr;
    }/* end of if statement */

    for( ; ; ) {
        if (pstr[0]>=L'0' && pstr[0]<=L'9') {
            if(bBeforeDecimalPoint == true){
                n = 10*n+(int)(pstr[0]-L'0');
            } else {
                n = n+ ((int)(pstr[0]-L'0'))/k;
                k = k * 10; // decrease the decimal point

            }/* end of if statement */
            hr = S_OK;
        } else if (  MyIsWhiteSpace( pstr[0] ) || pstr[0] == L'\0' ) {
            break;
        } else if( bBeforeDecimalPoint && pstr[0] == L'.') {
            bBeforeDecimalPoint = false;
        } else {
            hr = E_INVALIDARG;
            break;
        }/* end of if statement */
        ++pstr;
    }/* end of for loop */

    n *= Sign; // adjust the sign
    return(hr);
}/* end of function MyStrToDouble */

/*************************************************************************/
/* Function: CompSubstr                                                  */
/* Description: ComaparesSubstr, eats up whithe spaces.                  */
/*************************************************************************/
HRESULT CompSubstr(WCHAR*& strSource, const WCHAR* strKey){

    bool bEatSpaces = true;
    register WCHAR wcKey = *strKey;
    register WCHAR wcSrc = *strSource;

    for(INT i = 0; wcKey != NULL; wcSrc = *(++strSource)){

        if(bEatSpaces){
            // eat up the spaces and tabs and enters and cr
            if(MyIsWhiteSpace(wcSrc)){
                continue;
            }
            else {
                bEatSpaces = false;
            }/* end of if statement */
        }/* end of if statement */
        
        if(wcKey != wcSrc){

            return(E_FAIL);
        }/* end of if statement */

        if(NULL == wcSrc){

            return(E_FAIL); // ran out of space in the source string
        }/* end of if statement */

        wcKey = strKey[++i]; // advance the key
    }/* end of for loop */

    return(S_OK);    
}/* end of function CompSubstr */

/*************************************************************************/
/* Function: ParsePropertyBag                                            */
/* Description: Retrives a property from the bag and puts it into variant*/
/* if it fails returns E_FAIL.                                           */
/*************************************************************************/
HRESULT CContainerObject::ParsePropertyBag(LPCOLESTR pszPropName, VARIANT* pVar, 
                                    IErrorLog* /* pErrorLog */){

    HRESULT hr = S_OK;

    try {

        CComBSTR strBag = m_pObj->GetPropBag();

        if(!strBag){

            throw(E_FAIL);
        }/* end of if statement */       

        WCHAR* strValue = NULL; // the place where we are going to stick the actuall value
                         // before putting it into variant
        WCHAR* strTmpValue = L"";
        WCHAR* strTmpBag = strBag;

        if(NULL == *strTmpBag){

            throw(E_FAIL);
        }/* end of if statement */

        INT iState = 0; // 0 start

        bool fFound = false;
        bool fFinished = false;
        INT iLength = 0; // noting the start and end of the value string
        // now try to parse out the value for the appropriate string
        for(INT i = 0; NULL != *strTmpBag && !fFinished; i++){

            switch(iState){
                case 0: // looking for start <
                    if(FAILED(CompSubstr(strTmpBag, L"<"))) return (E_FAIL);
                    iState = 1; break;
                    
                case 1: // PARAM
                    if(FAILED(CompSubstr(strTmpBag, L"PARAM"))) return (E_FAIL);
                    iState = 2; break;

                case 2: // NAME
                    if(FAILED(CompSubstr(strTmpBag, L"NAME"))) return (E_FAIL);
                    iState = 3; break;

                case 3: // =
                    if(FAILED(CompSubstr(strTmpBag, L"="))) return (E_FAIL);
                    iState = 4; break;

                case 4: // "
                    if(FAILED(CompSubstr(strTmpBag, L"\""))) return (E_FAIL);
                    iState = 5; break;
                
                case 5: // pszPropName (the actual name)
                    if(SUCCEEDED(CompSubstr(strTmpBag, pszPropName))){
                        
                        fFound = true; // found the PropName
                    }/* end of if statement */

                    iState = 6; break;

                case 6: // "            
                    if(SUCCEEDED(CompSubstr(strTmpBag, L"\""))){

                        iState = 7; 
                    }
                    else {

                        strTmpBag++;
                    }/* end of if statement */
                    break;

                case 7: // VALUE
                    if(FAILED(CompSubstr(strTmpBag, L"VALUE"))) return (E_FAIL);
                    iState = 8; break;

                case 8: // =
                    if(FAILED(CompSubstr(strTmpBag, L"="))) return (E_FAIL);
                    iState = 9; break;

                case 9: // "
                    if(FAILED(CompSubstr(strTmpBag, L"\""))) return (E_FAIL);
                    iState = 10; break;


                case 10: // VALUE
                    if(fFound){

                        // read up the string and exit the loop
                        strTmpValue = strTmpBag;                        
                    }/* end of if statement */
                    
                    iState = 11; break;

                case 11: // "
                    if(SUCCEEDED(CompSubstr(strTmpBag, L"\""))){
                        iState = 12; 

                        if(fFound){
                            iLength = INT(strTmpBag - strTmpValue);                        

                            strValue = new WCHAR[iLength];
                            memcpy(strValue, strTmpValue, iLength * sizeof(WCHAR));
                            strValue[iLength - 1] = NULL;
                            // read up the string and exit the loop

                            fFinished = true; // exit the loop
                        }/* end of if statement */                        
                    }
                    else {

                        strTmpBag++;
                    }/* end of if statement */
                    break;
                
                case 12: // closing brakcet >  
                    if(FAILED(CompSubstr(strTmpBag, L">"))) return (E_FAIL);
                    iState = 0;
                    break;
            }/* end of switch statement */
        }/* end of for loop */

        if(!fFinished){

            return(E_FAIL);
        }/* end of if statement */

        // at this moment we have value parsed out

        switch(pVar->vt){

        case VT_BSTR:
            pVar->bstrVal = ::SysAllocString(strValue);
            break;

        case VT_I4: {
            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->lVal = (INT)dbl;
        }
        case VT_UI4:{
            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->ulVal = (ULONG)dbl;
        }
        break;

        case VT_R4: {

            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->fltVal = (FLOAT) dbl;

        }
        break;

        case VT_R8: {

            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->dblVal = dbl;

        }
        break;

        case VT_BOOL: {
            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            if(0.0 == dbl){

                pVar->boolVal = VARIANT_FALSE;
            }
            else if(1.0 == dbl || -1.0 == dbl){

                pVar->boolVal = VARIANT_TRUE;
            }
            else {

                throw(E_FAIL);
            }/* end of if statement */
        }
        break;

        default:
            ATLTRACE2(atlTraceHosting, 0, _T("This type is not implemented please add.\r\n"));
            ATLASSERT(FALSE);
            throw(E_FAIL);
        }/* end of switch statement */

        delete strValue; // cleanup our variable
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function ParsePropertyBag */

/*************************************************************************/
/* Function: GetExtendedControl                                          */
/* Description: Used to get a DISPATCH of the wrapper for the control,   */
/* that exposes container specific features. Implement this in order to  */
/* speed up processing in the container.                                 */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetExtendedControl(IDispatch** ppDisp){

        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::GetExtendedControl\n"));
        ATLASSERT(FALSE); // TODO, this interface needs to be moved to the hosted object

#if 0
		if (ppDisp == NULL)
			return E_POINTER;
		return m_spOleObject.QueryInterface(ppDisp);
#endif

        *ppDisp = NULL;
        return(E_FAIL);
}/* end of function GetExtendedControl */

/*************************************************************************/
/* Function: GetBorder                                                   */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetBorder(LPRECT lprectBorder){

	GET_INPLACEUIWINDOW
    return(pUIWindow->GetBorder(lprectBorder));
}/* end of function GetBorder */

/*************************************************************************/
/* Function: RequestBorderSpace                                          */
/*************************************************************************/
STDMETHODIMP CContainerObject::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths){

    GET_INPLACEUIWINDOW
    return(pUIWindow->RequestBorderSpace(pborderwidths));
}/* end of function RequestBorderSpace */

/*************************************************************************/
/* Function: SetBorderSpace                                              */
/*************************************************************************/
STDMETHODIMP CContainerObject::SetBorderSpace(LPCBORDERWIDTHS pborderwidths){

    GET_INPLACEUIWINDOW
    return(pUIWindow->SetBorderSpace(pborderwidths));	
}/* end of function SetBorderSpace */

/*************************************************************************/
/* Function: SetActiveObject                                             */
/* Description: Sets the active object on the container to which we      */
/* send messagess.                                                       */
/*************************************************************************/
STDMETHODIMP CContainerObject::SetActiveObject(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR pszObjName){

    GET_INPLACEUIWINDOW
    return(pUIWindow->SetActiveObject(pActiveObject, pszObjName));	
}/* end of function SetActiveObject */
        
/*************************************************************************/
/* End of file: CCObj.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\cstutils.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CstUtils.h                                                      */
/* Description: Utilities that we can share across mutliple modules.     */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFCSTUTILS_H_
#define __MSMFCSTUTILS_H_
#include <commctrl.h>

#ifdef _WMP
#include "wmp.h" // for wmp integration
#endif

const bool gcfGrayOut = false;

#define WM_USER_FOCUS (WM_USER + 0x10)
#define WM_USER_ENDHELP (WM_USER + 0x11)

#define OCR_ARROW_DEFAULT 100

#define USE_MF_OVERWRITES \
HRESULT InvalidateRgn(bool fErase = false){return MFInvalidateRgn(fErase);} \
HRESULT FireViewChange(){return MFFireViewChange();} \
HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect){return MFInPlaceActivate(iVerb, prcPosRect);} \
HRESULT SetCapture(bool bCapture){return MFSetCapture(bCapture);} \
HRESULT SetFocus(bool bFocus){return MFSetFocus(bFocus);} \
HWND    GetWindow(){return MFGetWindow();} \
HRESULT ForwardWindowMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LONG& lRes,\
         bool fForwardInWndls = false){return MFForwardWindowMessage(uMsg, wParam, lParam, lRes, \
                                        fForwardInWndls);}


#define USE_MF_RESOURCEDLL \
STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal){return get_MFResourceDLL(pVal);} \
STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal){return put_MFResourceDLL(newVal);}

#define USE_MF_WINDOWLESS_ACTIVATION \
STDMETHOD(get_Windowless)(VARIANT_BOOL *pVal){return get_MFWindowless(pVal);} \
STDMETHOD(put_Windowless)(VARIANT_BOOL newVal){return put_MFWindowless(newVal);}

#define USE_MF_TRANSPARENT_FLAG \
STDMETHOD(get_TransparentBlit)(TransparentBlitType *pVal){return  get_MFTransparentBlit(pVal);}\
STDMETHOD(put_TransparentBlit)(TransparentBlitType newVal){return put_MFTransparentBlit(newVal);}

#define USE_MF_CLASSSTYLE \
static CWndClassInfo& GetWndClassInfo(){ \
    static HBRUSH wcBrush = ::CreateSolidBrush(RGB(0,0,0)); \
	    static CWndClassInfo wc = {{ sizeof(WNDCLASSEX), 0 /*CS_OWNDC*/, StartWindowProc, \
		      0, 0, NULL, NULL, NULL,  wcBrush /* (HBRUSH)(COLOR_WINDOW + 1) */, \
              NULL, TEXT("MSMFCtlClass"), NULL }, \
		    NULL, NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT), TRUE, 0, _T("") }; \
	    return wc; \
    }/* end of function GetWndClassInfo */

#define USE_MF_TOOLTIP \
STDMETHOD(GetDelayTime)(long delayType, long *pVal) {return MFGetDelayTime(delayType, pVal); } \
STDMETHOD(SetDelayTime)(long delayType, long newVal){return MFSetDelayTime(delayType, newVal); } \
STDMETHOD(get_ToolTip)(BSTR *pVal)  {return get_MFToolTip(pVal); } \
STDMETHOD(put_ToolTip)(BSTR newVal) {put_MFToolTip(newVal); return CreateToolTip(m_hWnd, m_rcPos);} \
STDMETHOD(get_ToolTipMaxWidth)(long *pVal) {return get_MFToolTipMaxWidth(pVal); } \
STDMETHOD(put_ToolTipMaxWidth)(long newVal){return put_MFToolTipMaxWidth(newVal); } \
STDMETHOD(get_ToolTipTracking)(VARIANT_BOOL *pVal)  {return get_MFTooltipTracking(pVal); } \
STDMETHOD(put_ToolTipTracking)(VARIANT_BOOL newVal) {put_MFTooltipTracking(newVal); return CreateToolTip(m_hWnd, m_rcPos);} \
HRESULT OnPostVerbInPlaceActivate() { \
    /* Return if tooltip is already created */ \
    if (m_hWndTip) return S_OK; \
    return CreateToolTip(m_hWnd, m_rcPos); \
} \

/*************************************************************************/
/* Defines                                                               */
/* Could not find these under windows headers, so if there is a conflict */
/* it is good idea to ifdef these out.                                   */
/*************************************************************************/
#define GET_X_LPARAM(lp)   ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)   ((int)(short)HIWORD(lp))

	
template <class T>
class ATL_NO_VTABLE CMSMFCntrlUtils{

/*************************************************************************/
/* PUBLIC MEMBER FUNCTIONS                                               */
/*************************************************************************/
public:

/*************************************************************************/
/* Function: CMSMFCntrlUtils                                             */
/*************************************************************************/
CMSMFCntrlUtils(){

    m_hRes = NULL;
    m_blitType = TRANSPARENT_TOP_LEFT; // DISABLE used to be the correct default TODO
    m_fNoFocusGrab = true; // to enable standalone "windowed" focus handeling please
                           // make this flag a property
    m_hCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT));

    m_hWndTip = NULL;
    m_nTTMaxWidth = 200;
    m_bTTTracking = FALSE;
    m_bTrackingActivated = FALSE;
    m_dwTTInitalDelay = 10;
    m_dwTTReshowDelay = 2;
    m_dwTTAutopopDelay = 10000;
    ::ZeroMemory(&m_toolInfo, sizeof(TOOLINFO));

}/* end of function CMSMFCntrlUtils */

/*************************************************************************/
/* Function: ~CMSMFCntrlUtils                                            */
/*************************************************************************/
virtual ~CMSMFCntrlUtils(){

    if (m_hCursor != NULL) {

        ::DestroyCursor(m_hCursor);
        m_hCursor  = NULL;
    }/* end of if statement */

    if(NULL != m_hRes){

        ::FreeLibrary(m_hRes); // unload our resource library
        m_hRes = NULL;
    }/* end of if statement */    
}/* end of function ~CMSMFCntrlUtils */

/*************************************************************************/
/* Message Map                                                           */
/*************************************************************************/  
typedef CMSMFCntrlUtils< T >	thisClass;

BEGIN_MSG_MAP(thisClass)
	MESSAGE_HANDLER(WM_ERASEBKGND, CMSMFCntrlUtils::MFOnErase)
    MESSAGE_HANDLER(WM_SETCURSOR, CMSMFCntrlUtils::MFOnSetCursor)    
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, CMSMFCntrlUtils::MFOnQueryNewPalette)
    MESSAGE_HANDLER(WM_PALETTECHANGED, CMSMFCntrlUtils::MFOnPaletteChanged)
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, CMSMFCntrlUtils::MFOnMouseToolTip)
END_MSG_MAP()

/*************************************************************************/  
/* Function: MFOnErase                                                   */
/* Description: Avoids erasing backround to avoid flashing.              */
/*************************************************************************/  
LRESULT MFOnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
	return 0;
}/* end of function MFOnErase */

/*************************************************************************/  
/* Function: MFOnSetCursor                                               */
/* Description: Sets our cursor.                                         */
/*************************************************************************/  
LRESULT MFOnSetCursor(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    ::SetCursor(m_hCursor);     
    return(TRUE);
}/* end of function MFOnSetCursor */

/*************************************************************************/
/* Function: MFOnQueryNewPalette                                         */
/* Description: Called when we are about to be instantiated.             */
/*************************************************************************/
LRESULT MFOnQueryNewPalette(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    T* pT = static_cast<T*>(this);

    if(NULL == ::IsWindow(pT->m_hWnd)){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HPALETTE hPal = CBitmap::GetSuperPal();
    
    if(NULL == hPal){

        //bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HDC hdc = ::GetDC(pT->m_hWnd);

    if(NULL == hdc){

        return FALSE;
    }/* end of if statement */

    ::SelectPalette(hdc, hPal, FALSE);
    ::RealizePalette(hdc);
    ::InvalidateRect(pT->m_hWnd, NULL, FALSE);

    ::ReleaseDC(pT->m_hWnd, hdc);
    
	return TRUE;
}/* end of function MFOnQueryNewPalette */

/*************************************************************************/
/* Function: MFOnPaletteChanged                                          */
/* Description: Called when palette is chaning.                          */
/*************************************************************************/
LRESULT MFOnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    T* pT = static_cast<T*>(this);

    if(NULL == ::IsWindow(pT->m_hWnd)){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    if((HWND) wParam == pT->m_hWnd){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HPALETTE hPal = CBitmap::GetSuperPal();

    if(NULL == hPal){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HDC hdc = ::GetDC(pT->m_hWnd);

    if(NULL == hdc){

        return FALSE;
    }/* end of if statement */

    ::SelectPalette(hdc, hPal, FALSE);
    ::RealizePalette(hdc);
    ::UpdateColors(hdc);

    ::InvalidateRect(pT->m_hWnd, NULL, FALSE);
    
    ::ReleaseDC(pT->m_hWnd, hdc);

    bHandled = FALSE;
    
	return TRUE;
}/* end of function MFOnPaletteChanged */

/*************************************************************************/
/* Function: get_MFResourceDLL                                           */
/* Description: Returns the string of the loaded resource DLL.           */
/*************************************************************************/
STDMETHOD(get_MFResourceDLL)(BSTR *pVal){

    *pVal = m_strResDLL.Copy();
	return S_OK;
}/* end of function get_MFResourceDLL */

/*************************************************************************/
/* Function: put_MFResourceDLL                                           */
/* Description: Loads the resource DLL.                                  */
/*************************************************************************/
STDMETHOD(put_MFResourceDLL)(BSTR strFileName){

	HRESULT hr = LoadResourceDLL(strFileName);

    // see if we loaded it
    if(FAILED(hr)){    

	    return(hr);
    }/* end of if statement */

    // update the cached variable value
    m_strResDLL = strFileName;

    return(hr);
}/* end of function put_MFResourceDLL */

/*************************************************************************/
/* Function: get_MFWindowless                                            */
/* Description: Gets if we we tried to be windowless activated or not.   */
/*************************************************************************/
HRESULT get_MFWindowless(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {
        T* pT = static_cast<T*>(this);

        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = pT->m_bWindowOnly == FALSE ? VARIANT_FALSE: VARIANT_TRUE; 
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function get_MFWindowless */

/*************************************************************************/
/* Function: put_MFWindowless                                            */
/* Description: This sets the windowless mode, should be set from the    */
/* property bag.                                                         */
/*************************************************************************/
HRESULT put_MFWindowless(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {
        T* pT = static_cast<T*>(this);

        if(VARIANT_FALSE == newVal){

            pT->m_bWindowOnly = TRUE; 
        }
        else {

            pT->m_bWindowOnly = FALSE; 
        }/* end of if statement */

        // TODO: This function should fail after we inplace activated !!
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function put_MFWindowless */

/*************************************************************************/
/* Function: get_MFTransparentBlit                                       */
/* Description: Gets current state of the transperent blit.              */
/*************************************************************************/
HRESULT get_MFTransparentBlit(TransparentBlitType *pVal){

    HRESULT hr = S_OK;

    try {
    	T* pT = static_cast<T*>(this);

        *pVal = pT->m_blitType;
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function get_MFTransparentBlit */

/*************************************************************************/
/* Function: put_MFTransparentBlit                                       */
/* Description: Sets the state of the transperent blit.                  */
/*************************************************************************/
HRESULT put_MFTransparentBlit(TransparentBlitType newVal){

    HRESULT hr = S_OK;

    try {    
        T* pT = static_cast<T*>(this);

        pT->m_blitType = newVal;
    }
     catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function put_MFTransparentBlit */

/*************************************************************************/
/* Function: MFInvalidateRgn                                             */
/* Description: Invalidates the whole rect in case we need to repaint it.*/
/*************************************************************************/
HRESULT MFInvalidateRgn(bool fErase = false){

    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess){

        pT->m_spInPlaceSite->InvalidateRgn(NULL ,fErase ? TRUE: FALSE);
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

		    ::InvalidateRgn(pT->m_hWnd, NULL, fErase ? TRUE: FALSE); // see if we can get by by not erasing..
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function MFInvalidateRgn */

/*************************************************************************/
/* Function: MFFireViewChange                                            */
/* Description: Overloaded base function, which would try to repaint the */
/* whole container. Just like to repaint the control area instead.       */
/*************************************************************************/
inline HRESULT MFFireViewChange(){ // same as FireView change but optimized

    T* pT = static_cast<T*>(this);

	if (pT->m_bInPlaceActive){
		// Active
        if (pT->m_hWndCD != NULL){

			::InvalidateRect(pT->m_hWndCD, NULL, FALSE); // Window based
        }
        else if (pT->m_spInPlaceSite != NULL){

			pT->m_spInPlaceSite->InvalidateRect(&pT->m_rcPos, FALSE); // Do not invalidate the whole container
        }/* end of if statement */
	}
    else {// Inactive
		pT->SendOnViewChange(DVASPECT_CONTENT);
    }/* end of if statement */

	return S_OK;
}/* end of function MFFireViewChange */

/*************************************************************************/
/* Function: MFForwardWindowMessage                                      */
/* Description: Forward the message to the parent window.                */
/*************************************************************************/
HRESULT MFForwardWindowMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LONG& lRes,
                               bool fForwardInWndls = false){

    HRESULT hr = S_OK;
    T* pT = static_cast<T*>(this);
    lRes = 0;

    if(false == fForwardInWndls){

        if(pT->m_bWndLess || (!::IsWindow(pT->m_hWnd))){

            hr = S_FALSE;
            return (hr);
        }/* end of if statement */

    }/*  end of if statement */

    HWND hwnd = NULL;

    hr = GetParentHWND(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    lRes = (LONG)::SendMessage(hwnd, uMsg, wParam, lParam);

    return(hr);
}/* end of function MFForwardWindowMessage */

/*************************************************************************/
/* Function: InPlaceActivate                                             */
/* Description: Modified InPlaceActivate so WMP can startup.             */
/*************************************************************************/
HRESULT MFInPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/){

    HRESULT hr;
    T* pT = static_cast<T*>(this);

    if (pT->m_spClientSite == NULL){

        return S_OK;
    }/* end of if statement */

    CComPtr<IOleInPlaceObject> pIPO;
    pT->ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
    ATLASSERT(pIPO != NULL);

    if (!pT->m_bNegotiatedWnd){

        if (!pT->m_bWindowOnly)
            // Try for windowless site
            hr = pT->m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&pT->m_spInPlaceSite);

        if (pT->m_spInPlaceSite){

            pT->m_bInPlaceSiteEx = TRUE;
            // CanWindowlessActivate returns S_OK or S_FALSE
            if ( pT->m_spInPlaceSite->CanWindowlessActivate() == S_OK ){

                pT->m_bWndLess = TRUE;
                pT->m_bWasOnceWindowless = TRUE;
            }
            else
            {
                pT->m_bWndLess = FALSE;
            }/* end of if statement */
        }
        else {
            pT->m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pT->m_spInPlaceSite);
            if (pT->m_spInPlaceSite)
                pT->m_bInPlaceSiteEx = TRUE;
            else
                hr = pT->m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&pT->m_spInPlaceSite);
        }/* end of if statement */
    }/* end of if statement */

    ATLASSERT(pT->m_spInPlaceSite);
    if (!pT->m_spInPlaceSite)
        return E_FAIL;

    pT->m_bNegotiatedWnd = TRUE;

    if (!pT->m_bInPlaceActive){

        BOOL bNoRedraw = FALSE;
        if (pT->m_bWndLess)
            pT->m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
        else {

            if (pT->m_bInPlaceSiteEx)
                pT->m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
            else {
                hr = pT->m_spInPlaceSite->CanInPlaceActivate();
                // CanInPlaceActivate returns S_FALSE or S_OK
                if (FAILED(hr))
                    return hr;
                if ( hr != S_OK )
                {
                   // CanInPlaceActivate returned S_FALSE.
                   return( E_FAIL );
                }
                pT->m_spInPlaceSite->OnInPlaceActivate();
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    pT->m_bInPlaceActive = TRUE;

    // get location in the parent window,
    // as well as some information about the parent
    //
    OLEINPLACEFRAMEINFO frameInfo;
    RECT rcPos, rcClip;
    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    HWND hwndParent;

    // DJ - GetParentHWND per MNnovak

    if (SUCCEEDED( GetParentHWND(&hwndParent) )){

        pT->m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
            &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

        if (!pT->m_bWndLess){

            if (pT->m_hWndCD){

                ::ShowWindow(pT->m_hWndCD, SW_SHOW);
                if (!::IsChild(pT->m_hWndCD, ::GetFocus()))
                    ::SetFocus(pT->m_hWndCD);
            }
            else{

                HWND h = pT->CreateControlWindow(hwndParent, rcPos);
                ATLASSERT(h != NULL);   // will assert if creation failed
                ATLASSERT(h == pT->m_hWndCD);
                h;  // avoid unused warning
            }/* end of if statement */
        }/* end of if statement */

        pIPO->SetObjectRects(&rcPos, &rcClip);
    }/* end of if statement */

    CComPtr<IOleInPlaceActiveObject> spActiveObject;
    pT->ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

    // Gone active by now, take care of UIACTIVATE
    if (pT->DoesVerbUIActivate(iVerb)){

        if (!pT->m_bUIActive){

            pT->m_bUIActive = TRUE;
            hr = pT->m_spInPlaceSite->OnUIActivate();
            if (FAILED(hr))
                return hr;

            pT->SetControlFocus(TRUE);
            // set ourselves up in the host.
            //
            if (spActiveObject)
            {
                if (spInPlaceFrame)
                    spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
                if (spInPlaceUIWindow)
                    spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
            }

            if (spInPlaceFrame)
                spInPlaceFrame->SetBorderSpace(NULL);
            if (spInPlaceUIWindow)
                spInPlaceUIWindow->SetBorderSpace(NULL);
        }/* end of if statement */
    }/* end of if statement */

    pT->m_spClientSite->ShowObject();

    return S_OK;
}/* end of function MFInPlaceActivate */

/*************************************************************************/
/* PROTECTED MEMBER FUNCTIONS                                            */
/*************************************************************************/
protected:

/*************************************************************************/
/* Function: MFGetWindow                                                 */
/* Description:  Gets the window. If we are windowless we pass           */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HWND MFGetWindow(){

  HWND hwnd = NULL;

  T* pT = static_cast<T*>(this);

  if(pT->m_bWndLess){

      GetParentHWND(&hwnd);
      return(hwnd);
  }/* end of if statement */

  //ATLASSERT(::IsWindow(m_hWnd));
  return pT->m_hWnd;
}/* end of function MFGetWindow */

/*************************************************************************/
/* Function: GetParentHWND                                               */
/* Description: Gets the parent window HWND where we are operating.      */
/*************************************************************************/
HRESULT GetParentHWND(HWND* pWnd){

    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);

    CComPtr<IOleClientSite> pClientSite;
    CComPtr<IOleContainer> pContainer;
    CComPtr<IOleObject> pObject;

    hr = pT->GetClientSite(&pClientSite);

    if(FAILED(hr)){

		return(hr);	
    }/* end of if statement */

    IOleWindow *pOleWindow;
    
    do {
        hr = pClientSite->QueryInterface(IID_IOleWindow, (LPVOID *) &pOleWindow);
        
        if(FAILED(hr)){
            
            return(hr);	
        }/* end of if statement */
        
        hr = pOleWindow->GetWindow(pWnd);
        
        // if pClientSite is windowless, go get its container
        if (FAILED(hr)) {
            HRESULT hrTemp = pClientSite->GetContainer(&pContainer);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            
            hrTemp = pContainer->QueryInterface(IID_IOleObject, (LPVOID*)&pObject);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            
            hrTemp = pObject->GetClientSite(&pClientSite);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
        }
    } while (FAILED(hr));
    
    return(hr);
}/* end of function GetParentHWND */

/*************************************************************************/
/* Function: GetCapture                                                  */
/* Description: Gets the capture state. S_FALSE no capture S_OK has      */
/* capture.                                                              */
/*************************************************************************/
HRESULT GetCapture(){

    HRESULT hr = E_UNEXPECTED;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess){

        hr = pT->m_spInPlaceSite->GetCapture();
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            HWND h = ::GetCapture();

            if(pT->m_hWnd == h){

                hr = S_OK;
            }
            else {

                hr = S_FALSE;
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function GetCapture */

/*************************************************************************/
/* Function: GetFocus                                                    */
/* Description: Gets the focus state. S_FALSE no capture S_OK has        */
/* a focus.                                                              */
/*************************************************************************/
HRESULT GetFocus(){

    HRESULT hr = E_UNEXPECTED;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess || m_fNoFocusGrab){

        hr = pT->m_spInPlaceSite->GetFocus();
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            HWND h = ::GetFocus();

            if(pT->m_hWnd == h){

                hr = S_OK;
            }
            else {

                hr = S_FALSE;
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function GetFocus */

/*************************************************************************/
/* Function: MFSetFocus                                                  */
/* Description: Sets the focus for the keyboard.                         */
/*************************************************************************/
HRESULT MFSetFocus(bool fFocus){
    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess || m_fNoFocusGrab){

        pT->m_spInPlaceSite->SetFocus(fFocus ? TRUE: FALSE);
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            if(fFocus){

		        ::SetFocus(pT->m_hWnd);
            }
            else {
                    
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function MFSetFocus */

/*************************************************************************/
/* Function: MFSetCapture                                                  */
/* Description: Sets the capture for the mouse.                          */
/*************************************************************************/
HRESULT MFSetCapture(bool bCapture){
    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess){

        pT->m_spInPlaceSite->SetCapture(bCapture ? TRUE: FALSE);
    }
    else {

#if 0
    if(bCapture){

        ATLTRACE("SETTING mouse capture! \n");
    }
    else {

        ATLTRACE("RELEASING mouse capture! \n");
    }/* end of if statement */

#endif 

        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            if(bCapture){

		        ::SetCapture(pT->m_hWnd);
            }
            else {
                    // note this might case problems if multiple ActiveX controls
                    // in the container have a capture
                if(::GetCapture() == pT->m_hWnd){

                    ::ReleaseCapture();                
                }/* end of if statement */
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function MFSetCapture */

/*************************************************************************/
/* Function: LoadResourceDLL                                             */
/* Description: The path is relative to this module exe                  */
/*************************************************************************/
HRESULT LoadResourceDLL(BSTR strResDLLName){
	
    HRESULT hr = E_UNEXPECTED;
    
    if(NULL != m_hRes){

        ::FreeLibrary(m_hRes); // unload our resource library if we had some loaded
    }/* end of if statement */

#if 0 // use relative path
     TCHAR szModule[_MAX_PATH+10];
     ::GetModuleFileName(_Module.m_hInstResource, szModule, _MAX_PATH);
        *( _tcsrchr( szModule, '\\' ) + 1 ) = TEXT('\0');


    // now attempt to load the library, since it is not ActiveX control
    USES_CONVERSION;

     _tcscat( szModule, OLE2T(strResDLLName));

    m_hRes = ::LoadLibrary(szModule);
#else 
    USES_CONVERSION;
    m_hRes = ::LoadLibrary(OLE2T(strResDLLName));
#endif
    if (!m_hRes){

        hr = HRESULT_FROM_WIN32(::GetLastError());
        ATLTRACE(TEXT("Failed to load resource DLL\n"));
    }
    else {
        hr = S_OK;
    }/* end of if statement */

    return (hr);
}/* end of function LoadResourceDLL */


/*************************************************************/
/* Name: get_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*************************************************************/
HRESULT get_MFToolTip(BSTR *pVal){

    if (!pVal) {
        return E_POINTER;
    }

	*pVal = m_bstrToolTip.Copy();
    return S_OK;

}/* end of function get_ToolTip */

/*************************************************************/
/* Name: put_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*  Cache the tooltip string if there is no window available */
/*************************************************************/
HRESULT put_MFToolTip(BSTR newVal){

    m_bstrToolTip = newVal;
    return S_OK;
}

/*************************************************************/
/* Name: get_MFTooltipTracking
/* Description: 
/*************************************************************/
HRESULT get_MFTooltipTracking(VARIANT_BOOL *pVal) {

    if (!pVal) {
        return E_POINTER;
    }

    *pVal = (m_bTTTracking==FALSE) ? VARIANT_FALSE:VARIANT_TRUE;
    return S_OK;
}

/*************************************************************/
/* Name: put_MFTooltipTracking
/* Description: 
/*************************************************************/
HRESULT put_MFTooltipTracking(VARIANT_BOOL newVal) {

    BOOL bTemp = (newVal==VARIANT_FALSE) ? FALSE:TRUE;
    if (m_bTTTracking != bTemp) {
        m_bTTTracking = bTemp;
        ::DestroyWindow(m_hWndTip);
        m_hWndTip = NULL;
    }
    m_bTrackingActivated = FALSE;
    return S_OK;
}

/*************************************************************/
/* Name: CreateToolTip
/* Description: create a tool tip for the button
/*************************************************************/
HRESULT CreateToolTip(HWND parentWnd, RECT rc){

    HWND hwnd = MFGetWindow();
    if (!hwnd) return S_FALSE;

    if (m_bstrToolTip.Length() == 0)
        return S_FALSE;

 	USES_CONVERSION;
 
    TOOLINFO ti;    // tool information 
    ti.cbSize = sizeof(TOOLINFO);
    ti.hwnd = hwnd; 
    ti.hinst = _Module.GetModuleInstance(); 
    ti.lpszText = OLE2T(m_bstrToolTip); 
    
    // if the button is a windowed control, the tool tip is added to 
    // the button's own window, and the tool tip area should just be
    // the client rect of the window
    if (hwnd == parentWnd) {
        ::GetClientRect(hwnd, &ti.rect);
        ti.uId = (WPARAM) hwnd; 
        ti.uFlags = TTF_IDISHWND;
    }

    // otherwise the tool tip is added to the closet windowed parent of
    // the button, and the tool tip area should be the relative postion
    // of the button in the parent window
    else {
        ti.rect.left = rc.left; 
        ti.rect.top = rc.top; 
        ti.rect.right = rc.right; 
        ti.rect.bottom = rc.bottom; 
        ti.uId = (UINT) 0; 
        ti.uFlags = 0;
    }

    if (m_bTTTracking)
        ti.uFlags |= TTF_TRACK; 

    // If tool tip is to be created for the first time
    if (m_hWndTip == (HWND) NULL) {
        // Ensure that the common control DLL is loaded, and create 
        // a tooltip control. 
        InitCommonControls(); 
        
        m_hWndTip = CreateWindow(TOOLTIPS_CLASS, (LPCTSTR) NULL, TTS_ALWAYSTIP, 
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
            hwnd, (HMENU) NULL, _Module.GetModuleInstance(), NULL); 
        ATLTRACE(TEXT("Tooltip %s CreateWindow\n"), OLE2T(m_bstrToolTip));
        if (m_hWndTip == (HWND) NULL) 
            return S_FALSE; 
        
        if (!::SendMessage(m_hWndTip, TTM_ADDTOOL, 0, (LPARAM)&ti)) {
            ::DestroyWindow(m_hWndTip);
            m_hWndTip = NULL;
            return S_FALSE;
        }
    }

    else {
        ::SendMessage(m_hWndTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
    }

    // Save the tooltip info
    m_toolInfo = ti;

    
    // Set initial delay time
    put_MFToolTipMaxWidth(m_nTTMaxWidth);
    MFSetDelayTime(TTDT_AUTOPOP, m_dwTTAutopopDelay); 
    MFSetDelayTime(TTDT_INITIAL, m_dwTTInitalDelay);
    MFSetDelayTime(TTDT_RESHOW, m_dwTTReshowDelay);
    return S_OK;
}/* end of function CreateToolTip */

/*************************************************************/
/* Name: GetDelayTime
/* Description: Get the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
HRESULT MFGetDelayTime(long delayType, long *pVal){

    if (!pVal) {
        return E_POINTER;
    }

    if (delayType>TTDT_INITIAL || delayType<TTDT_RESHOW) {
        return E_INVALIDARG;
    }

    // If tooltip has been created
    if (m_hWndTip) {
        *pVal = (long)::SendMessage(m_hWndTip, TTM_GETDELAYTIME, 
            (WPARAM) (DWORD) delayType, 0);
    }

    // else return cached values
    else {
        switch (delayType) {
        case TTDT_AUTOPOP:
            *pVal =  m_dwTTAutopopDelay;
            break;
        case TTDT_INITIAL:
            *pVal =  m_dwTTInitalDelay;
            break;
        case TTDT_RESHOW:
            *pVal =  m_dwTTReshowDelay;
            break;
        }
    }

	return S_OK;
}/* end of function GetDelayTime */

/*************************************************************/
/* Name: SetDelayTime
/* Description: Set the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_AUTOMATIC          0
/*              TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
HRESULT MFSetDelayTime(long delayType, long newVal){

    if (delayType>TTDT_INITIAL || delayType<TTDT_AUTOMATIC || newVal<0) {
        return E_INVALIDARG;
    }

    if (m_hWndTip) {
        if (!::SendMessage(m_hWndTip, TTM_SETDELAYTIME, 
            (WPARAM) (DWORD) delayType, 
            (LPARAM) (INT) newVal))
            return S_FALSE; 
    }

    // cache these values
    switch (delayType) {
    case TTDT_AUTOPOP:
        m_dwTTAutopopDelay = newVal;
        break;
    case TTDT_INITIAL:
        m_dwTTInitalDelay = newVal;
        break;
    case TTDT_RESHOW:
        m_dwTTReshowDelay = newVal;
        break;
    case TTDT_AUTOMATIC:
        m_dwTTInitalDelay = newVal;
        m_dwTTAutopopDelay = newVal*10;
        m_dwTTReshowDelay = newVal/5;
        break;
    }
    
	return S_OK;
}/* end of function SetDelayTime */

/*************************************************************************/
/* Function: get_ToolTipMaxWidth                                         */
/*************************************************************************/
HRESULT get_MFToolTipMaxWidth(long *pVal){

    if (!pVal)     {
        return E_POINTER;
    }

    if (m_hWndTip){

        *pVal = (long)::SendMessage(m_hWndTip, TTM_GETMAXTIPWIDTH, 0, 0);
    }/* end of if statement */

	return S_OK;
}/* end of function get_ToolTipMaxWidth */

/*************************************************************************/
/* Function: put_ToolTipMaxWidth                                         */
/*************************************************************************/
HRESULT put_MFToolTipMaxWidth(long newVal){

    if (newVal<0) {
        return E_INVALIDARG;
    }

    m_nTTMaxWidth = newVal;
    if (m_hWndTip){

        ::SendMessage(m_hWndTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)(INT) newVal);
    }/* end of if statement */

	return S_OK;
}/* end of function put_ToolTipMaxWidth */

/*************************************************************/
/* Name: UpdateTooltipRect
/* Description: 
/*************************************************************/
HRESULT UpdateTooltipRect(LPCRECT prcPos) {

    if (!m_hWndTip) return S_OK;

    HWND hwnd = MFGetWindow();
    if (!hwnd) return S_FALSE;

    m_toolInfo.rect = *prcPos;  // new tooltip position

    if (!::SendMessage(m_hWndTip, TTM_NEWTOOLRECT, 0, 
        (LPARAM) (LPTOOLINFO) &m_toolInfo)) 
        return S_FALSE; 
    
    return S_OK;
} /* end of function UpdateTooltipRect */

/*************************************************************************/
/* Function: MFOnMouseToolTip                                              */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT MFOnMouseToolTip(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

#define X_OFFSET 15
#define Y_OFFSET X_OFFSET

    MSG mssg;
    mssg.hwnd = MFGetWindow();
    ATLASSERT(mssg.hwnd);
    mssg.message = msg;
    mssg.wParam = wParam;
    mssg.lParam = lParam;

    POINT pt;
    ::GetCursorPos(&pt);
    mssg.pt.x    = pt.x;
    mssg.pt.y    = pt.y;
    if (m_hWndTip) 
        ::SendMessage(m_hWndTip, TTM_RELAYEVENT, 0, (LPARAM)&mssg);

    RECT rc = m_toolInfo.rect;
    ::MapWindowPoints(m_toolInfo.hwnd, ::GetDesktopWindow(), (LPPOINT)&rc, 2);
    if (::PtInRect(&rc, pt)) {
        if (m_hWndTip) {
            
            if (m_bTTTracking) {
                ::SendMessage(m_hWndTip, TTM_TRACKPOSITION, 0, (LPARAM)MAKELPARAM(X_OFFSET+pt.x, Y_OFFSET+pt.y));

                // Activate tracking if not yet
                if (!m_bTrackingActivated) {
                    ::SendMessage(m_hWndTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&m_toolInfo);
                    m_bTrackingActivated = TRUE;
                }
            }
        }
    }
    bHandled = FALSE;
    return 0;
}/* end of function MFOnMouseToolTip */

// variables
protected:
    HINSTANCE m_hRes;
    HCURSOR   m_hCursor;
    CComBSTR m_strResDLL;
    TransparentBlitType m_blitType;
    bool     m_fNoFocusGrab;    // disable grabbing focus for windowed controls

    HWND m_hWndTip;             // Tooltip window
    TOOLINFO m_toolInfo;        // Tooltip info
    LONG m_nTTMaxWidth;         // Max tooltip width
    CComBSTR m_bstrToolTip;     // Tooltip string
    BOOL m_bTTTracking;         // Tracking or not
    BOOL m_bTrackingActivated;  // Tracking activated or not

    DWORD m_dwTTReshowDelay;
    DWORD m_dwTTAutopopDelay;
    DWORD m_dwTTInitalDelay;
};

#endif //__MSMFCSTUTILS_H_

/*************************************************************************/
/* End of file: CstUtils.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\ctext.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ctext.h                                                         */
/* Description: header file for class CText.                             */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/

#ifndef __CTEXT_H_
#define __CTEXT_H_

// font style flags for internal use

#define FS_NORMAL     0x00
#define FS_BOLD       0x01
#define FS_ITALIC     0x02
#define FS_UNDERLINE  0x04
#define FS_STRIKEOUT  0x08

class CText
{
public:
    CText();
    ~CText();
    void SetTextAlignment(BSTR pwszAlignment);
    void SetTextColor(COLORREF clrColor);
	void SetFontStyle(BSTR pwszFontStyle);
	void SetFontFace(BSTR pwszFontFace);
    void SetFontSize(long lSize);
    void SetFixedSizeFont(bool fFixed);

    HRESULT RealizeFont(HDC hdc);
    HRESULT Write(HDC hdc, const RECT & rc, const WCHAR * pwszText);
    HRESULT GetTextWidth(HDC hdc, const WCHAR * pwszText, SIZE *pSize);

private:    
    HFONT       m_hFont;
    bool        m_fDirty; //true when we need to recalc font and bounding rect
    UINT        m_uiState;
    CComBSTR    m_bstrFontFace;
    CComBSTR    m_bstrFontStyle;
    UINT        m_uiFontSize;
    UINT        m_uiAlignment;
    COLORREF    m_clrTextColor;
    BYTE        m_fFontStyleFlags;
    bool        m_fFixedSizeFont;
};

#endif //__CTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\eobj.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: EObj.h                                                          */
/* Description: Declaration of CEventObject, which is used to hold event */
/* descriptions.                                                         */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __EOBJ_H
#define __EOBJ_H

/*************************************************************************/
/* Class: CEventObject                                                   */
/* Description: Object that contains the events.                         */
/*************************************************************************/
class CEventObject{
public: 
    CEventObject(BSTR strObjectID, BSTR strEvent, BSTR strEventCode) :
    m_strObjectID(strObjectID), 
    m_strEvent(strEvent), 
    m_strEventCode(strEventCode){}
    
    CComBSTR m_strObjectID; 
    CComBSTR m_strEvent;
    CComBSTR m_strEventCode;
}; /* end of class CEventObject */

#endif //__EOBJ_H
/*************************************************************************/
/* End of file: EObj.h                                                   */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\ctext.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ctext.cpp                                                       */
/* Description: Implementation of ctext class for drawing text.          */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/
#include "stdafx.h"
#include "ctext.h"

/*************************************************************************/
/* Function: CText::CText()                                              */
/* Description: Initialize the properties and states.                    */
/*************************************************************************/
CText::CText()
{
    m_fDirty = true;
    m_hFont = NULL;

    //properties
    m_uiFontSize = 10;
    m_uiAlignment = TA_CENTER;
    m_clrTextColor = GetSysColor(COLOR_WINDOWTEXT);
    m_bstrFontFace = L"Arial";
    m_bstrFontStyle = L"Normal";
    m_fFontStyleFlags = FS_NORMAL;
    m_fFixedSizeFont = false;
}


/*************************************************************************/
/* Function: CText::~CText()                                             */
/* Description: Destroy the cached font.                                 */
/*************************************************************************/
CText::~CText()
{
    if (m_hFont)
    {
        ::DeleteObject(m_hFont);
        m_hFont = NULL;
    }
}


/*************************************************************************/
/* Function: Write                                                       */
/* Description: Draw text in the specified rectangle.                    */
/*   The font is not created until drawing text for the first time.      */
/*   Assume the following settings:                                      */
/*     - Use Transparent background mode; no change of bg color          */
/*     - Vertical alignment is always centered                           */
/*************************************************************************/
HRESULT CText::Write(HDC hdc, const RECT & rc, const WCHAR * pwszText)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    const int cBorderMargin = 2; // 2 pixel margin on left or right border

    // set drawing attributes, save the old ones

    UINT uiOldAlign = ::SetTextAlign(hdc, m_uiAlignment|TA_BOTTOM);
    COLORREF crOldTextColor = ::SetTextColor(hdc, m_clrTextColor);
    int iOldBkMode = ::SetBkMode(hdc, TRANSPARENT);

    // create the required font

    if (m_fDirty)
    {
        hr = RealizeFont(hdc);
    }

    HFONT hOldFont = NULL;
    if (m_hFont)
    {
        hOldFont = (HFONT) ::SelectObject(hdc, m_hFont);
    }

    // set position of text based on alignment

    TEXTMETRIC tm;
    GetTextMetrics(hdc, &tm);

    int x = (rc.left + rc.right)/2;
    if (m_uiAlignment == TA_LEFT)
    {
        x = rc.left + cBorderMargin;
    }
    else if (m_uiAlignment == TA_RIGHT)
    {
        x = rc.right - cBorderMargin;
    }

    // text is aligned at the bottom. Adding half of text height makes
    // it to position at the center vertically

    int y = (rc.top + rc.bottom)/2 + tm.tmHeight/2;

    LPCTSTR strTemp = W2CT(pwszText);
    int nLength = _tcslen(strTemp);

    if (NULL == strTemp)
    {
        hr = E_POINTER;
    }
    else
    {
        ::TextOut(hdc, x, y, strTemp, nLength);
    }

    // restore original font

    if (hOldFont)
    {
        ::SelectObject(hdc, hOldFont);
    }

    ::SetTextAlign(hdc, uiOldAlign);
    ::SetTextColor(hdc, crOldTextColor);
    ::SetBkMode(hdc, iOldBkMode);

	return hr;
}


/*************************************************************************/
/* Function: GetTextWidth                                                */
/* Description: Get the width of text string based on the current font   */
/* and settings.                                                         */
/*************************************************************************/
HRESULT CText::GetTextWidth(HDC hdc, const WCHAR * pwszText, SIZE *pSize)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    const int cBorderMargin = 2; // 2 pixel margin on left or right border

    // create the required font

    if (m_fDirty)
    {
        hr = RealizeFont(hdc);
    }

    HFONT hOldFont = NULL;
    if (m_hFont)
    {
        hOldFont = (HFONT) ::SelectObject(hdc, m_hFont);
    }

    LPCTSTR strTemp = W2CT(pwszText);
    int nLength = _tcslen(strTemp);

    if (NULL == strTemp) // guard agaist a NULL pointer
    {
        hr = E_POINTER;
    }
    else
    {
        ::GetTextExtentPoint32(hdc, strTemp, nLength, pSize);
        pSize->cx += 2*cBorderMargin;
    }

    if (hOldFont)
    {
        ::SelectObject(hdc, hOldFont);
    }

    return hr;
}

/*************************************************************************/
/* Function: RealizeFont                                                 */
/* Description: create a font based on the current font style, size etc. */
/* Cache the font.                                                       */
/*************************************************************************/
HRESULT CText::RealizeFont(HDC hdc)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    if( NULL != m_hFont)
    {
        ::DeleteObject(m_hFont);
        m_hFont = NULL;
    }

    // by default, font size changes with system font size which
    // depends on the system screen resolution

    int nPixelsPerInch = GetDeviceCaps(hdc, LOGPIXELSY);

    // if we fixed the font size, we assume always small font (96 pixels per inch)
    if (m_fFixedSizeFont)
    {
        nPixelsPerInch = 96;
    }

    int nHeight = -MulDiv(m_uiFontSize, nPixelsPerInch, 72);

    m_hFont =  ::CreateFont(
        nHeight,                    // logical height of font
        0,                          // logical average character width
        0,                          // angle of escapement
        0,                          // base-line orientation angle
        (m_fFontStyleFlags&FS_BOLD)?FW_BOLD:FW_NORMAL,// font weight
        (m_fFontStyleFlags&FS_ITALIC)?1:0,    // italic attribute flag
        (m_fFontStyleFlags&FS_UNDERLINE)?1:0, // underline attribute flag
        (m_fFontStyleFlags&FS_STRIKEOUT)?1:0, // strikeout attribute flag
        DEFAULT_CHARSET,            // character set identifier
        OUT_DEFAULT_PRECIS,         // output precision
        CLIP_DEFAULT_PRECIS,        // clipping precision
        ANTIALIASED_QUALITY,        // output quality
        DEFAULT_PITCH,              // pitch and family
        W2T(m_bstrFontFace.m_str)          // pointer to typeface name string
    );

    if( NULL == m_hFont )
    {
        DWORD dwErr;
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    
    m_fDirty = false;

    return hr;
}


/*************************************************************************/
/* Function: SetFontSize                                                 */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
void CText::SetFontSize(long lSize)
{
    if ((UINT)lSize != m_uiFontSize)
    {
        m_uiFontSize = (UINT)lSize;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFixedSizeFont                                            */
/* Description: set flag which indicates whether the font size is fixed  */
/*   or variable with system font.                                       */
/*************************************************************************/
void CText::SetFixedSizeFont(bool fFixed)
{
    if (fFixed != m_fFixedSizeFont)
    {
        m_fFixedSizeFont = fFixed;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFontFace                                                 */
/* Description: set the FontFace property.                               */
/*************************************************************************/
void CText::SetFontFace(BSTR pwszFontFace)
{
    if (_wcsicmp(m_bstrFontFace, pwszFontFace) != 0)
    {
        m_bstrFontFace = pwszFontFace;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFontStyle                                                */
/* Description: set the FontStyle property. The style string should      */
/* contain either "Normal", or concatenation of one or more strings of:  */
/* "Bold", "Italic", "Underline", "Strikeout". Default is "Normal".      */
/*************************************************************************/
void CText::SetFontStyle(BSTR pwszFontStyle)
{
    BYTE fFontStyleFlags = FS_NORMAL;

    //find a match
    if( NULL != wcsstr(pwszFontStyle, L"Normal"))
    {
        fFontStyleFlags = FS_NORMAL;
    }
    else
    {
        // Turn on all styles that match
        if( NULL != wcsstr(pwszFontStyle, L"Bold"))
        {
            fFontStyleFlags |= FS_BOLD;
        }

        if( NULL != wcsstr(pwszFontStyle, L"Italic"))
        {
            fFontStyleFlags |= FS_ITALIC;
        }

        if( NULL != wcsstr(pwszFontStyle, L"Underline"))
        {
            fFontStyleFlags |= FS_UNDERLINE;
        }

        if( NULL != wcsstr(pwszFontStyle, L"Strikeout"))
        {
            fFontStyleFlags |= FS_STRIKEOUT;
        }
    }

    if (fFontStyleFlags != m_fFontStyleFlags)
    {
        m_fFontStyleFlags = fFontStyleFlags;
        m_bstrFontStyle = pwszFontStyle;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFontSize                                                 */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
void CText::SetTextColor(COLORREF clrColor)
{
    if (clrColor != m_clrTextColor)
    {
        m_clrTextColor = clrColor;
    }
}


/*************************************************************************/
/* Function: SetTextAlignment                                            */
/* Description: set the TextAlignment property. It controls the          */
/* horizontal text alignment. Must be one of "Left", "Center", or        */
/* "Right". Default is "Center".                                         */
/*************************************************************************/
void CText::SetTextAlignment(BSTR pwszAlignment)
{
    UINT uiAlignment = 0;

    //set the text alignment
    if (!_wcsicmp(pwszAlignment, L"Right"))
    {
        uiAlignment = TA_RIGHT;
    }
    else if (!_wcsicmp(pwszAlignment, L"Center"))
    {
        uiAlignment = TA_CENTER;
    }
    else if (!_wcsicmp(pwszAlignment, L"Left"))
    {
        uiAlignment = TA_LEFT;
    }

    if (m_uiAlignment != uiAlignment)
    {
        m_uiAlignment = uiAlignment;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\mfbar.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MFBar.cpp                                                       */
/* Description: Control that is scriptable and contains other controls.  */
/* Designed specifically for DVD/TV control plates.                      */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MFBar.h"
#include "ccobj.h"
#include "eobj.h"
#include "CBitmap.h"
#include "HtmlHelp.h"

/*************************************************************************/
/* Local defines                                                         */
/* Could not find these under windows headers, so if there is a conflict */
/* it is good idea to ifdef these out.                                   */
/*************************************************************************/
#define GET_X_LPARAM(lp)   ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)   ((int)(short)HIWORD(lp))
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)
#define ID_EV_TIMER         0xff
#define  VK_LEFT           0x25
#define  VK_UP             0x26
#define  VK_RIGHT          0x27
#define  VK_DOWN           0x28
#define  VK_SELECT         0x29
#define  VK_SPACE          0x20
#define  VK_RETURN         0x0D
#define  SYS_MOVE_SIZE      8
#define  SYS_TITLEBAR_WIDTH 25

/*************************************************************************/
/* Windows defines not present, remove when doing the real BUILD.        */
/*************************************************************************/
typedef WINUSERAPI BOOL ( WINAPI * SETLAYEREDWINDATR)(
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
#if 0
#define LWA_COLORKEY            0x00000001
#endif
/*************************************************************************/
/* Local functions                                                       */
/*************************************************************************/
inline long MAX(long l1, long l2){return(l1 > l2 ? l1 : l2);}
inline long MIN(long l1, long l2){return(l1 < l2 ? l1 : l2);}

/*************************************************************************/
/* Statics for window class info                                         */
/*************************************************************************/
HICON CMFBar::m_hIcon = NULL;
#if 0
HICON CMFBar::m_hIconSmall = NULL;
#endif

/*****************************************************************/
/* change this depending if the file was saved as Unicode or not */
/*****************************************************************/
#define _UNICODE_SCRIPT_FILE 
//#define _UNICODE_TEST_SCRIPT_FILE 

#if WINVER < 0x0500
#define MNS_NOCHECK         0x80000000
#define MNS_MODELESS        0x40000000
#define MNS_DRAGDROP        0x20000000
#define MNS_AUTODISMISS     0x10000000
#define MNS_NOTIFYBYPOS     0x08000000
#define MNS_CHECKORBMP      0x04000000

#define MIM_MAXHEIGHT               0x00000001
#define MIM_BACKGROUND              0x00000002
#define MIM_HELPID                  0x00000004
#define MIM_MENUDATA                0x00000008
#define MIM_STYLE                   0x00000010
#define MIM_APPLYTOSUBMENUS         0x80000000

typedef struct tagMENUINFO
{
    DWORD   cbSize;
    DWORD   fMask;
    DWORD   dwStyle;
    UINT    cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    ULONG_PTR dwMenuData;
}   MENUINFO, FAR *LPMENUINFO;
typedef MENUINFO CONST FAR *LPCMENUINFO;

static BOOL (WINAPI *pfnGetMenuInfo)(HMENU, LPMENUINFO);
static BOOL (WINAPI *pfnSetMenuInfo)(HMENU, LPCMENUINFO);
typedef BOOL (WINAPI *PFNGETMENUINFOHANDLE)(HMENU, LPMENUINFO);
typedef BOOL (WINAPI *PFNSETMENUINFOHANDLE)(HMENU, LPCMENUINFO);

HRESULT CallGetMenuInfo(HMENU hMenu, LPMENUINFO pmInfo)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstDll = ::LoadLibrary(TEXT("USER32.DLL"));

    if (hinstDll)
    {
        pfnGetMenuInfo = (PFNGETMENUINFOHANDLE)GetProcAddress(hinstDll, "GetMenuInfo");

        if (pfnGetMenuInfo)
        {
            hr = pfnGetMenuInfo(hMenu, pmInfo);
        }

        FreeLibrary(hinstDll);
    }

    return hr;
}

HRESULT CallSetMenuInfo(HMENU hMenu, LPCMENUINFO pmInfo)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstDll = ::LoadLibrary(TEXT("USER32.DLL"));

    if (hinstDll)
    {
        pfnSetMenuInfo = (PFNSETMENUINFOHANDLE)GetProcAddress(hinstDll, "SetMenuInfo");

        if (pfnSetMenuInfo)
        {
            hr = pfnSetMenuInfo(hMenu, pmInfo);
        }

        FreeLibrary(hinstDll);
    }

    return hr;
}

#define MIIM_STRING      0x00000040
#define MIIM_BITMAP      0x00000080
#define MIIM_FTYPE       0x00000100
#define HBMMENU_POPUP_CLOSE         ((HBITMAP)  8)
#define HBMMENU_POPUP_RESTORE       ((HBITMAP)  9)
#define HBMMENU_POPUP_MAXIMIZE      ((HBITMAP) 10)
#define HBMMENU_POPUP_MINIMIZE      ((HBITMAP) 11)

typedef struct tagMENUITEMINFOAInternal
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT     fState;        // used if MIIM_STATE
    UINT     wID;           // used if MIIM_ID
    HMENU    hSubMenu;      // used if MIIM_SUBMENU
    HBITMAP  hbmpChecked;   // used if MIIM_CHECKMARKS
    HBITMAP  hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData;   // used if MIIM_DATA
    LPSTR    dwTypeData;    // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT     cch;           // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    HBITMAP  hbmpItem;      // used if MIIM_BITMAP
}   MENUITEMINFOAInternal, FAR *LPMENUITEMINFOAInternal;
typedef struct tagMENUITEMINFOWInternal
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT     fState;        // used if MIIM_STATE
    UINT     wID;           // used if MIIM_ID
    HMENU    hSubMenu;      // used if MIIM_SUBMENU
    HBITMAP  hbmpChecked;   // used if MIIM_CHECKMARKS
    HBITMAP  hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData;   // used if MIIM_DATA
    LPWSTR   dwTypeData;    // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT     cch;           // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    HBITMAP  hbmpItem;      // used if MIIM_BITMAP
}   MENUITEMINFOWInternal, FAR *LPMENUITEMINFOWInternal;

#ifdef UNICODE
typedef MENUITEMINFOWInternal MENUITEMINFOInternal;
typedef LPMENUITEMINFOWInternal LPMENUITEMINFOInternal;
#else
typedef MENUITEMINFOAInternal MENUITEMINFOInternal;
typedef LPMENUITEMINFOAInternal LPMENUITEMINFOInternal;
#endif // UNICODE

typedef MENUITEMINFOAInternal CONST FAR *LPCMENUITEMINFOAInternal;
typedef MENUITEMINFOWInternal CONST FAR *LPCMENUITEMINFOWInternal;

#ifdef UNICODE
typedef LPCMENUITEMINFOWInternal LPCMENUITEMINFOInternal;
#else
typedef LPCMENUITEMINFOAInternal LPCMENUITEMINFOInternal;
#endif // UNICODE
#endif /* WINVER < 0x0500 */


/*************************************************************************/
/* CMFBar Implementation                                                 */
/*************************************************************************/

/*************************************************************************/
/* Function:  Init                                                       */
/* Description: Initializes memeber variables.                           */
/*************************************************************************/
HRESULT CMFBar::Init(){

    HRESULT hr = S_OK;

// ####  BEGIN CONTAINER SUPPORT ####
    m_bCanWindowlessActivate = true;
// ####  END CONTAINER SUPPORT ####
    
#if 1 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
#endif
    m_fSelfHosted = false;

    // TODO: Investigate if it works in pallete mode
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    m_lMinWidth = -1;  // disable it 
    m_lMinHeight = -1;  // disable it by default
    m_fHandleHelp = false;
    m_blitType = DISABLE;
    m_bMouseDown = false;

    m_nReadyState = READYSTATE_LOADING;        
    m_fAutoLoad = VARIANT_TRUE;
    m_pBackBitmap = NULL;
    m_fForceKey = false;
    m_lTimeout = 0;
    m_fUserActivity = false;
    m_fWaitingForActivity = false;

    // setup the default resource DLL to be this binary
    m_hRes = _Module.m_hInstResource; // set the resource DLL Name
    TCHAR szModule[_MAX_PATH+10];
    ::GetModuleFileName(m_hRes, szModule, _MAX_PATH);

    USES_CONVERSION;
    m_strResDLL = T2OLE(szModule);

    if(NULL == m_hIcon){

         m_hIcon = ::LoadIcon(m_hRes, MAKEINTRESOURCE(IDI_ICON1));
    }/* end of if statement */
#if 0
    if(NULL == m_hIconSmall){

         m_hIconSmall = (HICON)::LoadImage(m_hRes, MAKEINTRESOURCE(IDI_ICON1), IMAGE_ICON, 
             ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);
    }/* end of if statement */
#endif    
    m_HitRegion = NOHIT; // Initialize the hit region

    m_hMenu = NULL;
    m_bSysMenuOn = FALSE;
    m_bHandleEnter = FALSE;
    m_hCursor = NULL;
    m_hinstHelpDll = NULL;

    ::ZeroMemory(&m_rcWnd, sizeof(RECT));
    ::ZeroMemory(&m_rcWndOld, sizeof(RECT));
    ::ZeroMemory(&m_ptMouse, sizeof(POINT));
    ::ZeroMemory(&m_ptMouseOld, sizeof(POINT));

    m_bHandleUserFocus = TRUE;

    return(hr);
}/* end of function Init */

/*************************************************************************/
/* Function: Cleanup                                                     */
/* Description: Makes sure the script engine is released. Also cleans    */
/* up the contained objects in the containers.                           */
/*************************************************************************/
HRESULT CMFBar::Cleanup(){

  // Release the language engine, since it may hold on to us
    HRESULT hr = S_OK;

    try {
        if (m_psp){

            m_psp.Release();
        }/* end of if statement */

        if (m_ps){

            m_ps->Close();
            m_ps.Release();
        }/* end of if statement */

        // Reset the Active Object
        m_spActiveObject.Release();

        // cleanup the event list    
        for(CNTEVNT::iterator i = m_cntEvnt.begin(); false == m_cntEvnt.empty(); ){        

            CEventObject* pObj = (*i);
            delete pObj;
            i = m_cntEvnt.erase(i);
        }/* end of if statement */
    
        CHostedObject* pSelfObj = NULL;
        CContainerObject* pSelfContainer = NULL;

        // cleanup the object list    
        for(CNTOBJ::iterator j = m_cntObj.begin(); false == m_cntObj.empty(); ){        

            CHostedObject* pObj = (*j);
            CContainerObject* pContainerObj;
            HRESULT hrCont = pObj->GetContainerObject(&pContainerObj);
                       
    #ifdef _DEBUG
            CComBSTR strOBJID = pObj->GetID();
    #endif

    #if 1
            if(pObj->GetUnknown() != GetUnknown()){

                try {

                    delete pObj; // do not delete our self at the moment
                }
                catch(...){
    #if _DEBUG
                    USES_CONVERSION;
                    ATLTRACE(TEXT(" Failed to destroy %s "), OLE2T(strOBJID));                    
    #endif
                }/* end of catch statement */
            }
            else {

                pSelfObj = pObj;                
            }/* end of if statement */
    #endif

            
    #if 1
            if(pObj->GetUnknown() != GetUnknown()){

                try {

                    delete pContainerObj; // do not delete our self at the moment
                }
                catch(...){
    #if _DEBUG
                    USES_CONVERSION;
                    ATLTRACE(TEXT(" Failed to destroy wrapper for %s "), OLE2T(strOBJID));                    
    #endif
                }/* end of catch statement */
            }
            else {

                pSelfContainer = pContainerObj;                
            }/* end of if statement */
    #endif
    
            j = m_cntObj.erase(j);
        }/* end of if statement */

        ResetFocusArray();

        try {

            delete pSelfObj;
            delete pSelfContainer;
        }
        catch(...){

            ATLTRACE(TEXT(" The container failed to destroy it self properly"));                    
        }/* end of if statemnent */

        if(m_pBackBitmap){

            delete m_pBackBitmap;
            m_pBackBitmap = NULL;
        }/* end of if statement */

        CBitmap::FinalRelease(); // cleanup the mosaic if present

        if (m_hMenu) {
            ::DestroyMenu(m_hMenu);
            m_hMenu = NULL;
        }

        if (m_hCursor) {
            ::DestroyCursor(m_hCursor);
            m_hCursor = NULL;
        }

        hr = Init();

        if (m_hIcon) {
            ::DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }/* end of if statement */

#if 0
        if (m_hIconSmall) {
            ::DestroyIcon(m_hIconSmall);
            m_hIconSmall = NULL;
        }/* end of if statement */
#endif
        if(m_hinstHelpDll){

            ::FreeLibrary(m_hinstHelpDll);
        }/* end of if statement */

    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return (hr);
}/* end of function Cleanup */

/*************************************************************************/
/* Function:  ~CMFBar                                                    */
/*************************************************************************/
CMFBar::~CMFBar(){

    Cleanup();
    ATLTRACE(TEXT("Exiting CMFBar destructor! \n"));
}/* end of function  ~CMFBar */

/*************************************************************************/
/* Message handling.                                                     */
/*************************************************************************/

/*************************************************************************/
/* Function: OnPaint                                                     */
/* Description: Had to overwrite the the deafult OnPaint so I could      */
/* somehow get the real update rects.                                    */
/*************************************************************************/
LRESULT CMFBar::OnPaint(UINT /* uMsg */, WPARAM wParam,
	LPARAM /* lParam */, BOOL& /* lResult */){

	RECT rc;
	PAINTSTRUCT ps;

	HDC hdc = (wParam != NULL) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);
	if (hdc == NULL)
		return 0;
	::GetClientRect(m_hWndCD, &rc);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.hdcDraw = hdc;
    // DJ change here, keep the real update rect from the PAINTSTRUCT
    // Set the window size to the size of the window
    di.prcWBounds = (LPCRECTL)&rc; 
    di.prcBounds = (LPCRECTL)&ps.rcPaint; 

	OnDrawAdvanced(di); // Eventually propagates to OnDraw
	if (wParam == NULL)
		::EndPaint(m_hWndCD, &ps);
	return 0; 
}/* end of function OnPaint */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Just Draws the rectangular background and contained      */
/* windowless controls.                                                  */
/*************************************************************************/
HRESULT CMFBar::OnDraw(ATL_DRAWINFO& di){

    try {
        HDC hdc = di.hdcDraw;

        RECT rcClient = *(RECT*)di.prcBounds;        
        RECT rcWClient = *(RECT*)di.prcWBounds;           

        // this might not work if you overlapp the controls
        // controls like to be painted as a whole so if
        // we need to update the are that contains the control
        // we need to find all the controls that intersect it, combine the
        // rectangle and then repaint the whole region
        if(::IsWindow(m_hWnd)){

            if(!::EqualRect(&rcClient, &rcWClient)){

                RECT rcNewClient = rcClient; // the original update are which we are enlarging
                for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
                    // iterate through all the contained objects and draw them
                    CHostedObject* pObj = (*i);
                       
                    if((NULL != pObj) && (pObj->IsActive())){

                        if(pObj->IsWindowless()){
                        
                            RECT rcCntrl;
                            pObj->GetPos(&rcCntrl); // get the position of the object

                            RECT rcInt;
                            if(!::IntersectRect(&rcInt, &rcCntrl, &rcClient)){

                                continue;
                            }
                            else {
                                // OK we need to add this control rect to our rect union
                                ::UnionRect(&rcNewClient, &rcClient, &rcCntrl);
                            }/* end of if statement */                                                  
		                }/* end of if statement */
                    }/* end of if statement */
                }/* end of for loop */

                rcClient = rcNewClient; // update our are with enlarged client
            }/* end of if statement */
            // else if the rects are the same we are updating the whole
            // window so there is no point to do the calculations
        }/* end of if statement */

        COLORREF clr;
        HPALETTE hPal = NULL;
        
        if(m_pBackBitmap){
                        
            hPal = CBitmap::GetSuperPal();
            m_pBackBitmap->SelectRelizePalette(hdc, hPal);            
        }/* end of if statement */
        
        ::OleTranslateColor (m_clrBackColor, hPal, &clr);        
     
        // fill in the background and get ready to fill in the objects
        LONG lBmpWidth = RECTWIDTH(&rcWClient);
        LONG lBmpHeight = RECTHEIGHT(&rcWClient);

        HBITMAP hBitmap = ::CreateCompatibleBitmap(hdc, lBmpWidth, lBmpHeight);

        if(NULL == hBitmap){

            ATLASSERT(FALSE);
            return(0);
        }/* end of if statement */

	    HDC hdcCompatible = ::CreateCompatibleDC(hdc);

        if(NULL == hdcCompatible){

            ATLASSERT(FALSE);
            ::DeleteObject(hBitmap);
            return(0);
        }/* end of if statement */

        // Draw background on the faceplate bitmap
        ::SelectObject(hdcCompatible, hBitmap); 
        
        if (!m_pBackBitmap){
            // fill background of specific color
            HBRUSH hbrBack = ::CreateSolidBrush(clr);            

            if(NULL == hbrBack){

                ATLASSERT(FALSE);
                ::DeleteObject(hBitmap);
                return(0);
            }/* end of if statement */

            //::FillRect(hdc, &rcClient, hbrBack);
            ::FillRect(hdcCompatible, &rcClient, hbrBack);
            ::DeleteObject(hbrBack);
        }
        else {
            m_pBackBitmap->SelectRelizePalette(hdcCompatible, hPal);

            //BOOL bRet = m_pBackBitmap->PaintTransparentDIB(hdc, &rcWClient, &rcClient, m_blitType, true);
            BOOL bRet = m_pBackBitmap->PaintTransparentDIB(hdcCompatible, &rcWClient, &rcClient);
            
            if(!bRet){
                
                ATLTRACE(TEXT(" The transparent Blit did not work!"));
            }/* end of if statement */
        }/* end of if statement */
        
        for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained objects and draw them
            CHostedObject* pObj = (*i);

            CComPtr<IViewObjectEx> pViewObject = NULL;
        
            if((NULL != pObj) && (pObj->IsActive()) && (SUCCEEDED(pObj->GetViewObject(&pViewObject)))){

                if(pObj->IsWindowless()){

                    if(pViewObject){

                        if(GetUnknown() == pObj->GetUnknown()){
                            // in case we are windowless and we are trying to draw our self again
                            continue;
                        }/* end of if statement */                    
                        
                        RECT rcCntrl;
                        pObj->GetPos(&rcCntrl);

                        RECT rcInt;
                        if(!::IntersectRect(&rcInt, &rcCntrl, &rcClient)){

                            continue;
                        }/* end of if statement */
                        
                        LONG lBmpWidth = RECTWIDTH(&rcCntrl);
                        LONG lBmpHeight = RECTHEIGHT(&rcCntrl);
                        RECT rcCntrlBitmap = {0, 0, lBmpWidth, lBmpHeight};

                        POINT ptNewOffset = {rcCntrl.left, rcCntrl.top};
                        
                        POINT ptOldOffset;

                        ::GetViewportOrgEx(hdcCompatible, &ptOldOffset);
                        LPtoDP(hdcCompatible, &ptNewOffset, 1);
                        // offset the rect we are catually going to draw
                        //::OffsetRect(&rcInt, -ptNewOffset.x, -ptNewOffset.y);
                        // offset the DC
                        ::OffsetViewportOrgEx(hdcCompatible, ptNewOffset.x, ptNewOffset.y, &ptOldOffset);
                        
                       // draw
                        ATLTRACE2(atlTraceWindowing, 31, TEXT("Drawing CONTROL into rcClient.left = %d, rcClient.right = %d, rcClient.bottom =%d, rcClient.top = %d\n"),rcCntrl.left, rcCntrl.right, rcCntrl.bottom, rcCntrl.top); 
#if 1    // used to redraw the whole control, now we are just doinf part of it
                        //HRGN hrgnOld = NULL;
                        //HRGN hrgnNew = NULL;
                        //if(::IsWindow(m_hWnd)){
                        //
                        //    hrgnNew = ::CreateRectRgnIndirect(&rcInt);
                        //    hrgnOld = (HRGN)::SelectObject(hdc, hrgnNew);                            
                        //}/* end of if statement */

			            pViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&rcCntrlBitmap, (RECTL*)&rcCntrlBitmap, NULL, NULL); 
#else
                        pViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&rcInt, (RECTL*)&rcCntrlBitmap, NULL, NULL); 
#endif                       
                        ::SetViewportOrgEx(hdcCompatible, ptOldOffset.x, ptOldOffset.y, NULL);
                    }
    #ifdef _DEBUG
                    else {

                        ATLTRACE2(atlTraceWindowing, 30,TEXT("FAILED Drawing the object since pView is NULL\n"));              
                    }/* end of if statement */
    #endif                                    
		        }/* end of if statement */
            }/* end of if statement */
        }/* end of for loop */

        ::BitBlt(hdc, rcClient.left, rcClient.top, lBmpWidth, lBmpHeight,  hdcCompatible, rcClient.left, rcClient.top, SRCCOPY);             
        // cleanup
        ::DeleteDC(hdcCompatible);        
        ::DeleteObject(hBitmap);        
                
        return(1);       
    }/* end of try statement */
    catch(...){
        return(0);
    }/* end of catch statement */
}/* end of function OnDraw */

/*************************************************************************/
/* Function: OnErase                                                     */
/* Description: Skip the erasing to avoid flickers.                      */
/*************************************************************************/
LRESULT CMFBar::OnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLTRACE2(atlTraceWindowing, 32, TEXT("Received WM_ERASE MESSAGE \n")); 

#if 0
    POINT pt; pt.x =0; pt.y = 0;
    ::MapWindowPoints(m_hWnd, hWndPar, &pt, 1);
    ::OffsetWindowOrgEx(hdc, pt.x, pt.y, &pt);        
    ::SendMessage(hWndPar, WM_ERASEBKGND, (WPARAM) hdc, 0);
    ::SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
    
#endif

    //InvalidateRect(&m_rcPos, FALSE);

    bHandled = TRUE;
	return 1;
}/* end of function OnErase */

/*************************************************************************/
/* Function: OnClose                                                     */
/* Description: Skip the erasing to avoid flickers.                      */
/*************************************************************************/
LRESULT CMFBar::OnClose(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if(::IsWindow(m_hWnd)){

        ::DestroyWindow(m_hWnd);
    }/* end of if statement */

    HRESULT hr = Close(OLECLOSE_SAVEIFDIRTY);
    ATLTRACE(TEXT("Closing \n"));

    if(SUCCEEDED(hr)){

        bHandled = TRUE;
    }/* end of if statement */
    
    return 0;
}/* end of function OnClose */

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
LRESULT CMFBar::OnActivate(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {

    switch (LOWORD(wParam)) {
    case WA_ACTIVE:
    case WA_CLICKACTIVE:
        Fire_OnActivate(VARIANT_TRUE);
        break;
    case WA_INACTIVE:
        Fire_OnActivate(VARIANT_FALSE);
        break;
    }
    return 0;
}

/*************************************************************************/
/* Function: OnSysCommand                                                */
/* Description: Handles the on syscommand.                               */
/*************************************************************************/
LRESULT CMFBar::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLTRACE2(atlTraceWindowing, 20, TEXT("Received WM_SYSCOMMAND MESSAGE \n")); 
    LRESULT lRet = 0;

    switch (wParam) {
    case SC_CONTEXTHELP :
        m_fHandleHelp = true;
        bHandled = FALSE;
        lRet = 1;
        break;

    case SC_RESTORE:
    case SC_MOVE:
    case SC_SIZE:
    case SC_MINIMIZE:
    case SC_MAXIMIZE:
    case SC_CLOSE:
        OnCommand(WM_COMMAND, wParam, lParam, bHandled);
        bHandled = TRUE;
        lRet = 0;
        break;
    
    default:
        bHandled = FALSE;
        return ::DefWindowProc(m_hWnd, uMsg, wParam, lParam);
    }
    
    return(lRet);    
}/* end of function OnSysCommand */

/*************************************************************************/
/* Function: OnCommand                                                   */
/* Description: Handles the on command.                                  */
/*************************************************************************/
LRESULT CMFBar::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLTRACE2(atlTraceWindowing, 20, TEXT("Received WM_COMMAND MESSAGE \n")); 
    LRESULT lRet = 0;

    if (NULL == m_hMenu)
        return lRet;

    switch (LOWORD(wParam)) {
    case ID_SYSTEMMENU_RESTORE:
    case SC_RESTORE:
        ShowSelfSite(SW_RESTORE);
        break;

    case ID_SYSTEMMENU_MOVE: 
    case SC_MOVE: {

        // Save window size and position
        ::GetWindowRect(m_hWnd, &m_rcWndOld);
        ::GetCursorPos(&m_ptMouseOld);
        
        RECT rc;
        ::GetClientRect(m_hWnd, &rc);
        POINT point = {(rc.left+rc.right)/2, rc.top + SYS_TITLEBAR_WIDTH/2};

        POINT screenPt = point;        
        ::ClientToScreen(m_hWnd, &screenPt);

        RECT rcDeskt;
        ::GetWindowRect(::GetDesktopWindow(), &rcDeskt);

        LONG lx = LONG((FLOAT)screenPt.x/ RECTWIDTH(&rcDeskt) * 0xFFFF);
        LONG ly = LONG((FLOAT)screenPt.y/ RECTHEIGHT(&rcDeskt) * 0xFFFF);
        
        mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, lx, ly, 0, 0);
        m_HitRegion = PREMOVE;
        UpdateCursor(m_HitRegion);
        
        m_bHandleEnter = TRUE;
        break;
        }                          

    case ID_SYSTEMMENU_SIZE:
    case SC_SIZE: {

        // Save window size and position
        ::GetWindowRect(m_hWnd, &m_rcWndOld);
        ::GetCursorPos(&m_ptMouseOld);
        
        RECT rc;
        ::GetClientRect(m_hWnd, &rc);
        POINT point = {rc.right/2, rc.bottom/2};

        POINT screenPt = point;        
        ::ClientToScreen(m_hWnd, &screenPt);

        RECT rcDeskt;
        ::GetWindowRect(::GetDesktopWindow(), &rcDeskt);

        LONG lx = LONG((FLOAT)screenPt.x/ RECTWIDTH(&rcDeskt) * 0xFFFF);
        LONG ly = LONG((FLOAT)screenPt.y/ RECTHEIGHT(&rcDeskt) * 0xFFFF);
        
        mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, lx, ly, 0, 0);
        m_HitRegion = PRESIZE;
        UpdateCursor(m_HitRegion);
        
        m_bHandleEnter = TRUE;
        break;
        }                          

    case ID_SYSTEMMENU_MINIMIZE:
    case SC_MINIMIZE:
        ShowSelfSite(SW_MINIMIZE);
        break;

    case ID_SYSTEMMENU_MAXIMIZE:
    case SC_MAXIMIZE:
        ShowSelfSite(SW_MAXIMIZE);
        break;

    case ID_SYSTEMMENU_CLOSE:
    case SC_CLOSE:
        OnClose(WM_CLOSE, wParam, lParam, bHandled);
        break;

    default:
        bHandled = FALSE;
        return ::DefWindowProc(m_hWnd, uMsg, wParam, lParam);
    }

    m_bSysMenuOn = FALSE;
    return(lRet);    
}/* end of function OnCommand */

/*************************************************************************/
/* Function: OnTimer                                                     */
/* Description: Handles the timer message.                               */
/*************************************************************************/
LRESULT CMFBar::OnTimer(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    WPARAM wTimerID = wParam;

    if(ID_EV_TIMER == wTimerID){

        if(false == m_fUserActivity && false == m_fWaitingForActivity){

            // If system menu is on, do not time out
            if (!m_bSysMenuOn) {
                
                // fire message that there is no activity going on 
                m_fWaitingForActivity = true;
                Fire_ActivityDeclined();
            }
        }/* end of if statement */

        m_fUserActivity = false; // reset the flag
    } 
    else {

        if(::IsWindow(m_hWnd)){

            ::KillTimer(m_hWnd, wTimerID);
        }/* end of if statement */

        Fire_Timeout(wTimerID);        
    }/* end of if statement */
    
    bHandled = TRUE;
    return(1);    
}/* end of function OnTimer */

/*************************************************************************/
/* Function: OnCaptureChanged                                            */
/* Description: Handles the on syscommand.                               */
/*************************************************************************/
LRESULT CMFBar::OnCaptureChanged(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLTRACE2(atlTraceWindowing, 4, TEXT("Received WM_CAPTURECHANGED MESSAGE \n")); 
   
    if(m_fHandleHelp){

        HWND h;
        if(SUCCEEDED(GetWindow(&h))){

            POINT pt;
            ::GetCursorPos(&pt);
            RECT rc;
            ::GetWindowRect(h, &rc);

            if(!::PtInRect(&rc, pt)){
                // we clicked somewhere outiside in our help mode
                m_fHandleHelp = false; // otherwise we are going to get lbutton up and we will
                                       // turn it off then
            }/* end of if statement */
        }
        else {

            m_fHandleHelp = false; // could not get the window, but better trun off
                                   // the help mode
        }/* end of if statement */

    
        return(0);    
    }/* end of if statement */

    if(::IsWindow(m_hWnd)){

        HWND hwndNewCapture = (HWND) lParam;
        if(m_hWnd != hwndNewCapture){
        
            ResetCaptureFlags();
#if 0  // uncoment this if we get badly behaving controls
             if(m_bMouseDown){

                 // we are not supposed to do that
                 // but if our child takes a focus away while we
                 // are resizigng we get in trouble
                 SetCapture(TRUE);                    
             }/* end of if statement */        
#endif
        }/* end of if statement */
    }/* end of if statement */
        
    return(0); 
}/* end of function OnCaptureChanged */

/*************************************************************************/
/* Function: OnSetIcon                                                   */
/* Description: Set icon            .                                    */
/*************************************************************************/
LRESULT CMFBar::OnSetIcon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    LRESULT lr = ::DefWindowProc(m_hWnd, uMsg, wParam, lParam);

    return(lr);
}/* end of function OnSetIcon */

/*************************************************************************/
/* Function: OnInitDialog                                                */
/* Description: Fires the help event.                                    */
/*************************************************************************/
LRESULT CMFBar::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLASSERT(FALSE);
    LRESULT lr = ::DefWindowProc(m_hWnd, uMsg, wParam, lParam);

    return(lr);
}/* end of function OnInitDialog */

/*************************************************************************/
/* Function: OnHelp                                                      */
/* Description: Fires the help event.                                    */
/*************************************************************************/
LRESULT CMFBar::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    HELPINFO* pHpi = (LPHELPINFO) lParam;
    bHandled = TRUE;

    if(NULL == pHpi){

        return 0;
    }/* end of if statement */

    // first check if we have fired help on message box
    HWND hCntrlWnd = (HWND)pHpi->hItemHandle;

    if((::GetWindowLong(hCntrlWnd, GWL_STYLE) & WS_DLGFRAME) == WS_DLGFRAME){
        // we have a message box up

        HWND hwndText;

        hwndText = ::FindWindowEx(hCntrlWnd, NULL, TEXT("Static"), NULL);

        if(hwndText){

            TCHAR strWindowText[MAX_PATH];
            ::GetWindowText(hwndText, strWindowText, MAX_PATH);

            //::DestroyWindow(hCntrlWnd);

            BSTR strToolbarName;

            if(SUCCEEDED(GetToolbarName(&strToolbarName))){

                USES_CONVERSION;            
                Fire_OnHelp(strToolbarName, ::SysAllocString(T2OLE(strWindowText)));
            }/* end of if statement */
        }
        else {

            ;//::DestroyWindow(hCntrlWnd);
        }/* end of if statement */

        return(TRUE);
    }/* end of if statement */

    // then check if a windowed control has fired help
    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
    // iterate through all the contained controls
        
        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            ATLASSERT(FALSE); // should not be null
            continue;
        }/* end of if statement */

        if(pObj->IsInputEnabled() && !pObj->IsWindowless()){
            
            HWND hwnd = NULL;

            HRESULT hr = pObj->GetWindow(&hwnd);

            if(FAILED(hr)){

                continue;
            }/* end of if statement */

            if(hwnd == hCntrlWnd){
                
                Fire_OnHelp(::SysAllocString(pObj->GetID()));                                
                //ResetFocusFlags();
                return(TRUE);
            }/* end of if statement */        
        }/* end of if statement */
    }/* end of for loop */

    // now look into windowless control
    POINT ptMouse = pHpi->MousePos;

    m_fHandleHelp = false; // get our self out of the help mode in case we clicked
    // on windowed control and we did not get notified about this 

    // convert the point to client coordinates
    HWND h = NULL;
    HRESULT hr = GetWindow(&h);

    if(FAILED(hr)){

        ATLASSERT(FALSE);    
        return(0);
    }/* end of if statement */

    if(!::ScreenToClient(h, &ptMouse)){

        ATLASSERT(FALSE);    
        return(0);
    }/* end of if statement */
        
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
    // iterate through all the contained controls
        
        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            ATLASSERT(FALSE); // should not be null
            continue;
        }/* end of if statement */


        // send the message to the control over which we are howering or on which we
        // have clicked, check if we already are ready to send the message
        // in that case do not bother with the rect interstec bussines
        if(pObj->IsInputEnabled()){
            
            CComPtr<IViewObjectEx> pViewObject;
            HRESULT hr = pObj->GetViewObject(&pViewObject);

            if(FAILED(hr)){

                ATLASSERT(FALSE); // should have a view
                continue;
            }/* end of if statement */

            DWORD dwHitResult = HITRESULT_OUTSIDE;
            
            RECT rcCntrl;
            pObj->GetPos(&rcCntrl);

			pViewObject->QueryHitPoint(DVASPECT_CONTENT, &rcCntrl, ptMouse, 0, &dwHitResult);
			
            if(HITRESULT_HIT == dwHitResult){

                Fire_OnHelp(::SysAllocString(pObj->GetID()));                                
                return(TRUE);
            }/* end of if statement */        
            
        }/* end of if statement */
    }/* end of for loop */

    // Get toolbar name
    BSTR strToolbarName;

    if(SUCCEEDED(GetToolbarName(&strToolbarName))){

        Fire_OnHelp(strToolbarName);
    }/* end of if statement */

    return(TRUE);
}/* end of function OnHelp */

/*************************************************************************/
/* Function: OnSize                                                      */
/* Description: Handles the onsize message if we are self contained.     */
/*************************************************************************/
LRESULT CMFBar::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

try {

    if(false == m_fSelfHosted){

        bHandled = FALSE;
        return 0;
    }/* end of if statement */

    // Update the system menu accordingly
    
    if (m_hMenu) {
    	HMENU hSubMenu = ::GetSubMenu(m_hMenu, 0);

      if(hSubMenu){
        MENUITEMINFO mInfo;
        mInfo.cbSize = sizeof(MENUITEMINFO);
        
        BOOL bRestored = (wParam == SIZE_RESTORED);
        ::GetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_RESTORE, false, &mInfo);
        mInfo.fMask = MIIM_STATE;
        mInfo.fState = bRestored? MFS_GRAYED:MFS_ENABLED;
        ::SetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_RESTORE, false, &mInfo);
        
        BOOL bMaximized = (wParam == SIZE_MAXIMIZED);
        ::GetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_MAXIMIZE, false, &mInfo);
        mInfo.fMask = MIIM_STATE;
        mInfo.fState = bMaximized? MFS_GRAYED:MFS_ENABLED;
        ::SetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_MAXIMIZE, false, &mInfo);
        
        BOOL bMinimized = (wParam == SIZE_MINIMIZED);
        ::GetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_MINIMIZE, false, &mInfo);
        mInfo.fMask = MIIM_STATE;
        mInfo.fState = bMinimized? MFS_GRAYED:MFS_ENABLED;
        ::SetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_MINIMIZE, false, &mInfo);

        BOOL bMovable = !(bMaximized || bMinimized);
        ::GetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_SIZE, false, &mInfo);
        mInfo.fMask = MIIM_STATE;
        mInfo.fState = bMovable? MFS_ENABLED:MFS_GRAYED;
        ::SetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_SIZE, false, &mInfo);
        ::GetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_MOVE, false, &mInfo);
        mInfo.fMask = MIIM_STATE;
        mInfo.fState = bMovable? MFS_ENABLED:MFS_GRAYED;
        ::SetMenuItemInfo(hSubMenu, ID_SYSTEMMENU_MOVE, false, &mInfo);
      }
    }

    if (wParam == SIZE_MAXIMIZED) {
#ifndef _DEBUG
        ::SetWindowPos(m_hWnd, HWND_TOPMOST, 0, 0, 0, 0, 
            SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);
#endif
    }
    
    else {
        ::SetWindowPos(m_hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
            SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);
    }

    LONG lWidth = LOWORD(lParam);
    LONG lHeight = HIWORD(lParam);

    Fire_OnResize(lWidth, lHeight, wParam);

    if (m_pBackBitmap) {
        InvalidateRgn();
        if (::IsWindow(m_hWnd))
            ::UpdateWindow(m_hWnd);
    }

    bHandled = true;

  }	    
  catch(...){
  }
  
  return 0;
}/* end of function OnSize */

/*************************************************************************/
/* Function: OnSizing                                                    */
/* Description: Does not let us scale beyond the minimum size. If it     */
/* tries to we fix up the rect on it.                                    */
/*************************************************************************/
LRESULT CMFBar::OnSizing(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if(false == m_fSelfHosted){

        bHandled = FALSE;
        return 0;
    }/* end of if statement */

    RECT* lpRect = (LPRECT)lParam;
    
    LONG lWidth = RECTWIDTH(lpRect);
    LONG lHeight = RECTHEIGHT(lpRect);

    // if we are going to be to small fix the rect
    if(lWidth < m_lMinWidth){

        lpRect->right = lpRect->left + m_lMinWidth;
    }/* end of if statement */

    if(lHeight < m_lMinHeight){

        lpRect->bottom = lpRect->top + m_lMinHeight;
    }/* end of if statement */
   
    bHandled = true;

    return 0;
}/* end of function OnSizing */

/*************************************************************************/
/* Function: Close                                                       */
/* Description: Just exposes the underlaying Close functionality to our  */
/* custom interface.                                                     */
/*************************************************************************/
STDMETHODIMP CMFBar::Close(){


    if(::IsWindow(m_hWnd)){

        ::PostMessage(m_hWnd, WM_CLOSE, NULL, NULL);

        return(S_OK);
        //::DestroyWindow(m_hWnd);
    }/* end of if statement */

	return(Close(OLECLOSE_SAVEIFDIRTY));
}/* end of function Close */

/*************************************************************************/
/* Function: Close                                                       */
/* Description: Calls OLECLOSE the contained objects, then itself.       */
/* The cleans up the containers and send WM_QUIT if we are self hosting. */
/*************************************************************************/
STDMETHODIMP CMFBar::Close(DWORD dwSaveOption){
       
    HRESULT hr = DestroyScriptEngine();

    ATLASSERT(SUCCEEDED(hr));

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        // iterate through all the contained objects and call on the Close
        CHostedObject* pObj = (*i);

        CComPtr<IOleObject> pIOleObject;
        HRESULT hrIOleObj = pObj->GetOleObject(&pIOleObject);

        if(FAILED(hr)){

            continue;
        }/* end of if statement */

        if(GetUnknown() == pObj->GetUnknown()){

            continue; // that is us we close our self later after the contained objects
        }/* end of if statement */

        pIOleObject->Close(dwSaveOption);               
    }/* end of for loop */    

    hr = IOleObjectImpl<CMFBar>::Close(dwSaveOption);
    
    bool fSelfHosted = m_fSelfHosted; // cache up the variable, since we are going to
                                      // wipe it out

    Cleanup(); // delete all the objects

    if(fSelfHosted){

        ::PostMessage(NULL, WM_QUIT, NULL, NULL); // tell our container to give up
    }/* end of if statement */

    return(hr);
}/* end of function Close */

/*************************************************************************/
/* Function: ProcessMessages                                             *
/* Description: Process the windows messages.                            */
/*************************************************************************/
STDMETHODIMP CMFBar::ProcessMessages(){

    HRESULT hr = ::WaitMessage() ? S_OK: S_FALSE;

	return(hr);
}/* end of function ProcessMessages */

/*************************************************************************/
/* Function: AddFocusObject                                              */
/* Description: Adds an object to the end of the focus array.            */
/*************************************************************************/
STDMETHODIMP CMFBar::AddFocusObject(BSTR strObjectID){

	HRESULT hr = S_OK;

    try {

        CHostedObject* pObj;

        hr = FindObject(strObjectID, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        m_cntFocus.insert(m_cntFocus.end(), pObj);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of try statement */

	return (hr);
}/* end of function AddFocusObject */

/*************************************************************************/
/* Function: ResetFocusArray                                             */
/* Description: Resets the focus array.                                  */
/*************************************************************************/
STDMETHODIMP CMFBar::ResetFocusArray(){

	HRESULT hr = S_OK;

    try {
        ResetFocusFlags();

        // cleanup the focus array    
        for(CNTOBJ::iterator k = m_cntFocus.begin(); false == m_cntFocus.empty(); ){        

            k = m_cntFocus.erase(k);
        }/* end of for loop */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of try statement */

	return (hr);
}/* end of function ResetFocusArray */

/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: Iterates through the container and sends the focus       */
/* message to the control that thinks it has the focus.                  */
/*************************************************************************/
LRESULT CMFBar::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    LONG lRes = 0;

    if(m_cntObj.empty() == true){

    	return 0;
    }/* end of if statement */

    MoveFocus(TRUE, lRes);

	return lRes;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: OnHelpEnd                                                   */
/* Description: Resets the help                                          */
/*************************************************************************/
LRESULT CMFBar::OnHelpEnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    LONG lRes = 0;

    m_fHandleHelp = false;

	return lRes;
}/* end of function OnHelpEnd */

/*************************************************************************/
/* Function: OnUserFocus                                                 */
/* Description: Iterates through the container and sends the focus       */
/* message to the control that thinks it has the focus. In this case     */
/* the control is specified by hwnd and that it is a windowed control.   */
/*************************************************************************/
LRESULT CMFBar::OnUserFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    LONG lRes = 0;
    if (!m_bHandleUserFocus) {

        m_bHandleUserFocus = TRUE;
        return lRes;
    }

    HRESULT hr = E_FAIL; // did not find the object

    if(m_fHandleHelp){

        ResetFocusFlags();
        return(lRes);
    }/* end of if statement */

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            continue;
        }/* end of if statement */

        HWND hwndCtrl = NULL;
        hr = pObj->GetWindow(&hwndCtrl);

        if(FAILED(hr)){

            continue;
        }/* end of if statement */

        if(hwndCtrl == (HWND) wParam){

            SetClosestFocus(lRes, pObj);

            //SetObjectFocus(pObj, TRUE, lRes);            
            return(lRes);
        }/* end of if statement */
    }/* end of for loop */

	return lRes;
}/* end of function OnUserFocus */

/*************************************************************************/
/* Function: OnKillFocus                                                 */
/* Description: Sends the kill focus message to the control that has     */
/* Itterates through the container and removes the focus                 */
/* from the contained objects.                                           */
/*************************************************************************/
LRESULT CMFBar::OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    LONG lRes = 0;

    ResetFocusFlags(); // cleanup the focus flags    
	return lRes;
}/* end of function OnKillFocus */ 

/*************************************************************************/
/* Function: OnMouseMessage                                              */
/* Description: Handles the mouse messages, distrubutes to proper        */
/* controls if needed.                                                   */
/*************************************************************************/
LRESULT CMFBar::OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                               BOOL& bHandled){
    
    LONG lRes = 0;
    bHandled = FALSE; // indicated if we dispatched the message

    if(m_lTimeout > 0){

        //WM_MOUSEMOVE messages keep comming over even if we really do not move the mouse

        bool bResetActivity = false;
        if(WM_MOUSEMOVE == uMsg){

            static WPARAM wParTmp = 0;
            static LPARAM lParTmp = 0;

            if(wParam != wParTmp || lParam != lParTmp){

                 bResetActivity = true;
            }/* end of if statement */

            if(wParam & MK_CONTROL ||
               wParam & MK_CONTROL ||
               wParam & MK_LBUTTON ||
               wParam & MK_MBUTTON ||
               wParam & MK_RBUTTON ||
               wParam & MK_SHIFT   ){

                 bResetActivity = true;
            }/* end of if statement */

            lParTmp = lParam;
            wParTmp = wParam;
        }
        else {

            bResetActivity = true;
        }/* end of if statement */
        
        if(bResetActivity){

            m_fUserActivity = true;

            if(m_fWaitingForActivity){

                Fire_ActivityStarted();        
                m_fWaitingForActivity = false;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    ATLTRACE2(atlTraceWindowing, 32, TEXT("R WM_ button message : "));

    if(!m_bMouseDown && m_HitRegion!=PRESIZE && m_HitRegion!=PREMOVE){
        
        CHostedObject* pMouseCaptureObj = NULL;

        // send the message to the control(s) that have the capture    
        if(false == m_fHandleHelp && GetCapture() == S_OK){

            for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
            // iterate through all the contained controls
          

                CHostedObject* pObj = (*i);
        
                if(NULL == pObj){

                    ATLASSERT(FALSE); // should not be null
                    continue;
                }/* end of if statement */

                // need to be able send message to the button with the capture                
                if(pObj->HasCapture()){

                    ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_ buttons message to button %ls \n"), pObj->GetID());
                    HRESULT hr = SendMessageToCtl(pObj, uMsg, wParam, lParam, bHandled, lRes);

                    if(SUCCEEDED(hr)){

                        
                       if (WM_LBUTTONDOWN == uMsg) {

                           CComPtr<IViewObjectEx> pViewObject;
                            HRESULT hr = pObj->GetViewObject(&pViewObject);

                            if(FAILED(hr)){

                                ATLASSERT(FALSE); // should have a view
                                continue;
                            }/* end of if statement */

                            DWORD dwHitResult = HITRESULT_OUTSIDE;

                            POINT ptMouse = { LOWORD(lParam), HIWORD(lParam) };
                            RECT rcCntrl;
                            pObj->GetPos(&rcCntrl);

			                pViewObject->QueryHitPoint(DVASPECT_CONTENT, &rcCntrl, ptMouse, 0, &dwHitResult);
			                
                            if(HITRESULT_HIT == dwHitResult){

                                if (WM_LBUTTONDOWN == uMsg) {

                                    LONG lRes;
                                    //SetObjectFocus(pObj, TRUE, lRes);
                                    SetClosestFocus(lRes, pObj);
                                }/* end of if statement */
                            }/* end of if statement */
                        }/* end of if statement */

                        pMouseCaptureObj = pObj;
                        break; // send mouse message to only the one control that has capture
                        // then to the ones we hower over
                    }/* end of if statement */                    
                }/* end of if statement */
            }/* end of for loop */
        }/* end of if statement */    
    
        // send the message to the control(s) that we are over, but not to the one
        // that which had focus and we already send one
        for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained controls

            CHostedObject* pObj = (*i);
        
            if(NULL == pObj){

                ATLASSERT(FALSE); // should not be null
                continue;
            }/* end of if statement */

            // need to be able send message to the button with the capture
            
            // send the message to the control over which we are howering or on which we
            // have clicked, check if we already are ready to send the message
            // in that case do not bother with the rect interstec bussines
            if(!bHandled && pObj->IsWindowless() && pObj->IsInputEnabled()){
            
                CComPtr<IViewObjectEx> pViewObject;
                HRESULT hr = pObj->GetViewObject(&pViewObject);

                if(FAILED(hr)){

                    ATLASSERT(FALSE); // should have a view
                    continue;
                }/* end of if statement */

                DWORD dwHitResult = HITRESULT_OUTSIDE;

                POINT ptMouse = { LOWORD(lParam), HIWORD(lParam) };
                RECT rcCntrl;
                pObj->GetPos(&rcCntrl);

			    pViewObject->QueryHitPoint(DVASPECT_CONTENT, &rcCntrl, ptMouse, 0, &dwHitResult);

                if(HITRESULT_HIT == dwHitResult){

                    // see if we are handling help, if so do not do anything else, but
                    // fire help with the control ID we are howering over
                    if(m_fHandleHelp){

                        if (WM_LBUTTONUP == uMsg) {

                            Fire_OnHelp(::SysAllocString(pObj->GetID()));
                            m_fHandleHelp = false;
                        }/* end of if statement */
    
                        bHandled = TRUE;
                        return(lRes);
                    }
                    else {
                        
                        if(pMouseCaptureObj == pObj){

                            continue; // we already have send message to this control
                            // do not do it again
                        }/* end of if statememt */

                        ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_ buttons message to button %ls \n"), pObj->GetID());
                        SendMessageToCtl(pObj, uMsg, wParam, lParam, bHandled, lRes);    

                        if (WM_LBUTTONDOWN == uMsg) {
                            
                               LONG lRes;
                               //SetObjectFocus(pObj, TRUE, lRes);                            
                               SetClosestFocus(lRes, pObj);
                        }/* end of if statement */

                    }/* end of if statement */                    
                }/* end of if statement */        
            }/* end of if statement */            
        }/* end of for loop */    
    }/* end of if statement */

    
    if(TRUE == bHandled){
        // we send some messages to a control, so there is no need to handle container now
        
        return(lRes);
    }/* end of if statement */

    // we are not over any control so we might be over container itself, so handle
    // the mouse message appropriately

    ATLTRACE2(atlTraceWindowing, 32, TEXT("Not forwarding the message to the controls\n"));

    if(WM_LBUTTONDOWN == uMsg) {
        Fire_OnMouseDown();
    }

    if(WM_LBUTTONUP == uMsg || WM_LBUTTONDBLCLK == uMsg){

        // TODO: Fire the click only if we are on our window or bitmap
        if(m_fHandleHelp){
            BSTR strToolbarName;

            if(SUCCEEDED(GetToolbarName(&strToolbarName))){
                
                Fire_OnHelp(strToolbarName);                
            }/* end of if statement */
            m_fHandleHelp = false;
        }
        else {

            if(WM_LBUTTONUP == uMsg){

                Fire_OnClick();
                Fire_OnMouseUp();
            }
            else {
                
                Fire_OnDblClick();
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    // handle the moving of the container window
    if(m_fSelfHosted && !m_fHandleHelp){

            if(WM_LBUTTONDOWN == uMsg){
                OnButtonDown(uMsg, wParam, lParam, bHandled);
            }/* end of if statement */

            if(WM_MOUSEMOVE == uMsg){
                OnMouseMove(uMsg, wParam, lParam, bHandled);
            }/* end of if statement */

            if(WM_LBUTTONUP == uMsg){
                OnButtonUp(uMsg, wParam, lParam, bHandled);
            }/* end of if statement */

            // Right click on the title bar
            if(WM_RBUTTONDOWN == uMsg) {

                POINT ptMouse = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
                if (ptMouse.y <= SYS_TITLEBAR_WIDTH) {
                    ::ClientToScreen(m_hWnd, &ptMouse);
                    PopupSystemMenu(ptMouse.x, ptMouse.y);
                }/* end of if statement */
            }/* end of if statement */
    }/* end of if statement */

    return(lRes);
}/* end of function OnMouseMessage */

/*************************************************************************/
/* Function: OnSetCursor                                                 */
/* Description: Handles the WM_SETCURSOR messages, distrubutes to proper */
/* controls if needed.                                                   */
/*************************************************************************/
LRESULT CMFBar::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                               BOOL& bHandled){

    LONG lRes = 0;

    if(!::IsWindow(m_hWnd)){

        return lRes;
    }/* end of if statement */

    if (m_HitRegion == PRESIZE || m_HitRegion == PREMOVE) {

        return lRes;
    }

    bHandled = FALSE;

    if(m_cntObj.empty() == true){

    	return 0;
    }/* end of if statement */

        
    CHostedObject* pMouseCaptureObj = NULL;
    
    // send the message to the control(s) that have the capture    
    if(false == m_fHandleHelp && GetCapture() == S_OK){
        
        for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
            // iterate through all the contained controls
            
            
            CHostedObject* pObj = (*i);
            
            if(NULL == pObj){
                
                ATLASSERT(FALSE); // should not be null
                continue;
            }/* end of if statement */
            
            // need to be able send message to the button with the capture                
            if(pObj->HasCapture()){
                
                ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_SETCURSOR message to button %ls \n"), pObj->GetID());
                HRESULT hr = SendMessageToCtl(pObj, uMsg, wParam, lParam, bHandled, lRes);                

#if 0
                if(SUCCEEDED(hr)){

                    return(lRes);
                }/* end of if statement */
#endif
            }/* end of if statement */
        }/* end of for loop */
    }/* end of if statement */    

    DWORD dwValue = ::GetMessagePos();
    POINT ptMouse = {GET_X_LPARAM(dwValue), GET_Y_LPARAM(dwValue)};
    ::ScreenToClient(m_hWnd, &ptMouse);
    
    // send the message to the control(s) that we are over, but not to the one
    // that which had focus and we already send one
    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained controls
        
        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){
            
            ATLASSERT(FALSE); // should not be null
            continue;
        }/* end of if statement */
        
        // need to be able send message to the button with the capture
        
        // send the message to the control over which we are howering or on which we
        // have clicked, check if we already are ready to send the message
        // in that case do not bother with the rect interstec bussines
        if(pObj->IsWindowless()){
            
            CComPtr<IViewObjectEx> pViewObject;
            HRESULT hr = pObj->GetViewObject(&pViewObject);
            
            if(FAILED(hr)){
                
                ATLASSERT(FALSE); // should have a view
                continue;
            }/* end of if statement */
            
            DWORD dwHitResult = HITRESULT_OUTSIDE;
                        
            RECT rcCntrl;
            pObj->GetPos(&rcCntrl);
            
            pViewObject->QueryHitPoint(DVASPECT_CONTENT, &rcCntrl, ptMouse, 0, &dwHitResult);
            
            if(HITRESULT_HIT == dwHitResult){
                
                // see if we are handling help, if so do not do anything else, but
                // fire help with the control ID we are howering over
                if(m_fHandleHelp){
                    
                    bHandled = FALSE;
                    return(lRes);
                }
                else {
                    
                    if(pMouseCaptureObj == pObj){
                        
                        continue; // we already have send message to this control
                        // do not do it again
                    }/* end of if statememt */
                    
                    ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_SETCURSOR message to button %ls \n"), pObj->GetID());
                    SendMessageToCtl(pObj, uMsg, wParam, lParam, bHandled, lRes); 

                    if(SUCCEEDED(hr)){

                        return(lRes);
                    }/* end of if statement */
                }/* end of if statement */                    
            }/* end of if statement */        
        }/* end of if statement */            
    }/* end of for loop */    

    return lRes;	
}

/*************************************************************************/
/* Function: OnKeyMessage                                                */
/* Description: Distrubutes the keyboard messages properly.              */
/*************************************************************************/
LRESULT CMFBar::OnKeyMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    m_fUserActivity = true;

    static bool fHandleKeyUp = false; // when onther child window closes on top 
                                      // of us we get an UP message without down
                                      // this should.. eat it up

    if(uMsg == WM_KEYDOWN || uMsg == WM_SYSKEYDOWN){

        fHandleKeyUp = true;    
    }/* end of if statement */

    if(m_fWaitingForActivity){

        Fire_ActivityStarted();        
        m_fWaitingForActivity = false;
    }/* end of if statement */


    if(uMsg == WM_KEYUP || uMsg == WM_SYSKEYUP){            

        if(!fHandleKeyUp){

            fHandleKeyUp = false;    
            return 0;
        }/* end of if statement */

        fHandleKeyUp = false;
    }/* end of if statement */

    bHandled = FALSE;
    LONG lRes = 0;    
    VARIANT_BOOL fEat = VARIANT_FALSE;

    LONG lEnable = 1; // using long since the framework will not handle short

    LONG lVirtKey = (LONG) wParam;
    LONG lKeyData = (LONG) lParam;

    m_fForceKey = false; // reset the flag, the change in the value would indicate
                         // that we have received call to force key during the event
                         // processing

    // Handle keys for manual move and size
    HandleMoveSizeKey(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        return lRes;

    if (!m_bHandleEnter && !m_bSysMenuOn) {
        
        if(WM_KEYDOWN == uMsg)
            Fire_OnKeyDown(lVirtKey, lKeyData);
        
        else if (WM_KEYUP == uMsg) 
            Fire_OnKeyUp(lVirtKey, lKeyData);

        ATLTRACE2(atlTraceWindowing, 4, TEXT("OnKeyMessage Fire_OnKey message\n")); 

    }/* end of if statement */    
    
    if(WM_SYSKEYDOWN == uMsg){

        Fire_OnSysKeyDown(lVirtKey, lKeyData);
    }/* end of if statement */

    if(WM_SYSKEYUP == uMsg){

        Fire_OnSysKeyUp(lVirtKey, lKeyData);
    }/* end of if statement */

    if(m_fForceKey){

        fEat = m_fEat;
        lVirtKey = m_lVirtKey;
        lKeyData = m_lKeyData;
    }/* end of if statement */

    if(VARIANT_FALSE == fEat){

        if(WM_KEYUP == uMsg ){
            switch(lVirtKey){

            case VK_TAB:
                bool fForward = true;

                if(::GetKeyState(VK_SHIFT) < 0){

                    fForward = false;
                }/* end of if statement */

                MoveFocus(fForward, lRes);
                return(lRes);        
             }/* end of switch statement */
        }/* end of if statement */

        if (m_bHandleEnter || m_bSysMenuOn)
            return lRes;

        // iterates through the controls and send these key messages to the one
        // with focus
        CNTOBJ::iterator i;     
        for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained controls

            CHostedObject* pObj = (*i);
        
            if(NULL == pObj){

                ATLASSERT(FALSE);
                continue;
            }/* end of if statement */

            if(pObj->HasFocus()){

                // handle help
                if(WM_KEYUP == uMsg && VK_F1 == lVirtKey){
                    
                    Fire_OnHelp(::SysAllocString(pObj->GetID()));                    
                }/* end of if statement */

                HRESULT hr = SendMessageToCtl(pObj, uMsg, lVirtKey, lKeyData, bHandled, lRes, false);
                ATLTRACE2(atlTraceWindowing, 4, TEXT("OnKeyMessage SendMessageToCtl\n")); 

                if(SUCCEEDED(hr)){

                    return(lRes);
                }/* end of if statement */                        
            }/* end of if statement */
        }/* end of for loop */

        // handle help
        if(WM_KEYUP == uMsg && VK_F1 == lVirtKey){
            BSTR strToolbarName;

            if(SUCCEEDED(GetToolbarName(&strToolbarName))){

                USES_CONVERSION;            
                Fire_OnHelp(strToolbarName, NULL);
                //m_fHandleHelp = false;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    return(lRes);
}/* end of function OnKeyMessage */

/*************************************************************/
/* Name: HandleMoveSizeKey
/* Description: Handle arrows for manual move and size
/*************************************************************/
LRESULT CMFBar::HandleMoveSizeKey(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LONG lRes = 0;
    bHandled = TRUE;

    LONG lVirtKey = (LONG) wParam;
    LONG lKeyData = (LONG) lParam;

    POINT point = m_ptMouse;
    
    // Get Window rc
    RECT rc;
    ::GetClientRect(m_hWnd, &rc);

    // Get Desktop rc
    RECT rcDeskt;
    ::GetWindowRect(::GetDesktopWindow(), &rcDeskt);

    ATLTRACE2(atlTraceWindowing, 4, TEXT("OnKeyMessage m_bHandleEnter %d\n"), m_bHandleEnter); 

    if (lVirtKey == VK_ESCAPE || lVirtKey == VK_SELECT || lVirtKey == VK_SPACE || lVirtKey == VK_RETURN) {
        if (WM_KEYDOWN == uMsg) {
            if (m_bHandleEnter) {
                
                if (lVirtKey == VK_ESCAPE) { 
                    ::MoveWindow(m_hWnd, m_rcWndOld.left, m_rcWndOld.top, RECTWIDTH(&m_rcWndOld), RECTHEIGHT(&m_rcWndOld), TRUE);
                }

                point = m_ptMouseOld;
                LONG lx = LONG((FLOAT)point.x/ RECTWIDTH(&rcDeskt) * 0xFFFF);
                LONG ly = LONG((FLOAT)point.y/ RECTHEIGHT(&rcDeskt) * 0xFFFF);
                
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTUP, lx, ly, 0, 0);                
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, lx, ly, 0, 0);
                return lRes;
            }
        }
        else if (WM_KEYUP == uMsg) {
            if (m_bHandleEnter && !m_bMouseDown && 
                m_HitRegion!=PRESIZE && m_HitRegion!=PREMOVE) {
                m_bHandleEnter = FALSE;
                return lRes;
            }
        } /* end of if statement */
    } /* end of if statement */
     
    if (WM_KEYDOWN == uMsg && 
        (lVirtKey == VK_LEFT || lVirtKey == VK_RIGHT|| 
         lVirtKey == VK_UP   || lVirtKey == VK_DOWN)) {
        
        POINT leftTop = {SYS_MOVE_SIZE, SYS_MOVE_SIZE};
        POINT rightBottom = {rc.right-SYS_MOVE_SIZE, rc.bottom-SYS_MOVE_SIZE};
        
        POINT scLeftTop = leftTop;        
        ::ClientToScreen(m_hWnd, &scLeftTop);
        POINT scRightBottom = rightBottom;        
        ::ClientToScreen(m_hWnd, &scRightBottom);
        
        LONG left = LONG((FLOAT)scLeftTop.x/ RECTWIDTH(&rcDeskt) * 0xFFFF);
        LONG top = LONG((FLOAT)scLeftTop.y/ RECTHEIGHT(&rcDeskt) * 0xFFFF);
        LONG right = LONG((FLOAT)scRightBottom.x/ RECTWIDTH(&rcDeskt) * 0xFFFF);
        LONG bottom = LONG((FLOAT)scRightBottom.y/ RECTHEIGHT(&rcDeskt) * 0xFFFF);

        if (m_HitRegion == PREMOVE) {

            POINT point = {(rc.left+rc.right)/2, rc.top + SYS_TITLEBAR_WIDTH/2};            
            POINT screenPt = point;        
            ::ClientToScreen(m_hWnd, &screenPt);
           
            LONG lx = LONG((FLOAT)screenPt.x/ RECTWIDTH(&rcDeskt) * 0xFFFF);
            LONG ly = LONG((FLOAT)screenPt.y/ RECTHEIGHT(&rcDeskt) * 0xFFFF);
            
            m_HitRegion = NOHIT;
            mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, lx, ly, 0, 0);
            mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, lx, ly, 0, 0);
            return lRes;
        }

        else if (m_HitRegion == PRESIZE) {
            
            m_HitRegion = NOHIT;
            switch (lVirtKey) {
                
            case VK_LEFT: 
                
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, left, (top+bottom)/2, 0, 0);
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, left, (top+bottom)/2, 0, 0);
                break;
            case VK_RIGHT:
                
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, right, (top+bottom)/2, 0, 0);
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, right, (top+bottom)/2, 0, 0);
                break;
            case VK_UP:
                
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, (left+right)/2, top, 0, 0);
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, (left+right)/2, top, 0, 0);
                break;
            case VK_DOWN:
                
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, (left+right)/2, bottom, 0, 0);
                mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, (left+right)/2, bottom, 0, 0);
                break;
                
            } /* end of switch statement */
            return lRes;
        }

        else if (m_bMouseDown) {
            switch (lVirtKey) {
                
            case VK_LEFT: 
                
                if (!(m_HitRegion&RIGHT || m_HitRegion&LEFT) && m_HitRegion!=NOHIT) {
                    m_HitRegion = (HitRegion) (m_HitRegion | LEFT);
                    
                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, left, m_HitRegion&BOTTOM?bottom:top, 0, 0);
                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, left, m_HitRegion&BOTTOM?bottom:top, 0, 0);
                    return lRes;
                }

                if (!(m_HitRegion&RIGHT && RECTWIDTH(&rc)-SYS_MOVE_SIZE<=m_lMinWidth))
                    point.x -= SYS_MOVE_SIZE;
                break;
            case VK_RIGHT:
                
                if (!(m_HitRegion&RIGHT || m_HitRegion&LEFT) && m_HitRegion!=NOHIT) {
                    m_HitRegion = (HitRegion) (m_HitRegion | RIGHT);

                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, right, m_HitRegion&BOTTOM?bottom:top, 0, 0);
                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, right, m_HitRegion&BOTTOM?bottom:top, 0, 0);
                    return lRes;
                }
                if (!(m_HitRegion&LEFT && RECTWIDTH(&rc)-SYS_MOVE_SIZE<=m_lMinWidth))
                    point.x += SYS_MOVE_SIZE;
                break;
            case VK_UP:
                
                if (!(m_HitRegion&TOP || m_HitRegion&BOTTOM) && m_HitRegion!=NOHIT) {
                    m_HitRegion = (HitRegion) (m_HitRegion | TOP);
                    
                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, m_HitRegion&RIGHT?right:left, top, 0, 0);
                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, m_HitRegion&RIGHT?right:left, top, 0, 0);
                    return lRes;
                }

                if (!(m_HitRegion&BOTTOM && RECTHEIGHT(&rc)-SYS_MOVE_SIZE<=m_lMinHeight))
                    point.y -= SYS_MOVE_SIZE;
                break;
            case VK_DOWN:
                
                if (!(m_HitRegion&TOP || m_HitRegion&BOTTOM) && m_HitRegion!=NOHIT) {
                    m_HitRegion = (HitRegion) (m_HitRegion | BOTTOM);

                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, m_HitRegion&RIGHT?right:left, bottom, 0, 0);
                    mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, m_HitRegion&RIGHT?right:left, bottom, 0, 0);
                    return lRes;
                }

                if (!(m_HitRegion&TOP && RECTHEIGHT(&rc)-SYS_MOVE_SIZE<=m_lMinHeight))
                    point.y += SYS_MOVE_SIZE;
                break;
                
            } /* end of switch statement */
            ::SetCursorPos(point.x, point.y);
            return lRes;
        }/* end of if statement */
    }

    bHandled = FALSE;
    return lRes;
} /*HandleMoveSizekey*/
    
/*************************************************************************/
/* Function: OnDispChange                                                */
/* Description: Forwards this message to all the controls.               */
/*************************************************************************/
LRESULT CMFBar::OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    LONG lRes =0;

    long cBitsPerPixel = wParam; 
    long cxScreen = LOWORD(lParam); 
    long cyScreen = HIWORD(lParam); 
    if (NULL != m_pBackBitmap)
        m_pBackBitmap->OnDispChange(cBitsPerPixel, cxScreen, cyScreen);
    
    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            continue;
        }/* end of if statement */

        SendMessageToCtl(pObj, uMsg, wParam, lParam, bHandled, lRes, true, false);
        
    }/* end of for loop */
    
    return(lRes);
}/* end of function OnDispChange */

/*************************************************************************/
/* Function: AdvanceIterator                                             */
/* Description: Helper inline function that helps to keep track which    */
/* direction we are advancing.                                           */
/*************************************************************************/
void AdvanceIterator(CNTOBJ::iterator& i, bool fForward){

    if(fForward){

        i++;
    }
    else {

        i--;
    }/* end of if statement */
}/* end of function AdvanceIterator */

/*************************************************************************/
/* Function: MoveFocus                                                   */
/* Descrition: Moves focus through the objects in forward or reverse     */
/* direction.                                                            */
/*************************************************************************/
HRESULT CMFBar::MoveFocus(bool fForward, LONG& lRes){

    
    HRESULT hr = S_OK;

    if(true == m_cntFocus.empty()){

        return(S_FALSE);
    }/* end of if statement */

    // first remove the focus and remeber the object
    CHostedObject* pLastFocusObject = NULL;            

    CNTOBJ::iterator i, iEnd;

    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
        iEnd--;
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();

    }/* end of if statement */

    BOOL bFirst = TRUE;
    
    do {

        // do not advance if first time in the loop
        if (!bFirst)
            AdvanceIterator(i, fForward);
        else
            bFirst = FALSE;
        
        // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj->HasFocus()){

           LONG lRes;
           SetObjectFocus(pObj, FALSE, lRes);                       
           pLastFocusObject = pObj;
           continue; // get to the next object
        }/* end of if statement */

        // try to set the focus to the next object
        if(NULL != pLastFocusObject){

            if(pObj->IsInputEnabled()){
           
               LONG lRes = 0;
               HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

                if(FAILED(hr)){
            
                    continue; // this is the container so skip it
                }/* end of if statement */

                if(-1 == lRes){
                    // did not want to handle focus, since the button is disabled
                    SetObjectFocus(pObj, FALSE, lRes); 
                    continue;
                }/* end of if statement */

                return(hr);
            }/* end of if statement */
        }/* end of if statement */
    } while (i != iEnd); /* end of do loop */

    // OK lets try to set focus to somebody before
    //CNTOBJ::iterator i;
    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
        iEnd--;
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();

    }/* end of if statement */

    bFirst = TRUE;
    
    do {
        // do not advance if first time in the loop
        if (!bFirst)
            AdvanceIterator(i, fForward);
        else
            bFirst = FALSE;

        // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj->IsInputEnabled()){

            LONG lRes = 0;
            HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

            if(FAILED(hr)){

                continue; // this is the container so skip it
            }/* end of if statement */

            if(-1 == lRes){
                // did not want to handle focus, since the button is disabled
                SetObjectFocus(pObj, FALSE, lRes); 
                continue;
            }/* end of if statement */

            return(hr);
        }/* end of if statement */
    } while (i != iEnd); /* end of do loop */

    //ATLASSERT(FALSE); // should not really hapen, to have all the objects disabled
    return(hr);    
}/* end of function MoveFocus */

/*************************************************************************/
/* Function: SetClosestFocus                                             */
/* Descrition: Sets the focus to the closes object to pObj if specified. */
/*************************************************************************/
HRESULT CMFBar::SetClosestFocus(LONG& lRes, CHostedObject* pStartObj, bool fForward){
    
    HRESULT hr = S_OK;

    if(m_cntFocus.empty()){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    ResetFocusFlags();
    
    // first remove the focus and remeber the object
    bool fStartSettingFocus = false;            

    CNTOBJ::iterator i, iEnd;

    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
        iEnd--;
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();

    }/* end of if statement */

    if(NULL == pStartObj){
        
        pStartObj = (*i); // initialize our start object
    }/* end of if statement */

    BOOL bFirst = TRUE;
    
    do {
        // do not advance if first time in the loop
        if (!bFirst)
            AdvanceIterator(i, fForward);
        else
            bFirst = FALSE;
        
        // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj == pStartObj){

           fStartSettingFocus = true;           
        }/* end of if statement */

        // try to set the focus to the next object
        if(fStartSettingFocus ){

            if(pObj->IsInputEnabled()){
           
               LONG lRes = 0;
               HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

                if(FAILED(hr)){
            
                    continue; // this is the container so skip it
                }/* end of if statement */

                if(-1 == lRes){
                    // did not want to handle focus, since the button is disabled
                    SetObjectFocus(pObj, FALSE, lRes); 
                    continue;
                }/* end of if statement */

                return(hr);
            }/* end of if statement */
        }/* end of if statement */
    } while (i != iEnd); /* end of do loop */

    if(!fStartSettingFocus){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    // OK lets try to set focus to somebody before
    //CNTOBJ::iterator i;
    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
        iEnd--;
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();
    }/* end of if statement */

    bFirst = TRUE;
    
    do {
        // do not advance if first time in the loop
        if (!bFirst)
            AdvanceIterator(i, fForward);
        else
            bFirst = FALSE;

        // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj->IsInputEnabled()){

            LONG lRes = 0;
            HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

            if(FAILED(hr)){

                continue; // this is the container so skip it
            }/* end of if statement */

            if(-1 == lRes){
                // did not want to handle focus, since the button is disabled
                SetObjectFocus(pObj, FALSE, lRes); 
                continue;
            }/* end of if statement */

            return(hr);
        }/* end of if statement */
    } while (i != iEnd); /* end of do loop */

    ATLASSERT(FALSE); // should not really hapen, to have all the objects disabled
    return(hr);
    
}/* end of function SetClosestFocus */


/*************************************************************************/
/* Function: OnForwardMsg                                                */
/* Description: Forwards the message to the active object.               */
/*************************************************************************/
LRESULT CMFBar::OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/){

    ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::OnForwardMsg\n"));

	ATLASSERT(lParam != 0);
	LPMSG lpMsg = (LPMSG)lParam;
	
	if(m_spActiveObject){

		if(m_spActiveObject->TranslateAccelerator(lpMsg) == S_OK)
			return 1;
	}/* end of function OnForwardMessage */
	return 0;
}/* end of function OnForwardMessage */

/*************************************************************************/
/* Function: ReflectNotifications                                        */
/* Description: Reflects the messages to the child windows               */
/*************************************************************************/
LRESULT CMFBar::ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                                     BOOL& bHandled){
	HWND hWndChild = NULL;

	switch(uMsg){

	    case WM_COMMAND:
		    if(lParam != NULL)	// not from a menu
			    hWndChild = (HWND)lParam;
		    break;
	    case WM_NOTIFY:
		    hWndChild = ((LPNMHDR)lParam)->hwndFrom;
		    break;
	    case WM_PARENTNOTIFY:
		    switch(LOWORD(wParam))
		    {
		    case WM_CREATE:
		    case WM_DESTROY:
			    hWndChild = (HWND)lParam;
			    break;
		    default:
			    hWndChild = GetDlgItem(HIWORD(wParam));
			    break;
		    }
		    break;
	    case WM_DRAWITEM:
		    if(wParam)	// not from a menu
			    hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
		    break;
	    case WM_MEASUREITEM:
		    if(wParam)	// not from a menu
			    hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
		    break;
	    case WM_COMPAREITEM:
		    if(wParam)	// not from a menu
			    hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
		    break;
	    case WM_DELETEITEM:
		    if(wParam)	// not from a menu
			    hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
		    break;
	    case WM_VKEYTOITEM:
	    case WM_CHARTOITEM:
	    case WM_HSCROLL:
	    case WM_VSCROLL:
		    hWndChild = (HWND)lParam;
		    break;
	    case WM_CTLCOLORBTN:
	    case WM_CTLCOLORDLG:
	    case WM_CTLCOLOREDIT:
	    case WM_CTLCOLORLISTBOX:
	    case WM_CTLCOLORMSGBOX:
	    case WM_CTLCOLORSCROLLBAR:
	    case WM_CTLCOLORSTATIC:
		    hWndChild = (HWND)lParam;
		    break;
	    default:
		    break;
	}/* end of switch statement */

	if(hWndChild == NULL){

		bHandled = FALSE;
		return 1;
	}/* end of if statememnt */

	ATLASSERT(::IsWindow(hWndChild));
	return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
}/* end of function ReflectNotifications */

/*************************************************************************/
/* Function: put_Caption                                                 */
/* Description: Sets the caption to the window if present and handles    */
/* the ambient property implementation.                                  */
/*************************************************************************/
STDMETHODIMP CMFBar::put_Caption(BSTR bstrCaption){ 

	ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Caption\n")); 
	
    HRESULT hr = S_OK;

    if (FireOnRequestEdit(DISPID_CAPTION) == S_FALSE){

		return S_FALSE; 
    }/* end of if statement */

    m_bstrCaption = bstrCaption;        
	m_bRequiresSave = TRUE; 
	FireOnChanged(DISPID_CAPTION);
	FireViewChange(); 
	SendOnDataChange(NULL); 

    if(::IsWindow(m_hWnd)){

#ifdef _UNICODE
        ::SetWindowText(m_hWnd, bstrCaption);
#else
        USES_CONVERSION;
        LPTSTR strTemp = OLE2T(bstrCaption);
        if (strTemp != NULL)
        {
            ::SetWindowText(m_hWnd, strTemp);
        }
        else
        {
            hr = E_POINTER;
        }
#endif
    }/* end of if statement */

	return hr; 
}/* end of function put_Caption */

/*************************************************************************/
/* Function: BitsPerPixel                                                */
/* Description: Gets the number of bits per pixel.                       */
/*************************************************************************/
STDMETHODIMP CMFBar::BitsPerPixel(long *plBits){

    HRESULT hr = S_OK;
    try {
        
        HWND hwnd = NULL;

        hr = GetWindow(&hwnd);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        HDC hdc = ::GetWindowDC(hwnd);

        if(NULL == hdc){

            throw(E_FAIL);
        }/* end of if statement */

        *plBits = ::GetDeviceCaps(hdc, BITSPIXEL);
                
        ::ReleaseDC(hwnd, hdc);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of try statement */

    return(hr);
}/* end of function BitsPerPixel */
	
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
/*************************************************************************/
/* IActiveScriptSite Interface Implementation                            */
/*************************************************************************/

/*************************************************************************/
/* Function: get_CmdLine                                                 */
/*************************************************************************/
STDMETHODIMP CMFBar::get_CmdLine(BSTR *pVal){

    if(NULL == pVal){

        return(E_POINTER);
    }/* end of if statement */

    *pVal = m_strCmdLine.Copy();
	return S_OK;
}/* end of function get_CmdLine */

/*************************************************************************/
/* Function: put_CmdLine                                                 */
/*************************************************************************/
STDMETHODIMP CMFBar::put_CmdLine(BSTR newVal){

    m_strCmdLine = newVal;
	return S_OK;
}/* end of function put_CmdLine */

/*************************************************************************/
/* Function: GetUserLCID                                                 */
/* Description: Gets the user default LCID                               */
/*************************************************************************/
STDMETHODIMP CMFBar::GetUserLCID(long *plcid){

    *plcid = ::GetUserDefaultLCID();
  return (S_OK);
}/* end of function GetUserLCID */

/*************************************************************************/
/* Function: GetLCID                                                     */
/* Description: Gets the user default LCID                               */
/*************************************************************************/
STDMETHODIMP CMFBar::GetLCID(LCID *plcid){

    *plcid = ::GetUserDefaultLCID();
  return (S_OK);
}/* end of function GetLCID */

/*************************************************************************/
/* Function: GetItemInfo                                                 */
/* Description: Returns IUnknown or TypeInfo of the contained (embedded) */
/* objects in the active script, in this case we return also a container,*/
/* since we can script it as well (but the script container is inserted  */
/* in the list as well, so no special case for it.                       */
/* TODO: Might want to optimize and use hash table for faster compares.  */
/* on the other hand it seems like a script engine calls this just once  */
/* for an object an then reuses its internal reference.                  */
/*************************************************************************/
STDMETHODIMP CMFBar::GetItemInfo(LPCOLESTR strObjectID, DWORD dwReturnMask, 
                                 IUnknown**  ppunkItemOut, ITypeInfo** pptinfoOut){

    HRESULT hr = S_OK;

    if (dwReturnMask & SCRIPTINFO_ITYPEINFO){

      if (!pptinfoOut){

        return E_INVALIDARG;
      }/* end of if statement */

    *pptinfoOut = NULL;
    }/* end of if statement */

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN){

      if (!ppunkItemOut){
        return E_INVALIDARG;
      }/* end of if statement */

    *ppunkItemOut = NULL;
    }/* end of if statement */

    CHostedObject* pObj;

    if(SUCCEEDED(FindObject(const_cast<BSTR>(strObjectID), &pObj))){
    
        if (dwReturnMask & SCRIPTINFO_ITYPEINFO){

            hr = pObj->GetTypeInfo(0, ::GetUserDefaultLCID(), pptinfoOut);

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
        }/* end of if statement */

        if (dwReturnMask & SCRIPTINFO_IUNKNOWN){

            *ppunkItemOut = pObj->GetUnknown(); // does AddRef under the hood
            (*ppunkItemOut)->AddRef();
        }/* end of if statement */

        return(hr); // found out item no need to dig around longer      
    }/* end of for loop */
    
    return TYPE_E_ELEMENTNOTFOUND;
}/* end of function GetItemInfo */

/*************************************************************************/
/* Function: GetDocVersionString                                         */
/*************************************************************************/
STDMETHODIMP CMFBar::GetDocVersionString(BSTR *pbstrVersion ){

  return (E_NOTIMPL);  
}/* end of function GetDocVersionString */

/*************************************************************************/
/* Function: OnScriptTerminate                                           */  
/*************************************************************************/
STDMETHODIMP CMFBar::OnScriptTerminate(const VARIANT   *pvarResult,
                                       const EXCEPINFO *pexcepinfo){

  return (E_NOTIMPL);  
}/* end of function OnScriptTerminate */

/*************************************************************************/
/* Function: OnStateChange                                               */
/*************************************************************************/
STDMETHODIMP CMFBar::OnStateChange(SCRIPTSTATE ssScriptState){

    return (E_NOTIMPL);  
}/* end of function OnStateChange */

/*************************************************************************/
/* Function: OnScriptError                                               */
/* Description: Display the script error in debug mode, skip it in       */
/* release mode for now.                                                 */
/*************************************************************************/
STDMETHODIMP CMFBar::OnScriptError(IActiveScriptError *pse){

  HRESULT   hr = S_OK;

#ifdef _DEBUG
  WCHAR      szError[1024]; 
  EXCEPINFO ei;
  DWORD     dwSrcContext;
  ULONG     ulLine;
  LONG      ichError;
  BSTR      bstrLine = NULL;


  hr = pse->GetExceptionInfo(&ei);

  if(FAILED(hr)){

      return(hr);
  }/* end of if statement */

  hr = pse->GetSourcePosition(&dwSrcContext, &ulLine, &ichError);

  if(FAILED(hr)){

      return(hr);
  }/* end of if statement */

  hr = pse->GetSourceLineText(&bstrLine);

  if (hr){

    hr = S_OK;  // Ignore this error, there may not be source available
  }/* end of if statement */
  
  if (!hr){
 
     wsprintfW(szError, L"Source:'%s'\n Line:%d  Description:%s\n",
                      ei.bstrSource, ulLine, ei.bstrDescription);
#ifdef _DEBUG
     USES_CONVERSION;
     //ATLTRACE(OLE2T(szError));
     ::MessageBeep((UINT)-1);
     ::MessageBoxW(::GetFocus(), szError, L"Error", MB_OK);    
#endif
    // TODO: Add real error handling for released version
 }/* end of if statment */

  if (bstrLine){

      ::SysFreeString(bstrLine);
  }/* end of if statement */

#endif
  return hr;
}/* end of function OnScriptError */

//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------
STDMETHODIMP CMFBar::OnEnterScript
(
  void 
)
{
  // No need to do anything
  return S_OK;
}


//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------
STDMETHODIMP CMFBar::OnLeaveScript
(
  void 
)
{
  // No need to do anything
  return S_OK;
}

// #####  END  ACTIVEX SCRIPTING SUPPORT #####

/*************************************************************************/
/* Function: About                                                       */
/* Description: Displayes about box.                                     */
/*************************************************************************/
STDMETHODIMP CMFBar::About(){

     HRESULT hr = S_OK;

     const INT ciMaxBuffSize = MAX_PATH; // enough for the text
     TCHAR strBuffer[ciMaxBuffSize];
     TCHAR strBufferAbout[ciMaxBuffSize];

     if(!::LoadString(m_hRes, IDS_BAR_ABOUT, strBuffer, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

     if(!::LoadString(m_hRes, IDS_ABOUT, strBufferAbout, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

    ::MessageBox(::GetFocus(), strBuffer, strBufferAbout, MB_OK);

	return (hr);
}/* end of function About */

/*************************************************************************/
/* Function: GetObjectUnknown                                            */
/* Description: Iterates throught the object collection, finds the       */
/* object that has the specific ID then returns it IUnknown.             */
/*************************************************************************/
STDMETHODIMP CMFBar::GetObjectUnknown(BSTR strObjectID, IUnknown **ppUnk){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        return E_POINTER;
    }/* end of if statement */

    if(NULL == ppUnk){

        return E_POINTER;
    }/* end of if statement */

    *ppUnk = NULL;

    CHostedObject* pObj;

    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    *ppUnk = pObj->GetUnknown();        
    hr = S_OK;

    if(*ppUnk == NULL){
    
        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    (*ppUnk)->AddRef(); // adds the reference, since we are giving  out
    
	return (hr);
}/* end of function GetObjectUnknown */

/*************************************************************************/
/* Function: InvalidateObjectRect                                        */
/* Description: Invalidates the object.                                  */
/*************************************************************************/
STDMETHODIMP CMFBar::InvalidateObjectRect(BSTR strObjectID){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        return E_POINTER;
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    CContainerObject* pCnt;
    hr = pObj->GetContainerObject(&pCnt);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
           
    hr = pCnt->InvalidateObjectRect();
    
	return (hr);
}/* end of function InvalidateObjectRect */

/*************************************************************************/
/* Function: Invalidate                                                  */
/* Description: Invalidates the whole container, which in turns repaints */
/* all the controls.                                                     */
/*************************************************************************/
STDMETHODIMP CMFBar::Invalidate(){

	HRESULT hr = InvalidateRect(NULL, FALSE);

	return (hr);
}/* end of function Invalidate */

/*************************************************************************/
/* Function: EnableObject                                                */
/* Description: Goes trough the objects and enables or disables it       */
/* depending on the flag. Invalidates the objects rect as well.          */
/*************************************************************************/
STDMETHODIMP CMFBar::EnableObject(BSTR strObjectID, VARIANT_BOOL fEnable){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        return E_POINTER;
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
           
    bool fTmpEnable = VARIANT_FALSE == fEnable ? false: true;

    CContainerObject* pCnt;
    hr = pObj->GetContainerObject(&pCnt);

    if(FAILED(hr)){

        if(pObj->GetUnknown() == GetUnknown()){
            // special case when we are invalidating our self/ the self hosted container
            if(fTmpEnable){

                InvalidateRect(NULL, false);
            }/* end of if statement */
            pObj->SetActive(fTmpEnable);
            hr = S_OK;
            return(hr);
        }/* end of if statement */        
    }/* end of if statemenet */

    if (pObj->IsActive() == fTmpEnable)
        return S_OK;

    pObj->SetActive(fTmpEnable);        

    if(false == fTmpEnable){

        LONG lRes = 0;
        if (pObj->HasFocus()) {

            SetClosestFocus(lRes);
            //MoveFocus(true, lRes);
            //SetObjectFocus(pObj, FALSE, lRes);
        }

        if(pObj->HasCapture()){

            pCnt->SetCapture(FALSE);
        }/* end of if statement */
    }/* end of if statement */
    
    // invalidate area where the object lives
    if(pObj->IsWindowless()){

        // invalidate the rect only if we are windowless control
        // the windowed control shopuld be able
        // to update itself depending on the SW_SHOW, HIDE messagess
        hr = pCnt->InvalidateObjectRect();
    }/* end of if statement */

	return (hr);
}/* end of function EnableObject */

/*************************************************************************/
/* Function: ObjectEnabled                                               */
/* Description: Goes trough the objects and checks if the particular     */
/* object is enabled or disabled.                                        */
/*************************************************************************/
STDMETHODIMP CMFBar::ObjectEnabled(BSTR strObjectID, VARIANT_BOOL *pfEnabled){

    HRESULT hr = E_FAIL;

    if(NULL == pfEnabled){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
    
    *pfEnabled = pObj->IsActive()? VARIANT_TRUE : VARIANT_FALSE;             

	return (hr);
}/* end of function ObjectEnabled */

/*************************************************************************/
/* Function: EnableObjectInput                                           */
/*************************************************************************/
STDMETHODIMP CMFBar::EnableObjectInput(BSTR strObjectID, VARIANT_BOOL fEnable){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        return E_POINTER;
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
           
    bool fTmpEnable = VARIANT_FALSE == fEnable ? false: true;

    CContainerObject* pCnt;
    hr = pObj->GetContainerObject(&pCnt);

    if(FAILED(hr)){

        if(pObj->GetUnknown() == GetUnknown()){
            // special case when we are invalidating our self/ the self hosted container
            if(fTmpEnable){

                InvalidateRect(NULL, false);
            }/* end of if statement */
            pObj->SetInputEnabled(fTmpEnable);
            hr = S_OK;
            return(hr);
        }/* end of if statement */        

        if(NULL == pCnt){

            return(hr);
        }/* end of if statement */
    }/* end of if statemenet */

    if (pObj->IsInputEnabled() == fTmpEnable)
        return S_OK;

    pObj->SetInputEnabled(fTmpEnable);        

    if(false == fTmpEnable){

        LONG lRes = 0;
        SetClosestFocus(lRes);
        //MoveFocus(true, lRes);
        //SetObjectFocus(pObj, FALSE, lRes);

        if(pObj->HasCapture()){

            pCnt->SetCapture(FALSE);
        }/* end of if statement */
    }/* end of if statement */
    
    // invalidate area where the object lives
    if(pObj->IsWindowless()){

        // invalidate the rect only if we are windowless control
        // the windowed control shopuld be able
        // to update itself depending on the SW_SHOW, HIDE messagess
        hr = pCnt->InvalidateObjectRect();
    }/* end of if statement */

	return (hr);
}/* end of function EnableObjectInput */

/*************************************************************************/
/* Function: ObjectInputEnabled                                          */
/*************************************************************************/
STDMETHODIMP CMFBar::ObjectInputEnabled(BSTR strObjectID, VARIANT_BOOL *pfEnabled){

    HRESULT hr = E_FAIL;

    if(NULL == pfEnabled){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
    
    *pfEnabled = pObj->IsInputEnabled()? VARIANT_TRUE : VARIANT_FALSE;             

	return (hr);
}/* end of function ObjectInputEnabled */

/*************************************************************************/
/* Function: SetCookie                                                   */
/* Description: Sets a cookie to object, so it can be retrived later.    */
/*************************************************************************/
STDMETHODIMP CMFBar::SetCookie(BSTR strObjectID, VARIANT vCookie){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        return E_POINTER;
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
           
    pObj->SetCookie(vCookie);

	return (hr);
}/* end of function SetCookie */

/*************************************************************************/
/* Function: GetCookie                                                   */
/* Description: Gets help ID associated with the object.                 */
/*************************************************************************/
STDMETHODIMP CMFBar::GetCookie(BSTR strObjectID, VARIANT *pvCookie){

    HRESULT hr = E_FAIL;

    if(NULL == pvCookie){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
    
     hr = pObj->GetCookie(pvCookie);

	return (hr);
}/* end of function GetCookie */

/*************************************************************************/
/* Function: ForceKey                                                    */
/* Description: Forces the in the eventa handling code.                  */
/* The fEat disables or enables default key handler.                     */
/*************************************************************************/
STDMETHODIMP CMFBar::ForceKey(LONG lVirtKey, LONG lKeyData, VARIANT_BOOL fEat){

    m_fForceKey = true; // set the flag for key handler routine

    m_fEat = (fEat == VARIANT_FALSE ? VARIANT_FALSE : VARIANT_TRUE); // disable or enable this call
    m_lVirtKey = lVirtKey; // put in data
    m_lKeyData = lKeyData; // put in data

    return S_OK;
}/* end of function ForceKey */

/*************************************************************************/
/* Function: get_ScriptLanguage                                          */
/* Description: Gets current script language such as JScript, VBScript   */
/*************************************************************************/
STDMETHODIMP CMFBar::get_ScriptLanguage(BSTR *pstrScriptLanguage){

    if(NULL == pstrScriptLanguage){

        return(E_POINTER);
    }/* end of if statement */

    *pstrScriptLanguage = m_strScriptLanguage.Copy();
	return S_OK;
}/* end of function get_ScriptLanguage */

/*************************************************************************/
/* Function: put_ScriptLanguage                                          */
/* Description: Gets current script language such as JScript, VBScript   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_ScriptLanguage(BSTR strScriptLanguage){

    HRESULT hr = S_OK;

    if (m_ps){

        hr = E_FAIL;  // Already created the script engine, so it 
                      // will not take an effect untill we unload it
        return(hr);
    }/* end of if statement */
    
    m_strScriptLanguage = strScriptLanguage;
	
	return (hr);
}/* end of function put_ScriptLanguage */

/*************************************************************************/
/* Function: get_ScriptFile                                              */
/* Description: Gets the current script file.                            */
/* By default we have empty string which means loading from Windows      */
/* resources, which is not really a file.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::get_ScriptFile(BSTR *pstrScriptFile){

    if(NULL == pstrScriptFile){

        return(E_POINTER);
    }/* end of if statement */

    *pstrScriptFile = m_strScriptFile.Copy();	
	return S_OK;
}/* end of function get_ScriptFile */

/*************************************************************************/
/* Function: put_ScriptFile                                              */
/* Description: Sets the script file. Only valid before the load and     */
/* unload.                                                               */
/*************************************************************************/
STDMETHODIMP CMFBar::put_ScriptFile(BSTR strScriptFile){
	
	HRESULT hr = S_OK;

    try {

        if(VARIANT_TRUE == m_fAutoLoad){

            hr = DestroyScriptEngine();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_strScriptFile = strScriptFile;

            hr = Load();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

             const INT ciMaxBuffSize = MAX_PATH; // enough for the text
             TCHAR strBuffer[ciMaxBuffSize];
     
             if(!::LoadString(m_hRes, IDS_MAIN_ENTRY, strBuffer, ciMaxBuffSize)){

                 hr = E_UNEXPECTED;
                 return(hr);
             }/* end of if statement */

             USES_CONVERSION;
             hr = Run(T2OLE(strBuffer));

        } 
        else {

            // case when we are loading manually        


            if (m_ps){

                hr = E_FAIL;  // Already created the script engine, so it 
                              // will not take an effect untill we unload it
                throw(hr);
            }/* end of if statement */  

            m_strScriptFile = strScriptFile;        
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;      
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function put_ScriptFile */

/*************************************************************************/
/* IActiveScriptSiteWindow Interface Implementation                      */
/*************************************************************************/

/*************************************************************************/
/* Function: GetWindow                                                   */
/* Description:  Gets the window. If we are windowless we do not pass    */
/* down the parent window, since that seems to confuse the control       */
/*************************************************************************/
STDMETHODIMP CMFBar::GetWindow(HWND *phwndOut){

  HRESULT hr = S_OK;

  if (!phwndOut){

    hr = E_INVALIDARG;
    return (hr);
  }/* end of if statement */


  if(m_bWndLess){
      if(!::IsWindow(m_hWnd)){

          return(GetParentHWND(phwndOut));
      }/* end of if statement */
  }
  else {
      if(!::IsWindow(m_hWnd)){
          
          *phwndOut = NULL;
          hr = E_FAIL;
          return(hr);
      }/* end of if statement */
  }/* end of if statement */

  *phwndOut = m_hWnd;    
  
  return(hr);
}/* end of function GetWindow */

/*************************************************************************/
/* Function: EnableModeless                                              */
/* Description: Sets the window from which the UI elemnt can come out    */
/*************************************************************************/
STDMETHODIMP CMFBar::EnableModeless(BOOL fModeless){

    HRESULT hr = S_OK;

    if(m_hWnd == NULL){

        hr = E_NOTIMPL;
        return (hr);
    }/* end of if statement */

    ::EnableWindow(m_hWnd, fModeless);
    return(hr);
}/* end of function EnableModeless */

/*************************************************************************/
/* Function: get_MinWidth                                                */
/* Description: Gets the minimum width beyond which we do not resize.    */
/*************************************************************************/
STDMETHODIMP CMFBar::get_MinWidth(long *pVal){
	
	if(NULL == pVal){
        
        return(E_POINTER);
    }/* end of if statement */

    *pVal = m_lMinWidth;
	return S_OK;
}/* end of function get_MinWidth */

/*************************************************************************/
/* Function: put_MinWidth                                                */
/* Description: Puts the minimum width beyond which we do not resize.    */
/*************************************************************************/
STDMETHODIMP CMFBar::put_MinWidth(long newVal){

	m_lMinWidth = newVal;
	return S_OK;
}/* end of function put_MinWidth */

/*************************************************************************/
/* Function: get_MinWidth                                                */
/* Description: Gets the minimum height beyond which we do not resize.   */
/*************************************************************************/
STDMETHODIMP CMFBar::get_MinHeight(long *pVal){

    if(NULL == pVal){
        
        return(E_POINTER);
    }/* end of if statement */

    *pVal = m_lMinHeight;
	return S_OK;
}/* end of function get_MinHeight */

/*************************************************************************/
/* Function: put_MinHeight                                               */
/* Description: Sets the minimum height beyond which we do not resize.   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_MinHeight(long newVal){
	
    m_lMinHeight = newVal;
	return S_OK;
}/* end of function put_MinHeight */

// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####

/*************************************************************************/
/* Function: CreateScriptEngine                                          */
/* Description: Initializes the script engine.                           */
/*************************************************************************/
HRESULT CMFBar::CreateScriptEngine(){
  
    HRESULT hr = S_OK;

#ifndef _UNICODE  
    USES_CONVERSION;
#endif

    if (m_ps){

        hr = S_FALSE;  // Already created the script engine
        return(hr);    // so get out
    }/* end of if statement */  

    /*************************************************************************/
    /* add (this) the container as a scriptable object as well               */
    /* this is special case so we can call script on our self as well        */
    /*************************************************************************/
    const INT ciMaxBuffSize = MAX_PATH; // should be enough for tlbr ID, keep ID small if can
    TCHAR strBuffer[ciMaxBuffSize];
    
    if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IUnknown> pUnk = GetUnknown();
    CComQIPtr<IDispatch> pDisp (pUnk);    
    
    if(!pDisp){
        
        return(hr);
    }/* end of if statement */

#ifdef _UNICODE  
    BSTR strObjectID = ::SysAllocString(strBuffer); // gets freed in the destructor of the holding object    
#else
    BSTR strObjectID = ::SysAllocString(T2OLE(strBuffer));
#endif

    hr = AddObject(strObjectID, pDisp); // this one adds the object to the list as well

    ::SysFreeString(strObjectID); // free up the sys string, since we allocate it in the contructor for the object

    if(FAILED(hr)){
                
        return(hr);
    }/* end of if statement */
    
    if(!m_strScriptLanguage){
         // load what script language we decided to support if not set explicitly by user
        if(!::LoadString(m_hRes, IDS_SCRIPT_LANGUAGE, strBuffer, ciMaxBuffSize)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

        m_strScriptLanguage = strBuffer;
    }/* end of if statement */

    CLSID clsid;

    hr = ::CLSIDFromProgID(m_strScriptLanguage, &clsid); // get the language

    if(FAILED(hr)){

	    return hr;
    }/* end of if statement */

    hr = m_ps.CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER);
    // Create the ActiveX Scripting Engine
    //hr = ::CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&m_ps);
    if (FAILED(hr)){

        //s_pszError = "Creating the ActiveX Scripting engine failed.  Scripting engine is probably not correctly registered or CLSID incorrect.";
        return (hr);
    }/* end of if statement */

    // Script Engine must support IActiveScriptParse for us to use it
    hr = m_ps->QueryInterface(IID_IActiveScriptParse, (void**) &m_psp);

    if (FAILED(hr)){

        //s_pszError = "ActiveX Scripting engine does not support IActiveScriptParse";
        return (hr);
    }/* end of if statement */

    hr = m_ps->SetScriptSite(this);

    if(FAILED(hr)){

        return hr;
    }/* end of if statement */

    // InitNew the object:
    hr = m_psp->InitNew();

    if(FAILED(hr)){

        return hr;
    }/* end of if statement */

    // Adding dynamically added items so they can be recognized by name
    // and scripted via script language such as VBScript or JScript
    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        // iterate throw the array and see if we find matching ID
        CHostedObject* pObj = (*i);

        hr = m_ps->AddNamedItem((pObj)->GetID(), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);

        if(FAILED(hr)){

            return(hr); // might want to modify this later to not exit if we get one bad object
        }/* end of if statement */    
    }/* end of for loop */
   
    // Special case adding the root object
    if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

#ifdef _UNICODE
    hr = m_ps->AddNamedItem(strBuffer, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
#else
    hr = m_ps->AddNamedItem(A2W(strBuffer), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
#endif

    // Add up the events that we have saved in the event array
    for(CNTEVNT::iterator j = m_cntEvnt.begin(); j!= m_cntEvnt.end(); j++){

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));

        BSTR strName;
        CEventObject* pObj = (*j);

        hr = m_psp->AddScriptlet(NULL, pObj->m_strEventCode, pObj->m_strObjectID, NULL, pObj->m_strEvent, NULL, 0, 0,  0, &strName, &ei);

        if(FAILED(hr)){

            ATLTRACE(TEXT("Failed to add an event, might be using a different language or the object does not exists. \n"));
            ATLASSERT(FALSE);
            return(hr);
        }/* end of if statement */  
    }/* end of for loop */

    return (hr);
}/* end of function CreateScriptEngine */

/*************************************************************************/
/* Function: DestroyScriptEngine                                         */
/* Description: Destroys the engine. Might be usefull when using one     */
/* script to initialize the objects and the other script to run the      */
/* objects.                                                              */
/*************************************************************************/
STDMETHODIMP CMFBar::DestroyScriptEngine(){

    HRESULT hr = S_OK;

    if(m_ps){

        hr = m_ps->SetScriptState(SCRIPTSTATE_DISCONNECTED);
    }/* end of if statement */
   
    // Release the language engine, since it may hold on to us
    if (m_psp){
        
        m_psp.Release();        
    }/* end of if statement */

    if (m_ps){

        //HRESULT hrTmp = m_ps->InterruptScriptThread(SCRIPTTHREADID_CURRENT, NULL, SCRIPTINTERRUPT_DEBUG);
        //ATLASSERT(SUCCEEDED(hrTmp));
        
        hr = m_ps->Close();

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */
                
        m_ps.Release();
    }/* end of if statement */

	return (hr);
}/* end of function DestroyScriptEngine */

/*************************************************************************/
/* Function: Load                                                        */
/* Description: Loads the script.                                        */
/*************************************************************************/
STDMETHODIMP CMFBar::Load(){

//#ifndef _UNICODE_SCRIPT_FILE 
    USES_CONVERSION;
//#endif

    HRESULT hr = CreateScriptEngine();

    if(FAILED(hr)){

        ATLTRACE(TEXT("Failed to create a script engine.\n")); 
        ATLASSERT(FALSE);
        return(hr);
    }/* end of if statement */

    // see if we can find this resource DLL in the script
//    TCHAR* strType = TEXT("SCRIPT");

    LPTSTR strTemp = OLE2T(m_strScriptFile);

    if (NULL == strTemp)
    {
        hr = E_POINTER;
        return hr;
    }

    HRSRC hrscScript = ::FindResource(m_hRes, strTemp, MAKEINTRESOURCE(23));
    
    if(NULL != hrscScript){
        
        /**********************************************************************/
        /* load up the script from a resource                                 */
        /**********************************************************************/

        if(NULL == hrscScript){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }/* end of if statement */

        HGLOBAL hScript = ::LoadResource(m_hRes, hrscScript); 

        if(NULL == hScript){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }/* end of if statement */
    
        DWORD dwSize = ::SizeofResource((HMODULE)m_hRes, hrscScript);

        if(dwSize == 0){
        
            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

        /*****************************************************************/
        /* change this depending if the file was saved as Unicode or not */
        /*****************************************************************/
    #ifndef _UNICODE_SCRIPT_FILE 
        WCHAR* strCode = A2W((CHAR*)hScript);
        //delete[] hScript; // free up the temp buffer
    #else        
        // work around script engine bug which does not recognize termination string
        BSTR strCode = ::SysAllocStringLen((WCHAR*)hScript+ 1,dwSize / (sizeof(WCHAR) /sizeof(BYTE)) - 1);    
        ATLASSERT(strCode[dwSize / (sizeof(WCHAR) /sizeof(BYTE)) - 1] == 0x0000);
        //strCode ++; // skip the word that indicates the byte order
    #endif

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));
        hr = m_psp->ParseScriptText(strCode, NULL, NULL, NULL, 0, 0, SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE, NULL, &ei);
        
        #ifdef _UNICODE_SCRIPT_FILE 
            ::SysFreeString(strCode);            
        #endif

    }
    else {
        /**********************************************************************/
        /* load up the script from a file                                     */
        /**********************************************************************/
        // Create File m_strScriptFile
        HANDLE hFile = ::CreateFile(
	                        OLE2T(m_strScriptFile),    // pointer to name of the file
	                        GENERIC_READ,   // access (read-write) mode
	                        FILE_SHARE_READ,    // share mode
	                        NULL,   // pointer to security descriptor
	                        OPEN_EXISTING,  // how to create
	                        FILE_ATTRIBUTE_NORMAL,  // file attributes
	                        NULL    // handle to file with attributes to copy
                           );

        if(hFile == INVALID_HANDLE_VALUE){

            hr = HRESULT_FROM_WIN32(::GetLastError());

            #if _DEBUG
    
                TCHAR strBuffer[MAX_PATH + 25];
                wsprintf(strBuffer, TEXT("Failed to open script file %s"), OLE2T(m_strScriptFile));
                ::MessageBox(::GetFocus(), strBuffer, TEXT("Error"), MB_OK);
            #endif            
            return(hr);
        }/* end of if statement */

        DWORD dwBitsSize = GetFileSize(hFile,NULL);

        if(0 == dwBitsSize){

            hr = E_UNEXPECTED;
            return(hr); // the file size should be definetly more then 0
        }/* end of if statement */

        BYTE* pbBuffer = new BYTE[dwBitsSize + sizeof(WCHAR)];
        ::ZeroMemory(pbBuffer, dwBitsSize + sizeof(WCHAR));

        // load it up convert the text to UNICODE
        DWORD dwBytesRead = 0;

        if(!ReadFile(hFile, pbBuffer, dwBitsSize, &dwBytesRead, NULL)){

            hr = HRESULT_FROM_WIN32(::GetLastError());
	        delete[] pbBuffer;            
            ::CloseHandle(hFile); // close the file
		    return (hr);
    	}/* end of function ReadFile */

        if(dwBitsSize != dwBytesRead){

           ATLTRACE(TEXT("Implement reading loop"));
           delete[] pbBuffer; // free up the temp buffer
           ::CloseHandle(hFile); // close the file
           hr = E_UNEXPECTED;
           return(hr);
        }/* end of if statement */

        /*****************************************************************/
        /* change this depending if the file was saved as Unicode or not */
        /*****************************************************************/
    #ifndef _UNICODE_TEST_SCRIPT_FILE 
        WCHAR* strCode = A2W((CHAR*)pbBuffer);
        delete[] pbBuffer; // free up the temp buffer
    #else        
        WCHAR* strCode = (WCHAR*)pbBuffer;
    #endif
        ::CloseHandle(hFile); // close the file

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));

        #ifdef _UNICODE
            hr = m_psp->ParseScriptText(strCode, NULL, NULL, NULL, 0, 0, SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE, NULL, &ei);
        #else
            hr = m_psp->ParseScriptText(strCode, NULL, NULL, NULL, 0, 0, SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE, NULL, &ei);
        #endif
    }/* end of if statement */

    // take out the extra character at the begining of the unicode file just in case it is garbled by editor
    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

	hr = m_ps->SetScriptState(/* SCRIPTSTATE_STARTED */ SCRIPTSTATE_CONNECTED);

	return hr;
}/* end of function Load */

/*************************************************************************/
/* Function: AddScriptlet                                                */
/* Description: Using this method you can add events for JScript and     */
/* other languages that do not support event handlers internally. This   */
/* method just add these to the array which does get initializied on load*/
/*************************************************************************/
STDMETHODIMP CMFBar::AddScriptlet(BSTR strObjectID, BSTR strEvent, BSTR strEventCode){

    HRESULT hr = S_OK;

    CEventObject* pObj = new CEventObject(strObjectID, strEvent, strEventCode);
    
    if(NULL == pObj){

        hr = E_OUTOFMEMORY;
        return(hr);
    }/* end of if statement */

    m_cntEvnt.insert(m_cntEvnt.end(), pObj);

	return(hr);
}/* end of function AddScriptlet */

/*************************************************************************/
/* Function: HookScriptlet                                               */
/* Description: Hooks the scrtiptlet for immidiate use, unlike the       */
/* Add scriptlet which adds it, so it takes effect in the next Load.     */
/* However, it also adds the callback to the array, so if needs to be    */
/* loaded on the next load.                                              */
/*************************************************************************/
STDMETHODIMP CMFBar::HookScriptlet(BSTR strObjectID, BSTR strEvent, BSTR strEventCode){

    HRESULT hr = S_OK;

    try {

        hr = AddScriptlet(strObjectID, strEvent, strEventCode);

        if(!m_ps){
        
            ATLTRACE(TEXT("No Script Engine!! No Run!!\n")); 
            ATLASSERT(FALSE);
            throw(S_FALSE);
        }/* end of if statement */

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));

        BSTR strName;

        hr = m_ps->SetScriptState(SCRIPTSTATE_STARTED);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_psp->AddScriptlet(NULL, strEventCode, strObjectID, NULL, strEvent, NULL, 0, 0,  0, &strName, &ei);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_ps->SetScriptState(SCRIPTSTATE_CONNECTED);
              
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function HookScriptlet */

/*************************************************************************/
/* Function: Run                                                         */
/* Description: Runs the Script function. Right now I do not support     */
/* TODO: parameters, but they can be added, by handling VARIANT.         */
/*************************************************************************/
STDMETHODIMP CMFBar::Run(BSTR strStatement){

    HRESULT hr = E_FAIL;

    if(!m_ps){
        
        ATLTRACE(TEXT("No Script Engine!! No Run!!\n")); 
        ATLASSERT(FALSE);
        return(hr);
    }/* end of if statement */

    CComPtr<IDispatch> pDispatch;

    hr = m_ps->GetScriptDispatch(NULL, &pDispatch);

    if (FAILED(hr)){

        return(hr);
    }/* end of if statement */
	    
    DISPID dispidMain;

    LCID lcid = ::GetUserDefaultLCID();
    hr = pDispatch->GetIDsOfNames(IID_NULL, &strStatement, 1, lcid, &dispidMain);
    
    if (hr == ResultFromScode(DISP_E_UNKNOWNNAME))
	    hr = NOERROR;
    else if (FAILED(hr))
	    hr = E_UNEXPECTED;
    else{

	    UINT uArgErr;
	    DISPPARAMS params;
	    EXCEPINFO ei;

	    params.cArgs = 0;
	    params.cNamedArgs = 0;
	    params.rgvarg = NULL;
	    params.rgdispidNamedArgs = NULL;

	    hr = pDispatch->Invoke(dispidMain, IID_NULL, lcid, DISPATCH_METHOD,
						       &params,NULL, &ei, &uArgErr);
        if (FAILED(hr)){
            
		    return(hr);
	    }/* end of if statement */
        
    }/* end of if statement */

#ifdef _DEBUG    
    ULONG ulcstmt = 0;

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    CComQIPtr<IActiveScriptStats> pstat(m_ps);
   
    if (pstat){
        ULONG luT;
        if (FAILED(pstat->GetStat(SCRIPTSTAT_STATEMENT_COUNT, &luT, &ulcstmt)))
	        ulcstmt = 0;            
    }/* end of if statement */

    ATLTRACE("Statments executed %d\n", ulcstmt);
#endif

    return(hr);
}/* end of function Run */

/*************************************************************************/
/* Function: CreateObject                                                */
/* Description: Creates a new ActiveX object that can be scripted.       */
/* Puts the newly created object into container and activates it.        */
/*************************************************************************/
STDMETHODIMP CMFBar::CreateObject(BSTR strID, BSTR strProgID, 
                                  long lx, long ly, long lWidth, long lHeight,
                                  BSTR strPropBag, VARIANT_BOOL fDisabled,
                                  BSTR strScriptHook){

    HRESULT hr;
	CHostedObject *pObj = NULL; // an ActiveX object

    try {

        hr = FindObject(strID, &pObj);
        
        if(SUCCEEDED(hr)){

            ATLTRACE(TEXT("Duplicate Object \n!"));
            throw(E_FAIL);
        }/* end of if statement */

        // create the object
        hr = CHostedObject::CreateObject(strID, strProgID, strPropBag, &pObj);
       
        if(FAILED(hr)){

            ATLTRACE2(atlTraceHosting, 2, TEXT("Failed to Create Object %ls \n"), strID);
            throw(hr);
        }/* end of if statement */

        // initialize inPlaceObject
        CComPtr<IUnknown> pObjectUnknown;
        pObjectUnknown = pObj->GetUnknown();
        
        // Get this container unknown
        CComPtr<IUnknown> pContainerUnknown;
        pContainerUnknown = GetUnknown();

        if(!pContainerUnknown){

            throw(hr);
        }/* end of if statement */
        
        // this is just a container that delegates pretty
        // much all the methods to this container
        // only purpose for its being is that we need to connection
        // between the container and a specific object
        // for SetCapture and SetFocus calls

        CContainerObject* pContainerObj = new CContainerObject(pContainerUnknown, pObj);
        pContainerUnknown.Release();

        if(NULL == pContainerObj){

            throw(E_OUTOFMEMORY);
        }/* end of if statement */

        pObj->SetContainerObject(pContainerObj);

        CComPtr<IUnknown> pUnkContainerObj;
        
        hr = pContainerObj->QueryInterface(IID_IUnknown, (void**)&pUnkContainerObj);
                
        if(FAILED(hr)){

            hr = E_FAIL;
            throw(hr);
        }/* end of if statement */

        // insert it at the end of the list
        // TODO: eventually check for duplicate IDs
        m_cntObj.insert(m_cntObj.end(), pObj);
        // add our self to the script engine, so we can hook up the events
        HRESULT hrTmp = m_ps->AddNamedItem((pObj)->GetID(), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);

        if(FAILED(hrTmp)){

            ATLTRACE(TEXT("Engine is not initilized yet, but that is what I guess we intended\n"));
            ATLASSERT(FALSE);
        }/* end of if statement */
        
        CComPtr<IOleObject> pOleObject;
        HRESULT hrOle = pObj->GetOleObject(&pOleObject);

        if(SUCCEEDED(hrOle)){

            DWORD dwMiscStatus;
            pOleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);

             // set the OLE site
            CComPtr<IOleClientSite> spClientSite;
        
            hr = pUnkContainerObj->QueryInterface(&spClientSite);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

			if(dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST){

				pOleObject->SetClientSite(spClientSite); // set the client site
			}/* end of if statement */

            // no property bag so try to initialze from stream
            CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI(pOleObject);
            
            // TODO: Eventaully load up stream via CreateStreamOnHGlobal
            
            if (spPSI)
                spPSI->InitNew(); // create new stream
            

            // see if want to use the IPropertyBag to initialize our properties
            CComQIPtr<IPersistPropertyBag, &IID_IPersistPropertyBag> pBag(pObjectUnknown);

            if (pBag) {
                CComQIPtr<IPropertyBag, &IID_IPropertyBag> pSBag(pUnkContainerObj);
                
                if(!pSBag){
                    
                    ATLTRACE2(atlTraceHosting, 0, _T("Could not get IPropertyBag.\r\n"));
                    ATLASSERT(FALSE);
                    throw(E_UNEXPECTED);
                }/* end of if statement */
                
                HRESULT hrTmp = pBag->Load(pSBag, NULL);
                
                if(SUCCEEDED(hrTmp)){
                    
                    pBag->Save(pSBag, FALSE, TRUE);
                }/* end of if statement */
            }/* end of if statement */
            
            if(0 == (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)){

				pOleObject->SetClientSite(spClientSite); // set the client site
			}/* end of if statement */

            pObj->InitViewObject(); // cache view object

            // hook up sink/notify for events
            // via this call in which we have chance to hook them up
            if(NULL != *strScriptHook){
                          
                HRESULT hrTmp = Run(strScriptHook);

                if(FAILED(hrTmp)){

                    ATLTRACE(TEXT("Engine is not initilized yet, but that is what I guess we intended\n"));
                    ATLASSERT(FALSE);
                }/* end of if statement */
            }/* end of if statement */
        
            // Get the extents adjust them etc...
            // TODO enhance this to handle generic size
            RECT rcPos;

            SIZEL sSize, shmSize;            
			sSize.cx = lWidth;
			sSize.cy = lHeight;
			AtlPixelToHiMetric(&sSize, &shmSize);

			pOleObject->SetExtent(DVASPECT_CONTENT, &shmSize);
			pOleObject->GetExtent(DVASPECT_CONTENT, &shmSize);
			AtlHiMetricToPixel(&shmSize, &sSize);

            // TODO: handle the moves on SetObjectRects
            // right now we set offset once but this needs to be eventaully done

            rcPos.left   = lx; // use m_rcPos for the offsets these any time we get SetObjectRects call
            rcPos.top    = ly;
			rcPos.right  = rcPos.left + sSize.cx;
			rcPos.bottom = rcPos.top + sSize.cy;
            
            // TODO: we might want to wait till our rect is set 
            // and then let the script to go at it, that way we reduce the moves
            // and possible flashes
            pObj->SetRawPos(&rcPos); // remember our new position raw position

            //pObj->SetOffset(&m_rcPos.left, &m_rcPos.top); // sets the pointers to the offset

            //pObj->GetPos(&rcPos); // get the position back with adjusted rect
            
            
            // IN_PLACE ACTIVATE
			hrOle = pOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &rcPos);			                                  

            if(VARIANT_FALSE != fDisabled){	        

              pObj->SetActive(false);
            }/* end of if statement */

        }
        else {
            // use the liter interface when IOleObject is not available            
            CComQIPtr<IObjectWithSite> spSite(pObjectUnknown);
		    
            if(spSite){

			    spSite->SetSite(pUnkContainerObj);
            }/* end of if statement */
        }/* end of if statement */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
        // cleanup our variables just in case
        if(NULL != pObj){

            delete pObj;
        }/* end of if statement */
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function CreateObject */

/*************************************************************************/
/* Function: ShowSelfSite                                                */
/* Description: Show itself as an site for itself.                       */
/*************************************************************************/
STDMETHODIMP CMFBar::ShowSelfSite(long nCmd)
{
    if (::IsWindow(m_hWnd)) {
        if (NULL != m_pBackBitmap)
            m_pBackBitmap->DeleteMemDC();

#if 0
        long extStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);

        if (nCmd == SW_MAXIMIZE) {
            extStyle |= WS_EX_TOPMOST;
        }
        else {
            extStyle &= ~WS_EX_TOPMOST;
        }

        ::SetWindowLong(m_hWnd, GWL_EXSTYLE, extStyle);
#endif
        ::ShowWindow(m_hWnd, nCmd);

        InvalidateRgn();
    }
    return S_OK;
}

/*************************************************************************/
/* Function: SetupSelfSite                                               */
/* Description: Sets itself as an site for itself.                       */
/*************************************************************************/
STDMETHODIMP CMFBar::SetupSelfSite(long lx, long ly, long lWidth, 
                                   long lHeight, BSTR strPropBag,
                                   VARIANT_BOOL fDisabled,
                                   VARIANT_BOOL fHelpDisabled,
                                   VARIANT_BOOL fWindowDisabled){
	
    HRESULT hr;
	CHostedObject *pObj = NULL; // an ActiveX object

    try {
        if(true == m_fSelfHosted){
            // we are already hosting our self so do not try to do so again
            throw(S_FALSE);
        }/* end of if statement */

        if(m_nReadyState == READYSTATE_COMPLETE){

            throw(S_FALSE); //we are already hosted (most likely IE)
        }/* end of if statement */

        m_bWindowOnly = TRUE; // create self as a window
        m_fSelfHosted = true; // we are trying to self host so send a QUIT message
        
        CComPtr<IDispatch> pDisp;
        hr = GetUnknown()->QueryInterface(&pDisp);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        const INT ciMaxBuffSize = MAX_PATH; // should be enough for tlbr ID, keep ID small if can
        TCHAR strBuffer[ciMaxBuffSize];
    
        if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

#ifndef _UNICODE
        USES_CONVERSION;        
        BSTR strObjectID = ::SysAllocString(T2W(strBuffer));

#else
        BSTR strObjectID = ::SysAllocString(strBuffer);
#endif

        hr = CHostedObject::AddObject(strObjectID, strPropBag, pDisp, &pObj);
        // strPropBag gets allocated as well
        ::SysFreeString(strObjectID);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // initialize inPlaceObject
        CComPtr<IUnknown> pObjectUnknown;
        pObjectUnknown = pObj->GetUnknown();

        // Get this container unknown
        CComPtr<IUnknown> pContainerUnknown;
        pContainerUnknown = GetUnknown();

        if(!pContainerUnknown){

            throw(hr);
        }/* end of if statement */
        
        // this is just a container that delegates pretty
        // much all the methods to this container
        // only purpose for its being is that we need to connection
        // between the container and a specific object
        // for SetCapture and SetFocus calls

        CContainerObject* pContainerObj = new CContainerObject(pContainerUnknown, pObj);
        pContainerUnknown.Release();

        if(NULL == pContainerObj){

            throw(E_OUTOFMEMORY);
        }/* end of if statement */

        pObj->SetContainerObject(pContainerObj);

        CComPtr<IUnknown> pUnkContainerObj;
        
        hr = pContainerObj->QueryInterface(IID_IUnknown, (void**)&pUnkContainerObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // DO NOT INSERT THIS OBJECT, SINCE IT IS OUR CONTAINER
        // m_cntObj.insert(m_cntObj.end(), pObj);
        
        CComPtr<IOleObject> pOleObject;
        HRESULT hrOle = pObj->GetOleObject(&pOleObject);

        if(FAILED(hrOle)){

            throw(hrOle);
        }/* end of if statement */
        
        DWORD dwMiscStatus;
        pOleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);

         // set the OLE site
        CComPtr<IOleClientSite> spClientSite;
    
        hr = pUnkContainerObj->QueryInterface(&spClientSite);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

		if(dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST){

			pOleObject->SetClientSite(spClientSite); // set the client site
		}/* end of if statement */

        // no property bag so try to initialze from stream
        CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI(pOleObject);
        
        // TODO: Eventaully load up stream via CreateStreamOnHGlobal
        
        if (spPSI)
            spPSI->InitNew(); // create new stream
        
        // see if want to use the IPropertyBag to initialize our properties
        CComQIPtr<IPersistPropertyBag, &IID_IPersistPropertyBag> pBag(pObjectUnknown);

        if (pBag) {
            CComQIPtr<IPropertyBag, &IID_IPropertyBag> pSBag(pUnkContainerObj);
            
            if(!pSBag){
                
                ATLTRACE2(atlTraceHosting, 0, _T("Could not get IPropertyBag.\r\n"));
                ATLASSERT(FALSE);
                throw(E_UNEXPECTED);
            }/* end of if statement */
            
            HRESULT hrTmp = pBag->Load(pSBag, NULL);
            
            if(SUCCEEDED(hrTmp)){
                
                pBag->Save(pSBag, FALSE, TRUE);
            }/* end of if statement */
        }/* end of if statement */
        
        if(0 == (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)){

			pOleObject->SetClientSite(spClientSite); // set the client site
		}/* end of if statement */

        pObj->InitViewObject(); // cache view object

        // TODO: hook up sink/notify for events

        // Get the extents adjust them etc...
        // TODO enhance this to handle generic size
        RECT rcPos;

        SIZEL sSize, shmSize;            
		sSize.cx = lWidth;
		sSize.cy = lHeight;
		AtlPixelToHiMetric(&sSize, &shmSize);

		pOleObject->SetExtent(DVASPECT_CONTENT, &shmSize);
		pOleObject->GetExtent(DVASPECT_CONTENT, &shmSize);
		AtlHiMetricToPixel(&shmSize, &sSize);

        // TODO: handle the moves on SetObjectRects
        // right now we set offset once but this needs to be eventaully done        

        rcPos.left   = lx; // use m_rcPos for the offsets these any time we get SetObjectRects call
        rcPos.top    = ly;
		rcPos.right  = rcPos.left + sSize.cx;
		rcPos.bottom = rcPos.top + sSize.cy;
        
        RECT rcClientRect;

        rcClientRect.left   = 0; // use m_rcPos for the offsets these any time we get SetObjectRects call
        rcClientRect.top    = 0;
		rcClientRect.right  = sSize.cx;
		rcClientRect.bottom = sSize.cy;
        
        // TODO: we might want to wait till our rect is set 
        // and then let the script to go at it, that way we reduce the moves
        // and possible flashes

        pObj->SetRawPos(&rcPos); // remember our new position raw position

        // adjust rects
        // IN_PLACE ACTIVATE OUR SELF ACTIVATION VERSION

        if (m_spClientSite == NULL)
		    return S_OK;

	    CComPtr<IOleInPlaceObject> pIPO;
	    ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	    ATLASSERT(pIPO != NULL);

        m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void**)&m_spInPlaceSite);
		if (m_spInPlaceSite)
			m_bInPlaceSiteEx = TRUE;
		else
			hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void**) &m_spInPlaceSite);

	    ATLASSERT(m_spInPlaceSite);
	    if (!m_spInPlaceSite)
		    throw(E_FAIL);

	    m_bNegotiatedWnd = TRUE;

	    if (!m_bInPlaceActive){

		    BOOL bNoRedraw = FALSE;
		    if (m_bInPlaceSiteEx)
				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
			else
			{
				hr = m_spInPlaceSite->CanInPlaceActivate();
				// CanInPlaceActivate returns S_FALSE or S_OK
				if (FAILED(hr))
					throw(hr);
				if ( hr != S_OK )
				{
				   // CanInPlaceActivate returned S_FALSE.
				   throw( E_FAIL );
				}
				m_spInPlaceSite->OnInPlaceActivate();
			}		        
	    }/* end of if statement */

	    m_bInPlaceActive = TRUE;

	    // get location in the parent window,
	    // as well as some information about the parent
	    //
	    OLEINPLACEFRAMEINFO frameInfo;
	    
	    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

	    if (!m_bWndLess){

            DWORD dwStyle;
            DWORD dwExStyle;
            HWND hwndPar = NULL;

            
            if(VARIANT_FALSE == fWindowDisabled){
                // one with the frame
                 dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
                 dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
            }
            else {
                // one without the frame
                dwStyle =  WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |WS_SYSMENU| WS_MAXIMIZEBOX| WS_MINIMIZEBOX ;
                //dwExStyle = WS_EX_TRANSPARENT; //| WS_EX_LTRREADING| WS_EX_WINDOWEDGE;
                //dwExStyle = 0x00080000; //WS_EX_LAYERED = 0x00080000;
                dwExStyle = WS_EX_APPWINDOW;
                //hwndPar = ::GetDesktopWindow();
            }/* end of if statement */

            if(VARIANT_FALSE == fDisabled){

                dwStyle |= WS_VISIBLE;                
            }/* end of if statement */            

            if(VARIANT_FALSE == fHelpDisabled){

                dwStyle &= ~(WS_MINIMIZEBOX | WS_MAXIMIZEBOX); // take out the min max style
                            // help does not work with it
                dwExStyle |=  WS_EX_CONTEXTHELP;
            }/* end of if statement */

#ifdef _UNICODE
            HWND h = Create(hwndPar, rcPos, m_bstrCaption /* window name */, dwStyle, dwExStyle);
#else
            USES_CONVERSION;
            HWND h = Create(hwndPar, rcPos, OLE2T(m_bstrCaption) /* window name */, dwStyle, dwExStyle);
#endif
            
            //  used instead of 
			//  HWND h = CreateControlWindow(hwndParent, rcPos);
			ATLASSERT(h != NULL);	// will assert if creation failed
			ATLASSERT(h == m_hWndCD);
			if(NULL == h){

                throw(E_FAIL);
            }/* end of if statement */

            if(VARIANT_TRUE == fWindowDisabled){

                ::SendMessage(h, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) m_hIcon);
                ::SendMessage(h, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM) m_hIcon);
            }/* end of if statement */

	    }/* end of if statement */

        if(VARIANT_FALSE != fDisabled){	        

          pObj->SetActive(false);
        }/* end of if statement */
        
        if (m_hMenu) {
            ::DestroyMenu(m_hMenu);
            m_hMenu = NULL;
        }

        // Create the system menu
        m_hMenu = ::LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_SYSMENU));
        
        MENUINFO mInfo;
        mInfo.cbSize = sizeof(MENUINFO);
#if(WINVER >= 0x0500)
        ::GetMenuInfo(::GetSubMenu(m_hMenu, 0), &mInfo);
#else
        CallGetMenuInfo(::GetSubMenu(m_hMenu, 0), &mInfo);
#endif
        
        mInfo.dwStyle = MNS_NOCHECK;
        mInfo.fMask = MIM_STYLE;
#if(WINVER >= 0x0500)
        ::SetMenuInfo(::GetSubMenu(m_hMenu, 0), &mInfo);
#else
        CallSetMenuInfo(::GetSubMenu(m_hMenu, 0), &mInfo);
#endif
        
#if(WINVER >= 0x0500)
        MENUITEMINFO iInfo;
        iInfo.cbSize = sizeof(MENUITEMINFO);
#else
        MENUITEMINFOInternal iInfo;
        iInfo.cbSize = sizeof(MENUITEMINFOInternal);
#endif
        
        ::GetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_RESTORE, false, (LPMENUITEMINFO)&iInfo);
        iInfo.hbmpItem = HBMMENU_POPUP_RESTORE;
        iInfo.fMask = MIIM_BITMAP;
        ::SetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_RESTORE, false, (LPCMENUITEMINFO)&iInfo);
        
        ::GetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_MINIMIZE, false, (LPMENUITEMINFO)&iInfo);
        iInfo.hbmpItem = HBMMENU_POPUP_MINIMIZE;
        iInfo.fMask = MIIM_BITMAP;
        ::SetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_MINIMIZE, false, (LPCMENUITEMINFO)&iInfo);
        
        ::GetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_MAXIMIZE, false, (LPMENUITEMINFO)&iInfo);
        iInfo.hbmpItem = HBMMENU_POPUP_MAXIMIZE;
        iInfo.fMask = MIIM_BITMAP;
        ::SetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_MAXIMIZE, false, (LPCMENUITEMINFO)&iInfo);
        
        ::GetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_CLOSE, false, (LPMENUITEMINFO)&iInfo);
        iInfo.hbmpItem = HBMMENU_POPUP_CLOSE;
        iInfo.fMask = MIIM_BITMAP|MIIM_STATE;
        iInfo.fState = MFS_DEFAULT;
        ::SetMenuItemInfo(::GetSubMenu(m_hMenu, 0), ID_SYSTEMMENU_CLOSE, false, (LPCMENUITEMINFO)&iInfo);


    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
        m_fSelfHosted = false;
        // cleanup our variables just in case
        if(NULL != pObj){

            delete pObj;
        }/* end of if statement */
    }
    catch(...){        
        m_fSelfHosted = false;
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SetupSelfSite */

/*************************************************************************/
/* Function: AddObject                                                   */
/* Description: Adds a scriptable only object that was created somewhere */
/* else into our object container.                                       */
/*************************************************************************/
STDMETHODIMP CMFBar::AddObject(BSTR strObjectID, LPDISPATCH pDisp){

    HRESULT hr;
	CHostedObject *pObj = NULL; // an ActiveX object

    try {
        // add an object that was already created
        // this object does not get the Active flag set which
        // means we will not try to draw it and do other
        // activities on it, such as we would do on the objects
        // that are contained and have a site
        hr = CHostedObject::AddObject(strObjectID, NULL, pDisp, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // now add the object to the container
        // insert it at the end of the list
        // TODO: eventually check for duplicate IDs
        m_cntObj.insert(m_cntObj.end(), pObj);

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
        // cleanup our variables just in case
        if(NULL != pObj){

            delete pObj;
        }/* end of if statement */
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function AddObject */

// #####  END  ACTIVEX SCRIPTING SUPPORT #####

/*************************************************************************/
/* Function: GetParentHWND                                               */
/* Description: Gets the parent window HWND where we are operating.      */
/*************************************************************************/
HRESULT CMFBar::GetParentHWND(HWND* pWnd){

    HRESULT hr = E_FAIL;
    *pWnd = NULL;

    if(m_bWndLess){

        CComPtr<IOleClientSite> pClientSite;

        hr = GetClientSite(&pClientSite);

        if(FAILED(hr)){

		    return(hr);	
        }/* end of if statement */

        CComQIPtr<IOleWindow> pOleWindow(pClientSite);
    
        if(!pOleWindow){

            hr = E_FAIL;
		    return(hr);	
        }/* end of if statement */

        hr = pOleWindow->GetWindow(pWnd);        
    }
    else {

        if(::IsWindow(m_hWnd)){

            *pWnd = ::GetParent(m_hWnd);
            if(::IsWindow(*pWnd)){

                hr = S_OK;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    return(hr);
}/* end of function GetParentHWND */

/*************************************************************************/
/* Function: GetClientRect                                               */
/* Description:  Gets the client rect. If we are windowless we pass down */
/* the m_rcPos.                                                          */
/*************************************************************************/
BOOL CMFBar::GetClientRect(LPRECT lpRect) const{

  BOOL bRet = TRUE;

  if (!lpRect){

    bRet = FALSE;
    return (bRet);
  }/* end of if statement */

  if(m_bWndLess){
      
      *lpRect = m_rcPos;
      return(bRet);
  }/* end of if statement */

  ATLASSERT(::IsWindow(m_hWnd));
  bRet = ::GetClientRect(m_hWnd, lpRect);
      
  return(bRet);
}/* end of function GetClientRect */

/*************************************************************************/
/* Function: GetParent                                                   */
/* Description:  Gets the parent window. If we are windowless we pass    */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HWND CMFBar::GetParent(){

  HWND hwnd = NULL;

  if(m_bWndLess){

      GetParentHWND(&hwnd);
      return(hwnd);
  }/* end of if statement */

  ATLASSERT(::IsWindow(m_hWnd));
  return ::GetParent(m_hWnd);
}/* end of function GetParent */

/*************************************************************************/
/* Function: AdjustRects                                                 */
/* Description: calls all our contained objects and the adjusts their    */
/* rects in the case we have moved, if we do not have any that is OK,    */
/* since the offset is kept in m_rcPos and set whenever the objects      */
/* get created.                                                          */
/*************************************************************************/
HRESULT CMFBar::AdjustRects(const LPCRECT prcPos){

    HRESULT hr = S_OK;

    //TODO: handle resizing
    ATLTRACE2(atlTraceHosting, 2, TEXT("Resizing control prcPos->left = %d, prcPos.right = %d, prcPos.bottom =%d, prcPos.top = %d\n"),
        prcPos->left, prcPos->right, prcPos->bottom, prcPos->top); 

    if(false == m_fSelfHosted){

        Fire_OnResize(RECTWIDTH(prcPos), RECTHEIGHT(prcPos), SIZE_RESTORED);        
    }/* end of if statement */

#if 0    
    if(!m_bWndLess){

        return(hr);
    }/* end of if statement */

    if(m_cntObj.empty() == true){

    	hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        ATLASSERT(pObj);

        if(m_fSelfHosted && (GetUnknown() == pObj->GetUnknown())){

            continue; // that is us we close our self later after the contained objects
        }/* end of if statement */

        pObj->SetObjectRects(); // adjust the current offset if it needs to be so       
    }/* end of for loop */    
#endif
    return(hr);
}/* end of function AdjustRects */
                               
/*************************************************************************/
/* IOleInPlaceSiteEx Implementation                                      */
/*************************************************************************/

/*************************************************************************/
/* Function: CanWindowlessActivate                                       */
/* Description: Return if we can windowless activate or not.             */
/*************************************************************************/
STDMETHODIMP CMFBar::CanWindowlessActivate(){

	return m_bCanWindowlessActivate ? S_OK : S_FALSE;
}/* end of function CanWindowlessActivate */

/*************************************************************************/
/* Function: GetDC                                                       */
/* Description: Gets a DC to draw with.                                  */
/*************************************************************************/
STDMETHODIMP CMFBar::GetDC(LPCRECT pRect, DWORD grfFlags, HDC* phDC){
    
	HRESULT hr = S_OK;

    if(m_bWndLess){

        hr = m_spInPlaceSite->GetDC(pRect, grfFlags, phDC);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    *phDC  = ::GetDC(m_hWnd);
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */
    }/* end of if statement */

    return(hr);
}/* end of function GetDC */

/*************************************************************************/
/* Function: ReleaseDC                                                   */
/* Description: Releases the DC                                          */
/*************************************************************************/
STDMETHODIMP CMFBar::ReleaseDC(HDC hDC){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        hr = m_spInPlaceSite->ReleaseDC(hDC);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::ReleaseDC(m_hWnd, hDC);
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function ReleaseDC */

/*************************************************************************/
/* Function: OnDefWindowMessage                                          */
/* Description: Sends on messages to the default window procedure.       */
/*************************************************************************/
STDMETHODIMP CMFBar::OnDefWindowMessage(UINT msg, WPARAM wParam, 
                                        LPARAM lParam, LRESULT* plResult){

		*plResult = DefWindowProc(msg, wParam, lParam);
		return S_OK;
}/* end of function OnDefWindowMessage */

/*************************************************************************/
/* Function: InvalidateRgn                                               */
/* Description: Invalidates the whole rect in case we need to repaint it.*/
/*************************************************************************/
STDMETHODIMP CMFBar::InvalidateRgn(HRGN hRGN, BOOL fErase){

    HRESULT hr = S_OK;
#if 0
    if (!hRGN) {
        RECT rc;
        GetClientRect(&rc);
        hRGN = ::CreateRectRgn( rc.left, rc.top, rc.right, rc.bottom);
    }

    HRGN newRgn = ::CreateRectRgn(0, 0, 10, 10);
    ::CombineRgn(newRgn, hRGN, NULL, RGN_COPY) ;

    CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        ATLASSERT(pObj);

        if(m_fSelfHosted && (GetUnknown() == pObj->GetUnknown())){

            continue; // that is us we close our self later after the contained objects
        }/* end of if statement */

        if (!pObj->IsWindowless() &&  pObj->IsActive()) {
            LONG x1, y1, w, h;
            GetObjectPosition(pObj->GetID(), &x1, &y1, &w, &h);
            HRGN objRgn = ::CreateRectRgn( x1, y1, x1+w, y1+h );
            ::CombineRgn(newRgn, newRgn, objRgn, RGN_DIFF);
            //ATLTRACE(TEXT("Excluding Rgn %d %d %d %d\n"), x1, y1, x1+w, y1+h);
        }
    }/* end of for loop */    

    hRGN = newRgn;
#endif

    if(m_bWndLess){

        hr = m_spInPlaceSite->InvalidateRgn(hRGN ,fErase);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::InvalidateRgn(m_hWnd, hRGN, fErase); // see if we can get by by not erasing..
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function InvalidateRgn */

/*************************************************************************/
/* Function: InvalidateRect                                              */
/* Description: Invalidates the rect, handles if we are windowless       */
/*************************************************************************/
STDMETHODIMP CMFBar::InvalidateRect(LPCRECT pRect, BOOL fErase){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        hr = m_spInPlaceSite->InvalidateRect(pRect, fErase);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::InvalidateRect(m_hWnd, pRect, fErase);
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function InvalidateRect */

/*************************************************************************/
/* Function: GetCapture                                                  */
/* Description: Used to determine if we have a cupature or not           */
/*************************************************************************/
STDMETHODIMP CMFBar::GetCapture(){

    HRESULT hr = S_OK;

    if(m_bWndLess){
       
        hr = m_spInPlaceSite->GetCapture();                    
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

            hr = ::GetCapture() == m_hWnd ? S_OK : S_FALSE;
        }/* end of if statement */
    }/* end of if statement */
            
    return(hr);    
}/* end of function GetCapture */
	
/*************************************************************************/
/* Function: SetCapture                                                  */
/* Description: Used to set the capture for mouse events                 */
/* Only one container at the time can have a capture.                    */
/*************************************************************************/
STDMETHODIMP CMFBar::SetCapture(BOOL fCapture){

    HRESULT hr = S_OK;
    
    // whatever we we are doing we need to reset the capture flags on all the object
    // after this call is finished the specific site will set appropriate flag
    ResetCaptureFlags();

    if(fCapture){

        ATLTRACE2(atlTraceUser, 31, TEXT("Setting Mouse Capture in the container \n")); 
    }
    else {

        ATLTRACE2(atlTraceUser, 31, TEXT("Resetting Mouse Capture in the container\n")); 
    }/* end of if statement */
    
    if(m_bWndLess){

        if (fCapture){

            hr = m_spInPlaceSite->SetCapture(TRUE);            
        }
        else {

            hr = m_spInPlaceSite->SetCapture(FALSE);            
        }/* end of if statement */
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

	        if (fCapture){
                // do not have a capture, so set it
                ATLTRACE2(atlTraceWindowing, 4, TEXT("Setting caputure to our self (container) \n")); 
                ::SetCapture(m_hWnd);                
            }
            else{
                // nobody more has a capture, so let it go
                ATLTRACE2(atlTraceWindowing, 4, TEXT("Releasing caputure from our self (container) \n")); 
                ::ReleaseCapture();                
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);    
}/* end of function SetCapture */

/*************************************************************************/
/* Function: ResetCaptureFlags                                           */
/* Description: Resets the capture on contained objects.                 */
/*************************************************************************/
HRESULT  CMFBar::ResetCaptureFlags(){

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained objects and draw them
        CHostedObject* pObj = (*i);
   
        pObj->SetCapture(false);
    }/* end of for function */

    return(S_OK);
}/* end of function ResetCaptureFlags */

/*************************************************************************/
/* Function: ResetFocusFlags                                             */
/* Description: Resets the capture on contained objects.                 */
/*************************************************************************/
HRESULT  CMFBar::ResetFocusFlags(){

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained objects and draw them
        CHostedObject* pObj = (*i);
        if(pObj->HasFocus()){

            LONG lRes;
            SetObjectFocus(pObj, FALSE, lRes);          
        }/* end of if statement */
    }/* end of for function */

    return(S_OK);
}/* end of function ResetFocusFlags */

/*************************************************************************/
/* Function: EnumObjects                                                 */
/* Description: Returns IEnumUnknown                                     */
/*************************************************************************/
STDMETHODIMP CMFBar::EnumObjects(DWORD /*grfFlags*/, IEnumUnknown** ppenum){

    if (ppenum == NULL)
	    return E_POINTER;

    *ppenum = NULL;

    // TODO: handle flags
    ATLASSERT(FALSE);

    if(m_cntObj.empty() == true){

    	return E_FAIL;
    }/* end of if statement */

    typedef CComObject<CComEnum<IEnumUnknown, &IID_IEnumUnknown, IUnknown*, _CopyInterface<IUnknown> > > enumunk;
    enumunk* p = NULL;
    ATLTRY(p = new enumunk);
    if(p == NULL)
	    return E_OUTOFMEMORY;

    // create an array to which we put our *IUnknowns   
    INT iSize = m_cntObj.size();
    IUnknown** pArray = new IUnknown* [iSize];

    if(pArray == NULL)
	    return E_OUTOFMEMORY;
    
    bool bFirstElement = true;
	CNTOBJ::iterator i;
    INT iCount = 0;

    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
    // move the interfaces to the array        
        CHostedObject* pObj = (*i);        
        pArray[iCount] = pObj->GetUnknown();

        pArray[iCount]->AddRef();

        iCount++;
    }/* end of for loop */

    HRESULT hRes = p->Init(pArray, pArray + iSize, GetUnknown(), AtlFlagCopy);
    if (SUCCEEDED(hRes))
	    hRes = p->QueryInterface(IID_IEnumUnknown, (void**)ppenum);
    if (FAILED(hRes))
	    delete p;

    delete[] pArray;

    return hRes;
}/* end of function EnumObjects */

/*************************************************************************/
/* Function: SendMessageToCtl                                            */
/* Description: Forwards message to a control                            */
/*************************************************************************/
HRESULT CMFBar::SendMessageToCtl(CHostedObject* pObj, 
                                      UINT uMsg, WPARAM wParam, LPARAM lParam,
                                      BOOL& bHandled, LONG& lRes, bool fWndwlsOnly, bool fActiveOnly){

    HRESULT hr = S_OK;
   
    if(NULL == pObj){

      hr = E_UNEXPECTED;
      return(hr);
    }/* end of if statement */

    if(fWndwlsOnly && (!pObj->IsWindowless())){

        ATLTRACE2(atlTraceUser, 31, TEXT("NOT SENDING message to control %ls !!!\n"), pObj->GetID());
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    if(fActiveOnly && (!pObj->IsInputEnabled())){

        ATLTRACE2(atlTraceUser, 31, TEXT("NOT SENDING message to control %ls !!!\n"), pObj->GetID());
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */
   
    CComPtr<IUnknown> pUnk = pObj->GetUnknown();
    
    if(!pUnk){

        ATLASSERT(FALSE); // should not be null
        return(E_FAIL);
    }/* end of if statement */

    if(pUnk == GetUnknown()){

        // do not send message to our self since we might endup in the never ending recusion
        return(S_FALSE);
    }/* end of if statement */

    CComQIPtr<IOleInPlaceObjectWindowless> spInPlaceObjectWindowless(pUnk);
    
    if(spInPlaceObjectWindowless){

        // more then one control can have have a capture
        LRESULT lResTemp;
        spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lResTemp);
        lRes = (LONG) lResTemp;
        bHandled = TRUE;                                        
    }/* end of if statement */

    return(hr);
}/* end of function SendMessageToCtl */
  
/*************************************************************************/
/* Function: GetFocus                                                    */
/* Description: Determine if we have a focus or not.                     */
/*************************************************************************/
STDMETHODIMP CMFBar::GetFocus(){

    HRESULT hr = S_OK;

    if(m_bWndLess){
       
        hr = m_spInPlaceSite->GetFocus();                    
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

            hr = ::GetFocus() == m_hWnd ? S_OK : S_FALSE;
        }/* end of if statement */
    }/* end of if statement */
            
    return(hr);    
}/* end of function GetFocus */

/*************************************************************************/
/* Function: SetFocus                                                    */
/* Description: Sets focus to the control                                */
/*************************************************************************/
STDMETHODIMP CMFBar::SetFocus(BOOL fFocus){
    
    HRESULT hr = S_OK;

    // we reset the flags depending on WM_SET and WM_KILL focus messages
    if(fFocus){

        ATLTRACE2(atlTraceUser, 31, TEXT("Setting Mouse Focus in the container \n")); 
    }
    else {

        ATLTRACE2(atlTraceUser, 31, TEXT("Resetting Mouse Focus in the container\n")); 
    }/* end of if statement */
    
    if(m_bWndLess){

        if (fFocus){

            hr = m_spInPlaceSite->SetFocus(TRUE);            
        }
        else {

            hr = m_spInPlaceSite->SetFocus(FALSE);            
        }/* end of if statement */
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

	        if (fFocus){
                
                ::SetFocus(m_hWnd);                
            }
            else {

                // else could call ::SetFocus(NULL), but that does not seem like a good solution
                // so instead reset the focus on contained conrols 
                // which is risky too, since some control could try to call SetFocus(false)
                // when it does not have the focus, but that is handled in the caller
                //ResetFocusFlags();
            }/* end of if statement */                        
        }/* end of if statement */
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);    
}/* end of function SetFocus */

/*************************************************************************/
/* Function: get_ActivityTimeOut                                         */
/* Description: Gets the currrent timout value.                          */
/*************************************************************************/
STDMETHODIMP CMFBar::get_ActivityTimeout(long *plTimeout){

    *plTimeout = m_lTimeout;
    return(S_OK);
}/* end of function get_ActivityTimeOut */

/*************************************************************************/
/* Function: put_ActivityTimeOut                                         */
/* Description: Creates a new timer if needed.                           */
/*************************************************************************/
STDMETHODIMP CMFBar::put_ActivityTimeout(long lTimeout){

    if(lTimeout < 0){

        return(E_INVALIDARG);
    }/* end of if statement */

    if(!::IsWindow(m_hWnd)){

        return(E_FAIL);
    }/* end of if statement */

    if(m_lTimeout != 0 || 0 == lTimeout ){

        // kill it each time we set a new timer
        ::KillTimer(m_hWnd, ID_EV_TIMER);
    }
    else {

        if(0 == ::SetTimer(m_hWnd, ID_EV_TIMER, lTimeout, NULL)){

            return(E_FAIL);
        }/* end of if statement */
    }/* end of if statement */

    m_lTimeout = lTimeout;
    m_fUserActivity = false;    
    m_fWaitingForActivity = false;

    return(S_OK);
}/* end of function put_ActivityTimeOut */

/*************************************************************************/
/* Function: SetObjectExtent                                             */
/* Description: Sets specific object witdth and height.                  */
/*************************************************************************/
STDMETHODIMP CMFBar::SetObjectExtent(BSTR strObjectID, long lWidth, long lHeight){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */
    
    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);

        if(!_wcsicmp(pObj->GetID(), strObjectID)){
            RECT rcOld;
            hr = pObj->GetPos(&rcOld);
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            RECT rcNew; 
            rcNew.left = rcOld.left; rcNew.top = rcOld.top; 
            rcNew.right = rcNew.left + lWidth; rcNew.bottom = rcNew.top + lHeight;

            if(::EqualRect(&rcOld, &rcNew)){

                hr = S_FALSE; // no point to monkey around if the rects are the same
                return(hr);
            }/* end of if statement */

            // Set the objects new position            
            hr = pObj->SetRawPos(&rcNew); 
            
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            // Set the objects new position            
            hr = pObj->SetRawPos(&rcNew); 
            
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            if(pObj->IsWindowless()){

                hr = pObj->SetObjectRects();            
            }
            else {
                
                hr = pObj->SetObjectRects(&rcNew);            
            }/* end of if statement */

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
            
            RECT rcUnion;

            ::UnionRect(&rcUnion, &rcOld, &rcNew);

            if (pObj->IsWindowless())
                hr = InvalidateRect(&rcUnion, FALSE);

            break; // already have set the state and invalidated and bail out
        }/* end of if statement */
    }/* end of for loop */

	return (hr);
}/* end of function SetObjectExtent */

/*************************************************************************/
/* Function: SetObjectPosition                                           */
/* Description: Sets specific object position. Looks up object by object */
/* ID.  Sets also extents.                                               */
/*************************************************************************/
STDMETHODIMP CMFBar::SetObjectPosition(BSTR strObjectID, long xPos, 
                                       long yPos, long lWidth, long lHeight){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    RECT rcNew; 
    rcNew.left = xPos; rcNew.top = yPos; 
    rcNew.right = rcNew.left + lWidth; rcNew.bottom = rcNew.top + lHeight;

    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);

        if(!_wcsicmp(pObj->GetID(), strObjectID)){
            RECT rcOld;
            hr = pObj->GetPos(&rcOld);
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            if(::EqualRect(&rcOld, &rcNew)){

                hr = S_FALSE; // no point to monkey around if the rects are the same
                return(hr);
            }/* end of if statement */

            // Set the objects new position            
            hr = pObj->SetRawPos(&rcNew); 
            
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            if(pObj->IsWindowless()){

                hr = pObj->SetObjectRects();            

                LPARAM lParam = MAKELPARAM(lWidth, lHeight);
                WPARAM wParam = SIZE_RESTORED;
                BOOL bHandled;
                LONG lRes;
                SendMessageToCtl(pObj, WM_SIZE, wParam, lParam, bHandled, lRes);
            }
            else {
                
                hr = pObj->SetObjectRects(&rcNew);            
            }/* end of if statement */

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
            
            RECT rcUnion;

            ::UnionRect(&rcUnion, &rcOld, &rcNew);

            if (pObj->IsWindowless())
                hr = InvalidateRect(&rcUnion, FALSE);

            break; // already have set the state and invalidated and bail out
        }/* end of if statement */
    }/* end of for loop */

	return (hr);
}/* end of function SetObjectPosition */

/*************************************************************************/
/* Function: GetObjectPosition                                           */
/* Description: SetObjectPosition                                        */
/*************************************************************************/
STDMETHODIMP CMFBar::GetObjectPosition(BSTR strObjectID, long* pxPos, long* pyPos, long* plWidth, long* plHeight){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    if(NULL == pxPos || NULL == pyPos || NULL == plWidth || NULL == plHeight){

        return(E_POINTER);
    }/* end of if statement */

    *pxPos = *pyPos = *plWidth = *plHeight = 0;

    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        
        if(!_wcsicmp((*i)->GetID(), strObjectID)){

            CHostedObject* pObj = (*i);        
             
            // Set the objects new position
            RECT rc;             
            hr = pObj->GetPos(&rc);

            if(SUCCEEDED(hr)){
                
                *pxPos = rc.left; *pyPos = rc.top; *plWidth = RECTWIDTH(&rc); *plHeight = RECTHEIGHT(&rc);
            }/* end of if statement */

            break; // already have set the state and invalidated and bail out
        }/* end of if statement */
    }/* end of for loop */

	return (hr);
}/* end function GetObjectPosition */

/*************************************************************************/
/* Function: WinHelp                                                     */
/* Description: Called by the script to execute specific help topic.     */
/*************************************************************************/
STDMETHODIMP CMFBar::WinHelp(BSTR strHelpFile, long lCommand, long dwData){

    HRESULT hr = S_OK;

    try {
        HWND h = NULL;

        hr = GetWindow(&h);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        USES_CONVERSION;
        LPTSTR strTemp = OLE2T(strHelpFile);
        if (strTemp != NULL)
        {
            BOOL bResult = ::WinHelp(h, strTemp, lCommand, dwData);

            if(!bResult){

                // failed so lets try to get some more meaningful result
                hr = HRESULT_FROM_WIN32(::GetLastError());            
            }/* end of if statement */
        }
        else
        {
            hr = E_POINTER;
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function WinHelp */

static HWND (WINAPI *pfnHtmlHelp)(HWND , LPCTSTR , UINT , ULONG_PTR);
typedef HWND  (WINAPI *PFNHTMLHELP)(HWND , LPCTSTR , UINT , ULONG_PTR);

/*************************************************************************/
/* Function: CallHtmlHelp                                                */
/* Description: Dynamically load the HTML help.                          */
/*************************************************************************/
HWND CMFBar::CallHtmlHelp(HWND hwndCaller,LPCTSTR pszFile,UINT uCommand,ULONG_PTR dwData){

    HWND hwnd = NULL; // return value

    if(NULL == m_hinstHelpDll){

        m_hinstHelpDll = ::LoadLibrary(TEXT("HHCTRL.OCX"));
    }/* end of if statement */

    if (m_hinstHelpDll){

#ifndef _UNICODE
        pfnHtmlHelp = (PFNHTMLHELP)GetProcAddress(m_hinstHelpDll, "HtmlHelpA");
#else
        pfnHtmlHelp = (PFNHTMLHELP)GetProcAddress(m_hinstHelpDll, "HtmlHelpW");
#endif

        if (pfnHtmlHelp){

            hwnd = pfnHtmlHelp(hwndCaller, pszFile, uCommand, dwData);
        }/* end of if statement */
    }/* end of if statement */

    return (hwnd);
}/* end of function CallHtmlHelp */

/*************************************************************************/
/* Function: HTMLHelp                                                    */
/* Description: Called by the script to execute specific help topic.     */
/*************************************************************************/
STDMETHODIMP CMFBar::HTMLHelp(BSTR strHelpFile, long lCommand, VARIANT vData){

    HRESULT hr = S_OK;

    try {

        HWND h = NULL;

        hr = GetWindow(&h);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        USES_CONVERSION;

        ULONG_PTR pData = NULL;

        switch(vData.vt){

            case VT_BSTR: {  // This might be tricky since we have to convert to ansi if not un Unicode

#ifndef _UNICODE
                USES_CONVERSION;
                pData = (ULONG_PTR) OLE2T(vData.bstrVal);
#else
                pData = (ULONG_PTR) vData.bstrVal;
#endif                      
            }
            break;
            default:   pData = vData.ulVal;  // like VT_I4 just cast to the the type
        }/* end of switch statement */

        CComBSTR cstr = TEXT("hcp:");

        if(cstr == strHelpFile){
        
            // special case when we are creating process for TS
            // per Bradley Serbus we do not build another function for this
            TCHAR lpszCmdLine[MAX_PATH * 3];
            
            if(MAX_PATH < GetWindowsDirectory(lpszCmdLine,  MAX_PATH )){

                // not enough size in max path
                ATLASSERT(TRUE);
                throw(E_UNEXPECTED);
            }/* end of if statement */

            _tcscat(lpszCmdLine, TEXT("\\pchealth\\helpctr\\binaries\\helpctr.exe"));
                        
            _tcscat(lpszCmdLine, TEXT(" -url hcp://help/"));

            if(VT_BSTR != vData.vt){
                
                throw(E_INVALIDARG);
            }/* end of if statement */

            TCHAR* strTS = OLE2T(vData.bstrVal);

            if(NULL == strTS){

                throw(E_UNEXPECTED);
            }/* end of if statement */
            
            _tcscat(lpszCmdLine, strTS);
           
            // take the container out of the top-most mode
            ::SetWindowPos(m_hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
            SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);

#ifndef _UNICODE
            if(WinExec(lpszCmdLine, SW_SHOW) <= 31){
#else
            long cCharacters = wcslen(lpszCmdLine)+1;
            long cbAnsi = cCharacters*2;

            // Use of the OLE allocator is not required because the resultant
            // ANSI  string will never be passed to another COM component. You
            // can use your own allocator.
            LPSTR pszA = (LPSTR) CoTaskMemAlloc(cbAnsi);

            if (NULL == pszA)
                throw(E_OUTOFMEMORY);

            if (0 == WideCharToMultiByte(CP_ACP, 0, lpszCmdLine, cCharacters, pszA, cbAnsi, NULL, NULL)) {
                DWORD dwError = GetLastError();
                CoTaskMemFree(pszA);
                throw HRESULT_FROM_WIN32(dwError);
            }

            if(WinExec(pszA, SW_SHOW) <= 31){
                CoTaskMemFree(pszA);
#endif
            //if(!::CreateProcess(lpszCmdLine, NULL , NULL, NULL, FALSE, 0, NULL, NULL, NULL, NULL)){

                ATLASSERT(FALSE);
                throw(E_FAIL);
            }/* end of if statement */

#ifdef _UNICODE
            CoTaskMemFree(pszA);
#endif

        }
        else {

            // take the container out of the top-most mode
            ::SetWindowPos(m_hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
            SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);
            m_bHandleUserFocus = FALSE;

            HWND hWndNew = CallHtmlHelp(h, OLE2T(strHelpFile), lCommand, pData);

            if(!::IsWindow(hWndNew)){

                // failed so lets try to get some more meaningful result
                hr = HRESULT_FROM_WIN32(::GetLastError());            
            }/* end of if statement */

        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function HTMLHelp */

/*************************************************************************/
/* Function: MessageBox                                                  */
/* Description: Displays the message box using specified parameters.     */
/*************************************************************************/
STDMETHODIMP CMFBar::MessageBox(BSTR strText, BSTR strCaption, long lType){

    HRESULT hr = S_OK;

    try {
        USES_CONVERSION;

        HWND hWnd = NULL;
        HRESULT hr = GetWindow(&hWnd);

        if(FAILED(hr)){

            ATLASSERT(FALSE);    
            throw(hr);
        }/* end of if statement */

        LPTSTR strTemp1 = OLE2T(strText);
        LPTSTR strTemp2 = OLE2T(strCaption);
        if (strTemp1 != NULL && strTemp2 != NULL)
        {
            ::MessageBox(hWnd, strTemp1, strTemp2, lType);
        }
        else
        {
            hr = E_POINTER;
        }
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }
	return S_OK;
}/* end of function MessageBox */

/*************************************************************************/
/* Function: GetToolbarName                                              */
/* Description: Gets and allocates the toolbar name.                     */
/*************************************************************************/
HRESULT CMFBar::GetToolbarName(BSTR* strToolbarName){

    HRESULT hr = S_OK;

    if(NULL == strToolbarName){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    const INT ciMaxBuffSize = MAX_PATH; // should be enough for tlbr ID, keep ID small if can
    TCHAR strBuffer[ciMaxBuffSize];
    
    if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

        hr = E_FAIL;
        return(E_FAIL);
    }/* end of if statement */   

#ifdef _UNICODE  
    *strToolbarName = ::SysAllocString(strBuffer); 
#else
   USES_CONVERSION;
   *strToolbarName = ::SysAllocString(T2OLE(strBuffer));
#endif

   return(hr);
}/* end of function GetToolbarName */

/*************************************************************************/
/* Function: SetPriority                                                 */
/* Description: Sets the thread priority.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::SetPriority(long lPriority){

    HRESULT hr = S_OK;

    try {

        HANDLE hThread = ::GetCurrentThread();

        if(!::SetThreadPriority(hThread, lPriority)){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            throw (hr);
        }/* end of if statement */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SetPriority */

/*************************************************************************/
/* Function: SetPriorityClass                                            */
/* Description: Sets the thread priority.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::SetPriorityClass(long lPriority){

    HRESULT hr = S_OK;

    try {

        HANDLE hThread = ::GetCurrentThread();

        if(!::SetPriorityClass(hThread, lPriority)){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            throw (hr);
        }/* end of if statement */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SetPriorityClass */

/*************************************************************************/
/* Function: get_BackgroundImage                                         */
/* Description: Gets the backround image.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::get_BackgroundImage(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackImageFilename.Copy();
	return S_OK;
}/* end of function get_BackgroundImage */

/*************************************************************************/
/* Function: put_BackgroundImage                                         */
/* Description: Attempts to load the background image.                   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_BackgroundImage(BSTR strFilename){

    USES_CONVERSION;
    HRESULT hr = S_OK;

    if(NULL != m_pBackBitmap){

        delete m_pBackBitmap;
    }/* end of if statement */

    m_pBackBitmap = new CBitmap;

    //m_pBackBitmap->LoadPalette(true); // load the palette if available, since this
                                 // is the palette we use for the rest
                                 // of the contained objects

	m_bstrBackImageFilename = strFilename;

    TCHAR strBuffer[MAX_PATH] = TEXT("\0");

    bool fGrayOut = false;

    hr = m_pBackBitmap->PutImage(strFilename, m_hRes, FALSE, m_blitType, CUSTOM_CONTAINER);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    // we are updating image that is being used, refresh it
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
    InvalidateRgn(); // our helper function            

    return(hr);
}/* end of function put_BackgroundImage */

/*************************************************************************/
/* Function: SetReadyState                                               */
/* Description: Sets ready state and fires event if it needs to be fired */
/*************************************************************************/
HRESULT CMFBar::SetReadyState(LONG lReadyState){

    HRESULT hr = S_OK;
    
    bool bFireEvent = (lReadyState != m_nReadyState);

    
#ifdef _DEBUG    
    if(m_nFreezeEvents > 0){

        ::Sleep(10);
        ATLTRACE("Container not expecting events at the moment");
    }/* end of is statement */

#endif

    if(bFireEvent){

        put_ReadyState(lReadyState);
        Fire_ReadyStateChange(lReadyState);
    }
    else {
        // set the variable
        m_nReadyState = lReadyState;
    }/* end of if statement */

    return(hr);
}/* end of function SetReadyState */

/*************************************************************************/
/* Function: OnPostVerbInPlaceActivate                                   */
/* Description: Creates the in place active object.                      */
/*************************************************************************/
HRESULT CMFBar::OnPostVerbInPlaceActivate(){

    SetReadyState(READYSTATE_COMPLETE);

    return(S_OK);
}/* end of function OnPostVerbInPlaceActivate */

/*************************************************************************/
/* Function: get_AutoLoad                                                */
/*************************************************************************/
STDMETHODIMP CMFBar::get_AutoLoad(VARIANT_BOOL *pVal){

    *pVal = m_fAutoLoad;

	return S_OK;
}/* end of function get_AutoLoad */

/*************************************************************************/
/* Function: put_AutoLoad                                                */
/* Description: Sets the flag to autolaod the engine after we set a      */
/* script file or not.                                                   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_AutoLoad(VARIANT_BOOL newVal){

    m_fAutoLoad = (VARIANT_FALSE == newVal ? VARIANT_FALSE : VARIANT_TRUE);

	return S_OK;
}/* end of function put_AutoLoad */

/*************************************************************/
/* Name: SetRectRgn
/* Description: Set up a rectangular window update region
/*************************************************************/
STDMETHODIMP CMFBar::SetRectRgn(long x1, long y1, long x2, long y2)
{
    HRGN hRgn = ::CreateRectRgn( x1, y1, x2, y2 );
    ::SetWindowRgn(m_hWnd, hRgn, TRUE);
	return S_OK;
}

/*************************************************************/
/* Name: SetRoundRectRgn
/* Description: Set up a round corner window update region
/*************************************************************/
STDMETHODIMP CMFBar::SetRoundRectRgn(long x1, long y1, long x2, long y2, long width, long height){

    HRGN hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, width, height);
    ::SetWindowRgn(m_hWnd, hRgn, TRUE);
	return S_OK;
}/* end of function SetRoundRectRgn */

/*************************************************************/
/* Function: SetTimeout                                      */
/* Description: Creates a timer and then calls events when   */
/* timer proc gets called.                                   */
/*************************************************************/
STDMETHODIMP CMFBar::SetTimeout(long lTimeout, long lId){

    if(lTimeout < 0){

        return(E_INVALIDARG);
    }/* end of if statement */

    if(!::IsWindow(m_hWnd)){

        return(E_FAIL);
    }/* end of if statement */

    if(ID_EV_TIMER == lId){

        return(E_INVALIDARG);
    }/* end of if statement */

    if(lTimeout == 0){

        ::KillTimer(m_hWnd, lId);
    }
    else{

        if(0 != lTimeout){

            if(0 == ::SetTimer(m_hWnd, lId, lTimeout, NULL)){

                return(E_FAIL);
            }/* end of if statement */
        }/* end of if statement */	
    }/* end of if statement */

	return S_OK;
}/* end of function SetTimeout */

/*************************************************************/
/* Function: Sleep                                           */
/*************************************************************/
STDMETHODIMP CMFBar::Sleep(long lMiliseconds){

    ::Sleep(lMiliseconds);

	return S_OK;
}/* end of function Sleep */

/*************************************************************/
/* Name: OnButtonDown
/* Description: Handles WM_MOUSEDOWN
/*************************************************************/
LRESULT CMFBar::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(::IsWindow(m_hWnd)){    
        
        m_ptMouse.x = GET_X_LPARAM(lParam);
        m_ptMouse.y = GET_Y_LPARAM(lParam);
        ::ClientToScreen(m_hWnd, &m_ptMouse);
        SetCapture(TRUE);
        SetFocus(TRUE);
        ATLTRACE(TEXT("Button down, starting to track\n"));

        m_bMouseDown = true;
        
        // Test for resize hit region
        ::GetWindowRect(m_hWnd, &m_rcWnd);
        m_HitRegion = ResizeHitRegion(m_ptMouse);
        UpdateCursor(m_HitRegion);
    }/* end of if statement */
    
    return 0;
}

/*************************************************************/
/* Name: OnButtonUp
/* Description: Handles WM_MOUSEUP
/*************************************************************/
LRESULT CMFBar::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(::IsWindow(m_hWnd)){

        m_bMouseDown = false;

        SetCapture(FALSE);
        ATLTRACE(TEXT("Done tracking the window\n"));        
        m_HitRegion = ResizeHitRegion(m_ptMouse);
        UpdateCursor(m_HitRegion);

    }/* end of if statement */
    
    return 0;
}

/*************************************************************/
/* Name: OnMouseMove
/* Description: Handles WM_MOUSEMOVE
/*************************************************************/
LRESULT CMFBar::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
        
    if(::IsWindow(m_hWnd)){
        ::GetWindowRect(m_hWnd, &m_rcWnd);
        
        POINT ptMouse;
        ptMouse.x = GET_X_LPARAM(lParam);
        ptMouse.y = GET_Y_LPARAM(lParam);
        ::ClientToScreen(m_hWnd, &ptMouse);
        
        // Test for resize hit region
        HitRegion hitRegion = ResizeHitRegion(ptMouse);
        if (!m_bMouseDown && m_HitRegion!=PREMOVE && m_HitRegion!=PRESIZE)
            UpdateCursor(hitRegion);
        
        // No mouse movement, return
        long xAdjustment = m_ptMouse.x - ptMouse.x;
        long yAdjustment = m_ptMouse.y - ptMouse.y;
        if (xAdjustment == 0 &&  yAdjustment == 0)
            return 0;

        m_ptMouse = ptMouse;
//        ATLTRACE(TEXT("Mouse pos: %d %d\n"), m_ptMouse.x, m_ptMouse.y);

        if (m_HitRegion!=NOHIT && m_bMouseDown) {
            long resizeX = m_rcWnd.left;
            long resizeY = m_rcWnd.top;
            long resizeW = RECTWIDTH(&m_rcWnd);
            long resizeH = RECTHEIGHT(&m_rcWnd);
            HWND desktopWnd = ::GetDesktopWindow();
            RECT desktopRC;
            ::GetWindowRect(desktopWnd, &desktopRC);

            if (m_HitRegion & LEFT) {
                ptMouse.x -= SYS_MOVE_SIZE;
                resizeW = m_rcWnd.right-ptMouse.x;
                if (resizeW >RECTWIDTH(&desktopRC)) {
                    resizeW = RECTWIDTH(&desktopRC);
                }
                else if (resizeW < m_lMinWidth) {
                    resizeW = m_lMinWidth;
                }
                resizeX = m_rcWnd.right-resizeW;
            }
            if (m_HitRegion & RIGHT) {
                ptMouse.x += SYS_MOVE_SIZE;
                resizeW = ptMouse.x-m_rcWnd.left;
                if (resizeW >RECTWIDTH(&desktopRC)) {
                    resizeW = RECTWIDTH(&desktopRC);
                }
                else if (resizeW < m_lMinWidth) {
                    resizeW = m_lMinWidth;
                }
            }
            if (m_HitRegion & TOP) {
                ptMouse.y -= SYS_MOVE_SIZE;
                resizeH = m_rcWnd.bottom-ptMouse.y;
                if (resizeH >RECTHEIGHT(&desktopRC)) {
                    resizeH = RECTHEIGHT(&desktopRC);
                }
                else if (resizeH < m_lMinHeight) {
                    resizeH = m_lMinHeight;
                }
                resizeY = m_rcWnd.bottom - resizeH;
            }
            if (m_HitRegion & BOTTOM) {
                ptMouse.y += SYS_MOVE_SIZE;
                resizeH = ptMouse.y-m_rcWnd.top;
                if (resizeH >RECTHEIGHT(&desktopRC)) {
                    resizeH = RECTHEIGHT(&desktopRC);
                }
                else if (resizeH < m_lMinHeight) {
                    resizeH = m_lMinHeight;
                }
            }

            if (resizeW >= m_lMinWidth || resizeH >= m_lMinHeight) {

                if(NULL != m_pBackBitmap){
                    
                    m_pBackBitmap->DeleteMemDC();
                }/* end of if statement */

                ::MoveWindow(m_hWnd, resizeX, resizeY, resizeW, resizeH, TRUE);
                ATLTRACE2(atlTraceWindowing, 30, TEXT("Resize window to: %d %d %d %d\n"), resizeX, resizeY, resizeX+resizeW, resizeY+resizeH);
                
            }

        }/* end of if statement */
    
            
        else if(m_bMouseDown){
            long x = m_rcWnd.left;
            long y = m_rcWnd.top;
            long width = RECTWIDTH(&m_rcWnd);
            long height = RECTHEIGHT(&m_rcWnd);
            ::MoveWindow(m_hWnd, x - xAdjustment, y - yAdjustment, width, height, TRUE);
            ATLTRACE2(atlTraceWindowing, 32, TEXT("Moving the window\n"));
            m_ptMouse = ptMouse;
        }/* end of if statement */
    }/* end of if statement */
    
    return 0;
}

/*************************************************************/
/* Name: ResizeHitRegion                                     */
/* Description: Test if mouse is in resize hit region        */
/*************************************************************/
HitRegion CMFBar::ResizeHitRegion(POINT p){

    // TODO: DO NOT HARDCODE THE REGION SIZES
    int hitRegion = NOHIT;
    if (abs(p.x-m_rcWnd.left)<=10) {
        hitRegion |= LEFT;
    }
    else if (abs(p.x-m_rcWnd.right)<=10) {
        hitRegion |= RIGHT;
    }/* end of if statement */

    if (abs(p.y-m_rcWnd.top)<=10) {
        hitRegion |= TOP;
    }
    else if (abs(p.y-m_rcWnd.bottom)<=10) {
        hitRegion |= BOTTOM;
    }/* end of if statement */

    return (HitRegion)hitRegion;
}/* end of function ResizeHitRegion */

/*************************************************************/
/* Name: UpdateCursor                                        */
/* Description: Change cursor shape to move arrows           */
/*************************************************************/
HRESULT CMFBar::UpdateCursor(HitRegion hitRegion){

    if (m_hCursor)
        ::DestroyCursor(m_hCursor);

    int iHitRegion = (int) hitRegion;
    switch (iHitRegion) {
    case PREMOVE:
    case PRESIZE:
        m_hCursor = ::LoadCursor(0, IDC_SIZEALL);
        break;
    case LEFT|NOHIT:
    case RIGHT|NOHIT:
        m_hCursor = ::LoadCursor(0, IDC_SIZEWE);
        break;
    case TOP|NOHIT:
    case BOTTOM|NOHIT:
        m_hCursor = ::LoadCursor(0, IDC_SIZENS);
        break;
    case LEFT|TOP|NOHIT:
    case RIGHT|BOTTOM|NOHIT:
        m_hCursor = ::LoadCursor(0, IDC_SIZENWSE);
        break;
    case RIGHT|TOP|NOHIT:
    case LEFT|BOTTOM|NOHIT:
        m_hCursor = ::LoadCursor(0, IDC_SIZENESW);
        break;
    default:
        m_hCursor = ::LoadCursor(0, IDC_ARROW);
        break;

    }/* end of switch statement */

    ::SetCursor(m_hCursor);

    return S_OK;
}/* end of function UpdateCursor */

/*************************************************************************/
/* Function: SetObjectFocus                                              */
/* Description: Sets or resets focus to specific object.                 */
/*************************************************************************/
STDMETHODIMP CMFBar::SetObjectFocus(BSTR strObjectID, VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;

    try {

        CHostedObject* pObj;

        hr = FindObject(strObjectID, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statetement */

        LONG lRes = 0;

        hr = SetObjectFocus(pObj, VARIANT_FALSE == fEnable ? FALSE : TRUE, lRes);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(-1 == lRes){

            throw(E_FAIL); // the control did not take the focus since it is disabled
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;      
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */    

    return(hr);
}/* end of function SetObjectFocus */

/*************************************************************************/
/* Function: HasObjectFocus                                              */
/*************************************************************************/
STDMETHODIMP CMFBar::HasObjectFocus(BSTR strObjectID, VARIANT_BOOL* pfEnable){

    HRESULT hr = S_OK;

    try {

        CHostedObject* pObj;

        hr = FindObject(strObjectID, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statetement */
        
        *pfEnable = pObj->HasFocus() ? VARIANT_TRUE : VARIANT_FALSE;
       
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;      
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */    

    return(hr);
}/* end of function HasObjectFocus */

/*************************************************************************/
/* Function: SetObjectFocus                                              */
/* Description: Sets or resets focus to specific object.                 */
/*************************************************************************/
HRESULT CMFBar::SetObjectFocus(CHostedObject* pObj, BOOL fSet, LONG& lRes){

    HRESULT hr = S_OK;

    CContainerObject* pCnt;
    hr = pObj->GetContainerObject(&pCnt);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    LONG lParam = 0;
    BOOL bHandled = FALSE;

    if(fSet){

        ResetFocusFlags(); // reset old focus on other control
        pCnt->SetFocus(TRUE);                                                                      
        SendMessageToCtl(pObj, WM_SETFOCUS, (WPARAM) m_hWnd, lParam, bHandled, lRes, false);

        ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_SETFOCUS to %ls \n"), pObj->GetID());
    }
    else {

        pCnt->SetFocus(FALSE);  // disable focus and caputure if we are disabeling the object                                        
        SendMessageToCtl(pObj, WM_KILLFOCUS, (WPARAM) m_hWnd, lParam, bHandled, lRes, false);

        ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_KILLFOCUS to %ls \n"), pObj->GetID());
    }/* end of if statement */

    return(hr);
}/* end of function SetObjectFocus */

/*************************************************************************/
/* Function: FindObject                                                  */
/* Description: Itterates the objects till it finds the one with matching*/
/* ID.                                                                   */
/*************************************************************************/
HRESULT CMFBar::FindObject(BSTR strObjectID, CHostedObject** ppObj){

    HRESULT hr = E_FAIL; // did not find the object
    *ppObj = NULL;

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            continue;
        }/* end of if statement */
        
        if(!_wcsicmp(pObj->GetID(), strObjectID)){

            *ppObj = pObj; // set the pointer and bail out            
            hr = S_OK;
            break; // got the unknown get out
        }/* end of if statement */
    }/* end of for loop */

    return(hr);
}/* end of function FindObject */

/*************************************************************/
/* Name: HasObjectCapture                                    */
/* Description: Gives us status of capture on specific object*/
/*************************************************************/
STDMETHODIMP CMFBar::HasObjectCapture(BSTR strObjectID, VARIANT_BOOL *pfEnable){
    
    HRESULT hr = S_OK;

    try {

        CHostedObject* pObj;

        hr = FindObject(strObjectID, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statetement */
        
        *pfEnable = pObj->HasCapture() ? VARIANT_TRUE : VARIANT_FALSE;
       
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;      
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */    

    return(hr);
}/* end of function HasObjectCapture */

/*************************************************************/
/* Name: PopupSystemMenu
/* Description: 
/*************************************************************/
STDMETHODIMP CMFBar::PopupSystemMenu(long x, long y)
{
    
    if (m_hMenu == NULL)
        return S_FALSE;

    RECT rc;
    ::GetWindowRect(m_hWnd, &rc);

    m_bSysMenuOn = TRUE;
    m_bHandleEnter = TRUE;

    if (x < 0)
        x = rc.left;
    if (y < 0)
        y = rc.top+SYS_TITLEBAR_WIDTH;

    ::TrackPopupMenu(::GetSubMenu(m_hMenu, 0), TPM_LEFTALIGN, x, y, 0, m_hWnd, 0);

    m_bSysMenuOn = FALSE;
	return S_OK;
}

/*************************************************************/
/* Name: GetRegistryDword
/* Description: 
/*************************************************************/
BOOL GetRegistryDword(const TCHAR *pValueName, const TCHAR *pSubKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pSubKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        lRet = RegQueryValueEx(hKey, pValueName, NULL, &dwType, (LPBYTE)dwRet, &dwLen);
        if (ERROR_SUCCESS != lRet) 
            *dwRet = dwDefault;

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDword
/* Description: 
/*************************************************************/
BOOL SetRegistryDword(const TCHAR *pValueName, const TCHAR *pSubKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, pSubKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pValueName, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

const TCHAR g_szLeft[] = TEXT("Left");
const TCHAR g_szTop[] = TEXT("Top");
const TCHAR g_szRight[] = TEXT("Right");
const TCHAR g_szBottom[] = TEXT("Bottom");
const TCHAR g_szFullScreen[] = TEXT("FullScreen");
const TCHAR g_szUserData[] = TEXT("UserData");
const TCHAR g_szKey[] = TEXT("Software\\Microsoft\\Multimedia\\MSMFCnt\\");
/*************************************************************/
/* Name: SaveSelfHostState
/* Description: 
/*************************************************************/
STDMETHODIMP CMFBar::SaveSelfHostState(BSTR strAppName)
{
    USES_CONVERSION;
    TCHAR *szAppName = OLE2T(strAppName);

    TCHAR szSubKey[MAX_PATH];
    _stprintf(szSubKey, TEXT("%s%s"), g_szKey, szAppName);

    if (m_fSelfHosted && ::IsWindow(m_hWnd)) {
    
        WINDOWPLACEMENT wndPlacement;
        wndPlacement.length = sizeof(WINDOWPLACEMENT);
        ::GetWindowPlacement(m_hWnd, &wndPlacement);
        
        if (wndPlacement.showCmd == SW_SHOWMAXIMIZED) {
            SetRegistryDword(g_szFullScreen, szSubKey, 1);
        }

        else {
            SetRegistryDword(g_szFullScreen, szSubKey, 0);
        }

        SetRegistryDword(g_szLeft, szSubKey, wndPlacement.rcNormalPosition.left);
        SetRegistryDword(g_szTop, szSubKey, wndPlacement.rcNormalPosition.top);
        SetRegistryDword(g_szRight, szSubKey, wndPlacement.rcNormalPosition.right);
        SetRegistryDword(g_szBottom, szSubKey, wndPlacement.rcNormalPosition.bottom);

        return S_OK;
    }

	return E_FAIL;
}

/*************************************************************/
/* Name: RestoreSelfHostState
/* Description: 
/*************************************************************/
STDMETHODIMP CMFBar::RestoreSelfHostState(BSTR strAppName)
{
    USES_CONVERSION;
    TCHAR *szAppName = OLE2T(strAppName);

    TCHAR szSubKey[MAX_PATH];
    _stprintf(szSubKey, TEXT("%s%s"), g_szKey, szAppName);

    if (m_fSelfHosted && ::IsWindow(m_hWnd)) {
    
        BOOL bFullScreen;
        GetRegistryDword(g_szFullScreen, szSubKey, (DWORD*)&bFullScreen, 0);

        UINT uFlags = SWP_NOZORDER;
        if (bFullScreen) 
            uFlags |= SWP_HIDEWINDOW;

        DWORD left, top, right, bottom;
        if (
            GetRegistryDword(g_szLeft, szSubKey, &left, 0) &&
            GetRegistryDword(g_szTop, szSubKey, &top, 0) &&
            GetRegistryDword(g_szRight, szSubKey, &right, 0) &&
            GetRegistryDword(g_szBottom, szSubKey, &bottom, 0) ) {
            if (0 == ::SetWindowPos(m_hWnd, 0, left, top, right-left, bottom-top, uFlags))
                return E_FAIL;
        }

        else {
            if (!bFullScreen)
                return E_FAIL;
        }

        if (bFullScreen) {
            ShowSelfSite(SW_MAXIMIZE);
        }

        return S_OK;
    }

	return E_FAIL;
}

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
STDMETHODIMP CMFBar::SaveSelfHostUserData(BSTR strAppName, long lData)
{
    USES_CONVERSION;
    TCHAR *szAppName = OLE2T(strAppName);

    TCHAR szSubKey[MAX_PATH];
    _stprintf(szSubKey, TEXT("%s%s"), g_szKey, szAppName);

    SetRegistryDword(g_szUserData, szSubKey, lData);

	return S_OK;
}

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
STDMETHODIMP CMFBar::GetSelfHostUserData(BSTR strAppName, long *lData)
{
    USES_CONVERSION;
    TCHAR *szAppName = OLE2T(strAppName);

    TCHAR szSubKey[MAX_PATH];
    _stprintf(szSubKey, TEXT("%s%s"), g_szKey, szAppName);

    DWORD dwRet;
    if (GetRegistryDword(g_szUserData, szSubKey, &dwRet, 0)) {
        *lData = dwRet;
	    return S_OK;
    }

    return E_FAIL;
}

/*************************************************************/
/* Name: get_DoubleClickTime
/* Description: 
/*************************************************************/
STDMETHODIMP CMFBar::get_DoubleClickTime(long *pVal)
{
    if (pVal == NULL)
        return E_INVALIDARG;

    *pVal = ::GetDoubleClickTime();
    return S_OK;
}

/*************************************************************************/
/* End of file: MFBar.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfbbtn.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFBBtn.cpp                                                    */
/* Description: Implementation of CMSMFBBtn Bitmap Button                */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFBBtn.h"
#include "ocidl.h"	// Added by ClassView
extern CComModule _Module;

/////////////////////////////////////////////////////////////////////////////
// CMSMFBBtn
/*************************************************************************/
/* Function:  CMSMFBBtn                                                  */
/*************************************************************************/
CMSMFBBtn::CMSMFBBtn(){

    Init();    
    for(INT i = 0; i < cgMaxBtnStates; i++){

	    m_pBitmap[i] = new CBitmap;
    }/* end of for loop */
}/* end of function CMSMFBBtn */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes variable states.                             */
/*************************************************************************/
void CMSMFBBtn::Init(){

    m_nEntry = BtnState::Static;    

    m_fDirty = true;   // to refresh text property, font etc.
    m_uiFontSize = 10;
    m_bstrTextValue = L"";
    m_bstrFontFace = L"Arial";
    m_bstrFontStyle = L"Normal";
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    m_clrColorActive = 0x00ff0000; // blue
    m_clrColorStatic = 0x00000000; // black
    m_clrColorHover = 0x00ff0000;  // blue
    m_clrColorPush = 0x00ffffff;   // white
    m_clrColorDisable = 0x00808080; // grey
    m_dwButtonClickStamp = 0;
#if 0 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
#endif
}/* end of function Init */

/*************************************************************************/
/* Function: ~CMSMFBBtn                                                  */
/* Description: Cleanup the bitmap and pallete arrays, unload resource   */
/* DLL.                                                                  */
/*************************************************************************/
CMSMFBBtn::~CMSMFBBtn(){

    ATLTRACE(TEXT("In the BUTTON Object destructor!\n"));
    for(INT i = 0; i < cgMaxBtnStates; i++){
        if (m_pBitmap[i]){

            delete m_pBitmap[i];
            m_pBitmap[i] = NULL;
        }/* end of if statement */
        //CComBSTR m_bstrFilename[..] should get destructed on the stack
    }/* end of for loop */

    Init();
}/* end of function ~CMSMFBBtn */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Does the basic drawing                                   */
/*************************************************************************/
HRESULT CMSMFBBtn::OnDraw(ATL_DRAWINFO& di){

    USES_CONVERSION;
	RECT& rc = *(RECT*)di.prcBounds;
    HRESULT hr = S_OK;

    if (m_pBitmap[m_nEntry]){
        BOOL bRet;

        HPALETTE hNewPal = m_pBitmap[m_nEntry]->GetPal();

        if (::IsWindow(m_hWnd)){ // in othere words not windowless
                        
            CBitmap::SelectRelizePalette(di.hdcDraw, hNewPal);
        }/* end of if statement */

        if (::IsWindow(m_hWnd) && m_blitType != DISABLE) {

            COLORREF clr;            
            ::OleTranslateColor (m_clrBackColor, hNewPal, &clr);        
            
            // fill background of specific color
            HBRUSH hbrBack = ::CreateSolidBrush(clr);            

            if(NULL == hbrBack){

                hr = E_UNEXPECTED;
                return hr;
            }/* end of if statement */

            //::FillRect(hdc, &rcClient, hbrBack);
            ::FillRect(di.hdcDraw, (LPRECT)di.prcBounds, hbrBack);
            ::DeleteObject(hbrBack);
        }

        bRet = m_pBitmap[m_nEntry]->PaintTransparentDIB(di.hdcDraw, (LPRECT) di.prcBounds,
            (LPRECT) di.prcBounds);
        
        if (m_fDirty)
        {
            SetTextProperties();
        }

        if(m_bstrTextValue.Length() > 0){

            // draw text only if needed
            hr = m_cText.Write(di.hdcDraw, rc, m_bstrTextValue);
        }/* end of if statement */

        hr = GetFocus();

        // THIS ASSUMES WE ARE REPAINTING THE WHOLE CONTROL
        // WHICH IS WHAT ATL AT THIS INCARNATION DOES
        if(S_OK == hr){

            ::DrawFocusRect(di.hdcDraw, (LPRECT)di.prcBounds);
        }/* end of if statement */

        if(!bRet){

            hr = E_UNEXPECTED;
        }/* end of if statement */
    }/* end of if statement */
	
	return (hr);
}/* end of function OnDraw */

/*************************************************************************/
/* Function: SetTextProperties                                           */
/* Description: Set the properties for the CText object.                 */
/*************************************************************************/
HRESULT CMSMFBBtn::SetTextProperties()
{
    HRESULT hr = S_OK;

    m_cText.SetFontFace(m_bstrFontFace);
    m_cText.SetFontSize(m_uiFontSize);
    m_cText.SetFontStyle(m_bstrFontStyle);
    m_cText.SetFixedSizeFont(true);

    // set the font color based on the current state

    OLE_COLOR clrColorCurrent = m_clrColorStatic;
    switch(m_nEntry)
    {
        case(BtnState::Static):
            clrColorCurrent = m_clrColorStatic;
            break;
        case(BtnState::Hover):
            clrColorCurrent = m_clrColorHover;
            break;
        case(BtnState::Active):
            clrColorCurrent = m_clrColorActive;
            break;
        case(BtnState::Push):
            clrColorCurrent = m_clrColorPush;
            break;
        case(BtnState::Disabled):
            clrColorCurrent = m_clrColorDisable;
            break;
    }

    // translate OLE_COLOR to COLORREF
    COLORREF crCurrentState;

    hr = OleTranslateColor(clrColorCurrent, CBitmap::GetSuperPal(), &crCurrentState);

    if (FAILED(hr))
    {
        crCurrentState = GetSysColor(COLOR_WINDOWTEXT);
    }
    
    m_cText.SetTextColor(crCurrentState);

    m_fDirty = false;

    return hr;
}


STDMETHODIMP CMSMFBBtn::get_TextWidth(long *pVal)
{
    // special case early return
    if (m_bstrTextValue.Length() == 0)
    {
        *pVal = 0;
        return S_OK;
    }

    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    *pVal = size.cx;

    ::ReleaseDC(hwnd, hdc); // do not forget to free DC

	return S_OK;
}

STDMETHODIMP CMSMFBBtn::get_TextHeight(long *pVal)
{
    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){
        
        return(E_UNEXPECTED);
    }/* end of if statement */

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    *pVal = size.cy;

    ::ReleaseDC(hwnd, hdc); // do not forget to free DC

	return S_OK;
}

/*************************************************************************/
/* Function: get_ColorPush                                               */
/* Description: return the ColorPush property.                           */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorPush(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorPush;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Push state.                                                    */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorPush(OLE_COLOR clrColor)
{
    m_clrColorPush = clrColor;

    if (m_nEntry == BtnState::Push)
    {
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_ColorHover                                              */
/* Description: return the ColorHover property.                          */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorHover(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorHover;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorHover                                              */
/* Description: set the ColorHover property. This is the color of text   */
/* in the Hover state.                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorHover(OLE_COLOR clrColor)
{
    m_clrColorHover = clrColor;

    if (m_nEntry == BtnState::Hover)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorStatic                                             */
/* Description: return the ColorStatic property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorStatic(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorStatic;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Static (normal) state.                                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorStatic(OLE_COLOR clrColor)
{
    m_clrColorStatic = clrColor;

    if (m_nEntry == BtnState::Static)
    {
        m_fDirty = true;
    }
	
    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorDisable                                            */
/* Description: return the ColorDisable property.                        */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorDisable(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorDisable;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorDisable                                            */
/* Description: set the ColorDisable property. This is the color of text */
/* in the Disabled state.                                                */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorDisable(OLE_COLOR clrColor)
{
    m_clrColorDisable = clrColor;

    if (m_nEntry == BtnState::Disabled)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorActive                                             */
/* Description: return the ColorActive property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorActive(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorActive;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorActive                                             */
/* Description: set the ColorActive property. This is the color of text  */
/* in the Active state.                                                  */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorActive(OLE_COLOR clrColor)
{
    m_clrColorActive = clrColor;

    if (m_nEntry == BtnState::Active)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_FontSize                                                */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_FontSize(long *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_uiFontSize;

	return S_OK;
}


/*************************************************************************/
/* Function: put_FontSize                                                */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_FontSize(long lSize)
{
    if ((UINT)lSize != m_uiFontSize)
    {
        m_uiFontSize = (UINT)lSize;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_Text                                                    */
/* Description: return the Text that is displayed in the control.        */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_Text(BSTR *pText)
{
    if (!pText)
    {
        return E_POINTER;
    }

    *pText = m_bstrTextValue.Copy();

    return S_OK;
}


/*************************************************************************/
/* Function: put_Text                                                    */
/* Description: set the text to be displayed in the control.             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_Text(BSTR wsText)
{
    if (_wcsicmp(m_bstrTextValue, wsText) != 0)
    {
        m_bstrTextValue = wsText;
        FireViewChange();
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontFace                                                */
/* Description: return the FontFace property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_FontFace(BSTR *pFontFace)
{
    if (!pFontFace)
    {
        return E_POINTER;
    }

    *pFontFace = m_bstrFontFace.Copy();
    
	return S_OK;
}


/*************************************************************************/
/* Function: put_FontFace                                                */
/* Description: set the FontFace property.                               */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_FontFace(BSTR wsFontFace)
{
    if (_wcsicmp(m_bstrFontFace, wsFontFace) != 0)
    {
        m_bstrFontFace = wsFontFace;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontStyle                                               */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_FontStyle(BSTR *pFontStyle)
{
    if (!pFontStyle)
    {
        return E_POINTER;
    }

    *pFontStyle = m_bstrFontStyle.Copy();
    
    return S_OK;
}


/*************************************************************************/
/* Function: put_FontStyle                                               */
/* Description: set the FontStyle property. The style string should      */
/* contain either "Normal", or concatenation of one or more strings of:  */
/* "Bold", "Italic", "Underline", "Strikeout". Default is "Normal".      */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_FontStyle(BSTR wsFontStyle)
{
    if (_wcsicmp(m_bstrFontStyle, wsFontStyle) != 0)
    {
        m_bstrFontStyle = wsFontStyle;
        m_fDirty = true;
    }

    return S_OK;
}

/*************************************************************************/
/* Function: get_ImageStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageStatic(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Static].Copy();
	return S_OK;
}/* end of function get_ImageStatic */

/*************************************************************************/
/* Function: put_ImageStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageStatic(BSTR strFilename){

    if (!m_bstrFilename[BtnState::Disabled])
        PutImage(strFilename, BtnState::Disabled);
	return (PutImage(strFilename, BtnState::Static));
}/* end of function put_ImageStatic */

/*************************************************************************/
/* Function: get_ImageHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageHover(BSTR *pstrFilename){

    *pstrFilename = m_bstrFilename[BtnState::Hover].Copy();    
    return S_OK;
}/* end of function get_ImageHover */

/*************************************************************************/
/* Function: put_ImageHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageHover(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Hover));
}/* end of function put_ImageHover */

/*************************************************************************/
/* Function: get_ImagePush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImagePush(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Push].Copy();    
    return S_OK;
}/* end of function get_ImagePush */

/*************************************************************************/
/* Function: put_ImagePush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImagePush(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Push));
}/* end of function put_ImagePush */

/*************************************************************************/
/* Function: get_ImageDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageDisabled(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Disabled].Copy();    
    return S_OK;
}/* end of function get_ImagePush */

/*************************************************************************/
/* Function: put_ImageDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageDisabled(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Disabled));
}/* end of function put_ImagePush */

/*************************************************************************/
/* Function: get_ImageActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageActive(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Active].Copy();    
    return S_OK;
}/* end of function get_ImagePush */

/*************************************************************************/
/* Function: put_ImageActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageActive(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Active));
}/* end of function put_ImagePush */

/*************************************************************************/
/* Function: PutImage                                                    */
/* Description: Reads the DIB file (from file or resource) into a DIB,   */
/* updates palette and rects of the internal bitmap.                     */
/* Also forces redraw if changing the active image.                      */
/*************************************************************************/
HRESULT CMSMFBBtn::PutImage(BSTR strFilename, int nEntry){

	USES_CONVERSION;
    HRESULT hr = S_OK;

	m_bstrFilename[nEntry] = strFilename;

    TCHAR strBuffer[MAX_PATH] = TEXT("\0");

     bool fGrayOut = false;

    if(BtnState::Disabled == nEntry){

        fGrayOut = gcfGrayOut;
    }/* end of if statement */

    hr = m_pBitmap[nEntry]->PutImage(strFilename, m_hRes, TRUE, m_blitType, NORMAL);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(nEntry == m_nEntry ){
        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function PutImage */

/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Handles when buttons is selected. Captures the mouse     */
/* movents (supported for windowless, via interfaces).                   */
/*************************************************************************/
LRESULT CMSMFBBtn::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    if (m_nEntry == BtnState::Disabled){
        
        return 0;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if(PtOnButton(xPos, yPos)){

        // we are really on the buttons bitmap and we pushed it

        if(BtnState::Hover !=  m_nEntry){
            // in hover case we already have captured the mouse, so do not do
            // that again
            SetCapture(true); // capture the mouse messages
        }/* end of if statement */

	    SetButtonState(BtnState::Push);

    }/* end of if statement */

    Fire_OnMouseDown();

	return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Releases the capture, updates the button visual state,   */
/* and if release on the buttons image fire the event.                   */
/*************************************************************************/
LRESULT CMSMFBBtn::OnButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
        
    LONG lRes = 0;

    DWORD dwTick = ::GetTickCount();

    ATLTRACE(TEXT("old stamp %d\n"), m_dwButtonClickStamp);
    ATLTRACE(TEXT("new stamp %d\n"), dwTick);
    if ( dwTick - m_dwButtonClickStamp <= ::GetDoubleClickTime()) {
        
        uMsg = WM_LBUTTONDBLCLK;
        OnDblClick(uMsg, wParam, lParam, bHandled);
        return 0;
    }
    
    else 
        m_dwButtonClickStamp = dwTick;

    if (m_nEntry == BtnState::Disabled){

        ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);        
        ForwardWindowMessage(WM_USER_ENDHELP, (WPARAM) m_hWnd, 0, lRes);
        
        return lRes;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool bOnButtonImage = PtOnButton(xPos, yPos);
    bool bFire = (m_nEntry == BtnState::Push);
	
    if(bOnButtonImage){

        SetButtonState(BtnState::Static); //change to static even 
        SetCapture(false); // release the capture of the mouse messages
    }
    else {

        SetButtonState(BtnState::Static);
        // do it only when we do not hower, if we hower, then keep the capture
        SetCapture(false); // release the capture of the mouse messages
    }/* end of if statement */

    if (bFire){

        if(bOnButtonImage){

            Fire_OnClick();
        }/* end of if statement */


    }/* end of if statement */

    Fire_OnMouseUp();

    ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);
    ForwardWindowMessage(WM_USER_ENDHELP, (WPARAM) m_hWnd, 0, lRes);
 
	return lRes;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnDblClick                                                  */
/* Description: Releases the capture, updates the button visual state,   */
/* and if release on the buttons image fire the event.                   */
/*************************************************************************/
LRESULT CMSMFBBtn::OnDblClick(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    LONG lRes = 0;

    if (m_nEntry == BtnState::Disabled){

        ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);
        
        return lRes;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool bOnButtonImage = PtOnButton(xPos, yPos);
	
    if(bOnButtonImage){

        SetButtonState(BtnState::Static); //change to static even 
        SetCapture(false); // release the capture of the mouse messages
    }
    else {

        SetButtonState(BtnState::Static);
        // do it only when we do not hower, if we hower, then keep the capture
        SetCapture(false); // release the capture of the mouse messages
    }/* end of if statement */

    if(bOnButtonImage){
        
        Fire_OnDblClick();
    }/* end of if statement */
        
    ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);
 
	return lRes;
}/* end of function OnDblClick */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSMFBBtn::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == BtnState::Disabled)
        return 0;

	LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if (m_nEntry != BtnState::Push){    
    
        if(PtOnButton(xPos, yPos)){
            if(BtnState::Hover != m_nEntry || S_OK != GetCapture()){

                SetCapture(true); // capture the mouse messages
		        SetButtonState(BtnState::Hover);
            }/* end of if statement */
        }
        else {

            if(BtnState::Static != m_nEntry){

                SetCapture(false); // release the capture of the mouse messages
		        SetButtonState(BtnState::Static);
            }/* end of if statement */
        }/* end of if statement */
	}/* end of if statement */

	return 0;
}/* end of function OnMouseMove */

/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFBBtn::OnSetFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == BtnState::Disabled){

        if(GetFocus() == S_OK){

            SetFocus(false);
        }/* end of if statement */

        FireViewChange();
        return(-1);
    }/* end of if statement */

    FireViewChange();
    return 0;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: OnKillFocus                                                 */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFBBtn::OnKillFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    FireViewChange();
    return 0;
}/* end of function OnKillFocus */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFBBtn::PtOnButton(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnButton(pos));
}/* end of function PtOnButton */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Determines if the point is located on the button.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFBBtn::PtOnButton(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    //TODO: Add also if we are on bitmap itsels possibly

#ifdef _DEBUG
if(bRet)
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d in Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
else
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d NOT ON RECT Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
#endif

    return(bRet);
}/* end of function PtOnButton */

/*************************************************************************/
/* Function: OnKeyDown                                                   */
/* Description: Depresses the button.                                    */
/*************************************************************************/
LRESULT CMSMFBBtn::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    LONG lRes = 0;

    if (m_nEntry == BtnState::Disabled){
        
        return 0;
    }/* end of if statement */


    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 

            SetButtonState(BtnState::Push);

            break;
    }/* end of if statement */    
    return(lRes);
}/* end of function OnKeyDown */

/*************************************************************************/
/* Function: OnKeyUp                                                     */
/* Description: Distrubutes the keyboard messages properly.              */
/*************************************************************************/
LRESULT CMSMFBBtn::OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    LONG lRes = 0;

    if (m_nEntry == BtnState::Disabled){
        
        return 0;
    }/* end of if statement */

    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 

            Fire_OnClick();

            SetButtonState(BtnState::Static);

            break;
    }/* end of if statement */    
    return(lRes);
}/* end of function OnKeyUp */

/*************************************************************************/
/* Function: OnSize                                                      */
/* Description: Invalidate region since size has changed                 */
/*************************************************************************/
LRESULT CMSMFBBtn::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    InvalidateRgn();
    return 0;
}

/*************************************************************************/
/* Function: OnDispChange                                                */
/* Description: Forwards this message to all the controls.               */
/*************************************************************************/
LRESULT CMSMFBBtn::OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    LONG lRes =0;  
    
    long cBitsPerPixel = (long)wParam; 
    long cxScreen = LOWORD(lParam); 
    long cyScreen = HIWORD(lParam); 

    for (int i=0; i<cgMaxBtnStates; i++) {
        if (m_pBitmap[i])
            m_pBitmap[i]->OnDispChange(cBitsPerPixel, cxScreen, cyScreen);
    }

    return(lRes);
}/* end of function OnDispChange */

/*************************************************************************/
/* Function: SetButtonState                                              */
/* Description: Sets the button states forces redraw.                    */
/*************************************************************************/
HRESULT CMSMFBBtn::SetButtonState(BtnState btnState){

    HRESULT hr = S_OK;

    bool fRedraw = false;
    
    if(btnState != m_nEntry ){

        fRedraw = true;
    }/* end of if statement */

    m_nEntry = btnState;    
    
    if(fRedraw){

        if (m_nEntry == BtnState::Disabled){
            
            SetFocus(false); // disable the focus
            SetCapture(false);
        }/* end of if statement */

        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        m_fDirty = true;  // to force an update of font color
	    FireViewChange(); // update the display
        //InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function SetButtonState */

/*************************************************************************/
/* Function: About                                                       */
/* Description: Displays the AboutBox                                    */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::About(){

	 HRESULT hr = S_OK;

     const INT ciMaxBuffSize = MAX_PATH; // enough for the text
     TCHAR strBuffer[ciMaxBuffSize];
     TCHAR strBufferAbout[ciMaxBuffSize];

     if(!::LoadString(_Module.m_hInstResource, IDS_BTN_ABOUT, strBuffer, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

     if(!::LoadString(_Module.m_hInstResource, IDS_ABOUT, strBufferAbout, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

    ::MessageBox(::GetFocus(), strBuffer, strBufferAbout, MB_OK);

	return (hr);
}/* end of function About */

/*************************************************************/
/* Function: get_Disable                                     */
/* Description: Returns OLE-BOOL if disabled or enabled.     */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::get_Disable(VARIANT_BOOL *pVal){

    *pVal =  BtnState::Disabled == m_nEntry ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}/* end of function get_Disable */

/*************************************************************/
/* Function: put_Disable                                     */
/* Description: Disable or enable the buttons (disabled      */
/* are greyed out and do not except mouse clicks).           */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::put_Disable(VARIANT_BOOL newVal){

    // TODO: Right Now We Get Restored Automatically into Static state
    // we could detect the mouse and see if we are in static 
    // or hower state
    BtnState  btnSt =  VARIANT_FALSE == newVal ? BtnState::Static : BtnState::Disabled;	
    HRESULT hr = SetButtonState(btnSt);

	return (hr);
}/* end of function put_Disable */

/*************************************************************/
/* Function: get_BtnState                                    */
/* Description: Gets current button state.                   */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::get_BtnState(long *pVal){

    *pVal =  (long) m_nEntry;
	return S_OK;
}/* end of function get_BtnState */

/*************************************************************/
/* Function: put_BtnState                                    */
/* Description: Sets the button state manually.              */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::put_BtnState(long newVal){

    HRESULT hr = SetButtonState((BtnState)newVal);
	return(hr);
}/* end of function put_BtnState */

/*************************************************************/
/* Name: SetObjectRects                                      */
/* Description: Update tooltip rect object is being moved    */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){

    // Call the default method first
    IOleInPlaceObjectWindowlessImpl<CMSMFBBtn>::SetObjectRects(prcPos, prcClip);

    return UpdateTooltipRect(prcPos);
}/* end of function SetObjectRects */

/*************************************************************************/
/* End of file: MSMFBBtn.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\mfbar.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MFBar.h                                                         */
/* Description: Declaration of CMFBar                                    */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MFBAR_H_
#define __MFBAR_H_

#include "resource.h"       // main symbols
#include "MSMFCnt.h"
#include <atlctl.h>
#include <activscp.h>
#include <list>
#include "chobj.h"
#include "eobj.h"
#include "cbitmap.h"
#include "CstUtils.h"
#include "MSMFCntCP.h"

enum HitRegion 
{
    NOHIT = 1, 
    LEFT = 2, 
    TOP = 4, 
    RIGHT = 8, 
    BOTTOM = 16,
    PREMOVE = 0xef,
    PRESIZE = 0xff
};

using namespace std;

/*************************************************************************/
/* Template list containing contained objects.                           */
/*************************************************************************/
typedef list<CHostedObject*> CNTOBJ;
typedef list<CEventObject*> CNTEVNT;

/*************************************************************************/
/* Class: CMFBar                                                         */
/*************************************************************************/
class ATL_NO_VTABLE CMFBar : 
	public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CMFBar, IMSMFBar, &IID_IMSMFBar, &LIBID_MSMFCNTLib>,
	//public IDispatchImpl<IMFBar, &IID_IMFBar, &LIBID_BBTNLib>,
	public CComControl<CMFBar>,
	public IPersistStreamInitImpl<CMFBar>,
	public IOleControlImpl<CMFBar>,
	public IOleObjectImpl<CMFBar>,
	public IOleInPlaceActiveObjectImpl<CMFBar>,
	public IViewObjectExImpl<CMFBar>,
	public IOleInPlaceObjectWindowlessImpl<CMFBar>,
    public IPersistPropertyBagImpl<CMFBar>,
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
    public IActiveScriptSite, 
    public IActiveScriptSiteWindow,
    // public IProvideMultipleClassInfo, // Implemented via template above
// #####  END  ACTIVEX SCRIPTING SUPPORT #####
    public IObjectSafetyImpl<CMFBar, INTERFACESAFE_FOR_UNTRUSTED_CALLER| INTERFACESAFE_FOR_UNTRUSTED_DATA>,    
    //public IProvideMultipleClassInfoImpl<CMFBar, &CLSID_MFBar, &DIID__MFBar, &LIBID_BBTNLib>,
    public IProvideClassInfo2Impl<&CLSID_MSMFBar, &DIID__IMSMFBar, &LIBID_MSMFCNTLib>,
// ####  BEGIN CONTAINER SUPPORT ####
    public IOleClientSite,
    public IOleContainer,
    public IOleInPlaceUIWindow,
    public IOleInPlaceSiteWindowless,
// ####  END CONTAINER SUPPORT ####
	public CComCoClass<CMFBar, &CLSID_MSMFBar>,
    public IConnectionPointContainerImpl<CMFBar>,    
    public CProxy_IMSMFBar<CMFBar>,
    public CMSMFCntrlUtils<CMFBar> // custom utilities we share across controls
{
public:
    CMFBar(){Init();};
    virtual ~CMFBar();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFBAR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMFBar)
	COM_INTERFACE_ENTRY(IMSMFBar)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
    COM_INTERFACE_ENTRY(IActiveScriptSite)
    COM_INTERFACE_ENTRY(IActiveScriptSiteWindow)
   // COM_INTERFACE_ENTRY(IProvideMultipleClassInfo)
// #####  END  ACTIVEX SCRIPTING SUPPORT #####
	COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
// ####  BEGIN CONTAINER SUPPORT ####
    COM_INTERFACE_ENTRY(IOleClientSite)
    COM_INTERFACE_ENTRY(IOleContainer)
    COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
    COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
	COM_INTERFACE_ENTRY(IOleInPlaceSite)
// ####  END CONTAINER SUPPORT #### 
END_COM_MAP()

BEGIN_PROP_MAP(CMFBar)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("TransparentBlitType", 20, CLSID_NULL)
    PROP_ENTRY("ScriptFile", 10, CLSID_NULL) 
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("Window", DISPID_HWND, CLSID_NULL)              
    PROP_ENTRY("Caption", DISPID_CAPTION, CLSID_NULL)
    PROP_ENTRY("ResourceDLL", 32, CLSID_NULL)    
    PROP_ENTRY("BackgroundImage", 19, CLSID_NULL)
    PROP_ENTRY("AutoLoad", 25, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)    
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CMFBar)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_ERASEBKGND,  OnErase)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_USER_ENDHELP, OnHelpEnd)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_SIZING, OnSizing)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)
    MESSAGE_HANDLER(WM_COMMAND, OnCommand)
    MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
    MESSAGE_HANDLER(WM_SETICON, OnSetIcon)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnHelp)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)    
    MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDispChange)
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
    MESSAGE_RANGE_HANDLER(WM_KEYFIRST, WM_KEYLAST, OnKeyMessage)
    MESSAGE_HANDLER(WM_USER_FOCUS, OnUserFocus)
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, CMSMFCntrlUtils<CMFBar>::MFOnQueryNewPalette)
    MESSAGE_HANDLER(WM_PALETTECHANGED, CMSMFCntrlUtils<CMFBar>::MFOnPaletteChanged)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
    // add m_bMessageReflect
    lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled);
	if(bHandled) return TRUE;
    MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
	CHAIN_MSG_MAP(CComControl<CMFBar>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnActivate(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSizing(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysCommand(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCaptureChanged(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnHelp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetIcon(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled);
    LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled);
    LRESULT OnUserFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelpEnd(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
   	LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/);    
    LRESULT OnPaint(UINT /* uMsg */, WPARAM wParam, LPARAM /* lParam */, BOOL& /* lResult */);
    HRESULT OnDraw(ATL_DRAWINFO& di);
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

BEGIN_CONNECTION_POINT_MAP(CMFBar)
	CONNECTION_POINT_ENTRY(DIID__IMSMFBar)
END_CONNECTION_POINT_MAP()

// IMFBar
public:
	STDMETHOD(Load)();
    STDMETHOD(Run)(BSTR strStatement);
	STDMETHOD(About)();
    STDMETHOD(CreateObject)(BSTR strObjectID, BSTR strProgID, long lx, long ly, long lWidth, 
        long lHeight,BSTR strPropBag, VARIANT_BOOL fDisabled, BSTR strScriptHook);
    STDMETHOD(ShowSelfSite)(long nCmd); 
    STDMETHOD(SetupSelfSite)(long lx, long ly, long lWitdh, long lHeight, BSTR strPropBag, 
        VARIANT_BOOL fDisabled, VARIANT_BOOL fHelpDisabled,VARIANT_BOOL fWindowDisabled);
    STDMETHOD(AddObject)(BSTR strObjectID, LPDISPATCH pDisp);
    STDMETHOD(AddScriptlet)(BSTR strObjectID, BSTR strEvent, BSTR strEventCode);
    STDMETHOD(EnableObject)(BSTR strObjectID, VARIANT_BOOL fEnable);
   	STDMETHOD(ObjectEnabled)(BSTR strObjectID, VARIANT_BOOL* pfEnabled);
    STDMETHOD(EnableObjectInput)(BSTR strObjectID, VARIANT_BOOL fEnable);
   	STDMETHOD(ObjectInputEnabled)(BSTR strObjectID, VARIANT_BOOL* pfEnabled);   	
   	STDMETHOD(SetObjectPosition)(BSTR strObjectID, long xPos, long yPos, long lWidth, long lHeight);
    STDMETHOD(GetObjectPosition)(BSTR strObjectID, long* pxPos, long* pyPos, long* plWidth, long* plHeight);
	STDMETHOD(GetObjectUnknown)(BSTR strObjectID, IUnknown** ppUnk);
   	STDMETHOD(get_ScriptFile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ScriptFile)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ScriptLanguage)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ScriptLanguage)(/*[in]*/ BSTR newVal);    
    STDMETHOD(HookScriptlet)(BSTR strObjectID, BSTR strEvent, BSTR strEventCode);
	STDMETHOD(DestroyScriptEngine)();
    STDMETHOD(get_MinHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_MinHeight)(/*[in]*/ long newVal);
	STDMETHOD(get_MinWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_MinWidth)(/*[in]*/ long newVal);
    STDMETHOD(put_Caption)(BSTR bstrCaption);
   	STDMETHOD(WinHelp)(BSTR strHelpFile, long lCommand, long dwData);
    STDMETHOD(HTMLHelp)(BSTR strHelpFile, long lCommand, VARIANT vData);        
    STDMETHOD(Close)(DWORD dwSaveOption);        
    STDMETHOD(ProcessMessages)();
    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip){
        HRESULT hr = IOleInPlaceObjectWindowlessImpl<CMFBar>::SetObjectRects(prcPos, prcClip);
        if(FAILED(hr)) return(hr);
        AdjustRects(prcPos); return (hr);
    }/* end of function SetObjectRects */
    STDMETHOD(Close)();
	STDMETHOD(get_BackgroundImage)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackgroundImage)(/*[in]*/ BSTR newVal);
    STDMETHOD(SetPriority)(long lPriority);
    STDMETHOD(SetPriorityClass)(long lPriorityClass);
   	STDMETHOD(get_AutoLoad)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_AutoLoad)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(SetRoundRectRgn)(long x1, long y1, long x2, long y2, long width, long height);
	STDMETHOD(SetRectRgn)(long x1, long y1, long x2, long y2 );
    STDMETHOD(SetObjectFocus)(BSTR strObjectID, VARIANT_BOOL fEnable);
    STDMETHOD(ForceKey)(LONG lVirtKey, LONG lKeyData, VARIANT_BOOL fEat);
    STDMETHOD(SetObjectExtent)(BSTR strID, long lWidth, long lHeight);
	STDMETHOD(MessageBox)(BSTR strText, BSTR strCaption, long lType);
    STDMETHOD(get_ActivityTimeout)(/*[out, retval]*/ long *plTimeout);
	STDMETHOD(put_ActivityTimeout)(/*[in]*/ long lTimout);
    STDMETHOD(Sleep)(long lMiliseconds);
	STDMETHOD(SetTimeout)(long lMilliseconds, long lId);	
    STDMETHOD(GetUserLCID)(long *plcid);
    USE_MF_TRANSPARENT_FLAG
    //STDMETHOD(get_TransparentBlit)(/*[out, retval]*/ TransparentBlitType *pVal);
	//STDMETHOD(put_TransparentBlit)(/*[in]*/ TransparentBlitType newVal);
    USE_MF_RESOURCEDLL  // replaces the two lines below
    //STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal);
	//STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_CmdLine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CmdLine)(/*[in]*/ BSTR newVal);
    STDMETHOD(ResetFocusArray)();
	STDMETHOD(AddFocusObject)(BSTR strObjectID);
	STDMETHOD(PopupSystemMenu)(long x, long y);
	STDMETHOD(GetSelfHostUserData)(BSTR strAppName, long* lData);
	STDMETHOD(SaveSelfHostUserData)(BSTR strAppName, long lData);
	STDMETHOD(RestoreSelfHostState)(BSTR strAppName);
	STDMETHOD(SaveSelfHostState)(BSTR strAppName);
	STDMETHOD(get_DoubleClickTime)(/*[out, retval]*/ long *pVal);
    STDMETHOD(SetCookie)(BSTR strObjectID, VARIANT vCookie);
    STDMETHOD(GetCookie)(BSTR strObjectID, VARIANT *pvCookie);

    HRESULT OnPostVerbInPlaceActivate();

    static HICON m_hIcon;
#if 0
    static HICON m_hIconSmall;
#endif

    static CWndClassInfo& GetWndClassInfo(){ 
        static HBRUSH wcBrush = ::CreateSolidBrush(RGB(0,0,0));         
        //static HBRUSH wcBrush = ::CreateSolidBrush(RGB(156,173,198));         
	    static CWndClassInfo wc = {{ sizeof(WNDCLASSEX), CS_DBLCLKS /*CS_OWNDC*/, StartWindowProc, 
		      0, 0, NULL, m_hIcon, NULL, wcBrush /* (HBRUSH)(COLOR_BTNFACE + 1) */, 
              NULL, TEXT("MSMFVideoClass"), NULL }, 
		    NULL, NULL, IDC_ARROW, TRUE, 0, _T("") };
	    return wc; 
    }/* end of function GetWndClassInfo */
		
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
  // *** IActiveScriptSite methods ***
  STDMETHOD(GetLCID)(LCID *plcid);
  STDMETHOD(GetItemInfo)(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppiunkItem, ITypeInfo **ppti);
  STDMETHOD(GetDocVersionString)(BSTR *pszVersion);
  //STDMETHOD(RequestItems)(void);
  //STDMETHOD(RequestTypeLibs)(void);
  STDMETHOD(OnScriptTerminate)(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo);
  STDMETHOD(OnStateChange)(SCRIPTSTATE ssScriptState);
  STDMETHOD(OnScriptError)(IActiveScriptError *pscripterror);
  STDMETHOD(OnEnterScript)(void);
  STDMETHOD(OnLeaveScript)(void);

  // *** IActiveScriptSiteWindow methods ***
  STDMETHOD(GetWindow)(HWND *phwnd);
  STDMETHOD(EnableModeless)(BOOL fEnable);

  // *** IProvideMultipleClassInfo methods ***
  // Implemented in the template above
  //STDMETHOD(GetMultiTypeInfoCount)(ULONG *pcti);
  //STDMETHOD(GetInfoOfIndex)(ULONG iti, DWORD dwFlags, ITypeInfo** pptiCoClass, DWORD* pdwTIFlags, ULONG* pcdispidReserved, IID* piidPrimary, IID* piidSource);
// #####  END  ACTIVEX SCRIPTING SUPPORT #####


// ####  BEGIN CONTAINER SUPPORT ####
  // IOleClientSite
  STDMETHOD(SaveObject)(){ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));}
  STDMETHOD(GetMoniker)(DWORD /*dwAssign*/, DWORD /*dwWhichMoniker*/, IMoniker** /*ppmk*/){ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));}
  STDMETHOD(GetContainer)(IOleContainer** ppContainer){ATLTRACENOTIMPL(_T("IOleClientSite::GetContainer"));}
  STDMETHOD(ShowObject)(){ATLTRACENOTIMPL(_T("IOleClientSite::ShowObject"));}
  STDMETHOD(OnShowWindow)(BOOL /*fShow*/){ATLTRACENOTIMPL(_T("IOleClientSite::OnShowWindow"));}
  STDMETHOD(RequestNewObjectLayout)(){ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));}
  // IOleContainer
  STDMETHOD(ParseDisplayName)(IBindCtx* /*pbc*/, LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/){ATLTRACENOTIMPL(_T("IOleClientSite::ParseDisplayName"));}
  STDMETHOD(EnumObjects)(DWORD /*grfFlags*/, IEnumUnknown** ppenum);		
  STDMETHOD(LockContainer)(BOOL fLock){ATLTRACENOTIMPL(_T("IOleClientSite::LockContainer"));}

  // IOleInPlaceUIWindow
  STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
  {
	    ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::GetBorder\n"));
      return S_OK;
  }

  STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
  {
      ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::RequestBorderSpace\n"));
	    return INPLACE_E_NOTOOLSPACE;
  }

  STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
  {
      ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::SetBorderSpace\n"));
	  return S_OK;
  }

  STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/){

      ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::SetActiveObject\n"));
	  m_spActiveObject = pActiveObject;
	  return S_OK;
  }
	    

    // IOleInPlaceSite
#if 0
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		*phwnd = m_hWnd;
		return S_OK;
	}
#endif

	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		ATLTRACENOTIMPL(_T("IOleWindow::CanInPlaceActivate"));
	}


	STDMETHOD(CanInPlaceActivate)(){return S_OK;}
    STDMETHOD(OnInPlaceActivate)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnInPlaceActivate"));}
    STDMETHOD(OnInPlaceDeactivate)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnInPlaceDeactivate"));}
    STDMETHOD(OnUIDeactivate)(BOOL /*fUndoable*/){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnUIDeactivate\n"));}		
	STDMETHOD(OnUIActivate)()
	{
		ATLTRACE2(atlTraceHosting, 0, _T("IOleInPlaceSite::OnUIActivate\n"));
		m_bUIActive = TRUE;
		return S_OK;
	}
	STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo){
        ATLTRACENOTIMPL(_T("IOleInPlaceSite::GetWindowContext"));}
	STDMETHOD(Scroll)(SIZE /*scrollExtant*/){ATLTRACENOTIMPL(_T("IOleInPlaceSite::Scroll"));}
	STDMETHOD(DiscardUndoState)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::DiscardUndoState"));}
	STDMETHOD(DeactivateAndUndo)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::DeactivateAndUndo"));}
	STDMETHOD(OnPosRectChange)(LPCRECT /*lprcPosRect*/){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnPosRectChange"));}

    // IOleInPlaceSiteEx
    STDMETHOD(OnInPlaceActivateEx)(BOOL* /*pfNoRedraw*/, DWORD dwFlags){ATLTRACENOTIMPL(_T("IOleInPlaceSiteEx::OnInPlaceActivateEx"));};
	STDMETHOD(OnInPlaceDeactivateEx)(BOOL /*fNoRedraw*/){ATLTRACENOTIMPL(_T("IOleInPlaceSiteEx::OnInPlaceDeactivateEx"));};
	STDMETHOD(RequestUIActivate)(){return S_OK;}
    STDMETHOD(CanWindowlessActivate)();
	STDMETHOD(GetCapture)();
	STDMETHOD(SetCapture)(BOOL fCapture);
	STDMETHOD(GetFocus)();
	STDMETHOD(SetFocus)(BOOL fFocus);
	STDMETHOD(GetDC)(LPCRECT /*pRect*/, DWORD /*grfFlags*/, HDC* phDC);
	STDMETHOD(ReleaseDC)(HDC hDC);
	STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase);
	STDMETHOD(InvalidateRgn)(HRGN hRGN = NULL, BOOL fErase = FALSE);	
	STDMETHOD(ScrollRect)(INT /*dx*/, INT /*dy*/, LPCRECT /*pRectScroll*/, LPCRECT /*pRectClip*/){return S_OK;}
	STDMETHOD(AdjustRect)(LPRECT /*prc*/){return S_OK;}
	STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);	
    STDMETHOD(HasObjectCapture)(BSTR strObjectID, VARIANT_BOOL* pfEnable);
	STDMETHOD(BitsPerPixel)(long* plBits);
	STDMETHOD(Invalidate)();
	STDMETHOD(InvalidateObjectRect)(BSTR strObjectID);
	STDMETHOD(HasObjectFocus)(BSTR strObjectID, VARIANT_BOOL* pfFocus);

#ifdef _WIN64
  	HRESULT STDMETHODCALLTYPE get_Window(LONG_PTR* phWnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Window\n"));
		*phWnd = (LONG_PTR)m_hWnd;
		return S_OK;
	}
#endif

// ####  END CONTAINER SUPPORT ####


protected: // member variables
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
  CComPtr<IActiveScript>        m_ps;
  CComPtr<IActiveScriptParse>   m_psp;
// #####  END  ACTIVEX SCRIPTING SUPPORT #####
// ####  BEGIN CONTAINER SUPPORT ####
  // !!!!TODO: Take these out and implement the interfaces !!!!
  //CComPtr<IOleObject> m_spOleObject; // TODO: Implement this in the outer container, move out
  CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
  CNTOBJ m_cntObj; // collection of contained controls
  CNTEVNT m_cntEvnt; // collection of events
  CNTOBJ m_cntFocus; // collection of contained controls
  CComBSTR m_strScriptLanguage;
  CComBSTR m_strScriptFile;
  bool m_fSelfHosted;  // see if we are hosting our self
  LONG m_lMinWidth; // the smallest Width we allow
  LONG m_lMinHeight; // the smallest Height we allow
  bool m_fHandleHelp; // flag to change the help
  //TransparentBlitType m_blitType; moved to common utils

  POINT m_ptMouse; // last mouse point
  POINT m_ptMouseOld;

  // Ambient property storage
  unsigned long m_bCanWindowlessActivate:1;
  unsigned long m_ulCapture;
  CComBSTR m_bstrBackImageFilename;
  CBitmap  *m_pBackBitmap;
  VARIANT_BOOL m_fAutoLoad;
  bool m_fForceKey; // flag to see if the force Key method was fired
  VARIANT_BOOL m_fEat;
  LONG m_lVirtKey; // virt key passed down by the force key
  LONG m_lKeyData; // data passes by force key method
  RECT m_rcWnd;
  RECT m_rcWndOld;
  bool m_bMouseDown;
  HitRegion m_HitRegion;
  long m_lTimeout; // activity timeout
  bool m_fUserActivity; // flag if there is a user activity
  bool m_fWaitingForActivity; // flag which set when we wait for an activity
  HMENU m_hMenu;
  BOOL m_bSysMenuOn;
  BOOL m_bHandleEnter;
  HINSTANCE m_hinstHelpDll; // HTML HELP DLL we load dynamically
  BOOL m_bHandleUserFocus;

// ####  END CONTAINER SUPPORT ####
public: // member variables  					
	OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl
    CComBSTR m_bstrCaption;     // stock property for caption
    CComBSTR m_strCmdLine;       // command line argument we set
    LONG m_nReadyState; // ready state change stock property


protected: // private helper functions
    HRESULT Init(); // Initializes the internal variables
    HRESULT Cleanup(); // End of function cleanup
    HRESULT AdjustRects(const LPCRECT prcPos); // calls all our contained objects and the adjusts their
                                 // rects in the case we have moved
    HRESULT CreateScriptEngine();
    HRESULT GetParentHWND(HWND* pWnd);
    BOOL GetClientRect(LPRECT lpRect) const;
    HWND GetParent();
    HRESULT GetToolbarName(BSTR* strToolbarName);
    HRESULT SendMessageToCtl(CHostedObject* pObj, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled, LONG& lRes, bool fWndwlsOnly = true, bool fActiveOnly = true);    
    HRESULT SetReadyState(LONG lReadyState);
    HRESULT ResetCaptureFlags();    
    HRESULT ResetFocusFlags(); 
	HRESULT SendMouseMessageToCtl(CHostedObject* pObj, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled, LONG& lRes);
    HitRegion ResizeHitRegion(POINT p);
    HRESULT UpdateCursor(HitRegion hitRegion);
    HRESULT SetObjectFocus(CHostedObject* pObj, BOOL fSet, LONG& lRes);
    HRESULT FindObject(BSTR strObjectID, CHostedObject** ppObj);
    HRESULT MoveFocus(bool fForward, LONG& lRes);
    HRESULT SetClosestFocus(LONG& lRes, CHostedObject* pStartObj = NULL, bool fForward = true);
    LRESULT HandleMoveSizeKey(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HWND CallHtmlHelp(HWND hwndCaller,LPCTSTR pszFile,UINT uCommand,ULONG_PTR dwData);
};

#endif //__MFBAR_H_
/*************************************************************************/
/* End of file: MFBar.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfbbtn.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFBBtn.h                                                      */
/* Description: Declaration of CMSMFBBtn                                 */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFBBTN_H_
#define __MSMFBBTN_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "CstUtils.h"
#include "ctext.h"
#include "cbitmap.h"
#include "MSMFCntCP.h"

/*************************************************************************/
/* Consts                                                                */
/*************************************************************************/
const int cgMaxBtnStates = 5; // the number of button states
 
/*************************************************************************/
/* Class: CMSMFBBtn                                                      */
/*************************************************************************/
class ATL_NO_VTABLE CMSMFBBtn : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CMSMFBBtn, IMSMFBBtn, &IID_IMSMFBBtn, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFBBtn>,
	public IPersistStreamInitImpl<CMSMFBBtn>,
	public IOleControlImpl<CMSMFBBtn>,
	public IOleObjectImpl<CMSMFBBtn>,
	public IOleInPlaceActiveObjectImpl<CMSMFBBtn>,
	public IViewObjectExImpl<CMSMFBBtn>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFBBtn>,
    public IPersistPropertyBagImpl<CMSMFBBtn>,
	public CComCoClass<CMSMFBBtn, &CLSID_MSMFBBtn>,
    public IProvideClassInfo2Impl<&CLSID_MSMFBBtn, &DIID__IMSMFBBtn, &LIBID_MSMFCNTLib>,
    public IObjectSafetyImpl<CMSMFBBtn, INTERFACESAFE_FOR_UNTRUSTED_CALLER| INTERFACESAFE_FOR_UNTRUSTED_DATA>,    
#ifdef _WMP
    public IWMPUIPluginImpl<CMSMFBBtn>,
    public IWMPUIPluginEventsImpl,
#endif
    public IConnectionPointContainerImpl<CMSMFBBtn>,
    public CProxy_IMSMFBBtn< CMSMFBBtn >,
    public CMSMFCntrlUtils<CMSMFBBtn> // custom utilities we share across controls        
{
public:
	CMSMFBBtn();
	virtual ~CMSMFBBtn();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFBBTN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFBBtn)
	COM_INTERFACE_ENTRY(IMSMFBBtn)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
#ifdef _WMP
    COM_INTERFACE_ENTRY(IWMPUIPlugin)
    COM_INTERFACE_ENTRY(IWMPUIPlugin2)
    COM_INTERFACE_ENTRY(IWMPUIPluginEvents)
#endif
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMFBBtn)    
	CONNECTION_POINT_ENTRY(DIID__IMSMFBBtn)
END_CONNECTION_POINT_MAP()

BEGIN_PROP_MAP(CMSMFBBtn)
    // the properties are loaded in order below
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
    PROP_ENTRY("TransparentBlitType", 4, CLSID_NULL)
    PROP_ENTRY("ResourceDLL", 13, CLSID_NULL)
	PROP_ENTRY("ImageStatic",1, CLSID_NULL)
	PROP_ENTRY("ImageHover", 2, CLSID_NULL)
	PROP_ENTRY("ImagePush",  3, CLSID_NULL)
    PROP_ENTRY("ImageDisabled",  14, CLSID_NULL)
    PROP_ENTRY("ImageActive",  15, CLSID_NULL)
    PROP_ENTRY("ToolTip",    9, CLSID_NULL)
    PROP_ENTRY("ToolTipMaxWidth", 12, CLSID_NULL)
    PROP_ENTRY("Windowless", 20, CLSID_NULL)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CMSMFBBtn)    
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFBBtn>)
	MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
	MESSAGE_HANDLER(WM_LBUTTONDBLCLK,   OnDblClick)
    MESSAGE_HANDLER(WM_SETFOCUS,    OnSetFocus)    
    MESSAGE_HANDLER(WM_KILLFOCUS,    OnKillFocus)    
    MESSAGE_HANDLER(WM_KEYUP,  OnKeyUp)
    MESSAGE_HANDLER(WM_KEYDOWN,  OnKeyDown)
    MESSAGE_HANDLER(WM_SIZE,  OnSize)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDispChange)
	CHAIN_MSG_MAP(CComControl<CMSMFBBtn>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
  
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDblClick(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKillFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSMFBBtn
public:
	STDMETHOD(get_TextHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TextWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_ColorActive)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorActive)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorDisable)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorDisable)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorStatic)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorStatic)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorHover)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorHover)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorPush)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorPush)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ImagePush)(/*[out, retval]*/ BSTR *pstrFilename);
	STDMETHOD(put_ImagePush)(/*[in]*/ BSTR strFilename);
	STDMETHOD(get_ImageHover)(/*[out, retval]*/ BSTR *pstrFilename);
	STDMETHOD(put_ImageHover)(/*[in]*/ BSTR strFilename);
	STDMETHOD(get_ImageStatic)(/*[out, retval]*/ BSTR *pstrFilename);
	STDMETHOD(put_ImageStatic)(/*[in]*/ BSTR strFilename);    
	STDMETHOD(get_Disable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Disable)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_BtnState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_BtnState)(/*[in]*/ long newVal);    
    USE_MF_RESOURCEDLL  // replaces the two lines below
    //STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal);
	//STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal);
    USE_MF_TOOLTIP
	//STDMETHOD(GetDelayTime)(/*[in]*/ long delayType, /*[out, retval]*/ long *pVal);
	//STDMETHOD(SetDelayTime)(/*[in]*/ long delayType, /*[in]*/ long newVal);	
    //STDMETHOD(get_ToolTip)(/*[out, retval]*/ BSTR *pVal);
	//STDMETHOD(put_ToolTip)(/*[in]*/ BSTR newVal);    
	//STDMETHOD(get_ToolTipMaxWidth)(/*[out, retval]*/ long *pVal);
	//STDMETHOD(put_ToolTipMaxWidth)(/*[in]*/ long newVal);
    STDMETHOD(get_ImageActive)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ImageActive)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ImageDisabled)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ImageDisabled)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontStyle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontStyle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontFace)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontFace)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Text)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Text)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontSize)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_FontSize)(/*[in]*/ long newVal);
    STDMETHOD(About)();
    USE_MF_WINDOWLESS_ACTIVATION // replaces the two lines below
	//STDMETHOD(get_Windowless)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	//STDMETHOD(put_Windowless)(/*[in]*/ VARIANT_BOOL newVal);
    USE_MF_TRANSPARENT_FLAG
	HRESULT OnDraw(ATL_DRAWINFO& di);

// IOleInPlaceObjectWindowlessImpl
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);

// IOleObjectImp
    //HRESULT OnPostVerbInPlaceActivate();
   
public:			
	enum BtnState {Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4};

    USE_MF_OVERWRITES

    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers

public: // member variable that have to be public due to ATL
    OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl
	
private: // data member variables
    CComBSTR m_bstrFilename[cgMaxBtnStates]; // filenames containing the images
    CBitmap* m_pBitmap[cgMaxBtnStates];

    BtnState m_nEntry;
    CText       m_cText;   // text drawing object
    bool        m_fDirty; // if any attribute for the text drawing object changes
    CComBSTR    m_bstrTextValue;
    CComBSTR    m_bstrFontFace;
    CComBSTR    m_bstrFontStyle;
    UINT        m_uiFontSize;
    OLE_COLOR   m_clrColorActive;
    OLE_COLOR   m_clrColorStatic;
    OLE_COLOR   m_clrColorHover;
    OLE_COLOR   m_clrColorPush;
    OLE_COLOR   m_clrColorDisable;
    DWORD       m_dwButtonClickStamp;

protected: // helper functions
    void Init();
    bool PtOnButton(LONG x, LONG y);
    bool PtOnButton(POINT pos);
    HRESULT PutImage(BSTR strFilename, int nEntry);
    HRESULT SetButtonState(BtnState btnState);        
    HRESULT SetTextProperties();
};

#endif //__MSMFBBTN_H_
/*************************************************************************/
/* End of file: MSMFBBtn.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfcntcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSMFCNTCP_H_
#define _MSMFCNTCP_H_


template <class T>
class CProxy_IMSMFSldr : public IConnectionPointImpl<T, &DIID__IMSMFSldr, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseDown()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseUp()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnValueChange(FLOAT flNewVal)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = flNewVal;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};

template <class T>
class CProxy_IMSMFText : public IConnectionPointImpl<T, &DIID__IMSMFText, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseDown()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseUp()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
};

template <class T>
class CProxy_MSMFImg : public IConnectionPointImpl<T, &DIID__MSMFImg, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseDown()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseUp()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
};


template <class T>
class CProxy_IMSMFBar : public IConnectionPointImpl<T, &DIID__IMSMFBar, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseDown()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseUp()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnResize(LONG lWidth, LONG lHeight, LONG lCode)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = lWidth;
				pvars[1] = lHeight;
				pvars[0] = lCode;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnHelp(BSTR strObjectID, BSTR strExtraInfo = ::SysAllocString(L""))
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = strObjectID;
				pvars[0] = strExtraInfo;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnKeyUp(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnKeyDown(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ActivityDeclined()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x14, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_ActivityStarted()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x15, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_Timeout(LONG lTimerID)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = lTimerID;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x16, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnDblClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x17, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnSysKeyUp(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x18, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnSysKeyDown(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x19, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnActivate(VARIANT_BOOL bActivated)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bActivated;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x1a, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReadyStateChange(LONG ReadyState)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = ReadyState;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(DISPID_READYSTATECHANGE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};


template <class T>
class CProxy_IMSMFBBtn : public IConnectionPointImpl<T, &DIID__IMSMFBBtn, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseDown()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseUp()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnDblClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfimg.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFImg.h                                                       */
/* Description: Declaration of CMSMFImg                                  */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFIMG_H_
#define __MSMFIMG_H_

#include "resource.h"       // main symbols
#include "CBitmap.h"
#include <atlctl.h>
#include "CstUtils.h"
#include "MSMFCntCP.h"

/////////////////////////////////////////////////////////////////////////////
// CMSMFImg
class ATL_NO_VTABLE CMSMFImg : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CMSMFImg, IMSMFImg, &IID_IMSMFImg, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFImg>,
	public IPersistStreamInitImpl<CMSMFImg>,
	public IOleControlImpl<CMSMFImg>,
	public IOleObjectImpl<CMSMFImg>,
	public IOleInPlaceActiveObjectImpl<CMSMFImg>,
	public IViewObjectExImpl<CMSMFImg>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFImg>,
	public IPersistStorageImpl<CMSMFImg>,
    public IPersistPropertyBagImpl<CMSMFImg>,
	public IProvideClassInfo2Impl<&CLSID_MSMFImg, &DIID__MSMFImg, &LIBID_MSMFCNTLib>,
    public IObjectSafetyImpl<CMSMFImg, INTERFACESAFE_FOR_UNTRUSTED_CALLER| INTERFACESAFE_FOR_UNTRUSTED_DATA>,    
	public CComCoClass<CMSMFImg, &CLSID_MSMFImg>,
    public CMSMFCntrlUtils<CMSMFImg>, // custom utilities we share across controls
    public CProxy_MSMFImg< CMSMFImg >,
    public IConnectionPointContainerImpl<CMSMFImg>
{
public:
	CMSMFImg();
	virtual ~CMSMFImg();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFIMG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFImg)
	COM_INTERFACE_ENTRY(IMSMFImg)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CMSMFImg)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("Windowless", 3, CLSID_NULL)
    PROP_ENTRY("TransparentBlitType", 4, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMFImg)
	CONNECTION_POINT_ENTRY(DIID__MSMFImg)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CMSMFImg)
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFImg>)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDispChange)
	CHAIN_MSG_MAP(CComControl<CMSMFImg>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    HRESULT OnDraw(ATL_DRAWINFO& di);
    USE_MF_OVERWRITES
    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers
    LRESULT OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSMFImg
public:
    USE_MF_RESOURCEDLL
    USE_MF_TRANSPARENT_FLAG
	STDMETHOD(get_Image)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Image)(/*[in]*/ BSTR newVal);
    USE_MF_WINDOWLESS_ACTIVATION	
    OLE_COLOR m_clrBackColor;

protected: // member variables
    CBitmap  m_BackBitmap;
    CComBSTR m_bstrBackFilename;

protected: 
    void Init();
    HRESULT PutImage(BSTR strFilename);
};

#endif //__MSMFIMG_H_
/*************************************************************************/
/* End of file: MSMFImg.h                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfimg.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFImg.cpp                                                     */
/* Description: Implementation of CMSMFImg Static Image class            */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFImg.h"

/////////////////////////////////////////////////////////////////////////////
// CMSMFImg

/*************************************************************************/
/* Function:  CMSMFImg                                                   */
/*************************************************************************/
CMSMFImg::CMSMFImg(){
    
    Init();    
}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes variable states.                             */
/*************************************************************************/
void CMSMFImg::Init(){

    m_blitType = DISABLE;
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
        
#if 0 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
#endif    
}/* end of function Init */

/*************************************************************************/
/* Function:  ~CMSMFImg                                                 */
/* Description: Cleanup the stuff we allocated here rest will be done    */
/* in the button destructor.                                             */
/*************************************************************************/
CMSMFImg::~CMSMFImg(){
       
    //Init();    
    ATLTRACE(TEXT("In the IMG Object destructor!\n"));
}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Does the basic drawing                                   */
/* First draws the background the the thumb at the specific position.    */
/*************************************************************************/
HRESULT CMSMFImg::OnDraw(ATL_DRAWINFO& di){

    HRESULT hr = S_OK;

    BOOL bRet = TRUE;
    HDC hdc = di.hdcDraw;
    RECT rcClient = *(RECT*)di.prcBounds;

    HPALETTE hNewPal = NULL;

    if (!m_BackBitmap.IsEmpty()){

        hNewPal = CBitmap::GetSuperPal();
    }
    else {

        hNewPal = m_BackBitmap.GetPal();
    }/* end of if statement */

    if (::IsWindow(m_hWnd)){ //in other words not windowless

        CBitmap::SelectRelizePalette(hdc, hNewPal);
    }/* end of if statement */


    // DRAW THE BACKGROUND
    if (!m_BackBitmap.IsEmpty()){

        bRet = m_BackBitmap.PaintTransparentDIB(hdc, &rcClient, 
            &rcClient);
    } 
    else {

        COLORREF clr;
        ::OleTranslateColor (m_clrBackColor, CBitmap::GetSuperPal(), &clr); 

        HBRUSH hbrBack = ::CreateSolidBrush(clr);                        

        if(NULL == hbrBack){
            
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        ::FillRect(hdc, &rcClient, hbrBack);
        ::DeleteObject(hbrBack);
    }/* end of if statement */
    	
	return (hr);
}/* end of function OnDraw */

/*************************************************************************/
/* Function: OnDispChange                                                */
/* Description: Forwards this message to all the controls.               */
/*************************************************************************/
LRESULT CMSMFImg::OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){
    LONG lRes =0;    
    
    long cBitsPerPixel = (long) wParam; 
    long cxScreen = LOWORD(lParam); 
    long cyScreen = HIWORD(lParam); 

    m_BackBitmap.OnDispChange(cBitsPerPixel, cxScreen, cyScreen);
    
    return(lRes);
}/* end of function OnDispChange */

/*************************************************************************/
/* Function: PutImage                                                    */
/* Description: Sets the image of the background.                        */
/*************************************************************************/
HRESULT CMSMFImg::PutImage(BSTR strFilename){

    HRESULT hr = S_OK;

    m_bstrBackFilename = strFilename;

    bool fGrayOut = false;
    
    hr = m_BackBitmap.PutImage(strFilename, m_hRes, FALSE, m_blitType, 
        MAINTAIN_ASPECT_RATIO);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    InvalidateRgn(); // our helper function            
   
    return(hr);
}/* end of function PutImage */

/*************************************************************************/
/* Function: get_Image                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFImg::get_Image(BSTR *pstrFilename){

    *pstrFilename = m_bstrBackFilename.Copy();
	return S_OK;
}/* end of function get_Image */

/*************************************************************************/
/* Function: put_Image                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFImg::put_Image(BSTR strFilename){
	
	return (PutImage(strFilename));
}/* end of function put_BackStatic */

/*************************************************************************/
/* End of file: MSMFImg.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfcnt.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFCnt.cpp                                                     */
/* Description: Implementation of DLL Exports.                           */
/* Author: David Janecek                                                 */
/*************************************************************************/
// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSMFCntps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSMFCnt.h"

#include "MSMFCnt_i.c"
#include "MFBar.h"
#include "MSMFBBtn.h"
#include "MSMFImg.h"
#include "MSMFSldr.h"
#include "MSMFText.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MSMFBar, CMFBar)
OBJECT_ENTRY(CLSID_MSMFBBtn, CMSMFBBtn)
OBJECT_ENTRY(CLSID_MSMFImg, CMSMFImg)
OBJECT_ENTRY(CLSID_MSMFSldr, CMSMFSldr)
OBJECT_ENTRY(CLSID_MSMFText, CMSMFText)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSMFCNTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}

/*************************************************************************/
/* End of file: MSMFCnt.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfsldr.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFSldr.h                                                      */
/* Description: Declaration of MSMFSldr                                  */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFSLDR_H_
#define __MSMFSLDR_H_

#include "resource.h"       // main symbols
#include "CBitmap.h"
#include <atlctl.h>
#include "CstUtils.h"
#include "MSMFCntCP.h"

/*************************************************************************/
/* Consts                                                                */
/*************************************************************************/
const int cgMaxSldrStates = 5; // the number of button states

/////////////////////////////////////////////////////////////////////////////
// CMSMFSldr
class ATL_NO_VTABLE CMSMFSldr : 
	public CComObjectRootEx<CComSingleThreadModel>,	
    public CStockPropImpl<CMSMFSldr, IMSMFSldr, &IID_IMSMFSldr, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFSldr>,
	public IPersistStreamInitImpl<CMSMFSldr>,
	public IOleControlImpl<CMSMFSldr>,
	public IOleObjectImpl<CMSMFSldr>,
	public IOleInPlaceActiveObjectImpl<CMSMFSldr>,
	public IViewObjectExImpl<CMSMFSldr>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFSldr>,
	public IPersistStorageImpl<CMSMFSldr>,
	public ISpecifyPropertyPagesImpl<CMSMFSldr>,
	public IQuickActivateImpl<CMSMFSldr>,
	public IDataObjectImpl<CMSMFSldr>,	
	public CComCoClass<CMSMFSldr, &CLSID_MSMFSldr>,
    public IProvideClassInfo2Impl<&CLSID_MSMFSldr, &DIID__IMSMFSldr, &LIBID_MSMFCNTLib>,
    public IPersistPropertyBagImpl<CMSMFSldr>,
    public IConnectionPointContainerImpl<CMSMFSldr>,
    public CProxy_IMSMFSldr< CMSMFSldr>,
    public CMSMFCntrlUtils<CMSMFSldr> // custom utilities we share across controls
{
public:
    CMSMFSldr();
    virtual ~CMSMFSldr();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFSLDR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFSldr)
	COM_INTERFACE_ENTRY(IMSMFSldr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMFSldr)    
	CONNECTION_POINT_ENTRY(DIID__IMSMFSldr)	
END_CONNECTION_POINT_MAP()


BEGIN_PROP_MAP(CMSMFSldr)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("ResourceDLL", 19, CLSID_NULL)
    PROP_ENTRY("Windowless", 20, CLSID_NULL)
    //PROP_ENTRY("TransparentBlitType", 4, CLSID_NULL)
	PROP_ENTRY("ThumbStatic",5, CLSID_NULL)
	PROP_ENTRY("ThumbHover", 6, CLSID_NULL)
	PROP_ENTRY("ThumbPush",  7, CLSID_NULL)
    PROP_ENTRY("ThumbDisabled",  8, CLSID_NULL)
    PROP_ENTRY("ThumbActive",  9, CLSID_NULL)
    PROP_ENTRY("BackStatic",10, CLSID_NULL)
	PROP_ENTRY("BackHover", 11, CLSID_NULL)
	PROP_ENTRY("BackPush",  12, CLSID_NULL)
    PROP_ENTRY("BackDisabled",  13, CLSID_NULL)
    PROP_ENTRY("BackActive",  14, CLSID_NULL)
    PROP_ENTRY("ThumbWidth",  4, CLSID_NULL)
    PROP_ENTRY("Min",  2, CLSID_NULL)
    PROP_ENTRY("Max",  3, CLSID_NULL)
    PROP_ENTRY("Value",  1, CLSID_NULL)
    PROP_ENTRY("XOffset",  17, CLSID_NULL)
    PROP_ENTRY("YOffset",  18, CLSID_NULL)
    PROP_ENTRY("ToolTip",  23, CLSID_NULL)
    PROP_ENTRY("ToolTipMaxWidth", 26, CLSID_NULL)

	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CMSMFSldr)
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFSldr>)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
    MESSAGE_HANDLER(WM_KEYUP,  OnKeyUp)
    MESSAGE_HANDLER(WM_KEYDOWN,  OnKeyDown)
    MESSAGE_HANDLER(WM_SETFOCUS,    OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS,    OnKillFocus)    
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDispChange)
	CHAIN_MSG_MAP(CComControl<CMSMFSldr>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()

    LRESULT OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnSetFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKillFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);   
    LRESULT OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSMFSldr
// IMSMFSldr
public:
	STDMETHOD(get_Disable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Disable)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_SldrState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SldrState)(/*[in]*/ long newVal);
	STDMETHOD(get_ThumbActive)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbActive)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbDisabled)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbDisabled)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbPush)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbPush)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbHover)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbHover)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbStatic)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbStatic)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BackActive)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackActive)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackDisabled)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackDisabled)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackPush)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackPush)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackHover)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackHover)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackStatic)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackStatic)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_XOffset)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_XOffset)(/*[in]*/ LONG newVal);
    STDMETHOD(get_YOffset)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_YOffset)(/*[in]*/ LONG newVal);	
    STDMETHOD(get_ThumbWidth)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_ThumbWidth)(/*[in]*/ LONG newVal);	
	STDMETHOD(get_Max)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Max)(/*[in]*/ float newVal);
	STDMETHOD(get_Min)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Min)(/*[in]*/ float newVal);
	STDMETHOD(get_Value)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Value)(/*[in]*/ float newVal);
    USE_MF_RESOURCEDLL  // replaces the two lines below
    //STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal);
	//STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal);
    USE_MF_WINDOWLESS_ACTIVATION
    USE_MF_TRANSPARENT_FLAG
    USE_MF_TOOLTIP

    HRESULT OnDraw(ATL_DRAWINFO& di);

    // IOleInPlaceObjectWindowlessImpl
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);

    enum SldrState {Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4};

    USE_MF_OVERWRITES
    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers


public: // member variable that have to be public due to ATL
	STDMETHOD(get_ArrowKeyDecrement)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_ArrowKeyDecrement)(/*[in]*/ float newVal);
	STDMETHOD(get_ArrowKeyIncrement)(/*[out, retval]*/ FLOAT *pVal);
	STDMETHOD(put_ArrowKeyIncrement)(/*[in]*/ FLOAT newVal);
    OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl

private:
    FLOAT m_fValue;
    FLOAT m_fMin;
    FLOAT m_fMax;    
    LONG  m_lXOffset; 
    LONG  m_lYOffset; 
    LONG  m_lThumbWidth; 
    FLOAT m_fKeyIncrement;
    FLOAT m_fKeyDecrement;
    CBitmap* m_pThumbBitmap[cgMaxSldrStates];
    CComBSTR m_bstrThumbFilename[cgMaxSldrStates]; // filenames containing the thumb images
    CBitmap* m_pBackBitmap[cgMaxSldrStates];
    CComBSTR m_bstrBackFilename[cgMaxSldrStates]; // filenames containing the background images
    SldrState m_nEntry;
    RECT m_rcThumb; // position for the thumb

protected:
    void Init();
    HRESULT RecalculateValue();
    HRESULT RecalculateTumbPos(); // Centers the thumb rect around the m_fValue
    HRESULT PutThumbImage(BSTR strFilename, int nEntry);
    HRESULT PutBackImage(BSTR strFilename, int nEntry);
    HRESULT SetSliderState(SldrState sldrState);    
    HRESULT SetThumbPos(LONG xPos);
    HRESULT OffsetX(LONG& xPos);
    HRESULT FitValue();
    bool PtOnSlider(LONG x, LONG y);
    bool PtOnSlider(POINT pos);
    bool PtOnThumb(LONG x, LONG y);
    bool PtOnThumb(POINT pos);
};

#endif //__MSMFSLDR_H_
/*************************************************************************/
/* End of file: MSMFSldr.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmfsldr.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFSldr.cpp                                                    */
/* Description: Implementation of CMSMFSldr                              */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFSldr.h"

#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

/////////////////////////////////////////////////////////////////////////////
// CMSMFSldr

/*************************************************************************/
/* Function:  CMSMFSldr                                                  */
/*************************************************************************/
CMSMFSldr::CMSMFSldr(){

    Init();    
    for(INT i = 0; i < cgMaxSldrStates; i++){        

	    m_pThumbBitmap[i] = new CBitmap;
        m_pBackBitmap[i] = new CBitmap;
    }/* end of for loop */

}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes variable states.                             */
/*************************************************************************/
void CMSMFSldr::Init(){

    m_nEntry = SldrState::Static;
    m_fValue =0.2f;
    m_fMin =0;
    m_fMax = 100;
    m_lXOffset = 5; 
    m_lYOffset = 2;
    m_fKeyIncrement = 1.0f;
    m_fKeyDecrement = 1.0f;
    m_lThumbWidth = 8;
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    
    ::ZeroMemory(&m_rcThumb, sizeof(RECT));
}/* end of function Init */

/*************************************************************************/
/* Function:  ~CMSMFSldr                                                 */
/* Description: Cleanup the stuff we allocated here rest will be done    */
/* in the button destructor.                                             */
/*************************************************************************/
CMSMFSldr::~CMSMFSldr(){

    ATLTRACE(TEXT("In the SLIDER Object destructor!\n"));
    for(INT i = 0; i < cgMaxSldrStates; i++){        

	    delete m_pThumbBitmap[i];
        delete m_pBackBitmap[i];
        m_pBackBitmap[i] = NULL;
        m_pThumbBitmap[i] = NULL;
    }/* end of for loop */

    Init();    
}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Does the basic drawing                                   */
/* First draws the background the the thumb at the specific position.    */
/*************************************************************************/
HRESULT CMSMFSldr::OnDraw(ATL_DRAWINFO& di){

    HRESULT hr = S_OK;

    BOOL bRet = TRUE;
    HDC hdc = di.hdcDraw;
    RECT rcClient = *(RECT*)di.prcBounds;

    HPALETTE hNewPal = m_pBackBitmap[m_nEntry]->GetPal();;

    if (::IsWindow(m_hWnd)){ // is not windowless
                    
        CBitmap::SelectRelizePalette(di.hdcDraw, hNewPal);
    }/* end of if statement */


    // DRAW THE BACKGROUND
    if (::IsWindow(m_hWnd) && m_blitType != DISABLE) {
            
            COLORREF clr;            
            ::OleTranslateColor (m_clrBackColor, hNewPal, &clr);        
            
            // fill background of specific color
            HBRUSH hbrBack = ::CreateSolidBrush(clr);            

            if(NULL == hbrBack){
            
                hr = E_FAIL;
                return(hr);
            }/* end of if statement */

            //::FillRect(hdc, &rcClient, hbrBack);
            ::FillRect(di.hdcDraw, (LPRECT)di.prcBounds, hbrBack);
            ::DeleteObject(hbrBack);
    }/* end of if statement */

    if (m_pBackBitmap[m_nEntry]){

        bRet = m_pBackBitmap[m_nEntry]->PaintTransparentDIB(hdc, &rcClient,
            &rcClient);
    } 
    else {

        COLORREF clr;
        ::OleTranslateColor (m_clrBackColor, m_pBackBitmap[m_nEntry]->GetPal(), &clr); 

        HBRUSH hbrBack = ::CreateSolidBrush(clr);                        
        ::FillRect(hdc, &rcClient, hbrBack);
        ::DeleteObject(hbrBack);
    }/* end of if statement */

    // DRAW THE THUMB
#if 0 // just for debugging purposes
    COLORREF clr = RGB(0xff, 0, 0);
    
    HBRUSH hbrBack = ::CreateSolidBrush(clr);                        
    ::FillRect(hdc, &m_rcThumb, hbrBack);
    ::DeleteObject(hbrBack);
#endif

    if (m_pBackBitmap[m_nEntry]){

            RECT rcThumb = m_rcThumb;

            if(!m_bWndLess){

                 ATLASSERT(::IsWindow(m_hWnd));

                 ::OffsetRect(&rcThumb, -m_rcPos.left, -m_rcPos.top);        
            }/* end of if statement */            

        bRet = m_pThumbBitmap[m_nEntry]->PaintTransparentDIB(hdc, &rcThumb,
            &rcThumb);
    } /* end of if statement */
        
    hr = GetFocus();

    // THIS ASSUMES WE ARE REPAINTING THE WHOLE CONTROL
    // WHICH IS WHAT ATL AT THIS INCARNATION DOES
    if(S_OK == hr){

        ::DrawFocusRect(hdc, &rcClient);
    }/* end of if statement */

    if(!bRet){

        hr = E_UNEXPECTED;
    }/* end of if statement */
    	
	return (hr);
}/* end of function OnDraw */

/*************************************************************************/
/* Function: OnSize                                                      */
/* Description: Handles the onsize message if we are self contained.     */
/*************************************************************************/
LRESULT CMSMFSldr::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    bHandled = true;

    RecalculateTumbPos();

    //ATLASSERT(FALSE); // move the code from SetObjectRects in here  

    return 0;
}/* end of function OnSize */

/*************************************************************************/
/* Function: OnDispChange                                                */
/* Description: Forwards this message to all the controls.               */
/*************************************************************************/
LRESULT CMSMFSldr::OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    LONG lRes =0;    

    long cBitsPerPixel = (long) wParam; 
    long cxScreen = LOWORD(lParam); 
    long cyScreen = HIWORD(lParam); 

    for (int i=0; i<cgMaxSldrStates; i++) {
        if (m_pThumbBitmap[i])
            m_pThumbBitmap[i]->OnDispChange(cBitsPerPixel, cxScreen, cyScreen);
    }
    for (i=0; i<cgMaxSldrStates; i++) {
        if (m_pBackBitmap[i])
            m_pBackBitmap[i]->OnDispChange(cBitsPerPixel, cxScreen, cyScreen);
    }

    return(lRes);
}/* end of function OnDispChange */

/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFSldr::OnSetFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == SldrState::Disabled){

        if(GetFocus() == S_OK){

            SetFocus(false);
        }/* end of if statement */

         FireViewChange();
        return(-1);
    }/* end of if statement */

    FireViewChange();
    return 0;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: OnKillFocus                                                 */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFSldr::OnKillFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    FireViewChange();
    return 0;
}/* end of function OnKillFocus */

/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Handles when buttons is selected. Captures the mouse     */
/* movents (supported for windowless, via interfaces).                   */
/*************************************************************************/
LRESULT CMSMFSldr::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == SldrState::Disabled){
        
        return 0;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if(PtOnSlider(xPos, yPos)){        

        if(SldrState::Hover !=  m_nEntry){
            // in hover case we already have captured the mouse, so do not do
            // that again
            SetCapture(true); // capture the mouse messages
        }/* end of if statement */

        OffsetX(xPos);	    
        SetThumbPos(xPos);
        SetSliderState(SldrState::Push);
    }/* end of if statement */

    Fire_OnMouseDown();

	return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Releases the capture, updates the button visual state,   */
/* and if release on the buttons image fire the event.                   */
/*************************************************************************/
LRESULT CMSMFSldr::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    LONG lRes = 0;

    if (m_nEntry == SldrState::Disabled){

        ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);
        ForwardWindowMessage(WM_USER_ENDHELP, (WPARAM) m_hWnd, 0, lRes);
        
        return lRes;
    }/* end of if statement */


    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool bOnButtonImage = PtOnSlider(xPos, yPos);
    bool bFire = (m_nEntry == SldrState::Push);
	
    if(bOnButtonImage){

        SetSliderState(SldrState::Static); //change to static even 
        SetCapture(false); // release the capture of the mouse messages
    }
    else {

        SetSliderState(SldrState::Static);
        // do it only when we do not hower, if we hower, then keep the capture
        SetCapture(false); // release the capture of the mouse messages
    }/* end of if statement */

    if (bFire){

        if(bOnButtonImage){

            OffsetX(xPos);
            SetThumbPos(xPos);
            Fire_OnClick();            
        }/* end of if statement */
    }/* end of if statement */

    Fire_OnMouseUp();

	ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);
    ForwardWindowMessage(WM_USER_ENDHELP, (WPARAM) m_hWnd, 0, lRes);

	return lRes;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSMFSldr::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == SldrState::Disabled)
        return 0;

	LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool fPointOnSlider = PtOnSlider(xPos, yPos);

    if (m_nEntry != SldrState::Push){    
    
        if(fPointOnSlider){
            if(SldrState::Hover != m_nEntry || S_OK != GetCapture()){

                SetCapture(true); // capture the mouse messages
		        SetSliderState(SldrState::Hover);
            }/* end of if statement */
        }
        else {

            if(SldrState::Static != m_nEntry){

                SetCapture(false); // release the capture of the mouse messages
		        SetSliderState(SldrState::Static);
            }/* end of if statement */
        }/* end of if statement */
    }
    else {
        if(fPointOnSlider){

            OffsetX(xPos);
            SetThumbPos(xPos);
            FireViewChange();
        }/* end of if statement */
	}/* end of if statement */

	return 0;
}/* end of function OnMouseMove */

/*************************************************************************/
/* Function: OnKeyDown                                                   */
/* Description: Depresses the button.                                    */
/*************************************************************************/
LRESULT CMSMFSldr::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;    
    LONG lRes = 0;

    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 
        case VK_LEFT:
        case VK_RIGHT:

            //SetSliderState(SldrState::Push);
            bHandled = TRUE;
            break;
    }/* end of if statement */    
    return(lRes);
}/* end of function OnKeyDown */

/*************************************************************************/
/* Function: OnKeyUp                                                     */
/* Description: Distrubutes the keyboard messages properly.              */
/*************************************************************************/
LRESULT CMSMFSldr::OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){
    
    LONG lRes = 0;
    bHandled = FALSE;    
    FLOAT m_fTmpValue = m_fValue;

    bool fFireClick = false;

    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 
            fFireClick = true;
            break;

        case VK_LEFT: m_fValue -= m_fKeyDecrement; FitValue();
             fFireClick = true;
             break;

        case VK_RIGHT: m_fValue += m_fKeyIncrement; FitValue();
            fFireClick = true;
            break;
    }/* end of switch statement */

    if(fFireClick){

        RecalculateTumbPos();

        Fire_OnClick(); // we clicked on it, it does not meen
        // we did change the value of it
        if(m_fTmpValue !=  m_fValue){

            Fire_OnValueChange(m_fValue);
        }/* end of if statement */
        //SetSliderState(SldrState::Static);

        bHandled = TRUE;
    }/* end of if statement */

    return(lRes);
}/* end of function OnKeyUp */

/*************************************************************/
/* Function: FitValue                                        */
/* Description: Fits the xVal inside the params.             */
/*************************************************************/
HRESULT CMSMFSldr::FitValue(){

    if(m_fValue < m_fMin){

        m_fValue = m_fMin;    
    }/* end of if statement */

    if(m_fValue > m_fMax){

        m_fValue = m_fMax;            
    }/* end of if statement */

    return(S_OK);
}/* end of function FitValue */

/*************************************************************/
/* Name: SetObjectRects                                      */
/* Description: Update thumbnail rect object is being moved  */
/*************************************************************/
STDMETHODIMP CMSMFSldr::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){
    // Call the default method first
    IOleInPlaceObjectWindowlessImpl<CMSMFSldr>::SetObjectRects(prcPos, prcClip);
  
    RecalculateTumbPos();

    return UpdateTooltipRect(prcPos);
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: PutThumbImage                                               */
/* Description: Sets the image to thumb.                                 */
/*************************************************************************/
HRESULT CMSMFSldr::PutThumbImage(BSTR strFilename, int nEntry){

    HRESULT hr = S_OK;

    m_bstrThumbFilename[nEntry] = strFilename;

    // figure out if we need to gray out the image

    bool fGrayOut = false;

    if(SldrState::Disabled == nEntry){

        fGrayOut = gcfGrayOut; 
    }/* end of if statement */

    hr = m_pThumbBitmap[nEntry]->PutImage(strFilename, m_hRes, TRUE, m_blitType, NORMAL);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(nEntry == m_nEntry ){
        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function PutThumbImage */

/*************************************************************************/
/* Function: PutBackImage                                               */
/* Description: Sets the image to Back.                                 */
/*************************************************************************/
HRESULT CMSMFSldr::PutBackImage(BSTR strFilename, int nEntry){

    HRESULT hr = S_OK;

    m_bstrBackFilename[nEntry] = strFilename;

    bool fGrayOut = false;

    if(SldrState::Disabled == nEntry){

        fGrayOut = gcfGrayOut; // TODO some more complex stuff if we get custom disable
                          // images                            
    }/* end of if statement */

    hr = m_pBackBitmap[nEntry]->PutImage(strFilename, m_hRes, TRUE, m_blitType, NORMAL);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(nEntry == m_nEntry ){
        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function PutBackImage */

/*************************************************************************/
/* Function: get_Value                                                   */
/* Description: Get the current value.                                   */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_Value(float *pVal){

	*pVal = m_fValue;

	return S_OK;
}/* end of function get_Value */

/*************************************************************************/
/* Function: put_Value                                                   */
/* Description: Sets the current value                                   */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_Value(float newVal){

	HRESULT hr = S_OK;

    if(newVal < m_fMin || newVal > m_fMax){

        hr = E_INVALIDARG;
        return (hr);
    }/* end of if statement */

    if(newVal == m_fValue){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    m_fValue = newVal;

    RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

	return (hr);
}/* end of function put_Value */

/*************************************************************************/
/* Function: get_Min                                                     */
/* Description: Gets the minimum value on which the rect should expand   */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_Min(float *pVal){

	*pVal = m_fMin;
	return S_OK;
}/* end of function get_Min */

/*************************************************************************/
/* Function: put_Max                                                     */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_Min(float newVal){

	HRESULT hr = S_OK;

	m_fMin = newVal;    
    hr = RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

    //ATLASSERT(SUCCEEDED(hr));

	return (S_OK);
}/* end of function put_Min */

/*************************************************************************/
/* Function: get_Max                                                     */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_Max(float *pVal){

	*pVal = m_fMax;
	return S_OK;
}/* end of function get_Max */

/*************************************************************************/
/* Function: put_Max                                                     */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_Max(float newVal){

    HRESULT hr = S_OK;

	m_fMax = newVal;    
    hr = RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

    //ATLASSERT(SUCCEEDED(hr));

	return (S_OK);
}/* end of function put_Max */

/*************************************************************************/
/* Function: get_XOffset                                                 */
/* Descriptoin: The part we do not draw on, end of the rail..            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_XOffset(LONG *pVal){

	*pVal = m_lXOffset;
	return S_OK;
}/* end of function get_XOffset */

/*************************************************************************/
/* Function: put_XOffset                                                 */
/* Description: Adjust it, cache our new FLOAT offset and recalculate    */
/* the position.                                                         */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_XOffset(LONG newVal){

    HRESULT hr = S_OK;

	m_lXOffset = newVal;    

    hr = RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

    //ATLASSERT(SUCCEEDED(hr));

	return (S_OK);
}/* end of function put_XOffset */

/*************************************************************************/
/* Function: get_Offset                                                  */
/* Descriptoin: The part we do not draw on, end of the rail..            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_YOffset(LONG *pVal){

	*pVal = m_lYOffset;
	return S_OK;
}/* end of function get_YOffset */

/*************************************************************************/
/* Function: put_YOffset                                                 */
/* Description: Adjust it, cache our new FLOAT offset and recalculate    */
/* the position.                                                         */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_YOffset(LONG newVal){

    HRESULT hr = S_OK;

	m_lYOffset = newVal;    

    m_rcThumb.top = m_rcPos.top - m_lYOffset;
    m_rcThumb.bottom = m_rcPos.bottom - m_lYOffset;

    FireViewChange();

	return (hr);
}/* end of function put_YOffset */

/*************************************************************************/
/* Function: get_ThumbWidth                                              */
/* Descriptoin: Width of the thumb.                                      */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbWidth(LONG *pVal){

	*pVal = m_lThumbWidth;
	return S_OK;
}/* end of function get_YOffset */

/*************************************************************************/
/* Function: put_ThumbWidth                                              */
/* Description: Sets the thumb width.                                    */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbWidth(LONG newVal){

    HRESULT hr = S_OK;

	m_lThumbWidth = newVal;    

    RecalculateTumbPos();

	return (S_OK);
}/* end of function put_YOffset */

/*************************************************************************/
/* Function: get_ThumbStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbStatic(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Static].Copy();
	return S_OK;
}/* end of function get_ThumbStatic */

/*************************************************************************/
/* Function: put_ThumbStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbStatic(BSTR strFilename){

    if (!m_bstrThumbFilename[SldrState::Disabled]){

        PutThumbImage(strFilename, SldrState::Disabled);
    }/* end of if statement */

	return (PutThumbImage(strFilename, SldrState::Static));
}/* end of function put_ThumbStatic */

/*************************************************************************/
/* Function: get_ThumbHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbHover(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Hover].Copy(); 

	return S_OK;
}/* end of function get_ThumbHover */

/*************************************************************************/
/* Function: put_ThumbHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbHover(BSTR strFilename){

	return (PutThumbImage(strFilename, SldrState::Hover));
}/* end of function put_ThumbHover */

/*************************************************************************/
/* Function: get_ThumbPush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbPush(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Push].Copy();    
    return S_OK;
}/* end of function get_ThumbPush */

/*************************************************************************/
/* Function: put_ThumbPush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbPush(BSTR strFilename){

    return (PutThumbImage(strFilename, SldrState::Push));
}/* end of function put_ThumbPush */

/*************************************************************************/
/* Function: get_ThumbDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbDisabled(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Disabled].Copy();    
    return S_OK;
}/* end of function get_ThumbDisabled */

/*************************************************************************/
/* Function: put_ThumbDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbDisabled(BSTR strFilename){

    return (PutThumbImage(strFilename, SldrState::Disabled));
}/* end of function put_ThumbDisabled */

/*************************************************************************/
/* Function: get_ThumbActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbActive(BSTR *pstrFilename){

    *pstrFilename = m_bstrThumbFilename[SldrState::Active].Copy();    
    return S_OK;
}/* end of function get_ThumbActive */

/*************************************************************************/
/* Function: put_ThumbActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbActive(BSTR strFilename){

    return (PutThumbImage(strFilename, SldrState::Active));
}/* end of function put_ThumbActive */


/*************************************************************************/
/* Function: get_BackStatic                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackStatic(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Static].Copy();
	return S_OK;
}/* end of function get_BackStatic */

/*************************************************************************/
/* Function: put_BackStatic                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackStatic(BSTR strFilename){

    if (!m_bstrBackFilename[SldrState::Disabled]){

        PutBackImage(strFilename, SldrState::Disabled);
    }/* end of if statement */

	return (PutBackImage(strFilename, SldrState::Static));
}/* end of function put_BackStatic */

/*************************************************************************/
/* Function: get_BackHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackHover(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Hover].Copy(); 

	return S_OK;
}/* end of function get_BackHover */

/*************************************************************************/
/* Function: put_BackHover                                               */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackHover(BSTR strFilename){

	return (PutBackImage(strFilename, SldrState::Hover));
}/* end of function put_BackHover */

/*************************************************************************/
/* Function: get_BackPush                                                */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackPush(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Push].Copy();    
    return S_OK;
}/* end of function get_BackPush */

/*************************************************************************/
/* Function: put_BackPush                                                */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackPush(BSTR strFilename){

    return (PutBackImage(strFilename, SldrState::Push));
}/* end of function put_BackPush */

/*************************************************************************/
/* Function: get_BackDisabled                                            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackDisabled(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Disabled].Copy();    
    return S_OK;
}/* end of function get_BackDisabled */

/*************************************************************************/
/* Function: put_BackDisabled                                            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackDisabled(BSTR strFilename){

    return (PutBackImage(strFilename, SldrState::Disabled));
}/* end of function put_BackDisabled */

/*************************************************************************/
/* Function: get_BackActive                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackActive(BSTR *pstrFilename){

    *pstrFilename = m_bstrBackFilename[SldrState::Active].Copy();    
    return S_OK;
}/* end of function get_BackActive */

/*************************************************************************/
/* Function: put_BackActive                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackActive(BSTR strFilename){

    return (PutBackImage(strFilename, SldrState::Active));
}/* end of function put_BackActive */

/*************************************************************/
/* Function: get_SldrState                                   */
/* Description: Gets current slider state.                   */
/*************************************************************/
STDMETHODIMP CMSMFSldr::get_SldrState(long *pVal){

	*pVal =  (long) m_nEntry;
	return S_OK;
}/* end of function get_SldrState */

/*************************************************************************/
/* Function: put_SldrState                                               */
/* Description: Sets slider state.                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_SldrState(long newVal){

	HRESULT hr = SetSliderState((SldrState)newVal);
	return (hr);
}/* end of function put_SldrState */

/*************************************************************/
/* Function: get_Disable                                     */
/* Description: Returns OLE-BOOL if disabled or enabled.     */
/*************************************************************/
STDMETHODIMP CMSMFSldr::get_Disable(VARIANT_BOOL *pVal){

    *pVal =  SldrState::Disabled == m_nEntry ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}/* end of function get_Disable */

/*************************************************************/
/* Function: put_Disable                                     */
/* Description: Disable or enable the buttons (disabled      */
/* are greyed out and do not except mouse clicks).           */
/*************************************************************/
STDMETHODIMP CMSMFSldr::put_Disable(VARIANT_BOOL newVal){

    SldrState  sldrSt =  VARIANT_FALSE == newVal ? SldrState::Static : SldrState::Disabled;	
    HRESULT hr = SetSliderState(sldrSt);

	return (hr);
}/* end of function put_Disable */

/*************************************************************************/
/* HELPER Functions                                                      */
/*************************************************************************/

/*************************************************************************/
/* Function: RecalculateTumbPos                                          */
/* Description: Centers the rect around x value.                         */
/* This one calculate the thumb rectangle x position.                    */
/*************************************************************************/
HRESULT CMSMFSldr::RecalculateTumbPos(){

    HRESULT hr = S_OK;

    // offset the rect depending on the y value
    m_rcThumb.top = m_rcPos.top + m_lYOffset;
    m_rcThumb.bottom = m_rcPos.bottom - m_lYOffset;

    // just offset x coordibate of the thumb the rect depening on the new xValue
    // calculate the length
    FLOAT flLengthU = m_fMax - m_fMin; // length in units
    FLOAT flLengthR = (FLOAT)RECTWIDTH(&m_rcPos) - 2* m_lXOffset;

    // calcalate the center of the thumb in RECT coordinates
    FLOAT fPos = (m_fValue - m_fMin) * flLengthR /  flLengthU;
    // fPos is at the center of the thumb
    
    LONG lThumbWidthHalf =  m_lThumbWidth/2;

    LONG lPos = (INT)fPos + m_lXOffset + m_rcPos.left;

    if(lPos < (m_rcPos.left + lThumbWidthHalf) || lPos > (m_rcPos.right - lThumbWidthHalf)){

        // we are of the rectangle
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    LONG lOldPos = m_rcThumb.left + lThumbWidthHalf;

    if(lOldPos == lPos){

        // thumb is in the same position as before so lets not bother with it
        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    m_rcThumb.left = lPos - lThumbWidthHalf;
    m_rcThumb.right = lPos + lThumbWidthHalf;    

    FireViewChange();

    return(hr);
}/* end of function RecalculateTumbPos */

/*************************************************************************/
/* Function: RecalculateValue                                            */
/* Description: Recalculates the slider value, since the thumb rect has  */
/* changed.                                                              */
/*************************************************************************/
HRESULT CMSMFSldr::RecalculateValue(){

    HRESULT hr = S_OK;

    // calculate the length
    FLOAT flLengthU = m_fMax - m_fMin; // length in units
    FLOAT flLengthR = (FLOAT)RECTWIDTH(&m_rcPos) - 2* m_lXOffset;

    LONG lThumbXPos = m_rcThumb.left + m_lThumbWidth/2;    
    lThumbXPos -= m_rcPos.left + m_lXOffset; // shift it over to 0 origin at left offset

    // calcalate the center of the thumb in VALUE coordinates
    FLOAT fPos = m_fMin + (lThumbXPos) * flLengthU / flLengthR;
    // fPos is at the center of the thumb
        
    if(fPos < (m_fMin) || fPos > (m_fMax)){

        // we are of the rectangle
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    m_fValue = fPos;

    // Fire Event that we have changed our value

    return(hr);
}/* end of function RecalculateValue */

/*************************************************************************/
/* Function: SetSliderState                                              */
/* Description: Sets the button states forces redraw.                    */
/*************************************************************************/
HRESULT CMSMFSldr::SetSliderState(SldrState sldrState){

    HRESULT hr = S_OK;

    bool fRedraw = false;
    
    if(sldrState != m_nEntry ){

        fRedraw = true;
    }/* end of if statement */

    m_nEntry = sldrState;    
    
    if(fRedraw){

        if (m_nEntry == SldrState::Disabled){
            
            SetFocus(false); // disable the focus
            SetCapture(false);
        }/* end of if statement */

        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
	    FireViewChange(); // update the display
        //InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function SetSliderState */

/*************************************************************************/
/* Function: PtOnSlider                                                  */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFSldr::PtOnSlider(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnSlider(pos));
}/* end of function PtOnSlider */

/*************************************************************************/
/* Function: PtOnSlider                                                  */
/* Description: Determines if the point is located on the slider.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFSldr::PtOnSlider(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    //TODO: Add also if we are on bitmap itsels possibly

#ifdef _DEBUG
if(bRet)
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d in Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
else
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d NOT ON RECT Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
#endif

    return(bRet);
}/* end of function PtOnSlider */

/*************************************************************************/
/* Function: PtOnThumb                                                   */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFSldr::PtOnThumb(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnThumb(pos));
}/* end of function PtOnThumb */

/*************************************************************************/
/* Function: PtOnThumb                                                  */
/* Description: Determines if the point is located on the slider.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFSldr::PtOnThumb(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    return(bRet);
}/* end of function PtOnThumb */

/*************************************************************************/
/* Function: OffsetX                                                     */
/* Description: Adjusts the x position for windows case when we are 0,0  */
/* based.                                                                */
/*************************************************************************/
HRESULT CMSMFSldr::OffsetX(LONG& xPos){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        return(hr);
    }/* end of if statement */

    ATLASSERT(::IsWindow(m_hWnd));

    xPos = m_rcPos.left + xPos;
    
    return(hr);
}/* end of function OffsetX */

/*************************************************************************/
/* Function: SetThumbPos                                                 */
/* Description: Sets the thumb position.                                 */
/*************************************************************************/
HRESULT CMSMFSldr::SetThumbPos(LONG xPos){

    HRESULT hr = S_FALSE;

    //MOVE THE THUMB TO THIS X POSITION        
    long ThumbWidthHalf = m_lThumbWidth /2;

    // see if the positions are the same
    if(m_rcThumb.left + ThumbWidthHalf != xPos){

        // see if we are with offset regions
        if((xPos > (m_rcPos.left  + m_lXOffset)) && 
           (xPos < (m_rcPos.right - m_lXOffset))){

            m_rcThumb.left = xPos - ThumbWidthHalf;
            m_rcThumb.right = xPos + ThumbWidthHalf;
            hr = RecalculateValue();

            if(SUCCEEDED(hr)){

                Fire_OnValueChange(m_fValue); // fire to the container that we are chaning the value
            }/* end of if statement */            
        }
        else {

            hr = E_FAIL; // not in the offset any more
        }/* end of if statement*/
    }/* end of if statement */

    return(hr);
}/* end of function SetThumbPos */

/*************************************************************************/
/* Function: get_ArrowKeyIncrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ArrowKeyIncrement(FLOAT *pVal){

    *pVal = m_fKeyIncrement;
	return S_OK;
}/* end of function get_ArrowKeyIncrement */

/*************************************************************************/
/* Function: put_ArrowKeyIncrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ArrowKeyIncrement(FLOAT newVal){

	m_fKeyIncrement = newVal;
	return S_OK;
}/* end of function put_ArrowKeyIncrement */

/*************************************************************************/
/* Function: get_ArrowKeyDecrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ArrowKeyDecrement(float *pVal){

	*pVal = m_fKeyDecrement;
	return S_OK;
}/* end of function get_ArrowKeyDecrement */

/*************************************************************************/
/* Function: put_ArrowKeyDecrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ArrowKeyDecrement(float newVal){
	
    m_fKeyDecrement = newVal;
	return S_OK;
}/* end of function put_ArrowKeyDecrement */

/*************************************************************************/
/* End of file: MSMFSldr.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmftext.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFText.cpp                                                    */
/* Description: Implementation of CMSMFText control object               */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFText.h"
#include "CBitmap.h"

/////////////////////////////////////////////////////////////////////////////
// CMSMFText

/*************************************************************************/
/* Function: CMSMFText::CMSMFText()                                      */
/* Description: Initialize the properties and states.                    */
/*************************************************************************/
CMSMFText::CMSMFText()
{
    m_fDirty = true;

    //properties
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    m_uiState = TextState::Static;
    m_uiFontSize = 10;
    m_fDisabled = false;
    m_clrColorActive = 0x00ff0000; // blue
    m_clrColorStatic = 0x00000000; // black
    m_clrColorHover = 0x00ff0000;  // blue
    m_clrColorPush = 0x00ffffff;   // white
    m_clrColorDisable = 0x00808080; // grey
    m_bstrTextValue = L"";
    m_bstrFontFace = L"Arial";
    m_bstrAlignment = L"Center";
    m_bstrFontStyle = L"Normal";
    m_uiEdgeStyle = 0; // no edge
    #if 0 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
    #endif
    m_fTransparent = false;
}


/*************************************************************************/
/* Function: CMSMFText::SetTextProperties                                */
/* Description: Set the properties for the CText object.                 */
/*************************************************************************/
HRESULT CMSMFText::SetTextProperties()
{
    HRESULT hr = S_OK;

    m_cText.SetFontFace(m_bstrFontFace);
    m_cText.SetFontSize(m_uiFontSize);
    m_cText.SetFontStyle(m_bstrFontStyle);
    m_cText.SetTextAlignment(m_bstrAlignment);
    m_cText.SetFixedSizeFont(true);

    // set the font color based on the current state

    OLE_COLOR clrColorCurrent = m_clrColorStatic;
    switch(m_uiState)
    {
        case(TextState::Static):
            clrColorCurrent = m_clrColorStatic;
            break;
        case(TextState::Hover):
            clrColorCurrent = m_clrColorHover;
            break;
        case(TextState::Active):
            clrColorCurrent = m_clrColorActive;
            break;
        case(TextState::Push):
            clrColorCurrent = m_clrColorPush;
            break;
        case(TextState::Disabled):
            clrColorCurrent = m_clrColorDisable;
            break;
    }

    // translate OLE_COLOR to COLORREF
    COLORREF crCurrentState;

    hr = OleTranslateColor(clrColorCurrent, CBitmap::GetSuperPal(), &crCurrentState);

    if (FAILED(hr))
    {
        crCurrentState = GetSysColor(COLOR_WINDOWTEXT);
    }
    
    m_cText.SetTextColor(crCurrentState);

    m_fDirty = false;

    return hr;
}

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Draw text in the specified rectangle.                    */
/*************************************************************************/
HRESULT CMSMFText::OnDraw(ATL_DRAWINFO& di)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
	RECT& rc = *(RECT*)di.prcBounds;

    HPALETTE hNewPal = CBitmap::GetSuperPal();

    if (::IsWindow(m_hWnd)){ // is not windowless
                    
        CBitmap::SelectRelizePalette(di.hdcDraw, hNewPal);
    }/* end of if statement */

    // draw background
    if (!m_fTransparent)
    {
        COLORREF clr;
        ::OleTranslateColor (m_clrBackColor, hNewPal, &clr);        
 
        HBRUSH hbrBack = ::CreateSolidBrush(clr);            

        if(NULL == hbrBack){
            
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        ::FillRect(di.hdcDraw, &rc, hbrBack);
        ::DeleteObject(hbrBack);
    }

    if (m_fDirty)
    {
        SetTextProperties();
    }

    hr = m_cText.Write(di.hdcDraw, rc, m_bstrTextValue);

    // draw edge

    if (m_uiEdgeStyle != 0)
    {
        ::DrawEdge(di.hdcDraw, &rc, m_uiEdgeStyle, BF_RECT);
    }

    // draw focus rectagle

    HRESULT hr2 = GetFocus();

    if(S_OK == hr2)
    {
        ::DrawFocusRect(di.hdcDraw, (LPRECT)di.prcBounds);
    }

	return hr;
}/* end of function OnDraw */


/*************************************************************************/
/* Function: get_FontSize                                                */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_FontSize(long *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_uiFontSize;

	return S_OK;
}


/*************************************************************************/
/* Function: put_FontSize                                                */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_FontSize(long lSize)
{
    if ((UINT)lSize != m_uiFontSize)
    {
        m_uiFontSize = (UINT)lSize;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_Text                                                    */
/* Description: return the Text that is displayed in the control.        */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_Text(BSTR *pText)
{
    if (!pText)
    {
        return E_POINTER;
    }

    *pText = m_bstrTextValue.Copy();

    return S_OK;
}


/*************************************************************************/
/* Function: put_Text                                                    */
/* Description: set the text to be displayed in the control.             */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_Text(BSTR wsText)
{
    if (_wcsicmp(m_bstrTextValue, wsText) != 0)
    {
        m_bstrTextValue = wsText;
        FireViewChange();
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontFace                                                */
/* Description: return the FontFace property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_FontFace(BSTR *pFontFace)
{
    if (!pFontFace)
    {
        return E_POINTER;
    }

    *pFontFace = m_bstrFontFace.Copy();
    
	return S_OK;
}


/*************************************************************************/
/* Function: put_FontFace                                                */
/* Description: set the FontFace property.                               */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_FontFace(BSTR wsFontFace)
{
    if (_wcsicmp(m_bstrFontFace, wsFontFace) != 0)
    {
        m_bstrFontFace = wsFontFace;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontStyle                                               */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_FontStyle(BSTR *pFontStyle)
{
    if (!pFontStyle)
    {
        return E_POINTER;
    }

    *pFontStyle = m_bstrFontStyle.Copy();
    
    return S_OK;
}


/*************************************************************************/
/* Function: put_FontStyle                                               */
/* Description: set the FontStyle property. The style string should      */
/* contain either "Normal", or concatenation of one or more strings of:  */
/* "Bold", "Italic", "Underline", "Strikeout". Default is "Normal".      */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_FontStyle(BSTR wsFontStyle)
{
    if (_wcsicmp(m_bstrFontStyle, wsFontStyle) != 0)
    {
        m_bstrFontStyle = wsFontStyle;
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_TextAlignment                                           */
/* Description: return the TextAlignment (horizontal) property.          */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_TextAlignment(BSTR *pAlignment)
{
    if (!pAlignment)
    {
        return E_POINTER;
    }

    *pAlignment = m_bstrAlignment.Copy();

    return S_OK;
}


/*************************************************************************/
/* Function: put_TextAlignment                                           */
/* Description: set the TextAlignment property. It controls the          */
/* horizontal text alignment. Must be one of "Left", "Center", or        */
/* "Right". Default is "Center".                                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_TextAlignment(BSTR wsAlignment)
{
    if (_wcsicmp(m_bstrAlignment, wsAlignment) != 0)
    {
        m_bstrAlignment = wsAlignment;
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorPush                                               */
/* Description: return the ColorPush property.                           */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorPush(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorPush;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Push state.                                                    */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorPush(OLE_COLOR clrColor)
{
    m_clrColorPush = clrColor;

    if (m_uiState == TextState::Push)
    {
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_ColorHover                                              */
/* Description: return the ColorHover property.                          */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorHover(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorHover;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorHover                                              */
/* Description: set the ColorHover property. This is the color of text   */
/* in the Hover state.                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorHover(OLE_COLOR clrColor)
{
    m_clrColorHover = clrColor;

    if (m_uiState == TextState::Hover)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorStatic                                             */
/* Description: return the ColorStatic property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorStatic(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorStatic;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Static (normal) state.                                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorStatic(OLE_COLOR clrColor)
{
    m_clrColorStatic = clrColor;

    if (m_uiState == TextState::Static)
    {
        m_fDirty = true;
    }
	
    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorDisable                                            */
/* Description: return the ColorDisable property.                        */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorDisable(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorDisable;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorDisable                                            */
/* Description: set the ColorDisable property. This is the color of text */
/* in the Disabled state.                                                */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorDisable(OLE_COLOR clrColor)
{
    m_clrColorDisable = clrColor;

    if (m_uiState == TextState::Disabled)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorActive                                             */
/* Description: return the ColorActive property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorActive(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorActive;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorActive                                             */
/* Description: set the ColorActive property. This is the color of text  */
/* in the Active state.                                                  */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorActive(OLE_COLOR clrColor)
{
    m_clrColorActive = clrColor;

    if (m_uiState == TextState::Active)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_TextState                                               */
/* Description: return the TextState property.                           */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_TextState(long *pState)
{
    if (!pState)
    {
        return E_POINTER;
    }

    *pState = m_uiState;
	return S_OK;
}


/*************************************************************************/
/* Function: put_TextState                                               */
/* Description: set the TextState property. It should be one of:         */
/* Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4.            */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_TextState(long lState)
{
    if (lState < 0 || lState > 4)
    {
        return E_INVALIDARG;
    }

    if ((UINT)lState != m_uiState)
    {
        m_uiState = (UINT)lState;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_Disable                                                 */
/* Description: return the Disable property.                             */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_Disable(VARIANT_BOOL *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_fDisabled?VARIANT_TRUE:VARIANT_FALSE;

	return S_OK;
}


/*************************************************************************/
/* Function: put_Disable                                                 */
/* Description: set the Disable property.                                */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_Disable(VARIANT_BOOL newVal)
{
    bool fDisabled;

    if (newVal == VARIANT_TRUE)
    {
        fDisabled = true;
        m_uiState = TextState::Disabled;
    }
    else
    {
        fDisabled = false;
        m_uiState = TextState::Static;
    }

    if (fDisabled != m_fDisabled)
    {
        m_fDisabled = fDisabled;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_EdgeStyle                                               */
/* Description: return the EdgeStyle.                                    */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_EdgeStyle(BSTR *pStyle)
{
    if (!pStyle)
    {
        return E_POINTER;
    }

    switch (m_uiEdgeStyle)
    {
    case 0: // no edge
        *pStyle = SysAllocString(L"None");
        break;
    case EDGE_SUNKEN:
        *pStyle = SysAllocString(L"Sunken");
        break;
    case EDGE_RAISED:
        *pStyle = SysAllocString(L"Raised");
        break;
    default:
        // we should not reach here
        *pStyle = NULL;
        DebugBreak();
    }

	return S_OK;
}


/*************************************************************************/
/* Function: put_EdgeStyle                                               */
/* Description: set the EdgeStyle property. Must be one of "None",       */
/* "Raised", or "Sunken". Default is "None".                             */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_EdgeStyle(BSTR wsStyle)
{
    UINT uiStyle = 0;

    //set the text alignment
    if (!_wcsicmp(wsStyle, L"None"))
    {
        uiStyle = 0;
    }
    else if (!_wcsicmp(wsStyle, L"Sunken"))
    {
        uiStyle = EDGE_SUNKEN;
    }
    else if (!_wcsicmp(wsStyle, L"Raised"))
    {
        uiStyle = EDGE_RAISED;
    }

    if (m_uiEdgeStyle != uiStyle)
    {
        m_uiEdgeStyle = uiStyle;
        FireViewChange();
    }

    return S_OK;
}


/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Handles when buttons is selected. Captures the mouse     */
/* movents (supported for windowless, via interfaces).                   */
/*************************************************************************/
LRESULT CMSMFText::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled){
        
        return 0;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if(PtOnButton(xPos, yPos)){

        // we are really on the buttons bitmap and we pushed it

        if(TextState::Hover !=  m_uiState){
            // in hover case we already have captured the mouse, so do not do
            // that again
            SetCapture(true); // capture the mouse messages
        }/* end of if statement */

	    SetButtonState(TextState::Push);
    }/* end of if statement */

	return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Releases the capture, updates the button visual state,   */
/* and if release on the buttons image fire the event.                   */
/*************************************************************************/
LRESULT CMSMFText::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled){

        LONG lRes;
        ForwardWindowMessage(WM_USER_ENDHELP, (WPARAM) m_hWnd, 0, lRes);
        return 0;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool bOnButtonImage = PtOnButton(xPos, yPos);
    bool bFire = (m_uiState == TextState::Push);
	
    if(bOnButtonImage){

        SetButtonState(TextState::Static); //change to static even 
        SetCapture(false); // release the capture of the mouse messages
    }
    else {

        SetButtonState(TextState::Static);
        // do it only when we do not hower, if we hower, then keep the capture
        SetCapture(false); // release the capture of the mouse messages
    }/* end of if statement */

    if (bFire){

        if(bOnButtonImage){

            Fire_OnClick();
        }/* end of if statement */
    }/* end of if statement */

    LONG lRes;
    ForwardWindowMessage(WM_USER_ENDHELP, (WPARAM) m_hWnd, 0, lRes);
	return 0;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSMFText::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled)
        return 0;

	LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if (m_uiState != TextState::Push){    
    
        if(PtOnButton(xPos, yPos)){
            if(TextState::Hover != m_uiState || S_OK != GetCapture()){

                SetCapture(true); // capture the mouse messages
		        SetButtonState(TextState::Hover);
            }/* end of if statement */
        }
        else {

            if(TextState::Static != m_uiState){

                SetCapture(false); // release the capture of the mouse messages
		        SetButtonState(TextState::Static);
            }/* end of if statement */
        }/* end of if statement */
	}/* end of if statement */

	return 0;
}/* end of function OnMouseMove */


/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFText::OnSetFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled){

        if(GetFocus() == S_OK){

            SetFocus(false);
        }/* end of if statement */

        return(-1);
    }/* end of if statement */

    return 0;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFText::PtOnButton(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnButton(pos));
}/* end of function PtOnButton */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Determines if the point is located on the button.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFText::PtOnButton(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    //TODO: Add also if we are on bitmap itsels possibly

#ifdef _DEBUG
if(bRet)
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d in Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
else
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d NOT ON RECT Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
#endif

    return(bRet);
}/* end of function PtOnButton */


/*************************************************************************/
/* Function: SetButtonState                                              */
/* Description: Sets the button states forces redraw.                    */
/*************************************************************************/
HRESULT CMSMFText::SetButtonState(TextState txtState){

    HRESULT hr = S_OK;

    bool fRedraw = false;
    
    if((UINT)txtState != m_uiState ){

        fRedraw = true;
    }/* end of if statement */

    m_uiState = txtState;    
    
    if(fRedraw){

        if (m_uiState == TextState::Disabled){
            
            SetFocus(false); // disable the focus
            SetCapture(false);
        }/* end of if statement */

        m_fDirty = true;
	    FireViewChange(); // update the display
    }/* end of if statement */

    return(hr);
}/* end of function SetButtonState */


STDMETHODIMP CMSMFText::get_TextWidth(long *pVal)
{
    HRESULT hr = S_OK;

    // special case early return
    if (m_bstrTextValue.Length() == 0){
        *pVal = 0;
        return S_OK;
    }/* end of if statement */

    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return E_FAIL;
    }/* end of if statement */

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    hr = m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    if (S_OK == hr)
    {
        *pVal = size.cx;
    }
    else
    {
        *pVal = 0;
    }

    ::ReleaseDC(hwnd, hdc);

	return hr;
}

STDMETHODIMP CMSMFText::get_TextHeight(long *pVal)
{
    HRESULT hr = S_OK;
    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return E_FAIL;
    }/* end of if statement */

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    hr = m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    if (S_OK == hr)
    {
        *pVal = size.cy;
    }
    else
    {
        *pVal = 0;
    }

    ::ReleaseDC(hwnd, hdc); // do not forget to free DC

	return hr;
}

STDMETHODIMP CMSMFText::get_TransparentText(VARIANT_BOOL *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_fTransparent?VARIANT_TRUE:VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CMSMFText::put_TransparentText(VARIANT_BOOL newVal)
{
    bool fTransparent;

    if (newVal == VARIANT_FALSE)
    {
        fTransparent = false;
    }
    else
    {
        fTransparent = true;
    }

    if (fTransparent != m_fTransparent)
    {
        m_fTransparent = fTransparent;
        FireViewChange();
    }

	return S_OK;
}

/*************************************************************/
/* Name: SetObjectRects                                      */
/*************************************************************/
STDMETHODIMP CMSMFText::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){
    // Call the default method first
    IOleInPlaceObjectWindowlessImpl<CMSMFText>::SetObjectRects(prcPos, prcClip);
  
    FireViewChange();

    
    return S_OK;
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: OnSize                                                      */
/*************************************************************************/
LRESULT CMSMFText::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    bHandled = true;

    FireViewChange();

    return 0;
}/* end of function OnSize */


/*************************************************************************/
/* End of file: MSMFText.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\msmftext.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFText.h                                                      */
/* Description: Header file for CMSMFText control object                 */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/

#ifndef __MSMFTEXT_H_
#define __MSMFTEXT_H_

#include "MSMFCntCP.h"
#include "resource.h"       // main symbols
#include "ctext.h"
#include <atlctl.h>
#include "CstUtils.h"


/////////////////////////////////////////////////////////////////////////////
// CMSMFText
class ATL_NO_VTABLE CMSMFText : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CMSMFText, IMSMFText, &IID_IMSMFText, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFText>,
	public IPersistStreamInitImpl<CMSMFText>,
	public IOleControlImpl<CMSMFText>,
	public IOleObjectImpl<CMSMFText>,
	public IOleInPlaceActiveObjectImpl<CMSMFText>,
	public IViewObjectExImpl<CMSMFText>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFText>,
	public IConnectionPointContainerImpl<CMSMFText>,
	public IPersistStorageImpl<CMSMFText>,
	public ISpecifyPropertyPagesImpl<CMSMFText>,
	public IQuickActivateImpl<CMSMFText>,
	public IDataObjectImpl<CMSMFText>,
	public IProvideClassInfo2Impl<&CLSID_MSMFText, &DIID__IMSMFText, &LIBID_MSMFCNTLib>,	
	public CComCoClass<CMSMFText, &CLSID_MSMFText>,
    public IPersistPropertyBagImpl<CMSMFText>,
    public CProxy_IMSMFText<CMSMFText>,
    public CMSMFCntrlUtils<CMSMFText> // custom utilities we share across controls
{
public:
    CMSMFText();
    virtual ~CMSMFText(){ATLTRACE(TEXT("In the TEXT Object destructor!\n"));};

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFTEXT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFText)
	COM_INTERFACE_ENTRY(IMSMFText)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CMSMFText)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("TransparentText", 17, CLSID_NULL)
    PROP_ENTRY("Windowless", 18, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMFText)	
    CONNECTION_POINT_ENTRY(DIID__IMSMFText)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CMSMFText)
	MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
    MESSAGE_HANDLER(WM_SETFOCUS,    OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFText>)
	CHAIN_MSG_MAP(CComControl<CMSMFText>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

    USE_MF_OVERWRITES
    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers

// IMSMFText
public:
	STDMETHOD(get_TransparentText)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_TransparentText)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_TextHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TextWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_EdgeStyle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EdgeStyle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_TextAlignment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TextAlignment)(/*[in]*/ BSTR newVal);
    USE_MF_RESOURCEDLL  // replaces the two lines below
	STDMETHOD(get_Disable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Disable)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_TextState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_TextState)(/*[in]*/ long newVal);
	STDMETHOD(get_ColorActive)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorActive)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorDisable)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorDisable)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorStatic)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorStatic)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorHover)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorHover)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorPush)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorPush)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_FontStyle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontStyle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontFace)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontFace)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Text)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Text)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontSize)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_FontSize)(/*[in]*/ long newVal);
    USE_MF_WINDOWLESS_ACTIVATION //Replaces the two lines below
    //STDMETHOD(get_Windowless)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	//STDMETHOD(put_Windowless)(/*[in]*/ VARIANT_BOOL newVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);
    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);
	OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl

	enum TextState {Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4};

private:    

    CText       m_cText;
    bool        m_fDirty; // if any attribute for the text drawing object changes

    //properties
    UINT        m_uiState;
    CComBSTR    m_bstrTextValue;
    CComBSTR    m_bstrFontFace;
    CComBSTR    m_bstrFontStyle;
    CComBSTR    m_bstrAlignment;
    UINT        m_uiFontSize;
    bool        m_fDisabled;
    OLE_COLOR   m_clrColorActive;
    OLE_COLOR   m_clrColorStatic;
    OLE_COLOR   m_clrColorHover;
    OLE_COLOR   m_clrColorPush;
    OLE_COLOR   m_clrColorDisable;
    UINT        m_uiEdgeStyle;
    bool        m_fTransparent;

    HRESULT SetTextProperties();
    bool PtOnButton(LONG x, LONG y);
    bool PtOnButton(POINT pos);
    HRESULT SetButtonState(TextState txtState);        
};

#endif //__MSMFTEXT_H_

/*************************************************************************/
/* End of file: MSMFText.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSMFCnt.rc
//
#define IDS_PROJNAME                    100
#define IDB_MSMFBAR                     101
#define IDB_MSMFBBTN                    101
#define IDB_MSMFIMG                     101
#define IDB_MSMFSLDR                    101
#define IDB_MSMFTEXT                    101
#define IDR_MSMFBAR                     102
#define IDR_MSMFBBTN                    104
#define IDR_MSMFIMG                     106
#define IDR_MSMFSLDR                    108
#define IDR_MSMFTEXT                    110
#define IDS_BAR_ABOUT                   111
#define IDS_ABOUT                       112
#define IDS_SCRIPT_LANGUAGE             113
#define IDS_END_FILE                    114
#define IDS_ROOT_OBJECT                 115
#define IDS_BTN_ABOUT                   116
#define IDS_MAIN_ENTRY                  117
#define IDR_SCRIPT                      118
#define IDI_ICON1                       201
#define IDR_SYSMENU                     205
#define ID_SYSTEMMENU_RESTORE           32768
#define ID_SYSTEMMENU_MOVE              32769
#define ID_SYSTEMMENU_SIZE              32770
#define ID_SYSTEMMENU_MINIMIZE          32771
#define ID_SYSTEMMENU_MAXIMIZE          32772
#define ID_SYSTEMMENU_CLOSE             32773

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        206
#define _APS_NEXT_COMMAND_VALUE         32777
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\bookmark.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#ifndef __BOOKMARK_H
#define __BOOKMARK_H

//#include <streams.h>

class CBookmark {

public:	
    static HRESULT SaveToRegistry(IDvdState *ppBookmark);
    static HRESULT LoadFromRegistry(IDvdState **ppBookmark);
    static HRESULT DeleteFromRegistry();

};/* end of class CBookmark */

#endif // __BOOKMARK_H
/*************************************************************************/
/* Function: Bookmark.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\bookmark.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#include "stdafx.h"
#include "msdvd.h"
#include "msdvdadm.h"
#include "Bookmark.h"

/*************************************************************************/
/* Global consts.                                                        */
/*************************************************************************/
static const WCHAR* cgszBookmarkName = L"StopBookMark";
static const TCHAR g_szBookmark[] = TEXT("DVD.bookmark");

/*************************************************************************/
/* Outgoing interaface implementation.                                   */
/*************************************************************************/

/*************************************************************************/
/* Function: SaveBookmark                                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SaveBookmark(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    

        CComPtr<IDvdState> pBookmark;

        hr = m_pDvdInfo2->GetState(&pBookmark);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = CBookmark::SaveToRegistry(pBookmark);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SaveBookmark */

/*************************************************************************/
/* Function: RestoreBookmark                                             */
/* Description: Restores the state by loading the bookmark stream        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::RestoreBookmark(){

    HRESULT hr = S_OK;

    try {
       
        CComPtr<IDvdState> pBookmark;

        HRESULT hrTemp = CBookmark::LoadFromRegistry(&pBookmark);

        if(SUCCEEDED(hrTemp)){

            INITIALIZE_GRAPH_IF_NEEDS_TO_BE
                
            if(!m_pDvdCtl2){
                
                throw(E_UNEXPECTED);
            }/* end of if statement */
            
            hr = m_pDvdCtl2->SetState(pBookmark, DVD_CMD_FLAG_Block| DVD_CMD_FLAG_Flush, 0);
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RestoreBookmark */

/*************************************************************************/
/* Function: DeleteBookmark                                               */
/* Description: Blasts the bookmark file away.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::DeleteBookmark(){

	HRESULT hr = S_OK;

    try {

        hr = CBookmark::DeleteFromRegistry();

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function DeleteBookmark */

/*************************************************************************/
/* CBookMark helper class implementation.                                */
/*************************************************************************/

/*************************************************************/
/* Name: SaveToRegistry
/* Description: Save the bookmark to registry
/*************************************************************/
HRESULT CBookmark::SaveToRegistry(IDvdState *pbookmark)
{
	IPersistMemory* pPersistMemory;
    HRESULT hr = pbookmark->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

    if (SUCCEEDED(hr)) {

		ULONG ulMax;
		hr = pPersistMemory->GetSizeMax( &ulMax );
		if( SUCCEEDED( hr )) {

			BYTE *buffer = new BYTE[ulMax];
			hr = pPersistMemory->Save( buffer, TRUE, ulMax );
            
            DWORD dwLen = ulMax;
            if (SUCCEEDED(hr)) {
                BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, buffer, dwLen);
                if (!bSuccess)
                    hr = E_FAIL;
            }

            delete[] buffer; 
        }
		pPersistMemory->Release();
    } 
	return hr;
}

/*************************************************************/
/* Name: LoadFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::LoadFromRegistry(IDvdState **ppBookmark)
{
	HRESULT hr = CoCreateInstance( CLSID_DVDState, NULL, CLSCTX_INPROC_SERVER, IID_IDvdState, (LPVOID*) ppBookmark );

	if( SUCCEEDED( hr )) {

		IPersistMemory* pPersistMemory;
		hr = (*ppBookmark)->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

        if( SUCCEEDED( hr )) {

            ULONG ulMax;
            hr = pPersistMemory->GetSizeMax( &ulMax );
            
            if (SUCCEEDED(hr)) {
                
                BYTE *buffer = new BYTE[ulMax];
                DWORD dwLen = ulMax;
                BOOL bFound = GetRegistryBytesCU(g_szBookmark, buffer, &dwLen);
           
                if (bFound && dwLen != 0){
                    hr = pPersistMemory->Load( buffer, dwLen);
                }
                else{
					dwLen = ulMax;
                    bFound = GetRegistryBytes(g_szBookmark, buffer, &dwLen);
                    if (bFound && dwLen != 0){
                        hr = pPersistMemory->Load( buffer, dwLen);
                        if(SUCCEEDED(hr)){
                            SetRegistryBytes(g_szBookmark, NULL, 0);
                        }
                    }
                    else{
                        hr = E_FAIL;
                    }
                }
                delete[] buffer; 

            }
            pPersistMemory->Release();
        }
	}
	return hr;
}

/*************************************************************/
/* Name: DeleteFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::DeleteFromRegistry()
{
    HRESULT hr = S_OK;
    BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, NULL, 0);
    if (!bSuccess)
        hr = E_FAIL;
    return hr;
}

/*************************************************************************/
/* End of file: Bookmark.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\msmfcnt\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__801B2C9D_82CA_459C_8670_6F6293B6985E__INCLUDED_)
#define AFX_STDAFX_H__801B2C9D_82CA_459C_8670_6F6293B6985E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define ATL_TRACE_CATEGORY atlTraceUser
#define ATL_TRACE_LEVEL 31

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#pragma warning( disable: 4100 )  /*unreferenced formal parameter*/



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__801B2C9D_82CA_459C_8670_6F6293B6985E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\ddrawobj.cpp ===
#include "stdafx.h"
#include "mswebdvd.h"
#include "msdvd.h"
#include "ddrawobj.h"
//
// CDDrawDVD constructor
//
CDDrawDVD::CDDrawDVD(CMSWebDVD *pDVD)
{
    m_pDVD = pDVD;

    // Default colors to be used for filling
    m_VideoKeyColor = RGB(255, 0, 255) ;

    m_pOverlayCallback = new CComObject<COverlayCallback> ;
    
    CComVariant vData;
    vData.vt = VT_VOID;
    vData.byref = this;
    if(m_pOverlayCallback){
        m_pOverlayCallback->SetDDrawDVD(vData);
    }
}


//
// CDDrawDVD destructor
//
CDDrawDVD::~CDDrawDVD(void)
{
}

/*************************************************************************/
/* Function: SetupDDraw                                                  */
/* Description: Creates DDrawObject and Surface                          */
/*************************************************************************/
HRESULT CDDrawDVD::SetupDDraw(const AMDDRAWGUID* lpDDGUID, HWND hwnd){

    // DO NOT CALL TWICE !!!
    // WILL CRASH OV MIXER DJ
    HRESULT hr = E_UNEXPECTED;
        
    if(!::IsWindow(hwnd)){
        
        return(hr);
    }/* end of if statement */

    m_pDDObject.Release();
    hr = ::DirectDrawCreate(lpDDGUID->lpGUID, &m_pDDObject, NULL);
    
    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    hr = m_pDDObject->SetCooperativeLevel(hwnd, DDSCL_NORMAL);

    if(FAILED(hr)){

        m_pDDObject.Release();            
        return(hr);
    }/* end of if statement */

    DDSURFACEDESC ddsd;
    ::ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);

    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    m_pPrimary.Release();
    hr = m_pDDObject->CreateSurface(&ddsd, &m_pPrimary, NULL);

    if(FAILED(hr)){
        
        m_pDDObject.Release();            
        return(hr);
    }/* end of if statement */

    CComPtr<IDirectDrawClipper> pClipper;
    
    hr = m_pDDObject->CreateClipper(0, &pClipper, NULL);

    if(FAILED(hr)){
        
        m_pPrimary.Release();
        m_pDDObject.Release();            
        
        return(hr);
    }/* end of if statement */

    hr = pClipper->SetHWnd(0, hwnd);

    if(FAILED(hr)){

        m_pPrimary.Release();            
        m_pDDObject.Release();            
        pClipper.Release();            
        return(hr);
    }/* end of if statement */


    hr = m_pPrimary->SetClipper(pClipper);

	if (FAILED(hr)){

        m_pPrimary.Release();        
        m_pDDObject.Release();            
        pClipper.Release();            
        return(hr);
	}/* end of if statement */

	/*
	 * We release the clipper interface after attaching it to the surface
	 * as we don't need to use it again and the surface holds a reference
	 * to the clipper when its been attached. The clipper will therefore
	 * be released when the surface is released.
	 */
	pClipper.Release();

    return(hr);
}/* end of function SetupDDraw */

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
HRESULT CDDrawDVD::SetColorKey(COLORREF colorKey)
{
    m_VideoKeyColor = colorKey;

    // if 256 color mode, force to set back to magenta
    HWND hwnd = ::GetDesktopWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return(E_UNEXPECTED);
    }/* end of if statement */

    HRESULT hr = S_OK;

    if ((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE)
    {   
        if (m_VideoKeyColor != MAGENTA_COLOR_KEY) {
            hr = m_pDVD->put_ColorKey(MAGENTA_COLOR_KEY);
            if (SUCCEEDED(hr)) 
                m_VideoKeyColor = MAGENTA_COLOR_KEY;
        }
    }

    ::ReleaseDC(hwnd, hdc);
    return hr ;
}

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
COLORREF CDDrawDVD::GetColorKey()
{
     // if 256 color mode, force to set back to magenta
    HWND hwnd = ::GetDesktopWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return(E_UNEXPECTED);
    }/* end of if statement */

    if ((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE)
    {   
        if (m_VideoKeyColor != MAGENTA_COLOR_KEY) {

            if (SUCCEEDED(m_pDVD->put_ColorKey(MAGENTA_COLOR_KEY)))
                m_VideoKeyColor = MAGENTA_COLOR_KEY;
        }
    }
    
    ::ReleaseDC(hwnd, hdc);
    return m_VideoKeyColor;
}

/*************************************************************************/
/* Function: HasOverlay                                                  */
/* Description: Tells us if the video card support overlay.              */
/*************************************************************************/
HRESULT CDDrawDVD::HasOverlay(){

    HRESULT hr = S_OK;

    if(!m_pDDObject){

        return(E_UNEXPECTED);
    }/* end of if statement */

    DDCAPS caps;

    ::ZeroMemory(&caps, sizeof(DDCAPS));

     caps.dwSize = sizeof(DDCAPS);

    hr = m_pDDObject->GetCaps(&caps, NULL);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    if(caps.dwMaxVisibleOverlays > 0){

        hr = S_OK;
    }
    else {

        hr = S_FALSE;
    }/* end of if statement */    
    
    return(hr);
}/* end of function HasOverlay */

/*************************************************************************/
/* Function: HasAvailableOverlay                                         */
/* Description: Tells us if the overlay is used.                         */
/*************************************************************************/
HRESULT CDDrawDVD::HasAvailableOverlay(){

    HRESULT hr = S_OK;

    if(!m_pDDObject){

        return(E_UNEXPECTED);
    }/* end of if statement */

    DDCAPS caps;

    ::ZeroMemory(&caps, sizeof(DDCAPS));

     caps.dwSize = sizeof(DDCAPS);

    hr = m_pDDObject->GetCaps(&caps, NULL);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */
   
    if((caps.dwMaxVisibleOverlays > 0) && (caps.dwMaxVisibleOverlays > caps.dwCurrVisibleOverlays)){

        hr = S_OK;
    }
    else {

        hr = S_FALSE;
    }/* end of if statement */    
    
    return(hr);
}/* end of function HasAvailableOverlay */

/*************************************************************************/
/* Function: GetOverlayMaxStretch                                        */
/* Description: Tells us the maximum stretch factors of overlay.         */
/*************************************************************************/
HRESULT CDDrawDVD::GetOverlayMaxStretch(DWORD *pdwMaxStretch){

    HRESULT hr = S_OK;

    if(!m_pDDObject){

        return(E_UNEXPECTED);
    }/* end of if statement */

    DDCAPS caps;

    ::ZeroMemory(&caps, sizeof(DDCAPS));

     caps.dwSize = sizeof(DDCAPS);

    hr = m_pDDObject->GetCaps(&caps, NULL);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    if (caps.dwCaps & DDCAPS_OVERLAYSTRETCH && caps.dwMaxOverlayStretch!=0) {
        *pdwMaxStretch = caps.dwMaxOverlayStretch/2;
    }

    else {
#ifdef _DEBUG
        ::MessageBox(::GetFocus(), TEXT("Overlay can't stretch"), TEXT("Error"), MB_OK) ;
#endif
    }

     
    return(hr);
}/* end of function GetOverlayMaxStretch */

// convert a RGB color to a pysical color.
// we do this by leting GDI SetPixel() do the color matching
// then we lock the memory and see what it got mapped to.
HRESULT CDDrawDVD::DDColorMatchOffscreen(COLORREF rgb, DWORD* dwColor)
{
    HDC hdc;
    *dwColor = CLR_INVALID;
    DDSURFACEDESC ddsd;
    IDirectDrawSurface* pdds;
    
    LPDIRECTDRAW pdd = GetDDrawObj();

    HRESULT hr = S_OK;

    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth = 8;
    ddsd.dwHeight = 8;
    hr = pdd->CreateSurface(&ddsd, &pdds, NULL);
    if (hr != DD_OK) {
        return 0;
    }
 
    //  use GDI SetPixel to color match for us
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        // set our value
        SetPixel(hdc, 0, 0, rgb);              
        pdds->ReleaseDC(hdc);
    }
 
    // now lock the surface so we can read back the converted color
    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;
 
    if (hr == DD_OK)
    {
        // get DWORD
        DWORD temp = *(DWORD *)ddsd.lpSurface;
 
        // mask it to bpp
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 32)
            temp &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount)-1;

        pdds->Unlock(NULL);

        *dwColor = temp;
        hr = S_OK; 
    }
 
    pdds->Release();
    return hr;
}

/*************************************************************/
/* Name: CreateDIBBrush
/* Description: 
/*************************************************************/
HRESULT CDDrawDVD::CreateDIBBrush(COLORREF rgb, HBRUSH *phBrush)
{
#if 1
  
    HDC hdc;
    DDSURFACEDESC ddsd;
    IDirectDrawSurface* pdds;
    
    LPDIRECTDRAW pdd = GetDDrawObj();
    HRESULT hr = S_OK;

    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth = 8;
    ddsd.dwHeight = 8;
    hr = pdd->CreateSurface(&ddsd, &pdds, NULL);
    if (hr != DD_OK) {
        return 0;
    }
 
    //  use GDI SetPixel to color match for us
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        // set our value
        SetPixel(hdc, 0, 0, rgb);              
        pdds->ReleaseDC(hdc);
    }
 
    // now lock the surface so we can read back the converted color
    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;
 
    DWORD temp = CLR_INVALID;
    if (hr == DD_OK)
    {
        // get DWORD
        temp = *((DWORD *)ddsd.lpSurface);
        
        // mask it to bpp
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 32)
            temp &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount)-1;

        pdds->Unlock(NULL);

        hr = S_OK; 
    }
 
    ::ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;        
    hr = pdds->GetSurfaceDesc(&ddsd) ;
    if (! (SUCCEEDED(hr) && (ddsd.dwFlags & DDSD_WIDTH) && (ddsd.dwFlags & DDSD_HEIGHT)) ) {
        return hr;
    }

    if (hr == DD_OK && temp != CLR_INVALID) {
        DDBLTFX ddBltFx;
        ::ZeroMemory(&ddBltFx, sizeof(ddBltFx)) ;
        ddBltFx.dwSize = sizeof(DDBLTFX);
        ddBltFx.dwFillColor = temp;

        RECT rc;
        ::SetRect(&rc, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

        hr = pdds->Blt(&rc, NULL, NULL, DDBLT_COLORFILL|DDBLT_WAIT, &ddBltFx);
        if (FAILED(hr)) {
            return hr;
        }

        DWORD dwBitCount = ddsd.ddpfPixelFormat.dwRGBBitCount;
        DWORD dwWidth = WIDTHBYTES(ddsd.dwWidth*dwBitCount);
        DWORD dwSizeImage = ddsd.dwHeight*dwWidth;

        BYTE *packedDIB = new BYTE[sizeof(BITMAPINFOHEADER) + dwSizeImage + 1024];
        BITMAPINFOHEADER *lpbmi = (BITMAPINFOHEADER*) packedDIB;

        ::ZeroMemory(lpbmi, sizeof(BITMAPINFOHEADER));
        lpbmi->biSize = sizeof(BITMAPINFOHEADER);
        lpbmi->biBitCount = (WORD)dwBitCount;
        lpbmi->biWidth = ddsd.dwWidth;
        lpbmi->biHeight = ddsd.dwHeight;
        lpbmi->biPlanes = 1;
        
        LPDWORD pdw = (LPDWORD)DibColors(lpbmi);

        switch (dwBitCount) {
        case 8: {
            lpbmi->biCompression = BI_RGB;
            lpbmi->biClrUsed = 256;
            for (int i=0; i<(int)lpbmi->biClrUsed/16; i++)
            {
                *pdw++ = 0x00000000;    // 0000  black
                *pdw++ = 0x00800000;    // 0001  dark red
                *pdw++ = 0x00008000;    // 0010  dark green
                *pdw++ = 0x00808000;    // 0011  mustard
                *pdw++ = 0x00000080;    // 0100  dark blue
                *pdw++ = 0x00800080;    // 0101  purple
                *pdw++ = 0x00008080;    // 0110  dark turquoise
                *pdw++ = 0x00C0C0C0;    // 1000  gray
                *pdw++ = 0x00808080;    // 0111  dark gray
                *pdw++ = 0x00FF0000;    // 1001  red
                *pdw++ = 0x0000FF00;    // 1010  green
                *pdw++ = 0x00FFFF00;    // 1011  yellow
                *pdw++ = 0x000000FF;    // 1100  blue
                *pdw++ = 0x00FF00FF;    // 1101  pink (magenta)
                *pdw++ = 0x0000FFFF;    // 1110  cyan
                *pdw++ = 0x00FFFFFF;    // 1111  white
            }
            break;
        }
        case 16:
            lpbmi->biCompression = BI_BITFIELDS;
            lpbmi->biClrUsed = 3;
            pdw[0] = ddsd.ddpfPixelFormat.dwRBitMask ;
            pdw[1] = ddsd.ddpfPixelFormat.dwGBitMask ;
            pdw[2] = ddsd.ddpfPixelFormat.dwBBitMask ;
            break;
        case 24:
        case 32:
            lpbmi->biCompression = BI_RGB;
            lpbmi->biClrUsed = 0;
            break;
        }

        ZeroMemory(&ddsd, sizeof(ddsd)) ;
        ddsd.dwSize = sizeof(ddsd) ;
        while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;

        if (hr != DD_OK)
            return hr;

        BYTE *lpTempSurf = (BYTE *)ddsd.lpSurface;
        for (DWORD i=0; i<ddsd.dwHeight; i++) {
            ::memcpy((BYTE*) DibPtr(lpbmi)+i*dwWidth, 
                lpTempSurf+i*ddsd.lPitch, dwWidth);
        }
        pdds->Unlock(NULL);

        *phBrush = ::CreateDIBPatternBrushPt((LPVOID) packedDIB, DIB_RGB_COLORS);
    }

    pdds->Release();
#else
        
    HRESULT hr = S_OK;
    typedef struct {
        BYTE rgb[3];
    } RGB;

    typedef struct {
        BITMAPINFOHEADER bmiHeader;
        RGB pBits[8][8];
    } PackedDIB;

    PackedDIB packedDIB;

    ::ZeroMemory(&packedDIB, sizeof(PackedDIB));
    packedDIB.bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
    packedDIB.bmiHeader.biCompression = BI_RGB;
    packedDIB.bmiHeader.biBitCount = 24;
    packedDIB.bmiHeader.biHeight = 8;
    packedDIB.bmiHeader.biWidth = 8;
    packedDIB.bmiHeader.biPlanes = 1;
    
    for (int i=0; i<8; i++) {
        for (int j=0; j<8; j++)
            packedDIB.pBits[i][j] = *((RGB*)&rgb);
    }
    
    *phBrush = ::CreateDIBPatternBrushPt((LPVOID)&packedDIB, DIB_RGB_COLORS);
#endif
    return hr;
}


/* COverlayCallback */
/*************************************************************/
/* Name: OnUpdateOverlay
/* Description: 
/*************************************************************/
HRESULT STDMETHODCALLTYPE COverlayCallback::OnUpdateOverlay(BOOL  bBefore,
                                             DWORD dwFlags,
                                             BOOL  bOldVisible,
                                             const RECT *prcSrcOld,
                                             const RECT *prcDestOld,
                                             BOOL  bNewVisible,
                                             const RECT *prcSrcNew,
                                             const RECT *prcDestNew)
{
    if (bBefore)
        return S_OK;

    if(!prcSrcOld || !prcDestOld || !prcSrcNew || !prcDestNew){
        return E_POINTER;
    }
    CMSWebDVD *pDVD = m_pDDrawDVD->GetDVD();
    ATLASSERT(pDVD);

    if (m_dwWidth != (DWORD)RECTWIDTH(prcDestNew) ||
        m_dwHeight != (DWORD)RECTHEIGHT(prcDestNew) ||
        m_dwARWidth != (DWORD)RECTWIDTH(prcDestNew) ||
        m_dwARHeight != (DWORD)RECTHEIGHT(prcDestNew)) {

        m_dwWidth = (DWORD)RECTWIDTH(prcDestNew);
        m_dwHeight = (DWORD)RECTHEIGHT(prcDestNew);
        m_dwARWidth = (DWORD)RECTWIDTH(prcDestNew);
        m_dwARHeight = (DWORD)RECTHEIGHT(prcDestNew);

        return pDVD->UpdateOverlay();
    } /* end of if statement */

    return S_OK;
}


/*************************************************************/
/* Name: OnUpdateColorKey
/* Description: 
/*************************************************************/
HRESULT STDMETHODCALLTYPE COverlayCallback::OnUpdateColorKey(COLORKEY const *pKey, DWORD dwColor)
{
    m_pDDrawDVD->SetColorKey(pKey->HighColorValue);
    return S_OK ;
}


/*************************************************************/
/* Name: OnUpdateSize
/* Description: 
/*************************************************************/
HRESULT STDMETHODCALLTYPE COverlayCallback::OnUpdateSize(DWORD dwWidth, DWORD dwHeight, 
                                          DWORD dwARWidth, DWORD dwARHeight)
{
    CMSWebDVD *pDVD = m_pDDrawDVD->GetDVD();
    ATLASSERT(pDVD);
    
    if (m_dwWidth != dwWidth ||
        m_dwHeight != dwHeight ||
        m_dwARWidth != dwARWidth ||
        m_dwARHeight != dwARHeight) {

        m_dwWidth = dwWidth;
        m_dwHeight = dwHeight;
        m_dwARWidth = dwARWidth;
        m_dwARHeight = dwARHeight;

        return pDVD->UpdateOverlay();
    } /* end of if statement */

    return S_OK;
}

/*************************************************************/
/* Name: SetDDrawDVD
/* Description: 
/*************************************************************/
STDMETHODIMP COverlayCallback::SetDDrawDVD(VARIANT pDDrawDVD)
{
    switch(pDDrawDVD.vt){
        
    case VT_VOID: {  
        m_pDDrawDVD = static_cast<CDDrawDVD*> (pDDrawDVD.byref);
        break;
    }
    
    } /* end of switch statement */

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\capture.h ===
/*************************************************************************/
/* Copyright (C) 2000 Microsoft Corporation                              */
/* File: capture.h                                                       */
/* Description: Declaration for capture related functions                */
/* Author: Phillip Lu                                                    */
/*************************************************************************/
#ifndef __CAPTURE_H_
#define __CAPTURE_H_

#define BYTES_PER_PIXEL  3

typedef struct 
{
    int Width;
    int Height;
    int Stride;
    unsigned char *Scan0;
    unsigned char *pBuffer;
} CaptureBitmapData;


#endif // __CAPTURE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\capture.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: capture.cpp                                                     */
/* Description: Convert a captured DVD frame from YUV formats to RGB,    */
/*              and save to file in various formats.                     */
/* Author: phillu                                                        */
/*************************************************************************/

#include "stdafx.h"

#include "MSWebDVD.h"
#include "msdvd.h"
#include <shlobj.h>
#include "capture.h"


HRESULT WriteBitmapDataToJPEGFile(char * filename, CaptureBitmapData *bm);
HRESULT WriteBitmapDataToBMPFile(char * filename, CaptureBitmapData *bm);

// YUV FourCC Formats (byte-swapped). We support a subset of them.
// Ref: http://www.webartz.com/fourcc/

// packed formats
#define FourCC_IYU1     '1UYI'
#define FourCC_IYU2     '2UYI'
#define FourCC_UYVY     'YVYU'      // supported
#define FourCC_UYNV     'VNYU'      // supported
#define FourCC_cyuv     'vuyc'
#define FourCC_YUY2     '2YUY'      // supported
#define FourCC_YUNV     'VNUY'      // supported
#define FourCC_YVYU     'UYVY'      // supported
#define FourCC_Y41P     'P14Y'
#define FourCC_Y211     '112Y'
#define FourCC_Y41T     'T14Y'
#define FourCC_Y42T     'T24Y'
#define FourCC_CLJR     'RJLC'

// planar formats
#define FourCC_YVU9     '9UVY'
#define FourCC_IF09     '90FI'
#define FourCC_YV12     '21VY'      // supported
#define FourCC_I420     '024I'
#define FourCC_IYUV     'VUYI'
#define FourCC_CLPL     'LPLC'


extern CComModule _Module;

//
// Save image file
//

static HRESULT
SaveFileDialog(HWND hwnd, CaptureBitmapData *bmpdata)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    OPENFILENAME ofn;
    TCHAR filename[MAX_PATH];
    TCHAR FolderPath[MAX_PATH];
    const ciBufSize = 256;
    TCHAR titlestring[ciBufSize];

    // get the path of "My Pictures" and use it as default location
    if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_MYPICTURES, FALSE) == FALSE)
    {
        // if My Pictures doesn't exist, try My Documents
        if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_PERSONAL, FALSE) == FALSE)
        {
            // use current directory as last resort
            lstrcpyn(FolderPath,  _T("."), sizeof(FolderPath) / sizeof(FolderPath[0]));
        }
    }

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = _Module.m_hInstResource;
    ofn.lpstrFile = filename;
    ofn.lpstrDefExt = _T("jpg"); // it appears it doesn't matter what string to use
                       // it will use the ext in lpstrFilter according to selected type.
    ofn.nMaxFile = MAX_PATH;
    ::LoadString(_Module.m_hInstResource, IDS_SAVE_FILE, titlestring, ciBufSize);
    ofn.lpstrTitle = titlestring;
    ofn.lpstrInitialDir = FolderPath;
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_EXPLORER;
    lstrcpyn(filename, _T("capture"), sizeof(filename) / sizeof(filename[0]));

    // Make up the file type filter string

    TCHAR* filter = _T("JPEG\0*.JPG\0Windows Bitmap\0*.BMP\0");

    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1; // set format to JPG as default

    // Present the file/save dialog

    if (GetSaveFileName(&ofn))
    {
        switch (ofn.nFilterIndex)
        {
        case 2:
            hr = WriteBitmapDataToBMPFile(T2A(filename), bmpdata);
            break;
        default:
            hr = WriteBitmapDataToJPEGFile(T2A(filename), bmpdata);
            break;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////
// This block of code deals with converting YUV format to RGB bitmap
///////////////////////////////////////////////////////////////////////

static inline BYTE Clamp(float x)
{
    if (x < 0.0f)
        return 0;
    else if (x > 255.0f)
        return 255;
    else
        return (BYTE)(x + 0.5f);
}

// Convert YUV to RGB
static inline void ConvertPixelToRGB(int y, int u, int v, BYTE *pBuf)
{
    //
    // This equation was taken from Video Demystified (2nd Edition)
    // by Keith Jack, page 43.
    //

    BYTE red = Clamp((1.1644f * (y-16)) + (1.5960f * (v-128))                       );
    BYTE grn = Clamp((1.1644f * (y-16)) - (0.8150f * (v-128)) - (0.3912f * (u-128)));
    BYTE blu = Clamp((1.1644f * (y-16))                        + (2.0140f * (u-128)));

    // RGB format, 3 bytes per pixel

    pBuf[0] = red;
    pBuf[1] = grn;
    pBuf[2] = blu;
}

// Convert image in YUY2 format to RGB bitmap

static void ConvertYUY2ToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x += 2)
        {
            int  Y0 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
            ConvertPixelToRGB(Y1, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}

// Convert image in UYVY format to RGB bitmap

static void ConvertUYVYToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x += 2)
        {
            int  U0 = (int) *pYUVBits++;
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
            ConvertPixelToRGB(Y1, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}

// Convert image in YVYU format to RGB bitmap

static void ConvertYVYUToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x += 2)
        {
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
            ConvertPixelToRGB(Y1, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}


// Convert image in YV12 format to RGB bitmap

static void ConvertYV12ToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/2) * (lpImage->lStride/2);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/2) * (lpImage->lStride/2);

        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x ++)
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 2x2 pixels. only advance pointers every two pixels

            if (x&1)
            {
                pVBits++;
                pUBits++;
            }

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}

// Convert image in YVU9 format to RGB bitmap

static void ConvertYVU9ToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/4) * (lpImage->lStride/4);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/4) * (lpImage->lStride/4);

        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x ++)
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 4x4 pixels. only advance pointers every 4 pixels

            if ((x&3) == 3)
            {
                pVBits++;
                pUBits++;
            }

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}


static HRESULT InitBitmapData(CaptureBitmapData *bmpdata, int Width, int Height)
{
    bmpdata->Width = Width;
    bmpdata->Height = Height;
    bmpdata->Stride = (BYTES_PER_PIXEL*Width + 3) & (~3); // align with word boundary
    bmpdata->Scan0 = new BYTE[Height * bmpdata->Stride];
    bmpdata->pBuffer = bmpdata->Scan0;

    if (NULL == bmpdata->Scan0)
    {
        return E_OUTOFMEMORY;
    }

    
    return S_OK;
}


static void FreeBitmapData(CaptureBitmapData *bmpdata)
{
    delete[] bmpdata->pBuffer;
    bmpdata->pBuffer = NULL;
    bmpdata->Scan0 = NULL;
}


static HRESULT ConvertToBitmapImage(YUV_IMAGE *lpImage, CaptureBitmapData *bmp)
{
    HRESULT hr = S_OK;

    // create a bitmap object

    hr = InitBitmapData(bmp, lpImage->lWidth, lpImage->lHeight);

    if (FAILED(hr))
    {
        return hr;
    }

    bool fSupported = true;

        // convert different types of YUV formats to RGB

    switch (lpImage->dwFourCC)
    {
    case FourCC_YUY2:
    case FourCC_YUNV:  // the two are equivalent
        ConvertYUY2ToBitmap(lpImage, bmp);
        break;

    case FourCC_UYVY:
    case FourCC_UYNV:  // equivalent
        ConvertUYVYToBitmap(lpImage, bmp);
        break;

    case FourCC_YVYU:
        ConvertYVYUToBitmap(lpImage, bmp);
        break;

    case FourCC_YV12:
        ConvertYV12ToBitmap(lpImage, bmp);
        break;

    case FourCC_YVU9:
        ConvertYVU9ToBitmap(lpImage, bmp);
        break;

    default:
        fSupported = false;
        break;
    }

    if (!fSupported)
    {
        hr = E_FORMAT_NOT_SUPPORTED;
    }

    return hr;
}


#ifdef _DEBUG
static void AlertUnsupportedFormat(DWORD dwFourCC, HWND hwnd)
{
    char buf[256];
    StringCchPrintf(buf, sizeof(buf), "YUV format %c%c%c%c not supported\n",
        dwFourCC & 0xff,
        (dwFourCC >> 8) & 0xff,
        (dwFourCC >> 16) & 0xff,
        (dwFourCC >> 24) & 0xff);
    MessageBoxA(hwnd, buf, "", MB_OK);
}
#endif


// This helper function does several things.
//
// First, it determines if clipping is necessary, return true if it is,
// and false otherwise.
//
// Second, it maps the ViewClipRect (clipping rect in the view coordinates,
// i.e. the one after correcting aspect ratio) back to the raw captured
// image coordinates. Return it in ImageClipRect. This step is skipped (and
// ImageClipRect will be invalid) if clipping is not necessary.
//
// Third, it calculates the stretched image size. It should be in the same
// aspect ratio as the ViewClipRect. It will also be made as full-size as possible

static bool ClipAndStretchSizes(YUV_IMAGE *lpImage, const RECT *pViewClipRect,
                         RECT *pImageClipRect, int *pViewWidth, int *pViewHeight)
{
    float aspectRaw = (float)lpImage->lHeight / (float)lpImage->lWidth;
    float aspectView = (float)lpImage->lAspectY / (float)lpImage->lAspectX;
    int viewWidth = lpImage->lWidth;
    int viewHeight = (int)(viewWidth * aspectView + 0.5f);

    // the rect is given in the stretched (aspect-ratio corrected) window
    // we will adjust it back to the raw image space

    bool fClip = false;

    if (pViewClipRect)
    {
        RECT rc;
        rc.left = pViewClipRect->left;
        rc.right = pViewClipRect->right;
        rc.top = (int)(pViewClipRect->top * aspectRaw / aspectView + 0.5f);
        rc.bottom = (int)(pViewClipRect->bottom * aspectRaw / aspectView + 0.5f);

        RECT rcFullImage;
        ::SetRect(&rcFullImage, 0, 0, lpImage->lWidth, lpImage->lHeight);

        if (! ::EqualRect(&rc, &rcFullImage) &&
            ::IntersectRect(pImageClipRect, &rc, &rcFullImage))
        {
            fClip = true;
        }
    }

    // adjust the stretched image size according to the rect aspect ratio

    if (fClip)
    {
        float aspectRect = (float)(RECTHEIGHT(pViewClipRect))
                            / (float)(RECTWIDTH(pViewClipRect));

        if (aspectRect < aspectView)
        {
            // clip rect has a wider aspect ratio.
            // keep the width, adjust the height

            viewHeight = (int)(viewWidth * aspectRect + 0.5f);
        }
        else
        {
            // clip rect has a taller aspect ratio.
            // keep the height, adjust width

            viewWidth = (int)(viewHeight / aspectRect + 0.5f);
        }
    }

    *pViewWidth = viewWidth;
    *pViewHeight = viewHeight;

    return fClip;
}


static HRESULT ClipBitmap(CaptureBitmapData *bmpdata, RECT *rect)
{
    HRESULT hr = S_OK;

    if (NULL == rect)
    {
        return S_OK;
    }

    bmpdata->Width = rect->right - rect->left;
    bmpdata->Height = rect->bottom - rect->top;
    //    bmpdata->Stride = bmpdata->Stride;
    bmpdata->Scan0 = bmpdata->Scan0 +
                     rect->top * bmpdata->Stride + (rect->left * BYTES_PER_PIXEL);

    return S_OK;
}


static HRESULT StretchBitmap(CaptureBitmapData *bmpdata, int newWidth, int newHeight)
{
    HRESULT hr = S_OK;
    int nX, nY, nX0, nY0, nX1, nY1;
    double dXRatio, dYRatio, dXCoor, dYCoor, dXR, dYR;
    double pdRGB0[3];
    double pdRGB1[3];
    BYTE *pRow0;
    BYTE *pRow1;
    BYTE *pPix0;
    BYTE *pPix1;
    BYTE *pDest;

    if (bmpdata->Width == newWidth && bmpdata->Height == newHeight)
    {
        return hr;
    }

    int newStride = (newWidth*BYTES_PER_PIXEL + 3) & (~3); // align with word boundary
    BYTE *pBuffer = new BYTE[newHeight * newStride];

    if (NULL == pBuffer)
    {
        return E_OUTOFMEMORY;
    }

    dXRatio = (double)(bmpdata->Width)/(double)(newWidth);
    dYRatio = (double)(bmpdata->Height)/(double)(newHeight);

    // bilinear stretching
    // Note this is not the most efficient algorithm as it uses a lot of floating calc
    // Nevertheless it is simple

    for (nY = 0; nY < newHeight; nY++)
    {
        // determine two coordinates along Y direction for interpolation

        dYCoor = (nY + 0.5)*dYRatio - 0.5;

        if (dYCoor < 0)
        {
            nY0 = nY1 = 0;
            dYR = 0.0;
        }
        else if (dYCoor >= bmpdata->Height - 1)
        {
            nY0 = nY1 = bmpdata->Height - 1;
            dYR = 0.0;
        }
        else
        {
            nY0 = (int)dYCoor;
            nY1 = nY0 + 1;
            dYR = dYCoor - nY0;
        }

        pRow0 = bmpdata->Scan0 + nY0 * bmpdata->Stride;
        pRow1 = bmpdata->Scan0 + nY1 * bmpdata->Stride;
        pDest = pBuffer + nY * newStride;

        for (nX = 0; nX < newWidth; nX++, pDest+=3)
        {
            // determine two coordinates along X direction for interpolation

            dXCoor = (nX + 0.5)*dXRatio - 0.5;

            if (dXCoor < 0)
            {
                nX0 = nX1 = 0;
                dXR = 0.0;
            }
            else if (dXCoor >= bmpdata->Width - 1)
            {
                nX0 = nX1 = bmpdata->Width - 1;
                dXR = 0.0;
            }
            else
            {
                nX0 = (int)dXCoor;
                nX1 = nX0 + 1;
                dXR = dXCoor - nX0;
            }

            // interpolate along X, in the upper row
            pPix0 = pRow0 + nX0 * BYTES_PER_PIXEL;
            pPix1 = pRow0 + nX1 * BYTES_PER_PIXEL;
            pdRGB0[0] = pPix0[0] + (pPix1[0] - pPix0[0])*dXR;
            pdRGB0[1] = pPix0[1] + (pPix1[1] - pPix0[1])*dXR;
            pdRGB0[2] = pPix0[2] + (pPix1[2] - pPix0[2])*dXR;

            // interpolate along X, in the lower row
            pPix0 = pRow1 + nX0 * BYTES_PER_PIXEL;
            pPix1 = pRow1 + nX1 * BYTES_PER_PIXEL;
            pdRGB1[0] = pPix0[0] + (pPix1[0] - pPix0[0])*dXR;
            pdRGB1[1] = pPix0[1] + (pPix1[1] - pPix0[1])*dXR;
            pdRGB1[2] = pPix0[2] + (pPix1[2] - pPix0[2])*dXR;

            // interpolate along Y
            pDest[0] = (BYTE)(pdRGB0[0] + (pdRGB1[0] - pdRGB0[0])*dYR + 0.5);
            pDest[1] = (BYTE)(pdRGB0[1] + (pdRGB1[1] - pdRGB0[1])*dYR + 0.5);
            pDest[2] = (BYTE)(pdRGB0[2] + (pdRGB1[2] - pdRGB0[2])*dYR + 0.5);
        }
    }

    // replace the bitmap buffer

    delete[] bmpdata->pBuffer;
    bmpdata->pBuffer = bmpdata->Scan0 = pBuffer;
    bmpdata->Stride = newStride;
    bmpdata->Width = newWidth;
    bmpdata->Height = newHeight;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// ConvertImageAndSave: this is the main function to be called by the player.
//
// Convert a captured YUV image to a GDI BitmapImage, and save it to a file
// allowing user to choose file format and file name.

// The clipping rectangle should be in the full size view coordinate system
// with corrected aspect ratio (i.e. 720x540 for 4:3).

HRESULT ConvertImageAndSave(YUV_IMAGE *lpImage, RECT *pViewClipRect, HWND hwnd)
{
    HRESULT hr = S_OK;
    CaptureBitmapData bmpdata;

    hr = ConvertToBitmapImage(lpImage, &bmpdata);


#ifdef _DEBUG
    if (E_FORMAT_NOT_SUPPORTED == hr)
    {
        AlertUnsupportedFormat(lpImage->dwFourCC, hwnd);
    }
#endif


    // calculate size and rectangles for clipping and stretching

    int viewWidth, viewHeight; // size of the clipped and stretch image
    bool fClip;  // is clipping necessary
    RECT rcClipImage;  // view clipping rect mapped to image space

    fClip = ClipAndStretchSizes(lpImage, pViewClipRect, &rcClipImage,
                                &viewWidth, &viewHeight);

    // crop the image to the clip rectangle.

    if (SUCCEEDED(hr) && fClip)
    {
        hr = ClipBitmap(&bmpdata, &rcClipImage);
    }

    // stretch the image to the right aspect ratio

    if (SUCCEEDED(hr))
    {
        hr = StretchBitmap(&bmpdata, viewWidth, viewHeight);
    }

    // save final bitmap to a file

    if (SUCCEEDED(hr))
    {
        hr = SaveFileDialog(hwnd, &bmpdata);
    }

    // clean up, release the image buffer

    FreeBitmapData(&bmpdata);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\capture_gdi.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: capture.cpp                                                     */
/* Description: Convert a captured DVD frame from YUV formats to RGB,    */
/*              and save to file in various formats.                     */
/* Author: phillu                                                        */
/*************************************************************************/

#include "stdafx.h"

// This version of capture is for Millennium where GDI+ is installed

#include "MSWebDVD.h"
#include "msdvd.h"
#include <initguid.h>
#include "imaging.h"
#include <shlobj.h>

// YUV FourCC Formats (byte-swapped). We support a subset of them.
// Ref: http://www.webartz.com/fourcc/

// packed formats
#define FourCC_IYU1     '1UYI'
#define FourCC_IYU2     '2UYI'
#define FourCC_UYVY     'YVYU'      // supported
#define FourCC_UYNV     'VNYU'      // supported
#define FourCC_cyuv     'vuyc'
#define FourCC_YUY2     '2YUY'      // supported
#define FourCC_YUNV     'VNUY'      // supported
#define FourCC_YVYU     'UYVY'      // supported
#define FourCC_Y41P     'P14Y'
#define FourCC_Y211     '112Y'
#define FourCC_Y41T     'T14Y'
#define FourCC_Y42T     'T24Y'
#define FourCC_CLJR     'RJLC'

// planar formats
#define FourCC_YVU9     '9UVY'
#define FourCC_IF09     '90FI'
#define FourCC_YV12     '21VY'      // supported
#define FourCC_I420     '024I'
#define FourCC_IYUV     'VUYI'
#define FourCC_CLPL     'LPLC'

// global variables

IImagingFactory* g_pImgFact = NULL;   // pointer to IImageingFactory object

// helper: calls release on a Non-NULL pointer, and sets it to NULL
#define SAFE_RELEASE(ptr)       \
{                               \
	if (ptr)					\
	{							\
		ptr->Release();			\
		ptr	= NULL;				\
	}							\
}

extern CComModule _Module;

///////////////////////////////////////////////////////////////////////////
// This block of code handles saving a GDI+ image object to a file,
// allowing user to select a format.
///////////////////////////////////////////////////////////////////////////


//
// Save the current image to a file
//

static HRESULT
SaveImageFile(IImage *pImage, const TCHAR* filename, const CLSID* clsid)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    if (!pImage || !g_pImgFact)
        return E_FAIL;

    // Create an encoder object

    IImageEncoder* encoder = NULL;
    hr = g_pImgFact->CreateImageEncoderToFile(clsid, T2CW(filename), &encoder);

    if (FAILED(hr))
        return hr;

    // Get an IImageSink interface to the encoder

    IImageSink* sink = NULL;

    hr = encoder->GetEncodeSink(&sink);

    if (SUCCEEDED(hr))
    {
        hr = pImage->PushIntoSink(sink);
        SAFE_RELEASE(sink);
    }

    encoder->TerminateEncoder();
    SAFE_RELEASE(encoder);

    return hr;
}


//
// Compose a file type filter string given an array of
// ImageCodecInfo structures; also find the index of JPG format
//

static TCHAR* 
MakeFilterFromCodecs(UINT count, const ImageCodecInfo* codecs, UINT *jpgIndex)
{
    USES_CONVERSION;
    
    // Figure out the total size of the filter string

    UINT index, size;

    for (index=size=0; index < count; index++)
    {
        size += wcslen(codecs[index].FormatDescription) + 1
                + wcslen(codecs[index].FilenameExtension) + 1;
    }

    size += 1; // for the double trailing '\0'

    // Allocate memory

    TCHAR *filter = (TCHAR*) malloc(size*sizeof(TCHAR));
    UINT strSize = size;
    if (!filter)
        return NULL;

    TCHAR* p = filter;
    const WCHAR* ws;
    *jpgIndex = 0;
    LPCTSTR strTemp = NULL;

    for (index=0; index < count; index++)
    {
        ws = codecs[index].FormatDescription;
        size = wcslen(ws) + 1;
        strTemp = W2CT(ws);
        if (NULL != strTemp)
        {
            lstrcpyn(p, strTemp, strSize - lstrlen(p));
            p += size;
        }

        ws = codecs[index].FilenameExtension;
        size = wcslen(ws) + 1;
        strTemp = W2CT(ws);
        if (NULL != strTemp)
        {
            lstrcpyn(p, strTemp, strSize - lstrlen(p));
            p += size;
        }

        // find the index of jpg format
        if (wcsstr(ws, L"JPG"))
        {
            *jpgIndex = index + 1;
        }
    }

    *((TCHAR*) p) = _T('\0');

    return filter;
}

//
// Save image file
//

static HRESULT 
SaveFileDialog(HWND hwnd, IImage *pImage)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    OPENFILENAME ofn;
    TCHAR filename[MAX_PATH];
    TCHAR FolderPath[MAX_PATH];
    const ciBufSize = 256;
    TCHAR titlestring[ciBufSize];

    // get the path of "My Pictures" and use it as default location
    if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_MYPICTURES, FALSE) == FALSE)
    {
        // if My Pictures doesn't exist, try My Documents
        
        if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_PERSONAL, FALSE) == FALSE)
        { 
            // use current directory as last resort
            lstrcpyn(FolderPath, _T("."), sizeof(FolderPath) / sizeof(FolderPath[0]));
        }
    }

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = _Module.m_hInstResource;
    ofn.lpstrFile = filename;
    ofn.lpstrDefExt = _T("jpg"); // it appears it doesn't matter what string to use
                       // it will use the ext in lpstrFilter according to selected type.
    ofn.nMaxFile = MAX_PATH;
    ::LoadString(_Module.m_hInstResource, IDS_SAVE_FILE, titlestring, ciBufSize);
    ofn.lpstrTitle = titlestring;
    ofn.lpstrInitialDir = FolderPath;
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_EXPLORER;
    lstrcpyn(filename, _T("capture"), sizeof(filename) / sizeof(filename[0]));

    // Make up the file type filter string

    ImageCodecInfo* codecs;
    UINT count;

    hr = g_pImgFact->GetInstalledEncoders(&count, &codecs);

    if (FAILED(hr))
        return hr;

    UINT jpgIndex;
    TCHAR* filter = MakeFilterFromCodecs(count, codecs, &jpgIndex);

    if (!filter)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }
    else
    {
        ofn.lpstrFilter = filter;
        ofn.nFilterIndex = jpgIndex; // set format to JPG as default

        // Present the file/save dialog

        if (GetSaveFileName(&ofn))
        {
            UINT index = ofn.nFilterIndex;

            if (index == 0 || index > count)
                index = 0;
            else
                index--;

            hr = SaveImageFile(pImage, filename, &codecs[index].Clsid);
        }   

        free(filter);
    } 

    CoTaskMemFree(codecs);

    return hr;
}


///////////////////////////////////////////////////////////////////////
// This block of code deals with converting YUV format to RGB bitmap
///////////////////////////////////////////////////////////////////////

inline BYTE Clamp(float x)
{
    if (x < 0.0f)
        return 0;
    else if (x > 255.0f)
        return 255;
    else
        return (BYTE)(x + 0.5f);
}

// Convert YUV to ARGB
static inline ARGB ConvertPixelToARGB(int y, int u, int v)
{
    //
    // This equation was taken from Video Demystified (2nd Edition)
    // by Keith Jack, page 43.
    //

    BYTE red = Clamp((1.1644f * (y-16)) + (1.5960f * (v-128))                       );
    BYTE grn = Clamp((1.1644f * (y-16)) - (0.8150f * (v-128)) - (0.3912f * (u-128)));
    BYTE blu = Clamp((1.1644f * (y-16))                        + (2.0140f * (u-128)));

    return MAKEARGB(0xff, red, grn, blu);
}

// Convert image in YUY2 format to RGB bitmap

static void ConvertYUY2ToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x += 2) 
        {
            int  Y0 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
            *pARGB++ = ConvertPixelToARGB(Y1, U0, V0);
        }
    }
}

// Convert image in UYVY format to RGB bitmap

static void ConvertUYVYToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x += 2) 
        {
            int  U0 = (int) *pYUVBits++;
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
            *pARGB++ = ConvertPixelToARGB(Y1, U0, V0);
        }
    }
}

// Convert image in YVYU format to RGB bitmap

static void ConvertYVYUToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x += 2) 
        {
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
            *pARGB++ = ConvertPixelToARGB(Y1, U0, V0);
        }
    }
}


// Convert image in YV12 format to RGB bitmap

static void ConvertYV12ToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/2) * (lpImage->lStride/2);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/2) * (lpImage->lStride/2);

        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x ++) 
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 2x2 pixels. only advance pointers every two pixels

            if (x&1)
            {
                pVBits++;
                pUBits++;
            }

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
        }
    }
}

// Convert image in YVU9 format to RGB bitmap

static void ConvertYVU9ToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/4) * (lpImage->lStride/4);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/4) * (lpImage->lStride/4);

        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x ++) 
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 4x4 pixels. only advance pointers every 4 pixels

            if ((x&3) == 3)
            {
                pVBits++;
                pUBits++;
            }

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
        }
    }
}


static HRESULT ConvertToBitmapImage(YUV_IMAGE *lpImage, IBitmapImage **bmp)
{
    IBitmapImage* bmpimg = NULL;
    BitmapData bmpdata;
    HRESULT hr = S_OK;

    // create a bitmap object

    if (!g_pImgFact || bmp == NULL)
    {
        return E_FAIL;
    }

    hr = g_pImgFact->CreateNewBitmap(
                lpImage->lWidth,
                lpImage->lHeight,
                PIXFMT_32BPP_ARGB,
                &bmpimg);

    bool fSupported = true;

    if (SUCCEEDED(hr)) // bmpimg created
    {
        hr = bmpimg->LockBits(
                    NULL,
                    IMGLOCK_WRITE,
                    PIXFMT_DONTCARE,
                    &bmpdata);

        if (SUCCEEDED(hr))
        {
            // convert different types of YUV formats to RGB

            switch (lpImage->dwFourCC) 
            {
            case FourCC_YUY2:
            case FourCC_YUNV:  // the two are equivalent
                ConvertYUY2ToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_UYVY:
            case FourCC_UYNV:  // equivalent
                ConvertUYVYToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_YVYU:
                ConvertYVYUToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_YV12:
                ConvertYV12ToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_YVU9:
                ConvertYVU9ToBitmap(lpImage, &bmpdata);
                break;

            default:
                fSupported = false;
                break;
            }

            hr = bmpimg->UnlockBits(&bmpdata);
        }

        if (!fSupported)
        {
            SAFE_RELEASE(bmpimg);
            hr = E_FORMAT_NOT_SUPPORTED;
        }
    }

    *bmp = bmpimg;
    // Addref() and Release() cancels out
    bmpimg = NULL;

    return hr;
}


#ifdef _DEBUG
static void AlertUnsupportedFormat(DWORD dwFourCC, HWND hwnd)
{
    char buf[256];
    StringCchPrintf(buf, sizeof(buf), "YUV format %c%c%c%c not supported\n",
        dwFourCC & 0xff, 
        (dwFourCC >> 8) & 0xff,
        (dwFourCC >> 16) & 0xff, 
        (dwFourCC >> 24) & 0xff);
    MessageBoxA(hwnd, buf, "", MB_OK);
}
#endif


// This helper function does several things.
//
// First, it determines if clipping is necessary, return true if it is,
// and false otherwise.
// 
// Second, it maps the ViewClipRect (clipping rect in the view coordinates,
// i.e. the one after correcting aspect ratio) back to the raw captured
// image coordinates. Return it in ImageClipRect. This step is skipped (and
// ImageClipRect will be invalid) if clipping is not necessary.
//
// Third, it calculates the stretched image size. It should be in the same
// aspect ratio as the ViewClipRect. It will also be made as full-size as possible

static bool ClipAndStretchSizes(YUV_IMAGE *lpImage, const RECT *pViewClipRect,
                         RECT *pImageClipRect, int *pViewWidth, int *pViewHeight)
{
    float aspectRaw = (float)lpImage->lHeight / (float)lpImage->lWidth;
    float aspectView = (float)lpImage->lAspectY / (float)lpImage->lAspectX;
    int viewWidth = lpImage->lWidth;
    int viewHeight = (int)(viewWidth * aspectView + 0.5f);

    // the rect is given in the stretched (aspect-ratio corrected) window
    // we will adjust it back to the raw image space
    
    bool fClip = false;

    if (pViewClipRect)
    {
        RECT rc;
        rc.left = pViewClipRect->left;
        rc.right = pViewClipRect->right;
        rc.top = (int)(pViewClipRect->top * aspectRaw / aspectView + 0.5f);
        rc.bottom = (int)(pViewClipRect->bottom * aspectRaw / aspectView + 0.5f);

        RECT rcFullImage;
        ::SetRect(&rcFullImage, 0, 0, lpImage->lWidth, lpImage->lHeight);

        if (! ::EqualRect(&rc, &rcFullImage) &&
            ::IntersectRect(pImageClipRect, &rc, &rcFullImage))
        {
            fClip = true;
        }
    }

    // adjust the stretched image size according to the rect aspect ratio

    if (fClip)
    {
        float aspectRect = (float)(RECTHEIGHT(pViewClipRect)) 
                            / (float)(RECTWIDTH(pViewClipRect));

        if (aspectRect < aspectView)
        {
            // clip rect has a wider aspect ratio.
            // keep the width, adjust the height

            viewHeight = (int)(viewWidth * aspectRect + 0.5f);
        }
        else
        {
            // clip rect has a taller aspect ratio.
            // keep the height, adjust width

            viewWidth = (int)(viewHeight / aspectRect + 0.5f);
        }
    }

    *pViewWidth = viewWidth;
    *pViewHeight = viewHeight;

    return fClip;
}


/////////////////////////////////////////////////////////////////////////////
//
// ConvertImageAndSave: this is the main function to be called by the player.
// 
// Convert a captured YUV image to a GDI BitmapImage, and save it to a file
// allowing user to choose file format and file name.

// The clipping rectangle should be in the full size view coordinate system
// with corrected aspect ratio (i.e. 720x540 for 4:3).

HRESULT GDIConvertImageAndSave(YUV_IMAGE *lpImage, RECT *pViewClipRect, HWND hwnd)
{
    IBitmapImage* bmpimg = NULL;
    IBitmapImage* bmpStretched = NULL;
    HRESULT hr = S_OK;
    
    // Create an IImagingFactory object
     
    hr = CoCreateInstance(
            CLSID_ImagingFactory,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IImagingFactory,
            (VOID**) &g_pImgFact);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = ConvertToBitmapImage(lpImage, &bmpimg);
    
#ifdef _DEBUG
    if (E_FORMAT_NOT_SUPPORTED == hr)
    {
        AlertUnsupportedFormat(lpImage->dwFourCC, hwnd);
    }
#endif


    // calculate size and rectangles for clipping and stretching

    int viewWidth, viewHeight; // size of the clipped and stretch image
    bool fClip;  // is clipping necessary
    RECT rcClipImage;  // view clipping rect mapped to image space

    fClip = ClipAndStretchSizes(lpImage, pViewClipRect, &rcClipImage,
                                &viewWidth, &viewHeight);

    // crop the image to the clip rectangle.

    if (SUCCEEDED(hr) && fClip) // by now we have valid bits in bmpimg
    {
        IBasicBitmapOps *bmpops = NULL;
        IBitmapImage* bmpClipped = NULL;

        hr = bmpimg->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

        if (SUCCEEDED(hr))
        {
            hr = bmpops->Clone(&rcClipImage, &bmpClipped);
            SAFE_RELEASE(bmpops);
        }

        if (SUCCEEDED(hr)) // valid bmpClipped
        {
            // replace bmpimg with bmpClipped

            SAFE_RELEASE(bmpimg);
            bmpimg = bmpClipped;
            bmpimg->AddRef();
            SAFE_RELEASE(bmpClipped);
        }
    }

    // stretch the image to the right aspect ratio

    if (SUCCEEDED(hr)) // valid bits in bmpimg
    {
        IImage *image = NULL;

        hr = bmpimg->QueryInterface(IID_IImage, (VOID**) &image);

        if (SUCCEEDED(hr))
        {
            hr = g_pImgFact->CreateBitmapFromImage(
                        image,
                        viewWidth, 
                        viewHeight,
                        PIXFMT_DONTCARE, 
                        INTERP_BILINEAR, 
                        &bmpStretched);
    
            SAFE_RELEASE(image);
        }

        SAFE_RELEASE(bmpimg);
    }

    // save final bitmap to a file

    if (SUCCEEDED(hr)) // bmpStretched valid
    {
        IImage *image = NULL;

        hr = bmpStretched->QueryInterface(IID_IImage, (VOID**) &image);

        if (SUCCEEDED(hr))
        {
            hr = SaveFileDialog(hwnd, image);
            SAFE_RELEASE(image);
        }

        SAFE_RELEASE(bmpStretched);
    } 

    // clean up, release the imaging factory

    SAFE_RELEASE(g_pImgFact);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\ddrawobj.h ===
/*************************************************************************/
/* Helper function                                                       */
/*************************************************************************/
#include "resource.h"       // main symbols
#include <atlctl.h>
#include "MSWebDVD.h"
#include "msdvd.h"

class CDDrawDVD;

/////////////////////////////////////////////////////////////////////////////
// COverlayCallback
class ATL_NO_VTABLE COverlayCallback : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<COverlayCallback, &CLSID_OverlayCallback>,
	public IDispatchImpl<IOverlayCallback, &IID_IOverlayCallback, &LIBID_MSWEBDVDLib>,
    public IObjectWithSiteImplSec<COverlayCallback>,
    public IDDrawExclModeVideoCallback
{
public:
	COverlayCallback()
	{
        m_dwWidth = 0;
        m_dwHeight = 0;
        m_dwARWidth = 1;
        m_dwARHeight = 1;
        m_pDDrawDVD = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_OVERLAYCALLBACK)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COverlayCallback)
	COM_INTERFACE_ENTRY(IOverlayCallback)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IDDrawExclModeVideoCallback)
END_COM_MAP()

// IOverlayCallback
public:

    STDMETHOD(SetDDrawDVD)(VARIANT pDDrawDVD);

    //IDDrawExclModeVideoCallback
    HRESULT STDMETHODCALLTYPE OnUpdateOverlay(BOOL  bBefore,
        DWORD dwFlags,
        BOOL  bOldVisible,
        const RECT *prcSrcOld,
        const RECT *prcDestOld,
        BOOL  bNewVisible,
        const RECT *prcSrcNew,
        const RECT *prcDestNew);    
    HRESULT STDMETHODCALLTYPE OnUpdateColorKey(COLORKEY const *pKey, DWORD dwColor);
    HRESULT STDMETHODCALLTYPE OnUpdateSize(DWORD dwWidth, DWORD dwHeight, 
        DWORD dwARWidth, DWORD dwARHeight);
private:
    CDDrawDVD *m_pDDrawDVD;
    DWORD m_dwWidth;
    DWORD m_dwHeight;
    DWORD m_dwARWidth;
    DWORD m_dwARHeight;
};


//
// DDraw object class to paint color key, flip etc etc.
//
class CDDrawDVD {

public:
    CDDrawDVD(CMSWebDVD *pDVD);
    ~CDDrawDVD();

    HRESULT SetupDDraw(const AMDDRAWGUID* lpDDGUID, HWND hWnd);
    HRESULT SetColorKey(COLORREF dwColorKey);
    COLORREF GetColorKey();

    HRESULT CreateDIBBrush(COLORREF rgb, HBRUSH *phBrush);

    inline CMSWebDVD* GetDVD() {return m_pDVD;};
    inline IDirectDraw* GetDDrawObj(){return ((IDirectDraw*) m_pDDObject);}
    inline IDirectDrawSurface* GetDDrawSurf(){return ((IDirectDrawSurface*) m_pPrimary);}
    inline IDDrawExclModeVideoCallback * GetCallbackInterface() { 

        CComQIPtr<IDDrawExclModeVideoCallback, &IID_IDDrawExclModeVideoCallback> pIDDrawExclModeVideoCallback(m_pOverlayCallback);
        return (IDDrawExclModeVideoCallback*) pIDDrawExclModeVideoCallback ; 
    } ;

    HRESULT DDColorMatchOffscreen(COLORREF rgb, DWORD* dwColor);
    HRESULT HasOverlay();
    HRESULT HasAvailableOverlay();
    HRESULT GetOverlayMaxStretch(DWORD *pdwMaxStretch);
private:

    CComPtr<IDirectDraw>  m_pDDObject; // ddraw object
    CComPtr<IDirectDrawSurface> m_pPrimary; // primary ddraw surface    
    CComPtr<IOverlayCallback> m_pOverlayCallback ;  // overlay callback handler interface

    COLORREF m_VideoKeyColor ;
    CMSWebDVD *m_pDVD;
};

#define DibFree(pdib)           GlobalFreePtr(pdib)
#define DibWidth(lpbi)          _abs((int)(LONG)(((LPBITMAPINFOHEADER)(lpbi))->biWidth))
#define DibHeight(lpbi)         _abs((int)(LONG)(((LPBITMAPINFOHEADER)(lpbi))->biHeight))
#define DibBitCount(lpbi)       (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biBitCount)
#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)

#define DibWidthBytesN(lpbi, n) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(n))
#define DibWidthBytes(lpbi)     DibWidthBytesN(lpbi, (lpbi)->biBitCount)

#define DibSizeImage(lpbi)      ((lpbi)->biSizeImage == 0 \
                                    ? ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)DibHeight(lpbi)) \
                                    : (lpbi)->biSizeImage)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))

#define DibFlipY(lpbi, y)       ((int)_abs((lpbi)->biHeight)-1-(y))

//HACK for NT BI_BITFIELDS DIBs
#ifdef WIN32
    #define DibPtr(lpbi)        ((lpbi)->biCompression == BI_BITFIELDS \
                                    ? (LPVOID)(DibColors(lpbi) + 3) : (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed))
#else
    #define DibPtr(lpbi)        (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed)
#endif

#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\dvdrect.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: DVDRect.h                                                       */
/* Description: Declaration of the CDVDRect                              */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __DVDRECT_H_
#define __DVDRECT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDVDRect
class ATL_NO_VTABLE CDVDRect : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDVDRect, &CLSID_DVDRect>,
	public IDispatchImpl<IDVDRect, &IID_IDVDRect, &LIBID_MSWEBDVDLib>,
    public IObjectWithSiteImplSec<CDVDRect>,
    public ISupportErrorInfo,
    public IObjectSafety
{
public:
    CDVDRect(){ m_x = 0; m_y = 0; m_lWidth = 0; m_lHeight = 0;};

DECLARE_REGISTRY_RESOURCEID(IDR_DVDRECT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVDRect)
	COM_INTERFACE_ENTRY(IDVDRect)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
// IDVDRect
	STDMETHOD(get_Height)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Height)(/*[in]*/ long newVal);
	STDMETHOD(get_Width)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Width)(/*[in]*/ long newVal);
	STDMETHOD(get_y)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_y)(/*[in]*/ long newVal);
	STDMETHOD(get_x)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_x)(/*[in]*/ long newVal);

//IObjectSafety
     STDMETHOD(GetInterfaceSafetyOptions)( REFIID riid, 
                                          DWORD *pdwSupportedOptions, 
                                          DWORD *pdwEnabledOptions );

    STDMETHOD(SetInterfaceSafetyOptions)( REFIID riid, 
                                          DWORD dwOptionSetMask, 
                                          DWORD dwEnabledOptions );
protected:
    HRESULT HandleError(HRESULT hr);

private:
    long m_x;
    long m_y;
    long m_lWidth;
    long m_lHeight;
};

#endif //__DVDRECT_H_

/*************************************************************************/
/* End of file: DVDRect.h                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\gdipluspixelformats.h ===
/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus pixel formats
*
* Abstract:
*
*   Definitions for color types, palettes, pixel format IDs.
*
* Notes:
*
*   imaging.h
*
* Revision History:
*
*   10/13/1999 agodfrey
*       Separated it from imaging.h
*
\**************************************************************************/

#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

//
// 32-bit and 64-bit ARGB pixel value
//

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

#define MAKEARGB(a, r, g, b) \
        (((ARGB) ((a) & 0xff) << ALPHA_SHIFT) | \
         ((ARGB) ((r) & 0xff) <<   RED_SHIFT) | \
         ((ARGB) ((g) & 0xff) << GREEN_SHIFT) | \
         ((ARGB) ((b) & 0xff) <<  BLUE_SHIFT))

//
// In-memory pixel data formats:
//  bits 0-7 = format index
//  bits 8-15 = pixel size (in bits)
//  bits 16-23 = flags
//  bits 24-31 = reserved
//

typedef enum PixelFormatID
{
    PIXFMTFLAG_INDEXED      = 0x00010000, // Indexes into a palette
    PIXFMTFLAG_GDI          = 0x00020000, // Is a GDI-supported format
    PIXFMTFLAG_ALPHA        = 0x00040000, // Has an alpha component
    PIXFMTFLAG_PALPHA       = 0x00080000, // Uses pre-multiplied alpha
    PIXFMTFLAG_EXTENDED     = 0x00100000, // Uses extended color (16 bits per channel)
    PIXFMTFLAG_CANONICAL    = 0x00200000, // ?

    PIXFMT_UNDEFINED        =  0,
    PIXFMT_DONTCARE         =  0,
    PIXFMT_1BPP_INDEXED     =  1 | ( 1 << 8) | PIXFMTFLAG_INDEXED
                                             | PIXFMTFLAG_GDI,
    PIXFMT_4BPP_INDEXED     =  2 | ( 4 << 8) | PIXFMTFLAG_INDEXED
                                             | PIXFMTFLAG_GDI,
    PIXFMT_8BPP_INDEXED     =  3 | ( 8 << 8) | PIXFMTFLAG_INDEXED
                                             | PIXFMTFLAG_GDI,
    PIXFMT_16BPP_GRAYSCALE  =  4 | (16 << 8) | PIXFMTFLAG_EXTENDED,
    PIXFMT_16BPP_RGB555     =  5 | (16 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_16BPP_RGB565     =  6 | (16 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_16BPP_ARGB1555   =  7 | (16 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_GDI,
    PIXFMT_24BPP_RGB        =  8 | (24 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_32BPP_RGB        =  9 | (32 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_32BPP_ARGB       = 10 | (32 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_GDI
                                             | PIXFMTFLAG_CANONICAL,
    PIXFMT_32BPP_PARGB      = 11 | (32 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_PALPHA
                                             | PIXFMTFLAG_GDI,
    PIXFMT_48BPP_RGB        = 12 | (48 << 8) | PIXFMTFLAG_EXTENDED,
    PIXFMT_64BPP_ARGB       = 13 | (64 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_CANONICAL
                                             | PIXFMTFLAG_EXTENDED,
    PIXFMT_64BPP_PARGB      = 14 | (64 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_PALPHA
                                             | PIXFMTFLAG_EXTENDED,
    PIXFMT_24BPP_BGR        = 15 | (24 << 8) | PIXFMTFLAG_GDI,

    PIXFMT_MAX              = 16
} PixelFormatID;

// Return the pixel size for the specified format (in bits)

inline UINT
GetPixelFormatSize(
    PixelFormatID pixfmt
    )
{
    return (pixfmt >> 8) & 0xff;
}

// Determine if the specified pixel format is an indexed color format

inline BOOL
IsIndexedPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_INDEXED) != 0;
}

// Determine if the pixel format can have alpha channel

inline BOOL
IsAlphaPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_ALPHA) != 0;
}

// Determine if the pixel format is an extended format,
// i.e. supports 16-bit per channel

inline BOOL
IsExtendedPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_EXTENDED) != 0;
}

// Determine if the pixel format is canonical format:
//  PIXFMT_32BPP_ARGB
//  PIXFMT_32BPP_PARGB
//  PIXFMT_64BPP_ARGB
//  PIXFMT_64BPP_PARGB

inline BOOL
IsCanonicalPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_CANONICAL) != 0;
}


//
// Color palette
//  palette entries are limited to 32bpp ARGB pixel format
//

enum
{
    PALFLAG_HASALPHA    = 0x0001,
    PALFLAG_GRAYSCALE   = 0x0002,
    PALFLAG_HALFTONE    = 0x0004
};

typedef struct tagColorPalette
{
    UINT Flags;             // palette flags
    UINT Count;             // number of color entries
    ARGB Entries[1];        // palette color  entries
} ColorPalette;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\imaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imaging.h
*
* Abstract:
*
*   Public SDK header file for the imaging library
*
* Notes:
*
*   This is hand-coded for now. Eventually it'll be automatically
*   generated from an IDL file.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGING_H
#define _IMAGING_H

#include "GdiplusPixelFormats.h"

//
// Imaging library GUIDS:
//  image file format identifiers
//  interface and class identifers
//

#include "imgguids.h"

//
// Image property ID tags (PROPID's from the EXIF tags)
//

#define TAG_EXIF_IFD            0x8769
#define TAG_GPS_IFD             0x8825

#define TAG_IMAGE_WIDTH         0x0100
#define TAG_IMAGE_HEIGHT        0x0101
#define TAG_BITS_PER_SAMPLE     0x0102
#define TAG_COMPRESSION         0x0103
#define TAG_PHOTOMETRIC_INTERP  0x0106
#define TAG_IMAGE_DESCRIPTION   0x010E
#define TAG_EQUIP_MAKE          0x010F
#define TAG_EQUIP_MODEL         0x0110
#define TAG_STRIP_OFFSETS       0x0111
#define TAG_ORIENTATION         0x0112
#define TAG_SAMPLES_PER_PIXEL   0x0115
#define TAG_ROWS_PER_STRIP      0x0116
#define TAG_STRIP_BYTES_COUNT   0x0117
#define TAG_X_RESOLUTION        0x011A
#define TAG_Y_RESOLUTION        0x011B
#define TAG_PLANAR_CONFIG       0x011C
#define TAG_RESOLUTION_UNIT     0x0128
#define TAG_TRANSFER_FUNCTION   0x012D
#define TAG_SOFTWARE_USED       0x0131
#define TAG_DATE_TIME           0x0132
#define TAG_ARTIST              0x013B
#define TAG_WHITE_POINT         0x013E
#define TAG_PRIMAY_CHROMATICS   0x013F

#define TAG_JPEG_INTER_FORMAT   0x0201
#define TAG_JPEG_INTER_LENGTH   0x0202
#define TAG_YCbCr_COEFFICIENTS  0x0211
#define TAG_YCbCr_SUBSAMPLING   0x0212
#define TAG_YCbCr_POSITIONING   0x0213
#define TAG_REF_BLACK_WHITE     0x0214

#define TAG_COPYRIGHT           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define TAG_RESOLUTION_X_UNIT   0x5001
#define TAG_RESOLUTION_Y_UNIT   0x5002
#define TAG_RESOLUTION_X_LENGTH_UNIT   0x5003
#define TAG_RESOLUTION_Y_LENGTH_UNIT   0x5004
#define TAG_PRINT_FLAGS         0x5005
#define TAG_HALFTONE_LPI        0x5006
#define TAG_HALFTONE_LPI_UNIT   0x5007
#define TAG_HALFTONE_DEGREE     0x5008
#define TAG_HALFTONE_SHAPE      0x5009
#define TAG_HALFTONE_MISC       0x5010
#define TAG_HALFTONE_SCREEN     0x5011
#define TAG_JPEG_QUALITY        0x5012
#define TAG_GRID_SIZE           0x5013
#define TAG_THUMBNAIL_FORMAT    0x5014
#define TAG_THUMBNAIL_WIDTH     0x5015
#define TAG_THUMBNAIL_HEIGHT    0x5016
#define TAG_THUMBNAIL_COLORDEPTH    0x5017
#define TAG_THUMBNAIL_PLANES    0x5018
#define TAG_THUMBNAIL_RAWBYTES  0x5019
#define TAG_THUMBNAIL_SIZE      0x5020
#define TAG_THUMBNAIL_COMPRESSED_SIZE   0x5021

// EXIF specific tag

#define EXIF_TAG_EXPOSURE_TIME  0x829A
#define EXIF_TAG_F_NUMBER       0x829D

#define EXIF_TAG_EXPOSURE_PROG  0x8822
#define EXIF_TAG_SPECTRAL_SENSE 0x8824
#define EXIF_TAG_ISO_SPEED      0x8827
#define EXIF_TAG_OECF           0x8828

#define EXIF_TAG_VER            0x9000
#define EXIF_TAG_D_T_ORIG       0x9003 // Date & time of original
#define EXIF_TAG_D_T_DIGITIZED  0x9004 // Date & time of digital data generation

#define EXIF_TAG_COMP_CONFIG    0x9101
#define EXIF_TAG_COMP_BPP       0x9102

#define EXIF_TAG_SHUTTER_SPEED  0x9201
#define EXIF_TAG_APERATURE      0x9202
#define EXIF_TAG_BRIGHTNESS     0x9203
#define EXIF_TAG_EXPOSURE_BIAS  0x9204
#define EXIF_TAG_MAX_APERATURE  0x9205
#define EXIF_TAG_SUBJECT_DIST   0x9206
#define EXIF_TAG_METERING_MODE  0x9207
#define EXIF_TAG_LIGHT_SOURCE   0x9208
#define EXIF_TAG_FLASH          0x9209
#define EXIF_TAG_FOCAL_LENGTH   0x920A
#define EXIF_TAG_MAKER_NOTE     0x927C
#define EXIF_TAG_USER_COMMENT   0x9286
#define EXIF_TAG_D_T_SUBSEC     0x9290  // Date & Time subseconds
#define EXIF_TAG_D_T_ORIG_SS    0x9291  // Date & Time original subseconds
#define EXIF_TAG_D_T_DIG_SS     0x9292  // Date & TIme digitized subseconds

#define EXIF_TAG_FPX_VER        0xA000
#define EXIF_TAG_COLOR_SPACE    0xA001
#define EXIF_TAG_PIX_X_DIM      0xA002
#define EXIF_TAG_PIX_Y_DIM      0xA003
#define EXIF_TAG_RELATED_WAV    0xA004  // related sound file
#define EXIF_TAG_INTEROP        0xA005
#define EXIF_TAG_FLASH_ENERGY   0xA20B
#define EXIF_TAG_SPATIAL_FR     0xA20C  // Spatial Frequency Response
#define EXIF_TAG_FOCAL_X_RES    0xA20E  // Focal Plane X Resolution
#define EXIF_TAG_FOCAL_Y_RES    0xA20F  // Focal Plane Y Resolution
#define EXIF_TAG_FOCAL_RES_UNIT 0xA210  // Focal Plane Resolution Unit
#define EXIF_TAG_SUBJECT_LOC    0xA214
#define EXIF_TAG_EXPOSURE_INDEX 0xA215
#define EXIF_TAG_SENSING_METHOD 0xA217
#define EXIF_TAG_FILE_SOURCE    0xA300
#define EXIF_TAG_SCENE_TYPE     0xA301
#define EXIF_TAG_CFA_PATTERN    0xA302

#define GPS_TAG_VER             0x0000
#define GPS_TAG_LATTITUDE_REF   0x0001
#define GPS_TAG_LATTITUDE       0x0002
#define GPS_TAG_LONGITUDE_REF   0x0003
#define GPS_TAG_LONGITUDE       0x0004
#define GPS_TAG_ALTITUDE_REF    0x0005
#define GPS_TAG_ALTITUDE        0x0006
#define GPS_TAG_GPS_TIME        0x0007
#define GPS_TAG_GPS_SATELLITES  0x0008
#define GPS_TAG_GPS_STATUS      0x0009
#define GPS_TAG_GPS_MEASURE_MODE 0x00A
#define GPS_TAG_GPS_DOP         0x000B  // Measurement precision
#define GPS_TAG_SPEED_REF       0x000C
#define GPS_TAG_SPEED           0x000D
#define GPS_TAG_TRACK_REF       0x000E
#define GPS_TAG_TRACK           0x000F
#define GPS_TAG_IMG_DIR_REF     0x0010
#define GPS_TAG_IMG_DIR         0x0011
#define GPS_TAG_MAP_DATUM       0x0012
#define GPS_TAG_DEST_LAT_REF    0x0013
#define GPS_TAG_DEST_LAT        0x0014
#define GPS_TAG_DEST_LONG_REF   0x0015
#define GPS_TAG_DEST_LONG       0x0016
#define GPS_TAG_DEST_BEAR_REF   0x0017
#define GPS_TAG_DEST_BEAR       0x0018
#define GPS_TAG_DEST_DIST_REF   0x0019
#define GPS_TAG_DEST_DIST       0x001A

//
// Information about image pixel data
//

typedef struct tagBitmapData
{
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormatID PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
} BitmapData;

//
// Access modes used when calling IImage::LockBits
//

typedef enum ImageLockMode
{
    IMGLOCK_READ        = 0x0001,
    IMGLOCK_WRITE       = 0x0002,
    IMGLOCK_USERINPUTBUF= 0x0004
} ImageLockMode;

//
// Image flags
//

typedef enum ImageFlag
{
    IMGFLAG_NONE        = 0,

    // Low-word: shared with SINKFLAG_x

    IMGFLAG_SCALABLE            = 0x0001,
    IMGFLAG_HASALPHA            = 0x0002,
    IMGFLAG_HASTRANSLUCENT      = 0x0004,
    IMGFLAG_PARTIALLY_SCALABLE  = 0x0008,

    // Low-word: color space definition

    IMGFLAG_COLORSPACE_RGB      = 0x0010,
	IMGFLAG_COLORSPACE_CMYK     = 0x0020,
	IMGFLAG_COLORSPACE_GRAY     = 0x0040,
	IMGFLAG_COLORSPACE_YCBCR    = 0x0080,
	IMGFLAG_COLORSPACE_YCCK     = 0x0100,

    // Low-word: image size info

    IMGFLAG_HASREALDPI          = 0x1000,
    IMGFLAG_HASREALPIXELSIZE    = 0x2000,

    // High-word

    IMGFLAG_READONLY    = 0x00010000,
    IMGFLAG_CACHING     = 0x00020000
} ImageFlag;

//
// Decoder flags
//

typedef enum DecoderInitFlag
{
    DECODERINIT_NONE        = 0,

    // DECODERINIT_NOBLOCK indicates that the caller requires non-blocking
    // behavior.  This will be honored only by non-blocking decoders, that
    // is, decoders that don't have the IMGCODEC_BLOCKING_DECODE flag.

    DECODERINIT_NOBLOCK     = 0x0001,

    // Choose built-in decoders first before looking at any
    // installed plugin decoders.

    DECODERINIT_BUILTIN1ST  = 0x0002
} DecoderInitFlag;

//
// Flag to indicate how the memory buffer passed to
// IImagingFactory::CreateImageFromBuffer should be disposed.
//

typedef enum BufferDisposalFlag
{
    DISPOSAL_NONE,
    DISPOSAL_GLOBALFREE,
    DISPOSAL_COTASKMEMFREE,
    DISPOSAL_UNMAPVIEW
} BufferDisposalFlag;

//
// Quality hints used by resize/rotation operations
//

typedef enum InterpolationHint
{
    INTERP_DEFAULT,
    INTERP_NEAREST_NEIGHBOR,
    INTERP_BILINEAR,
    INTERP_AVERAGING,
    INTERP_BICUBIC
} InterpolationHint;

//
// Information about image codecs
//

enum
{
    IMGCODEC_ENCODER            = 0x00000001,
    IMGCODEC_DECODER            = 0x00000002,
    IMGCODEC_SUPPORT_BITMAP     = 0x00000004,
    IMGCODEC_SUPPORT_VECTOR     = 0x00000008,
    IMGCODEC_SEEKABLE_ENCODE    = 0x00000010,
    IMGCODEC_BLOCKING_DECODE    = 0x00000020,

    IMGCODEC_BUILTIN            = 0x00010000,
    IMGCODEC_SYSTEM             = 0x00020000,
    IMGCODEC_USER               = 0x00040000
};

typedef struct tagImageCodecInfo
{
    CLSID Clsid;
    GUID FormatID;
    const WCHAR* CodecName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
} ImageCodecInfo;

//
// Identifier for channel(s) in a pixel
//

typedef enum ChannelID
{
    ALPHA_CHANNEL       = 0x00000001,
    RED_CHANNEL         = 0x00000002,
    GREEN_CHANNEL       = 0x00000004,
    BLUE_CHANNEL        = 0x00000008,
    COLOR_CHANNELS      = RED_CHANNEL|GREEN_CHANNEL|BLUE_CHANNEL,
    ALL_CHANNELS        = COLOR_CHANNELS|ALPHA_CHANNEL,

    INTENSITY_CHANNEL   = 0x00010000
} ChannelID;

//
// Data structure for communicating to an image sink
//

enum
{
    // Low-word: shared with IMGFLAG_x

    SINKFLAG_SCALABLE   = IMGFLAG_SCALABLE,
    SINKFLAG_HASALPHA   = IMGFLAG_HASALPHA,
    SINKFLAG_PARTIALLY_SCALABLE = IMGFLAG_PARTIALLY_SCALABLE,

    // High-word

    SINKFLAG_TOPDOWN    = 0x00010000,
    SINKFLAG_BOTTOMUP   = 0x00020000,
    SINKFLAG_FULLWIDTH  = 0x00040000,
    SINKFLAG_MULTIPASS  = 0x00080000,
    SINKFLAG_COMPOSITE  = 0x00100000,
    SINKFLAG_WANTPROPS  = 0x00200000
};

typedef struct tagImageInfo
{
    GUID RawDataFormat;
    PixelFormatID PixelFormat;
    UINT Width, Height;
    UINT TileWidth, TileHeight;
    double Xdpi, Ydpi;
    UINT Flags;
} ImageInfo;

//
// Data structure for passing encoder paramaters
//

// NOTE:
//  Should this be in GdiplusTypes.h instead?  Leave imaging.h for stuff
//  shared between the internal stuff and the API?

typedef struct tagEncoderParam
{
    GUID    paramGuid;
    char*   Value;
} EncoderParam;

typedef struct tagEncoderParams
{
    UINT Count;
    EncoderParam Params[1];
} EncoderParams;

//
// Interface and class identifiers
//

interface IImagingFactory;
interface IImage;
interface IBitmapImage;
interface IImageDecoder;
interface IImageEncoder;
interface IImageSink;
interface IBasicBitmapOps;


//--------------------------------------------------------------------------
// Imaging utility factory object
//  This is a CoCreate-able object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
IImagingFactory : public IUnknown
{
public:

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        ) = 0;

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        ) = 0;
    
    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        ) = 0;

    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        ) = 0;

    // Create an image encoder object that can output data in the
    // specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        ) = 0;

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        ) = 0;

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        ) = 0;

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        ) = 0;

    // Create an in-memory IPropertySetStorage object

    STDMETHOD(CreateMemoryPropertyStore)(
        IN OPTIONAL HGLOBAL hmem,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Image interface
//  bitmap image
//  vector image
//  procedural image
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
IImage : public IUnknown
{
public:

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        ) = 0;

    // Get basic image info

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        ) = 0;

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        ) = 0;

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        ) = 0;

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Get/set the properties in the standard property set
    //  x-res
    //  y-res
    //  gamma
    //  ICC profile
    //  thumbnail
    //  tile width
    //  tile height
    //
    // Property-related methods

    STDMETHOD(GetProperties)(
        IN DWORD mode,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Bitmap interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
IBitmapImage : public IUnknown
{
public:

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        ) = 0;

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        ) = 0;

    // Access bitmap data in the specified pixel format
    //  must support at least PIXFMT_DONTCARE and
    //  the caninocal formats.

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        IN OUT BitmapData* lockedBitmapData
        ) = 0;

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        ) = 0;

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        ) = 0;

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;
};


//--------------------------------------------------------------------------
// Interface for performing basic operations on a bitmap image
//  This can be QI'ed from an IBitmapImage object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
IBasicBitmapOps : public IUnknown
{
public:

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        ) = 0;
    
    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        ) = 0;
    
    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
IImageDecoder : public IUnknown
{
public:

    // Initialize the image decoder object

    STDMETHOD(InitDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags
        ) = 0;

    // Clean up the image decoder object

    STDMETHOD(TerminateDecoder)() = 0;

    // Start decoding the current frame

    STDMETHOD(BeginDecode)(
        IN IImageSink* sink,
        IN OPTIONAL IPropertySetStorage* newPropSet
        ) = 0;

    // Continue decoding

    STDMETHOD(Decode)() = 0;

    // Stop decoding the current frame

    STDMETHOD(EndDecode)(
        IN HRESULT statusCode
        ) = 0;

    // Query multi-frame dimensions

    STDMETHOD(QueryFrameDimensions)(
        OUT UINT* count,
        OUT GUID** dimensionIDs
        ) = 0;

    // Get number of frames for the specified dimension

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        ) = 0;

    // Select currently active frame

    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        ) = 0;

    // Get basic information about the image

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Get image thumbnail

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Property/metadata related methods

    STDMETHOD(GetProperties)(
        OUT IPropertySetStorage** propSet
        ) = 0;

    // Query decoder parameters

    STDMETHOD(QueryDecoderParam)(
        IN GUID		Guid
        ) = 0;

    // Set decoder parameters

    STDMETHOD(SetDecoderParam)(
        IN GUID		Guid,
		IN UINT		Length,
		IN PVOID	Value
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decode sink interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
IImageSink : public IUnknown
{
public:

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        ) = 0;

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        ) = 0;

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        ) = 0;

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        ) = 0;

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        ) = 0;

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        ) = 0;

    // Methods for passing metadata / properties

    STDMETHOD(PushProperties)(
        IN IPropertySetStorage* propSet
        ) = 0;
    
    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        ) = 0;

    STDMETHOD(PushRawInfo)(
    IN OUT void* info
    ) = 0;

};


//--------------------------------------------------------------------------
// Image encoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
IImageEncoder : public IUnknown
{
public:

    // Initialize the image encoder object

    STDMETHOD(InitEncoder)(
        IN IStream* stream
        ) = 0;
    
    // Clean up the image encoder object

    STDMETHOD(TerminateEncoder)() = 0;

    // Get an IImageSink interface for encoding the next frame

    STDMETHOD(GetEncodeSink)(
        OUT IImageSink** sink
        ) = 0;
    
    // Set active frame dimension

    STDMETHOD(SetFrameDimension)(
        IN const GUID* dimensionID
        ) = 0;
    
    // Query encoder parameters

    STDMETHOD(QueryEncoderParam)(
        OUT EncoderParams** Params
    ) = 0;

    // Set encoder parameters

    STDMETHOD(SetEncoderParam)(
        IN EncoderParams* Param
        ) = 0;
};


//--------------------------------------------------------------------------
// Imaging library error codes
//
// !!! TODO
//  How does one pick a facility code?
//
// Standard error code used:
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_NOTIMPL
//  E_ACCESSDENIED
//  E_PENDING
//--------------------------------------------------------------------------

#define FACILITY_IMAGING        0x87b
#define MAKE_IMGERR(n)          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_IMAGING, n)
#define IMGERR_OBJECTBUSY       MAKE_IMGERR(1)
#define IMGERR_NOPALETTE        MAKE_IMGERR(2)
#define IMGERR_BADLOCK          MAKE_IMGERR(3)
#define IMGERR_BADUNLOCK        MAKE_IMGERR(4)
#define IMGERR_NOCONVERSION     MAKE_IMGERR(5)
#define IMGERR_CODECNOTFOUND    MAKE_IMGERR(6)
#define IMGERR_NOFRAME          MAKE_IMGERR(7)
#define IMGERR_ABORT            MAKE_IMGERR(8)

#endif // !_IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\dvdrect.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: DVDRect.cpp                                                     */
/* Description: Implementation of CDVDRect                               */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSWebDVD.h"
#include "DVDRect.h"
#include <errors.h>


/////////////////////////////////////////////////////////////////////////////
// CDVDRect

/*************************************************************************/
/* Function: get_x                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_x(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_x;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_x */

/*************************************************************************/
/* Function: put_x                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_x(long newVal){

    HRESULT hr = S_OK;

    try {
 
        m_x = newVal;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_x */

/*************************************************************************/
/* Function: get_y                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_y(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_y;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_y */

/*************************************************************************/
/* Function: put_y                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_y(long newVal){

    HRESULT hr = S_OK;

    try {
 
        m_y = newVal;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_y */

/*************************************************************************/
/* Function: get_Width                                                   */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_Width(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_lWidth;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_Width */

/*************************************************************************/
/* Function: put_Width                                                   */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_Width(long newVal){

   HRESULT hr = S_OK;

    try {

        if(newVal <= 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        m_lWidth = newVal;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_Width */

/*************************************************************************/
/* Function: get_Height                                                  */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_Height(long *pVal){	

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_lHeight;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_Height */

/*************************************************************************/
/* Function: put_Height                                                  */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_Height(long newVal){

    HRESULT hr = S_OK;

    try {

        if(newVal <= 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        m_lHeight = newVal;	
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_Height */

/*************************************************************************/
/* Function: GetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/* This control is safe since it does not write to HD.                   */
/*************************************************************************/
STDMETHODIMP CDVDRect::GetInterfaceSafetyOptions(REFIID /*riid*/, 
                                               DWORD* pdwSupportedOptions, 
                                               DWORD* pdwEnabledOptions){

    HRESULT hr = S_OK;
    if(!pdwSupportedOptions || !pdwEnabledOptions){
        return E_POINTER;
    }
	*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;

	*pdwEnabledOptions = *pdwSupportedOptions;

	return(hr);
}/* end of function GetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: SetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/*************************************************************************/
STDMETHODIMP CDVDRect::SetInterfaceSafetyOptions(REFIID /*riid*/, 
                                               DWORD /* dwSupportedOptions */, 
                                               DWORD /* pdwEnabledOptions */){

	return (S_OK);
}/* end of function SetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CDVDRect::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {
        &IID_IDVDRect,		
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Description, so we can suppor IError Info.    */
/*************************************************************************/
HRESULT CDVDRect::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
        
            // Ensure that the string is Null Terminated
            TCHAR strError[MAX_ERROR_TEXT_LEN+1];
            ZeroMemory(strError, MAX_ERROR_TEXT_LEN+1);

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                    ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                    ATLASSERT(FALSE);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************************/
/* End of file: DVDRect.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\monitor.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: msdvd.cpp                                                       */
/* Description: Implementation of CMSWebDVD.                             */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSDVD.h"
#include "ddrawobj.h"

#define COMPILE_MULTIMON_STUBS
#define HMONITOR_DECLARED // to cover up DDraw Monitor redefinition
#include <multimon.h>

extern GUID IID_IDDrawNonExclModeVideo = {
            0xec70205c,0x45a3,0x4400,{0xa3,0x65,0xc4,0x47,0x65,0x78,0x45,0xc7}};


/*****************************Private*Routine******************************\
* UpdateCurrentMonitor
*
* Updates the "m_lpCurMonitor" global to match the specified DDraw GUID
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT CMSWebDVD::UpdateCurrentMonitor(
    const AMDDRAWGUID* lpguid
    )
{
    if (lpguid->lpGUID)
    {
        for (AMDDRAWMONITORINFO* lpCurMonitor = &m_lpInfo[0];
             lpCurMonitor < &m_lpInfo[m_dwNumDevices]; lpCurMonitor++)
        {
            if (lpCurMonitor->guid.lpGUID &&
               *lpCurMonitor->guid.lpGUID == *lpguid->lpGUID)
            {
                m_lpCurMonitor = lpCurMonitor;
                return S_OK;
            }
        }
    }
    else
    {
        for (AMDDRAWMONITORINFO* lpCurMonitor = &m_lpInfo[0];
             lpCurMonitor < &m_lpInfo[m_dwNumDevices]; lpCurMonitor++)
        {
            if (lpguid->lpGUID == lpCurMonitor->guid.lpGUID)
            {
                m_lpCurMonitor = lpCurMonitor;
                return S_OK;
            }
        }
    }

    return E_FAIL;
}

/******************************Public*Routine******************************\
* DisplayChange
*
*
*
* History:
* Sat 11/27/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMSWebDVD::DisplayChange(
    HMONITOR hMon,
    const AMDDRAWGUID* lpguid
    )
{
    HRESULT hr = E_FAIL;

    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    CDDrawDVD* pDDrawObj = new CDDrawDVD(this);

    if(NULL == pDDrawObj){

        return (E_OUTOFMEMORY);
    }/* end if statement */

    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        delete pDDrawObj;
        return(hr);
    }/* end of if statement */

    hr = pDDrawObj->SetupDDraw(lpguid, hwnd);

    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    IDDrawNonExclModeVideo* pDDXMV;
    hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    LPDIRECTDRAW pDDObj = pDDrawObj->GetDDrawObj();
    LPDIRECTDRAWSURFACE pDDPrimary = pDDrawObj->GetDDrawSurf();

    hr = pDDXMV->SetCallbackInterface(NULL, 0) ;
    if (FAILED(hr)){

        pDDXMV->Release() ;  // release before returning
        return hr;
    }/* end of if statement */

    hr = pDDXMV->DisplayModeChanged(hMon, pDDObj, pDDPrimary);

    if (SUCCEEDED(hr)) {

        delete m_pDDrawDVD;
        m_pDDrawDVD = pDDrawObj;
        hr = UpdateCurrentMonitor(lpguid);
    }
    else {
        delete pDDrawObj;
    }

    hr = pDDXMV->SetCallbackInterface(m_pDDrawDVD->GetCallbackInterface(), 0) ;

    if (SUCCEEDED(hr))
    {
        hr = SetColorKey(DEFAULT_COLOR_KEY);
    }/* end of it statement */


    pDDXMV->Release();
    return hr;
}

/******************************Public*Routine******************************\
* ChangeMonitor
*
* Tells the OVMixer that we want to change to another monitor.
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMSWebDVD::ChangeMonitor(
    HMONITOR hMon,
    const AMDDRAWGUID* lpguid
    )
{

    HRESULT hr = E_FAIL;

    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    CDDrawDVD* pDDrawObj = new CDDrawDVD(this);

    if(NULL == pDDrawObj){

        return (E_OUTOFMEMORY);
    }/* end if statement */

    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        delete pDDrawObj;
        return(hr);
    }/* end of if statement */

    hr = pDDrawObj->SetupDDraw(lpguid, hwnd);

    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    IDDrawNonExclModeVideo* pDDXMV;
    hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    LPDIRECTDRAW pDDObj = pDDrawObj->GetDDrawObj();
    LPDIRECTDRAWSURFACE pDDPrimary = pDDrawObj->GetDDrawSurf();

    hr = pDDXMV->SetCallbackInterface(NULL, 0) ;
    if (FAILED(hr)){

        pDDXMV->Release() ;  // release before returning
        return hr;
    }/* end of if statement */

    hr = pDDXMV->ChangeMonitor(hMon, pDDObj, pDDPrimary);

    if (SUCCEEDED(hr)) {

        delete m_pDDrawDVD;
        m_pDDrawDVD = pDDrawObj;
        hr = UpdateCurrentMonitor(lpguid);
    }
    else {
        delete pDDrawObj;
    }

    hr = pDDXMV->SetCallbackInterface(m_pDDrawDVD->GetCallbackInterface(), 0) ;

    if (SUCCEEDED(hr))
    {
        hr = SetColorKey(DEFAULT_COLOR_KEY);
    }/* end of it statement */

    pDDXMV->Release();
    return hr;
}


/******************************Public*Routine******************************\
* RestoreSurfaces
*
* Tells the OVMixer to restore its internal DDraw surfaces
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMSWebDVD::RestoreSurfaces()
{
    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    IDDrawNonExclModeVideo* pDDXMV;
    HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pDDXMV->RestoreSurfaces();
    pDDXMV->Release();

    return hr;
}

/*************************************************************************/
/* Function: RefreshDDrawGuids                                           */
/*************************************************************************/
HRESULT CMSWebDVD::RefreshDDrawGuids()
{
    IDDrawNonExclModeVideo* pDDXMV;
    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        return hr;
    }

    GUID IID_IAMSpecifyDDrawConnectionDevice = {
            0xc5265dba,0x3de3,0x4919,{0x94,0x0b,0x5a,0xc6,0x61,0xc8,0x2e,0xf4}};

    IAMSpecifyDDrawConnectionDevice* pSDDC;
    hr = pDDXMV->QueryInterface(IID_IAMSpecifyDDrawConnectionDevice, (LPVOID *)&pSDDC);
    if (FAILED(hr))
    {
        pDDXMV->Release();
        return hr;
    }

    DWORD dwNumDevices;
    AMDDRAWMONITORINFO* lpInfo;

    hr = pSDDC->GetDDrawGUIDs(&dwNumDevices, &lpInfo);
    if (SUCCEEDED(hr)) {
        CoTaskMemFree(m_lpInfo);
        m_lpCurMonitor = NULL;
        m_lpInfo = lpInfo;
        m_dwNumDevices = dwNumDevices;
    }

    pSDDC->Release();
    pDDXMV->Release();

    return hr;
}/* end of function RefreshDDrawGuids */

/*****************************Private*Routine******************************\
* IsWindowOnWrongMonitor
*
* Use the same algorithm that the OVMixer uses to determine if we are on
* the wrong monitor or not.
*
* If we are on the wrong monitor *lphMon contains the monitor handle of the
* new monitor to use.
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
bool CMSWebDVD::IsWindowOnWrongMonitor(
    HMONITOR* lphMon)
{

    if (!m_lpCurMonitor)
    {
        return false;
    }

    HWND hwnd;

    HRESULT hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(false);
    }/* end of if statement */

    RECT rc;

    hr = GetClientRectInScreen(&rc);

    if(FAILED(hr)){

        return(false);
    }/* end of if statement */

    *lphMon = m_lpCurMonitor->hMon;
    if (GetSystemMetrics(SM_CMONITORS) > 1 && !::IsIconic(hwnd))
    {
        LPRECT lprcMonitor = &m_lpCurMonitor->rcMonitor;

        if (rc.left < lprcMonitor->left || rc.right > lprcMonitor->right ||
            rc.top < lprcMonitor->top   || rc.bottom > lprcMonitor->bottom)
        {
            HMONITOR hMon = MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST);
            if (*lphMon != hMon)
            {
                *lphMon = hMon;
                return true;
            }
        }
    }

    return false;
}

/*****************************Private*Routine******************************\
* DDrawGuidFromHMonitor
*
* Return the DDraw guid from the specified hMonitor handle.
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT CMSWebDVD::DDrawGuidFromHMonitor(
    HMONITOR hMon,
    AMDDRAWGUID* lpGUID
    )
{
    AMDDRAWMONITORINFO* lpCurMonitor = &m_lpInfo[0];

#if 1
    if (m_dwNumDevices == 1) {
        *lpGUID = lpCurMonitor->guid;
        return S_OK;
    }
#endif

    for (; lpCurMonitor < &m_lpInfo[m_dwNumDevices]; lpCurMonitor++)
    {
        if (lpCurMonitor->hMon == hMon) {
            *lpGUID = lpCurMonitor->guid;
            return S_OK;
        }
    }

    return E_FAIL;
}

struct MONITORDATA {
    HMONITOR hMonPB;
    BOOL fMsgShouldBeDrawn;
};


/*****************************Private*Routine******************************\
* MonitorEnumProc
*
* On Multi-Monitor systems make sure that the part of the window that is not
* on the primary monitor is black.
*
* History:
* Thu 06/03/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL CALLBACK
MonitorEnumProc(
  HMONITOR hMonitor,        // handle to display monitor
  HDC hdc,                  // handle to monitor-appropriate device context
  LPRECT lprcMonitor,       // pointer to monitor intersection rectangle
  LPARAM dwData             // data passed from EnumDisplayMonitors
  )
{
    MONITORDATA* lpmd = (MONITORDATA*)dwData;
    //COLORREF clrOld = GetBkColor(hdc);

    if (lpmd->hMonPB != hMonitor)
    {
        //SetBkColor(hdc, RGB(0,0,0));
        lpmd->fMsgShouldBeDrawn = TRUE;
    }
    else
    {   // put your own color key here
        ;//SetBkColor(hdc, RGB(255,0,255));
    }

    //ExtTextOut(hdc, 0, 0, ETO_OPAQUE, lprcMonitor, NULL, 0, NULL);
    //SetBkColor(hdc, clrOld);

    return TRUE;
}

/*************************************************************************/
/* Function: OnDispChange                                                */
/*************************************************************************/
LRESULT CMSWebDVD::OnDispChange(UINT /* uMsg */, WPARAM  wParam,
                            LPARAM lParam, BOOL& bHandled){

    if(::IsWindow(m_hWnd)){

        bHandled = FALSE;
        return(0);
        //do not handle this in windowed mode
    }/* end of if statement */

    RECT rc;

    HRESULT hr = GetClientRectInScreen(&rc);

    if(FAILED(hr)){

        return(-1);
    }/* end of if statement */

    HMONITOR hMon = ::MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST);

    AMDDRAWGUID guid;
    hr = RefreshDDrawGuids();

    if(FAILED(hr)){

        return -1;
    }/* end of if statement */

    hr = DDrawGuidFromHMonitor(hMon, &guid);

    if(FAILED(hr)){

        return -1;
    }/* end of if statement */

    hr = DisplayChange(hMon, &guid);

    if(FAILED(hr)){

        return -1;
    }/* end of if statement */

    return 0;
}/* end of function OnDispChange */

/*************************************************************************/
/* Function: HandleMultiMonMove                                          */
/* Description: Moves the playback to another monitor when needed.       */
/*************************************************************************/
HRESULT CMSWebDVD::HandleMultiMonMove(){

    HRESULT hr = S_FALSE;

    if (::GetSystemMetrics(SM_CMONITORS) > 1){

        HMONITOR hMon;
        if (IsWindowOnWrongMonitor(&hMon)) {

            AMDDRAWGUID guid;
            hr = DDrawGuidFromHMonitor(hMon, &guid);

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            hr = ChangeMonitor(hMon, &guid);

            if(FAILED(hr)){

                m_MonitorWarn = TRUE;
                InvalidateRgn();
                return(hr);
            }/* end of if statement */
        }/* end of if statement */

        //
        // We always have to invalidate the windows client area, otherwise
        // we handle the Multi-Mon case very badly.
        //

        //::InvalidateRect(hWnd, NULL, FALSE);
        InvalidateRgn();
        return(hr);
    }/* end of if statement */

    return(hr);
}/* end of function HandleMultiMonMove */

/*************************************************************************/
/* Function: HandleMultiMonPaint                                         */
/*************************************************************************/
HRESULT CMSWebDVD::HandleMultiMonPaint(HDC hDC){

    if (::GetSystemMetrics(SM_CMONITORS) > 1){

        MONITORDATA md;
        md.hMonPB = m_lpCurMonitor ? m_lpCurMonitor->hMon : (HMONITOR)NULL;
        md.fMsgShouldBeDrawn = FALSE;

        RECT rc;

        HRESULT hr = GetClientRectInScreen(&rc);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */

        //EnumDisplayMonitors(hDC, NULL, MonitorEnumProc, (LPARAM)&md);
        EnumDisplayMonitors(NULL, &rc, MonitorEnumProc, (LPARAM)&md);

        if (m_MonitorWarn && md.fMsgShouldBeDrawn){


            TCHAR strBuffer[MAX_PATH];
            if(!::LoadString(_Module.m_hInstResource, IDS_MOVE_TO_OTHER_MON, strBuffer, MAX_PATH)){

                return(E_UNEXPECTED);
            }/* end of if statement */

            SetBkColor(hDC, RGB(0,0,0));
            SetTextColor(hDC, RGB(255,255,0));

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            DrawText(hDC, strBuffer, -1, &m_rcPos, DT_CENTER | DT_WORDBREAK);
        }/* end of if statement */

        return(S_OK);
    }/* end of if statement */

    return(S_FALSE);
}/* end of function HandleMultiMonPaint */

/*************************************************************************/
/* Function: InvalidateRgn                                               */
/* Description: Invalidates the whole rect in case we need to repaint it.*/
/*************************************************************************/
HRESULT CMSWebDVD::InvalidateRgn(bool fErase){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        m_spInPlaceSite->InvalidateRgn(NULL ,fErase ? TRUE: FALSE);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::InvalidateRgn(m_hWnd, NULL, fErase ? TRUE: FALSE); // see if we can get by by not erasing..
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function InvalidateRgn */

/*************************************************************************/
/* End of file: monitor.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\iso3166.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __ISO3166_H
#define __ISO3166_H

char DVDToUpper(char x)
{
    if('a' <= x && x <= 'z') {
        return x - ('a' - 'A');
    } else {
        return x;
    }
}

struct ISO3166
{
    const char *Code;
    
    // access the table as ISO3166::GetCountry()
    static const ISO3166& GetCountry( unsigned i );
    static unsigned	GetNumCountries();

    // creates an ISO code from a two letter string
    static WORD	PackCode( const char string[2] )
    {
        return DVDToUpper(string[0])<<8 | DVDToUpper(string[1]);
    }
    
};

// ISO3166 country code table
static const ISO3166 g_Table[] =
{ // current as of Dec 22, 2000
    {/* "Afghanistan", */       "AF"},
    {/* "Albania", */           "AL"},
    {/* "Algeria", */           "DZ"},
    {/* "American Samoa", */    "AS"},
    {/* "Andorra", */           "AD"},
    {/* "Angola", */            "AO"},
    {/* "Anguilla", */          "AI"},
    {/* "Antarctica", */        "AQ"},
    {/* "Antigua and Barbuda", */  "AG"},
    {/* "Argentina", */         "AR"},
    {/* "Armenia", */           "AM"},
    {/* "Aruba", */             "AW"},
    {/* "Australia", */         "AU"},
    {/* "Austria", */           "AT"},
    {/* "Azerbaijan", */        "AZ"},
    {/* "Bahamas", */           "BS"},
    {/* "Bahrain", */           "BH"},
    {/* "Bangladesh", */        "BD"},
    {/* "Barbados", */          "BB"},
    {/* "Belarus", */           "BY"},
    {/* "Belgium", */           "BE"},
    {/* "Belize", */            "BZ"},
    {/* "Benin", */             "BJ"},
    {/* "Bermuda", */           "BM"},
    {/* "Bhutan", */            "BT"},
    {/* "Bolivia", */           "BO"},
    {/* "Bosnia and Herzegovina", */        "BA"},
    {/* "Botswana", */          "BW"},
    {/* "Bouvet Island", */     "BV"},
    {/* "Brazil", */            "BR"},
    {/* "British Indian Ocean Territory", */  "IO"},
    {/* "Brunei Darussalam", */ "BN"},
    {/* "Bulgaria", */          "BG"},
    {/* "Burkina Faso", */      "BF"},
    {/* "Burundi", */           "BI"},
    {/* "Cambodia", */          "KH"},
    {/* "Cameroon", */          "CM"},
    {/* "Canada", */            "CA"},
    {/* "Cape Verde", */        "CV"},
    {/* "Cayman Islands", */    "KY"},
    {/* "Central African Republic", */      "CF"},
    {/* "Chad", */              "TD"},
    {/* "Channel Islands", */	"GB"},
    {/* "Chile", */             "CL"},
    {/* "China", */             "CN"},
    {/* "Christmas Island", */  "CX"},
    {/* "Cocos (Keeling) Islands", */       "CC"},
    {/* "Colombia", */          "CO"},
    {/* "Comoros", */           "KM"},
    {/* "Congo", */             "CG"},
    {/* "Cook Islands", */      "CK"},
    {/* "Costa Rica", */        "CR"},
    {/* "Cte d'Ivoire", */     "CI"},
    {/* "Croatia (local name: Hrvatska)", */  "HR"},
    {/* "Cuba", */              "CU"},
    {/* "Cyprus", */            "CY"},
    {/* "Czech Republic", */    "CZ"},
    {/* "Denmark", */           "DK"},
    {/* "Djibouti", */          "DJ"},
    {/* "Dominica", */          "DM"},
    {/* "Dominican Republic", */  "DO"},
    {/* "East Timor", */        "TP"},
    {/* "Ecuador", */           "EC"},
    {/* "Egypt", */             "EG"},
    {/* "El Salvador", */       "SV"},
    {/* "Equatorial Guinea", */  "GQ"},
    {/* "Eritrea", */           "ER"},
    {/* "Estonia", */           "EE"},
    {/* "Ethiopia", */          "ET"},
    {/* "Falkland Islands (Malvinas)", */   "FK"},
    {/* "Faroe Islands", */     "FO"},
    {/* "Fiji", */              "FJ"},
    {/* "Finland", */           "FI"},
    {/* "France", */            "FR"},
    {/* "France, Metropolitan", */  "FX"},
    {/* "French Guiana", */     "GF"},
    {/* "French Polynesia", */  "PF"},
    {/* "French Southern and Antarctic Lands", */	"TF"},
    {/* "Gabon", */             "GA"},
    {/* "Gambia", */            "GM"},
    {/* "Georgia", */           "GE"},
    {/* "Germany", */           "DE"},
    {/* "Ghana", */             "GH"},
    {/* "Gibraltar", */         "GI"},
    {/* "Greece", */            "GR"},
    {/* "Greenland", */         "GL"},
    {/* "Grenada", */           "GD"},
    {/* "Guadeloupe", */        "GP"},
    {/* "Guam", */              "GU"},
    {/* "Guatemala", */         "GT"},
    {/* "Guinea", */            "GN"},
    {/* "Guinea-Bissau", */     "GW"},
    {/* "Guyana", */            "GY"},
    {/* "Haiti", */             "HT"},
    {/* "Heard and Mc Donald Islands", */   "HM"},
    {/* "Holy See (Vatican City State)", */ "VA"},
    {/* "Honduras", */          "HN"},
    {/* "Hong Kong SAR", */         "HK"},
    {/* "Hungary", */           "HU"},
    {/* "Iceland", */           "IS"},
    {/* "India", */             "IN"},
    {/* "Indonesia", */         "ID"},
    {/* "Iran (Islamic Republic Of)", */    "IR"},
    {/* "Iraq", */              "IQ"},
    {/* "Ireland", */           "IE"},
    {/* "Israel", */            "IL"},
    {/* "Italy", */             "IT"},
    {/* "Jamaica", */           "JM"},
    {/* "Japan", */             "JP"},
    {/* "Jordan", */            "JO"},
    {/* "Kazakhstan", */        "KZ"},
    {/* "Kenya", */             "KE"},
    {/* "Kiribati", */          "KI"},
    {/* "Korea, Democratic People's Republic Of", */  "KP"},
    {/* "Korea, Republic Of", */  "KR"},
    {/* "Kuwait", */            "KW"},
    {/* "Kyrgyzstan", */        "KG"},
    {/* "Lao People's Democratic Republic", */  "LA"},
    {/* "Latvia", */            "LV"},
    {/* "Lebanon", */           "LB"},
    {/* "Lesotho", */           "LS"},
    {/* "Liberia", */           "LR"},
    {/* "Libyan Arab Jamahiriya", */        "LY"},
    {/* "Liechtenstein", */     "LI"},
    {/* "Lithuania", */         "LT"},
    {/* "Luxembourg", */        "LU"},
    {/* "Macau SAR", */             "MO"},
    {/* "Macedonia, The Former Yugoslav Republic Of", */  "MK"},
    {/* "Madagascar", */        "MG"},
    {/* "Malawi", */            "MW"},
    {/* "Malaysia", */          "MY"},
    {/* "Maldives", */          "MV"},
    {/* "Mali", */              "ML"},
    {/* "Malta", */             "MT"},
    {/* "Man, Isle of",*/   	"GB"},
    {/* "Marshall Islands", */  "MH"},
    {/* "Martinique", */        "MQ"},
    {/* "Mauritania", */        "MR"},
    {/* "Mauritius", */         "MU"},
    {/* "Mayotte", */           "YT"},
    {/* "Mexico", */            "MX"},
    {/* "Micronesia, Federated States Of", */  "FM"},
    {/* "Moldova, Republic Of", */          "MD"},
    {/* "Monaco", */            "MC"},
    {/* "Mongolia", */          "MN"},
    {/* "Montserrat", */        "MS"},
    {/* "Morocco", */           "MA"},
    {/* "Mozambique", */        "MZ"},
    {/* "Myanmar", */           "MM"},
    {/* "Namibia", */           "NA"},
    {/* "Nauru", */             "NR"},
    {/* "Nepal", */             "NP"},
    {/* "Netherlands", */       "NL"},
    {/* "Netherlands ANTILLES", */          "AN"},
    {/* "New Caledonia", */     "NC"},
    {/* "New Zealand", */       "NZ"},
    {/* "Nicaragua", */         "NI"},
    {/* "Niger", */             "NE"},
    {/* "Nigeria", */           "NG"},
    {/* "Niue", */              "NU"},
    {/* "Norfolk Island", */    "NF"},
    {/* "Northern Mariana Islands", */      "MP"},
    {/* "Norway", */            "NO"},
    {/* "Oman", */              "OM"},
    {/* "Pakistan", */          "PK"},
    {/* "Palau", */             "PW"},
    {/* "Panama", */            "PA"},
    {/* "Papua New Guinea", */  "PG"},
    {/* "Paraguay", */          "PY"},
    {/* "Peru", */              "PE"},
    {/* "Philippines", */       "PH"},
    {/* "Pitcairn Islands", */  "PN"},
    {/* "Poland", */            "PL"},
    {/* "Portugal", */          "PT"},
    {/* "Puerto Rico", */       "PR"},
    {/* "Qatar", */             "QA"},
    {/* "Reunion", */           "RE"},
    {/* "Romania", */           "RO"},
    {/* "Russian Federation", */            "RU"},
    {/* "Rwanda", */            "RW"},
    {/* "Saint Kitts and Nevis", */         "KN"},
    {/* "Saint Lucia", */       "LC"},
    {/* "Saint Vincent and The Grenadines", */  "VC"},
    {/* "Samoa", */             "WS"},
    {/* "San Marino", */        "SM"},
    {/* "So Tom and Prncipe ", */         "ST"},
    {/* "Saudi Arabia", */      "SA"},
    {/* "Senegal", */           "SN"},
    {/* "Seychelles", */        "SC"},
    {/* "Sierra Leone", */      "SL"},
    {/* "Singapore", */         "SG"},
    {/* "Slovakia (Slovak Republic)", */    "SK"},
    {/* "Slovenia", */          "SI"},
    {/* "Solomon Islands", */   "SB"},
    {/* "Somalia", */           "SO"},
    {/* "South Africa", */      "ZA"},
    {/* "South Georgia and The South Sandwich Islands", */  "GS"},
    {/* "Spain", */             "ES"},
    {/* "Sri Lanka", */         "LK"},
    {/* "St. Helena", */        "SH"},
    {/* "St. Pierre and Miquelon", */        "PM"},
    {/* "Sudan", */             "SD"},
    {/* "Suriname", */          "SR"},
    {/* "Svalbard and Jan Mayen Islands", */ "SJ"},
    {/* "Swaziland", */         "SZ"},
    {/* "Sweden", */            "SE"},
    {/* "Switzerland", */       "CH"},
    {/* "Syrian Arab Republic", */  "SY"},
    {/* "Taiwan", */            "TW"},
    {/* "Tajikistan", */        "TJ"},
    {/* "Tanzania, United Republic Of", */  "TZ"},
    {/* "Thailand", */          "TH"},
    {/* "Togo", */              "TG"},
    {/* "Tokelau", */           "TK"},
    {/* "Tonga", */             "TO"},
    {/* "Trinidad and Tobago", */  "TT"},
    {/* "Tunisia", */           "TN"},
    {/* "Turkey", */            "TR"},
    {/* "Turkmenistan", */      "TM"},
    {/* "Turks and Caicos Islands", */      "TC"},
    {/* "Tuvalu", */            "TV"},
    {/* "Uganda", */            "UG"},
    {/* "Ukraine", */           "UA"},
    {/* "United Arab Emirates", */  "AE"},
    {/* "United Kingdom", */    "GB"},
    {/* "United States", */     "US"},
    {/* "U.S. Minor Outlying Islands", */  "UM"},
    {/* "Uruguay", */           "UY"},
    {/* "Uzbekistan", */        "UZ"},
    {/* "Vanuatu", */           "VU"},
    {/* "Venezuela", */         "VE"},
    {/* "Viet Nam", */          "VN"},
    {/* "Virgin Islands (British)", */      "VG"},
    {/* "Virgin Islands (U.S.)", */         "VI"},
    {/* "Wallis and Futuna Islands", */     "WF"},
    {/* "Yemen", */             "YE"},
    {/* "Yugoslavia", */        "YU"},
    {/* "Congo (DRC)", */             "ZR"},
    {/* "Zambia", */            "ZM"},
    {/* "Zimbabwe", */          "ZW"}
};

static const unsigned g_uTableSize = sizeof( g_Table )/ sizeof( g_Table[0] );

const ISO3166& ISO3166::GetCountry( unsigned i )
{
    return g_Table[i];
}

unsigned ISO3166::GetNumCountries()
{
    return g_uTableSize;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\mediahndlr.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <stdafx.h>

#include <winuser.h>
#include <windows.h>

#include "mswebdvd.h"
#include "msdvd.h"
#include "MediaHndlr.h"
#include <dbt.h>    // device broadcast structure

//
//  Ejection event handler
//

CMediaHandler::CMediaHandler()
: m_driveMask( 0 )
, m_ejected( false )
, m_inserted( false )
{
    m_pDVD = NULL;
}

CMediaHandler::~CMediaHandler()
{
}

void CMediaHandler::ClearFlags()
{
    m_ejected = false;
    m_inserted = false;
}

bool CMediaHandler::SetDrive( TCHAR tcDriveLetter )
{
    if( TEXT('A') <= tcDriveLetter && tcDriveLetter <= TEXT('Z') ) {
        m_driveMask = 1<< (tcDriveLetter-TEXT('A'));
    } else if( TEXT('a') <= tcDriveLetter && tcDriveLetter <= TEXT('z')) {
        m_driveMask = 1<< (tcDriveLetter-TEXT('a'));
    } else {
        return false;
    }
    ClearFlags();
    return true;
}

LRESULT CMediaHandler::WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    if (m_pDVD == NULL)
        return ParentClass::WndProc( uMsg, wParam, lParam);

    switch (uMsg) {
        case WM_DEVICECHANGE:
        {
            switch( wParam ) {
            case DBT_DEVICEREMOVECOMPLETE:
            case DBT_DEVICEARRIVAL:
            case DBT_DEVICEQUERYREMOVE:
            {
                PDEV_BROADCAST_HDR pdbch = (PDEV_BROADCAST_HDR) lParam;
                if(pdbch->dbch_devicetype == DBT_DEVTYP_VOLUME ) {
                    PDEV_BROADCAST_VOLUME pdbcv = (PDEV_BROADCAST_VOLUME) pdbch;
                    if (pdbcv->dbcv_flags == DBTF_MEDIA || wParam == DBT_DEVICEQUERYREMOVE) 
                    {
                        // pdbcv->dbcv_unitmask identifies which logical drive
                        switch( wParam ) {
                            case DBT_DEVICEARRIVAL:
                                if( pdbcv->dbcv_unitmask & m_driveMask ) {
                                    // send change event
                                    if( !m_inserted ) {
                                        CComVariant var = 0;
                                        m_pDVD->Fire_DVDNotify(EC_DVD_DISC_INSERTED, var, var);
                                    }
                                    m_inserted = true;
                                    m_ejected = false;
                                    m_pDVD->SetDiscEjected(false);
                                }
                                // return TRUE .. see the MSDN docs for DBT_DEVICEQUERYREMOVE
                                return TRUE;

                            case DBT_DEVICEQUERYREMOVE:
                                if( pdbcv->dbcv_unitmask & m_driveMask ) {
                                    if( !m_ejected ) {
                                        CComVariant var = 0;
                                        m_pDVD->Fire_DVDNotify(EC_DVD_DISC_EJECTED, var, var);
                                    }
                                    m_ejected = true;
                                    m_inserted = false;
                                    m_pDVD->SetDiscEjected(true);

                                }
                                return TRUE;    // grant permission

                            case DBT_DEVICEREMOVECOMPLETE:
                                if( pdbcv->dbcv_unitmask & m_driveMask ) {
                                    if( !m_ejected ) {
                                        CComVariant var = 0;
                                        m_pDVD->Fire_DVDNotify(EC_DVD_DISC_EJECTED, var, var);
                                    }
                                    m_ejected = true;
                                    m_inserted = false;
                                    m_pDVD->SetDiscEjected(true);
                                }
                                return TRUE;    // grant permission

                            default:
                                return TRUE;
                        }
                    }
                }
                break;
            }
            default:
                break;
            }
            break;
        }
        default:
            break;
    }
    return ParentClass::WndProc( uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\imgguids.h ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgguids.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

//
// Image file format identifiers
//

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
 
//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\msdvd.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: msdvd.cpp                                                       */
/* Description: Implementation of CMSWebDVD.                             */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSDVD.h"
#include "resource.h"
#include <mpconfig.h>
#include <il21dec.h> // line 21 decoder
#include <commctrl.h>
#include "ThunkProc.h"
#include "ddrawobj.h"
#include "stdio.h"

/*************************************************************************/
/* Local constants and defines                                           */
/*************************************************************************/
const DWORD cdwDVDCtrlFlags = DVD_CMD_FLAG_Block| DVD_CMD_FLAG_Flush;
const DWORD cdwMaxFP_DOMWait = 30000; // 30sec for FP_DOM passing should be OK
const LONG cgStateTimeout = 0; // wait till the state transition occurs
                               // modify if needed

const LONG cgDVD_MIN_SUBPICTURE = 0;
const LONG cgDVD_MAX_SUBPICTURE = 31;
const LONG cgDVD_ALT_SUBPICTURE = 63;
const LONG cgDVD_MIN_ANGLE  = 0;
const LONG cgDVD_MAX_ANGLE = 9;
const double cgdNormalSpeed = 1.00;
const LONG cgDVDMAX_TITLE_COUNT = 99;
const LONG cgDVDMIN_TITLE_COUNT = 1;
const LONG cgDVDMAX_CHAPTER_COUNT = 999;
const LONG cgDVDMIN_CHAPTER_COUNT = 1;
const LONG cgTIME_STRING_LEN = 2;
const LONG cgMAX_DELIMITER_LEN = 4;
const LONG cgDVD_TIME_STR_LEN = (3*cgMAX_DELIMITER_LEN)+(4*cgTIME_STRING_LEN) + 1 /*NULL Terminator*/;
const LONG cgVOLUME_MAX = 0;
const LONG cgVOLUME_MIN = -10000;
const LONG cgBALANCE_MIN = -10000;
const LONG cgBALANCE_MAX = 10000;
const WORD cgWAVE_VOLUME_MIN = 0;
const WORD cgWAVE_VOLUME_MAX = 0xffff;

const DWORD cdwTimeout = 10; //100
const LONG  cgnStepTimeout = 100;

#define EC_DVD_PLAYING                 (EC_DVDBASE + 0xFE)
#define EC_DVD_PAUSED                  (EC_DVDBASE + 0xFF)
#define E_NO_IDVD2_PRESENT MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF0)
#define E_REGION_CHANGE_FAIL MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF1)
#define E_NO_DVD_VOLUME MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF3)
#define E_REGION_CHANGE_NOT_COMPLETED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF4)
#define E_NO_SOUND_STREAM MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF5)
#define E_NO_VIDEO_STREAM MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF6)
#define E_NO_OVERLAY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF7)
#define E_NO_USABLE_OVERLAY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF8)
#define E_NO_DECODER MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF9)
#define E_NO_CAPTURE_SUPPORT MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFFA)

#define DVD_ERROR_NoSubpictureStream    99

#if WINVER < 0x0500
typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

#define CURSOR_SHOWING     0x00000001
static BOOL (WINAPI *pfnGetCursorInfo)(PCURSORINFO);
typedef BOOL (WINAPI *PFNGETCURSORINFOHANDLE)(PCURSORINFO);

HRESULT CallGetCursorInfo(PCURSORINFO pci)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstDll = ::LoadLibrary(TEXT("USER32.DLL"));

    if (hinstDll)
    {
        pfnGetCursorInfo = (PFNGETCURSORINFOHANDLE)GetProcAddress(hinstDll, "GetCursorInfo");

        if (pfnGetCursorInfo)
        {
            hr = pfnGetCursorInfo(pci);
        }

        FreeLibrary(hinstDll);
    }

    return hr;
}
#endif

GUID IID_IAMSpecifyDDrawConnectionDevice = {
            0xc5265dba,0x3de3,0x4919,{0x94,0x0b,0x5a,0xc6,0x61,0xc8,0x2e,0xf4}};

extern CComModule _Module;

/*************************************************************************/
/* Global Helper Functions                                               */
/*************************************************************************/
// helper function for converting a captured YUV image to RGB
// and saving to file.


extern HRESULT GDIConvertImageAndSave(YUV_IMAGE *lpImage, RECT *prc, HWND hwnd);
extern HRESULT ConvertImageAndSave(YUV_IMAGE *lpImage, RECT *prc, HWND hwnd);


// Helper function to calcuate max common denominator
long MCD(long i, long j) {
    if (i == j)
        return i;

    else if (i>j) {
        if (i%j == 0)
            return j;
        else
            return MCD(i%j, j);
    }

    else {
        if (j%i == 0)
            return i;
        else
            return MCD(j%i, i);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CMSWebDVD

/*************************************************************************/
/* General initialization methods                                        */
/*************************************************************************/

/*************************************************************************/
/* Function: CMSWebDVD                                                 */
/*************************************************************************/
CMSWebDVD::CMSWebDVD(){

    Init();
}/* end of function CMSWebDVD */

/*************************************************************************/
/* Function: ~CMSWebDVD                                                */
/*************************************************************************/
CMSWebDVD::~CMSWebDVD(){
    
    // if we haven't been rendered or already been cleaned up
    if (!m_fInitialized){ 
        
        return;
    }/* end of if statement */

    Stop();
    Cleanup();    
    Init();
    ATLTRACE(TEXT("Inside the MSWEBDVD DESTRUCTOR!!\n"));
}/* end of function ~CMSWebDVD */

/*************************************************************************/
/* Function: Init                                                        */
/*************************************************************************/
VOID CMSWebDVD::Init(){

#if 1 // switch this to have the windowless case to be the deafult handling case
    m_bWindowOnly = TRUE; // turn on and off window only implementation
    m_fUseDDrawDirect = false;
#else
    m_bWindowOnly = FALSE;
    m_fUseDDrawDirect = true;
#endif

    m_lChapter = m_lTitle = 1;
    m_lChapterCount = NO_STOP;    
    m_clrColorKey = UNDEFINED_COLORKEY_COLOR;
    m_nReadyState = READYSTATE_LOADING;        
    m_bMute = FALSE;
    m_lLastVolume = 0;
    m_fEnableResetOnStop = FALSE; // TRUE
    m_clrBackColor = DEFAULT_BACK_COLOR; // off black used as a default key value to avoid flashing
#if 1
    m_nTTMaxWidth = 200;
    m_hWndTip = NULL;
    m_bTTCreated = FALSE;
#endif    
    m_fInitialized = false;
    m_hFPDOMEvent = NULL;
    m_fDisableAutoMouseProcessing = false;
    m_bEjected = false;
    m_fStillOn = false;    
    m_nCursorType = dvdCursor_Arrow;
    m_pClipRect = NULL;
    m_bMouseDown = FALSE;
    m_hCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT));
    m_dZoomRatio = 1;
    m_hWndOuter  = NULL;
    ::ZeroMemory(&m_rcOldPos, sizeof(RECT));
    m_hTimerId = NULL;
    m_fResetSpeed = true;
    m_DVDFilterState = dvdState_Undefined;
    m_lKaraokeAudioPresentationMode = 0;
    m_dwTTInitalDelay = 10;
    m_dwTTReshowDelay = 2;
    m_dwTTAutopopDelay = 10000;
    m_pDDrawDVD = NULL;
    m_dwNumDevices = 0;
    m_lpInfo = NULL;
    m_lpCurMonitor = NULL;
    m_MonitorWarn = FALSE;
    ::ZeroMemory(&m_ClipRectDown, sizeof(RECT));
    m_fStepComplete = false;
    m_bFireUpdateOverlay = FALSE;

    m_dwAspectX = 1;
    m_dwAspectY = 1;
    m_dwVideoWidth = 1;
    m_dwVideoHeight =1;

    // default overlay stretch factor x1000
    m_dwOvMaxStretch = 32000;
    m_bFireNoSubpictureStream = FALSE;

    // flags for caching decoder flags
    m_fBackWardsFlagInitialized = false;
    m_fCanStepBackwards = false;

}/* end of function Init */

/*************************************************************************/
/* Function: Cleanup                                                     */
/* Description: Releases all the interfaces.                             */
/*************************************************************************/
VOID CMSWebDVD::Cleanup(){

   m_mediaHandler.Close();

   if (m_pME){

        m_pME->SetNotifyWindow(NULL, WM_DVDPLAY_EVENT, 0) ;
        m_pME.Release() ;        
    }/* end of if statement */

    if(NULL != m_hTimerId){

        ::KillTimer(NULL, m_hTimerId);
    }/* end of if statement */

    if(NULL != m_hFPDOMEvent){

        ::CloseHandle(m_hFPDOMEvent);
        m_hFPDOMEvent = NULL;
    }/* end of if statement */

    m_pAudio.Release();
    m_pMediaSink.Release();
    m_pDvdInfo2.Release();
    m_pDvdCtl2.Release();
    m_pMC.Release();
    m_pVideoFrameStep.Release();
        
                 
    m_pGB.Release();        
    m_pDvdGB.Release();        
    m_pDDEX.Release();
    m_pDvdAdmin.Release();
        
    if (m_hCursor != NULL) {
        ::DestroyCursor(m_hCursor);
    }/* end of if statement */

    if(NULL != m_pDDrawDVD){

        delete m_pDDrawDVD;
        m_pDDrawDVD = NULL;
    }/* end of if statement */

    if(NULL != m_lpInfo){

        ::CoTaskMemFree(m_lpInfo);
        m_lpInfo = NULL;
    }/* end of if statement */

    ::ZeroMemory(&m_rcOldPos, sizeof(RECT));
}/* end of function Cleanup */

/*************************************************************************/
/* "ActiveX" methods  needed to support our interfaces                   */
/*************************************************************************/

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Just Draws the rectangular background.                   */
/*************************************************************************/
HRESULT CMSWebDVD::OnDraw(ATL_DRAWINFO& di){

    try {
       
        if(!m_bWndLess && m_fInitialized){
            // have to draw background only if in windowless mode or if we are not rendered yet
            
            // Get the active movie window
            HWND hwnd = ::GetWindow(m_hWnd, GW_CHILD);

            if (!::IsWindow(hwnd)){ 
    
                return S_OK;
            }/* end of if statement */

            if(::IsWindowVisible(hwnd)){

                return S_OK;
            }/* end of if statement */
        }/* end of if statement */

        HDC hdc = di.hdcDraw;

        // Not used for now
        // bool fHandled = true;

        // Paint backcolor first
        COLORREF clr;
                
        ::OleTranslateColor(m_clrBackColor, NULL, &clr);

        RECT rcClient = *(RECT*)di.prcBounds;
    
        HBRUSH hbrush = ::CreateSolidBrush(clr);

        if(NULL != hbrush){

            HBRUSH oldBrush = (HBRUSH)::SelectObject(hdc, hbrush);

            ::Rectangle(hdc, rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);
            //ATLTRACE(TEXT("BackColor, %d %d %d %d\n"), rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);

            ::SelectObject(hdc, oldBrush);

            ::DeleteObject(hbrush);
            hbrush = NULL;
        }/* end of if statement */
                
        // Paint color key in the video area

        if(NULL == m_pDDrawDVD){

            return(S_OK);
        }/* end of if statement */
        
        if(SUCCEEDED(AdjustDestRC())){
            RECT rcVideo = m_rcPosAspectRatioAjusted;
            rcVideo.left = rcClient.left+(RECTWIDTH(&rcClient)-RECTWIDTH(&rcVideo))/2;
            rcVideo.top = rcClient.top+(RECTHEIGHT(&rcClient)-RECTHEIGHT(&rcVideo))/2;
            rcVideo.right = rcVideo.left + RECTWIDTH(&rcVideo);
            rcVideo.bottom = rcVideo.top + RECTHEIGHT(&rcVideo);
    
            m_clrColorKey = m_pDDrawDVD->GetColorKey();
#if 1
            hbrush = ::CreateSolidBrush(::GetNearestColor(hdc, m_clrColorKey));
#else
            m_pDDrawDVD->CreateDIBBrush(m_clrColorKey, &hbrush);
#endif

            if(NULL != hbrush){

                HBRUSH oldBrush = (HBRUSH)::SelectObject(hdc, hbrush);

                ::Rectangle(hdc, rcVideo.left, rcVideo.top, rcVideo.right, rcVideo.bottom);
                //ATLTRACE(TEXT("ColorKey, %d %d %d %d\n"), rcVideo.left, rcVideo.top, rcVideo.right, rcVideo.bottom);

                ::SelectObject(hdc, oldBrush);

                ::DeleteObject(hbrush);
                hbrush = NULL;
            }/* end of if statement */
        }/* end of if statement */

        // in case we have a multimon we need to draw our warning
        HandleMultiMonPaint(hdc);
    }/* end of try statement statement */
    catch(...){
        return(0);
    }/* end of catch statement */

    return(1);
}/* end of function OnDraw */

#ifdef _WMP    
/*************************************************************************/
/* Function: InPlaceActivate                                             */
/* Description: Modified InPlaceActivate so WMP can startup.             */
/*************************************************************************/
HRESULT CMSWebDVD::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/){
    HRESULT hr;

    if (m_spClientSite == NULL)
        return S_OK;

    CComPtr<IOleInPlaceObject> pIPO;
    ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
    ATLASSERT(pIPO != NULL);

    if (!m_bNegotiatedWnd)
    {
        if (!m_bWindowOnly)
            // Try for windowless site
            hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);

        if (m_spInPlaceSite)
        {
            m_bInPlaceSiteEx = TRUE;
            // CanWindowlessActivate returns S_OK or S_FALSE
            if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )
            {
                m_bWndLess = TRUE;
                m_bWasOnceWindowless = TRUE;
            }
            else
            {
                m_bWndLess = FALSE;
            }
        }
        else
        {
            m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
            if (m_spInPlaceSite)
                m_bInPlaceSiteEx = TRUE;
            else
                hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
        }
    }

    ATLASSERT(m_spInPlaceSite);
    if (!m_spInPlaceSite)
        return E_FAIL;

    m_bNegotiatedWnd = TRUE;

    if (!m_bInPlaceActive)
    {

        BOOL bNoRedraw = FALSE;
        if (m_bWndLess)
            m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
        else
        {
            if (m_bInPlaceSiteEx)
                m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
            else
            {
                hr = m_spInPlaceSite->CanInPlaceActivate();
                // CanInPlaceActivate returns S_FALSE or S_OK
                if (FAILED(hr))
                    return hr;
                if ( hr != S_OK )
                {
                   // CanInPlaceActivate returned S_FALSE.
                   return( E_FAIL );
                }
                m_spInPlaceSite->OnInPlaceActivate();
            }
        }
    }

    m_bInPlaceActive = TRUE;

    // get location in the parent window,
    // as well as some information about the parent
    //
    OLEINPLACEFRAMEINFO frameInfo;
    RECT rcPos, rcClip;
    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    HWND hwndParent;

    // DJ - GetParentHWND per MNnovak

    if (SUCCEEDED( GetParentHWND(&hwndParent) ))
    {
        m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
            &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

        if (!m_bWndLess)
        {
            if (m_hWndCD)
            {
                ::ShowWindow(m_hWndCD, SW_SHOW);
                if (!::IsChild(m_hWndCD, ::GetFocus()))
                    ::SetFocus(m_hWndCD);
            }
            else
            {
                HWND h = CreateControlWindow(hwndParent, rcPos);
                ATLASSERT(h != NULL);   // will assert if creation failed
                ATLASSERT(h == m_hWndCD);
                h;  // avoid unused warning
            }
        }

        pIPO->SetObjectRects(&rcPos, &rcClip);
    }

    CComPtr<IOleInPlaceActiveObject> spActiveObject;
    ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

    // Gone active by now, take care of UIACTIVATE
    if (DoesVerbUIActivate(iVerb))
    {
        if (!m_bUIActive)
        {
            m_bUIActive = TRUE;
            hr = m_spInPlaceSite->OnUIActivate();
            if (FAILED(hr))
                return hr;

            SetControlFocus(TRUE);
            // set ourselves up in the host.
            //
            if (spActiveObject)
            {
                if (spInPlaceFrame)
                    spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
                if (spInPlaceUIWindow)
                    spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
            }

            if (spInPlaceFrame)
                spInPlaceFrame->SetBorderSpace(NULL);
            if (spInPlaceUIWindow)
                spInPlaceUIWindow->SetBorderSpace(NULL);
        }
    }

    m_spClientSite->ShowObject();

    return S_OK;
}/* end of function InPlaceActivate */
#endif

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {

		&IID_IMSWebDVD,
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: OnSize                                                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnSize(UINT uMsg, WPARAM /* wParam */, 
                            LPARAM lParam, BOOL& bHandled){

#ifdef _DEBUG
    if (WM_SIZING == uMsg) {
        //ATLTRACE(TEXT("WM_SIZING\n"));
    }
#endif 

    if(m_pDvdGB == NULL){
        
        return(0);
    }/* end of if statement */

    if (m_bWndLess || m_fUseDDrawDirect){

        OnResize();
    }
    else {

        IVideoWindow* pVW;

        HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

        if (SUCCEEDED(hr)){       
       
           LONG nWidth = LOWORD(lParam);  // width of client area 
           LONG nHeight = HIWORD(lParam); // height of client area 
       
           hr =  pVW->SetWindowPosition(0, 0, nWidth, nHeight);

           pVW->Release();
        }/* end of if statement */
    }/* end of if statement */

    bHandled = TRUE;

    return(0);
}/* end of function OnSize */

/*************************************************************************/
/* Function: OnResize                                                    */
/* Description: Handles the resizing and moving in windowless case.      */
/*************************************************************************/
HRESULT CMSWebDVD::OnResize(){

    HRESULT hr = S_FALSE;

    if (m_bWndLess || m_fUseDDrawDirect){

        RECT rc;

        hr = GetClientRectInScreen(&rc);
        
        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */                
        
        if(m_pDDEX){

            hr = m_pDDEX->SetDrawParameters(m_pClipRect, &rc);
            //ATLTRACE(TEXT("SetDrawParameters\n"));
        }/* end of if statement */

        HandleMultiMonMove();

    }/* end of if statement */

    return(hr);
}/* end of function OnResize */

/*************************************************************************/
/* Function: OnErase                                                     */
/* Description: Skip the erasing to avoid flickers.                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
	return 1;
}/* end of function OnErase */

/*************************************************************************/
/* Function: OnCreate                                                    */
/* Description: Sets our state to complete so we can proceed in          */
/* in initialization.                                                    */
/*************************************************************************/
LRESULT CMSWebDVD::OnCreate(UINT /* uMsg */, WPARAM /* wParam */, 
                            LPARAM lParam, BOOL& bHandled){
    
    return(0);
}/* end of function OnCreate */

/*************************************************************************/
/* Function: OnDestroy                                                   */
/* Description: Sets our state to complete so we can proceed in          */
/* in initialization.                                                    */
/*************************************************************************/
LRESULT CMSWebDVD::OnDestroy(UINT /* uMsg */, WPARAM /* wParam */, 
                            LPARAM lParam, BOOL& bHandled){

    // if we haven't been rendered
    if (!m_fInitialized){ 
        
        return 0;
    }/* end of if statement */

    Stop();
    Cleanup();
    Init();
    return(0);
}/* end of function OnCreate */

/*************************************************************************/
/* Function: GetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/* This control is safe since it does not write to HD.                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetInterfaceSafetyOptions(REFIID riid, 
                                               DWORD* pdwSupportedOptions, 
                                               DWORD* pdwEnabledOptions){

    HRESULT hr = S_OK;

	*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;

	*pdwEnabledOptions = *pdwSupportedOptions;

	return(hr);
}/* end of function GetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: SetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetInterfaceSafetyOptions(REFIID riid, 
                                               DWORD /* dwSupportedOptions */, 
                                               DWORD /* pdwEnabledOptions */){

	return (S_OK);
}/* end of function SetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: SetObjectRects                                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){

#if 0
    ATLTRACE(TEXT("Resizing control prcPos->left = %d, prcPos.right = %d, prcPos.bottom =%d, prcPos.top = %d\n"),
        prcPos->left, prcPos->right, prcPos->bottom, prcPos->top); 


    ATLTRACE(TEXT("Resizing control Clip prcClip->left = %d, prcClip.right = %d, prcClip.bottom =%d, prcClip.top = %d\n"),
        prcClip->left, prcClip->right, prcClip->bottom, prcClip->top); 
#endif

    HRESULT hr = IOleInPlaceObjectWindowlessImpl<CMSWebDVD>::SetObjectRects(prcPos,prcClip);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    if(!::IsWindow(m_hWnd)){

        hr = OnResize(); // need to update DDraw destination rectangle
    }/* end of if statement */

    return(hr);
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: GetParentHWND                                               */
/* Description: Gets the parent window HWND where we are operating.      */
/*************************************************************************/
HRESULT CMSWebDVD::GetParentHWND(HWND* pWnd){

    HRESULT hr = S_OK;

    IOleClientSite *pClientSite;
    IOleContainer *pContainer;
    IOleObject *pObject;

    hr = GetClientSite(&pClientSite);

    if(FAILED(hr)){

		return(hr);	
    }/* end of if statement */

    IOleWindow *pOleWindow;
    
    do {
        hr = pClientSite->QueryInterface(IID_IOleWindow, (LPVOID *) &pOleWindow);
        
        if(FAILED(hr)){
            
            return(hr);	
        }/* end of if statement */
        
        hr = pOleWindow->GetWindow((HWND*)pWnd);
        
        pOleWindow->Release();

        // if pClientSite is windowless, go get its container
        if (FAILED(hr)) {
            HRESULT hrTemp = pClientSite->GetContainer(&pContainer);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            pClientSite->Release();
            
            hrTemp = pContainer->QueryInterface(IID_IOleObject, (LPVOID*)&pObject);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            pContainer->Release();
            
            hrTemp = pObject->GetClientSite(&pClientSite);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
        }
    } while (FAILED(hr));

    pClientSite->Release();
    return(hr);
}/* end of function GetParentHWND */

/*************************************************************************/
/* Function: SetReadyState                                               */
/* Description: Sets ready state and fires event if it needs to be fired */
/*************************************************************************/
HRESULT CMSWebDVD::SetReadyState(LONG lReadyState){

    HRESULT hr = S_OK;
    
    bool bFireEvent = (lReadyState != m_nReadyState);

    
#ifdef _DEBUG    
    if(m_nFreezeEvents > 0){

        ::Sleep(10);
        ATLTRACE("Container not expecting events at the moment");
    }/* end of is statement */

#endif

    if(bFireEvent){

        put_ReadyState(lReadyState);
        Fire_ReadyStateChange(lReadyState);
    }
    else {
        // set the variable
        m_nReadyState = lReadyState;
    }/* end of if statement */

    return(hr);
}/* end of function SetReadyState */

/*************************************************************************/
/* DVD methods to do with supporting DVD Playback                        */
/*************************************************************************/

/*************************************************************************/
/* Function: Render                                                      */
/* Description: Builds Graph.                                            */
/* lRender not used in curent implemetation, but might be used in the    */
/* future to denote different mode of initializations.                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Render(long lRender){
USES_CONVERSION;

    HRESULT hr = S_OK;

    try {

        //throw(E_NO_DECODER);

        if(m_fInitialized && ((dvdRender_Reinitialize & lRender) != dvdRender_Reinitialize)){
            
            ATLTRACE(TEXT("Graph was already initialized\n"));
            throw(S_FALSE);
        }/* end of if statement */

        Cleanup(); // release all the interfaces so we start from ground up
        //Init();    // initialize the variables

        m_fInitialized = false; // set the flag that we are not initialized in
        // case if something goes wrong

        // create an event that lets us know we are past FP_DOM
        m_hFPDOMEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
        ATLASSERT(m_hFPDOMEvent);

        hr = ::CoCreateInstance(CLSID_DvdGraphBuilder, NULL, CLSCTX_INPROC, 
		    IID_IDvdGraphBuilder, (LPVOID *)&m_pDvdGB) ;

        if (FAILED(hr) || !m_pDvdGB){

    #ifdef _DEBUG
            ::MessageBox(::GetFocus(), TEXT("DirectShow DVD software not installed properly.\nPress OK to end the app."), 
                    TEXT("Error"), MB_OK | MB_ICONSTOP) ;
    #endif

            throw(hr);
        }/* end of if statement */
		
		/* Force NonExclMode (in other words: use Overlay Mixer and NOT VMR) */
		GUID IID_IDDrawNonExclModeVideo = {0xec70205c,0x45a3,0x4400,{0xa3,0x65,0xc4,0x47,0x65,0x78,0x45,0xc7}};
		
		// Set DDraw object and surface on DVD graph builder before starting to build graph    
		hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo, (LPVOID *)&m_pDDEX) ;
		if (FAILED(hr) || !m_pDDEX){
			
			ATLTRACE(TEXT("ERROR: IDvdGB::GetDvdInterface(IDDrawExclModeVideo) \n"));
			ATLTRACE(TEXT("The QDVD.DLL does not support IDvdInfo2 or IID_IDvdControl2, please update QDVD.DLL\n"));
			throw(E_NO_IDVD2_PRESENT);                
		}/* end of if statement */

        if (m_bWndLess || m_fUseDDrawDirect){

            hr = SetupDDraw();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            hr = m_pDDrawDVD->HasOverlay();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */
            
            if(S_FALSE == hr){

                throw(E_NO_OVERLAY);
            }/* end of if statement */

            hr = m_pDDrawDVD->HasAvailableOverlay();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            hr = m_pDDrawDVD->GetOverlayMaxStretch(&m_dwOvMaxStretch);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            if(S_FALSE == hr){

                throw(E_NO_USABLE_OVERLAY);
            }/* end of if statement */

            hr = m_pDDEX->SetDDrawObject(m_pDDrawDVD->GetDDrawObj());

            if (FAILED(hr)){

                ATLTRACE(TEXT("ERROR: IDDrawExclModeVideo::SetDDrawObject()"));
                m_pDDEX.Release() ;  // release before returning
                throw(hr);
            }/* end of if statement */

            hr = m_pDDEX->SetDDrawSurface(m_pDDrawDVD->GetDDrawSurf()); // have to set the surface if NOT the IDDExcl complains    

            if (FAILED(hr)){

                m_pDDEX.Release() ;  // release before returning
                throw(hr);
            }/* end of if statement */

             //OnResize(); // set the DDRAW RECTS, we are doing it in the thread
#if 1
            hr = m_pDDEX->SetCallbackInterface(m_pDDrawDVD->GetCallbackInterface(), 0) ;
            if (FAILED(hr))
            {

                throw(hr);
            }/* end of it statement */
#endif

        }/* end of if statement */        
    
        DWORD dwRenderFlag = AM_DVD_HWDEC_PREFER; // use the hardware if possible
        AM_DVD_RENDERSTATUS  amDvdStatus;
        //Completes building a filter graph according to user specifications for 
        // playing back a default DVD-Video volume
        hr = m_pDvdGB->RenderDvdVideoVolume(NULL, dwRenderFlag, &amDvdStatus);
                
        if (FAILED(hr)){

#ifdef _DEBUG
            TCHAR  strError[1000];
            AMGetErrorText(hr, strError, sizeof(strError)) ;
            ::MessageBox(::GetFocus(), strError, TEXT("Error"), MB_OK) ;
#endif
            if(VFW_E_DVD_DECNOTENOUGH == hr){

                throw(E_NO_DECODER);
            }/* end of if statement */

            throw(hr);
        }/* end of if statement */

        HRESULT hrTmp = m_pDvdGB->GetDvdInterface(IID_IDvdControl2, (LPVOID *)&m_pDvdCtl2) ;

        if(FAILED(hrTmp)){

            ATLTRACE(TEXT("The QDVD.DLL does not support IDvdInfo2 or IID_IDvdControl2, please update QDVD.DLL\n"));
            throw(E_NO_IDVD2_PRESENT);
        }/* end of if statement */

        if (hr == S_FALSE){  // if partial success
           
            if((dvdRender_Error_On_Missing_Drive & lRender) && amDvdStatus.bDvdVolInvalid || amDvdStatus.bDvdVolUnknown){

#if 0
                TCHAR filename[MAX_PATH];
                if (OpenIFOFile(::GetDesktopWindow(), filename)){

                    USES_CONVERSION;

                    if(!m_pDvdCtl2){
            
                        throw (E_UNEXPECTED);
                    }/* end of if statement */

                    hr = m_pDvdCtl2->SetDVDDirectory(T2W(filename));                    
                }
                else{

                    hr = E_NO_DVD_VOLUME;
                }/* end of if statement */
#else
                hr = E_NO_DVD_VOLUME;
#endif

                if(FAILED(hr)){

                    throw(E_NO_DVD_VOLUME);
                }/* end of if statement */
            }/* end of if statement */

            // improve your own error handling
            if(amDvdStatus.bNoLine21Out != NULL){ // we do not care about the caption
            
    #ifdef _DEBUG
                if (::MessageBox(::GetFocus(), TEXT(" Line 21 has failed Do you still want to continue?"), TEXT("Warning"), MB_YESNO) == IDNO){
                    throw(E_FAIL);
                }/* end of if statement */
    #endif
            }/* end of if statement */
            
            if((amDvdStatus.iNumStreamsFailed > 0) && ((amDvdStatus.dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO) == AM_DVD_STREAM_VIDEO)){

                throw(E_NO_VIDEO_STREAM);
            }/* end of if statement */
            // handeling this below

            if((amDvdStatus.iNumStreamsFailed > 0) && ((amDvdStatus.dwFailedStreamsFlag & AM_DVD_STREAM_SUBPIC) == AM_DVD_STREAM_SUBPIC)){
#if 0                
                TCHAR strBuffer1[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_E_NO_SUBPICT_STREAM, strBuffer1, MAX_PATH)){

                    throw(E_UNEXPECTED);
                }/* end of if statement */

                TCHAR strBuffer2[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_WARNING, strBuffer2, MAX_PATH)){

                    throw(E_UNEXPECTED);
                }/* end of if statement */

                ::MessageBox(::GetFocus(), strBuffer1, strBuffer2, MB_OK);    
#else
                // Will bubble up the error to the app
                m_bFireNoSubpictureStream = TRUE;
#endif
            }/* end of if statement */
        }/* end of if statement */

        // Now get all the interfaces to playback the DVD-Video volume
        hr = m_pDvdGB->GetFiltergraph(&m_pGB) ;
    
        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_pGB->QueryInterface(IID_IMediaControl, (LPVOID *)&m_pMC) ;

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

         hr = m_pGB->QueryInterface(IID_IVideoFrameStep, (LPVOID *)&m_pVideoFrameStep);

        if(FAILED(hr)){

            // do not bail out, since frame stepping is not that important
            ATLTRACE(TEXT("Frame stepping QI failed"));
            ATLASSERT(FALSE);
        }/* end of if statement */

        hr = m_pGB->QueryInterface(IID_IMediaEventEx, (LPVOID *)&m_pME) ;

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        IVideoWindow* pVW = NULL;

        if (!m_bWndLess){
    
            //
            // Also set up the event notification so that the main window gets
            // informed about all that we care about during playback.
            //
            // HAVE THREAD !!!

            INT iCount = 0;

            while(m_hWnd == NULL){


                if(iCount >10) break;

                ::Sleep(100);
                iCount ++;
            }/* end of while loop */

            if(m_hWnd == NULL){

                ATLTRACE(TEXT("Window is not active as of yet\n returning with E_PENDING\n"));
                hr = E_PENDING;
                throw(hr);
            }/* end of if statement */
            
	        hr = m_pME->SetNotifyWindow((OAHWND) m_hWnd, WM_DVDPLAY_EVENT, 0);
        
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            if(!m_fUseDDrawDirect){
        
                hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

                if(FAILED(hr)){
                  
                    throw(hr);
                }/* end of if statement */
        

                hr = pVW->put_MessageDrain((OAHWND)m_hWnd); // get our mouse messages over

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */
            }/* end of if statement */
        }
        else {
            // create the timer which will keep us updated
            
            m_hTimerId = ::SetTimer(NULL, 0, cdwTimeout, GetTimerProc());        
        }/* end of if statement */
                
        hr = m_pDvdGB->GetDvdInterface(IID_IDvdInfo2, (LPVOID *)&m_pDvdInfo2) ;

        if(FAILED(hr)){
            
            ATLTRACE(TEXT("The QDVD.DLL does not support IDvdInfo2 or IID_IDvdControl2, please update QDVD.DLL\n"));
            throw(E_NO_IDVD2_PRESENT);
        }/* end of if statement */
        
	    hr = SetupAudio();

        if(FAILED(hr)){

#if 1
            throw(E_NO_SOUND_STREAM);
#else
            TCHAR strBuffer1[MAX_PATH];
            if(!::LoadString(_Module.m_hInstResource, IDS_E_NO_SOUND_STREAM, strBuffer1, MAX_PATH)){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            TCHAR strBuffer2[MAX_PATH];
            if(!::LoadString(_Module.m_hInstResource, IDS_WARNING, strBuffer2, MAX_PATH)){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            ::MessageBox(::GetFocus(), strBuffer1, strBuffer2, MB_OK);
#endif            
        }/* end of if statement */

        hr = SetupEventNotifySink();

        #ifdef _DEBUG
            if(FAILED(hr)){
		        ATLTRACE(TEXT("Failed to setup event notify sink\n"));     
            }/* end of if statement */
        #endif

        if (!m_bWndLess && !m_fUseDDrawDirect){
            // set the window position and style
            hr =  pVW->put_Owner((OAHWND)m_hWnd); 

            RECT rc;
            ::GetWindowRect(m_hWnd, &rc);

            hr =  pVW->SetWindowPosition(0, 0, WIDTH(&rc), HEIGHT(&rc));

            LONG lStyle = GetWindowLong(GWL_STYLE);
            hr = pVW->put_WindowStyle(lStyle);
            lStyle = GetWindowLong(GWL_EXSTYLE);
            hr = pVW->put_WindowStyleEx(lStyle);

             pVW->Release();
        }/* end of if statement */

        bool fSetColorKey = false; // flag so we do not duplicate code, and simplify logic

        // case when windowless and  color key is not defined
        // then in that case get the color key from the OV mixer 
        if(m_bWndLess || m_fUseDDrawDirect){

            COLORREF clr;
            hrTmp = GetColorKey(&clr); 

            if(FAILED(hrTmp)){
#ifdef _DEBUG
                ::MessageBox(::GetFocus(), TEXT("failed to get color key"), TEXT("error"), MB_OK);
#endif
                
                throw(hrTmp);
            }/* end of if statement */
            
            if((m_clrColorKey & UNDEFINED_COLORKEY_COLOR) == UNDEFINED_COLORKEY_COLOR) {

                    m_clrColorKey = clr;
            }/* end of if statement */

            else if (clr != m_clrColorKey) {
                fSetColorKey = true;
            }

        }/* end of if statement */

        // case when color key is defined
        // if windowless set the background color at the same time
        if(fSetColorKey){

            hrTmp = put_ColorKey(m_clrColorKey);            
            
    #ifdef _DEBUG
                if(FAILED(hrTmp)){

                    ::MessageBox(::GetFocus(), TEXT("failed to set color key"), TEXT("error"), MB_OK);
                    throw(E_FAIL);
                }/* end of if statement */
    #endif                            
        }/* end of if statement */

        m_fInitialized = true;

        // turn off the closed caption. it is turned on by default
        // this code should be in the DVDNav!
        put_CCActive(VARIANT_FALSE);

        // Create the DVD administrator and set player level
        m_pDvdAdmin = new CComObject<CMSDVDAdm>;
        //m_pDvdAdmin.AddRef();        
        if(!m_pDvdAdmin){
            return E_UNEXPECTED;
        }
        RestoreDefaultSettings();       


        // disc eject and insert handler
        BSTR bstrRoot;
        hr = get_DVDDirectory(&bstrRoot);

        if (SUCCEEDED(hr)) {
            TCHAR *szRoot;
            szRoot = OLE2T(bstrRoot);
            m_mediaHandler.SetDrive(szRoot[0] );
            m_mediaHandler.SetDVD(this);
            m_mediaHandler.Open();
        }

        
        hr = m_pDvdCtl2->SetOption( DVD_HMSF_TimeCodeEvents, TRUE);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}/* end of function Render */

/*************************************************************************/
/* Function: Play                                                        */
/* Description: Puts the DVDNav in the run mode.                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Play(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE 

        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdCtl2 ){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        OAFilterState state;

        hr = m_pMC->GetState(cgStateTimeout, &state);

        m_DVDFilterState = (DVDFilterState) state; // save the state so we can restore it if an API fails        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        bool bFireEvent = false;  // fire event only when we change the state

        if(state != dvdState_Running){

            bFireEvent = true;

            // disable the stop in case CTRL+ALT+DEL
            if(state == dvdState_Stopped){

                if(FALSE == m_fEnableResetOnStop){
                
                    hr = m_pDvdCtl2->SetOption(DVD_ResetOnStop, FALSE);

                    if(FAILED(hr)){

                        throw(hr);
                    }/* end of if statement */
                }/* end of if statement */
            }/* end of if statement */

	        hr = m_pMC->Run();  // put it into running state just in case we are not in the running 
                                // state
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */
        }/* end of if statement */             
        
        if(bFireEvent && m_pMediaSink){

            m_pMediaSink->Notify(EC_DVD_PLAYING, 0, 0);
        }/* end of if statement */                
    
        // not collect hr
#ifdef _DEBUG
        if(m_fStillOn){

            ATLTRACE(TEXT("Not reseting the speed to 1.0 \n"));
        }/* end of if statement */
#endif
        if(false == m_fStillOn && true == m_fResetSpeed){

            // if we are in the still do not reset the speed            
            m_pDvdCtl2->PlayForwards(cgdNormalSpeed,0,0);
        }/* end of if statement */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Play */

/*************************************************************************/
/* Function: Pause                                                       */
/* Description: Pauses the filter graph just only in the case when stat  */
/* would not indicate that it was paused.                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Pause(){

	HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        OAFilterState state;

        hr = m_pMC->GetState(cgStateTimeout, &state);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        bool bFireEvent = false;  // fire event only when we change the state

        if(state != dvdState_Paused){

            bFireEvent = true;

	        hr = m_pMC->Pause();  // put it into running state just in case we are not in the running 
                                  // state
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

        }/* end of if statement */
#if 1
        // Fired our own paused event
        if(bFireEvent && m_pMediaSink){

            m_pMediaSink->Notify(EC_DVD_PAUSED, 0, 0);
        }/* end of if statement */                
#endif 

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Pause */

/*************************************************************************/
/* Function: Stop                                                        */
/* Description: Stops the filter graph if the state does not indicate    */
/* it was stopped.                                                       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Stop(){

	HRESULT hr = S_OK;

    try {

        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdCtl2){

            return(E_UNEXPECTED);
        }/* end of if statement */

        OAFilterState state;

        hr = m_pMC->GetState(cgStateTimeout, &state);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(state != dvdState_Stopped){

            if(FALSE == m_fEnableResetOnStop){
                
                hr = m_pDvdCtl2->SetOption(DVD_ResetOnStop, TRUE);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */
            }/* end of if statement */

	        hr = m_pMC->Stop();  // put it into running state just in case we are not in the running 
                                  // state
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Stop */

/*************************************************************************/
/* Function: OnDVDEvent                                                  */
/* Description: Handles the DVD events                                   */
/*************************************************************************/
LRESULT CMSWebDVD::OnDVDEvent(UINT /* uMsg */, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_bFireUpdateOverlay == TRUE) {
        if (m_fInitialized) {
            m_bFireUpdateOverlay = FALSE;
            Fire_UpdateOverlay();
        }
    }

    LONG        lEvent ;
    LONG_PTR    lParam1, lParam2 ;

    if (m_bFireNoSubpictureStream) {
        m_bFireNoSubpictureStream = FALSE;
        lEvent = EC_DVD_ERROR;
        lParam1 = DVD_ERROR_NoSubpictureStream;
        lParam2 = 0;
        VARIANT varLParam1;
        VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);
    }

    bHandled = TRUE;

    //
    //  Because the message mode for IMediaEvent may not be set before
    //  we get the first event it's important to read all the events
    //  pending when we get a window message to say there are events pending.
    //  GetEvent() returns E_ABORT when no more event is left.
    //
    while (m_pME && SUCCEEDED(m_pME->GetEvent(&lEvent, &lParam1, &lParam2, 0))){

        switch (lEvent){
            //
            // First the DVD error events
            //
            case EC_DVD_ERROR:
                switch (lParam1){

                case DVD_ERROR_Unexpected:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("An unexpected error (possibly incorrectly authored content)")
                        TEXT("\nwas encountered.")
                        TEXT("\nCan't playback this DVD-Video disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_CopyProtectFail:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("Key exchange for DVD copy protection failed.")
                        TEXT("\nCan't playback this DVD-Video disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_InvalidDVD1_0Disc:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video disc is incorrectly authored for v1.0  of the spec.")
                        TEXT("\nCan't playback this disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_InvalidDiscRegion:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video disc cannot be played, because it is not")
                        TEXT("\nauthored to play in the current system region.")
                        TEXT("\nThe region mismatch may be fixed by changing the")
                        TEXT("\nsystem region (with DVDRgn.exe)."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    Stop();
                    // fire the region change dialog                    
                    RegionChange();
                    break ;

                case DVD_ERROR_LowParentalLevel:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("Player parental level is set lower than the lowest parental")
                        TEXT("\nlevel available in this DVD-Video content.")
                        TEXT("\nCannot playback this DVD-Video disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_MacrovisionFail:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video content is protected by Macrovision.")
                        TEXT("\nThe system does not satisfy Macrovision requirement.")
                        TEXT("\nCan't continue playing this disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_IncompatibleSystemAndDecoderRegions:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("No DVD-Video disc can be played on this system, because ")
                        TEXT("\nthe system region does not match the decoder region.")
                        TEXT("\nPlease contact the manufacturer of this system."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_IncompatibleDiscAndDecoderRegions:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video disc cannot be played on this system, because it is")
                        TEXT("\nnot authored to be played in the installed decoder's region."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;
                }/* end of switch case */
                break ;

            //
            // Next the normal DVD related events
            //
            case EC_DVD_VALID_UOPS_CHANGE:
            {
                VALID_UOP_SOMTHING_OR_OTHER validUOPs = (DWORD) lParam1;
                if (validUOPs&UOP_FLAG_Play_Title_Or_AtTime) {
                    Fire_PlayAtTimeInTitle(VARIANT_FALSE);
                    Fire_PlayAtTime(VARIANT_FALSE);
                }
                else {
                    Fire_PlayAtTimeInTitle(VARIANT_TRUE);
                    Fire_PlayAtTime(VARIANT_TRUE);
                }
                    
                if (validUOPs&UOP_FLAG_Play_Chapter) {
                    Fire_PlayChapterInTitle(VARIANT_FALSE);
                    Fire_PlayChapter(VARIANT_FALSE);
                }
                else {
                    Fire_PlayChapterInTitle(VARIANT_TRUE);
                    Fire_PlayChapter(VARIANT_TRUE);
                }

                if (validUOPs&UOP_FLAG_Play_Title){
                    Fire_PlayTitle(VARIANT_FALSE);
                    
                }
                else {
                    Fire_PlayTitle(VARIANT_TRUE);
                }

                if (validUOPs&UOP_FLAG_Stop)
                    Fire_Stop(VARIANT_FALSE);
                else
                    Fire_Stop(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_ReturnFromSubMenu)
                    Fire_ReturnFromSubmenu(VARIANT_FALSE);
                else
                    Fire_ReturnFromSubmenu(VARIANT_TRUE);

                
                if (validUOPs&UOP_FLAG_Play_Chapter_Or_AtTime) {
                    Fire_PlayAtTimeInTitle(VARIANT_FALSE);
                    Fire_PlayChapterInTitle(VARIANT_FALSE);
                }
                else {
                    Fire_PlayAtTimeInTitle(VARIANT_TRUE);
                    Fire_PlayChapterInTitle(VARIANT_TRUE);
                }

                if (validUOPs&UOP_FLAG_PlayPrev_Or_Replay_Chapter){

                    Fire_PlayPrevChapter(VARIANT_FALSE);
                    Fire_ReplayChapter(VARIANT_FALSE);
                }                    
                else {
                    Fire_PlayPrevChapter(VARIANT_TRUE);
                    Fire_ReplayChapter(VARIANT_TRUE);
                }/* end of if statement */

                if (validUOPs&UOP_FLAG_PlayNext_Chapter)
                    Fire_PlayNextChapter(VARIANT_FALSE);
                else
                    Fire_PlayNextChapter(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_Play_Forwards)
                    Fire_PlayForwards(VARIANT_FALSE);
                else
                    Fire_PlayForwards(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Play_Backwards)
                    Fire_PlayBackwards(VARIANT_FALSE);
                else 
                    Fire_PlayBackwards(VARIANT_TRUE);
                                
                if (validUOPs&UOP_FLAG_ShowMenu_Title) 
                    Fire_ShowMenu(dvdMenu_Title, VARIANT_FALSE);
                else 
                    Fire_ShowMenu(dvdMenu_Title, VARIANT_TRUE);
                    
                if (validUOPs&UOP_FLAG_ShowMenu_Root) 
                    Fire_ShowMenu(dvdMenu_Root, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Root, VARIANT_TRUE);
                
                //TODO: Add the event for specific menus
                
                if (validUOPs&UOP_FLAG_ShowMenu_SubPic)
                    Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_ShowMenu_Audio)
                    Fire_ShowMenu(dvdMenu_Audio, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Audio, VARIANT_TRUE);
                    
                if (validUOPs&UOP_FLAG_ShowMenu_Angle)
                    Fire_ShowMenu(dvdMenu_Angle, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Angle, VARIANT_TRUE);

                    
                if (validUOPs&UOP_FLAG_ShowMenu_Chapter)
                    Fire_ShowMenu(dvdMenu_Chapter, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Chapter, VARIANT_TRUE);

                
                if (validUOPs&UOP_FLAG_Resume)
                    Fire_Resume(VARIANT_FALSE);
                else
                    Fire_Resume(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Select_Or_Activate_Button)
                    Fire_SelectOrActivatButton(VARIANT_FALSE);
                else 
                    Fire_SelectOrActivatButton(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Still_Off)
                    Fire_StillOff(VARIANT_FALSE);
                else
                    Fire_StillOff(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_Pause_On)
                    Fire_PauseOn(VARIANT_FALSE);
                else
                    Fire_PauseOn(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_Select_Audio_Stream)
                    Fire_ChangeCurrentAudioStream(VARIANT_FALSE);
                else
                    Fire_ChangeCurrentAudioStream(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Select_SubPic_Stream)
                    Fire_ChangeCurrentSubpictureStream(VARIANT_FALSE);
                else
                    Fire_ChangeCurrentSubpictureStream(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Select_Angle)
                    Fire_ChangeCurrentAngle(VARIANT_FALSE);
                else
                    Fire_ChangeCurrentAngle(VARIANT_TRUE);

                /*
                if (validUOPs&UOP_FLAG_Karaoke_Audio_Pres_Mode_Change)
                    ;
                if (validUOPs&UOP_FLAG_Video_Pres_Mode_Change)
                    ;
                */
                }
                break;
            case EC_DVD_STILL_ON:
		    m_fStillOn = true;    
            break ;

            case EC_DVD_STILL_OFF:                
            m_fStillOn = false;
            break ;

            case EC_DVD_DOMAIN_CHANGE:
                
                switch (lParam1){

                    case DVD_DOMAIN_FirstPlay: // = 1
                    //case DVD_DOMAIN_VideoManagerMenu:  // = 2
                        if(m_hFPDOMEvent){
                        // whenever we enter FP Domain we reset
                            ::ResetEvent(m_hFPDOMEvent);
                        }
                        else {
                            ATLTRACE(TEXT("No event initialized bug!!"));
                            ATLASSERT(FALSE);
                        }/* end of if statement */
                        break;

                    case DVD_DOMAIN_Stop:       // = 5
                    case DVD_DOMAIN_VideoManagerMenu:  // = 2                    
                    case DVD_DOMAIN_VideoTitleSetMenu: // = 3
                    case DVD_DOMAIN_Title:      // = 4
                    default:
                        if(m_hFPDOMEvent){
                         // whenever we get out of the FP Dom Set our state
                            ::SetEvent(m_hFPDOMEvent);
                        }
                        else {
                            ATLTRACE(TEXT("No event initialized bug!!"));
                            ATLASSERT(FALSE);
                        }/* end of if statement */
                        break;
                }/* end of switch case */
                break ;

            case EC_DVD_BUTTON_CHANGE:                       
                break;
    
            case EC_DVD_TITLE_CHANGE:                
                break ;

            case EC_DVD_CHAPTER_START:              
                break ;

            case EC_DVD_CURRENT_TIME: 
                //ATLTRACE(TEXT("Time event \n"));
                break;
            /**************
                DVD_TIMECODE *pTime = (DVD_TIMECODE *) &lParam1 ;
                wsprintf(m_achTimeText, TEXT("Current Time is  %d%d:%d%d:%d%d"),
                        pTime->Hours10, pTime->Hours1,
                        pTime->Minutes10, pTime->Minutes1,
                        pTime->Seconds10, pTime->Seconds1) ;
                InvalidateRect(m_hWnd, NULL, TRUE) ;
            ************************/

            case EC_DVD_CURRENT_HMSF_TIME: 
                //ATLTRACE(TEXT("New Time event \n"));                
                break;            

            //
            // Then the general DirectShow related events
            //
            case EC_COMPLETE:
            case EC_DVD_PLAYBACK_STOPPED:
                Stop() ;  // DShow doesn't stop on end; we should do that
                break;
                // fall through now...

            case EC_USERABORT:
            case EC_ERRORABORT:
            case EC_FULLSCREEN_LOST:
                //TO DO: Implement StopFullScreen() ;  // we must get out of fullscreen mode now
                break ;

            case EC_DVD_DISC_EJECTED:
                m_bEjected = true;
                break;
            case EC_DVD_DISC_INSERTED:
                m_bEjected = false;
                break;

            case EC_STEP_COMPLETE:                
                m_fStepComplete = true;
                break;

            default:
                break ;
        }/* end of switch case */

        // update for win64 since DShow uses now LONGLONG
        
        VARIANT varLParam1;
        VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);

        //
        // Remember to free the event params
        //
        m_pME->FreeEventParams(lEvent, lParam1, lParam2) ;

    }/* end of while loop  */

    return 0 ;
}/* end of function OnDVDEvent */

/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Selects the button.                                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    try {
        if(!m_fInitialized){

            return(0);
        }/* end of if statement */

        m_bMouseDown = TRUE;
        RECT rc;

        HWND hwnd;
        
        if(m_bWndLess){
            HRESULT hr = GetParentHWND(&hwnd);
            
            if(FAILED(hr)){
                
                return(hr);
            }/* end of if statement */

            rc = m_rcPos;
        }
        else {
            hwnd = m_hWnd;
            ::GetClientRect(hwnd, &rc);
        }/* end of if statement */
        
        if(::IsWindow(hwnd)){
            
            ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)&rc, 2);
        }/* end of if statement */
        ::ClipCursor(&rc);

        m_LastMouse.x = GET_X_LPARAM(lParam);
        m_LastMouse.y = GET_Y_LPARAM(lParam);

        if (m_pClipRect)
            m_ClipRectDown = *m_pClipRect;
        
        m_LastMouseDown = m_LastMouse;

        if(!m_fDisableAutoMouseProcessing){
            
            SelectAtPosition(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }/* end of if statement */
    }/* end of try statement */
    catch(...){
                
    }/* end of if statement */

    bHandled = true;
    return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Activates the button. The problem is that when we move   */
/* away from a button while holding left button down over some other     */
/* button then the button we are under gets activated. What should happen*/
/* is that no button gets activated.                                     */
/*************************************************************************/
LRESULT CMSWebDVD::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    try {        
        if(!m_fInitialized){

            return(0);
        }/* end of if statement */

        m_bMouseDown = FALSE;
        ::ClipCursor(NULL);
        if(!m_fDisableAutoMouseProcessing && m_nCursorType == dvdCursor_Arrow){
            
            ActivateAtPosition(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }

        else if(m_nCursorType == dvdCursor_ZoomIn ||
                m_nCursorType == dvdCursor_ZoomOut) {

            // Compute new clipping top left corner
            long x = GET_X_LPARAM(lParam);
            long y = GET_Y_LPARAM(lParam);
            POINT CenterPoint = {x, y};
            if (m_bWndLess) {
                RECT rc = {m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom};
                HWND hwnd;
                HRESULT hr = GetParentHWND(&hwnd);
                
                if(FAILED(hr)){
                    
                    return(hr);
                }/* end of if statement */
                
                if(::IsWindow(hwnd)){
                    
                    ::MapWindowPoints(hwnd, ::GetDesktopWindow(), &CenterPoint, 1);
                    ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)&rc, 2);
                }/* end of if statement */
                x = CenterPoint.x - rc.left;
                y = CenterPoint.y - rc.top;
            }
            
            CComPtr<IDVDRect> pDvdClipRect;
            HRESULT hr = GetClipVideoRect(&pDvdClipRect);
            if (FAILED(hr))
                throw(hr);
            
            // Get current clipping width and height
            long clipWidth, clipHeight;
            pDvdClipRect->get_Width(&clipWidth);
            pDvdClipRect->get_Height(&clipHeight);
            
            // Get current clipping top left corner
            long clipX, clipY;
            pDvdClipRect->get_x(&clipX);
            pDvdClipRect->get_y(&clipY);

            long newClipCenterX = x*clipWidth/RECTWIDTH(&m_rcPos) + clipX;
            long newClipCenterY = y*clipHeight/RECTHEIGHT(&m_rcPos) + clipY;
            
            if (m_nCursorType == dvdCursor_ZoomIn) {
            
                Zoom(newClipCenterX, newClipCenterY, 2.0);
            }
            else if (m_nCursorType == dvdCursor_ZoomOut) {
            
                Zoom(newClipCenterX, newClipCenterY, 0.5);
            }/* end of if statement */
        }
                
    }/* end of try statement */
    catch(...){
                
    }/* end of if statement */

    bHandled = true;
    return 0;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Selects the button.                                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

	try {
        if(!m_fInitialized){

            return(0);
        }/* end of if statement */

        if(!m_fDisableAutoMouseProcessing && m_nCursorType == dvdCursor_Arrow){

            SelectAtPosition(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }       

        else if (m_bMouseDown && m_nCursorType == dvdCursor_Hand) {

            CComPtr<IDVDRect> pDvdClipRect;
            CComPtr<IDVDRect> pDvdRect;
            HRESULT hr = GetVideoSize(&pDvdRect);
            if (FAILED(hr))
                throw(hr);
            hr = GetClipVideoRect(&pDvdClipRect);
            if (FAILED(hr))
                throw(hr);

            // Get video width and height
            long videoWidth, videoHeight;
            pDvdRect->get_Width(&videoWidth);
            pDvdRect->get_Height(&videoHeight);

            // Get clipping width and height;
            long clipWidth, clipHeight;
            pDvdClipRect->get_Width(&clipWidth);
            pDvdClipRect->get_Height(&clipHeight);

            if (!m_bWndLess) {

                AdjustDestRC();
            }/* end of if statement */

            double scaleFactorX = clipWidth/(double)RECTWIDTH(&m_rcPosAspectRatioAjusted);
            double scaleFactorY = clipHeight/(double)RECTHEIGHT(&m_rcPosAspectRatioAjusted);

            long xAdjustment = (long) ((GET_X_LPARAM(lParam) - m_LastMouseDown.x)*scaleFactorX);
            long yAdjustment = (long) ((GET_Y_LPARAM(lParam) - m_LastMouseDown.y)*scaleFactorY);

            RECT clipRect = m_ClipRectDown;

            ::OffsetRect(&clipRect, -xAdjustment, -yAdjustment);
            if (clipRect.left<0)
                ::OffsetRect(&clipRect, -clipRect.left, 0);
            if (clipRect.top<0)
                ::OffsetRect(&clipRect, 0, -clipRect.top);
            
            if (clipRect.right>videoWidth)
                ::OffsetRect(&clipRect, videoWidth-clipRect.right, 0);
            
            if (clipRect.bottom>videoHeight)
                ::OffsetRect(&clipRect, 0, videoHeight-clipRect.bottom);

            //ATLTRACE(TEXT("SetClipVideoRect %d %d %d %d\n"),
            //    m_pClipRect->left, m_pClipRect->top, m_pClipRect->right, m_pClipRect->bottom);
            
            pDvdClipRect->put_x(clipRect.left);
            pDvdClipRect->put_y(clipRect.top);

            hr = SetClipVideoRect(pDvdClipRect);
            if (FAILED(hr))
                throw(hr);

            m_LastMouse.x = GET_X_LPARAM(lParam);
            m_LastMouse.y = GET_Y_LPARAM(lParam);
        }/* end of if statement */ 

    }/* end of try statement */
    catch(...){
                
    }/* end of if statement */

    bHandled = true;
    return 0;
}/* end of function OnMouseMove */

/*************************************************************/
/* Function: OnSetCursor                                     */
/* Description: Sets the cursor to what we want overwrite    */
/* the default window proc.                                  */
/*************************************************************/
LRESULT CMSWebDVD::OnSetCursor(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    //ATLTRACE(TEXT("CMSWebDVD::OnSetCursor\n"));
    
    if (m_hCursor && m_nCursorType != dvdCursor_None){

        ::SetCursor(m_hCursor);
        //ATLTRACE(TEXT("Actually setting the cursor OnSetCursor\n"));
        return(TRUE);
    }/* end of if statement */
    
    bHandled = FALSE;
    return 0;
}/* end of function OnSetCursor */

/*************************************************************************/
/* Function: get_TitlesAvailable                                         */
/* Description: Gets the number of titles.                               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_TitlesAvailable(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    

        ULONG NumOfVol;
        ULONG ThisVolNum;
        DVD_DISC_SIDE Side;
        ULONG TitleCount;

        hr = m_pDvdInfo2->GetDVDVolumeInfo(&NumOfVol, &ThisVolNum, &Side, &TitleCount);

        *pVal = (LONG) TitleCount;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_TitlesAvailable */

/*************************************************************************/
/* Function: GetNumberChapterOfChapters                                  */
/* Description: Returns the number of chapters in title.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetNumberOfChapters(long lTitle, long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    
    
        hr = m_pDvdInfo2->GetNumberOfChapters(lTitle, (ULONG*)pVal);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function GetNumberChapterOfChapters */

/*************************************************************************/
/* Function: get_FullScreenMode                                          */
/* Description: Gets the current fullscreen mode.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_FullScreenMode(VARIANT_BOOL *pfFullScreenMode){

    //TODO: handle the other cases when not having IVideoWindow

    HRESULT hr = S_OK;

    try {

        if(NULL == pfFullScreenMode){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

	    IVideoWindow* pVW;

        if(!m_pDvdGB){

            return(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

        if (SUCCEEDED(hr) && pVW != NULL){       

           long lMode;
           hr =  pVW->get_FullScreenMode(&lMode);
       
           if(SUCCEEDED(hr)){

               *pfFullScreenMode = ((lMode == OAFALSE) ? VARIANT_FALSE : VARIANT_TRUE);
           }/* end of if statement */

           pVW->Release();
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_FullScreenMode */

/*************************************************************************/
/* Function: put_FullScreenMode                                          */
/* Description: Sets the full screen mode.                               */ 
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_FullScreenMode(VARIANT_BOOL fFullScreenMode){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

	    IVideoWindow* pVW;

        if(!m_pDvdGB){

            return(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

        if (SUCCEEDED(hr) && pVW != NULL){       

           hr =  pVW->put_FullScreenMode(fFullScreenMode);

           pVW->Release();
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function put_FullScreenMode */

/*************************************************************************/
/* Function: SetDDrawExcl                                                */
/* Descirption: Sets up Overlays Mixer DDraw interface. That way we avoid*/
/* drawing using IVideo Window and the control, can be windowless.       */
/*************************************************************************/
HRESULT CMSWebDVD::SetDDrawExcl(){

	HRESULT hr = S_OK;

	HWND hwndBrowser = NULL;

	hr = GetParentHWND(&hwndBrowser);

	if(FAILED(hr)){

		return(hr);
	}/* end of if statement */

	if(hwndBrowser == NULL){

		hr = E_POINTER;
		return(E_POINTER);
	}/* end of if statement */

	HDC hDC = ::GetWindowDC(hwndBrowser);

	if(hDC == NULL){

		hr = E_UNEXPECTED;	
		return(hr);
	}/* end of if statement */

	LPDIRECTDRAW pDDraw = NULL;

	hr = DirectDrawCreate(NULL, &pDDraw, NULL);

	if(FAILED(hr)){

        ::ReleaseDC(hwndBrowser, hDC);
		return(hr);
	}/* end of if statement */

	LPDIRECTDRAW4 pDDraw4 = NULL;

	hr = pDDraw->QueryInterface(IID_IDirectDraw4, (LPVOID*)&pDDraw4);

	pDDraw->Release();
		
	if(FAILED(hr)){

        ::ReleaseDC(hwndBrowser, hDC);
		return(hr);
	}/* end of if statement */

	LPDIRECTDRAWSURFACE4 pDDS4 = NULL;

	pDDraw4->GetSurfaceFromDC(hDC, &pDDS4);

	pDDraw4->Release();
    ::ReleaseDC(hwndBrowser, hDC);

	if(FAILED(hr)){

		return(hr);
	}/* end of if statement */

	LPDIRECTDRAW4 pDDrawIE = NULL;

	hr = pDDS4->GetDDInterface((LPVOID*)&pDDrawIE);

	pDDS4->Release();
	pDDrawIE->Release();

	return  HandleError(hr);
}/* end of function SetDDrawExcl */

/*************************************************************************/
/* Function: PlayBackwards                                               */
/* Description: Rewind, set to play state to start with.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayBackwards(double dSpeed, VARIANT_BOOL fDoNotReset){

    HRESULT hr = S_OK;

    try {
        if(VARIANT_FALSE != fDoNotReset){

            m_fResetSpeed = false;
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        m_fResetSpeed = true;
        
        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayBackwards(dSpeed,0,0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function BackwardScan */

/*************************************************************************/
/* Function: PlayForwards                                                */
/* Description: Set DVD in fast forward mode.                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayForwards(double dSpeed, VARIANT_BOOL fDoNotReset){

    HRESULT hr = S_OK;

    try {
        if(VARIANT_FALSE != fDoNotReset){

            m_fResetSpeed = false;
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        m_fResetSpeed = true;

        if(!m_pDvdCtl2){
        
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayForwards(dSpeed,0,0));

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayForwards */

/*************************************************************************/
/* Function: Resume                                                      */
/* Description: Resume from menu. We put our self in play state, just    */
/* in the case we were not in it. This might lead to some unexpected     */
/* behavior in case when we stopped and the tried to hit this button     */
/* but I think in this case might be appropriate as well.                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Resume(){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
    
        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
                    
        hr = m_pDvdCtl2->Resume(cdwDVDCtrlFlags, 0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Resume */

/*************************************************************************/
/* Function: ShowMenu                                                    */
/* Description: Invokes specific menu call.                              */
/* We set our selfs to play mode so we can execute this in case we were  */
/* paused or stopped.                                                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ShowMenu(DVDMenuIDConstants MenuID){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->ShowMenu((tagDVD_MENU_ID)MenuID, cdwDVDCtrlFlags, 0)); //!!keep in sync, or this cast will not work
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function MenuCall */

/*************************************************************************/
/* Function: get_PlayState                                               */
/* Description: Needs to be expanded for DVD, using their base APIs,     */
/* get DVD specific states as well.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_PlayState(DVDFilterState *pFilterState){

    HRESULT hr = S_OK;

    try {

	    if (NULL == pFilterState){

            throw(E_POINTER);         
        }/* end of if statement */

        if(!m_fInitialized){

           *pFilterState =  dvdState_Unitialized;
           return(hr);
        }/* end of if statement */
       
        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        OAFilterState fs;

        hr = m_pMC->GetState(cgStateTimeout, &fs);

        *pFilterState = (DVDFilterState)fs; // !!keep in sync, or this cast will not work
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of get_PlayState */

/*************************************************************************/
/* Function: SelectUpperButton                                           */
/* Description: Selects the upper button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectUpperButton(){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Upper);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectUpperButton */

/*************************************************************************/
/* Function: SelectLowerButton                                           */
/* Description: Selects the lower button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectLowerButton(){

	HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
        
        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Lower);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLowerButton */

/*************************************************************************/
/* Function: SelectLeftButton                                            */
/* Description: Selects the left button on DVD Menu.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectLeftButton(){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
    
        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Left);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLeftButton */

/*************************************************************************/
/* Function: SelectRightButton                                           */
/* Description: Selects the right button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectRightButton(){

	HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Right);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return  HandleError(hr);
}/* end of function SelectRightButton */

/*************************************************************************/
/* Function: ActivateButton                                              */
/* Description: Activates the selected button on DVD Menu.               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ActivateButton(){

	HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        hr = m_pDvdCtl2->ActivateButton();
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ActivateButton */

/*************************************************************************/
/* Function: SelectAndActivateButton                                     */
/* Description: Selects and activates the specific button.               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectAndActivateButton(long lButton){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){
            throw(hr);
        }

        if(lButton < 0){   
            throw(E_INVALIDARG);        
        }

        if( !m_pDvdCtl2){            
            throw(E_UNEXPECTED);
        }
            
        hr = m_pDvdCtl2->SelectAndActivateButton((ULONG)lButton);
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return  HandleError(hr);
}/* end of function SelectAndActivateButton */

/*************************************************************************/
/* Function: PlayNextChapter                                             */
/* Description: Goes to next chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayNextChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayNextChapter(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayNextChapter */

/*************************************************************************/
/* Function: PlayPrevChapter                                             */
/* Description: Goes to previous chapter                                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayPrevChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayPrevChapter(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayPrevChapter */

/*************************************************************************/
/* Function: ReplayChapter                                               */
/* Description: Halts playback and restarts the playback of current      */
/* program inside PGC.                                                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ReplayChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->ReplayChapter(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ReplayChapter */

/*************************************************************************/
/* Function: Return                                                      */
/* Description: Used in menu to return into prevoius menu.               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ReturnFromSubmenu(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->ReturnFromSubmenu(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Return */

/*************************************************************************/
/* Function: PlayChapter                                                 */
/* Description: Does chapter search. Waits for FP_DOM to pass and initi  */
/* lizes the graph as the other smar routines.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayChapter(LONG lChapter){

    HRESULT hr = S_OK;

    try {
	    if(lChapter < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayChapter(lChapter, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function PlayChapter */

/*************************************************************************/
/* Function: GetAudioLanguage                                            */
/* Description: Returns audio language associated with a stream.         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetAudioLanguage(LONG lStream, VARIANT_BOOL fFormat, BSTR *strAudioLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strAudioLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        USES_CONVERSION;
        LCID lcid;                
        hr = m_pDvdInfo2->GetAudioLanguage(lStream, &lcid);
    
        if (SUCCEEDED( hr )){

            // count up the streams for the same LCID like English 2
            
            pszString = m_LangID.GetLangFromLangID((WORD)PRIMARYLANGID(LANGIDFROMLCID(lcid)));
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_AUDIOTRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */

            DVD_AudioAttributes attr;
            if(SUCCEEDED(m_pDvdInfo2->GetAudioAttributes(lStream, &attr))){
                
                // If want audio format param is set
                if (fFormat != VARIANT_FALSE) {
                    switch(attr.AudioFormat){
                    case DVD_AudioFormat_AC3: AppendString(pszString, IDS_DOLBY, MAX_PATH ); break; 
                    case DVD_AudioFormat_MPEG1: AppendString(pszString, IDS_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG1_DRC: AppendString(pszString, IDS_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2: AppendString(pszString, IDS_MPEG2, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2_DRC: AppendString(pszString, IDS_MPEG2, MAX_PATH); break;
                    case DVD_AudioFormat_LPCM: AppendString(pszString, IDS_LPCM, MAX_PATH ); break;
                    case DVD_AudioFormat_DTS: AppendString(pszString, IDS_DTS, MAX_PATH ); break;
                    case DVD_AudioFormat_SDDS: AppendString(pszString, IDS_SDDS, MAX_PATH ); break;
                    }/* end of switch statement */                    
                }

                switch(attr.LanguageExtension){
                case DVD_AUD_EXT_NotSpecified:
                case DVD_AUD_EXT_Captions:     break; // do not add anything
                case DVD_AUD_EXT_VisuallyImpaired:   AppendString(pszString, IDS_AUDIO_VISUALLY_IMPAIRED, MAX_PATH ); break;      
                case DVD_AUD_EXT_DirectorComments1:  AppendString(pszString, IDS_AUDIO_DIRC1, MAX_PATH ); break;
                case DVD_AUD_EXT_DirectorComments2:  AppendString(pszString, IDS_AUDIO_DIRC2, MAX_PATH ); break;
                }/* end of switch statement */

            }/* end of if statement */

            *strAudioLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strAudioLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetAudioLanguage */

/*************************************************************************/
/* Function: StillOff                                                    */
/* Description: Turns the still off, what that can be used for is a      */
/* mistery to me.                                                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::StillOff(){

	if(!m_pDvdCtl2){

        return E_UNEXPECTED;
    }/* end of if statement */

    return HandleError(m_pDvdCtl2->StillOff());
}/* end of function StillOff */

/*************************************************************************/
/* Function: PlayTitle                                                   */
/* Description: If fails waits for FP_DOM to pass and tries later.       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayTitle(LONG lTitle){

    HRESULT hr = S_OK;

    try {
        if(0 > lTitle){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY
        
        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        long lNumTitles = 0;
        hr = get_TitlesAvailable(&lNumTitles);
        if(FAILED(hr)){
            throw hr;
        }
        
        if(lTitle > lNumTitles){
            throw E_INVALIDARG;
        }
        
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayTitle(lTitle, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayTitle */

/*************************************************************************/
/* Function: GetSubpictureLanguage                                       */
/* Description: Gets subpicture language.                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetSubpictureLanguage(LONG lStream, BSTR* strSubpictLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strSubpictLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(0 > lStream){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if((lStream > cgDVD_MAX_SUBPICTURE 
            && lStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID lcid;
        hr = m_pDvdInfo2->GetSubpictureLanguage(lStream, &lcid);
        
        if (SUCCEEDED( hr )){

            pszString = m_LangID.GetLangFromLangID((WORD)PRIMARYLANGID(LANGIDFROMLCID(lcid)));
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_SUBPICTURETRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */
#if 0
            DVD_SubpictureATR attr;
            if(SUCCEEDED(m_pDvdInfo2->GetSubpictureAttributes(lStream, &attr))){

            switch(attr){
                case DVD_SP_EXT_NotSpecified:
                case DVD_SP_EXT_Caption_Normal:  break;

                case DVD_SP_EXT_Caption_Big:  AppendString(pszString, IDS_CAPTION_BIG, MAX_PATH ); break; 
                case DVD_SP_EXT_Caption_Children: AppendString(pszString, IDS_CAPTION_CHILDREN, MAX_PATH ); break; 
                case DVD_SP_EXT_CC_Normal: AppendString(pszString, IDS_CLOSED_CAPTION, MAX_PATH ); break;                 
                case DVD_SP_EXT_CC_Big: AppendString(pszString, IDS_CLOSED_CAPTION_BIG, MAX_PATH ); break; 
                case DVD_SP_EXT_CC_Children: AppendString(pszString, IDS_CLOSED_CAPTION_CHILDREN, MAX_PATH ); break; 
                case DVD_SP_EXT_Forced: AppendString(pszString, IDS_CLOSED_CAPTION_FORCED, MAX_PATH ); break; 
                case DVD_SP_EXT_DirectorComments_Normal: AppendString(pszString, IDS_DIRS_COMMNETS, MAX_PATH ); break; 
                case DVD_SP_EXT_DirectorComments_Big: AppendString(pszString, IDS_DIRS_COMMNETS_BIG, MAX_PATH ); break; 
                case DVD_SP_EXT_DirectorComments_Children: AppendString(pszString, IDS_DIRS_COMMNETS_CHILDREN, MAX_PATH ); break; 
            }/* end of switch statement */
#endif

            USES_CONVERSION;
            *strSubpictLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strSubpictLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetSubpictureLanguage */

/*************************************************************************/
/* Function: PlayChapterInTitle                                          */
/* Description: Plays from the specified chapter without stopping        */
/* THIS NEEDS TO BE ENHANCED !!! Current implementation and queing       */
/* into the message loop is insufficient!!! TODO.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayChapterInTitle(LONG lTitle, LONG lChapter){

    HRESULT hr = S_OK;

    try {
        
        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
                
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayChapterInTitle(lTitle, lChapter, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChapterInTitle */

/*************************************************************************/
/* Function: PlayChapterAutoStop                                         */
/* Description: Plays set ammount of chapters.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayChaptersAutoStop(LONG lTitle, LONG lChapter, 
                                          LONG lChapterCount){

    HRESULT hr = S_OK;

    try {        

        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapterCount > cgDVDMAX_CHAPTER_COUNT) || (lChapterCount < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
                
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayChaptersAutoStop(lTitle, lChapter, lChapterCount, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChaptersAutoStop */

/*************************************************************************/
/* Function: PlayPeriodInTitleAutoStop                                   */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayPeriodInTitleAutoStop(long lTitle, 
                                                  BSTR strStartTime, BSTR strEndTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strStartTime){

            throw(E_POINTER);
        }/* end of if statement */

        if(NULL == strEndTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcStartTimeCode;
        hr = Bstr2DVDTime(&tcStartTimeCode, &strStartTime);

        if(FAILED(hr)){

            throw (hr);
        }

        DVD_HMSF_TIMECODE tcEndTimeCode;

        Bstr2DVDTime(&tcEndTimeCode, &strEndTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayPeriodInTitleAutoStop(lTitle, &tcStartTimeCode,
                &tcEndTimeCode,  cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayPeriodInTitleAutoStop */

/*************************************************************************/
/* Function: PlayAtTimeInTitle                                           */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayAtTimeInTitle(long lTitle, BSTR strTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        hr = Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayAtTimeInTitle(lTitle, &tcTimeCode, cdwDVDCtrlFlags, 0));

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTimeInTitle */

/*************************************************************************/
/* Function: PlayAtTime                                                  */
/* Description: TimeSearch, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayAtTime(BSTR strTime){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayAtTime( &tcTimeCode, cdwDVDCtrlFlags, 0));

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTime */

/*************************************************************************/
/* Function: get_CurrentTitle                                            */
/* Description: Gets current title.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentTitle(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

         DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.TitleNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentTitle */

/*************************************************************************/
/* Function: get_CurrentChapter                                          */
/* Description: Gets current chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentChapter(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.ChapterNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentChapter */

/*************************************************************************/
/* Function: get_FramesPerSecond                                         */
/* Description: Gets number of frames per second.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_FramesPerSecond(long *pVal){

    HRESULT hr = S_OK;

    try {       
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

         DVD_PLAYBACK_LOCATION2 dvdLocation;

        hr = m_pDvdInfo2->GetCurrentLocation(&dvdLocation);

        // we handle right now only 25 and 30 fps at the moment
		if( dvdLocation.TimeCodeFlags & DVD_TC_FLAG_25fps ) {
			*pVal = 25;
		} else if( dvdLocation.TimeCodeFlags & DVD_TC_FLAG_30fps ) {
			*pVal = 30;
		} else {
			// unknown
			*pVal = 0;
		}/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_FramesPerSecond */

/*************************************************************************/
/* Function: get_CurrentTime                                             */
/* Description: Gets current time.                                       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentTime(BSTR *pVal){

    HRESULT hr = S_OK;

    try {       
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        hr = m_pDvdInfo2->GetCurrentLocation(&dvdLocation);
        
        DVDTime2bstr(&(dvdLocation.TimeCode), pVal);          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentTime */

/*************************************************************************/
/* Function: get_DVDDirectory                                            */
/* Description: Gets the root of the DVD drive.                          */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DVDDirectory(BSTR *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        WCHAR szRoot[MAX_PATH];
        ULONG ulActual;

        hr = m_pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

        *pVal = ::SysAllocString(szRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_DVDDirectory */

/*************************************************************************/
/* Function: put_DVDDirectory                                            */
/* Description: Sets the root for DVD control.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_DVDDirectory(BSTR bstrRoot){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        if(!m_pDvdCtl2){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SetDVDDirectory(bstrRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function put_DVDDirectory */

/*************************************************************************/
/* Function: get_CurrentDomain                                           */
/* Description: gets current DVD domain.                                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentDomain(long *plDomain){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(NULL == plDomain){

            throw(E_POINTER);
        }/* end of if statememt */

        hr = m_pDvdInfo2->GetCurrentDomain((DVD_DOMAIN *)plDomain);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDomain */

/*************************************************************************/
/* Function: get_CurrentDiscSide                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentDiscSide(long *plDiscSide){

    HRESULT hr = S_OK;

    try {    	

        if(NULL == plDiscSide){

            throw(E_POINTER);
        }/* end of if statement */
        
        ULONG ulNumOfVol;
        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
                                            &ulThisVolNum, 
                                            &discSide, 
                                            &ulNumOfTitles);
        *plDiscSide = discSide;
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDiscSide */

/*************************************************************************/
/* Function: get_CurrentVolume                                           */
/* Description: Gets current volume.                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentVolume(long *plVolume){

    HRESULT hr = S_OK;

    try {    	
        if(NULL == plVolume){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulNumOfVol;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
                                              (ULONG*)plVolume, 
                                               &discSide, 
                                               &ulNumOfTitles);
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentVolume */

/*************************************************************************/
/* Function: get_VolumesAvailable                                        */
/* Description: Gets total number of volumes available.                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_VolumesAvailable(long *plNumOfVol){

    HRESULT hr = S_OK;

    try {    	
    
        if(NULL == plNumOfVol){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDVDVolumeInfo( (ULONG*)plNumOfVol, 
                                                    &ulThisVolNum, 
                                                    &discSide, 
                                                    &ulNumOfTitles);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_VolumesAvailable */

/*************************************************************************/
/* Function: get_CurrentSubpictureStream                                 */
/* Description: Gets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentSubpictureStream(long *plSubpictureStream){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, (ULONG*)plSubpictureStream, &bIsDisabled ));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentSubpictureStream */

/*************************************************************************/
/* Function: put_CurrentSubpictureStream                                 */
/* Description: Sets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentSubpictureStream(long lSubpictureStream){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if( lSubpictureStream < cgDVD_MIN_SUBPICTURE 
            || (lSubpictureStream > cgDVD_MAX_SUBPICTURE 
            && lSubpictureStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */
         
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectSubpictureStream(lSubpictureStream,0,0));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // now enabled the subpicture stream if it is not enabled
        ULONG ulStraemsAvial = 0L, ulCurrentStrean = 0L;
        BOOL fDisabled = TRUE;
        hr = m_pDvdInfo2->GetCurrentSubpicture(&ulStraemsAvial, &ulCurrentStrean, &fDisabled);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(TRUE == fDisabled){

            hr = m_pDvdCtl2->SetSubpictureState(TRUE,0,0); //turn it on
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function put_CurrentSubpictureStream */

/*************************************************************************/
/* Function: get_SubpictureOn                                            */
/* Description: Gets the current subpicture status On or Off             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_SubpictureOn(VARIANT_BOOL *pfDisplay){

    HRESULT hr = S_OK;

    try {
        if(NULL == pfDisplay){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL fDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &fDisabled))
    
        if(SUCCEEDED(hr)){

            *pfDisplay = fDisabled == FALSE ? VARIANT_TRUE : VARIANT_FALSE; // compensate for -1 true in OLE
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureOn */

/*************************************************************************/
/* Function: put_SubpictureOn                                            */
/* Description: Turns the subpicture On or Off                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_SubpictureOn(VARIANT_BOOL fDisplay){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &bIsDisabled ));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        BOOL bDisplay = fDisplay == VARIANT_FALSE ? FALSE : TRUE; // compensate for -1 true in OLE

        hr = m_pDvdCtl2->SetSubpictureState(bDisplay,0,0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function put_SubpictureOn */

/*************************************************************************/
/* Function: get_SubpictureStreamsAvailable                              */
/* Description: gets the number of streams available.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_SubpictureStreamsAvailable(long *plStreamsAvailable){

    HRESULT hr = S_OK;

    try {
	    if (NULL == plStreamsAvailable){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulSubpictureStream = 0L;
        *plStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture((ULONG*)plStreamsAvailable, &ulSubpictureStream, &bIsDisabled));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureStreamsAvailable */

/*************************************************************************/
/* Function: get_TotalTitleTime                                          */
/* Description: Gets total time in the title.                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_TotalTitleTime(BSTR *pTime){

    HRESULT hr = S_OK;

    try {
        if(NULL == pTime){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_HMSF_TIMECODE tcTime;
        ULONG ulFlags;	// contains 30fps/25fps
        hr =  m_pDvdInfo2->GetTotalTitleTime(&tcTime, &ulFlags);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = DVDTime2bstr(&tcTime, pTime);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_TotalTitleTime */ 

/*************************************************************************/
/* Function: get_CurrentCCService                                        */
/* Description: Gets current closed caption service.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentCCService(long *plService){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(NULL == plService){

            throw(E_POINTER);
        }/* end of if statement */            
     
        CComPtr<IAMLine21Decoder> pLine21Dec;
        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */
    
        AM_LINE21_CCSERVICE Service;
        RETRY_IF_IN_FPDOM(pLine21Dec->GetCurrentService(&Service));

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plService = (ULONG)Service;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_CurrentCCService */

/*************************************************************************/
/* Function: put_CurrentCCService                                        */
/* Description: Sets current closed caption service.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentCCService(long lService){

    HRESULT hr = S_OK;

    try {        
        if(lService < 0){

            throw(E_INVALIDARG);       
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);            
        }/* end of if statement */

        CComPtr<IAMLine21Decoder> pLine21Dec;

        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */
    
        RETRY_IF_IN_FPDOM(pLine21Dec->SetCurrentService((AM_LINE21_CCSERVICE)lService));		
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_CurrentCCService */

/*************************************************************************/
/* Function: get_CurrentButton                                           */
/* Description: Gets currently selected button.                          */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentButton(long *plCurrentButton){

    HRESULT hr = S_OK;

    try {
        if(NULL == plCurrentButton){

            throw(E_POINTER);
        }/* end of if statement */            

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumButtons = 0L;
        *plCurrentButton = 0;

        hr = m_pDvdInfo2->GetCurrentButton(&ulNumButtons, (ULONG*)plCurrentButton);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_CurrentButton */

/*************************************************************************/
/* Function: get_ButtonsAvailable                                        */
/* Description: Gets the count of the available buttons.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ButtonsAvailable(long *plNumButtons){

    HRESULT hr = S_OK;

    try {
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentButton = 0L;

        hr = m_pDvdInfo2->GetCurrentButton((ULONG*)plNumButtons, &ulCurrentButton);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_ButtonsAvailable */

/*************************************************************************/
/* Function: get_CCActive                                                */
/* Description: Gets the state of the closed caption service.            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CCActive(VARIANT_BOOL *fState){

    HRESULT hr = S_OK;

    try {        
        if(NULL == fState ){

            throw(E_POINTER);            
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){
        
            throw(E_UNEXPECTED);            
        }/* end of if statement */

        CComPtr<IAMLine21Decoder> pLine21Dec;
        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);
    
        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        AM_LINE21_CCSTATE State;
        RETRY_IF_IN_FPDOM(pLine21Dec->GetServiceState(&State));

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(AM_L21_CCSTATE_On == State){

            *fState = VARIANT_TRUE; // OLE TRUE
        }
        else {

            *fState = VARIANT_FALSE;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CCActive */

/*************************************************************************/
/* Function: put_CCActive                                                */
/* Description: Sets the ccActive state                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CCActive(VARIANT_BOOL fState){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

	    CComPtr<IAMLine21Decoder> pLine21Dec;
        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);
    
        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        AM_LINE21_CCSTATE ccState = (fState == VARIANT_FALSE ? AM_L21_CCSTATE_Off: AM_L21_CCSTATE_On);

        RETRY_IF_IN_FPDOM(pLine21Dec->SetServiceState(ccState));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CCActive */

/*************************************************************************/
/* Function: get_CurrentAngle                                            */
/* Description: Gets current angle.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentAngle(long *plAngle){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAngle){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulAnglesAvailable = 0;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAngle(&ulAnglesAvailable, (ULONG*)plAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAngle */

/*************************************************************************/
/* Function: put_CurrentAngle                                            */
/* Description: Sets the current angle (different DVD angle track.)      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentAngle(long lAngle){

    HRESULT hr = S_OK;

    try {
        if( lAngle < cgDVD_MIN_ANGLE || lAngle > cgDVD_MAX_ANGLE ){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
      
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectAngle(lAngle,0,0));          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAngle */

/*************************************************************************/
/* Function: get_AnglesAvailable                                         */
/* Description: Gets the number of angles available.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_AnglesAvailable(long *plAnglesAvailable){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAnglesAvailable){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulCurrentAngle = 0;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAngle((ULONG*)plAnglesAvailable, &ulCurrentAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AnglesAvailable */

/*************************************************************************/
/* Function: get_AudioStreamsAvailable                                   */
/* Description: Gets number of available Audio Streams                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_AudioStreamsAvailable(long *plNumAudioStreams){

    HRESULT hr = S_OK;

    try {
        if(NULL == plNumAudioStreams){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentStream;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAudio((ULONG*)plNumAudioStreams, &ulCurrentStream));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AudioStreamsAvailable */

/*************************************************************************/
/* Function: get_CurrentAudioStream                                      */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentAudioStream(long *plCurrentStream){

    HRESULT hr = S_OK;

    try {
        if(NULL == plCurrentStream){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumAudioStreams;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAudio(&ulNumAudioStreams, (ULONG*)plCurrentStream ));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAudioStream */

/*************************************************************************/
/* Function: put_CurrentAudioStream                                      */
/* Description: Changes the current audio stream.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentAudioStream(long lAudioStream){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectAudioStream(lAudioStream,0,0));            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAudioStream */

/*************************************************************************/
/* Function: get_ColorKey                                                */
/* Description: Gets the current color key. Goes to the dshow if we have */
/* a graph otherwise just gets the cached color key.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ColorKey(long *pClr){

    HRESULT hr = S_OK;

    try {
        if( NULL == pClr ){

            throw(E_POINTER);
        }/* end of if statement */

        *pClr = 0; // cleanup the variable

        COLORREF clr;
        ::ZeroMemory(&clr, sizeof(COLORREF));
        
        hr = GetColorKey(&clr); // we get COLORREF HERE and CANNOT be palette index
        
        HWND hwnd = ::GetDesktopWindow();
        HDC hdc = ::GetWindowDC(hwnd);

        if(NULL == hdc){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        clr = ::GetNearestColor(hdc, clr);        
        ::ReleaseDC(hwnd, hdc);
    
        // handles only case when getting RGB BACK, which is taken care of in the GetColorKey function
        *pClr = ((OLE_COLOR)(((BYTE)(GetBValue(clr))|((WORD)((BYTE)(GetGValue(clr)))<<8))|(((DWORD)(BYTE)(GetRValue(clr)))<<16)));

        if(FAILED(hr)){

            if(false == m_fInitialized){

                *pClr = ((OLE_COLOR)(((BYTE)(GetBValue(m_clrColorKey))|((WORD)((BYTE)(GetGValue(m_clrColorKey)))<<8))|(((DWORD)(BYTE)(GetRValue(m_clrColorKey)))<<16))); // give them our default value
                throw(S_FALSE); // we are not initialized yet, so probably we are called from property bag
            }/* end of if statement */
            throw(hr);
        }/* end of if statement */

        m_clrColorKey = clr; // cache up the value
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);	
}/* end of function get_ColorKey */

/*************************************************************************/
/* Function: put_ColorKey                                                */
/* Description: Sets the color key.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_ColorKey(long clr){

	HRESULT hr = S_OK;

    try {                    

#if 1
        HWND hwnd = ::GetDesktopWindow();
        HDC hdc = ::GetWindowDC(hwnd);

        if(NULL == hdc){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE){
            
            clr = MAGENTA_COLOR_KEY;                            
        }/* end of if statement */

        ::ReleaseDC(hwnd, hdc);
#endif        
        BYTE r = ((BYTE)((clr)>>16));
        BYTE g = (BYTE)(((WORD)(clr)) >> 8);
        BYTE b = ((BYTE)(clr));
        COLORREF clrColorKey = RGB(r, g, b); // convert to color ref

        hr = SetColorKey(clrColorKey);

        if(FAILED(hr)){
           
            if(false == m_fInitialized){

                m_clrColorKey = clrColorKey; // cache up the value for later                
                hr = S_FALSE;
            }/* end of if statement */

            throw(hr);
        }/* end of if statement */
#if 1
        hr = GetColorKey(&m_clrColorKey);
#endif

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_ColorKey */

/*************************************************************************/
/* Function: put_BackColor                                               */
/* Description: Put back color is sinonymous to ColorKey when in the     */
/* windowless mode.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_BackColor(VARIANT clrBackColor){

    HRESULT hr = S_OK;

    try {

        VARIANT dest;
        VariantInit(&dest);
        hr = VariantChangeTypeEx(&dest, &clrBackColor, 0, 0, VT_COLOR);
        if (FAILED(hr))
            throw hr;

        hr = CStockPropImpl<CMSWebDVD, IMSWebDVD, 
            &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>::put_BackColor(dest.lVal);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function put_BackColor */

/*************************************************************************/
/* Function: get_BackColor                                               */
/* Description: Put back color is sinonymous to ColorKey when in the     */
/* windowless mode.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_BackColor(VARIANT* pclrBackColor){

    HRESULT hr = S_OK;

    try {

        if ( NULL == pclrBackColor) {
            throw (E_POINTER);
        }

        OLE_COLOR clrColor;

        hr = CStockPropImpl<CMSWebDVD, IMSWebDVD, 
            &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>::get_BackColor(&clrColor);

        if (FAILED(hr))
            throw(hr);

        VariantInit(pclrBackColor);
        
        pclrBackColor->vt = VT_COLOR;
        pclrBackColor->lVal = clrColor;

	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function get_BackColor */

/*************************************************************************/
/* Function: get_ReadyState                                               */
/* Description: Put back color is sinonymous to ColorKey when in the     */
/* windowless mode.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ReadyState(LONG *pVal){

    HRESULT hr = S_OK;

    try {

        if (NULL == pVal) {
            throw (E_POINTER);
        }

        hr = CStockPropImpl<CMSWebDVD, IMSWebDVD, 
            &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>::get_ReadyState(pVal);

        if (FAILED(hr))
            throw(hr);

	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function get_ReadyState */

/*************************************************************************/
/* Function: UOPValid                                                    */
/* Description: Tells if UOP is valid or not, valid means the feature is */
/* turned on.                                                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::UOPValid(long lUOP, VARIANT_BOOL *pfValid){

    HRESULT hr = S_OK;

    try {
        if (NULL == pfValid){
            
            throw(E_POINTER);
        }/* end of if statement */

        if ((lUOP > 24) || (lUOP < 0)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulUOPS = 0;
        hr = m_pDvdInfo2->GetCurrentUOPS(&ulUOPS);

        *pfValid = ulUOPS & (1 << lUOP) ? VARIANT_FALSE : VARIANT_TRUE;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function UOPValid */

/*************************************************************************/
/* Function:  GetGPRM                                                    */
/* Description: Gets the GPRM at specified index                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetGPRM(long lIndex, short *psGPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psGPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        GPRMARRAY gprm;
        int iArraySize = sizeof(GPRMARRAY)/sizeof(gprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */
    
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        hr = m_pDvdInfo2->GetAllGPRMs(&gprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *psGPRM = gprm[lIndex];        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetGPRM */

/*************************************************************************/
/* Function: GetDVDTextNumberOfLanguages                                 */
/* Description: Retrieves the number of languages available.             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextNumberOfLanguages(long *plNumOfLangs){

    HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfLangs){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulNumOfLangs;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextNumberOfLanguages(&ulNumOfLangs));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfLangs = ulNumOfLangs;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfLanguages */

/*************************************************************************/
/* Function: GetDVDTextNumberOfStrings                                   */
/* Description: Gets the number of strings in the partical language.     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextNumberOfStrings(long lLangIndex, long *plNumOfStrings){

HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfStrings){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfStrings = uNumOfStings;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfStrings */

/*************************************************************/
/* Name: GetDVDTextLanguageLCID
/* Description: Get the LCID of an index of the DVD texts
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextLanguageLCID(long lLangIndex, long *lcid)
{
HRESULT hr = S_OK;

    try {
        if (NULL == lcid){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lcid = wLangCode;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextLanguageLCID */

/*************************************************************************/
/* Function: GetDVDtextString                                            */
/* Description: Gets the DVD Text string at specific location.           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextString(long lLangIndex, long lStringIndex, BSTR *pstrText){

    HRESULT hr = S_OK;

    try {
        if (NULL == pstrText){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulSize; 
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulSize, &type));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        if (ulSize == 0) {
            *pstrText = ::SysAllocString(L"");
        }

        else {
            // got the length so lets allocate a buffer of that size
            WCHAR* wstrBuff = new WCHAR[ulSize];
            
            ULONG ulActualSize;
            hr = m_pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  wstrBuff, ulSize, &ulActualSize, &type);
            
            ATLASSERT(ulActualSize == ulSize);
            
            if(FAILED(hr)){
                
                delete [] wstrBuff;
                throw(hr);
            }/* end of if statement */
            
            *pstrText = ::SysAllocString(wstrBuff);
            delete [] wstrBuff;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDtextString */

/*************************************************************************/
/* Function: GetDVDTextStringType                                        */
/* Description: Gets the type of the string at the specified location.   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextStringType(long lLangIndex, long lStringIndex, DVDTextStringType *pType){

    HRESULT hr = S_OK;

    try {
        if (NULL == pType){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulTheSize;
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulTheSize, &type));

        if(SUCCEEDED(hr)){

            *pType = (DVDTextStringType) type;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextStringType */

/*************************************************************************/
/* Function: GetSPRM                                                     */
/* Description: Gets SPRM at the specific index.                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetSPRM(long lIndex, short *psSPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psSPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        SPRMARRAY sprm;                
        int iArraySize = sizeof(SPRMARRAY)/sizeof(sprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        hr = m_pDvdInfo2->GetAllSPRMs(&sprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        *psSPRM = sprm[lIndex];            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetSPRM */

/*************************************************************************/
/* Function: get_DVDUniqueID                                             */
/* Description: Gets the UNIQUE ID that identifies the string.           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DVDUniqueID(BSTR *pStrID){

    HRESULT hr = E_FAIL;

    try {
        // TODO: Be able to get m_pDvdInfo2 without initializing the graph
	    if (NULL == pStrID){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONGLONG ullUniqueID;

        hr = m_pDvdInfo2->GetDiscID(NULL, &ullUniqueID);
                                 
        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        //TODO: Get rid of the STDLIB call!!
        // taken out of WMP

        // Script can't handle a 64 bit value so convert it to a string.
        // Doc's say _ui64tow returns 33 bytes (chars?) max.
        // we'll use double that just in case...
        //
        WCHAR wszBuffer[66];
        _ui64tow( ullUniqueID, wszBuffer, 10);
        *pStrID = SysAllocString(wszBuffer);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_DVDUniqueID */

/*************************************************************************/
/* Function: get_EnableResetOnStop                                      */
/* Description: Gets the flag.                                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_EnableResetOnStop(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {

        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */
    
        *pVal = m_fEnableResetOnStop ? VARIANT_TRUE: VARIANT_FALSE;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_EnableResetOnStop */

/*************************************************************************/
/* Function: put_EnableResetOnStop                                      */
/* Description: Sets the flag. The flag is used only on stop and play.   */
/* Transitions.                                                          */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_EnableResetOnStop(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {

        BOOL fEnable = (VARIANT_FALSE == newVal) ? FALSE: TRUE;
        BOOL fEnableOld = m_fEnableResetOnStop;

        m_fEnableResetOnStop = fEnable;

        if(!m_pDvdCtl2){

            throw(S_FALSE); // we might not have initialized graph as of yet, but will
            // defer this to play state
        }/* end of if statement */

        hr = m_pDvdCtl2->SetOption(DVD_ResetOnStop, fEnable);

        if(FAILED(hr)){

            m_fEnableResetOnStop = fEnableOld; // restore the old state
        }/* end of if statement */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_EnableResetOnStop */

/*************************************************************************/
/* Function: get_Mute                                                    */
/* Description: Gets the mute state.                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_Mute(VARIANT_BOOL *pfMute){

    HRESULT hr = S_OK;

    try {
        if(NULL == pfMute){

            throw(E_POINTER);
        }/* end of if statement */

        *pfMute = m_bMute ? VARIANT_TRUE: VARIANT_FALSE;
                    
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_Mute */

/*************************************************************************/
/* Function: DShowToWaveV                                                */
/*************************************************************************/
inline DShowToWaveV(long x){

   FLOAT fy = (((FLOAT)x + (-cgVOLUME_MIN)) / (-cgVOLUME_MIN)) * cgWAVE_VOLUME_MAX;
   return((WORD)fy);
}/* end of function DShowToWaveV */

/*************************************************************************/
/* Function: WaveToDShowV                                                */ 
/*************************************************************************/
inline LONG WaveToDShowV(WORD y){

   FLOAT fx = ((FLOAT)y * (-cgVOLUME_MIN)) / cgWAVE_VOLUME_MAX + cgVOLUME_MIN;
   return((LONG)fx);
}/* end of function WaveToDShowV */

/*************************************************************************/
/* Function: MixerSetVolume                                              */
/*************************************************************************/
HRESULT MixerSetVolume(DWORD dwVolume){

    WORD wVolume = (WORD)(0xffff & dwVolume);

    HRESULT hr = S_OK;

    HMIXER hmx = NULL;

    UINT cMixer = ::mixerGetNumDevs();
    if (cMixer <= 0) {
        return E_FAIL;
    }
    
    BOOL bVolControlFound = FALSE;
    DWORD dwVolControlID = 0;

    for (UINT i=0; i<cMixer; i++) {
        
        if(::mixerOpen(&hmx, i, 0, 0, 0) != MMSYSERR_NOERROR){
            
            // Can't open device, try next device
            continue;
        }/* end of if statement */
        
        MIXERLINE mxl; 
        ::ZeroMemory(&mxl, sizeof(MIXERLINE));
        mxl.cbStruct = sizeof(MIXERLINE);
        mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;
        
        if(::mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE) != MMSYSERR_NOERROR){
            
            // Can't find a audio line to adjust the speakers, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        MIXERLINECONTROLS mxlc;
        ::ZeroMemory(&mxlc, sizeof(MIXERLINECONTROLS));
        mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
        mxlc.dwLineID = mxl.dwLineID;
        mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
        mxlc.cControls = 1;
        MIXERCONTROL mxc;
        ::ZeroMemory(&mxc, sizeof(MIXERCONTROL));
        mxc.cbStruct = sizeof(MIXERCONTROL);
        mxlc.cbmxctrl = sizeof(MIXERCONTROL);
        mxlc.pamxctrl = &mxc;
        
        if(::mixerGetLineControls((HMIXEROBJ) hmx, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE) != MMSYSERR_NOERROR){
            
            // Can't get volume control on the audio line, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        if(cgWAVE_VOLUME_MAX != mxc.Bounds.dwMaximum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        if(cgWAVE_VOLUME_MIN != mxc.Bounds.dwMinimum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        // Volume control found, break out loop
        bVolControlFound = TRUE;
        dwVolControlID = mxc.dwControlID;
        break;
    }/*end of for loop*/

    if (!bVolControlFound)
        return E_FAIL;

    MIXERCONTROLDETAILS mxcd;
    MIXERCONTROLDETAILS_SIGNED volStruct;

    ::ZeroMemory(&mxcd, sizeof(MIXERCONTROLDETAILS));
    mxcd.cbStruct = sizeof(MIXERCONTROLDETAILS);
    mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_SIGNED);
    mxcd.dwControlID = dwVolControlID;
    mxcd.paDetails = &volStruct;
    volStruct.lValue = wVolume;
    mxcd.cChannels = 1;

    if(::mixerSetControlDetails((HMIXEROBJ) hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE)  != MMSYSERR_NOERROR){

        ::mixerClose(hmx);
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    ::mixerClose(hmx);
    return(hr);
}/* end of fucntion MixerSetVolume */

/*************************************************************************/
/* Function: MixerGetVolume                                              */
/*************************************************************************/
HRESULT MixerGetVolume(DWORD& dwVolume){

    HRESULT hr = S_OK;

    HMIXER hmx = NULL;

    UINT cMixer = ::mixerGetNumDevs();
    if (cMixer <= 0) {
        return E_FAIL;
    }
    
    BOOL bVolControlFound = FALSE;
    DWORD dwVolControlID = 0;

    for (UINT i=0; i<cMixer; i++) {
        
        if(::mixerOpen(&hmx, i, 0, 0, 0) != MMSYSERR_NOERROR){
            
            // Can't open device, try next device
            continue;
        }/* end of if statement */
        
        MIXERLINE mxl; 
        ::ZeroMemory(&mxl, sizeof(MIXERLINE));
        mxl.cbStruct = sizeof(MIXERLINE);
        mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;
        
        if(::mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE) != MMSYSERR_NOERROR){
            
            // Can't find a audio line to adjust the speakers, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        MIXERLINECONTROLS mxlc;
        ::ZeroMemory(&mxlc, sizeof(MIXERLINECONTROLS));
        mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
        mxlc.dwLineID = mxl.dwLineID;
        mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
        mxlc.cControls = 1;
        MIXERCONTROL mxc;
        ::ZeroMemory(&mxc, sizeof(MIXERCONTROL));
        mxc.cbStruct = sizeof(MIXERCONTROL);
        mxlc.cbmxctrl = sizeof(MIXERCONTROL);
        mxlc.pamxctrl = &mxc;
        
        if(::mixerGetLineControls((HMIXEROBJ) hmx, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE) != MMSYSERR_NOERROR){
            
            // Can't get volume control on the audio line, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        if(cgWAVE_VOLUME_MAX != mxc.Bounds.dwMaximum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        if(cgWAVE_VOLUME_MIN != mxc.Bounds.dwMinimum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        // Volume control found, break out loop
        bVolControlFound = TRUE;
        dwVolControlID = mxc.dwControlID;
        break;
    }/*end of for loop*/

    if (!bVolControlFound)
        return E_FAIL;

    MIXERCONTROLDETAILS mxcd;
    MIXERCONTROLDETAILS_SIGNED volStruct;

    ::ZeroMemory(&mxcd, sizeof(MIXERCONTROLDETAILS));
    mxcd.cbStruct = sizeof(MIXERCONTROLDETAILS);
    mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_SIGNED);
    mxcd.dwControlID = dwVolControlID;
    mxcd.paDetails = &volStruct;
    mxcd.cChannels = 1;

    if(::mixerGetControlDetails((HMIXEROBJ) hmx, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE)  != MMSYSERR_NOERROR){

        ::mixerClose(hmx);
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    // the volStruct.lValue gets initialize via call to mixerGetControlDetails with mxcd.paDetails = &volStruct;
    dwVolume = volStruct.lValue;

    ::mixerClose(hmx);
    return(hr);
}/* end of function MixerGetVolume */

/*************************************************************************/
/* Function: get_IntVolume                                               */
/*************************************************************************/
HRESULT CMSWebDVD::get_IntVolume(LONG* plVolume){

    HRESULT hr = S_OK;

    if(m_pAudio){

        hr = m_pAudio->get_Volume(plVolume); // get the volume
    }
    else {

        DWORD dwVolume;
        hr = MixerGetVolume(dwVolume);

        if(FAILED(hr)){
            
            return(hr);
        }/* end of if statement */

        *plVolume = WaveToDShowV(LOWORD(dwVolume));
    }/* end of if statememt */

    return(hr);
}/* end of function get_VolumeHelper */

/*************************************************************************/
/* Function: put_IntVolume                                               */
/*************************************************************************/
HRESULT CMSWebDVD::put_IntVolume(long lVolume){

    HRESULT hr = S_OK;

    if(m_pAudio){

        hr = m_pAudio->put_Volume(lVolume);
    }
    else {

        WORD wVolume = WORD(DShowToWaveV(lVolume));
        // set left and right volume same for now
        DWORD dwVolume;
        dwVolume = ((DWORD)(((WORD)(wVolume)) | ((DWORD)((WORD)(wVolume))) << 16));

        hr = MixerSetVolume(dwVolume);
    }/* end of if statement */

    return(hr);
}/* end of function put_IntVolume */

/*************************************************************************/
/* Function: put_Mute                                                    */
/* Description: Gets the mute state.                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_Mute(VARIANT_BOOL newVal){

	HRESULT hr = E_FAIL;

    try {
        if(VARIANT_FALSE == newVal){
            // case when we are unmutting
            LONG lVolume;

            if(TRUE != m_bMute){

                hr = get_IntVolume(&lVolume); // get the volume
                
                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                if(cgVOLUME_MIN != lVolume){

                   // OK we are not really muted, so
                   // send little displesure the app
                   throw(S_FALSE);
                }/* end of if statement */

                // otherwise proceed normally and sync our flag
            }/* end of if statement */
            
            hr = put_IntVolume(m_lLastVolume);
            
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_bMute = FALSE; // reset our flag, that we are muted

        }
        else {
            // case when we are mutting
            LONG lVolume;
            hr = get_IntVolume(&lVolume); // get the volume

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_lLastVolume = lVolume; // store the volume  for when we are unmutting
            
            hr = put_IntVolume(cgVOLUME_MIN);
            
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_bMute = TRUE; // set the mute flage
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_Mute */

/*************************************************************************/
/* Function: get_Volume                                                  */
/* Description: Gets the volume.                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_Volume(long *plVolume){

	HRESULT hr = E_FAIL;

    try {
        if(NULL == plVolume){

            throw(E_POINTER);
        }/* end of if statement */        
        
        if(FALSE == m_bMute){

            hr = get_IntVolume(plVolume);
        } 
        else {
            // we are in mute state so save the volume for "unmuting"

            *plVolume = m_lLastVolume;
            hr = S_FALSE; // indicate we are sort of unhappy
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_Volume */

/*************************************************************************/
/* Function: put_Volume                                                  */
/* Description: Sets the volume.                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_Volume(long lVolume){

	HRESULT hr = E_FAIL;

    try {

        // cgVOLUME_MIN is max and cgVOLUME_MAX is min by value
        if(cgVOLUME_MIN > lVolume || cgVOLUME_MAX < lVolume){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if(TRUE == m_bMute){

            // unmute we are setting volume
            m_bMute = FALSE;
        }/* end of if statement */

        hr = put_IntVolume(lVolume);

        // this statement might be taken out but might prevent some error scenarious
        // when things are not working right.
        if(SUCCEEDED(hr)){

            m_lLastVolume = lVolume; // cash up the volume
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_Volume */

/*************************************************************************/
/* Function: get_Balance                                                 */
/* Description: Gets the balance.                                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_Balance(long *plBalance){

	HRESULT hr = E_FAIL;

    try {
        if(NULL == plBalance){

            throw(E_POINTER);
        }/* end of if statement */

        if(!m_pAudio){

            throw(E_NOTIMPL);
        }/* end of if statement */

        hr = m_pAudio->get_Balance(plBalance);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_Balance */

/*************************************************************************/
/* Function: put_Balance                                                 */
/* Description: Sets the balance.                                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_Balance(long lBalance){

	HRESULT hr = E_FAIL;

    try {

        if(cgBALANCE_MIN > lBalance || cgBALANCE_MAX < lBalance){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if(!m_pAudio){

            throw(E_NOTIMPL);
        }/* end of if statement */

        hr = m_pAudio->put_Balance(lBalance);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_Balance */

#if 1 // USE TOOLTIPS

/*************************************************************************/
/* Function: OnMouseToolTip                                              */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSWebDVD::OnMouseToolTip(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = FALSE;

    if (!m_hWndTip){

        return 0;
    }/* end of if statement */

    MSG mssg;

    HWND hwnd;

    HRESULT hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(1);
    }/* end of if statement */

    if(!m_bWndLess){

        HWND hwndTmp = hwnd;
        // Get the active movie window
        hwnd = ::GetWindow(hwndTmp, GW_CHILD);

        if (!::IsWindow(hwnd)){ 
        
            return S_FALSE;
        }/* end of if statement */
    }/* end of if statement */

    mssg.hwnd = hwnd;

    ATLASSERT(mssg.hwnd);
    mssg.message = msg;
    mssg.wParam = wParam;
    mssg.lParam = lParam;    
    ::SendMessage(m_hWndTip, TTM_RELAYEVENT, 0, (LPARAM) &mssg);     
    return 0;
}/* end of function OnMouseToolTip */

/*************************************************************/
/* Name: get_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_ToolTip(BSTR *pVal){

    HRESULT hr = S_OK;
    try {
        if (NULL == pVal) {
            
            throw (E_POINTER);
        } /* end of if statment */
        
        *pVal = m_bstrToolTip.Copy();
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_ToolTip */

/*************************************************************/
/* Name: put_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*  Cache the tooltip string if there is no window available */
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_ToolTip(BSTR newVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == newVal){

            throw(E_POINTER);
        }/* end of if statement */

        m_bstrToolTip = newVal;
        hr = CreateToolTip();
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_ToolTip */

/*************************************************************************/
/* Function: GetUsableWindow                                             */
/* Description:  Gets the window. If we are windowless we pass           */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HRESULT CMSWebDVD::GetUsableWindow(HWND* pWnd){

  HRESULT hr = S_OK;

    if(NULL == pWnd){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *pWnd = NULL;

    HWND hwnd; // temp

    if(m_bWndLess){

        hr = GetParentHWND(&hwnd);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */
    }
    else {

        hwnd = m_hWnd;
    }/* end of if statement */

    if(::IsWindow(hwnd)){

        *pWnd =  hwnd;
        hr = S_OK;
    }
    else {
        hr = E_UNEXPECTED;
    }/* end of if statement */

    return(hr);
}/* end of function GetUsableWindow */

/*************************************************************************/
/* Function: GetUsableWindow                                             */
/* Description:  Gets the window. If we are windowless we pass           */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HRESULT CMSWebDVD::GetClientRectInScreen(RECT* prc){

    HRESULT hr = S_OK;

    if(NULL == prc){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *prc = m_rcPos; //{m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom};

    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)prc, 2);

    return(hr);
}/* end of function GetClientRectInScreen */

/*************************************************************/
/* Name: CreateToolTip
/* Description: create a tool tip for the button
/*************************************************************/
HRESULT CMSWebDVD::CreateToolTip(void){

    HWND hwnd;

    HRESULT hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */
    
    if(!m_bWndLess){

        HWND hwndTmp = hwnd;
        // Get the active movie window
        hwnd = ::GetWindow(hwndTmp, GW_CHILD);

        if (!::IsWindow(hwnd)){ 
        
            return S_FALSE;
        }/* end of if statement */
    }/* end of if statement */

 	USES_CONVERSION;
    // If tool tip is to be created for the first time
    if (m_hWndTip == (HWND) NULL) {
        // Ensure that the common control DLL is loaded, and create 
        // a tooltip control. 
        InitCommonControls(); 
        
        m_hWndTip = CreateWindow(TOOLTIPS_CLASS, (LPTSTR) NULL, TTS_ALWAYSTIP, 
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
            hwnd, (HMENU) NULL, _Module.GetModuleInstance(), NULL); 
    }

    if (m_hWndTip == (HWND) NULL) 
        return S_FALSE; 
 
    TOOLINFO ti;    // tool information 
    ti.cbSize = sizeof(TOOLINFO); 
    ti.uFlags = 0; 
    ti.hwnd = hwnd; 
    ti.hinst = _Module.GetModuleInstance(); 
    ti.uId = (UINT) 0; 
  	ti.lpszText = OLE2T(m_bstrToolTip);

    // if the button is a windowed control, the tool tip is added to 
    // the button's own window, and the tool tip area should just be
    // the client rect of the window
    if (hwnd == m_hWnd)
        ::GetClientRect(hwnd, &ti.rect);

    // otherwise the tool tip is added to the closet windowed parent of
    // the button, and the tool tip area should be the relative postion
    // of the button in the parent window
    else {
        ti.rect.left = m_rcPos.left; 
        ti.rect.top = m_rcPos.top; 
        ti.rect.right = m_rcPos.right; 
        ti.rect.bottom = m_rcPos.bottom; 
    }

    if (!SendMessage(m_hWndTip, TTM_ADDTOOL, 0, 
        (LPARAM) (LPTOOLINFO) &ti)) 
        return S_FALSE; 

    // Set initial delay time
    put_ToolTipMaxWidth(m_nTTMaxWidth);

    VARIANT varTemp;
    VariantInit(&varTemp);

#ifdef _WIN64
    varTemp.vt = VT_I8;
#define VARTEMP_VAL  (varTemp.llVal)
#else
    varTemp.vt = VT_I4;
#define VARTEMP_VAL  (varTemp.lVal)
#endif

    VARTEMP_VAL = m_dwTTAutopopDelay;
    SetDelayTime(TTDT_AUTOPOP, varTemp); 

    VARTEMP_VAL = m_dwTTInitalDelay;
    SetDelayTime(TTDT_INITIAL, varTemp);

    VARTEMP_VAL = m_dwTTReshowDelay;
    SetDelayTime(TTDT_RESHOW, varTemp);

#undef VARTEMP_VAL

    return S_OK;
}/* end of function CreateToolTip */

/*************************************************************************/
/* Function: get_ToolTipMaxWidth                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ToolTipMaxWidth(long *pVal){

    HRESULT hr = S_OK;

    try {
        
        if (NULL == pVal) {

            throw E_POINTER;
        } /* end of if statement */
        
        if (NULL != m_hWndTip){
            
            // Return value is width in pixels. Safe to cast to 32-bit.
            m_nTTMaxWidth = (LONG)::SendMessage(m_hWndTip, TTM_GETMAXTIPWIDTH, 0, 0);
        }/* end of if statement */

        *pVal = m_nTTMaxWidth;
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_ToolTipMaxWidth */

/*************************************************************************/
/* Function: put_ToolTipMaxWidth                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_ToolTipMaxWidth(long newVal){

    HRESULT hr = S_OK;

    try {
        
        if (newVal <= 0) {

            throw E_INVALIDARG;
        } /* end of if statement */
        
        m_nTTMaxWidth = newVal;
        if (m_hWndTip){
            
            ::SendMessage(m_hWndTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)(INT) newVal);
        }/* end of if statement */
        
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_ToolTipMaxWidth */

/*************************************************************/
/* Name: GetDelayTime
/* Description: Get the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetDelayTime(long delayType, VARIANT *pVal){

    HRESULT hr = S_OK;
    LRESULT lDelay = 0; //BUGBUG: Is this a good initialization value?

    try {
        
        if (NULL == pVal) {

            throw E_POINTER;
        } /* end of if statement */
        
        if (delayType>TTDT_INITIAL || delayType<TTDT_RESHOW) {

            throw E_INVALIDARG;
        } /* end of if statement */
        
        if (m_hWndTip) {
            lDelay = SendMessage(m_hWndTip, TTM_GETDELAYTIME, 
            (WPARAM) (DWORD) delayType, 0);
        }  
        
        // else return cached values
        else {
            switch (delayType) {
            case TTDT_AUTOPOP:
                lDelay =  m_dwTTAutopopDelay;
                break;
            case TTDT_INITIAL:
                lDelay =  m_dwTTInitalDelay;
                break;
            case TTDT_RESHOW:
                lDelay =  m_dwTTReshowDelay;
                break;
            }
        } /* end of if statement */


        /*
         * Copy the delay to the VARIANT return variable.
         * BUGBUG: If pVal was a properly initialized variant, we should
         * call VariantClear to free any pointers. If it wasn't initialized
         * VariantInit is the right thing to call instead. I prefer a leak 
         * to a crash so I'll use VariantInit below
         */
        
        VariantInit(pVal);
        
#ifdef _WIN64
        pVal->vt = VT_I8;
        pVal->llVal = lDelay;
#else
        pVal->vt = VT_I4;
        pVal->lVal  = lDelay;
#endif

    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */


	return HandleError(hr);
}/* end of function GetDelayTime */

/*************************************************************/
/* Name: SetDelayTime
/* Description: Set the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_AUTOMATIC          0
/*              TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
STDMETHODIMP CMSWebDVD::SetDelayTime(long delayType, VARIANT newVal){

    HRESULT hr = S_OK;
    LPARAM  lNewDelay = 0;

    try {
        if (delayType>TTDT_INITIAL || delayType<TTDT_AUTOMATIC) {

            throw E_INVALIDARG;
        } /* end of if statement */

        VARIANT dest;
        VariantInit(&dest);

#ifdef _WIN64
        hr = VariantChangeTypeEx(&dest, &newVal, 0, 0, VT_I8);
        if (FAILED(hr))
            throw hr;
        lNewDelay = dest.llVal;
#else
        hr = VariantChangeTypeEx(&dest, &newVal, 0, 0, VT_I4);
        if (FAILED(hr))
            throw hr;
        lNewDelay = dest.lVal;
#endif

        if (lNewDelay < 0) {

            throw E_INVALIDARG;
        } /* end of if statement */

        if (m_hWndTip) {
            if (!SendMessage(m_hWndTip, TTM_SETDELAYTIME, 
                (WPARAM) (DWORD) delayType, 
                lNewDelay))
                return S_FALSE; 
        }

        // cache these values
        switch (delayType) {
        case TTDT_AUTOPOP:
            m_dwTTAutopopDelay = lNewDelay;
            break;
        case TTDT_INITIAL:
            m_dwTTInitalDelay = lNewDelay;
            break;
        case TTDT_RESHOW:
            m_dwTTReshowDelay = lNewDelay;
            break;
        case TTDT_AUTOMATIC:
            m_dwTTInitalDelay = lNewDelay;
            m_dwTTAutopopDelay = lNewDelay*10;
            m_dwTTReshowDelay = lNewDelay/5;
            break;
        } /* end of switch statement */
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SetDelayTime */

#endif

/*************************************************************************/
/* Function: ProcessEvents                                               */
/* Description: Triggers the message, which checks if the messagess are  */
/* ready.                                                                */
/*************************************************************************/
HRESULT CMSWebDVD::ProcessEvents(){

   HRESULT hr = S_OK;

    try {
        // see if we have lost the DDraw Surf on in Windowless MODE
        if((m_pDDrawDVD) && (!::IsWindow(m_hWnd))){

            LPDIRECTDRAWSURFACE pDDPrimary = m_pDDrawDVD->GetDDrawSurf();
            if (pDDPrimary && (pDDPrimary->IsLost() == DDERR_SURFACELOST)){

                if (pDDPrimary->Restore() == DD_OK){

                    RestoreSurfaces();
                }/* end of if statement */
            }/* end of if statement */
        }/* end of if statement */
        
        // process the DVD event
        LRESULT lRes;
        ProcessWindowMessage(NULL, WM_DVDPLAY_EVENT, 0, 0, lRes);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return hr;
}/* end of function ProcessEvents */

/*************************************************************************/
/* Function: get_WindowlessActivation                                    */
/* Description: Gets if we we tried to be windowless activated or not.   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_WindowlessActivation(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        BOOL fUserMode = FALSE;

        GetAmbientUserMode(fUserMode);

        if(READYSTATE_COMPLETE == m_nReadyState && fUserMode){
            // case when we are up and running
            *pVal = m_bWndLess == FALSE ? VARIANT_FALSE: VARIANT_TRUE; 
        }
        else {

            *pVal = m_bWindowOnly == TRUE ? VARIANT_FALSE: VARIANT_TRUE; 
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_WindowlessActivation */

/*************************************************************************/
/* Function: put_WindowlessActivation                                    */
/* Description: This sets the windowless mode, should be set from the    */
/* property bag.                                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_WindowlessActivation(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {
        if(VARIANT_FALSE == newVal){

            m_bWindowOnly = TRUE; 
            m_fUseDDrawDirect = false;
        }
        else {

            m_bWindowOnly = FALSE; 
            m_fUseDDrawDirect = true;
        }/* end of if statement */

        // TODO: This function should fail after we inplace activated !!
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_WindowlessActivation */

/*************************************************************************/
/* Function: get_DisableAutoMouseProcessing                              */
/* Description: Gets the current state of the mouse processing code.     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DisableAutoMouseProcessing(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_fDisableAutoMouseProcessing;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_DisableAutoMouseProcessing */

/*************************************************************************/
/* Function: put_DisableAutoMouseProcessing                              */
/* Description: Gets the state of the mouse processing.                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_DisableAutoMouseProcessing(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {
        m_fDisableAutoMouseProcessing = VARIANT_FALSE == newVal ? false : true;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_DisableAutoMouseProcessing */

/*************************************************************************/
/* Function: ActivateAtPosition                                          */
/* Description: Activates a button at selected position.                 */ 
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ActivateAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_pDvdCtl2->ActivateAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function ActivateAtPosition */

/*************************************************************************/
/* Function: SelectAtPosition                                            */
/* Description: Selects a button at selected position.                   */ 
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = m_pDvdCtl2->SelectAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SelectAtPosition */

/*************************************************************************/
/* Function: GetButtonAtPosition                                         */
/* Description: Gets the button number associated with a position.       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetButtonAtPosition(long xPos, long yPos, 
                                              long *plButton)
{
	HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE;
        if(!plButton){
            throw E_POINTER;
        }
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        ULONG ulButton;
        hr = m_pDvdInfo2->GetButtonAtPosition(pt, &ulButton);

        if(SUCCEEDED(hr)){
            *plButton = ulButton;
        } 
        else {
            plButton = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetButtonAtPosition */

/*************************************************************************/
/* Function: GetButtonRect                                               */
/* Description: Gets an button rect associated with a button ID.         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetButtonRect(long lButton, IDVDRect** ppRect){

    // no support in MS DVDNav
	return HandleError(E_NOTIMPL);
}/* end of function GetButtonRect */

/*************************************************************************/
/* Function: GetDVDScreenInMouseCoordinates                              */
/* Description: Gets the mouse coordinate screen.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDScreenInMouseCoordinates(IDVDRect **ppRect){

    // no support in MS DVDNav
    return HandleError(E_NOTIMPL);
}/* end of function GetDVDScreenInMouseCoordinates */

/*************************************************************************/
/* Function: SetDVDScreenInMouseCoordinates                              */
/* Description: Sets the screen in mouse coordinates.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetDVDScreenInMouseCoordinates(IDVDRect *pRect){

    // no support in MS DVDNav
	return HandleError(E_NOTIMPL);
}/* end of function SetDVDScreenInMouseCoordinates */

/*************************************************************************/
/* Function: GetClipVideoRect                                            */
/* Description: Gets the source rect that is being used.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetClipVideoRect(IDVDRect **ppRect){

    HRESULT hr = S_OK;
    IBasicVideo* pIVid = NULL; 

    try {
        if(NULL == ppRect){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // If windowless and m_pDvdClipRect hasn't been yet, 
        // then the clipping size is the default video size
        if (m_bWndLess && !m_pClipRect) {
            
            return GetVideoSize(ppRect);
        }

        long lLeft=0, lTop=0, lWidth=0, lHeight=0;

        hr = ::CoCreateInstance(CLSID_DVDRect, NULL, CLSCTX_INPROC, IID_IDVDRect, (LPVOID*) ppRect);            
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */

        IDVDRect* pIRect = *ppRect; // just to make the code esier to read

        // Windowed case, it'll be cached in m_rcvdClipRect
        if (m_bWndLess) {

            // get it from cached m_pDvdClipRect
            hr = pIRect->put_x(m_pClipRect->left);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_y(m_pClipRect->top);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Width(RECTWIDTH(m_pClipRect));
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Height(RECTHEIGHT(m_pClipRect));
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */    
        }

        // Windowed case, get it from IBasicVideo
        else {
            
            hr = TraverseForInterface(IID_IBasicVideo, (LPVOID*) &pIVid);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIVid->GetSourcePosition(&lLeft, &lTop, &lWidth, &lHeight);
            
            pIVid->Release();
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_x(lLeft);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_y(lTop);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Width(lWidth);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Height(lHeight);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */    

        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetClipVideoRect */

/*************************************************************************/
/* Function: GetVideoSize                                                */
/* Description: Gets the video, size. 0, 0 for origin for now.           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetVideoSize(IDVDRect **ppRect){

    HRESULT hr = S_OK;    
    IBasicVideo* pIVid = NULL; 

    try {
        if(NULL == ppRect){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Windowless case
        if(m_bWndLess){

            if(!m_pDDEX){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            DWORD dwVideoWidth, dwVideoHeight, dwAspectX, dwAspectY;

            hr = m_pDDEX->GetNativeVideoProps(&dwVideoWidth, &dwVideoHeight, &dwAspectX, &dwAspectY);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_dwVideoWidth = dwVideoWidth;
            m_dwVideoHeight = dwVideoWidth*3/4;
            //m_dwVideoHeight = dwVideoHeight;
            m_dwAspectX = dwAspectX;
            m_dwAspectY = dwAspectY;
            //ATLTRACE(TEXT("GetNativeVideoProps %d %d %d %d\n"), dwVideoWidth, dwVideoHeight, dwAspectX, dwAspectY);
        } 

        // Windowed case, get it from IBasicVideo
        else {

            hr = TraverseForInterface(IID_IBasicVideo, (LPVOID*) &pIVid);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */


            hr = pIVid->GetVideoSize((LONG*)&m_dwVideoWidth, (LONG*)&m_dwVideoHeight);

            pIVid->Release();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */
        }/* end of if statement */
        
        hr = ::CoCreateInstance(CLSID_DVDRect, NULL, CLSCTX_INPROC, IID_IDVDRect, (LPVOID*) ppRect);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        IDVDRect* pIRect = *ppRect; // just to make the code esier to read

        hr = pIRect->put_Width(m_dwVideoWidth);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = pIRect->put_Height(m_dwVideoHeight);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */        
    }/* end of try statement */

    catch(HRESULT hrTmp){
        hr = hrTmp;

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetVideoSize */

/*************************************************************/
/* Name: AdjustDestRC
/* Description: Adjust dest RC to the right aspect ratio
/*************************************************************/
HRESULT CMSWebDVD::AdjustDestRC(){

    if(!m_fInitialized){

        return(E_FAIL);
    }/* end of if statement */
    m_rcPosAspectRatioAjusted = m_rcPos;
    RECT rc = m_rcPos;
    
    //ATLTRACE(TEXT("Dest Rect %d %d %d %d\n"), rc.left, rc.top, rc.right, rc.bottom);
    long width = RECTWIDTH(&rc);
    long height = RECTHEIGHT(&rc);
 
    // Make sure we get the right aspect ratio

    CComPtr<IDVDRect> pDvdRect;
    HRESULT hr = GetVideoSize(&pDvdRect);
    if (FAILED(hr))
        return hr;

    double aspectRatio = m_dwAspectX/(double)m_dwAspectY;

    long adjustedHeight, adjustedWidth;
    adjustedHeight = long (width / aspectRatio);

    if (adjustedHeight<=height) {
        rc.top += (height-adjustedHeight)/2;
        rc.bottom = rc.top + adjustedHeight;
    }
    
    else {
        adjustedWidth = long (height * aspectRatio);
        rc.left += (width - adjustedWidth)/2;
        rc.right = rc.left + adjustedWidth;
    }

    //ATLTRACE(TEXT("Ajusted Dest Rect %d %d %d %d\n"), rc.left, rc.top, rc.right, rc.bottom);
    m_rcPosAspectRatioAjusted = rc;
    return S_OK;
}

/*************************************************************************/
/* Function: SetClipVideoRect                                            */
/* Description: Set a video source rect. TODO: Might want to handle      */
/* preserving aspect ratio.                                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetClipVideoRect(IDVDRect *pIRect){

    HRESULT hr = S_OK;
    IBasicVideo* pIVid = NULL; 

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        long lLeft = 0, lTop = 0, lWidth = 0, lHeight = 0;
        if(NULL == pIRect){
            if (m_pClipRect) {
                delete  m_pClipRect;
                m_pClipRect = NULL;
            } /* end of if statement */
        }

        else {
            
            hr = pIRect->get_x(&lLeft);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->get_y(&lTop);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->get_Width(&lWidth);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->get_Height(&lHeight);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
        }

        CComPtr<IDVDRect> pDvdRect;
        hr = GetVideoSize(&pDvdRect);
        if (FAILED(hr))
            throw(hr);

        // Get video width and height
        long videoWidth, videoHeight;
        pDvdRect->get_Width(&videoWidth);
        pDvdRect->get_Height(&videoHeight);

        if (lLeft < 0 || lLeft >= videoWidth || lTop < 0 || lTop >= videoHeight){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (lLeft+lWidth > videoWidth || lTop+lHeight > videoHeight){

            throw(E_INVALIDARG);
        }/* end of if statement */

        // Windowless case
        if (m_bWndLess) {
#if 0            
            hr = AdjustDestRC();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            RECT rc = m_rcPosAspectRatioAjusted;
            if (!pIRect) 
                rc = m_rcPos;
#else
            RECT rc = m_rcPos;
#endif

            HWND hwnd;

            hr = GetUsableWindow(&hwnd);

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
                            
            ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)&rc, 2);
            
            //ATLTRACE(TEXT("Ajusted Dest Rect %d %d %d %d\n"), rc.left, rc.top, rc.right, rc.bottom);
            
            if(m_pDDEX){
                if (pIRect) {
                    if (!m_pClipRect) 
                        m_pClipRect = new RECT;
                    
                    m_pClipRect->left = lLeft;
                    m_pClipRect->top = lTop;
                    m_pClipRect->right = lLeft+lWidth;
                    m_pClipRect->bottom = lTop + lHeight;
                    hr = m_pDDEX->SetDrawParameters(m_pClipRect, &rc);
                }
                else {
                    hr = m_pDDEX->SetDrawParameters(NULL, &rc);
                }

            }/* end of if statement */
            
        }/* end of if statement */    

        // Windowed case, set it via IBasicVideo
        else {
            
            hr = TraverseForInterface(IID_IBasicVideo, (LPVOID*) &pIVid);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            if (pIRect) {
                if (!m_pClipRect) 
                    m_pClipRect = new RECT;
                
                m_pClipRect->left = lLeft;
                m_pClipRect->top = lTop;
                m_pClipRect->right = lLeft+lWidth;
                m_pClipRect->bottom = lTop + lHeight;
                
                hr = pIVid->SetSourcePosition(lLeft, lTop, lWidth, lHeight);
            }
            
            else {
                hr = pIVid->SetDefaultSourcePosition();
            }

            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            //hr = pIVid->SetDestinationPosition(m_rcPos.left, m_rcPos.top, WIDTH(&m_rcPos), HEIGHT(&m_rcPos));
            
            pIVid->Release();
            pIVid = NULL;
#if 0
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
#endif                            
        }

    }

    catch(HRESULT hrTmp){

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function SetClipVideoRect */

/*************************************************************************/
/* Function: get_DVDAdm                                                  */
/* Description: Returns DVD admin interface.                             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DVDAdm(IDispatch **pVal){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if (m_pDvdAdmin){

            hr = m_pDvdAdmin->QueryInterface(IID_IDispatch, (LPVOID*)pVal);
        }
        else {

            *pVal = NULL;            
            throw(E_FAIL);
        }/* end of if statement */
    
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_DVDAdm */

/*************************************************************************/
/* Function: GetPlayerParentalLevel                                      */
/* Description: Gets the player parental level.                          *
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetPlayerParentalLevel(long *plParentalLevel){
	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevel){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulLevel;
        BYTE bCountryCode[2];
        hr = m_pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){
            *plParentalLevel = ulLevel;
        } 
        else {
            *plParentalLevel = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalLevel */

/*************************************************************************/
/* Function: GetPlayerParentalCountry                                    */
/* Description: Gets the player parental country.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetPlayerParentalCountry(long *plCountryCode){

	HRESULT hr = S_OK;

    try {
        if(NULL == plCountryCode){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BYTE bCountryCode[2];
        ULONG ulLevel;
        hr = m_pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){

            *plCountryCode = bCountryCode[0]<<8 | bCountryCode[1];
        } 
        else {

            *plCountryCode = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalCountry */

/*************************************************************************/
/* Function: GetTitleParentalLevels                                      */
/* Description: Gets the parental level associated with a specific title.*/
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetTitleParentalLevels(long lTitle, long *plParentalLevels){

	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevels){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulLevel;
        hr = m_pDvdInfo2->GetTitleParentalLevels(lTitle, &ulLevel); 

        if(SUCCEEDED(hr)){

            *plParentalLevels = ulLevel;
        } 
        else {

            *plParentalLevels = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetTitleParentalLevels */

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectParentalLevel(long lParentalLevel, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != LEVEL_DISABLED && 
           (lParentalLevel < LEVEL_G || lParentalLevel > LEVEL_ADULT)) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->_ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);
    
        hr = SelectParentalLevel(lParentalLevel);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
HRESULT CMSWebDVD::SelectParentalLevel(long lParentalLevel){

    HRESULT hr = S_OK;
    try {

        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectParentalLevel(lParentalLevel);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalLevel */

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectParentalCountry(long lCountry, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->_ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);

        hr = SelectParentalCountry(lCountry);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
HRESULT CMSWebDVD::SelectParentalCountry(long lCountry){

    HRESULT hr = S_OK;
    try {

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        hr = m_pDvdCtl2->SelectParentalCountry(bCountryCode);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalCountry */

/*************************************************************************/
/* Function: put_NotifyParentalLevelChange                               */
/* Description: Sets the flag if to notify when parental level change    */
/* notification is required on the fly.                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::NotifyParentalLevelChange(VARIANT_BOOL fNotify){

	HRESULT hr = S_OK;

    try {
        //TODO: Add IE parantal level control
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SetOption(DVD_NotifyParentalLevelChange,
                          VARIANT_FALSE == fNotify? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function NotifyParentalLevelChange */

/*************************************************************************/
/* Function: AcceptParentalLevelChange                                   */
/* Description: Accepts the temprary parental level change that is       */
/* done on the fly.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::AcceptParentalLevelChange(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword){

    VARIANT_BOOL fRight;
    HRESULT hr = m_pDvdAdmin->_ConfirmPassword(NULL, strPassword, &fRight);

    // if password is wrong and want to accept, no 
    if (fAccept != VARIANT_FALSE && fRight == VARIANT_FALSE)
        return E_ACCESSDENIED;

    try {  
        // should not make sense to do initialization here, since this should
        // be a response to a callback
        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->AcceptParentalLevelChange(VARIANT_FALSE == fAccept? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function AcceptParentalLevelChange */

/*************************************************************/
/* Name: Eject                                               */
/* Description: Stop DVD playback and eject DVD from drive   */
/* Inserts the disk as well.                                 */
/*************************************************************/
STDMETHODIMP CMSWebDVD::Eject(){

    HRESULT hr = S_OK;

    try {      
        USES_CONVERSION;
	    DWORD  dwHandle;
    
        BSTR root;
        hr = get_DVDDirectory(&root);
        if (FAILED(hr)) 
            throw (hr);

        LPTSTR szDriveLetter = OLE2T(root);
        ::SysFreeString(root);

	    if(m_bEjected == false){	

		    if(szDriveLetter[0] == 0){

			    throw(S_FALSE);
		    }/* end of if statement */
	    
		    DWORD dwErr;
		    dwHandle = OpenCdRom(szDriveLetter[0], &dwErr);
		    if (dwErr != MMSYSERR_NOERROR){

			    throw(S_FALSE);
		    }/* end of if statement */

		    EjectCdRom(dwHandle);
	    }
        else{
            //do uneject
		    DWORD dwErr;
		    dwHandle = OpenCdRom(szDriveLetter[0], &dwErr);
		    if (dwErr != MMSYSERR_NOERROR){

			    throw(S_FALSE);
		    }/* end of if statement */
		    UnEjectCdRom(dwHandle);

	    }/* end of if statement */
	    CloseCdRom(dwHandle);	        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Eject */

/*************************************************************************/
/* Function: SetGPRM                                                     */
/* Description: Sets a GPRM at index.                                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetGPRM(long lIndex, short sValue){

    HRESULT hr = S_OK;

    try {
        if(lIndex < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SetGPRM(lIndex, sValue, cdwDVDCtrlFlags, 0);
            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SetGPRM */

/*************************************************************************/
/* Function: Capture                                                     */
/* Capture a image from DVD stream, convert it to RGB, and save it       */
/* to file.                                                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Capture(){

    HWND hwnd = NULL;
    HRESULT hr = S_OK;
    YUV_IMAGE *lpImage = NULL;
    try {

        hr = GetUsableWindow(&hwnd);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(::IsWindow(m_hWnd)){
            
            throw(E_NO_CAPTURE_SUPPORT);
        }/* end of if statement */

        if(!m_pDDEX){

            throw(E_UNEXPECTED);    
        }/* end of if statement */

        hr = m_pDDEX->IsImageCaptureSupported();

        if(S_FALSE == hr){

            throw(E_FORMAT_NOT_SUPPORTED);
        }/* end of if statement */

        hr = m_pDDEX->GetCurrentImage(&lpImage);
        if (SUCCEEDED(hr))
        {
#if 0
            // use the GDI version first, it should work when GDI+ is installed (Millennium)
			// otherwise use the standalone version
			// 12.04.00 GDI+ interfaces have changed and the function needs to be rewritten
			// look at this for blackcomb maybe for now just do the non-GDI+ function
            hr = GDIConvertImageAndSave(lpImage, m_pClipRect, hwnd); 

            if(FAILED(hr))
#endif
            {
                hr = ConvertImageAndSave(lpImage, m_pClipRect, hwnd);   

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */
            }
        }
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */
	if(lpImage){
		CoTaskMemFree(lpImage);
	}
	return HandleError(hr);
}/* end of function Capture */

/*************************************************************/
/* Name: get_CursorType                                      */
/* Description: Return cursor type over video                */
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_CursorType(DVDCursorType *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_nCursorType;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CursorType */

/*************************************************************/
/* Name: put_CursorType                                      */
/* Description: Set cursor type over video                   */
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_CursorType(DVDCursorType newVal){

    HRESULT hr = S_OK;

    try {

        if (newVal<dvdCursor_None || newVal>dvdCursor_Hand) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        m_nCursorType = newVal;
        if (m_hCursor)
            ::DestroyCursor(m_hCursor);
        switch(m_nCursorType) {
        case dvdCursor_ZoomIn:
        case dvdCursor_ZoomOut:
            m_hCursor = ::LoadCursor(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDC_ZOOMIN));
            break;
        case dvdCursor_Hand:
            m_hCursor = ::LoadCursor(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDC_HAND));            
            break;
        case dvdCursor_Arrow:
        default:
        

            //#define OCR_ARROW_DEFAULT 100
            // need special cursor, we we do not have color key around it
            //m_hCursor  = (HCURSOR) ::LoadImage((HINSTANCE) NULL,
            //                        MAKEINTRESOURCE(OCR_ARROW_DEFAULT),
            //                       IMAGE_CURSOR,0,0,0);
        

            m_hCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT));
            break;
        }

        if (m_hCursor)
            ::SetCursor(m_hCursor);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CursorType */

/*************************************************************/
/* Name: Zoom
/* Description: Zoom in at (x, y) in original video
/*  enlarge or decrease video size by zoomRatio
/*  if zoomRatio > 1    zoom in
/*  if zoomRatio = 1
/*  if zoomRatio < 1    zoom out
/*  if zoomRatio <= 0   invalid
/*************************************************************/
STDMETHODIMP CMSWebDVD::Zoom(long x, long y, double zoomRatio){

    HRESULT hr = S_OK;

    try {
        if (zoomRatio< 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        // Can't go beyond 1.0
        if (m_dZoomRatio <= 1.0) {
            if (zoomRatio <= 1.0) {
                m_dZoomRatio = 1.0;
                throw(hr);
            }
            m_dZoomRatio = 1.0;
        }

        // Can't go beyond the max stretch factor
        if (m_dZoomRatio*zoomRatio > m_dwOvMaxStretch/1000.0)
            throw hr;

        m_dZoomRatio *= zoomRatio;

        // Can't go beyond 1.0
        if (m_dZoomRatio <= 1.0)
            m_dZoomRatio = 1.0;

        CComPtr<IDVDRect> pDvdRect;
        hr = GetVideoSize(&pDvdRect);
        if (FAILED(hr))
            throw(hr);

        if(1.0 == m_dZoomRatio){

            hr = SetClipVideoRect(NULL);

            put_CursorType(dvdCursor_Arrow);
            throw(hr);
        }/* end of if statement */

        // Get video width and height
        long videoWidth, videoHeight;
        pDvdRect->get_Width(&videoWidth);
        pDvdRect->get_Height(&videoHeight);

        if (x < 0 || x >= videoWidth || y < 0 || y >= videoHeight){

            throw(E_INVALIDARG);
        }/* end of if statement */

        // Compute new clipping width and height
        long mcd = MCD(m_dwVideoWidth, m_dwVideoHeight);
        long videoX = m_dwVideoWidth/mcd;
        long videoY = m_dwVideoHeight/mcd;

        long newClipHeight = (long) (videoHeight/m_dZoomRatio);
        newClipHeight /= videoY;
        newClipHeight *= videoY;
        if (newClipHeight < 1) newClipHeight = 1;
        long newClipWidth =  (long) (newClipHeight*videoX/videoY);
        if (newClipWidth < 1) newClipWidth = 1;

        // Can't go beyong native video size
        if (newClipWidth>videoWidth)
            newClipWidth = videoWidth;
        if (newClipHeight>videoHeight)
            newClipHeight = videoHeight;
        if (newClipWidth == videoWidth && newClipHeight == videoHeight) {
            put_CursorType(dvdCursor_Arrow);
        }
        else {
            put_CursorType(dvdCursor_Hand);
        }

        long newClipX = x - newClipWidth/2;
        long newClipY = y - newClipHeight/2;

        // Can't go outsize the native video rect
        if (newClipX < 0)
            newClipX = 0;
        else if (newClipX + newClipWidth > videoWidth)
            newClipX = videoWidth - newClipWidth;

        if (newClipY < 0)
            newClipY = 0;
        else if (newClipY + newClipHeight > videoHeight)
            newClipY = videoHeight - newClipHeight;

        CComPtr<IDVDRect> pDvdClipRect;
        hr = GetClipVideoRect(&pDvdClipRect);
        if (FAILED(hr))
            throw(hr);
        pDvdClipRect->put_x(newClipX);
        pDvdClipRect->put_y(newClipY);
        pDvdClipRect->put_Width(newClipWidth);
        pDvdClipRect->put_Height(newClipHeight);
        hr = SetClipVideoRect(pDvdClipRect);

    }
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Zoom */

/*************************************************************************/
/* Function: RegionChange                                                */
/* Description:Changes the region code.                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::RegionChange(){

    USES_CONVERSION;
    HRESULT hr = S_OK;
    typedef BOOL (APIENTRY *DVDPPLAUNCHER) (HWND HWnd, CHAR DriveLetter);


    try {
        HWND parentWnd = NULL;
        HRESULT hrTmp = GetParentHWND(&parentWnd);
        if (SUCCEEDED(hrTmp) && (NULL != parentWnd)) {
            // take the container out of the top-most mode
            ::SetWindowPos(parentWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
                SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);
        }

        BOOL regionChanged = FALSE;
        OSVERSIONINFO ver;
        ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        ::GetVersionEx(&ver);

        if (ver.dwPlatformId==VER_PLATFORM_WIN32_NT) {

                HINSTANCE dllInstance;
                DVDPPLAUNCHER dvdPPLauncher;
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                LPSTR szDriveLetterA;

                //
                // tell the user why we are showing the dvd region property page
                //
                // DVDMessageBox(m_hWnd, IDS_REGION_CHANGE_PROMPT);

                hr = getDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){
					hr = E_UNEXPECTED;
                    throw(hr);
                }/* end of if statement */

                szDriveLetterA = T2A(szDriveLetter);

                GetSystemDirectory(szCmdLine, MAX_PATH);
                StringCchCat(szCmdLine, sizeof(szCmdLine) / sizeof(szCmdLine), _T("\\storprop.dll"));
        
                dllInstance = LoadLibrary (szCmdLine);
                if (dllInstance) {

                        dvdPPLauncher = (DVDPPLAUNCHER) GetProcAddress(
                                                            dllInstance,
                                                            "DvdLauncher");
                
                        if (dvdPPLauncher) {

                                regionChanged = dvdPPLauncher(this->m_hWnd,
                                                              szDriveLetterA[0]);
                        }

                        FreeLibrary(dllInstance);
                }

        } 
        else {
#if 0 // need to check for win9x or winnt
                INITIALIZE_GRAPH_IF_NEEDS_TO_BE

                //Get path of \windows\dvdrgn.exe and command line string
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                
                hr = getDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                GetWindowsDirectory(szCmdLine, MAX_PATH);
                StringCchCat(szCmdLine, sizeof(szCmdLine) / sizeof(szCmdLine[0]),  _T("\\dvdrgn.exe "));
                TCHAR strModuleName[MAX_PATH];
                lstrcpyn(strModuleName, szCmdLine, sizeof(strModuleName) / sizeof(strModuleName[0]));

                TCHAR csTmp[2]; ::ZeroMemory(csTmp, sizeof(TCHAR)* 2);
                csTmp[0] = szDriveLetter[0];
                StringCchCat(szCmdLine, sizeof(szCmdLine) / sizeof(szCmdLine[0]), csTmp);
        
                //Prepare and execuate dvdrgn.exe
                STARTUPINFO StartupInfo;
                PROCESS_INFORMATION ProcessInfo;
                StartupInfo.cb          = sizeof(StartupInfo);
                StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
                StartupInfo.wShowWindow = SW_SHOW;
                StartupInfo.lpReserved  = NULL;
                StartupInfo.lpDesktop   = NULL;
                StartupInfo.lpTitle     = NULL;
                StartupInfo.cbReserved2 = 0;
                StartupInfo.lpReserved2 = NULL;
                if( ::CreateProcess(strModuleName, szCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS,
                                                  NULL, NULL, &StartupInfo, &ProcessInfo) ){

                        //Wait dvdrgn.exe finishes.
                        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
                        DWORD dwRet = 1;
                        BOOL bRet = GetExitCodeProcess(ProcessInfo.hProcess, &dwRet);
                        if(dwRet == 0){
                            //User changed the region successfully
                            regionChanged = TRUE;
    
                        }
                        else{
                            throw(E_REGION_CHANGE_NOT_COMPLETED);
                        }
                }/* end of if statement */
#endif
        }/* end of if statement */

        if (regionChanged) {

                // start playing again
                hr = Play();                        
        } 
        else {

            throw(E_REGION_CHANGE_FAIL);
        }/* end of if statement */

	}
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RegionChange */

/*************************************************************************/
/* Function: getDVDDriveLetter                                           */
/* Description: Gets the first three characters that denote the DVD-ROM  */
/*************************************************************************/
HRESULT CMSWebDVD::getDVDDriveLetter(TCHAR* lpDrive) {

    HRESULT hr = E_FAIL;

	if(!m_pDvdInfo2){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */
        
    WCHAR szRoot[MAX_PATH];
    ULONG ulActual;

    hr = m_pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    USES_CONVERSION;
    
	lstrcpyn(lpDrive, OLE2T(szRoot), 3);
    if(::GetDriveType(&lpDrive[0]) == DRIVE_CDROM){
        
		return(hr);
    }
    else {
        //possibly root=c: or drive in hard disc
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */


    // does not seem to make sense to loop to figure out the drive letter
#if 0
    DWORD totChrs = GetLogicalDriveStrings(MAX_PATH, szTemp); //get all drives
	ptr = szTemp;
	for(DWORD i = 0; i < totChrs; i+=4)      //look at these drives one by one
	{
		if(GetDriveType(ptr) == DRIVE_CDROM) //look only CD-ROM and see if it has a disc
		{
			TCHAR achDVDFilePath1[MAX_PATH], achDVDFilePath2[MAX_PATH];
			lstrcpyn(achDVDFilePath1, ptr, 4);
			lstrcpyn(achDVDFilePath2, ptr, 4);
			lstrcat(achDVDFilePath1, _T("Video_ts\\Video_ts.ifo"));
			lstrcat(achDVDFilePath2, _T("Video_ts\\Vts_01_0.ifo"));

			if( ((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath1) &&
				((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath2) )							
			{
				lstrcpyn(lpDrive, ptr, 3);
				return(hr);   //Return the first found drive which has a valid DVD disc
			}
		}
		ptr += 4; 
	}
#endif

    return(hr);
}/* end of function getDVDDriveLetter */

/*************************************************************/
/* Name: SelectDefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::SelectDefaultAudioLanguage(long lang, long ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdCtl2 || !m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectDefaultAudioLanguage(lang, (DVD_AUDIO_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);

        // Save it with DVDAdmin
        //hr = m_pDvdAdmin->put_DefaultAudioLCID(lang);
        //if (FAILED(hr))
        //    throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);

}

/*************************************************************/
/* Name: SelectDefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::SelectDefaultSubpictureLanguage(long lang, DVDSPExt ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdCtl2 || !m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectDefaultSubpictureLanguage(lang, (DVD_SUBPICTURE_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);

        // Save it with DVDAdmin
        //hr = m_pDvdAdmin->put_DefaultSubpictureLCID(lang);
        //if (FAILED(hr))
        //    throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);

}

/*************************************************************/
/* Name: put_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_DefaultMenuLanguage(long lang){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdCtl2 || !m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectDefaultMenuLanguage(lang);
        if (FAILED(hr))
            throw(hr);

        // Save it with DVDAdmin
        //hr = m_pDvdAdmin->put_DefaultMenuLCID(lang);
        //if (FAILED(hr))
        //    throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);

}

/*************************************************************************/
/* Function: get_PreferredSubpictureStream                                    */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_PreferredSubpictureStream(long *plPreferredStream){

    HRESULT hr = S_OK;

    try {
	    if (NULL == plPreferredStream){

            throw(E_POINTER);         
        }/* end of if statement */

        LCID langDefaultSP;
        m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&langDefaultSP);
        
        // if none has been set
        if (langDefaultSP == (LCID) -1) {
            
            *plPreferredStream = 0;
            return hr;
        } /* end of if statement */
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
            
        if(!m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        USES_CONVERSION;
        LCID lcid = 0;
        
        ULONG ulNumAudioStreams = 0;
        ULONG ulCurrentStream = 0;
        BOOL  fDisabled = TRUE;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulNumAudioStreams, &ulCurrentStream, &fDisabled));
        
        *plPreferredStream = 0;
        for (ULONG i = 0; i<ulNumAudioStreams; i++) {
            hr = m_pDvdInfo2->GetSubpictureLanguage(i, &lcid);
            if (SUCCEEDED( hr ) && lcid){
                if (lcid == langDefaultSP) {
                    *plPreferredStream = i;
                }
            }
        }
    }
    
    catch(HRESULT hrTmp){
        return hrTmp;
    }/* end of catch statement */

    catch(...){
        return E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_AspectRatio
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_AspectRatio(double *pVal)
{

    HRESULT hr = S_OK;

    // Make sure we get the right aspect ratio
    try {
	    if (NULL == pVal){

            throw(E_POINTER);         
        }/* end of if statement */

        CComPtr<IDVDRect> pDvdRect;
        hr = GetVideoSize(&pDvdRect);
        if (FAILED(hr))
            throw(hr);
        
        //ATLTRACE(TEXT("get_AspectRatio, %d %d \n"), m_dwAspectX, m_dwAspectY);
        *pVal = (m_dwAspectX*1.0)/m_dwAspectY;
    }
    
    catch(HRESULT hrTmp){
        return hrTmp;
    }/* end of catch statement */
    
    catch(...){
        return E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************************/
/* Function: CanStep                                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::CanStep(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan){
   
    HRESULT hr = S_OK;
    try {
	    if (NULL == pfCan){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        *pfCan = VARIANT_FALSE;

        // Can't step if still is on
        if (m_fStillOn == true) {
            throw (hr);
        }/* end of if statement */

        if(!m_pVideoFrameStep){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(VARIANT_FALSE != fBackwards){

            if(S_OK != CanStepBackwards()){

                // we cannot step on decodors that do not provide smooth backward playback
                //*pfCan = VARIANT_FALSE; already set above so do not have to do that any more
                hr = S_OK;
                throw(hr);
            }/* end of if statement */
        }/* end of if statement */
        
        hr = m_pVideoFrameStep->CanStep(1L, NULL);

        if(S_OK == hr){

            *pfCan = VARIANT_TRUE;
        }/* end of if statement */

        hr = S_OK;

	}
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}/* end of function CanStep */

/*************************************************************************/
/* Function: Step                                                        */
/* Description: Steps forwards or backwords. Mutes un umutes sound if    */
/* necessary.                                                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Step(long lStep){

	HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    

        if(lStep < 0){
            // going backwards so check if we can do it
            if(S_OK != CanStepBackwards()){
                
                hr = E_FAIL; // aperently we cannot on this decoder
                throw(hr);
            }/* end of if statement */
        }/* end of if statement */

        if(!m_pVideoFrameStep){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        bool fUnMute = false;

        if(FALSE == m_bMute){
            
            hr = put_Mute(VARIANT_TRUE);
            if (SUCCEEDED(hr)){

                fUnMute = true;
            }/* end of if statement */
        }/* end if if statement */        

        ProcessEvents(); // cleanup the message queu

        m_fStepComplete = false;

        hr = m_pVideoFrameStep->Step(lStep, NULL);
        
        if(SUCCEEDED(hr)){

            HRESULT hrTmp = hr;
            hr = E_FAIL;
            for(INT i = 0; i < cgnStepTimeout; i++){


                // now wait for EC_STEP_COMPLETE flag
                ProcessEvents(); 
                if(m_fStepComplete){

                    hr = hrTmp;
                    break;
                }/* end of if statement */
                ::Sleep(cdwTimeout);
            }/* end of for loop */
        }/* end of if statement */

        if(fUnMute){

            hr = put_Mute(VARIANT_FALSE);
            if (FAILED(hr)){

                throw(hr);
            }/* end of if statement */
        }/* end if if statement */        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

	}
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}/* end of function Step */

/*************************************************************/
/* Function: CanStepBackwards                                */
/* Description: Checks if the decoder can step backwqards    */
/* cashesh the variable.                                     */
/* Returns S_OK if can, S_FALSE otherwise                    */
/*************************************************************/
HRESULT CMSWebDVD::CanStepBackwards(){

    HRESULT hr = S_OK;

    if(m_fBackWardsFlagInitialized){
        
        // pulling out the result from the cache
        return (m_fCanStepBackwards ? S_OK : S_FALSE);
    }/* end of if statement */
    
    DVD_DECODER_CAPS dvdCaps; 
    ::ZeroMemory(&dvdCaps, sizeof(DVD_DECODER_CAPS));
    dvdCaps.dwSize = sizeof(DVD_DECODER_CAPS);

    hr = m_pDvdInfo2->GetDecoderCaps(&dvdCaps);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    //dvdCaps.dBwdMaxRateVideo is zero if decoder does not support smooth reverse
    // playback that means it will not support reverse stepping mechanism as well
    if(0 == dvdCaps.dBwdMaxRateVideo){

        // we cannot step on decodors that do not provide smooth backward playback
        m_fBackWardsFlagInitialized = true;
        m_fCanStepBackwards = false;

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    m_fBackWardsFlagInitialized = true;
    m_fCanStepBackwards = true;
    hr = S_OK;

    return(hr);
}/* end of function CanStepBackwards */

/*************************************************************/
/* Name: GetKaraokeChannelAssignment
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetKaraokeChannelAssignment(long lStream, long *lChannelAssignment)
{
    HRESULT hr = S_OK;

    try {
        if(!lChannelAssignment){
            return E_POINTER;
        }
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lChannelAssignment = (long)attrib.ChannelAssignment;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: GetKaraokeChannelContent
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetKaraokeChannelContent(long lStream, long lChan, long *lContent)
{
    HRESULT hr = S_OK;

    try {
        if(!lContent){
            return E_POINTER;
        }
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (lChan >=8 ) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lContent = (long)attrib.wChannelContents[lChan];

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_KaraokeAudioPresentationMode(long *pVal)
{
    HRESULT hr = S_OK;

    try {

        if (NULL == pVal) {

            throw (E_POINTER);
        } /* end of if statement */

        *pVal = m_lKaraokeAudioPresentationMode;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: put_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_KaraokeAudioPresentationMode(long newVal)
{
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectKaraokeAudioPresentationMode((ULONG)newVal));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // Cache the value
        m_lKaraokeAudioPresentationMode = newVal;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultAudioLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = m_pDvdInfo2->GetDefaultAudioLanguage((LCID*)lang, (DVD_AUDIO_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultAudioLanguageExt(long *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = m_pDvdInfo2->GetDefaultAudioLanguage((LCID*)&lang, (DVD_AUDIO_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultSubpictureLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = m_pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)lang, (DVD_SUBPICTURE_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultSubpictureLanguageExt(DVDSPExt *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = m_pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)&lang, (DVD_SUBPICTURE_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultMenuLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDefaultMenuLanguage((LCID*)lang);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: RestoreDefaultSettings
/* Description: 
/*************************************************************/
HRESULT CMSWebDVD::RestoreDefaultSettings()
{
    HRESULT hr = S_OK;
    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdAdmin){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */
        
        
        if(!m_pDvdInfo2){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */
        
        // get the curent domain
        DVD_DOMAIN domain;
        
        hr = m_pDvdInfo2->GetCurrentDomain(&domain);
        
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */
        
        // Have to be in the stop domain
        if(DVD_DOMAIN_Stop != domain)
            throw (VFW_E_DVD_INVALIDDOMAIN);
            
        long level;
        hr = m_pDvdAdmin->GetParentalLevel(&level);
        if (SUCCEEDED(hr))
            SelectParentalLevel(level);
        
        LCID audioLCID;
        LCID subpictureLCID;
        LCID menuLCID;
        
        hr = m_pDvdAdmin->get_DefaultAudioLCID((long*)&audioLCID);
        if (SUCCEEDED(hr))
            SelectDefaultAudioLanguage(audioLCID, 0);
        
        hr = m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&subpictureLCID);
        if (SUCCEEDED(hr))
            SelectDefaultSubpictureLanguage(subpictureLCID, dvdSPExt_NotSpecified);
        
        hr = m_pDvdAdmin->get_DefaultMenuLCID((long*)&menuLCID);
        if (SUCCEEDED(hr))
            put_DefaultMenuLanguage(menuLCID);
        
    }
    
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************************/
/* DVD Helper Methods, used by the default interface                     */
/*************************************************************************/

/*************************************************************************/
/* Function: GetColorKey                                                 */
/* Description: Gets a colorkey via RGB filled COLORREF or palette index.*/
/* Helper function.                                                      */
/*************************************************************************/
HRESULT CMSWebDVD::GetColorKey(COLORREF* pClr)
{
    HRESULT hr = S_OK;

    if(m_pDvdGB == NULL)
        return(E_FAIL);

    CComPtr<IMixerPinConfig2> pMixerPinConfig;

    hr = m_pDvdGB->GetDvdInterface(IID_IMixerPinConfig2, (LPVOID *) &pMixerPinConfig);

    if(FAILED(hr))
        return(hr);    

    COLORKEY ck;
    DWORD    dwColor;

    hr = pMixerPinConfig->GetColorKey(&ck, &dwColor); // get the color key

    if(FAILED(hr))
        return(hr);    

    HWND hwnd = ::GetDesktopWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return(E_UNEXPECTED);
    }/* end of if statement */

    BOOL bPalette = (RC_PALETTE == (RC_PALETTE & GetDeviceCaps( hdc, RASTERCAPS )));
    
    if ((ck.KeyType & CK_INDEX)&& bPalette) {
        
        PALETTEENTRY PaletteEntry;
        UINT nTmp = GetSystemPaletteEntries( hdc, ck.PaletteIndex, 1, &PaletteEntry );
        if ( nTmp == 1 )
        {
            *pClr = RGB( PaletteEntry.peRed, PaletteEntry.peGreen, PaletteEntry.peBlue );
        }
    }
    else if (ck.KeyType & CK_RGB)
    {
        
        *pClr = ck.HighColorValue;  // set the RGB color
    }

    ::ReleaseDC(hwnd, hdc);
    return(hr);
}/* end of function GetColorKey */

/*************************************************************************/
/* Function: SetColorKey                                                 */
/* Description: Sets a colorkey via RGB filled COLORREF.                 */
/* Helper function.                                                      */
/*************************************************************************/
HRESULT CMSWebDVD::SetColorKey(COLORREF clr){
    HRESULT hr = S_OK;

    if(m_pDvdGB == NULL)
        return(E_FAIL);

    CComPtr<IMixerPinConfig2> pMixerPinConfig;
    hr = m_pDvdGB->GetDvdInterface(IID_IMixerPinConfig2, (LPVOID *) &pMixerPinConfig);

    if( SUCCEEDED( hr )){
        COLORKEY ck;

        HWND hwnd = ::GetDesktopWindow();
        HDC hdc = ::GetWindowDC(hwnd);

        if(NULL == hdc){

            return(E_UNEXPECTED);
        }/* end of if statement */

        if((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE)
        {
            ck.KeyType = CK_INDEX|CK_RGB; // have an index to the palette
            ck.PaletteIndex = 253;
            PALETTEENTRY PaletteEntry;
            UINT nTmp = GetSystemPaletteEntries( hdc, ck.PaletteIndex, 1, &PaletteEntry );
            if ( nTmp == 1 )
            {
                ck.LowColorValue = ck.HighColorValue = RGB( PaletteEntry.peRed, PaletteEntry.peGreen, PaletteEntry.peBlue );
            }
        }
        else
        {
            ck.KeyType = CK_RGB;
            ck.LowColorValue = clr; 
            ck.HighColorValue = clr;
        }/* end of if statement */
        
        hr = pMixerPinConfig->SetColorKey(&ck);
        ::ReleaseDC(hwnd, hdc);
    }/* end of if statement */

    return hr;
}/* end of function SetColorKey */

/*************************************************************************/
/* Function: TwoDigitToByte                                              */
/*************************************************************************/
static BYTE TwoDigitToByte( const WCHAR* pTwoDigit ){

	int tens    = int(pTwoDigit[0] - L'0');
	return BYTE( (pTwoDigit[1] - L'0') + tens*10);
}/* end of function TwoDigitToByte */

/*************************************************************************/
/* Function: Bstr2DVDTime                                                */
/* Description: Converts a DVD Time info from BSTR into a TIMECODE.      */
/*************************************************************************/
HRESULT CMSWebDVD::Bstr2DVDTime(DVD_HMSF_TIMECODE *ptrTimeCode, const BSTR *pbstrTime){


    if(NULL == pbstrTime || NULL == ptrTimeCode){

        return E_INVALIDARG;
    }/* end of if statement */

    ::ZeroMemory(ptrTimeCode, sizeof(DVD_HMSF_TIMECODE));
    WCHAR *pszTime = *pbstrTime;

    ULONG lStringLength = wcslen(pszTime);

    if(0 == lStringLength){

        return E_INVALIDARG;
    }/* end of if statement */    
    TCHAR tszTimeSep[5];
    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);  
    
    // If the string is two long, it is seconds only
    if(lStringLength == 2){
        ptrTimeCode->bSeconds = TwoDigitToByte( &pszTime[0] );
        return S_OK;
    }

    // Otherwise it is a normal time code of the format
    // 43:32:21:10
    // Where the ':' can be replaced with a localized string of upto 4 char in len
    // There is a possible error case where the length of the delimeter is different
    // then the current delimeter

    if(lStringLength >= (4*cgTIME_STRING_LEN)+(3 * _tcslen(tszTimeSep))){ // longest string nnxnnxnnxnn e.g. 43:23:21:10
                                                                         // where n is a number and 
                                                                         // x is a time delimeter usually ':', but can be any string upto 4 char in len)
        ptrTimeCode->bFrames    = TwoDigitToByte( &pszTime[(3*cgTIME_STRING_LEN)+(3*_tcslen(tszTimeSep))]);
    }

    if(lStringLength >= (3*cgTIME_STRING_LEN)+(2 * _tcslen(tszTimeSep))) { // string nnxnnxnn e.g. 43:23:21
        ptrTimeCode->bSeconds   = TwoDigitToByte( &pszTime[(2*cgTIME_STRING_LEN)+(2*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (2*cgTIME_STRING_LEN)+(1 * _tcslen(tszTimeSep))) { // string nnxnn e.g. 43:23
        ptrTimeCode->bMinutes   = TwoDigitToByte( &pszTime[(1*cgTIME_STRING_LEN)+(1*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (cgTIME_STRING_LEN)) { // string nn e.g. 43
        ptrTimeCode->bHours   = TwoDigitToByte( &pszTime[0] );
    }
    return (S_OK);
}/* end of function bstr2DVDTime */

/*************************************************************************/
/* Function: DVDTime2bstr                                                */
/* Description: Converts a DVD Time info from ULONG into a BSTR.         */
/*************************************************************************/
HRESULT CMSWebDVD::DVDTime2bstr( const DVD_HMSF_TIMECODE *pTimeCode, BSTR *pbstrTime){

    if(NULL == pTimeCode || NULL == pbstrTime) 
        return E_INVALIDARG;

    USES_CONVERSION;

    TCHAR tszTime[cgDVD_TIME_STR_LEN];
    TCHAR tszTimeSep[5];

    ::ZeroMemory(tszTime, sizeof(TCHAR)*cgDVD_TIME_STR_LEN);

    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);


    StringCchPrintf( tszTime, sizeof(tszTime) / sizeof(tszTime[0]), TEXT("%02lu%s%02lu%s%02lu%s%02lu"), 
                pTimeCode->bHours,   tszTimeSep,
                pTimeCode->bMinutes, tszTimeSep,
                pTimeCode->bSeconds, tszTimeSep,
                pTimeCode->bFrames );
    
    *pbstrTime = SysAllocString(T2OLE(tszTime));
    return (S_OK);
}/* end of function DVDTime2bstr */

/*************************************************************************/
/* Function: SetupAudio                                                  */
/* Description: Initialize the audio interface.                          */
/*************************************************************************/
HRESULT CMSWebDVD::SetupAudio(){

    HRESULT hr = E_FAIL;

    try {
#if 0 // Using 
        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID*) &m_pAudio) ;

        if(FAILED(hr)){

            ATLTRACE(TEXT("The QDVD.DLL does not support IID_IBasicAudio please update QDVD.DLL\n"));
            throw(hr);
        }/* end of if statement */

#else
        hr = TraverseForInterface(IID_IBasicAudio, (LPVOID*) &m_pAudio);

        if(FAILED(hr)){

             // might be a HW decoder
             HMIXER hmx = NULL;

             if(::mixerOpen(&hmx, 0, 0, 0, 0) != MMSYSERR_NOERROR){

                  hr = E_FAIL;
                  return(hr);
             }/* end of if statement */
             ::mixerClose(hmx);

             hr = S_OK;
        }/* end of if statement */

#endif
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return hr;
}/* end of function SetupAudio */

/*************************************************************************/
/* Function: TraverseForInterface                                        */
/* Description: Goes through the interface list and finds a desired one. */
/*************************************************************************/
HRESULT CMSWebDVD::TraverseForInterface(REFIID iid, LPVOID* ppvObject){

    HRESULT hr = E_FAIL;

    try {
        // take care and release any interface before passing
        // it over otherwise we leak

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        IGraphBuilder *pFilterGraph;

        hr = m_pDvdGB->GetFiltergraph(&pFilterGraph);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        CComPtr<IBaseFilter> pFilter;
        CComPtr<IEnumFilters> pEnum;
        
        hr = pFilterGraph->EnumFilters(&pEnum);

        pFilterGraph->Release();

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = E_FAIL; // set the hr to E_FAIL in case we do not find the IBasicAudio

        while(pEnum->Next(1, &pFilter, NULL) == S_OK){
            
            HRESULT hrTmp = pFilter->QueryInterface(iid, ppvObject);

            pFilter.Release();

            if(SUCCEEDED(hrTmp)){

                ATLASSERT(*ppvObject);
                // found our audio time to break
                if(*ppvObject == NULL){

                    throw(E_UNEXPECTED);
                }/* end of if statement */

                hr = hrTmp; // set the hr to SUCCEED
                break;
            }/* end of if statement */
        }/* end of while loop */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return hr;
}/* end of function TraverseForInterface */
 
/*************************************************************************/
/* Function: SetupEventNotifySink                                        */
/* Description: Gets the event notify sink interface.                    */
/*************************************************************************/
HRESULT CMSWebDVD::SetupEventNotifySink(){

    HRESULT hr = E_FAIL;

    try {
        if(m_pMediaSink){

            m_pMediaSink.Release();
        }/* end of if statement */

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        IGraphBuilder *pFilterGraph;

        hr = m_pDvdGB->GetFiltergraph(&pFilterGraph);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = pFilterGraph->QueryInterface(IID_IMediaEventSink, (void**)&m_pMediaSink);

        pFilterGraph->Release();
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return hr;
}/* end of function SetupEventNotifySink */

/*************************************************************************/
/* Function: OnPostVerbInPlaceActivate                                   */
/* Description: Creates the in place active object.                      */
/*************************************************************************/
HRESULT CMSWebDVD::OnPostVerbInPlaceActivate(){

    SetReadyState(READYSTATE_COMPLETE);

    return(S_OK);
}/* end of function OnPostVerbInPlaceActivate */

/*************************************************************************/
/* Function: RenderGraphIfNeeded                                         */
/* Description: Initializes graph if it needs to be.                     */ 
/*************************************************************************/
HRESULT CMSWebDVD::RenderGraphIfNeeded(){

    HRESULT hr = S_OK;

    try {
        m_DVDFilterState = dvdState_Undefined; // just a flag set so we can restore
                                               // graph state if the API fails
        if(!m_fInitialized){

            hr = Render(); // render the graph
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function RenderGraphIfNeeded */

/*************************************************************************/
/* Function: PassFP_DOM                                                  */
/* Description: Gets into title domain, past fp domain.                  */ 
/*************************************************************************/
HRESULT CMSWebDVD::PassFP_DOM(){

    HRESULT hr = S_OK;

    try {
        // get the curent domain
        DVD_DOMAIN domain;

        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetCurrentDomain(&domain);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
            
        if(DVD_DOMAIN_FirstPlay == domain /* || DVD_DOMAIN_VideoManagerMenu == domain */){
            // if the domain is FP_DOM wait a specified timeout 
            if(NULL == m_hFPDOMEvent){

                ATLTRACE(TEXT("The handle should have been already set \n"));
                throw(E_UNEXPECTED);
            }/* end of if statement */

            if(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hFPDOMEvent, cdwMaxFP_DOMWait)){

                hr = S_OK;
            }
            else {

                hr = E_FAIL;
            }/* end of if statement */
        } 
        else {

            hr = E_FAIL; // we were not originally in FP_DOM so it should have worked
            // there is a potential for raice condition, when we issue the command
            // the command failed due to that we were not in FP_DOM, but after the execution
            // it has changed before we got a chance to look it up
        }/* end of if statement */        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function PassFP_DOM */

/*************************************************************/
/* Name: OpenCdRom                                           */
/* Description: Open CDRom and return the device ID          */
/*************************************************************/
DWORD CMSWebDVD::OpenCdRom(TCHAR chDrive, LPDWORD lpdwErrCode){

	MCI_OPEN_PARMS  mciOpen;
	TCHAR           szElementName[4];
	TCHAR           szAliasName[32];
	DWORD           dwFlags;
	DWORD           dwAliasCount = GetCurrentTime();
	DWORD           dwRet;

    ZeroMemory( &mciOpen, sizeof(mciOpen) );

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    StringCchPrintf( szElementName, sizeof(szElementName) / sizeof(szElementName[0]), TEXT("%c:"), chDrive );
    StringCchPrintf( szAliasName, sizeof(szAliasName) / sizeof(szAliasName[0]), TEXT("SJE%lu:"), dwAliasCount );
    mciOpen.lpstrAlias = szAliasName;

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    mciOpen.lpstrElementName = szElementName;
    dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
	      MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

	// send mci command
    dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, reinterpret_cast<DWORD_PTR>(&mciOpen));

    if ( dwRet != MMSYSERR_NOERROR ) 
		mciOpen.wDeviceID = 0;

    if (lpdwErrCode != NULL)
		*lpdwErrCode = dwRet;

    return mciOpen.wDeviceID;
}/* end of function OpenCdRom */

/*************************************************************/
/* Name: CloseCdRom                                          */
/* Description: Close device handle for CDRom                */
/*************************************************************/
HRESULT CMSWebDVD::CloseCdRom(DWORD DevHandle){
	MCI_OPEN_PARMS  mciOpen;
    ZeroMemory( &mciOpen, sizeof(mciOpen) );
	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_CLOSE, 0L, reinterpret_cast<DWORD_PTR>(&mciOpen) );
    HRESULT hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return (hr);
}/* end of function CloseCdRom */

/*************************************************************/
/* Name: EjectCdRom                                          */
/* Description: Open device door for CDRom                   */
/*************************************************************/
HRESULT CMSWebDVD::EjectCdRom(DWORD DevHandle){
	MCI_OPEN_PARMS  mciOpen;
    ZeroMemory( &mciOpen, sizeof(mciOpen) );
	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_OPEN, reinterpret_cast<DWORD_PTR>(&mciOpen) );
    HRESULT hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return (hr);
}/* end of function EjectCdRom */

/*************************************************************/
/* Name: UnEjectCdRom                                        */
/* Description: Close device door for CDRom                  */
/*************************************************************/
HRESULT CMSWebDVD::UnEjectCdRom(DWORD DevHandle){
	MCI_OPEN_PARMS  mciOpen;
    ZeroMemory( &mciOpen, sizeof(mciOpen) );

	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_CLOSED, reinterpret_cast<DWORD_PTR>(&mciOpen) );
    HRESULT hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return (hr);
}/* end of function UnEjectCdRom */

/*************************************************************************/
/* Function: SetupDDraw                                                  */
/* Description: Creates DDrawObject and Surface                          */
/*************************************************************************/
HRESULT CMSWebDVD::SetupDDraw(){

    HRESULT hr = E_UNEXPECTED;
        
    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    IAMSpecifyDDrawConnectionDevice* pSDDC;
    hr = m_pDDEX->QueryInterface(IID_IAMSpecifyDDrawConnectionDevice, (LPVOID *)&pSDDC);
    if (FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    AMDDRAWGUID amGUID;
    hr = pSDDC->GetDDrawGUID(&amGUID);
    if (FAILED(hr)){

        pSDDC->Release();
        return(hr);
    }/* end of if statement */

    hr = pSDDC->GetDDrawGUIDs(&m_dwNumDevices, &m_lpInfo);
    pSDDC->Release();

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    UpdateCurrentMonitor(&amGUID);

    m_pDDrawDVD = new CDDrawDVD(this);

    if(NULL == m_pDDrawDVD){

        return(E_OUTOFMEMORY);
    }

    hr = m_pDDrawDVD->SetupDDraw(&amGUID, hwnd);

    return(hr);
}/* end of function SetupDDraw */

/*************************************************************************/
/* Function: TransformToWndwls                                           */
/* Description: Transforms the coordinates to screen onse.               */
/*************************************************************************/
HRESULT CMSWebDVD::TransformToWndwls(POINT& pt){

    HRESULT hr = S_FALSE;

    // we are windowless we need to map the points to screen coordinates
    if(m_bWndLess){

        HWND hwnd = NULL;

        hr = GetParentHWND(&hwnd);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */

        if(!::IsWindow(hwnd)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

#ifdef _DEBUG
       // POINT ptOld = pt;
#endif

        ::MapWindowPoints(hwnd, ::GetDesktopWindow(), &pt, 1);

        hr = S_OK;

#ifdef _DEBUG
       // ATLTRACE(TEXT("Mouse Client:x= %d, y = %d, Screen: x=%d, y= %d\n"),ptOld.x, ptOld.y, pt.x, pt.y); 
#endif
    }/* end of if statement */

    return(hr);
}/* end of function TransformToWndwls */

/*************************************************************************/
/* Function: RestoreGraphState                                           */
/* Description: Restores the graph state.  Used when API fails.          */
/*************************************************************************/
HRESULT CMSWebDVD::RestoreGraphState(){

    HRESULT hr = S_OK;

    switch(m_DVDFilterState){
        case dvdState_Undefined: 
        case dvdState_Running:  // do not do anything 
            break;

        case dvdState_Unitialized:
        case dvdState_Stopped:  hr = Stop(); break;

        case dvdState_Paused: hr = Pause();		      
    }/* end of switch statement */

    return(hr);
}/* end of if statement */

/*************************************************************************/
/* Function: AppendString                                                */
/* Description: Appends a string to an existing one.                     */
/*************************************************************************/
HRESULT CMSWebDVD::AppendString(TCHAR* strDest, INT strID, LONG dwLen){

    TCHAR strBuffer[MAX_PATH];

    if(!::LoadString(_Module.m_hInstResource, strID, strBuffer, MAX_PATH)){

        return(E_UNEXPECTED);
    }/* end of if statement */

    StringCchCat(strDest, dwLen, strBuffer);

    return(S_OK);
}/* end of function AppendString */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSWebDVD::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){

            switch(hr){

                case E_REGION_CHANGE_FAIL: Error(IDS_REGION_CHANGE_FAIL);   return (hr);
                case E_NO_IDVD2_PRESENT: Error(IDS_EDVD2INT);   return (hr);
                case E_FORMAT_NOT_SUPPORTED: Error(IDS_FORMAT_NOT_SUPPORTED);   return (hr);
                case E_NO_DVD_VOLUME: Error(IDS_E_NO_DVD_VOLUME); return (hr);
                case E_REGION_CHANGE_NOT_COMPLETED: Error(IDS_E_REGION_CHANGE_NOT_COMPLETED); return(hr);
                case E_NO_SOUND_STREAM: Error(IDS_E_NO_SOUND_STREAM); return(hr);                    
                case E_NO_VIDEO_STREAM: Error(IDS_E_NO_VIDEO_STREAM); return(hr);                    
                case E_NO_OVERLAY: Error(IDS_E_NO_OVERLAY); return(hr);
                case E_NO_USABLE_OVERLAY: Error(IDS_E_NO_USABLE_OVERLAY); return(hr);
                case E_NO_DECODER: Error(IDS_E_NO_DECODER); return(hr);
                case E_NO_CAPTURE_SUPPORT: Error(IDS_E_NO_CAPTURE_SUPPORT); return(hr);
            }/* end of switch statement */

            // Ensure that the string is Null Terminated
            TCHAR strError[MAX_ERROR_TEXT_LEN+1];
            ZeroMemory(strError, MAX_ERROR_TEXT_LEN+1);


            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                ATLASSERT(FALSE);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************/
/* Name: get_ShowCursor                                      */
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_ShowCursor(VARIANT_BOOL* pfShow)
{
   HRESULT hr = S_OK;

   try {

       if(NULL == pfShow){

           throw(E_POINTER);
       }/* end of if statement */

       CURSORINFO pci;
       ::ZeroMemory(&pci, sizeof(CURSORINFO));
       pci.cbSize = sizeof(CURSORINFO);

#if WINVER >= 0x0500
       if(!::GetCursorInfo(&pci)){
#else
       if(!CallGetCursorInfo(&pci)){
#endif
           throw(E_FAIL);
       }/* end of if statement */
       
       *pfShow = (pci.flags  == CURSOR_SHOWING) ? VARIANT_TRUE:VARIANT_FALSE;        
   }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return (hr);
}/* end of function get_ShowCursor */

/*************************************************************/
/* Name: put_ShowCursor                                      */
/* Description: Shows the cursor or hides it.                */
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_ShowCursor(VARIANT_BOOL fShow){

   HRESULT hr = S_OK;

   try {

        BOOL bTemp = (fShow==VARIANT_FALSE) ? FALSE:TRUE;

        if (bTemp)
            // Call ShowCursor(TRUE) until new counter is >= 0
            while (::ShowCursor(bTemp) < 0);
        else
            // Call ShowCursor(FALSE) until new counter is < 0
            while (::ShowCursor(bTemp) >= 0);

   }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return (hr);
}/* end of function put_ShowCursor */

/*************************************************************/
/* Name: GetLangFromLangID                                   */
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetLangFromLangID(long langID, BSTR* lang){

    HRESULT hr = S_OK;

    try {
        if (lang == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        USES_CONVERSION;
        if((unsigned long)langID > (WORD)langID){
            throw(E_INVALIDARG);
        }
        LPTSTR pszString = m_LangID.GetLangFromLangID((WORD)langID);
    
        if (pszString) {
            *lang = ::SysAllocString(T2OLE(pszString));
        }
        
        else {
            *lang = ::SysAllocString( L"");
            throw(E_INVALIDARG);
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function GetLangFromLangID */

/*************************************************************/
/* Name: IsAudioStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::IsAudioStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = m_pDvdInfo2->IsAudioStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: IsSubpictureStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::IsSubpictureStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = m_pDvdInfo2->IsSubpictureStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: DVDTimeCode2bstr
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::DVDTimeCode2bstr(long timeCode, BSTR *pTimeStr)
{
    return DVDTime2bstr((DVD_HMSF_TIMECODE*)&timeCode, pTimeStr);
}

/*************************************************************/
/* Name: UpdateOverlay
/* Description: 
/*************************************************************/
HRESULT CMSWebDVD::UpdateOverlay()
{
    RECT rc;    
    HWND hwnd;
    
    if(m_bWndLess){
        HRESULT hr = GetParentHWND(&hwnd);
        
        if(FAILED(hr)){
            
            return(hr);
        }/* end of if statement */
        
        rc = m_rcPos;
    }
    else {
        hwnd = m_hWnd;
        ::GetClientRect(hwnd, &rc);
    }/* end of if statement */
    
    ::InvalidateRect(hwnd, &rc, FALSE);

    m_bFireUpdateOverlay = TRUE;
    return S_OK;
}

HRESULT CMSWebDVD::SetClientSite(IOleClientSite *pClientSite){
    if(!!pClientSite){
        HRESULT hr = IsSafeSite(pClientSite);
        if(FAILED(hr)){
            return hr;
        }
    }
    return IOleObjectImpl<CMSWebDVD>::SetClientSite(pClientSite);
}
/*************************************************************************/
/* End of file: msdvd.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\mediahndlr.h ===
//
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
#ifndef __CMediaHandler__h
#define __CMediaHandler__h

#include "msgwindow.h"

class CMSWebDVD;
//
//  Specific code
//
class CMediaHandler : public CMsgWindow 
{
    typedef CMsgWindow ParentClass ;

public:
                        CMediaHandler();
                        ~CMediaHandler() ;

    virtual LRESULT     WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam );

    bool                WasEjected() const { return m_ejected; };
    bool                WasInserted() const { return m_inserted; };
    void                ClearFlags();

    bool                SetDrive( TCHAR tcDriveLetter );

    // currently unused by the pump thread, but it will be required if the ejection
    // handler becomes a new thread
    HANDLE              GetEventHandle() const;

    void                SetDVD(CMSWebDVD* pDVD) {m_pDVD = pDVD;};

private:
    DWORD               m_driveMask;

    bool                m_ejected;
    bool                m_inserted;
    CMSWebDVD*          m_pDVD;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\msdvd.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: msdvd.h                                                         */
/* Description: Declaration of CMSWebDVD                                 */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSWEBDVD_H_
#define __MSWEBDVD_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <streams.h>
#include <dvdevcod.h>
#include "MSWebDVD.h"
#include "MSWebDVDCP.h"
#include "MSDVDAdm.h"
#include "ThunkProc.h" // for template for MSDVD timer
#include "MSLCID.h"
#include "mediahndlr.h"

//
// Special user message used by the app for event notification
//
#define WM_DVDPLAY_EVENT    (WM_USER+101)
#define NO_STOP             (-1)
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

#define UNDEFINED_COLORKEY_COLOR 0xff000000
#define MAGENTA_COLOR_KEY 0x00ff00ff
#define DEFAULT_COLOR_KEY 0x00100010
#define DEFAULT_BACK_COLOR 0x00100010
#define OCR_ARROW_DEFAULT 100

/////////////////////////////////////////////////////////////////////////////////
// copied from vpinfo.h which is a private header

#if defined(CCHDEVICENAME)
#define AMCCHDEVICENAME CCHDEVICENAME
#else
#define AMCCHDEVICENAME 32
#endif
#define AMCCHDEVICEDESCRIPTION  256

#define AMDDRAWMONITORINFO_PRIMARY_MONITOR          0x0001
typedef struct {
    GUID*       lpGUID; // is NULL if the default DDraw device
    GUID        GUID;   // otherwise points to this GUID
} AMDDRAWGUID;


typedef struct {
    AMDDRAWGUID guid;
    RECT        rcMonitor;
    HMONITOR    hMon;
    DWORD       dwFlags;
    char        szDevice[AMCCHDEVICENAME];
    char        szDescription[AMCCHDEVICEDESCRIPTION];
    DDCAPS_DX3  ddHWCaps;
} AMDDRAWMONITORINFO;


DECLARE_INTERFACE_(IAMSpecifyDDrawConnectionDevice, IUnknown)
{
    // Use this method on a Multi-Monitor system to specify to the overlay
    // mixer filter which Direct Draw driver should be used when connecting
    // to an upstream decoder filter.
    //
    STDMETHOD (SetDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method to determine the direct draw object that will be used when
    // connecting the overlay mixer filter to an upstream decoder filter.
    //
    STDMETHOD (GetDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to specify to the
    // overlay mixer filter the default Direct Draw device to use when
    // connecting to an upstream filter.  The default direct draw device
    // can be overriden for a particular connection by SetDDrawGUID method
    // described above.
    //
    STDMETHOD (SetDefaultDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to determine which
    // is the default direct draw device the overlay mixer filter
    // will  use when connecting to an upstream filter.
    //
    STDMETHOD (GetDefaultDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;


    // Use this method to get a list of Direct Draw device GUIDs and thier
    // associated monitor information that the overlay mixer can use when
    // connecting to an upstream decoder filter.
    //
    // The method allocates and returns an array of AMDDRAWMONITORINFO
    // structures, the caller of function is responsible for freeing this
    // memory when it is no longer needed via CoTaskMemFree.
    //
    STDMETHOD (GetDDrawGUIDs)(THIS_
        /* [out] */ LPDWORD lpdwNumDevices,
        /* [out] */ AMDDRAWMONITORINFO** lplpInfo
        ) PURE;
};


typedef struct {
    long    lHeight;       // in pels
    long    lWidth;        // in pels
    long    lBitsPerPel;   // Usually 16 but could be 12 for the YV12 format
    long    lAspectX;      // X aspect ratio
    long    lAspectY;      // Y aspect ratio
    long    lStride;       // stride in bytes
    DWORD   dwFourCC;      // YUV type code ie. 'YUY2', 'YV12' etc
    DWORD   dwFlags;       // Flag used to further describe the image
    DWORD   dwImageSize;   // Size of the bImage array in bytes, which follows this
                           // data structure

//  BYTE    bImage[dwImageSize];

} YUV_IMAGE;

#define DM_BOTTOMUP_IMAGE   0x00001
#define DM_TOPDOWN_IMAGE    0x00002
#define DM_FIELD_IMAGE      0x00004
#define DM_FRAME_IMAGE      0x00008


DECLARE_INTERFACE_(IDDrawNonExclModeVideo , IDDrawExclModeVideo )
{
    //
    // Call this function to capture the current image being displayed
    // by the overlay mixer.  It is not always possible to capture the
    // current frame, for example MoComp may be in use.  Applications
    // should always call IsImageCaptureSupported (see below) before
    // calling this function.
    //
    STDMETHOD (GetCurrentImage)(THIS_
        /* [out] */ YUV_IMAGE** lplpImage
        ) PURE;

    STDMETHOD (IsImageCaptureSupported)(THIS_
        ) PURE;

    //
    // On a multi-monitor system, applications call this function when they
    // detect that the playback rectangle has moved to a different monitor.
    // This call has no effect on a single monitor system.
    //
    STDMETHOD (ChangeMonitor)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // When an application receives a WM_DISPLAYCHANGE message it should
    // call this function to allow the OVMixer to recreate DDraw surfaces
    // suitable for the new display mode.  The application itself must re-create
    // the new DDraw object and primary surface passed in the call.
    //
    STDMETHOD (DisplayModeChanged)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // Applications should continually check that the primary surface passed
    // to the OVMixer does not become "lost", ie. the user entered a Dos box or
    // pressed Alt-Ctrl-Del.  When "surface loss" is detected the application should
    // call this function so that the OVMixer can restore the surfaces used for
    // video playback.
    //
    STDMETHOD (RestoreSurfaces)(THIS_
        ) PURE;
};

////////////////////////////////////////////////////////////////////////////////////
/*************************************************************************/
/* Local Defines to sort of abstract the implementation and make the     */
/* changes bit more convinient.                                          */
/*************************************************************************/
#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE   \
        {                                 \
            hr = RenderGraphIfNeeded();   \
            if(FAILED(hr)){               \
                                          \
                throw(hr);                \
            }/* end of if statement */    \
        }

#define RETRY_IF_IN_FPDOM(func)              \
        {                                    \
            hr = (func);                     \
            if((VFW_E_DVD_INVALIDDOMAIN == hr || \
                VFW_E_DVD_OPERATION_INHIBITED == hr)){  \
                if(SUCCEEDED(PassFP_DOM())){ \
                                             \
                    hr = (func);             \
                }/* end of if statement */   \
            }/* end of if statement */       \
            if(FAILED(hr)){                  \
                RestoreGraphState();         \
            }/* end of if statement */       \
        }


#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY   \
        {                                          \
            hr = Play(); /* put in the play mode*/  \
                                                   \
            if(FAILED(hr)){                        \
                                                   \
                throw(hr);                         \
            }/* end of if statement */             \
        }

class CDDrawDVD;
class COverlayCallback;

/////////////////////////////////////////////////////////////////////////////
// CMSWebDVD
class ATL_NO_VTABLE CMSWebDVD :
	public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CMSWebDVD, IMSWebDVD, &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>,    
    public IPropertyNotifySinkCP<CMSWebDVD>,
	public CComControl<CMSWebDVD>,
	public IPersistStreamInitImpl<CMSWebDVD>,
	public IOleControlImpl<CMSWebDVD>,
	public IOleObjectImpl<CMSWebDVD>,
	public IOleInPlaceActiveObjectImpl<CMSWebDVD>,
	public IViewObjectExImpl<CMSWebDVD>,
	public IOleInPlaceObjectWindowlessImpl<CMSWebDVD>,
	public IPersistStorageImpl<CMSWebDVD>,
	public ISpecifyPropertyPagesImpl<CMSWebDVD>,
	public IDataObjectImpl<CMSWebDVD>,
	public IProvideClassInfo2Impl<&CLSID_MSWebDVD, &DIID__IMSWebDVD, &LIBID_MSWEBDVDLib>,
	public CComCoClass<CMSWebDVD, &CLSID_MSWebDVD>,
    public IObjectSafety,
    public ISupportErrorInfo,
    public IPersistPropertyBagImpl<CMSWebDVD>,
	public CProxy_IMSWebDVD< CMSWebDVD >,
#ifdef _WMP
    public IWMPUIPluginImpl<CMSWebDVD>,
    public IWMPUIPluginEventsImpl,
#endif
    public IConnectionPointContainerImpl<CMSWebDVD>,
    public IObjectWithSiteImplSec<CMSWebDVD>,
    public CMSDVDTimer<CMSWebDVD>
{
public:
    CMSWebDVD();
    virtual ~CMSWebDVD();

//DECLARE_CLASSFACTORY_SINGLETON(CMSWebDVD)

DECLARE_REGISTRY_RESOURCEID(IDR_MSWEBDVD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSWebDVD)
	COM_INTERFACE_ENTRY(IMSWebDVD)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)    
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

BEGIN_PROP_MAP(CMSWebDVD)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("DisableAutoMouseProcessing", 70, CLSID_NULL)
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("EnableResetOnStop", 66, CLSID_NULL)
    PROP_ENTRY("ColorKey", 58, CLSID_NULL)
    PROP_ENTRY("WindowlessActivation", 69, CLSID_NULL)
#if 0
    PROP_ENTRY("ToolTip",    92, CLSID_NULL)
    PROP_ENTRY("ToolTipMaxWidth", 95, CLSID_NULL)
#endif
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSWebDVD)
	CONNECTION_POINT_ENTRY(DIID__IMSWebDVD)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CMSWebDVD)
	MESSAGE_HANDLER(WM_CREATE, OnCreate); // works only in windowed case
	MESSAGE_HANDLER(WM_DESTROY,OnDestroy);// works only in windowed case
    MESSAGE_HANDLER(WM_SIZE, OnSize);
    MESSAGE_HANDLER(WM_SIZING, OnSize);
    MESSAGE_HANDLER(WM_ERASEBKGND,  OnErase)
    MESSAGE_HANDLER(WM_DVDPLAY_EVENT, OnDVDEvent);
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseToolTip)
    MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDispChange);
    MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);
	CHAIN_MSG_MAP(CComControl<CMSWebDVD>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
	
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSWebDVD
public:
	STDMETHOD(get_FullScreenMode)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_FullScreenMode)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(PlayChaptersAutoStop)(LONG lTitle, LONG lstrChapter, LONG lChapterCount);
	STDMETHOD(GetNumberOfChapters)(long lTitle, /*[out, retval]*/ long *pVal);
	STDMETHOD(get_TitlesAvailable)(/*[out, retval]*/ long* pVal);
	STDMETHOD(Render)(/*[in]*/ long lRender = 0);
	STDMETHOD(Stop)();
	STDMETHOD(Pause)();
	STDMETHOD(Play)();
	STDMETHOD(PlayTitle)(LONG lTitle);
	STDMETHOD(PlayChapterInTitle)(LONG lTitle, LONG lChapter);
	STDMETHOD(PlayChapter)(LONG lChapter);
    STDMETHOD(GetSubpictureLanguage)(LONG lStream, BSTR* strLanguage);
	STDMETHOD(PlayAtTime)(BSTR strTime);
	STDMETHOD(PlayAtTimeInTitle)(long lTitle, BSTR strTime);
    STDMETHOD(PlayPeriodInTitleAutoStop)(long lTitle, BSTR strStartTime, BSTR strEndTime);
	STDMETHOD(ReplayChapter)();
	STDMETHOD(PlayPrevChapter)();
	STDMETHOD(PlayNextChapter)();
	STDMETHOD(PlayForwards)(double dSpeed, VARIANT_BOOL fDoNotReset);
	STDMETHOD(PlayBackwards)(double dSpeed, VARIANT_BOOL fDoNotReset);
	STDMETHOD(StillOff)();
	STDMETHOD(GetAudioLanguage)(LONG lStream, VARIANT_BOOL fFormat, BSTR* strAudioLang);
	STDMETHOD(ReturnFromSubmenu)();
	STDMETHOD(SelectAndActivateButton)(long lButton);
	STDMETHOD(ActivateButton)();
	STDMETHOD(SelectRightButton)();
	STDMETHOD(SelectLeftButton)();
	STDMETHOD(SelectLowerButton)();
	STDMETHOD(SelectUpperButton)();
	STDMETHOD(get_PlayState)(/*[out, retval]*/ DVDFilterState *pVal);
	STDMETHOD(ShowMenu)(DVDMenuIDConstants MenuID);
	STDMETHOD(Resume)();
    STDMETHOD(get_CurrentSubpictureStream)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentSubpictureStream)(/*[in]*/ long newVal);
	STDMETHOD(get_VolumesAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentVolume)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentDiscSide)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentDomain)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_DVDDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DVDDirectory)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CurrentTime)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_FramesPerSecond)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentChapter)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentTitle)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_ColorKey)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_ColorKey)(/*[in]*/ long newVal);
	STDMETHOD(get_CurrentAudioStream)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentAudioStream)(/*[in]*/ long newVal);
	STDMETHOD(get_AudioStreamsAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_AnglesAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentAngle)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentAngle)(/*[in]*/ long newVal);
	STDMETHOD(get_CCActive)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_CCActive)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ButtonsAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentButton)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentCCService)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentCCService)(/*[in]*/ long newVal);
	STDMETHOD(get_TotalTitleTime)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SubpictureStreamsAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_SubpictureOn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SubpictureOn)(/*[in]*/ VARIANT_BOOL newVal);
   	STDMETHOD(UOPValid)(long lUOP, VARIANT_BOOL* pfValid);
    STDMETHOD(get_Balance)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Balance)(/*[in]*/ long newVal);
	STDMETHOD(get_Volume)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Volume)(/*[in]*/ long newVal);
	STDMETHOD(get_Mute)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Mute)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_DVDUniqueID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(GetSPRM)(long lIndex, short *psSPRM);
	STDMETHOD(GetGPRM)(long lIndex, short *psSPRM);
    STDMETHOD(get_EnableResetOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_EnableResetOnStop)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_BackColor)(VARIANT* pclrBackColor);
    STDMETHOD(put_BackColor)(VARIANT clrBackColor);
	STDMETHOD(get_ReadyState)(/*[out, retval]*/ LONG *pVal);
    STDMETHOD(ActivateAtPosition)(long xPos, long yPos);
    STDMETHOD(SelectAtPosition)(long xPos, long yPos);
	STDMETHOD(get_DisableAutoMouseProcessing)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_DisableAutoMouseProcessing)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_WindowlessActivation)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_WindowlessActivation)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(GetButtonRect)(long lButton, IDVDRect** pRect);
	STDMETHOD(GetButtonAtPosition)(long xPos, long yPos, long* plButton);
    STDMETHOD(AcceptParentalLevelChange)(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword);	
	STDMETHOD(NotifyParentalLevelChange)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(SelectParentalCountry)(long lCountry, BSTR strUserName, BSTR strPassword);
	STDMETHOD(SelectParentalLevel)(long lParentalLevel, BSTR strUserName, BSTR strPassword);
	STDMETHOD(GetTitleParentalLevels)(long lTitle, long* plParentalLevels);
	STDMETHOD(GetPlayerParentalCountry)(long* plCountryCode);
	STDMETHOD(GetPlayerParentalLevel)(long* plParentalLevel);
	STDMETHOD(SetClipVideoRect)(IDVDRect* pRect);
	STDMETHOD(GetVideoSize)(IDVDRect** ppRect);
	STDMETHOD(GetClipVideoRect)(IDVDRect** ppRect);
	STDMETHOD(SetDVDScreenInMouseCoordinates)(IDVDRect* pRect);
	STDMETHOD(GetDVDScreenInMouseCoordinates)(IDVDRect** ppRect);	
#if 1
	STDMETHOD(get_ToolTip)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ToolTip)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ToolTipMaxWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_ToolTipMaxWidth)(/*[in]*/ long newVal);
    STDMETHOD(GetDelayTime)(/*[in]*/ long delayType, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(SetDelayTime)(/*[in]*/ long delayType, /*[in]*/ VARIANT newVal);	
#endif
    HRESULT ProcessEvents();
	STDMETHOD(Eject)();
    STDMETHOD(SetGPRM)(long lIndex, short sValue);
    STDMETHOD(GetDVDTextStringType)(long lLangIndex, long lStringIndex,  DVDTextStringType* pType);
	STDMETHOD(GetDVDTextString)(long lLangIndex, long lStringIndex,  BSTR* pstrText);
	STDMETHOD(GetDVDTextNumberOfStrings)(long lLangIndex, long* plNumOfStrings);
	STDMETHOD(GetDVDTextNumberOfLanguages)(long* plNumOfLangs);
	STDMETHOD(GetDVDTextLanguageLCID)(/*[in]*/ long lLangIndex, /*[out, retval]*/ long* lcid);
    STDMETHOD(RegionChange)();
	STDMETHOD(Zoom)(long x, long y, double zoomRatio);
	STDMETHOD(get_CursorType)(/*[out, retval]*/ DVDCursorType *pVal);
	STDMETHOD(put_CursorType)(/*[in]*/ DVDCursorType newVal);
	STDMETHOD(get_DVDAdm)(/*[out, retval]*/ IDispatch* *pVal);
    STDMETHOD(DeleteBookmark)();
	STDMETHOD(RestoreBookmark)();
    STDMETHOD(SaveBookmark)();
    STDMETHOD(Capture)();
    STDMETHOD(SelectDefaultAudioLanguage)(long lang, long ext);
	STDMETHOD(SelectDefaultSubpictureLanguage)(long lang, DVDSPExt ext);
    STDMETHOD(get_PreferredSubpictureStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan);
    STDMETHOD(Step)(long lStep);
    STDMETHOD(get_DefaultMenuLanguage)(long* lang);
	STDMETHOD(put_DefaultMenuLanguage)(long lang);
    STDMETHOD(get_DefaultSubpictureLanguage)(long* lang);
	STDMETHOD(get_DefaultAudioLanguage)(long *lang);
	STDMETHOD(get_DefaultSubpictureLanguageExt)(DVDSPExt* ext);
	STDMETHOD(get_DefaultAudioLanguageExt)(long *ext);
	STDMETHOD(get_KaraokeAudioPresentationMode)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_KaraokeAudioPresentationMode)(/*[in]*/ long newVal);
	STDMETHOD(GetKaraokeChannelContent)(long lStream, long lChan, long* lContent);
	STDMETHOD(GetKaraokeChannelAssignment)(long lStream, long *lChannelAssignment);
	STDMETHOD(get_AspectRatio)(/*[out, retval]*/ double *pVal);
	STDMETHOD(put_ShowCursor)(VARIANT_BOOL fShow);
    STDMETHOD(get_ShowCursor)(VARIANT_BOOL* pfShow);
	STDMETHOD(GetLangFromLangID)(/*[in]*/ long langID, /*[out, retval]*/ BSTR* lang);
	STDMETHOD(DVDTimeCode2bstr)(/*[in]*/ long timeCode, /*[out, retval]*/ BSTR *pTimeStr);
	STDMETHOD(IsSubpictureStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);
	STDMETHOD(IsAudioStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);


    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);
	

	//ISafety
    STDMETHOD(GetInterfaceSafetyOptions)( REFIID riid,
                                          DWORD *pdwSupportedOptions,
                                          DWORD *pdwEnabledOptions );

    STDMETHOD(SetInterfaceSafetyOptions)( REFIID riid,
                                          DWORD dwOptionSetMask,
                                          DWORD dwEnabledOptions );
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    // local helper functions
public:
    HRESULT AdjustDestRC();
	HRESULT OnDraw(ATL_DRAWINFO& di);

#ifdef _WMP
	HRESULT InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/);
#endif 

    HRESULT OnPostVerbInPlaceActivate();
    HRESULT TimerProc(); // needs to be called from a timer proc
    static CWndClassInfo& GetWndClassInfo(){
        static HBRUSH hbr= ::CreateSolidBrush(RGB(0,0,0));




        /**********************************
        #define OCR_ARROW_DEFAULT 100
        // need special cursor, we we do not have color key around it
        static HCURSOR hcr = (HCURSOR) ::LoadImage((HINSTANCE) NULL,
                                MAKEINTRESOURCE(OCR_ARROW_DEFAULT),
                                IMAGE_CURSOR,0,0,0);
        *********************/
	    static CWndClassInfo wc = {{ sizeof(WNDCLASSEX), 0, StartWindowProc,

		      0, 0, NULL, NULL, NULL, /* NULL */ hbr,
              NULL, TEXT("MSMFVideoClass"), NULL },
		    NULL, NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT), TRUE, 0, _T("") };
	    return wc;
    }/* end of function GetWndClassInfo */

private:
    VOID Init();
    VOID Cleanup();
    HRESULT SetDDrawExcl();
    LRESULT OnDVDEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnErase(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseToolTip(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT SetReadyState(LONG lReadyState);
    static HRESULT DVDTime2bstr(const DVD_HMSF_TIMECODE *pulTime, BSTR *pbstrTime);
    static HRESULT Bstr2DVDTime(DVD_HMSF_TIMECODE *pulTime, const BSTR *pbstrTime);
    HRESULT SetColorKey(COLORREF clr);
    HRESULT GetColorKey(COLORREF* pClr);
    HRESULT TraverseForInterface(REFIID iid, LPVOID* ppvObject);
    HRESULT SetupAudio(); // fills in the audio interface
    HRESULT SetupDDraw();
    HRESULT SetupEventNotifySink(); // sets up IMediaEventSink
    HRESULT RenderGraphIfNeeded();
    HRESULT PassFP_DOM();
    HRESULT getCDDriveLetter(TCHAR* lpDrive);
    DWORD OpenCdRom(TCHAR chDrive, LPDWORD lpdwErrCode);
    HRESULT CloseCdRom(DWORD DevHandle);
    HRESULT EjectCdRom(DWORD DevHandle);
    HRESULT UnEjectCdRom(DWORD DevHandle);
    HRESULT HandleError(HRESULT hr);
    HRESULT SelectParentalLevel(long lParentalLevel);
    HRESULT SelectParentalCountry(long lCountry);
    HRESULT TransformToWndwls(POINT& pt);
    HRESULT getDVDDriveLetter(TCHAR* lpDrive);
    HRESULT GetMostOuterWindow(HWND* phwndParent);
    HRESULT RestoreDefaultSettings();
    HRESULT GetParentHWND(HWND* pWnd);
    HRESULT GetUsableWindow(HWND* pWnd);
    HRESULT GetClientRectInScreen(RECT* prc);
    HRESULT OnResize(); //helper function that we need to marshal
    HRESULT RestoreGraphState();
    HRESULT AppendString(TCHAR* strDest, INT strID, LONG dwLen);
    HRESULT InvalidateRgn(bool fErase = false);
    // monitor support
    HRESULT RefreshDDrawGuids();
    HRESULT DDrawGuidFromHMonitor(HMONITOR hMon, AMDDRAWGUID* lpGUID);
    bool IsWindowOnWrongMonitor(HMONITOR* lphMon);
    HRESULT RestoreSurfaces();
    HRESULT ChangeMonitor(HMONITOR hMon, const AMDDRAWGUID* lpguid);
    HRESULT DisplayChange(HMONITOR hMon, const AMDDRAWGUID* lpguid);
    HRESULT UpdateCurrentMonitor(const AMDDRAWGUID* lpguid);
    HRESULT HandleMultiMonMove();
    HRESULT HandleMultiMonPaint(HDC hdc);
    HRESULT get_IntVolume(LONG* plVolume);
    HRESULT put_IntVolume(long lVolume);
    HRESULT CanStepBackwards();

// member variables
private:
    LONG              m_lChapter, m_lTitle;
    LONG              m_lChapterCount; // count of the chapters to play
    CComPtr<IDvdGraphBuilder> m_pDvdGB;     // IDvdGraphBuilder interface
    CComPtr<IGraphBuilder>    m_pGB;        // IGraphBuilder interface
    CComPtr<IMediaControl>    m_pMC;        // IMediaControl interface
    CComPtr<IMediaEventEx>    m_pME ;       // IMediaEventEx interface
    CComPtr<IDvdControl2>     m_pDvdCtl2;    // New DVD Control    
    CComPtr<IDvdInfo2>        m_pDvdInfo2;  // New DVD Info Interface
    CComPtr<IBasicAudio>      m_pAudio;     // Audio interface
    CComPtr<IMediaEventSink>  m_pMediaSink;         
    BOOL              m_bUseColorKey; // flag to see if we are using color key
    COLORREF          m_clrColorKey;  // color key
    BOOL              m_bMute;        // mute flag
    LONG              m_lLastVolume; // used to preserve the last volume for mute
    BOOL              m_fEnableResetOnStop; // disable or enable the restart of the seek
    CComPtr<IVideoFrameStep>  m_pVideoFrameStep; 
    CComPtr<IDDrawNonExclModeVideo> m_pDDEX;   // The new interface that can capture
    //IDDrawExclModeVideo *m_pDDEX;   // IDDrawExclModeVideo interface    
    bool              m_fUseDDrawDirect; // flag to switch between a ddraw mode and none ddraw mode
    bool              m_fInitialized; // flag to see if we are initialize
    HANDLE            m_hFPDOMEvent; // handle to the FP_DOM event which gets signaled when we get out of FP_DOM
    bool              m_fDisableAutoMouseProcessing; // Disable the automatic mouse processing
    bool              m_bEjected;   // whether disc is ejected right now
    bool              m_fStillOn;    // flag to see if we have a still
    bool              m_fResetSpeed; 
    CComPtr<IMSDVDAdm> m_pDvdAdmin;
    DVDCursorType     m_nCursorType;
    RECT              *m_pClipRect;
    RECT              m_ClipRectDown;
    BOOL              m_bMouseDown;
    POINT             m_ClipCenter;
    POINT             m_LastMouse;
    POINT             m_LastMouseDown;
    HCURSOR           m_hCursor;
    double            m_dZoomRatio;
    DWORD             m_dwAspectX;
    DWORD             m_dwAspectY;
    DWORD             m_dwVideoWidth;
    DWORD             m_dwVideoHeight;
    DWORD             m_dwOvMaxStretch;
    HWND              m_hWndOuter;
    RECT              m_rcOldPos;
    RECT              m_rcPosAspectRatioAjusted;
    UINT_PTR          m_hTimerId;
    DVDFilterState    m_DVDFilterState;
    MSLangID          m_LangID;
    long              m_lKaraokeAudioPresentationMode;
    DWORD_PTR         m_dwTTReshowDelay;
    DWORD_PTR         m_dwTTAutopopDelay;
    DWORD_PTR         m_dwTTInitalDelay;
    // monitor support
    CDDrawDVD* m_pDDrawDVD;
    DWORD m_dwNumDevices;
    AMDDRAWMONITORINFO* m_lpInfo;
    AMDDRAWMONITORINFO* m_lpCurMonitor;
    BOOL m_MonitorWarn;
    bool m_fStepComplete;
    BOOL m_bFireUpdateOverlay;
    // ejection/insert handling
    // This MUST be in the same thread as the disk reader or we'll
    // end up with some nasty race conditions (ejection notification
    // will happen after a read instead of before)
    CMediaHandler   m_mediaHandler;
    BOOL m_bFireNoSubpictureStream;
#if 1
    HWND m_hWndTip;         // Tooltip window
    LONG m_nTTMaxWidth;     // Max tooltip width
    CComBSTR m_bstrToolTip; // Tooltip string
    BOOL m_bTTCreated;      // Has tooltip been created yet
    HRESULT CreateToolTip();
#endif
    bool m_fBackWardsFlagInitialized;
    bool m_fCanStepBackwards;

// stock properties have to be public due to ATL implementation
public: 		
	LONG m_nReadyState; // ready state change stock property
    OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl	

    void SetDiscEjected(bool bEjected) {m_bEjected = bEjected;};
    HRESULT UpdateOverlay();
};



// error code

#define E_FORMAT_NOT_SUPPORTED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF2)


#endif //__MSWEBDVD_H_
/*************************************************************************/
/* End of file: msdvd.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\msdvdadm.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSDVDAdm.h                                                      */
/* Description: Declaration of the CMSDVDAdm                             */
/* Author: Fang Wang                                                     */
/*************************************************************************/

#ifndef __MSDVDADM_H_
#define __MSDVDADM_H_

#include "resource.h"       // main symbols
#include <atlctl.h>

#define MAX_PASSWD      256
#define PRE_PASSWD      20
#define MAX_SECTION     20
#define MAX_RATE        10

#define LEVEL_G		    1
#define LEVEL_PG	    3
#define LEVEL_PG13	    4
#define LEVEL_R		    6
#define LEVEL_NC17	    7
#define LEVEL_ADULT	    8
#define LEVEL_DISABLED  -1

/////////////////////////////////////////////////////////////////////////////
// CMSDVDAdm
class ATL_NO_VTABLE CMSDVDAdm : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMSDVDAdm, &IID_IMSDVDAdm, &LIBID_MSWEBDVDLib>,
    public IObjectWithSiteImplSec<CMSDVDAdm>,
	public CComCoClass<CMSDVDAdm, &CLSID_MSDVDAdm>,
    public ISupportErrorInfo
{
public:
	CMSDVDAdm();
    virtual ~CMSDVDAdm();

DECLARE_REGISTRY_RESOURCEID(IDR_MSDVDADM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSDVDAdm)
	COM_INTERFACE_ENTRY(IMSDVDAdm)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_PROP_MAP(CMSDVDAdm)
END_PROP_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSDVDAdm
public:
	STDMETHOD(get_DefaultMenuLCID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DefaultMenuLCID)(/*[in]*/ long newVal);
	STDMETHOD(get_DefaultSubpictureLCID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DefaultSubpictureLCID)(/*[in]*/ long newVal);
	STDMETHOD(get_DefaultAudioLCID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DefaultAudioLCID)(/*[in]*/ long newVal);
	STDMETHOD(GetParentalCountry)(long *lCountry);
	STDMETHOD(GetParentalLevel)(long *lLevel);
    STDMETHOD(_ConfirmPassword)(BSTR strUserName, BSTR szPassword, VARIANT_BOOL *fRight);
	STDMETHOD(get_DisableScreenSaver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_DisableScreenSaver)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(ChangePassword)(BSTR strUserName, BSTR strOld, BSTR strNew);
    STDMETHOD(ConfirmPassword)(BSTR strUserName, BSTR szPassword, VARIANT_BOOL *fRight);
    STDMETHOD(SaveParentalLevel)(long lParentalLevel,BSTR strUserName,  BSTR strPassword);
    STDMETHOD(SaveParentalCountry)(long lCountry,BSTR strUserName,  BSTR strPassword);
	STDMETHOD(get_BookmarkOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_BookmarkOnStop)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_BookmarkOnClose)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_BookmarkOnClose)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(RestoreScreenSaver)();
protected:
   	long        m_lParentctrlLevel;
   	long        m_lParentctrlCountry;
    VARIANT_BOOL m_fDisableScreenSaver;
    BOOL        m_bScrnSvrOld;
    BOOL        m_bPowerlowOld;
    BOOL        m_bPowerOffOld;
    VARIANT_BOOL m_fBookmarkOnStop;
    VARIANT_BOOL m_fBookmarkOnClose;

    HRESULT EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *dwCryptLen, DWORD *dwAssault, BOOL genAssault);
    HRESULT DisableScreenSaver();
    HRESULT SaveScreenSaver();
    HRESULT HandleError(HRESULT hr);
};

    // Lame functions that default to hklm
BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryString(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDword(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

    // Not so lame functions that use hkcu
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

LPTSTR LoadStringFromRes(DWORD redId);

#endif //__MSDVDADM_H_

/*************************************************************************/
/* End of file: MSDVDAdm.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\msgwindow.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <stdafx.h>
#include <windows.h>

#include "msgwindow.h"
extern CComModule _Module;

// limit to this file
//
static const TCHAR szClassName[] = TEXT("CMSWEBDVDMsgWindowClass");
static const TCHAR szDefaultWindowName[] = TEXT("CMSWEBDVDMsgWindowClassName");

//
// CMessageWindow class implementation
// Generic goo to create a dummy window to handle events
//

static LRESULT CALLBACK StaticMsgWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMsgWindow* win = (CMsgWindow*) GetWindowLongPtr( hWnd, GWLP_USERDATA );
    if( !win ) {
        if( uMsg == WM_CREATE) {
            // on WM_CREATE messages the last parameter to CreateWindow() is returned in the lparam
            CREATESTRUCT* pCreate = (CREATESTRUCT *)lParam;
            win = (CMsgWindow*) pCreate->lpCreateParams;
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)win);
            win->SetHandle(hWnd);
        } else {
            return DefWindowProc( hWnd, uMsg, wParam, lParam);
        }
    }
    return win->WndProc( uMsg, wParam, lParam );
}

CMsgWindow::CMsgWindow()
: m_hWnd( NULL )
{
    WNDCLASS wc;  // class data

    if (!GetClassInfo(_Module.GetModuleInstance(), szClassName, &wc))
    {
        //
        // Register message window class
        //
        ZeroMemory(&wc, sizeof(wc)) ;
        wc.lpfnWndProc   = StaticMsgWndProc ;
        wc.hInstance     = _Module.GetModuleInstance() ;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1) ;
        wc.lpszClassName =  szClassName;
        wc.cbWndExtra = sizeof( LONG_PTR );
        if (0 == RegisterClass(&wc) ) // Oops, just leave; we'll catch later...
        {
        }
    }
}

bool CMsgWindow::Open( LPCTSTR pWindowName )
{
    if( m_hWnd ) {
        DestroyWindow( m_hWnd );
    }


    if (NULL == pWindowName) {
        pWindowName = szDefaultWindowName;
    }

    //
    // m_hWnd is assigned during WM_CREATE message processing
    //
    
    HWND hwnd =
    CreateWindowEx(WS_EX_TOOLWINDOW, szClassName, pWindowName,
        WS_ICONIC, 0, 0, 1, 1, NULL, NULL,
        GetModuleHandle(NULL),
        this );

    return (NULL != hwnd);
}

bool CMsgWindow::Close(){

    if(m_hWnd){
        DestroyWindow(m_hWnd);

        //SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (LONG_PTR)0);
        //PostMessage(m_hWnd, WM_CLOSE, 0, 0);
        //m_hWnd = NULL;
    }/* end of if statement */

    return(true);
}/* end of function Close */

CMsgWindow::~CMsgWindow()
{
    SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (LONG_PTR)0);
    PostMessage(m_hWnd, WM_CLOSE, 0, 0);
}

LRESULT CMsgWindow::WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc(m_hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\mslcid.h ===
/*************************************************************/
/* Name: MSLCID.h
/* Description: 
/*************************************************************/
#ifndef MSLCID_H_INCLUDE
#define MSLCID_H_INCLUDE

class MSLangID  
{
public:
    virtual ~MSLangID() {};
    MSLangID();

	struct LanguageList
	{
		UINT   ResourceID;
		WORD   LangID;
	};

	int m_LLlength;
	LanguageList* m_LL;

	LPTSTR GetLangFromLangID(WORD langID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\msdvdadm.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSDVDAdm.cpp                                                    */
/* Description: DImplementation of CMSDVDAdm                             */
/* Author: Fang Wang                                                     */
/*************************************************************************/
#include "stdafx.h"
#include "MSWebDVD.h"
#include "MSDVDAdm.h"
#include "iso3166.h"
#include <stdio.h>
#include <errors.h>
#include <wincrypt.h>

const TCHAR g_szRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\DVD");
const TCHAR g_szPassword[] = TEXT("DVDAdmin.password");
const TCHAR g_szSalt[] = TEXT("DVDAdmin.ps"); // password salt
const TCHAR g_szUserSalt[] = TEXT("DVDAdmin.us"); // username salt
const TCHAR g_szUsername[] = TEXT("DVDAdmin.username");
const TCHAR g_szPlayerLevel[] = TEXT("DVDAdmin.playerLevel");
const TCHAR g_szPlayerCountry[] = TEXT("DVDAdmin.playerCountry");
const TCHAR g_szDisableScrnSvr[] = TEXT("DVDAdmin.disableScreenSaver");
const TCHAR g_szBookmarkOnClose[] = TEXT("DVDAdmin.bookmarkOnClose");
const TCHAR g_szBookmarkOnStop[] = TEXT("DVDAdmin.bookmarkOnStop");
const TCHAR g_szDefaultAudio[] = TEXT("DVDAdmin.defaultAudioLCID");
const TCHAR g_szDefaultSP[] = TEXT("DVDAdmin.defaultSPLCID");
const TCHAR g_szDefaultMenu[] = TEXT("DVDAdmin.defaultMenuLCID");

/*************************************************************/
/* Helper functions                                          */
/*************************************************************/

/*************************************************************/
/* Function: LoadStringFromRes                               */
/* Description: load a string from resource                  */
/*************************************************************/
LPTSTR LoadStringFromRes(DWORD redId){

    TCHAR *string = new TCHAR[MAX_PATH];

    if(NULL == string){

       return(NULL);
    }   

    ::ZeroMemory(string, sizeof(TCHAR) * MAX_PATH);
    ::LoadString(_Module.GetModuleInstance(), redId, string, MAX_PATH);
    return string;
}/* end of if statement */

/*************************************************************/
/* Function: lstrlenWInternal                                */
/*************************************************************/
int WINAPI lstrlenWInternal(LPCWSTR lpString){

    int length = 0;
    while (*lpString++ != L'\0')
        length++;
    return length;
}/* end of function lstrlenWInternal */

/*************************************************************/
/* Name: GetRegistryDword
/* Description: 
/*************************************************************/
BOOL GetRegistryDword(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDword
/* Description: 
/*************************************************************/
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryString
/* Description: 
/*************************************************************/
BOOL GetRegistryString(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, *dwLen);
            *dwLen = 0;
        }
        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryString
/* Description: 
/*************************************************************/
BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByte
/* Description: 
/*************************************************************/
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytes
/* Description: 
/*************************************************************/
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// Start not so lame functions

/*************************************************************/
/* Name: GetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, sizeof(szRet) / sizeof(szRet[0]));
            *dwLen = 0;
        }
        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByteCU
/* Description: 
/*************************************************************/
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytesCU
/* Description: 
/*************************************************************/
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// end not so lame functions
/*************************************************************/
/* Function: CMSDVDAdm                                       */
/*************************************************************/
CMSDVDAdm::CMSDVDAdm(){

    DWORD temp;
    GetRegistryDword(g_szPlayerLevel, &temp, (DWORD)LEVEL_ADULT);		
    m_lParentctrlLevel = temp;

    GetRegistryDword(g_szPlayerCountry, &temp, (DWORD)0);		
    m_lParentctrlCountry = temp;

    GetRegistryDword(g_szDisableScrnSvr, &temp, (DWORD)VARIANT_TRUE);		
    m_fDisableScreenSaver = (VARIANT_BOOL)temp;
    SaveScreenSaver();
    if (m_fDisableScreenSaver != VARIANT_FALSE)
        DisableScreenSaver();

    GetRegistryDword(g_szBookmarkOnStop, &temp, (DWORD)VARIANT_FALSE);		
    m_fBookmarkOnStop = (VARIANT_BOOL)temp;
    GetRegistryDword(g_szBookmarkOnClose, &temp, (DWORD)VARIANT_TRUE);		
    m_fBookmarkOnClose = (VARIANT_BOOL)temp;
}/* end of function CMSDVDAdm */

/*************************************************************/
/* Function: ~CMSDVDAdm                                      */
/*************************************************************/
CMSDVDAdm::~CMSDVDAdm(){
    
    RestoreScreenSaver();
}/* end of function ~CMSDVDAdm */
    

/*************************************************************/
/* Name: EncryptPassword                                     */
/* Description: Hash the password                            */
/* Params:                                                   */
/*  lpPassword: password to hash                             */
/*  lpAssaultedHash: hashed password,                        */
/*      allocated by this fucntion, released by caller       */
/*  p_dwAssault: salt, save with hash; or salt passed in     */
/*  genAssault: TRUE = generate salt; FALSE = salt passed in */
/*************************************************************/
HRESULT CMSDVDAdm::EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *p_dwCryptLen, DWORD *p_dwAssault, BOOL genAssault){
    if(!lpPassword || !lpAssaultedHash || !p_dwAssault || !p_dwCryptLen){
        return E_POINTER;
    }
    if( lstrlen(lpPassword) > MAX_PASSWD){
        return E_INVALIDARG;
    }
    
    HCRYPTPROV hProv = NULL;   // Handle to Crypto Context
    HCRYPTHASH hHash = NULL;   // Handle to Hash Function    
    DWORD dwAssault = 0;       // As(Sa)u(lt) for hash
    DWORD dwAssaultedHash = 0; // Length of Assaulted hash
    
    // Init Crypto Context
    if(!CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)){
        return E_UNEXPECTED;
    }
    
    // Store the Salt in dwAssault, either generate it or copy the user passed value
    if(genAssault){        
        if(!CryptGenRandom(hProv, sizeof(DWORD), reinterpret_cast<BYTE *>(&dwAssault))){
            if(hProv) CryptReleaseContext(hProv, 0);                                                                       
            return E_UNEXPECTED;   
        }
        *p_dwAssault = dwAssault;
    }
    else{
        dwAssault = *p_dwAssault;
    }
    
    // Create the handle to the Hash function
    if(!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Hash the password
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(lpPassword), lstrlen(lpPassword)*sizeof(lpPassword[0]), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Add the salt
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(&dwAssault), sizeof(DWORD), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Get the size of the hashed data
    if(!CryptGetHashParam(hHash, HP_HASHVAL, 0, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Allocate a string large enough to hold the hash data and a null
    *lpAssaultedHash = new BYTE[dwAssaultedHash];
    if(!lpAssaultedHash){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Zero the string
    ZeroMemory(*lpAssaultedHash, dwAssaultedHash);
    
    // Copy length of Encrypted bytes to return value
    *p_dwCryptLen = dwAssaultedHash;
    
    // Get the hash data and store it in a string
    if(!CryptGetHashParam(hHash, HP_HASHVAL, *lpAssaultedHash, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        if(lpAssaultedHash){
            delete[] *lpAssaultedHash;
            *lpAssaultedHash = NULL;
        }
        return E_UNEXPECTED;
    }
    
    // Clean up
    if(hProv) CryptReleaseContext(hProv, 0);                                  
    if(hHash) CryptDestroyHash(hHash);                                      

    return S_OK;

}/* end of function EncryptPassword */

/*************************************************************/
/* Function: ConfirmPassword                                 */
/* Description:                                              */
/* There is no need for a user to confirm passwords unless   */
/* they are hacking the password.                            */ 
/* ConfirmPassword always fails (and waits five seconds)     */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::ConfirmPassword(BSTR strUserName, BSTR strPassword, VARIANT_BOOL *pVal){
    Sleep(1000);
    return E_FAIL;
}
/*************************************************************/
/* Function: _ConfirmPassword                                */
/* Description: comfired a password with the one saved       */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::_ConfirmPassword(BSTR /*strUserName*/,
                                        BSTR strPassword, VARIANT_BOOL *fRight){

    HRESULT hr = S_OK;

    try {

        USES_CONVERSION;

		if(!strPassword || !fRight){
			throw E_POINTER;
		}
        UINT bStrLen = lstrlen(strPassword);
        if(bStrLen >= MAX_PASSWD){
            throw E_INVALIDARG;
        }

        LPTSTR szPassword = OLE2T(strPassword);
	    BYTE szSavedPasswd[MAX_PASSWD];
        DWORD dwLen = MAX_PASSWD;
        BOOL bFound = GetRegistryBytes(g_szPassword, szSavedPasswd, &dwLen);

        // if no password has been set yet
        if (!bFound || dwLen == 0) {
            // so in this case accept only an empty string 
            if(lstrlen(szPassword) <= 0){
                *fRight = VARIANT_TRUE;
            }
            else {
                *fRight = VARIANT_FALSE;
            }
            throw (hr);
        }

        DWORD dwAssault = 0;
        bFound = GetRegistryDword(g_szSalt, &dwAssault, 0);
        if(!bFound ){
            // Old style password since there is no salt
            // ignore current password until it is reset
            *fRight = VARIANT_TRUE;
            throw(hr);
        }

        // if password is 0 len and password is set don't even try to encrypt just return false
        if(lstrlen(szPassword) <= 0){
            *fRight = VARIANT_FALSE;
            throw(hr);
        }

        // Encrypt the password with the salt from the registry
	    BYTE *pszEncrypted = NULL;
        DWORD dwCryptLen = 0;
        hr = EncryptPassword(szPassword, &pszEncrypted, &dwCryptLen, &dwAssault, FALSE);
        if(FAILED(hr)){
            throw (hr);
        }

        // Compare the Encrypted input password with the saved password
        if(memcmp(pszEncrypted, szSavedPasswd, (dwAssault <= dwLen?dwAssault:dwLen) ) == 0)
            *fRight = VARIANT_TRUE;
        else
            *fRight = VARIANT_FALSE;
        delete[] pszEncrypted;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    if(FAILED(hr)){
        Sleep(1000);
    }

    return (HandleError(hr));        
}/* end of function ConfirmPassword */

/*************************************************************/
/* Function: ChangePassword                                  */
/* Description: password change requested                    */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::ChangePassword(BSTR strUserName, 
                                       BSTR strOldPassword, BSTR strNewPassword){

    HRESULT hr = S_OK;

    try {

        USES_CONVERSION;
        if(!strUserName || !strOldPassword || !strNewPassword){
            return E_POINTER;
        }
        // check the size of the string so we do not overwrite 
        // or write a very big chunk into registry 
        if(lstrlen(strNewPassword) >= MAX_PASSWD){
            throw(E_FAIL);            
        }


        LPTSTR szNewPassword = OLE2T(strNewPassword);

        // Confirm old password first
        VARIANT_BOOL temp;
        _ConfirmPassword(strUserName, strOldPassword, &temp);
        if (temp == VARIANT_FALSE){
            throw E_ACCESSDENIED;
        }

        DWORD dwAssault = 0;
        DWORD dwCryptLen = 0;
        BYTE *pszEncrypted = NULL;
        
	    hr = EncryptPassword(szNewPassword, &pszEncrypted, &dwCryptLen, &dwAssault, TRUE);
        if(FAILED(hr)){
            throw E_FAIL;
        }

        BOOL bSuccess = SetRegistryBytes(g_szPassword, pszEncrypted, dwCryptLen);
        if (!bSuccess){
            hr = E_FAIL;
        }

        delete[] pszEncrypted;

        // If storing the password hash failed, don't store the salt
        if(SUCCEEDED(hr)){
            bSuccess = SetRegistryDword(g_szSalt, dwAssault);
            if (!bSuccess){
                hr = E_FAIL;
            }
        }
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function ChangePassword */

/*************************************************************/
/* Function: SaveParentalLevel                               */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::SaveParentalLevel(long lParentalLevel, 
                         BSTR strUserName, BSTR strPassword){
    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != LEVEL_DISABLED && 
           (lParentalLevel < LEVEL_G || lParentalLevel > LEVEL_ADULT)) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        if (m_lParentctrlLevel != lParentalLevel) {

            // Confirm password first
            VARIANT_BOOL temp;
            _ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw (E_ACCESSDENIED);

        }
        
        BOOL bSuccess = SetRegistryDword(g_szPlayerLevel, (DWORD) lParentalLevel);
        if (!bSuccess){
            throw E_FAIL;
        }

        m_lParentctrlLevel = lParentalLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function SaveParentalLevel */

/*************************************************************/
/* Name: SaveParentalCountry                                 */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::SaveParentalCountry(long lCountry,                                               
                        BSTR strUserName,BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        // convert the input country code to upper case by applying ToUpper to each letter
        WORD wCountry = ISO3166::PackCode( (char *)bCountryCode );
        BOOL bFound = FALSE;

        for( unsigned i=0; i<ISO3166::GetNumCountries(); i++ )
        {
            if( ISO3166::PackCode(ISO3166::GetCountry(i).Code) == wCountry )
            {
                bFound = TRUE;
            }
        }

        // Not a valid country code
        if (!bFound) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (m_lParentctrlCountry != lCountry) {

            // Confirm password first
            VARIANT_BOOL temp;
            _ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw(E_ACCESSDENIED);
        
        }
        BOOL bSuccess = SetRegistryDword(g_szPlayerCountry, (DWORD) lCountry);
        if (!bSuccess){
            throw E_FAIL;
        }    
        m_lParentctrlCountry = lCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return (HandleError(hr));        
}/* end of function SaveParentalCountry */

/*************************************************************/
/* Function: put_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DisableScreenSaver(VARIANT_BOOL fDisable){

    HRESULT hr = S_OK;

    try {

        if (fDisable == VARIANT_FALSE)
            RestoreScreenSaver();
        else 
            DisableScreenSaver();

        SetRegistryDword(g_szDisableScrnSvr, (DWORD) fDisable);
        m_fDisableScreenSaver = fDisable;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function put_DisableScreenSaver */

/*************************************************************/
/* Function: get_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DisableScreenSaver(VARIANT_BOOL *fDisable){

    HRESULT hr = S_OK;

    try {
        if(NULL == fDisable){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
   
        *fDisable = m_fDisableScreenSaver;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function get_DisableScreenSaver */

/*************************************************************/
/* Function: SaveScreenSaver                                 */
/*************************************************************/
HRESULT CMSDVDAdm::SaveScreenSaver(){

    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &m_bScrnSvrOld, 0);
    SystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &m_bPowerlowOld, 0);
    SystemParametersInfo(SPI_GETPOWEROFFACTIVE, 0, &m_bPowerOffOld, 0);

    return S_OK;
}
/*************************************************************/
/* Function: DisableScreenSaver                              */
/*************************************************************/
HRESULT CMSDVDAdm::DisableScreenSaver(){

    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETLOWPOWERACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETPOWEROFFACTIVE, FALSE, NULL, 0);

    return S_OK;
}/* end of function DisableScreenSaver */

/*************************************************************/
/* Function: RestoreScreenSaver                              */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::RestoreScreenSaver(){

    HRESULT hr = S_OK;

    try {

        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, m_bScrnSvrOld, NULL, 0);
        SystemParametersInfo(SPI_SETLOWPOWERACTIVE, m_bPowerlowOld, NULL, 0);
        SystemParametersInfo(SPI_SETPOWEROFFACTIVE, m_bPowerOffOld, NULL, 0);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function RestoreScreenSaver */

/*************************************************************/
/* Function: GetParentalLevel                                */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::GetParentalLevel(long *lLevel){

    HRESULT hr = S_OK;

    try {
        if(NULL == lLevel){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lLevel = m_lParentctrlLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalLevel */

/*************************************************************/
/* Function: GetParentalCountry                              */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::GetParentalCountry(long *lCountry){

    HRESULT hr = S_OK;

    try {
        if(NULL == lCountry){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lCountry = m_lParentctrlCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalCountry */

/*************************************************************/
/* Name: get_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DefaultAudioLCID(long *pVal){

    HRESULT hr = S_OK;

    try {

        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
    
        BOOL bSuccess = GetRegistryDwordCU(g_szDefaultAudio, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
} /* end of function get_DefaultAudioLCID */

/*************************************************************/
/* Name: put_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DefaultAudioLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultAudio, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
} /* end of put_DefaultAudioLCID */

/*************************************************************/
/* Name: get_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DefaultSubpictureLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultSP, (DWORD*) pVal, (DWORD)-1);

    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);	
} /* end of get_DefaultSubpictureLCID */

/*************************************************************/
/* Name: put_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DefaultSubpictureLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultSP, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of put_DefaultSubpictureLCID */

/*************************************************************/
/* Name: get_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DefaultMenuLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {

       if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultMenu, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of get_DefaultMenuLCID */

/*************************************************************/
/* Name: put_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DefaultMenuLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultMenu, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr); 
} /* end of put_DefaultMenuLCID */

/*************************************************************/
/* Name: put_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_BookmarkOnStop(VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;

    try {
        m_fBookmarkOnStop = fEnable;
        SetRegistryDword(g_szBookmarkOnStop, (DWORD) fEnable);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_BookmarkOnStop(VARIANT_BOOL *fEnable){
    
    HRESULT hr = S_OK;

    try {

       if(NULL == fEnable){

           hr = E_POINTER;
           throw(hr);
       }/* end of if statement */

       *fEnable = m_fBookmarkOnStop;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************/
/* Name: put_BookmarkOnClose
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_BookmarkOnClose(VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;
    try {

        m_fBookmarkOnClose = fEnable;
        SetRegistryDword(g_szBookmarkOnClose, (DWORD) fEnable);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);        
}

/*************************************************************/
/* Name: get_BookmarkOnClose
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_BookmarkOnClose(VARIANT_BOOL *fEnable){

    HRESULT hr = S_OK;

    try {
        if(NULL == fEnable){

           hr = E_POINTER;
           throw(hr);
       }/* end of if statement */

        *fEnable = m_fBookmarkOnClose;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);        
}

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CMSDVDAdm::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {
        &IID_IMSDVDAdm,		
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSDVDAdm::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
        
            // Ensure that the string is Null Terminated
            TCHAR strError[MAX_ERROR_TEXT_LEN+1];
            ZeroMemory(strError, MAX_ERROR_TEXT_LEN+1);

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                    ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                    ATLASSERT(FALSE);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************************/
/* End of file: MSDVDAdm.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\msgwindow.h ===
//
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
#ifndef __CMsgWindow__h
#define __CMsgWindow__h

//
//  Message Window class (for handling WM_TIMER messages) definition
//
class CMsgWindow
{
public:
    virtual         ~CMsgWindow() ;

    virtual bool    Open( LPCTSTR pWindowName = 0);
    virtual bool    Close();
    virtual LRESULT WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam );

    HWND            GetHandle() const { return m_hWnd; } ;
    void            SetHandle(HWND hwnd) {m_hWnd = hwnd; } ;

protected:
                    CMsgWindow();
private:
    HWND            m_hWnd ;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\mslcid.cpp ===
/*************************************************************/
/* Name: lcid.cpp
/* Description: 
/*************************************************************/
#include <stdafx.h>
#include "mslcid.h"
#include "mswebdvd.h"
#include "msdvdadm.h"
#include "resource.h"

MSLangID::MSLangID() {
    static LanguageList LL[] = {
        { IDS_INI_LANG1, LANG_AFRIKAANS },
        { IDS_INI_LANG2, LANG_ALBANIAN },
        { IDS_INI_LANG3, LANG_ARABIC },
        { IDS_INI_LANG4, LANG_BASQUE },
        { IDS_INI_LANG5, LANG_BELARUSIAN },
        { IDS_INI_LANG6, LANG_BULGARIAN },
        { IDS_INI_LANG7, LANG_CATALAN },
        { IDS_INI_LANG8, LANG_CHINESE },
        { IDS_INI_LANG9, LANG_CROATIAN },
        { IDS_INI_LANG10, LANG_CZECH },
        { IDS_INI_LANG11, LANG_DANISH },
        { IDS_INI_LANG12, LANG_DUTCH },
        { IDS_INI_LANG13, LANG_ENGLISH },
        { IDS_INI_LANG14, LANG_ESTONIAN },
        { IDS_INI_LANG15, LANG_FAEROESE },
        { IDS_INI_LANG16, LANG_FARSI },
        { IDS_INI_LANG17, LANG_FINNISH },
        { IDS_INI_LANG18, LANG_FRENCH },
        { IDS_INI_LANG19, LANG_GERMAN },
        { IDS_INI_LANG20, LANG_GREEK },
        { IDS_INI_LANG21, LANG_HEBREW },
        { IDS_INI_LANG22, LANG_HUNGARIAN },
        { IDS_INI_LANG23, LANG_ICELANDIC },
        { IDS_INI_LANG24, LANG_INDONESIAN },
        { IDS_INI_LANG25, LANG_ITALIAN },
        { IDS_INI_LANG26, LANG_JAPANESE },
        { IDS_INI_LANG27, LANG_KOREAN },
        { IDS_INI_LANG28, LANG_LATVIAN },
        { IDS_INI_LANG29, LANG_LITHUANIAN },
        { IDS_INI_LANG30, LANG_MALAY },
        { IDS_INI_LANG31, LANG_NORWEGIAN },
        { IDS_INI_LANG32, LANG_POLISH },
        { IDS_INI_LANG33, LANG_PORTUGUESE },
        { IDS_INI_LANG34, LANG_ROMANIAN },
        { IDS_INI_LANG35, LANG_RUSSIAN },
        { IDS_INI_LANG36, LANG_SERBIAN },
        { IDS_INI_LANG37, LANG_SLOVAK },
        { IDS_INI_LANG38, LANG_SLOVENIAN },
        { IDS_INI_LANG39, LANG_SPANISH },
        { IDS_INI_LANG40, LANG_SWAHILI },
        { IDS_INI_LANG41, LANG_SWEDISH },
        { IDS_INI_LANG42, LANG_THAI },
        { IDS_INI_LANG43, LANG_TURKISH },
        { IDS_INI_LANG44, LANG_UKRAINIAN },
    };
    m_LL = LL;
    m_LLlength = sizeof(LL)/sizeof(LL[0]);
};

LPTSTR MSLangID::GetLangFromLangID(WORD langID){

    if (langID == LANG_NEUTRAL) {
        langID = (WORD)PRIMARYLANGID(::GetUserDefaultLangID());
    }

    LCID lcid =  MAKELCID(MAKELANGID(langID, SUBLANG_DEFAULT), SORT_DEFAULT);
    // Try to get it from the system first
        
    for(int i = 0; i < m_LLlength; i++) {
        if(m_LL[i].LangID == langID)
            return LoadStringFromRes(m_LL[i].ResourceID);
    }
	return NULL;
}/* end of function GetLangFromLangID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\mswebdvd.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// MSWebDVD.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSWebDVDps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSWebDVD.h"

#include "MSWebDVD_i.c"
#include "MSDVD.h"
#include "DVDRect.h"
#include "MSDVDAdm.h"
#include "ddrawobj.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MSWebDVD, CMSWebDVD)
OBJECT_ENTRY(CLSID_DVDRect, CDVDRect)
OBJECT_ENTRY(CLSID_MSDVDAdm, CMSDVDAdm)
OBJECT_ENTRY(CLSID_OverlayCallback, COverlayCallback)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSWEBDVDLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\mswebdvdcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSWEBDVDCP_H_
#define _MSWEBDVDCP_H_




template <class T>
class CProxy_IMSWebDVD : public IConnectionPointImpl<T, &DIID__IMSWebDVD, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_DVDNotify(long lEventCode, VARIANT lParam1, VARIANT lParam2)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = lEventCode;
				pvars[1] = lParam1;
				pvars[0] = lParam2;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayForwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayBackwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ShowMenu(DVDMenuIDConstants __MIDL_0011, VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = __MIDL_0011;
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Resume(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_SelectOrActivatButton(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_StillOff(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PauseOn(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAudioStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentSubpictureStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xa, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAngle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xb, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTimeInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTime(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xd, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapterInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xe, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xf, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReplayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayNextChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Stop(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReturnFromSubmenu(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x14, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayPrevChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x15, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_UpdateOverlay()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x16, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_ReadyStateChange(LONG ReadyState)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = ReadyState;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(DISPID_READYSTATECHANGE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\savejpeg.cpp ===
#include <stdio.h>
#include <windows.h>
#include "capture.h"

HRESULT WriteBitmapDataToJPEGFile(char * filename, CaptureBitmapData *bm)
{
    // Function needs to be re-written to use gdi or gdi+ methods
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSWebDVD.rc
//
#define IDS_PROJNAME                    100
#define IDB_MSWEBDVD                    101
#define IDS_ABOUT                       101
#define IDR_MSWEBDVD                    102
#define IDS_WEBDVD_ABOUT                102
#define IDR_DVDRECT                     103
#define IDB_MSDVDADM                    104
#define IDR_MSDVDADM                    105
#define IDR_OVERLAYCALLBACK             106
#define IDD_CAPSAVE                     200
#define IDS_EDVD2INT                    202
#define IDS_INI_RATE                    203
#define IDS_INI_RATE_G                  204
#define IDS_INI_RATE_PG                 205
#define IDS_INI_RATE_PG13               206
#define IDS_INI_RATE_R                  207
#define IDS_INI_RATE_NC17               208
#define IDS_INI_RATE_ADULT              209
#define IDS_INI_ADMINISTRATOR           210
#define IDS_INI_PASSWORD                211
#define IDS_INI_DISABLE_PARENT          212
#define IDS_INI_COUNTRY                 213
#define IDS_INI_DEFAULT_CFG             214
#define IDS_INI_DISABLE_SCRNSVR         215
#define IDS_REGION_CHANGE_FAIL          216
#define IDS_FORMAT_NOT_SUPPORTED        217
#define IDS_INI_DEFAULT_AUDIO           218
#define IDS_INI_DEFAULT_SP              219
#define IDS_INI_DEFAULT_MENU            220
#define IDS_INI_BOOKMARK                221
#define IDS_INI_ENABLE_ONSTOP           222
#define IDS_INI_ENABLE_ONCLOSE          223
#define IDS_E_NO_DVD_VOLUME             224
#define IDS_SAVE_FILE                   225
#define IDS_AUDIOTRACK                  226
#define IDS_AUDIO_VISUALLY_IMPAIRED     227
#define IDS_AUDIO_DIRC1                 228
#define IDS_AUDIO_DIRC2                 229
#define IDS_DOLBY                       230
#define IDS_MPEG1                       231
#define IDS_MPEG2                       232
#define IDS_LPCM                        233
#define IDS_DTS                         234
#define IDS_SDDS                        235
#define IDS_SUBPICTURETRACK             236
#define IDS_CAPTION_BIG                 237
#define IDS_CAPTION_CHILDREN            238
#define IDS_CLOSED_CAPTION              239
#define IDS_CLOSED_CAPTION_BIG          240
#define IDS_CLOSED_CAPTION_CHILDREN     241
#define IDS_CLOSED_CAPTION_FORCED       242
#define IDS_DIRS_COMMNETS               243
#define IDS_DIRS_COMMNETS_BIG           244
#define IDS_DIRS_COMMNETS_CHILDREN      245
#define IDS_MOVE_TO_OTHER_MON           246
#define IDS_E_REGION_CHANGE_NOT_COMPLETED 247
#define IDS_E_NO_SOUND_STREAM           248
#define IDS_WARNING                     249
#define IDS_E_NO_VIDEO_STREAM           250
#define IDS_E_NO_OVERLAY                251
#define IDS_E_NO_USABLE_OVERLAY         252
#define IDS_E_NO_DECODER                253
#define IDS_E_NO_CAPTURE_SUPPORT        254
#define IDS_E_NO_SUBPICT_STREAM         255
#define IDI_ICON1                       301
#ifndef IDC_HAND
#define IDC_HAND                        302
#endif
#define IDC_ZOOMIN                      303

#define    IDS_INI_LANGFIRST 1000
#define    IDS_INI_LANG1   1+IDS_INI_LANGFIRST
#define    IDS_INI_LANG2   2+IDS_INI_LANGFIRST
#define    IDS_INI_LANG3   3+IDS_INI_LANGFIRST
#define    IDS_INI_LANG4   4+IDS_INI_LANGFIRST
#define    IDS_INI_LANG5   5+IDS_INI_LANGFIRST
#define    IDS_INI_LANG6   6+IDS_INI_LANGFIRST
#define    IDS_INI_LANG7   7+IDS_INI_LANGFIRST
#define    IDS_INI_LANG8   8+IDS_INI_LANGFIRST
#define    IDS_INI_LANG9    9+IDS_INI_LANGFIRST
#define    IDS_INI_LANG10   10+IDS_INI_LANGFIRST
#define    IDS_INI_LANG11   11+IDS_INI_LANGFIRST
#define    IDS_INI_LANG12   12+IDS_INI_LANGFIRST
#define    IDS_INI_LANG13   13+IDS_INI_LANGFIRST
#define    IDS_INI_LANG14   14+IDS_INI_LANGFIRST
#define    IDS_INI_LANG15   15+IDS_INI_LANGFIRST
#define    IDS_INI_LANG16   16+IDS_INI_LANGFIRST
#define    IDS_INI_LANG17   17+IDS_INI_LANGFIRST
#define    IDS_INI_LANG18   18+IDS_INI_LANGFIRST
#define    IDS_INI_LANG19   19+IDS_INI_LANGFIRST
#define    IDS_INI_LANG20   20+IDS_INI_LANGFIRST
#define    IDS_INI_LANG21   21+IDS_INI_LANGFIRST
#define    IDS_INI_LANG22   22+IDS_INI_LANGFIRST
#define    IDS_INI_LANG23   23+IDS_INI_LANGFIRST
#define    IDS_INI_LANG24   24+IDS_INI_LANGFIRST
#define    IDS_INI_LANG25   25+IDS_INI_LANGFIRST
#define    IDS_INI_LANG26   26+IDS_INI_LANGFIRST
#define    IDS_INI_LANG27   27+IDS_INI_LANGFIRST
#define    IDS_INI_LANG28   28+IDS_INI_LANGFIRST
#define    IDS_INI_LANG29   29+IDS_INI_LANGFIRST
#define    IDS_INI_LANG30   30+IDS_INI_LANGFIRST
#define    IDS_INI_LANG31   31+IDS_INI_LANGFIRST
#define    IDS_INI_LANG32   32+IDS_INI_LANGFIRST
#define    IDS_INI_LANG33   33+IDS_INI_LANGFIRST
#define    IDS_INI_LANG34   34+IDS_INI_LANGFIRST
#define    IDS_INI_LANG35   35+IDS_INI_LANGFIRST
#define    IDS_INI_LANG36   36+IDS_INI_LANGFIRST
#define    IDS_INI_LANG37   37+IDS_INI_LANGFIRST
#define    IDS_INI_LANG38   38+IDS_INI_LANGFIRST
#define    IDS_INI_LANG39   39+IDS_INI_LANGFIRST
#define    IDS_INI_LANG40   40+IDS_INI_LANGFIRST
#define    IDS_INI_LANG41   41+IDS_INI_LANGFIRST
#define    IDS_INI_LANG42   42+IDS_INI_LANGFIRST
#define    IDS_INI_LANG43   43+IDS_INI_LANGFIRST
#define    IDS_INI_LANG44   44+IDS_INI_LANGFIRST

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        304
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\ia64\atltmr21.s ===
.global	_TimerProcThunkProc
	.proc	_TimerProcThunkProc
	.align	32

_TimerProcThunkProc:
	// On entry, gp is actually a pointer to the pRealWndProcDesc member of 
	// the _WndProcThunk struct
	alloc	r36=ar.pfs,4,6,4,0
	mov		r37=rp  // Save return address
	mov		r38=gp  // Save gp
	mov		r40=gp  // r40 = &thunk.pRealWndProcDesc
	ld8		r30=[r40],8  // r30 = thunk.pRealWndProcDesc, r40 = &thunk.pThis
	ld8		r42=[r40]  // r42 = pThis
	ld8		r31=[r30],8  // r31 = thunk.pRealWndProcDesc->pfn, r30 = &thunk.pRealWndProcDesc->gp
	ld8		gp=[r30]  // gp = thunk.pRealWndProcDesc->gp
	mov		r43=r33  // r43 = nMsg
	mov		r44=r34  // r44 = wParam
	mov		r45=r35  // r45 = lParam
	mov		b6=r31  // b6 = thunk.pRealWndProcDesc->pfn
	br.call.sptk.many	rp=b6  // Call thunk.pRealWndProcDesc->pfn
	mov		gp=r38  // restore gp
	mov		rp=r37  // restore return address
	mov		ar.pfs=r36  // restore previous function state
	br.ret.sptk.many	rp  // return
	.endp	_TimerProcThunkProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\stdafx.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: stdafx.h                                                        */
/* Description: include file for standard system include files,          */
/*      or project specific include files that are used frequently,      */
/*      but are changed infrequently                                     */
/* Author: David Janecek                                                 */
/*************************************************************************/
#if !defined(AFX_STDAFX_H__38EE5CE4_4B62_11D3_854F_00A0C9C898E7__INCLUDED_)
#define AFX_STDAFX_H__38EE5CE4_4B62_11D3_854F_00A0C9C898E7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <strsafe.h>
#include "ObjectWithSiteImplSec.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__38EE5CE4_4B62_11D3_854F_00A0C9C898E7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\wmp.h ===
//************************************************************
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:        wmp.h
//
// Description: Modified template for wmp pluging
//************************************************************


#ifndef _WMPPLUGINIMPL_H_
#define _WMPPLUGINIMPL_H_


#pragma once

//#include "wmputil.h"
#include "c:\wmp\private\wmp\dev\idl\plugin.h"
//#include "c:\wmp\private\wmp\dev\include\wmpcore.h"
//#include "color.h"
#include "c:\wmp\private\wmp\dev\include\dynarray.h"
#include "atlbase.h"

// Example usage:
// class CMyNodeActiveX :
//     public IWMPUIPluginImpl<CMyNodeActiveX>
// {
//     DECLARE_WMP_NODE( IWMPSpectrumAnalyzer )
// }
//

#define DECLARE_WMP_NODE( NODE ) \
    CComPtr<NODE> m_spNode; \
    STDMETHODIMP GetPrimaryIID( IID * pMainIID ) \
    { \
        E_POINTER_RETURN( pMainIID ); \
        *pMainIID = IID_##NODE; \
        return S_OK; \
    } \
    STDMETHODIMP ConnectNode( IUnknown * pBaseNode ) \
    { \
        E_POINTER_RETURN( pBaseNode ); \
        HRESULT hr = pBaseNode->QueryInterface( IID_##NODE, reinterpret_cast<LPVOID *>(&m_spNode) ); \
        if (SUCCEEDED(hr)) \
        { \
            hr = OnConnectNode(); \
            if (FAILED(hr)) \
            { \
                DPF( 3, A, "OnConnectNode() Failed (%s)", #NODE ); \
                m_spNode.Release(); \
            } \
        } \
        else \
        { \
            DPF( 3, A, "The node given to this ActiveX control failed a QI for: %s", #NODE ); \
        } \
        return hr; \
    } \
    STDMETHODIMP DisconnectNode() \
    { \
        HRESULT hr = OnDisconnectNode(); \
        if (FAILED(hr)) \
        { \
            DPF( 3, A, "OnDisconnectNode() Failure: %s", #NODE ); \
        } \
        m_spNode.Release(); \
        return hr; \
    } \



//************************************************************

class ATL_NO_VTABLE IWMPUIPluginEventsImpl :
    public IWMPUIPluginEvents
{
public:

#ifdef DEBUG
    ~IWMPUIPluginEventsImpl(){};
#endif

    // IWMPUIPluginEvents

    STDMETHOD(FireStateChange)( DISPID dispid ){return E_NOTIMPL;};
    STDMETHOD(WMPAdvise)( IUnknown * pUnknown, DWORD * pdwCookie ){return E_NOTIMPL;};
    STDMETHOD(WMPUnadvise)( DWORD dwCookie ){return E_NOTIMPL;};

    // Helper functions for the derriving object

    void DoNotify( int nType, DISPID dspidProperty, const VARIANT varParam );
    void DoPropertyChange( DISPID dispid );
    void DoStateChange( DISPID dispid, bool fEnabled );
    void DoRegionChange();

protected:


    DynamicArray<IWMPUIPluginNotify *>  m_EventSites;
};

//************************************************************

template <class T>
class ATL_NO_VTABLE IWMPUIPluginImpl : 
    public IWMPUIPlugin2
{
public:

    IWMPUIPluginImpl();

    STDMETHOD(OnConnectNode)();
    STDMETHOD(OnDisconnectNode)();
    STDMETHOD(SetTransparencyColor)( WCHAR * pwszColor );
    STDMETHOD(GetTransparencyColor)( BSTR * pbstrColor );

    // IWMPUIPlugin

    STDMETHOD(SetCore)(IUnknown *pMediaPlayer);
    STDMETHOD(GetPrimaryIID)(IID *pMainIID);
    STDMETHOD(ConnectNode)(IUnknown *pBaseNode);
    STDMETHOD(DisconnectNode)();

    // IWMPUIPlugin2

    STDMETHOD(CreateInstance)( BSTR bstrObjectType, IDispatch ** ppDispatch );
    STDMETHOD(GetTransparencyColor)( OLE_COLOR * pColor );

protected:

    //CComPtr<IWMPCore>   m_spCore;
    COLORREF            m_crTransparent;
    bool                m_fTransparent;
};



//************************************************************
// IWMPUIPluginImpl
//************************************************************

template <class T>
IWMPUIPluginImpl<T>::IWMPUIPluginImpl() :
    m_crTransparent(0x00000000),
    m_fTransparent(false)
{
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::OnConnectNode()
{
    return S_OK;
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::OnDisconnectNode()
{
    return S_OK;
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::SetTransparencyColor( WCHAR * pwszColor )
{
#if 1
    return E_NOTIMPL;
#else
    E_POINTER_RETURN( pwszColor );

    bool fTransparent       = m_fTransparent;
    COLORREF crTransparent  = m_crTransparent;

    HRESULT hr = StringToColor( pwszColor, &m_crTransparent, &m_fTransparent );
    DPF_HR( hr, L, "StringToColor" );

    if (SUCCEEDED(hr))
    {
        m_fTransparent = !m_fTransparent;
    }

    if (SUCCEEDED(hr) && ((fTransparent != m_fTransparent) || (crTransparent != m_crTransparent)))
    {
        T* pT = static_cast<T*>(this);

        hr = pT->FireViewChange();
        DPF_HR( hr, L, "pT->FireViewChange" );
    }
    return hr;
#endif
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::GetTransparencyColor( BSTR * pbstrColor )
{
#if 1
    return E_NOTIMPL;
#else
    WString wsz;
    WCHAR * pwsz = wsz;
    HRESULT hr = ColorToString( &pwsz, m_crTransparent, m_fTransparent );
    DPF_HR( hr, L, "ColorToString" );

    if (SUCCEEDED(hr))
    {
        m_fTransparent = !m_fTransparent;

        *pbstrColor = wsz.CopyToBSTR();
        HRMEMCHECK( hr, *pbstrColor );
    }

    return hr;
#endif
}



//************************************************************
// IWMPUIPlugin
//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::SetCore( IUnknown * pMediaPlayer )
{
#if 1
    return E_NOTIMPL;
#else
    m_spCore.Release();
    if (pMediaPlayer)
    {
        return pMediaPlayer->QueryInterface( IID_IWMPCore, reinterpret_cast<LPVOID *>(&m_spCore) );
    }
    return S_OK;
#endif
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::GetPrimaryIID( IID * pMainIID )
{
    return E_NOTIMPL;
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::ConnectNode( IUnknown * pBaseNode )
{
    return E_NOTIMPL;
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::DisconnectNode()
{
    return E_NOTIMPL;
}

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::CreateInstance( BSTR bstrObjectType, IDispatch ** ppDispatch )
{
   // E_POINTER_RETURN( bstrObjectType );
   // E_POINTER_RETURN( ppDispatch );

    return E_NOTIMPL;
}       

//************************************************************

template <class T>
STDMETHODIMP IWMPUIPluginImpl<T>::GetTransparencyColor( OLE_COLOR * pColor )
{

    *pColor = static_cast<OLE_COLOR>(m_crTransparent);
    return S_OK;
}

//************************************************************



#endif // _WMPPLUGINIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\objectwithsiteimplsec.h ===
///////////////////////////////////////////////////////////
// ObjectWithSiteImplSec.h : Secure implementation of IObjectWithSite
// Copyright (c) Microsoft Corporation 2002.

#pragma once

#ifndef OBJECTWITHSITEIMPLSEC_H
#define OBJECTWITHSITEIMPLSEC_H
#include <guiddef.h>
#include <ocidl.h>
#include <urlmon.h>

#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
#include <atlconv.h>
#endif
using namespace ::ATL;
#include <strsafe.h>

inline HRESULT IsSafeZone(DWORD dwZone) {
    switch (dwZone) {
    case URLZONE_LOCAL_MACHINE:
    case URLZONE_INTRANET:
    case URLZONE_TRUSTED:
        // the fixed list of zones we trust
        return NOERROR;
    default:  
        // everything else is untrusted
        return E_FAIL;
    }
}
inline HRESULT IsSafeSite(IUnknown* pSite) {
    CComQIPtr<IServiceProvider> psp(pSite);
    if (!psp) {
        // no service provider interface on the site implies that we're not running in IE
        // so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    CComQIPtr<IInternetHostSecurityManager> pManager;
    HRESULT hr = psp->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (LPVOID *)&pManager);
    if (FAILED(hr)) {
        // no security manager interface on the site's service provider implies that we're not 
        // running in IE, so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    const int MAXZONE = MAX_SIZE_SECURITY_ID+6/*scheme*/+4/*zone(dword)*/+1/*wildcard*/+1/*trailing null*/;
    char pbSecurityId[MAXZONE];
    DWORD pcbSecurityId = sizeof(pbSecurityId);
    ZeroMemory(pbSecurityId, sizeof(pbSecurityId));
    hr = pManager->GetSecurityId(reinterpret_cast<BYTE*>(pbSecurityId), &pcbSecurityId, NULL);
    if(FAILED(hr)){
        // security manager not working(unexpected). but, the site tried to provide one. thus we
        // must assume untrusted content and fail
        return E_FAIL;   
    }
    char *pbEnd = pbSecurityId + pcbSecurityId - 1;
    if (*pbEnd == '*') {  //ignore the optional wildcard flag
        pbEnd--;
    }
    pbEnd -= 3;  // point to beginning of little endian zone dword
    DWORD dwZone = *(reinterpret_cast<long *>(pbEnd));
    return IsSafeZone(dwZone);
}


template<class T> 
class ATL_NO_VTABLE IObjectWithSiteImplSec : public IObjectWithSite {

public:

    CComPtr<IUnknown> m_pSite;

// IObjectWithSite
    STDMETHOD(GetSite)(REFIID iid, void** ppvSite) {
        if (!ppvSite) {
            return E_POINTER;
        }
		T* pT = static_cast<T*>(this);

        if (!pT->m_pSite) {
            return E_NOINTERFACE;
        }
        return pT->m_pSite->QueryInterface(iid, ppvSite);
    }
    STDMETHOD(SetSite)(IUnknown* pSite) {
        HRESULT hr = IsSafeSite(pSite);
        if (SUCCEEDED(hr)) {
		    T* pT = static_cast<T*>(this);
            pT->m_pSite = pSite;
        }
        return hr;
    }

};

#endif // OBJECTWITHSITEIMPLSEC_H
// end of file objectwithsiteimplsec.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\thunkproc.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ThunkProc.cpp                                                   */
/* Description: Implementation of timer procedure that checks if the     */
/* window has been resized.                                              */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "msdvd.h"

/*************************************************************************/
/* Function: TimerProc                                                   */
/* Description: gets called every each time to figure out if we the      */
/* parent window has been moved
/*************************************************************************/
HRESULT CMSWebDVD::TimerProc(){
    
    HRESULT hr = S_OK;

    hr = ProcessEvents();

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    HWND hwndParent = NULL;
    hr = GetMostOuterWindow(&hwndParent);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
    
    RECT rcTmp;
    ::GetWindowRect(hwndParent, &rcTmp);        
        
    if(rcTmp.left != m_rcOldPos.left || rcTmp.top != m_rcOldPos.top || rcTmp.right != m_rcOldPos.right ||
        rcTmp.bottom != m_rcOldPos.bottom){

        hr = OnResize();  // do the initial resize

        m_rcOldPos = rcTmp; // set the value so we can remeber it
        return(hr);
    }/* end of if statement */
    
    hr = S_FALSE;
    return(hr);
}/* end of function TimerProc  */

/*************************************************************************/
/* Function: GetMostOuterWindow                                          */
/* Description: Gets the window that really contains the MSWEBDVD and is */
/* the most outer parent window.                                         */
/*************************************************************************/
HRESULT CMSWebDVD::GetMostOuterWindow(HWND* phwndParent){
   
    HRESULT hr = S_OK;

    if(NULL != m_hWndOuter){

        *phwndParent =  m_hWndOuter;
        return(S_OK);
    }/* end of if statement */

    HWND hwnd;
    hr = GetParentHWND(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    HWND hwndParent = hwnd;

    // Get really the out most parent so we can see if the window got moved    
    for ( ;; ) {
 
        HWND hwndT = ::GetParent(hwndParent);
        if (hwndT == (HWND)NULL) break;
           hwndParent = hwndT;
    }/* end of for loop */

    *phwndParent = m_hWndOuter = hwndParent;

    return(S_OK);
}/* end of function GetMostOuterWindow */

/*************************************************************************/
/* End of file: ThunkProc.cpp                                            */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\savebmp.cpp ===
/*************************************************************************/
/* Copyright (C) 2000 Microsoft Corporation                              */
/* File: savebmp.cpp                                                     */
/* Description: Save a CaptureBitmapData to BMP file format.             */
/* Note: This is not a general BMP encode function.                      */
/*       Special assumptions made about bitmap format:                   */
/*       RGB (3 bytes per pixel without colormap)                        */
/*                                                                       */
/* Author: Phillip Lu                                                    */
/*************************************************************************/

#include "stdafx.h"
#include <stdio.h>
#include "capture.h"


HRESULT WriteBitmapDataToBMPFile(char *filename, CaptureBitmapData *bmpdata)
{
    BITMAPFILEHEADER bfh;
    BITMAPINFOHEADER bmih;
    UINT numColors = 0; // Number of colors in bmiColors
    FILE *outfile = NULL;
    HRESULT hr = S_OK;
    BYTE *bufline = NULL;
    int bitmapStride;
    int nBytesWritten;

    // Setup BITMAPINFOHEADER

    ZeroMemory(&bmih, sizeof(bmih));
    bmih.biSize   = sizeof(bmih);
    bmih.biWidth  = bmpdata->Width;
    bmih.biHeight = bmpdata->Height;
    bmih.biPlanes = 1;
    bmih.biCompression = BI_RGB;
    bmih.biBitCount = 24;
     
    // Compute the bitmap stride

    bitmapStride = (bmpdata->Width * bmih.biBitCount + 7) / 8;
    bitmapStride = (bitmapStride + 3) & (~3);
    

    // Now fill in the BITMAPFILEHEADER

    bfh.bfType = 0x4d42;
    bfh.bfReserved1 = 0;
    bfh.bfReserved2 = 0;
    bfh.bfOffBits = sizeof(bfh) + sizeof(bmih) + numColors * sizeof(RGBQUAD);
    bfh.bfSize = bfh.bfOffBits + bitmapStride * bmpdata->Height;

    // allocate a buffer to hold one line of bitmap data

    bufline = new BYTE[bitmapStride];
    if (NULL == bufline)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    ZeroMemory(bufline, bitmapStride);

    if ((outfile = fopen(filename, "wb")) == NULL) 
    {
        delete[] bufline;
        hr = E_FAIL;
        return hr;
    }

    // Write the BITMAPFILEHEADER

    fwrite((void *)&bfh, sizeof(bfh), 1, outfile);

    // Write the BITMAPINFOHEADER

    fwrite((void *)&bmih, sizeof(bmih), 1, outfile);

    // Write bitmap data

    for (int iLine = bmpdata->Height-1; iLine >= 0; iLine--)
    {
        BYTE *bmpSrc = bmpdata->Scan0 + iLine*bmpdata->Stride;
        BYTE *bmpDst = bufline;

        for (int iPixel=0; iPixel<bmpdata->Width; iPixel++)
        {
            // in BMP file a pixel is in BGR order, so we have reverse it
            bmpDst[2] = *bmpSrc++;
            bmpDst[1] = *bmpSrc++;
            bmpDst[0] = *bmpSrc++;
            bmpDst += 3;
        }

        fwrite(bufline, bitmapStride, 1, outfile);
    }

    if (bufline != NULL)
    {
        delete[] bufline;
    }

    if (outfile != NULL)
    {
        fclose(outfile);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\fullsc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\mswebdvd\thunkproc.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ThunkProc.h                                                     */
/* Description: In order to get rid of the thread. Which causes problems */
/* since we have to marshal we use this timer stuff from ATL.            */
/* The basic problem is that we would like to have a timer associated    */
/* with an object and this is a way to do so                             */
/* Author: David Janecek                                                 */
/*************************************************************************/

#ifndef __THUNKPROC_H
#define __THUNKPROC_H

/////////////////////////////////////////////////////////////////////////////
// TimerProc thunks

class CTimerProcThunk
{
public:
        _AtlCreateWndData cd;
        CStdCallThunk thunk;

        void Init(TIMERPROC proc, void* pThis)
        {
            thunk.Init((DWORD_PTR)proc, pThis);
        }
};

template <class T>
class ATL_NO_VTABLE CMSDVDTimer {
private:
    CTimerProcThunk   m_TimerThunk;
    HWND            m_hwnd;

/*************************************************************************/
/* Function: FakeTimerProc                                               */
/*************************************************************************/
static void CALLBACK FakeTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime){

    CMSDVDTimer* pThis = (CMSDVDTimer*)hwnd;
    pThis->RealTimerProc(pThis->m_hwnd, uMsg, idEvent, dwTime);
}/* end of function FakeTimerProc */

/*************************************************************************/
/* Function: RealTimerProc                                               */
/*************************************************************************/
void RealTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime){

    T* pT = static_cast<T*>(this);

    if(NULL == pT){

        return;
    }/* end of if statement */

    pT->TimerProc();
}/* end of function RealTimerProc */

public:
/*************************************************************************/
/* Function: MyTimerClass                                                */
/*************************************************************************/
CMSDVDTimer(HWND hwnd = (HWND)NULL){

    m_hwnd = hwnd;
    m_TimerThunk.Init(FakeTimerProc, this);
}/* end of function MyTimerClass */

/*************************************************************************/
/* Function: GetTimerProc                                                */
/*************************************************************************/
TIMERPROC GetTimerProc() {

    return (TIMERPROC)(m_TimerThunk.thunk.pThunk);
}/* end of function GetTimerProc */

};

#endif // __THUNKPROC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\fullsc\fullsc.cpp ===
// fullsc.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f fullscps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "fullsc.h"

#include "fullsc_i.c"
#include "FullScCtl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_FullScCtl, CFullScCtl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_FULLSCLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\fullsc\fullscctl.cpp ===
// FullScCtl.cpp : Implementation of CFullScCtl

#include "stdafx.h"
#include "Fullsc.h"
#include "FullScCtl.h"

/////////////////////////////////////////////////////////////////////////////
// CFullScCtl


STDMETHODIMP CFullScCtl::get_FullScreen(VARIANT_BOOL *pVal)
{
    HRESULT hr;
    LPOLECLIENTSITE pClientSite = NULL;
    IWebBrowser2 *pBrowser=NULL;

    hr = GetClientSite(&pClientSite);
    if (FAILED(hr))
        return hr;

    hr = pClientSite->QueryInterface(IID_IWebBrowser2, reinterpret_cast<void**>(&pBrowser));
    pClientSite->Release();
    if (FAILED(hr))
        return hr;

    hr = pBrowser->get_FullScreen(pVal);
    pBrowser->Release();
    if (FAILED(hr))
        return hr;

    return S_OK;
}


STDMETHODIMP CFullScCtl::put_FullScreen(VARIANT_BOOL newVal)
{
    HRESULT hr;
    LPOLECLIENTSITE pClientSite = NULL;
    IWebBrowser2 *pBrowser=NULL;

    hr = GetClientSite(&pClientSite);
    if (FAILED(hr))
        return hr;

#if 0 //This doesn't work. Use undocumented way as in the #else part.
    hr = pClientSite->QueryInterface(IID_IWebBrowser2, (LPVOID*)&pBrowser);
    pClientSite->Release();
	if(FAILED(hr))
		return(hr);	
#else
    IServiceProvider* psp=NULL;
    hr = pClientSite->QueryInterface(IID_IServiceProvider, (LPVOID*)&psp);
    pClientSite->Release();
	if(FAILED(hr))
		return(hr);	

    hr = psp->QueryService(IID_IWebBrowserApp, IID_IWebBrowser2, (LPVOID*)&pBrowser);
    psp->Release();
    if (FAILED(hr))
        return hr;
#endif

    hr = pBrowser->put_FullScreen(newVal);

    /*
    if (newVal == VARIANT_FALSE)
    {
        HideTitleBar(pBrowser);
    }
    */

    pBrowser->Release();
    if (FAILED(hr))
        return hr;

    return S_OK;
}


HRESULT
CFullScCtl::HideTitleBar(IWebBrowser2 *pBrowser)
{
    HWND    hWnd = NULL;
    HRESULT hr;

    hr = pBrowser->get_HWND(reinterpret_cast<PLONG>(&hWnd));     //? Does get_HWND addref the hwnd?
    if (FAILED(hr))
        return hr;

    LONG lWndStyle = ::GetWindowLong(hWnd, GWL_STYLE);
    if (0 == lWndStyle)
        return hr;

    lWndStyle &= (~WS_TILEDWINDOW);

    ::SetWindowLong(hWnd, GWL_STYLE, lWndStyle);

    ::InvalidateRect(hWnd, NULL, TRUE);
    ::UpdateWindow(hWnd);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\fullsc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A659BC89_0FDA_4340_8A95_C99544021E54__INCLUDED_)
#define AFX_STDAFX_H__A659BC89_0FDA_4340_8A95_C99544021E54__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A659BC89_0FDA_4340_8A95_C99544021E54__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\idl\makefile.inc ===
$(TV_INC_DIR)\sndctl.tlb : sndctl.tlb
    move $? $@

$(TV_INC_DIR)\fullsc.tlb : fullsc.tlb
    move $? $@

$(TV_INC_DIR)\tvprof.tlb : tvprof.tlb
    move $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\fullsc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fullsc.rc
//
#define IDS_PROJNAME                    100
#define IDB_FULLSCCTL                   101
#define IDR_FULLSCCTL                   102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\fullsc\fullscctl.h ===
// FullScCtl.h : Declaration of the CFullScCtl

#ifndef __FULLSCCTL_H_
#define __FULLSCCTL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <exdisp.h>


/////////////////////////////////////////////////////////////////////////////
// CFullScCtl
class ATL_NO_VTABLE CFullScCtl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IFullScCtl, &IID_IFullScCtl, &LIBID_FULLSCLib>,
    
	public CComControl<CFullScCtl>,
//	public IPersistStreamInitImpl<CFullScCtl>,
	public IOleControlImpl<CFullScCtl>,
	public IOleObjectImpl<CFullScCtl>,
	public IOleInPlaceActiveObjectImpl<CFullScCtl>,
	public IViewObjectExImpl<CFullScCtl>,
	public IOleInPlaceObjectWindowlessImpl<CFullScCtl>,
    
	public CComCoClass<CFullScCtl, &CLSID_FullScCtl>,
	public IObjectSafetyImpl<CFullScCtl, (INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA)>
{
public:
    CFullScCtl()
    {
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FULLSCCTL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFullScCtl)
	COM_INTERFACE_ENTRY(IFullScCtl)
	COM_INTERFACE_ENTRY(IDispatch)
    
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
    
    /*
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    */
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()


BEGIN_PROP_MAP(CFullScCtl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()


BEGIN_MSG_MAP(CFullScCtl)
	CHAIN_MSG_MAP(CComControl<CFullScCtl>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IFullScCtl
public:
	STDMETHOD(get_FullScreen)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_FullScreen)(/*[in]*/ VARIANT_BOOL newVal);

    HRESULT HideTitleBar(IWebBrowser2 *pBrowser);

	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 3.0 : FullScCtl");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		return S_OK;
	}

};

#endif //__FULLSCCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\ccobj.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CCObj.cpp                                                       */
/* Description: Contains holder for container objects.                   */
/*************************************************************************/
#include "stdafx.h"
#include "ccobj.h"

#define GET_SITE CComPtr<IOleInPlaceSiteWindowless> pSite;  \
                    HRESULT hr = GetWindowlessSite(pSite);   \
                    if(FAILED(hr)) return(hr);

#define GET_CONTAINER CComPtr<IOleContainer> pContainer;  \
                    HRESULT hr = GetContainer(pContainer);   \
                    if(FAILED(hr)) return(hr);

/*************************************************************************/
/* Function: CContainerObject                                            */
/* Description: Constructor that should set needed objects.              */
/*************************************************************************/
CContainerObject::CContainerObject(IUnknown* pUnknown, CHostedObject* pObj){

    Init();
    SetObjects(pUnknown, pObj);
}/* end of function CContainerObject */
    
/*************************************************************************/
/* Function: SetObjects                                                  */
/* Description: Sets the internal objects.                               */
/*************************************************************************/
HRESULT CContainerObject::SetObjects(IUnknown* pUnknown, CHostedObject* pObj){
    
    m_pUnkContainer = pUnknown;
    m_pObj = pObj;
    return(S_OK);
}/* end of function SetObjects */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes the member variables                         */
/*************************************************************************/
void CContainerObject::Init(){

    //m_pUnkContainer = NULL; // using smart pointer
    m_pObj = NULL;
    m_lRefCount = 1;
    m_bLocked = 0;
}/* end of function Init */

/*************************************************************************/
/* Function: QueryInterface                                              */
/* Description: Gets the supported interface rest sends to the aggregated*/
/* object                                                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::QueryInterface(const IID& iid, void**ppv){

    if(iid == IID_IUnknown){

        *ppv = static_cast<CContainerObject*>(this);
    }
    else if(iid == IID_IOleInPlaceSiteWindowless){

        *ppv = static_cast<IOleInPlaceSiteWindowless*>(this);
    }
    else if(iid == IID_IOleInPlaceSiteEx){

        *ppv = static_cast<IOleInPlaceSiteEx*>(this);
    }
    else if(iid == IID_IOleClientSite){

        *ppv = static_cast<IOleClientSite*>(this);
    }        
    else if(iid == IID_IOleContainer){

        *ppv = static_cast<IOleContainer*>(this);
    }        
    else if(iid == IID_IOleInPlaceSite){

        *ppv = static_cast<IOleInPlaceSite*>(this);
    }        
    else if(iid == IID_IObjectWithSite){

        *ppv = static_cast<IObjectWithSite*>(this);
    }        
    else if(iid == IID_IPropertyBag){

        *ppv = static_cast<IPropertyBag*>(this);
    }
    // TODO: Not Right way to agregate
    // this breaks the rules since we really do not
    // have non delegating object there
    else { // blindly aggregate
        if(!m_pUnkContainer){

            *ppv = NULL;
            return (E_NOINTERFACE);
        }/* end of if statement */

        return(m_pUnkContainer->QueryInterface(iid, ppv));
    }/* end of if statement */

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return(S_OK);
}/* end of function QueryInterface */

/*************************************************************************/
/* Function: AddRef                                                      */
/* Description: Adds the reference count.                                */
/*************************************************************************/
STDMETHODIMP_(ULONG) CContainerObject::AddRef ( void){

    return(InterlockedIncrement(&m_lRefCount));
}/* end of function AddRef */

/*************************************************************************/
/* Function: Release                                                     */
/* Description: Decrements the reference count and the possibly releases */
/*************************************************************************/
STDMETHODIMP_(ULONG) CContainerObject::Release( void){

    if(InterlockedIncrement(&m_lRefCount) <=0){

        delete this;
        return 0;
    }/* end of if statement */

    return (m_lRefCount);
}/* end of function Release */

/*************************************************************************/
/* Helper functions                                                      */
/*************************************************************************/

/*************************************************************************/
/* Function: GetWindowlessSite                                           */
/* Description: Returns an interface for windowless site.                */
/*************************************************************************/
inline HRESULT CContainerObject::GetWindowlessSite(CComPtr<IOleInPlaceSiteWindowless>& pSite){ 

    if(!m_pUnkContainer){ 

        return(E_UNEXPECTED);
    }/* end of if statement */

    return(m_pUnkContainer->QueryInterface(&pSite));
}/* end of function GetWindowlessSite */

/*************************************************************************/
/* Function: GetContainer                                                */
/* Description: Returns an interface for windowless site.                */
/*************************************************************************/
inline HRESULT CContainerObject::GetContainer(CComPtr<IOleContainer>& pContainer){ 

    if(!m_pUnkContainer){ 

        return(E_UNEXPECTED);
    }/* end of if statement */

    return(m_pUnkContainer->QueryInterface(&pContainer));
}/* end of function GetContainer */

/*************************************************************************/
/* IOleContainer Implementation                                          */
/*************************************************************************/

/*************************************************************************/
/* Function: ParseDisplayName                                            */
/*************************************************************************/
STDMETHODIMP CContainerObject::ParseDisplayName(IBindCtx* /*pbc*/, 
                                                LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/){

    ATLTRACENOTIMPL(_T("IOleClientSite::ParseDisplayName"));		
}/* end of function ParseDisplayName */

/*************************************************************************/
/* Function: EnumObjects                                                 */
/*************************************************************************/
STDMETHODIMP CContainerObject::EnumObjects(DWORD grfFlags, IEnumUnknown** ppenum){

    GET_CONTAINER
    return(pContainer->EnumObjects(grfFlags, ppenum));	
}/* end of function EnumObjects */

/*************************************************************************/
/* Function: LockContainer                                               */
/* Description: Sets the container locked so it does not go away.        */
/*************************************************************************/
STDMETHODIMP CContainerObject::LockContainer(BOOL fLock){

    // TODO: Actually do use the m_bLocked flag
	m_bLocked = fLock;
	return S_OK;
}/* end of function LockContainer */

/*************************************************************************/
/* IOleClientSite Implementation                                         */
/*************************************************************************/

/*************************************************************************/
/* Function: GetContainer                                                */
/* Description: Basically returns our self                               */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetContainer(IOleContainer** ppContainer){

    ATLTRACE2(atlTraceHosting, 0, _T("IOleClientSite::GetContainer\n"));
    HRESULT hr = E_POINTER;

    if (NULL == ppContainer){

        return(hr);
    }/* end of if statement */

    if (m_pUnkContainer){
	
	    (*ppContainer) = NULL;		         
	    hr = QueryInterface(IID_IOleContainer, (void**)ppContainer); // return our selfs
    }/* end of if statement */

    return hr;
}/* end of function GetContainer */

/*************************************************************************/
/* Function: ShowObject                                                  */
/* Description: Redraws the object.                                      */
/*************************************************************************/
STDMETHODIMP CContainerObject::ShowObject(){

    HRESULT hr = S_OK;

    ATLTRACE2(atlTraceHosting, 0, _T("IOleClientSite::ShowObject\r\n"));

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = InvalidateObjectRect();
    
    return (hr);
}/* end of function ShowObject */

/*************************************************************************/
/* Function: OnShowWindow                                                */
/* Description: Shows or hides the window. If no window to show or hide  */
/* we deactivate it.                                                     */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnShowWindow(BOOL fShow){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = m_pObj->SetActive(fShow ? true: false);

    return(hr);
}/* end of function OnShowWindow */

/*************************************************************************/
/* IOleInPlaceSiteEx Implementation                                      */
/* Just pass throw in most cases, in some do some extra house keeping    */
/* since we know which object we are containing.                         */
/*************************************************************************/

// IOleWindow
/*************************************************************************/
/* Function: GetWindow                                                   */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetWindow(HWND *phwnd){

    GET_SITE
    return(pSite->GetWindow(phwnd));
}/* end of function GetWindow */

/*************************************************************************/
/* Function: ContextSensitiveHelp                                        */
/*************************************************************************/
STDMETHODIMP CContainerObject::ContextSensitiveHelp(BOOL fEnterMode){

    GET_SITE
    return(pSite->ContextSensitiveHelp(fEnterMode));
}/* end of function ContextSensitiveHelp */

//IOleInPlaceSite
/*************************************************************************/
/* Function: CanInPlaceActivate                                          */
/*************************************************************************/
STDMETHODIMP CContainerObject::CanInPlaceActivate(){

    GET_SITE
    return(pSite->CanInPlaceActivate());
}/* end of function CanInPlaceActivate */

/*************************************************************************/
/* Function: OnUIActivate                                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnUIActivate(){

    GET_SITE
    return(pSite->OnUIActivate());
}/* end of function OnUIActivate */

/*************************************************************************/
/* Function: OnInPlaceActivate                                           */
/* Description: Activates non windowless object.                         */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceActivate(){

    ATLTRACE(TEXT("CContainerObject::OnInPlaceActivate \n"));

    HRESULT hr = E_FAIL;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IUnknown> pUnk = m_pObj->GetUnknown(); // get the control object that is being inserted

    if(!pUnk){

        return(E_UNEXPECTED);
    }/* end of if statement */

	//OleLockRunning(pUnk, TRUE, FALSE); // not sure if needed here

    m_pObj->SetWindowless(false);
	//m_pObj->SetActive(true);

    return(hr);
}/* end of function OnInPlaceActivate */

/*************************************************************************/
/* Function: OnUIDeactivate                                              */
/* Description: Deactivates the object.                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnUIDeactivate(BOOL fUndoable){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    m_pObj->SetActive(false);

    ATLTRACE(TEXT("TODO: In the deactivation code, time to cleanup the contained object!!! \n"));

    return(hr);
}/* end of function OnUIDeactivate */

/*************************************************************************/
/* Function: OnInPlaceDeactivate                                         */
/* Description: Deactivates the object.                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceDeactivate(){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    m_pObj->SetActive(false);

    ATLTRACE(TEXT("TODO: In the deactivation code, time to cleanup the contained object!!! \n"));

    return(hr);
}/* end of function OnInPlaceDeactivate */

/*************************************************************************/
/* Function: DiscardUndoState                                            */
/*************************************************************************/
STDMETHODIMP CContainerObject::DiscardUndoState(){

    GET_SITE
    return(pSite->DiscardUndoState());    
}/* end of function DiscardUndoState */

/*************************************************************************/
/* Function: DeactivateAndUndo                                           */
/*************************************************************************/
STDMETHODIMP CContainerObject::DeactivateAndUndo(){

    GET_SITE
    return(pSite->DeactivateAndUndo());
    // TODO: Handle specific container
}/* end of function DeactivateAndUndo */

/*************************************************************************/
/* Function: OnPosRectChange                                             */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnPosRectChange(LPCRECT lprcPosRect){

    GET_SITE
    return(pSite->OnPosRectChange(lprcPosRect));
    // TODO: Handle specific container
}/* end of function OnPosRectChange */

/*************************************************************************/
/* Function: Scroll                                                      */
/*************************************************************************/
STDMETHODIMP CContainerObject::Scroll(SIZE scrollExtent){

    GET_SITE
    return(pSite->Scroll(scrollExtent));
    // TODO: Handle specific container
}/* end of function OnPosRectChange */

/*************************************************************************/
/* Function: GetWindowContext                                            */
/* Description: Finish this function to be container specific.           */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetWindowContext(IOleInPlaceFrame** ppFrame, 
                           IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, 
                           LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo){

	HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL){

		hr = E_POINTER;
        return(hr);
    }/* end of if statement */
		
	if (!m_spInPlaceFrame){

		//CComObject<CAxFrameWindow>* pFrameWindow;
		//CComObject<CAxFrameWindow>::CreateInstance(&pFrameWindow);
        // ?? MODS DJ
		QueryInterface(IID_IOleInPlaceFrame, (void**) &m_spInPlaceFrame);
		ATLASSERT(m_spInPlaceFrame);
	}/* end of if statement */

	if (!m_spInPlaceUIWindow){
        // ?? MODS DJ
		//CComObject<CAxUIWindow>* pUIWindow;
		//CComObject<CAxUIWindow>::CreateInstance(&pUIWindow);
		QueryInterface(IID_IOleInPlaceUIWindow, (void**) &m_spInPlaceUIWindow);
		ATLASSERT(m_spInPlaceUIWindow);
	}/* end of if statement */

	m_spInPlaceFrame.CopyTo(ppFrame);
	m_spInPlaceUIWindow.CopyTo(ppDoc);

    RECT rc;
    hr = m_pObj->GetPos(&rc);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    *lprcPosRect = rc;
    *lprcClipRect = rc;

    HWND hwnd;
    hr = GetWindow(&hwnd);

    if(FAILED(hr)){

        hr = S_FALSE;
        //return(hr);
    }/* end of if statement */

    HWND hParent = NULL;

    if(NULL != hwnd){
        
        hParent = ::GetParent(hwnd);
    }/* end of function GetParent */

	ACCEL ac = { 0,0,0 };
    HACCEL hac = ::CreateAcceleratorTable(&ac, 1);
	pFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
	pFrameInfo->fMDIApp = 0;
	pFrameInfo->hwndFrame =  hParent;
	pFrameInfo->haccel = hac;
	pFrameInfo->cAccelEntries = 1;

	return hr;
}/* end of function GetWindowContext */

/*************************************************************************/
/* Function: GetSite                                                     */
/* Description: Returns pretty much QI, client sets the site and then    */
/* container is using it.                                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetSite(REFIID riid, void  **ppvSite){

    return(QueryInterface(riid, ppvSite));
}/* end of function GetSite */

//IOleInPlaceSiteEx

/*************************************************************************/
/* Function: OnInPlaceActivateEx                                         */
/* Description: Checks what way we shall instantiate the control.        */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceActivateEx(BOOL* /*pfNoRedraw*/, DWORD dwFlags){

    HRESULT hr = E_FAIL;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IUnknown> pUnk = m_pObj->GetUnknown(); // get the control object that is being inserted

    if(!pUnk){

        return(E_UNEXPECTED);
    }/* end of if statement */

	OleLockRunning(pUnk, TRUE, FALSE);

    CComPtr<IOleInPlaceObjectWindowless> spInPlaceObjectWindowless;

    bool bWindowless = false;

	if (dwFlags & ACTIVATE_WINDOWLESS){
		
        m_pObj->SetWindowless(true);
		hr = pUnk->QueryInterface(IID_IOleInPlaceObjectWindowless,(void**) &spInPlaceObjectWindowless);
	}/* end of if statement */

	if (FAILED(hr)){

		m_pObj->SetWindowless(false);
		hr = pUnk->QueryInterface(IID_IOleInPlaceObject, (void**) &spInPlaceObjectWindowless);
	}/* end of if statement */

    if (SUCCEEDED(hr)){

        RECT rcPos;
        hr = m_pObj->GetPos(&rcPos);
        
        if (FAILED(hr)){

            return(hr);
        }/* end of if statement */

        if(m_pObj->IsWindowless()){

		    spInPlaceObjectWindowless->SetObjectRects(&rcPos, &rcPos);            
            ATLTRACE(TEXT("Windowless object is contained object with ID %ls Rect left = %d top %d right %d bottom %d\n"), 
                m_pObj->GetID(), rcPos.left, rcPos.top, rcPos.right, rcPos.bottom);
        }/* end of if statement */        
    }/* end of if statement */
    
    //m_pObj->SetActive(true);
   
	return S_OK;
}/* end of function OnInPlaceActivateEx */

/*************************************************************************/
/* Function: OnInPlaceDeactivateEx                                       */
/* Description: Deactivates the object.                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnInPlaceDeactivateEx(BOOL fNoRedraw){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    m_pObj->SetActive(false);

    ATLTRACE(TEXT("TODO: In the deactivation code, time to cleanup the contained object!!! \n"));

    return(hr);
}/* end of function OnInPlaceDeactivateEx */

/*************************************************************************/
/* Function: RequestUIActivate                                           */
/*************************************************************************/
STDMETHODIMP CContainerObject::RequestUIActivate(){

    GET_SITE
    return(pSite->RequestUIActivate());
}/* end of function RequestUIActivate */

/*************************************************************************/
/* Function: CanWindowlessActivate                                       */
/*************************************************************************/
STDMETHODIMP CContainerObject::CanWindowlessActivate(){

    GET_SITE
    return(pSite->CanWindowlessActivate());
}/* end of function CanWindowlessActivate */

/*************************************************************************/
/* Function: GetDC                                                       */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetDC(LPCRECT pRect, DWORD grfFlags, HDC* phDC){

    GET_SITE
    return(pSite->GetDC(pRect, grfFlags, phDC));
}/* end of function GetDC */

/*************************************************************************/
/* Function: ReleaseDC                                                   */
/*************************************************************************/
STDMETHODIMP CContainerObject::ReleaseDC(HDC hDC){

    GET_SITE
    return(pSite->ReleaseDC(hDC));
}/* end of function ReleaseDC */

/*************************************************************************/
/* Function: InvalidateRect                                              */
/*************************************************************************/
STDMETHODIMP CContainerObject::InvalidateRect(LPCRECT pRect, BOOL fErase){

    GET_SITE
    return(pSite->InvalidateRect(pRect, fErase));
}/* end of function InvalidateRect */

/*************************************************************************/
/* Function: InvalidateObjectRect                                        */
/* Description: Invalidates the whole control.                           */
/*************************************************************************/
HRESULT CContainerObject::InvalidateObjectRect(){

    HRESULT hr = S_OK;

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */
    
    RECT rc;
    hr = m_pObj->GetPos(&rc);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    hr = InvalidateRect(&rc, FALSE); // invalidate the region instead 
                                    // of drawing the object directly
    return(hr);
}/* end of function InvalidateRect */    

/*************************************************************************/
/* Function: InvalidateRgn                                               */
/*************************************************************************/
STDMETHODIMP CContainerObject::InvalidateRgn(HRGN hRGN, BOOL fErase){

    GET_SITE
    return(pSite->InvalidateRgn(hRGN, fErase));
}/* end of function InvalidateRgn */

/*************************************************************************/
/* Function: ScrollRect                                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::ScrollRect(INT dx, INT dy, LPCRECT pRectScroll, LPCRECT pRectClip){

    GET_SITE
    return(pSite->ScrollRect(dx, dy, pRectScroll, pRectClip));
}/* end of function ScrollRect */

/*************************************************************************/
/* Function: AdjustRect                                                  */
/*************************************************************************/
STDMETHODIMP CContainerObject::AdjustRect(LPRECT prc){

    GET_SITE
    return(pSite->AdjustRect(prc));
}/* end of function AdjustRect */

/*************************************************************************/
/* Function: OnDefWindowMessage                                          */
/*************************************************************************/
STDMETHODIMP CContainerObject::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult){

    GET_SITE
    return(pSite->OnDefWindowMessage(msg, wParam, lParam, plResult));
}/* end of function OnDefWindowMessage */

/*************************************************************************/
/* Function: GetCapture                                                  */
/* Description: Used to determine if we have a cupature or not           */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetCapture(){

    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = pSite->GetCapture();

    if(SUCCEEDED(hr)){

        // we checked with the container if we
        // have a capture

        if(m_pObj->HasCapture() == false){

            hr = S_FALSE;
        } 
        else {

            if(hr == S_FALSE){ 
                // case when the container say we do not have
                // the capture any more
                // but the object thinks it has a capture
                // we better reset the flag
                m_pObj->SetCapture(false);
                // and say that we do not have capture
                hr = S_FALSE;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    return(hr);    
}/* end of function GetCapture */

/*************************************************************************/
/* Function: SetCapture                                                  */
/* Description: Used to set the capture for mouse events                 */
/*************************************************************************/
STDMETHODIMP CContainerObject::SetCapture(BOOL fCapture){

    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */
    
    if(fCapture && !m_pObj->IsActive()){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    if(m_pObj->HasCapture() == (fCapture ? true: false)){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    // Call our "real" container object for count keeping
    // and signaling to its window or another container   
    hr = pSite->SetCapture(fCapture);

    if(SUCCEEDED(hr)){

        m_pObj->SetCapture(fCapture? true: false); // set the capture on the object
    }/* end of if statement */

    return (hr);
}/* end of function SetCapture */

/*************************************************************************/
/* Function: GetFocus                                                    */
/* Description: Determine if we have a focus or not.                     */
/*************************************************************************/
STDMETHODIMP CContainerObject::GetFocus(){

    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    hr = pSite->GetFocus();

    if(SUCCEEDED(hr)){

        if(m_pObj->HasFocus() == false){

            hr = S_FALSE;
        } 
        else {

            if(S_FALSE == hr){ 
                m_pObj->SetFocus(false);
                hr = S_FALSE;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    return(hr);    
}/* end of function GetFocus */

/*************************************************************************/
/* Function: SetFocus                                                    */
/* Description: Sets focus to the control                                */
/*************************************************************************/
STDMETHODIMP CContainerObject::SetFocus(BOOL fFocus){
    
    GET_SITE

    if(NULL == m_pObj){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    if(fFocus && !m_pObj->IsActive()){

        // can't set focus to not active objects
        // but can take away focus from non active ones
        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    if(m_pObj->HasFocus() == (fFocus ? true: false)){

        // we are not chaning focus state so do not bother calling container
        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    // Call our "real" container object for count keeping
    // and signaling to its window or another container   
    hr = pSite->SetFocus(fFocus);

    if(SUCCEEDED(hr)){                  

        m_pObj->SetFocus(fFocus ? true: false); // set the capture on the object
    }/* end of if statement */

    InvalidateObjectRect();

    return (hr);
}/* end of function SetFocus */

/*************************************************************************/
/* Function: SetHostedObject                                             */
/* Description: Sets the control that we are hosting.                    */
/*************************************************************************/
STDMETHODIMP CContainerObject::SetHostedObject(LONG lVoid){

    
	// TODO!!!
    // THIS WILL BREAK ON WIN64 
    // NEED TO PASS REAL INTERFACE AROUND

    HRESULT hr = S_OK;

    try {
        m_pObj = reinterpret_cast<CHostedObject*>(lVoid);

    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SetHostedObject */

/*************************************************************************/
/* IPropertyBag                                                          */
/*************************************************************************/

/*************************************************************************/
/* Function: Read                                                        */
/* Description: Reads a specific control property from a bag.            */
/* The bag looks like IE compatible <PARAM NAME="PropName" VALUE="value">*/
/*************************************************************************/
STDMETHODIMP CContainerObject::Read(LPCOLESTR pszPropName, VARIANT* pVar, 
                                    IErrorLog* pErrorLog){

    HRESULT hr = S_OK;

    try {

        ATLTRACE2(atlTraceHosting, 0, _T("IPropertyBag::Read\r\n"));

        if(NULL == m_pObj){

            throw(E_UNEXPECTED);            
        }/* end of if statement */

        if (NULL == pVar){

            throw(E_POINTER);            
        }/* end of if statement */

        hr = ParsePropertyBag(pszPropName, pVar, pErrorLog);

    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function Read */

/*************************************************************************/
/* Function: MyIsWhiteSpace                                              */
/* Local function implementation, since we do not have standart C lib    */
/* support                                                               */
/*************************************************************************/
static bool MyIsWhiteSpace( WCHAR c ){

    return  c == L' ' ||
            c == L'\t' ||
            c == L'\r' ||
            c == L'\n';
}/* end of function MyIsWhiteSpace */

/*************************************************************************/
/* Function: MyStrToDouble                                               */
/* Description: Reads in string and converts it to double                */
/* Returns  E_INVALIDARG if there is alpah or some other undesired string*/
/* S_OK if we got some string, S_FALSE if no number string (empty or spac*/
/*************************************************************************/
static HRESULT MyStrToDouble(WCHAR* pstr, double &n)
{
    HRESULT hr = S_FALSE;

    int Sign = 1;
    n = 0;                // result wil be n*Sign
    bool bBeforeDecimalPoint = true;
    double k = 10;

    // eat whitespace at start
    while( *pstr != L'\n' && MyIsWhiteSpace( *pstr ) ) {
        pstr++;
    }

    while( pstr[lstrlenW(pstr)-1]!= L'\n' && MyIsWhiteSpace( *pstr ) ) {
        pstr[lstrlenW(pstr)-1] = L'\0';
    }

    //lstrcmpiW is not implemented on 98 need to use STDLIB
    // TODO: eventaully replace the below  _wcsicmp with our own so we can remove support
    // on standard C library
    if (_wcsicmp(pstr, L"true") == 0) {
        n = -1;
        return S_OK;
    }

    if (_wcsicmp(pstr, L"false") == 0) {
        n = 0;
        return S_OK;
    }

    if (pstr[0]==L'-'){
        Sign = -1;
        ++pstr;
    }/* end of if statement */

    for( ; ; ) {
        if (pstr[0]>=L'0' && pstr[0]<=L'9') {
            if(bBeforeDecimalPoint == true){
                n = 10*n+(int)(pstr[0]-L'0');
            } else {
                n = n+ ((int)(pstr[0]-L'0'))/k;
                k = k * 10; // decrease the decimal point

            }/* end of if statement */
            hr = S_OK;
        } else if (  MyIsWhiteSpace( pstr[0] ) || pstr[0] == L'\0' ) {
            break;
        } else if( bBeforeDecimalPoint && pstr[0] == L'.') {
            bBeforeDecimalPoint = false;
        } else {
            hr = E_INVALIDARG;
            break;
        }/* end of if statement */
        ++pstr;
    }/* end of for loop */

    n *= Sign; // adjust the sign
    return(hr);
}/* end of function MyStrToDouble */

/*************************************************************************/
/* Function: CompSubstr                                                  */
/* Description: ComaparesSubstr, eats up whithe spaces.                  */
/*************************************************************************/
HRESULT CompSubstr(WCHAR*& strSource, const WCHAR* strKey){

    bool bEatSpaces = true;
    register WCHAR wcKey = *strKey;
    register WCHAR wcSrc = *strSource;

    for(INT i = 0; wcKey != NULL; wcSrc = *(++strSource)){

        if(bEatSpaces){
            // eat up the spaces and tabs and enters and cr
            if(MyIsWhiteSpace(wcSrc)){
                continue;
            }
            else {
                bEatSpaces = false;
            }/* end of if statement */
        }/* end of if statement */
        
        if(wcKey != wcSrc){

            return(E_FAIL);
        }/* end of if statement */

        if(NULL == wcSrc){

            return(E_FAIL); // ran out of space in the source string
        }/* end of if statement */

        wcKey = strKey[++i]; // advance the key
    }/* end of for loop */

    return(S_OK);    
}/* end of function CompSubstr */

/*************************************************************************/
/* Function: ParsePropertyBag                                            */
/* Description: Retrives a property from the bag and puts it into variant*/
/* if it fails returns E_FAIL.                                           */
/*************************************************************************/
HRESULT CContainerObject::ParsePropertyBag(LPCOLESTR pszPropName, VARIANT* pVar, 
                                    IErrorLog* /* pErrorLog */){

    HRESULT hr = S_OK;

    try {

        BSTR strBag = m_pObj->GetPropBag();

        if(NULL == strBag){

            throw(E_FAIL);
        }/* end of if statement */       

        WCHAR* strValue = NULL; // the place where we are going to stick the actuall value
                         // before putting it into variant
        WCHAR* strTmpValue = L"";
        WCHAR* strTmpBag = strBag;

        if(NULL == *strTmpBag){

            throw(E_FAIL);
        }/* end of if statement */

        INT iState = 0; // 0 start

        bool fFound = false;
        bool fFinished = false;
        INT iLength = 0; // noting the start and end of the value string
        // now try to parse out the value for the appropriate string
        for(INT i = 0; NULL != *strTmpBag && !fFinished; i++){

            switch(iState){
                case 0: // looking for start <
                    if(FAILED(CompSubstr(strTmpBag, L"<"))) return (E_FAIL);
                    iState = 1; break;
                    
                case 1: // PARAM
                    if(FAILED(CompSubstr(strTmpBag, L"PARAM"))) return (E_FAIL);
                    iState = 2; break;

                case 2: // NAME
                    if(FAILED(CompSubstr(strTmpBag, L"NAME"))) return (E_FAIL);
                    iState = 3; break;

                case 3: // =
                    if(FAILED(CompSubstr(strTmpBag, L"="))) return (E_FAIL);
                    iState = 4; break;

                case 4: // "
                    if(FAILED(CompSubstr(strTmpBag, L"\""))) return (E_FAIL);
                    iState = 5; break;
                
                case 5: // pszPropName (the actual name)
                    if(SUCCEEDED(CompSubstr(strTmpBag, pszPropName))){
                        
                        fFound = true; // found the PropName
                    }/* end of if statement */

                    iState = 6; break;

                case 6: // "            
                    if(SUCCEEDED(CompSubstr(strTmpBag, L"\""))){

                        iState = 7; 
                    }
                    else {

                        strTmpBag++;
                    }/* end of if statement */
                    break;

                case 7: // VALUE
                    if(FAILED(CompSubstr(strTmpBag, L"VALUE"))) return (E_FAIL);
                    iState = 8; break;

                case 8: // =
                    if(FAILED(CompSubstr(strTmpBag, L"="))) return (E_FAIL);
                    iState = 9; break;

                case 9: // "
                    if(FAILED(CompSubstr(strTmpBag, L"\""))) return (E_FAIL);
                    iState = 10; break;


                case 10: // VALUE
                    if(fFound){

                        // read up the string and exit the loop
                        strTmpValue = strTmpBag;                        
                    }/* end of if statement */
                    
                    iState = 11; break;

                case 11: // "
                    if(SUCCEEDED(CompSubstr(strTmpBag, L"\""))){
                        iState = 12; 

                        if(fFound){
                            iLength = strTmpBag - strTmpValue;                        

                            strValue = new WCHAR[iLength];
                            memcpy(strValue, strTmpValue, iLength * sizeof(WCHAR));
                            strValue[iLength - 1] = NULL;
                            // read up the string and exit the loop

                            fFinished = true; // exit the loop
                        }/* end of if statement */                        
                    }
                    else {

                        strTmpBag++;
                    }/* end of if statement */
                    break;
                
                case 12: // closing brakcet >  
                    if(FAILED(CompSubstr(strTmpBag, L">"))) return (E_FAIL);
                    iState = 0;
                    break;
            }/* end of switch statement */
        }/* end of for loop */

        if(!fFinished){

            return(E_FAIL);
        }/* end of if statement */

        // at this moment we have value parsed out

        switch(pVar->vt){

        case VT_BSTR:
            pVar->bstrVal = ::SysAllocString(strValue);
            break;

        case VT_I4: {
            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->lVal = (INT)dbl;
        }
        case VT_UI4:{
            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->ulVal = (ULONG)dbl;
        }
        break;

        case VT_R4: {

            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->fltVal = (FLOAT) dbl;

        }
        break;

        case VT_R8: {

            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            pVar->dblVal = dbl;

        }
        break;

        case VT_BOOL: {
            double dbl;
            if(MyStrToDouble(strValue, dbl) != S_OK){

                // S_FALSE denotes empty string
                throw(E_FAIL);
            }/* end of if statement */

            // TODO: Create MyStrToInt and do not cast
            if(0.0 == dbl){

                pVar->boolVal = VARIANT_FALSE;
            }
            else if(1.0 == dbl || -1.0 == dbl){

                pVar->boolVal = VARIANT_TRUE;
            }
            else {

                throw(E_FAIL);
            }/* end of if statement */
        }
        break;

        default:
            ATLTRACE2(atlTraceHosting, 0, _T("This type is not implemented please add.\r\n"));
            ATLASSERT(FALSE);
            throw(E_FAIL);
        }/* end of switch statement */

        delete strValue; // cleanup our variable
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function ParsePropertyBag */
        
/*************************************************************************/
/* End of file: CCObj.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\chobj.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CHObj.cpp                                                       */
/*************************************************************************/
#include "stdafx.h"
#include "chobj.h"

/*************************************************************************/
/* Implemntation of Class: CHostedObject                                 */
/*************************************************************************/

/*************************************************************************/
/* Function: CHostedObject                                               */
/* Description: Constructor that initializes member variables of the     */
/* object.                                                               */
/*************************************************************************/
CHostedObject::CHostedObject(BSTR strID, BSTR strPropBag, IUnknown* pUnknown){

    Init();
    m_strID = ::SysAllocString(strID);
    m_strPropBag = ::SysAllocString(strPropBag);
    m_pUnknown = pUnknown;
    ::ZeroMemory(&m_rcRawPos, sizeof(RECT));
}/* end of function CHostedObject */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes the member variables                         */
/*************************************************************************/
void CHostedObject::Init(){

    m_pContainerObject = NULL;
    m_strID = NULL;
    m_strPropBag = NULL;
    m_bWindowless = false;
    //m_fActive = false;
    m_fActive = true;
    m_fCapture = false;
    m_fFocus = false;
    ::ZeroMemory(&m_rcRawPos, sizeof(RECT));    
}/* end of function Init */

/*************************************************************************/
/* Function: Cleanup                                                     */
/* Description: Cleans up the member variables                           */
/*************************************************************************/
void CHostedObject::Cleanup(){

    try {
        ATLTRACE(TEXT("In the cleanup of the CHostedObject\n"));
    
        if(NULL != m_strID){

            ::SysFreeString(m_strID);
            m_strID = NULL;
        }/* end of if statement */

        if(NULL != m_strPropBag){

            ::SysFreeString(m_strPropBag);
            m_strPropBag = NULL;
        }/* end of if statement */                    

        Init();
    }
    catch(...){
        ATLTRACE(TEXT("Reference counting is off \n"));
        return;
    }/* end of if statement */
}/* end of function Cleanup */

/*************************************************************************/
/* Function: CreateObject                                                */
/* Description: Creates the ActiveX Object via CoCreateInstance and      */
/* initializes it. If everything went OK the return the newly allocate   */
/* pObj.                                                                 */
/*************************************************************************/
HRESULT CHostedObject::CreateObject(BSTR strObjectID, BSTR strProgID, BSTR strPropBag, CHostedObject** ppObj){

    HRESULT hr;
    CLSID  tmpCLSID;

    if(NULL == ppObj){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *ppObj = NULL; // set the return value to NULL

    hr = ::CLSIDFromProgID(strProgID, &tmpCLSID);

    if (FAILED(hr)){

        // Try to get CLSID from string if not prog ID
        HRESULT hrTmp = CLSIDFromString(strProgID, &tmpCLSID);

        if(FAILED(hrTmp)){

            if (hr == CO_E_CLASSSTRING) {
                // BUG#101663
                // We can not use %1!ls! for Win95.
                return DISP_E_EXCEPTION;
            }/* end of if statement */
        
            return hr;
        }/* end of if statement */
    }/* end of if statement */

    CComPtr<IUnknown> pUnknown;

    hr = pUnknown.CoCreateInstance(tmpCLSID);        

    if (FAILED(hr)) {

        return(hr);
    }/* end of if statement */

    // everything went OK now allocate the object and set the variables to it
    *ppObj =  new  CHostedObject(strObjectID, strPropBag, pUnknown);

    if(NULL == *ppObj){ // in case we do not support exception handling

        hr =  E_OUTOFMEMORY;
    }/* end of if statement */

    return (hr);
}/* end of function CreateObject */

/*************************************************************************/
/* Function: AddObject                                                   */
/* Description: Simmilar to create object, but does not create on. Takes */
/* an existing IUnknown and wraps it, in the object structure.           */
/*************************************************************************/
HRESULT CHostedObject::AddObject(BSTR strObjectID, BSTR strPropBag, LPUNKNOWN pUnknown, 
                                 CHostedObject** ppObj){

    HRESULT hr = S_OK;
    
    if(NULL == ppObj){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    if(NULL == pUnknown){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *ppObj = NULL; // set the return value to NULL
    
    // everything went OK now allocate the object and set the variables to it
    *ppObj =  new  CHostedObject(strObjectID, strPropBag, pUnknown);

    if(NULL == *ppObj){ // in case we do not support exception handling

        hr =  E_OUTOFMEMORY;
    }/* end of if statement */

    return (hr);
}/* end of function AddObject */

/*************************************************************************/
/* Function: GetID                                                       */
/* Description: Returns the ID of the object                             */
/*************************************************************************/
BSTR CHostedObject::GetID(){

    return(m_strID);
}/* end of function GetID */

/*************************************************************************/
/* Function: GetPropBag                                                  */
/* Description: Returns the textual information that represents property */
/* bag and is associate with the object.                                 */
/*************************************************************************/
BSTR CHostedObject::GetPropBag(){

    return(m_strPropBag);
}/* end of function GetPropBag */

/*************************************************************************/
/* Function: GetUnknown                                                  */
/* Description: Gets the IUnknown stored in this object.                 */
/*************************************************************************/
IUnknown* CHostedObject::GetUnknown(){
    
    return(m_pUnknown);
}/* end of function GetUnknown */

/*************************************************************************/
/* Function: GetViewObject                                               */
/* Description: Gets the IViewObject cached for this object.             */
/*************************************************************************/
HRESULT CHostedObject::GetViewObject(IViewObjectEx** pIViewObject){

    HRESULT hr = S_OK;

    try {
        if(NULL == pIViewObject){

            throw(E_POINTER);
        }/* end of if statement */

        if(!m_spViewObject){

            hr = InitViewObject();

            if(FAILED(hr)){

                throw(hr);        
            }/* end of if statement */
        }/* end of if statement */

        if(!m_spViewObject){

            *pIViewObject = NULL;
            hr = E_FAIL;
            throw(hr);
        }/* end of if statement */

        *pIViewObject = m_spViewObject;
        (*pIViewObject)->AddRef(); // giving it out have add reff
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statemenmt */

	return(hr);	    
}/* end of function GetViewObject */

/*************************************************************************/
/* Function: GetOleObject                                                */
/* Description: Gets the IOleObject cached for this object.              */
/*************************************************************************/
HRESULT CHostedObject::GetOleObject(IOleObject** ppIOleObject){

    HRESULT hr = S_OK;

    try {
        if(NULL == ppIOleObject){

            throw(E_POINTER);
        }/* end of if statement */

        if(!m_pOleObject){

            if(!m_pUnknown){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            // cache up the IOleObject
            hr = m_pUnknown->QueryInterface(&m_pOleObject);

            if(FAILED(hr)){

                throw(hr);        
            }/* end of if statement */
        }/* end of if statement */

#ifdef _DEBUG
        if(!m_pOleObject){ // sometimes we get OK from QI but IOleObject is NULL

            *ppIOleObject = NULL;            
            throw(E_FAIL);
        }/* end of if statement */
#endif

        *ppIOleObject = m_pOleObject;        
        (*ppIOleObject)->AddRef();
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statemenmt */

	return(hr);	    
}/* end of function GetOleObject */

/*************************************************************************/
/* Function: GetTypeInfo                                                 */
/* Description: Calls the IDispatch object TypeInfo                      */
/*************************************************************************/
HRESULT CHostedObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo){

    HRESULT hr = S_OK;

    try {

        if(!m_pUnknown){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        CComPtr<IDispatch> pDispatch;

        hr = m_pUnknown->QueryInterface(&pDispatch);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = pDispatch->GetTypeInfo(itinfo,  lcid,  pptinfo);        

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statemenmt */
	return(hr);	
}/* end of funciton GetTypeInfo */

/*************************************************************************/
/* Function: GetPos                                                      */
/* Description: Accessor to the position of the embedded object.         */
/*************************************************************************/
HRESULT CHostedObject::GetPos(RECT* pRcPos){

    HRESULT hr = S_OK;

    if(NULL == pRcPos){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */
    
    // Get the raw rect for this object and then adjust it for the 
    // offset of the container

    *pRcPos = m_rcRawPos; 
   
    if(IsWindowless()){
        
        return(hr);
    }/* end of if statement */


    HWND hwnd = NULL;

    hr = GetWindow(&hwnd);

    if(FAILED(hr)){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    ::GetWindowRect(hwnd, pRcPos);  

    m_rcRawPos = *pRcPos; // update our cached value

    return(hr);
}/* end of function GetPos */

/*************************************************************************/
/* Function: SetRawPos                                                   */
/* Description: We set the RawPosition, which is location relative to the*/
/* container. Adjustment for the offset is done in GetPos function.      */
/*************************************************************************/
HRESULT CHostedObject::SetRawPos(const RECT* pRcPos){

    HRESULT hr = S_OK;

    if(NULL == pRcPos){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    m_rcRawPos = *pRcPos;
  
    return(hr);
}/* end of function SetRawPos */

/*************************************************************************/
/* Function: SetObjectRects                                              */
/* Description: Notififies the Controls about chaning rects, so they     */
/* will update their positions.                                          */
/*************************************************************************/
HRESULT CHostedObject::SetObjectRects(RECT* prcPos){

    HRESULT hr = S_OK;

    RECT rc;

    if(NULL == prcPos){
    
        hr = GetPos(&rc);
    }
    else {

        rc = *prcPos;
    }/* end of if statement */

    if(FAILED(hr)){

        throw(hr);
    }/* end of if statement */
    
    CComPtr<IOleInPlaceObject> pIOlePlace;

    if(!m_pUnknown){
        
        hr = S_FALSE;
        return(hr); // do not have the object yet no way to set it
    }/* end of if statement */

    hr = m_pUnknown->QueryInterface(&pIOlePlace);

    if(FAILED(hr)){
        
        hr = S_FALSE;
        return(hr); // do not have the IOleInPlaceObject in other words not activated
                    // object yet no way to set it, so lets not complain that
                    // much, since the ATL would break on 
    }/* end of if statement */

    // TODO: Pass down the clip rects evntaully, but right not used 
    // in our controls

    hr = pIOlePlace->SetObjectRects(&rc, &rc);
    
    return(hr);
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: InitViewObject                                              */
/* Description: Initializes the ViewObject.                              */
/*************************************************************************/
HRESULT CHostedObject::InitViewObject(){

    HRESULT hr = S_OK;

    if(!m_pUnknown){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

	hr = m_pUnknown->QueryInterface(IID_IViewObjectEx, (void**) &m_spViewObject);
    if (FAILED(hr)){

		hr = m_pUnknown->QueryInterface(IID_IViewObject2, (void**) &m_spViewObject);

        if (FAILED(hr)){

			hr = m_pUnknown->QueryInterface(IID_IViewObject, (void**) &m_spViewObject);			
		}/* end of if statement */
	}/* end of if statement */

    return(hr);
}/* end of function InitViewObject */

/*************************************************************************/
/* Function: SetActive                                                   */
/* Description: Sets the control flag to be active or not.               */
/* This disables it drawing in the container.                            */
/*************************************************************************/
HRESULT CHostedObject::SetActive(bool fActivate){

    HRESULT hr = S_OK;

    m_fActive = fActivate; // this might seem like a bug, but flag is important
                         // even if we do not get to hide the windowed control
    if(IsWindowless()){

        return(hr); // do not have to deal with hiding and showing of the window
        // we just do not draw the nonactive objects in the container
    }/* end of if statement */

    HWND hwnd = NULL;

    hr = GetWindow(&hwnd);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(::IsWindow(hwnd)){

        INT nShow = fActivate ? SW_SHOW : SW_HIDE;
        ::ShowWindow(hwnd, nShow);
    }/* end of if statement */

    return(hr);
}/* end of function SetActive */

/*************************************************************************/
/* Function: GetWindow                                                   */
/* Description: Gets the control window.                                 */
/*************************************************************************/
HRESULT CHostedObject::GetWindow(HWND* pHwnd){

    HRESULT hr = S_OK;

    // now try to 
    if(!m_pUnknown){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IOleInPlaceObject> pOleInPObject;
    hr = m_pUnknown->QueryInterface(&pOleInPObject);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */
    
    hr = pOleInPObject->GetWindow(pHwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    return(hr);
}/* end of if statement */
    
/*************************************************************************/
/* End of file: CHObj.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\chobj.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CHObj.h                                                         */
/* Description: Contains object that is the contained ActiveX controls   */
/*************************************************************************/

#ifndef __CHOBJ_H
#define __CHOBJ_H

class CContainerObject; // forward definition, so we do not have to include
// extra headers

/*************************************************************************/
/* Class: CHostedObject                                                  */
/* Description: Object that contains the contained control.              */
/*************************************************************************/
class CHostedObject{

public:        
    CHostedObject(){Init();};
    CHostedObject(BSTR strID, BSTR strPropBag, IUnknown* pUnknown);
    virtual ~CHostedObject(){Cleanup();};

    static HRESULT CreateObject(BSTR strObjectID, BSTR strProgID, BSTR strPropBag, CHostedObject** ppObj);
    static HRESULT CHostedObject::AddObject(BSTR strObjectID, BSTR strPropBag, LPUNKNOWN pUnknown, CHostedObject** ppObj);

    BSTR GetID(); // Gets the ID of the ActiveX Object
    BSTR GetPropBag(); // Gets the string to the property bag
    IUnknown* GetUnknown(); // gets the IUnknown of the ActiveX object
    HRESULT GetViewObject(IViewObjectEx** pIViewObject);
    HRESULT GetOleObject(IOleObject** pIOleObject);
    HRESULT InitViewObject(); // initializes the internal view object
    HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    HRESULT GetPos(RECT *rc);  
    HRESULT SetRawPos(const RECT *rc);    
    HRESULT SetObjectRects(RECT *rc = NULL);
    bool    IsWindowless(){return(m_bWindowless);};
    void    SetWindowless(bool bWindowless){m_bWindowless = bWindowless;};
    bool    IsActive(){return(m_fActive);};
    HRESULT SetActive(bool fActive);
    bool    HasCapture(){return(m_fCapture);};
    void    SetCapture(bool fCapture){m_fCapture = fCapture;};
    bool    HasFocus(){return(m_fFocus);};
    void    SetFocus(bool fFocus){m_fFocus = fFocus;};
    HRESULT GetContainerObject(CContainerObject** ppCnt){*ppCnt = m_pContainerObject; if(*ppCnt) return(S_OK); else return(E_UNEXPECTED);}
    HRESULT SetContainerObject(CContainerObject* pCnt){m_pContainerObject = pCnt; return(S_OK);};
    HRESULT GetWindow(HWND* pHwnd);
        
    // TODO: DISABLE COPY CONSTRUCTOR !!!
protected:
    void Init();
    void Cleanup();

private:    
    BSTR m_strID; // ID of the hosted control object (assigned by user)
    BSTR m_strPropBag; // Property bag info
    CComPtr<IUnknown> m_pUnknown; // pointer to IUnknown of the contained object
    CComPtr<IViewObjectEx> m_spViewObject; // pointer to IViewObject
    CComPtr<IOleObject> m_pOleObject; // pointer to this IOleObject
    CContainerObject* m_pContainerObject;    
    RECT m_rcRawPos; // position without the adjustment for offset    
    bool m_bWindowless;
    bool m_fActive;
    bool m_fCapture;
    bool m_fFocus;    
};/* end of class CHostedObject */

#endif __CHOBJ_H
/*************************************************************************/
/* End of file: CHObj.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\cbitmap.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: dibapi.cpp                                                      */
/* Description: Modified for transparent blitting.                       */
/*************************************************************************/
//  Source file for Device-Independent Bitmap (DIB) API.  Provides
//  the following functions:
//
//  PaintDIB()          - Painting routine for a DIB
//  PaintDIBTransparent() - Transparent painting routine for a DIB
//  CreateDIBPalette()  - Creates a palette from a DIB
//  FindDIBBits()       - Returns a pointer to the DIB bits
//  DIBWidth()          - Gets the width of the DIB
//  DIBHeight()         - Gets the height of the DIB
//  PaletteSize()       - Gets the size required to store the DIB's palette
//  DIBNumColors()      - Calculates the number of colors
//                        in the DIB's color table
//  CopyHandle()        - Makes a copy of the given global memory block
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
//#include "bbtn.h"
#include "CBitmap.h"
#include <io.h>
#include <errno.h>
#include <math.h>
#include <direct.h>

/*
 * Dib Header Marker - used in writing DIBs to files
 */
#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

/*************************************************************************/
/* Function: Init                                                        */
/*************************************************************************/
void CBitmap::Init(){

    m_hDIB = NULL;
    m_hPal = NULL;
    m_hMemDC = NULL;
    m_hMemBMP = NULL;
    m_hTransDC = NULL;
    m_hTransBMP = NULL;
    m_hRgn = NULL;
    m_fLoadPalette = false;
    ::ZeroMemory(&m_rc, sizeof(RECT));
}/* end of function Init */

/*************************************************************************/
/* Function: CleanUp                                                     */
/* Description: Destroys the objects.                                    */
/*************************************************************************/
void CBitmap::CleanUp() {

    try {
        // cleanup the background image resources
        if (m_hDIB){
        
            ::GlobalFree(m_hDIB);
        }/* end of if statement */
    }
    catch(...){
         ATLASSERT(FALSE);
    }

    try {
        // cleanup the palette if applicable
        if (m_hPal){
    
            ::DeleteObject(m_hPal);
        }/* end of if statement */

    }
    catch(...){
        ATLASSERT(FALSE);
    }

    try {

        if(NULL != m_hRgn){

            ::DeleteObject(m_hRgn);
        }/* end of if statement */        
        DeleteMemDC();
        DeleteTransDC();
    }
    catch(...){
        ATLASSERT(FALSE);
    }

    bool fLoadPalette = m_fLoadPalette;
    Init();
    m_fLoadPalette = fLoadPalette;
}/* end of function Cleanup */

/*************************************************************************

  Function:  ReadDIBFile (CFile&)

   Purpose:  Reads in the specified DIB file into a global chunk of
			 memory.

   Returns:  A handle to a dib (hDIB) if successful.
			 NULL if an error occurs.

  Comments:  BITMAPFILEHEADER is stripped off of the DIB.  Everything
			 from the end of the BITMAPFILEHEADER structure on is
			 returned in the global memory handle.

  TODO: Convert to HRESULTs clean up.
*************************************************************************/
HDIB WINAPI CBitmap::ReadDIBFile(LPCTSTR pszFileName, HINSTANCE hRes )
{
	BITMAPFILEHEADER bmfHeader;
	DWORD dwBitsSize;
	LPSTR pDIB;
	HANDLE hFile = NULL;
	DWORD nBytesRead;
    HGLOBAL hMemory = NULL;

    if(NULL == hRes){

	    /*
	     * get length of DIB in bytes for use when reading
	     */
        hFile =  ::CreateFile(
	    pszFileName,    // pointer to name of the file
	    GENERIC_READ,   // access (read-write) mode
	    FILE_SHARE_READ,    // share mode
	    NULL,   // pointer to security descriptor
	    OPEN_EXISTING,  // how to create
	    FILE_ATTRIBUTE_NORMAL,  // file attributes
	    NULL    // handle to file with attributes to copy
       );

        if(hFile == INVALID_HANDLE_VALUE){
            #if _DEBUG
    
                TCHAR strBuffer[MAX_PATH + 25];
                wsprintf(strBuffer, TEXT("Failed to download %s"), pszFileName);
                ::MessageBox(::GetFocus(), strBuffer, TEXT("Error"), MB_OK);
            #endif
            return NULL;
        }/* end of if statement */

	    dwBitsSize = GetFileSize(hFile,NULL);
    }
    else {

        TCHAR* strType = TEXT("DIB_FILE"); // this is a custom resource type, so we load the whole file
                                           // see script resource type in this project for an example
        HRSRC hrscScript = ::FindResource(hRes, pszFileName, strType);

        if(NULL == hrscScript){

            // convert the function to HRES evntually hr = HRESULT_FROM_WIN32(::GetLastError());
            #if _DEBUG
    
                TCHAR strBuffer[MAX_PATH + 25];
                wsprintf(strBuffer, TEXT("Failed to find resource %s"), pszFileName);
                ::MessageBox(::GetFocus(), strBuffer, TEXT("Error"), MB_OK);
            #endif

            return(NULL);
        }/* end of if statement */

        hMemory = ::LoadResource(hRes, hrscScript); 

        if(NULL == hMemory){

            //hr = HRESULT_FROM_WIN32(::GetLastError());
            return(NULL);
        }/* end of if statement */
    
        dwBitsSize = SizeofResource((HMODULE)hRes, hrscScript);
        
        // hMemory contains the raw data
        // modify the algorithm to one read, so we can use the resources
    }/* end of if statement */

    if(0 == dwBitsSize){
                   
        return(NULL); // the file size should be definetly more then 0
    }/* end of if statement */


    /*
    * Go read the DIB file header and check if it's valid.
    */
    if(NULL == hRes && hFile){
        // attempt an asynchronous read operation
        if(! ReadFile(hFile, (LPSTR)&bmfHeader, sizeof(bmfHeader), &nBytesRead, NULL))
            return NULL;
    }
    else if (hMemory){
        CopyMemory(&bmfHeader, hMemory, sizeof(bmfHeader));
    }
    if (bmfHeader.bfType != DIB_HEADER_MARKER)
        return NULL;
    

	/*
	 * Allocate memory for DIB
	 */
	m_hDIB = (HDIB) ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwBitsSize);
	if (m_hDIB == 0)
	{
		return NULL;
	}
	pDIB = (LPSTR) ::GlobalLock((HGLOBAL) m_hDIB);

    /*
    * Go read the bits.
    */
    if (NULL == hRes) {
        if(!ReadFile(hFile, (LPSTR)pDIB, dwBitsSize - sizeof(BITMAPFILEHEADER), &nBytesRead, NULL))
        {
            ::GlobalUnlock((HGLOBAL) m_hDIB);
            ::GlobalFree((HGLOBAL) m_hDIB);
            return NULL;
        }
        ::CloseHandle(hFile);

    }
    else{
        CopyMemory(pDIB, (LPSTR)hMemory+sizeof(BITMAPFILEHEADER), dwBitsSize - sizeof(BITMAPFILEHEADER));
    }
    ::GlobalUnlock((HGLOBAL) m_hDIB);

	return m_hDIB;
}/* end of function ReadDIBFile */

/*************************************************************/
/* Name: CreateMemDC                                         */
/* Description: Creates a memory DC.                         */
/*************************************************************/
BOOL CBitmap::CreateMemDC(HDC hDC, LPRECT lpDCRect){

    DeleteMemDC();

    m_hMemDC = ::CreateCompatibleDC(hDC); // handle to the device context
    
    if(m_hMemDC == NULL){
        
        return(FALSE);
    }/* end of if statement */
          
    m_iMemDCWidth  = RECTWIDTH(lpDCRect);
    m_iMemDCHeight = RECTHEIGHT(lpDCRect);
    
    m_hMemBMP = ::CreateCompatibleBitmap(hDC, m_iMemDCWidth, m_iMemDCHeight);
    
    if(m_hMemBMP == NULL){
        
        ::DeleteDC(m_hMemDC);
        return(FALSE);
    }/* end of if statement */
    
    ::SelectObject(m_hMemDC, m_hMemBMP);
    return TRUE;
}/* end of function CreateMemDC */

/*************************************************************/
/* Name: DeleteMemDC                                         */
/* Description: Deletes the memory DC.                       */
/*************************************************************/
BOOL CBitmap::DeleteMemDC(){

    if (m_hMemDC) {
        ::DeleteDC(m_hMemDC);
        m_hMemDC = NULL;
    }

    if (m_hMemBMP) {
        ::DeleteObject(m_hMemBMP);
        m_hMemBMP = NULL;
    }
    
    m_iMemDCWidth  = 0;
    m_iMemDCHeight = 0;

    return TRUE;
}/* end of function DeleteMemDC */

/*************************************************************/
/* Name: CreateTransDC
/* Description: Create a DC 
/*************************************************************/
BOOL CBitmap::CreateTransDC(HDC hDC, LPRECT lpDCRect)
{
    DeleteTransDC();

    m_hTransDC = ::CreateCompatibleDC(hDC); // handle to the device context
    
    if(m_hTransDC == NULL){
        
        return(FALSE);
    }/* end of if statement */
    
    m_iTransDCWidth  = RECTWIDTH(lpDCRect);
    m_iTransDCHeight = RECTHEIGHT(lpDCRect);
    
    m_hTransBMP = ::CreateCompatibleBitmap(hDC, m_iTransDCWidth, m_iTransDCHeight);
    
    if(m_hTransBMP == NULL){
        
        ::DeleteDC(m_hTransDC);
        return(FALSE);
    }/* end of if statement */
    
    ::SelectObject(m_hTransDC, m_hTransBMP);
    return TRUE;
}

/*************************************************************/
/* Name: DeleteTransDC
/* Description: 
/*************************************************************/
BOOL CBitmap::DeleteTransDC(){

    if (m_hTransDC) {
        ::DeleteDC(m_hTransDC);
        m_hTransDC = NULL;
    }

    if (m_hTransBMP) {
        ::DeleteObject(m_hTransBMP);
        m_hTransBMP = NULL;
    }
    
    m_iTransDCWidth  = 0;
    m_iTransDCHeight = 0;

    return TRUE;
}/* end of function DeleteTransDC */

/*************************************************************/
/* Name: BlitMemDC                                           */
/*************************************************************/
BOOL CBitmap::BlitMemDC(HDC hDC, RECT* lpDCRect, RECT* lpDIBRect){

    if(NULL == hDC){

        ATLASSERT(FALSE);
        return(FALSE);
    }/* end of if statement */

    if(FALSE == CreateMemDC(hDC, lpDCRect)){

        ATLASSERT(FALSE);
        return FALSE;
    }/* end of if statement */

    RECT DIBRect = *lpDIBRect;
    RECT DCRect = *lpDCRect;
    
    // Blit the upper left corner
    DIBRect.bottom = (DIBRect.top+DIBRect.bottom)/2;
    DIBRect.right = (DIBRect.left+DIBRect.right)/2;
    DCRect.bottom = DCRect.top + RECTHEIGHT(&DIBRect);
    DCRect.right = DCRect.left + RECTWIDTH(&DIBRect);
    PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);

    // Blit the upper right corner
    ::OffsetRect(&DCRect, RECTWIDTH(lpDCRect)-RECTWIDTH(&DIBRect), 0);
    ::OffsetRect(&DIBRect, RECTWIDTH(&DIBRect), 0);
    PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);
    
    // Blit the lower right corner
    ::OffsetRect(&DCRect, 0, RECTHEIGHT(lpDCRect)-RECTHEIGHT(&DIBRect));
    ::OffsetRect(&DIBRect, 0, RECTHEIGHT(&DIBRect));
    PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);
    
    // Blit the lower left corner
    ::OffsetRect(&DCRect, -RECTWIDTH(lpDCRect)+RECTWIDTH(&DIBRect), 0);
    ::OffsetRect(&DIBRect, -RECTWIDTH(&DIBRect), 0);
    PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);
    
    // Blit the the middle if window resized beyond the bitmap
    if (RECTWIDTH(&m_rc)<RECTWIDTH(lpDCRect)+20) {
        int neededWidth = RECTWIDTH(lpDCRect)+20-RECTWIDTH(&m_rc);
        RECT DIBRect = m_rc;
        RECT DCRect = *lpDCRect;
        DIBRect.bottom = (DIBRect.top+DIBRect.bottom)/2;
        DIBRect.left += (RECTWIDTH(&m_rc)-neededWidth)/2;
        DIBRect.right = DIBRect.left + neededWidth;
        
        DCRect.bottom = DCRect.top+RECTHEIGHT(&DIBRect);
        DCRect.left += RECTWIDTH(&m_rc)/2;
        DCRect.right = DCRect.left + neededWidth;
        PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);
        
        ::OffsetRect(&DCRect, 0, RECTHEIGHT(lpDCRect)-RECTHEIGHT(&DIBRect));
        ::OffsetRect(&DIBRect, 0, RECTHEIGHT(&DIBRect));
        PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);
    }
    
    if (RECTHEIGHT(&m_rc)<RECTHEIGHT(lpDCRect)+20) {
        int neededHeight = RECTHEIGHT(lpDCRect)+20-RECTHEIGHT(&m_rc);
        RECT DIBRect = m_rc;
        RECT DCRect = *lpDCRect;
        
        DIBRect.top += (RECTHEIGHT(&m_rc)-neededHeight)/2;
        DIBRect.bottom = DIBRect.top + neededHeight;
        DIBRect.right = (DIBRect.left+DIBRect.right)/2;
        
        DCRect.top += RECTHEIGHT(&m_rc)/2;
        DCRect.bottom = DCRect.top + neededHeight;
        DCRect.right = DCRect.left+RECTWIDTH(&DIBRect);
        PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);
        
        ::OffsetRect(&DCRect, RECTWIDTH(lpDCRect)-RECTWIDTH(&DIBRect), 0);
        ::OffsetRect(&DIBRect, RECTWIDTH(&DIBRect), 0);
        PaintDIB(m_hMemDC, &DCRect, &DCRect, &DIBRect);
    }

    return TRUE;
}/* end of function BlitMemDC */

/*************************************************************************
 *
 * PaintDIB()
 *
 * Parameters:
 *
 * HDC hDC          - DC to do output to
 *
 * LPRECT lpDCRect  - rectangle on DC to do output to
 *
 * Return Value:
 *
 * BOOL             - TRUE if DIB was drawn, FALSE otherwise
 *
 * Description:
 *   Painting routine for a DIB.  Calls StretchDIBits() or
 *   SetDIBitsToDevice() to paint the DIB.  The DIB is
 *   output to the specified DC, at the coordinates given
 *   in lpDCRect.  The area of the DIB to be output is
 *   given by lpDIBRect.
 *
 ************************************************************************/
 BOOL WINAPI CBitmap::PaintDIB(HDC     hDC,
					LPRECT  lpDCWRect,
					LPRECT  lpDCRect,
                    LPRECT  lpDIBRect,
                    bool complex)
{
	LPSTR    lpDIBHdr;            // Pointer to BITMAPINFOHEADER
	LPSTR    lpDIBBits;           // Pointer to DIB bits
	BOOL     bSuccess=FALSE;      // Success/fail flag
	HPALETTE hOldPal=NULL;        // Previous palette

	/* Check for valid DIB handle */
	if (m_hDIB == NULL)
		return FALSE;

	/* Lock down the DIB, and get a pointer to the beginning of the bit
	 *  buffer
	 */
	lpDIBHdr  = (LPSTR) ::GlobalLock((HGLOBAL) m_hDIB);
	lpDIBBits = FindDIBBits(lpDIBHdr);

	// Get the DIB's palette, then select it into DC
	// Select as background since we have
	// already realized in forground if needed
    //if(NULL != m_hPal){
    //
	//    hOldPal = ::SelectPalette(hDC, m_hPal, TRUE);
    //}/* end of if statement */

	/* Make sure to use the stretching mode best for color pictures */
	::SetStretchBltMode(hDC, COLORONCOLOR);

	/* Determine whether to call StretchDIBits() or SetDIBitsToDevice() */
	if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDIBRect)) && (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDIBRect)))
	{
		bSuccess = ::SetDIBitsToDevice(hDC,  // hDC
			lpDCRect->left,             // DestX
			lpDCRect->top,              // DestY
			RECTWIDTH(lpDCRect),        // nDestWidth
			RECTHEIGHT(lpDCRect),       // nDestHeight
			lpDIBRect->left,            // SrcX
			(int)DIBHeight(lpDIBHdr) -
			lpDIBRect->top -
			RECTHEIGHT(lpDIBRect),   // SrcY
			0,                          // nStartScan
			(WORD)DIBHeight(lpDIBHdr),  // nNumScans
			lpDIBBits,                  // lpBits
			(LPBITMAPINFO)lpDIBHdr,     // lpBitsInfo
			DIB_RGB_COLORS);            // wUsage
	}
	else
	{
        // resize the bitmap first and blit it
        if (complex) {
            if (m_hMemDC == NULL)
                BlitMemDC(hDC, lpDCWRect, lpDIBRect);

            else if (m_iMemDCWidth!= RECTWIDTH(lpDCWRect) ||
                m_iMemDCHeight!= RECTHEIGHT(lpDCWRect)) {
                if (EqualRect(lpDCWRect, lpDCRect))
                    BlitMemDC(hDC, lpDCWRect, lpDIBRect);
            }
            bSuccess = ::BitBlt(hDC, 
                lpDCRect->left, lpDCRect->top, 
                RECTWIDTH(lpDCRect), RECTHEIGHT(lpDCRect),
                m_hMemDC, lpDCRect->left, lpDCRect->top, SRCCOPY);
            ATLTRACE(TEXT("BitBlt %d %d %d %d\n"), 
                lpDCRect->left, lpDCRect->top, 
                RECTWIDTH(lpDCRect), RECTHEIGHT(lpDCRect));
        }
        else {
            bSuccess = ::StretchDIBits(hDC,     // hDC
                lpDCRect->left,                 // DestX
                lpDCRect->top,                  // DestY
                RECTWIDTH(lpDCRect),            // nDestWidth
                RECTHEIGHT(lpDCRect),           // nDestHeight
                lpDIBRect->left,                // SrcX
                lpDIBRect->top,                 // SrcY
                RECTWIDTH(lpDIBRect),           // wSrcWidth
                RECTHEIGHT(lpDIBRect),          // wSrcHeight
                lpDIBBits,                      // lpBits
                (LPBITMAPINFO)lpDIBHdr,         // lpBitsInfo
                DIB_RGB_COLORS,                 // wUsage
                SRCCOPY);                       // dwROP
        }
            
    }

   ::GlobalUnlock((HGLOBAL) m_hDIB);

	/* Reselect old palette */
	//if (hOldPal != NULL)
	//{
	//	::SelectPalette(hDC, hOldPal, TRUE);
	//}

   return bSuccess;
}

/*************************************************************************
 *
 * PaintTransparentDIB()
 *
 * Parameters:
 *
 * HDC hDC          - DC to do output to
 *
 * LPRECT lpDCRect  - rectangle on DC to do output to
 *
 * COLORREF clr     - color to be used as a transparency
 *
 * Return Value:
 *
 * BOOL             - TRUE if DIB was drawn, FALSE otherwise
 *
 *
 * Description:
 *   Painting routine for a DIB.  Calls StretchDIBits() or
 *   SetDIBitsToDevice() to paint the DIB.  The DIB is
 *   output to the specified DC, at the coordinates given
 *   in lpDCRect.  The area of the DIB to be output is
 *   given by lpDIBRect.
 *
 ************************************************************************/
 BOOL WINAPI CBitmap::PaintTransparentDIB(HDC     hDC,
                                LPRECT  lpDCWRect,
					            LPRECT  lpDCRect,
                                TransparentBlitType blitType,
                                bool complex,
                                HWND hWnd){

    BOOL bSuccess=FALSE;      // Success/fail flag

    if(NULL == m_hDIB){

        return(bSuccess);
    }/* end of if statement */
                
    if(blitType != DISABLE){

        LONG lWidth  = RECTWIDTH(lpDCRect);
        LONG lHeight = RECTHEIGHT(lpDCRect);
        
        RECT rc = {0, 0, lWidth, lHeight};
        ATLTRACE(TEXT("PaintTransparentDIB %d %d %d %d\n"), lWidth, lHeight,
                m_iTransDCWidth, m_iTransDCHeight);
        BOOL bNewRgn = FALSE;
        if (!m_hTransDC || lWidth != m_iTransDCWidth || lHeight != m_iTransDCHeight) {
            bNewRgn = TRUE;
            CreateTransDC(hDC, &rc);
            if(FALSE == PaintDIB(m_hTransDC, lpDCWRect, &rc, &m_rc)){
                
                return (FALSE);
            }/* end of if statement */
        }
        COLORREF clrTrans = RGB(255, 0, 255);

        LPSTR pDIB = (LPSTR)::GlobalLock(m_hDIB);
		LONG lBmpWidth  = DIBWidth(pDIB);
		LONG lBmpHeight  = DIBHeight(pDIB);
        ::GlobalUnlock(m_hDIB);

        if(0 != lBmpWidth && 0 != lBmpHeight){

            if(TRANSPARENT_TOP_LEFT == blitType ||
                TOP_LEFT_WITH_BACKCOLOR == blitType ||
                TOP_LEFT_WINDOW_REGION == blitType )
                clrTrans = ::GetPixel(m_hTransDC, 0, 0);
            else if(TRANSPARENT_BOTTOM_RIGHT  == blitType ||
                BOTTOM_RIGHT_WITH_BACKCOLOR == blitType ||
                BOTTOM_RIGHT_WINDOW_REGION == blitType )
                clrTrans = ::GetPixel(m_hTransDC, lBmpWidth - 1, lBmpHeight -1);
        }/* end of if statement */
       
        if (TOP_LEFT_WINDOW_REGION == blitType ||
            BOTTOM_RIGHT_WINDOW_REGION == blitType ) {
            HRGN hOldRgn = NULL;
            if (::IsWindow(hWnd)) {
                ::GetWindowRgn(hWnd, hOldRgn);
                if (bNewRgn) {
                    if (m_hRgn)
                        ::DeleteObject(m_hRgn);
                    GetRegion(m_hTransDC, &m_hRgn, &rc, clrTrans);
                }
                HRGN hNewRgn = ::CreateRectRgn(0, 0, 1, 1);
                ::CombineRgn(hNewRgn, m_hRgn, NULL, RGN_COPY);
                int nRet = ::SetWindowRgn(hWnd, hNewRgn, TRUE);
                ATLTRACE(TEXT("SetWindowRgn %d\n"), nRet);                        
                ::SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE);
            }
            
            bSuccess = ::StretchBlt(hDC, 
                lpDCRect->left,             // DestX
                lpDCRect->top,              // DestY
                lWidth,                         // nDestWidth
                lHeight,                        // nDestHeight
                m_hTransDC,
                0,                              // SrcX
                0,                              // SrcY
                lWidth,                         // nSrcWidth
                lHeight,                        // nSrcHeight
                SRCCOPY                         
                );
            if (::IsWindow(hWnd) && hOldRgn) 
                ::SetWindowRgn(hWnd, hOldRgn, FALSE);
        }
        else 
            bSuccess = ::TransparentBlt(hDC, 
            lpDCRect->left,             // DestX
            lpDCRect->top,              // DestY
            lWidth,                         // nDestWidth
            lHeight,                        // nDestHeight
            m_hTransDC,
            0,                              // SrcX
            0,                              // SrcY
            lWidth,                         // nSrcWidth
            lHeight,                        // nSrcHeight
            clrTrans                             // transparent color
            );
    }
    else {

        // no transparent blit
        bSuccess = PaintDIB(hDC, lpDCWRect, lpDCRect, &m_rc, complex);
    }/* end of if statement */

   return bSuccess;
}/* end of function PaintTransparentDIB */

/*************************************************************************
 *
 * CreateDIBPalette()
 *
 * Parameter:
 *
 * HDIB hDIB        - specifies the DIB
 *
 * Return Value:
 *
 * HPALETTE         - specifies the palette
 *
 * Description:
 *
 * This function creates a palette from a DIB by allocating memory for the
 * logical palette, reading and storing the colors from the DIB's color table
 * into the logical palette, creating a palette from this logical palette,
 * and then returning the palette's handle. This allows the DIB to be
 * displayed using the best possible colors (important for DIBs with 256 or
 * more colors).
 *
 ************************************************************************/
 BOOL WINAPI CBitmap::CreateDIBPalette()
{
	LPLOGPALETTE lpPal;      // pointer to a logical palette
	HANDLE hLogPal;          // handle to a logical palette
	HPALETTE hPal = NULL;    // handle to a palette
	int i;                   // loop index
	WORD wNumColors;         // number of colors in color table
	LPSTR lpbi;              // pointer to packed-DIB
	LPBITMAPINFO lpbmi;      // pointer to BITMAPINFO structure (Win3.0)
	LPBITMAPCOREINFO lpbmc;  // pointer to BITMAPCOREINFO structure (old)
	BOOL bWinStyleDIB;       // flag which signifies whether this is a Win3.0 DIB
	BOOL bResult = FALSE;

	/* if handle to DIB is invalid, return FALSE */

	if (m_hDIB == NULL)
	  return FALSE;

   lpbi = (LPSTR) ::GlobalLock((HGLOBAL) m_hDIB);

   /* get pointer to BITMAPINFO (Win 3.0) */
   lpbmi = (LPBITMAPINFO)lpbi;

   /* get pointer to BITMAPCOREINFO (old 1.x) */
   lpbmc = (LPBITMAPCOREINFO)lpbi;

   /* get the number of colors in the DIB */
   wNumColors = DIBNumColors(lpbi);

   if (wNumColors != 0)
   {
		/* allocate memory block for logical palette */
		hLogPal = ::GlobalAlloc(GHND, sizeof(LOGPALETTE)
									+ sizeof(PALETTEENTRY)
									* wNumColors);

		/* if not enough memory, clean up and return NULL */
		if (hLogPal == 0)
		{
			::GlobalUnlock((HGLOBAL) m_hDIB);
			return FALSE;
		}

		lpPal = (LPLOGPALETTE) ::GlobalLock((HGLOBAL) hLogPal);

		/* set version and number of palette entries */
		lpPal->palVersion = PALVERSION;
		lpPal->palNumEntries = (WORD)wNumColors;

		/* is this a Win 3.0 DIB? */
		bWinStyleDIB = IS_WIN30_DIB(lpbi);
		for (i = 0; i < (int)wNumColors; i++)
		{
			if (bWinStyleDIB)
			{
				lpPal->palPalEntry[i].peRed = lpbmi->bmiColors[i].rgbRed;
				lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
				lpPal->palPalEntry[i].peBlue = lpbmi->bmiColors[i].rgbBlue;
				lpPal->palPalEntry[i].peFlags = 0;
			}
			else
			{
				lpPal->palPalEntry[i].peRed = lpbmc->bmciColors[i].rgbtRed;
				lpPal->palPalEntry[i].peGreen = lpbmc->bmciColors[i].rgbtGreen;
				lpPal->palPalEntry[i].peBlue = lpbmc->bmciColors[i].rgbtBlue;
				lpPal->palPalEntry[i].peFlags = 0;
			}
		}

		/* create the palette and get handle to it */
		hPal = (HPALETTE)::CreatePalette((LPLOGPALETTE)lpPal);
		::GlobalUnlock((HGLOBAL) hLogPal);
		::GlobalFree((HGLOBAL) hLogPal);
		m_hPal = hPal;
	}

	::GlobalUnlock((HGLOBAL) m_hDIB);

	return (NULL != m_hPal);
}

/*************************************************************************
 *
 * ConvertColorTableGray()
 *
 * Parameter:
 *
 * HDIB hDIB        - specifies the DIB
 *
 * Return Value:
 *
 * HPALETTE         - specifies the palette
 *
 * Description:
 *
 ************************************************************************/
 BOOL WINAPI CBitmap::ConvertColorTableGray()
{
	int i;                   // loop index
	WORD wNumColors;         // number of colors in color table
	LPSTR lpbi;              // pointer to packed-DIB
	LPBITMAPINFO lpbmi;      // pointer to BITMAPINFO structure (Win3.0)
	LPBITMAPCOREINFO lpbmc;  // pointer to BITMAPCOREINFO structure (old)
	BOOL bWinStyleDIB;       // flag which signifies whether this is a Win3.0 DIB
	BOOL bResult = FALSE;

	/* if handle to DIB is invalid, return FALSE */

	if (m_hDIB == NULL)
	  return FALSE;

   lpbi = (LPSTR) ::GlobalLock((HGLOBAL) m_hDIB);

   /* get pointer to BITMAPINFO (Win 3.0) */
   lpbmi = (LPBITMAPINFO)lpbi;

   /* get pointer to BITMAPCOREINFO (old 1.x) */
   lpbmc = (LPBITMAPCOREINFO)lpbi;

   /* get the number of colors in the DIB */
   wNumColors = DIBNumColors(lpbi);

   if (wNumColors != 0)
   {
		/* is this a Win 3.0 DIB? */
		bWinStyleDIB = IS_WIN30_DIB(lpbi);
		for (i = 0; i < (int)wNumColors; i++)
		{
			if (bWinStyleDIB)
			{
                BYTE L = RGBtoL(lpbmi->bmiColors[i].rgbRed,
                    lpbmi->bmiColors[i].rgbGreen,
                    lpbmi->bmiColors[i].rgbBlue);

                lpbmi->bmiColors[i].rgbRed = L;
                lpbmi->bmiColors[i].rgbGreen = L;
                lpbmi->bmiColors[i].rgbBlue = L;
			}
			else
			{
                BYTE L = RGBtoL(lpbmc->bmciColors[i].rgbtRed,
                    lpbmc->bmciColors[i].rgbtGreen,
                    lpbmc->bmciColors[i].rgbtBlue);
                
                lpbmc->bmciColors[i].rgbtRed = L;
                lpbmc->bmciColors[i].rgbtGreen = L;
                lpbmc->bmciColors[i].rgbtBlue = L;
			}
		}

	}

	::GlobalUnlock((HGLOBAL) m_hDIB);
    return TRUE;

}

/*************************************************************************
 *
 * ConvertDIBGray()
 *
 * Parameter:
 *
 * HDIB hDIB        - specifies the DIB
 *
 * Return Value:
 *
 * blitType         - specifies the TransparentBlitType
 *
 * Description:
 *
 ************************************************************************/
BOOL WINAPI CBitmap::ConvertDIBGray(TransparentBlitType blitType)
{
	/* if handle to DIB is invalid, return FALSE */

   if (m_hDIB == NULL)
	  return FALSE;

   WORD wNumColors;         // number of colors in color table
   LPSTR lpbi;              // pointer to packed-DIB
   LPBITMAPINFO lpbmi;      // pointer to BITMAPINFO structure (Win3.0)
   LPBITMAPCOREINFO lpbmc;  // pointer to BITMAPCOREINFO structure (old)
   LPSTR    lpDIBBits;      // Pointer to DIB bits
   LPSTR    lpKeyColor;

   lpbi = (LPSTR) ::GlobalLock((HGLOBAL) m_hDIB);

   /* get pointer to BITMAPINFO (Win 3.0) */
   lpbmi = (LPBITMAPINFO)lpbi;

   /* get pointer to BITMAPCOREINFO (old 1.x) */
   lpbmc = (LPBITMAPCOREINFO)lpbi;

   /* get the number of colors in the DIB */
   wNumColors = DIBNumColors(lpbi);

   if (wNumColors != 0)
	   return FALSE;

   /* Lock down the DIB, and get a pointer to the beginning of the bit
   *  buffer
   */
   lpDIBBits = FindDIBBits(lpbi);

   // 24 bit color case
   if (lpbmi->bmiHeader.biBitCount==24) {
       int rowLength = lpbmi->bmiHeader.biWidth*3;
       if (rowLength%4) 
           rowLength = (rowLength/4+1)*4;
       
       if(TRANSPARENT_TOP_LEFT == blitType ||
          TOP_LEFT_WITH_BACKCOLOR == blitType ||
          TOP_LEFT_WINDOW_REGION == blitType )
           lpKeyColor = lpDIBBits;
       else if(TRANSPARENT_BOTTOM_RIGHT  == blitType ||
          BOTTOM_RIGHT_WITH_BACKCOLOR == blitType ||        
          BOTTOM_RIGHT_WINDOW_REGION == blitType )
           lpKeyColor = lpDIBBits+rowLength*lpbmi->bmiHeader.biHeight-1;
       // TODO: Handle magenta
       
       for (int i=0; i<lpbmi->bmiHeader.biHeight; i++) {
           for (int j=0; j<lpbmi->bmiHeader.biWidth; j++) {

               if (*(lpDIBBits+i*rowLength+j*3) != *(lpDIBBits) ||
                   *(lpDIBBits+i*rowLength+j*3+1) != *(lpDIBBits+1) ||
                   *(lpDIBBits+i*rowLength+j*3+2) != *(lpDIBBits+2)) {
                    BYTE L = RGBtoL(*(lpDIBBits+i*rowLength+j*3),
                        *(lpDIBBits+i*rowLength+j*3+1),
                        *(lpDIBBits+i*rowLength+j*3+2));

                   *(lpDIBBits+i*rowLength+j*3)   = L;
                   *(lpDIBBits+i*rowLength+j*3+1)   = L;
                   *(lpDIBBits+i*rowLength+j*3+2) = L;
               }
           }   
       }
   }
	
   // 16 bit color case
   else if (lpbmi->bmiHeader.biBitCount==16) {
       int rowLength = lpbmi->bmiHeader.biWidth*2;
       if (rowLength%4) 
           rowLength = (rowLength/4+1)*4;

       if (lpbmi->bmiHeader.biCompression==BI_RGB) {
           for (int i=0; i<lpbmi->bmiHeader.biHeight; i++) {
               for (int j=0; j<lpbmi->bmiHeader.biWidth; j++) {
                   WORD color = *(WORD*)(lpDIBBits+i*rowLength+j*2);
                   WORD green = (WORD)(color & 0x03E0);
                   WORD red = (WORD)(green << 5);
                   WORD blue = (WORD)(green >> 5);
                   color = (WORD)(red | green | blue);
                   *(WORD*)(lpDIBBits+i*rowLength+j*2) = color;
               }
           }
       }
   }

        
   ::GlobalUnlock((HGLOBAL) m_hDIB);
   return TRUE;
}

/*************************************************************************
 *
 * FindDIBBits()
 *
 * Parameter:
 *
 * LPSTR lpbi       - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * LPSTR            - pointer to the DIB bits
 *
 * Description:
 *
 * This function calculates the address of the DIB's bits and returns a
 * pointer to the DIB bits.
 *
 ************************************************************************/
 LPSTR WINAPI CBitmap::FindDIBBits(LPSTR lpbi)
{
	return (lpbi + *(LPDWORD)lpbi + PaletteSize(lpbi));
}

/*************************************************************/
/* Name: SetImage
/* Description: load bitmap image
/*************************************************************/
 HRESULT CBitmap::SetImage(TCHAR* strFilename, HINSTANCE hRes)
{
    HRESULT hr = S_OK;

    CleanUp();

	m_hDIB = ReadDIBFile(strFilename, hRes);

	if (m_hDIB){
        // we succeded
        if(m_fLoadPalette){

		    CreateDIBPalette();
        }/* end of if statement */

        LPSTR pDIB = (LPSTR)::GlobalLock(m_hDIB);
		m_rc.left = 0;
		m_rc.top = 0;
		m_rc.right = DIBWidth(pDIB);
		m_rc.bottom = DIBHeight(pDIB);
        ::GlobalUnlock((HGLOBAL)m_hDIB);
    }
    else {

        hr = E_FAIL; // failed to load this DIB
	}/* end of if statement */
    
    return hr;
}

 /*************************************************************************
 *
 * DIBWidth()
 *
 * Parameter:
 *
 * LPSTR lpbi       - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * DWORD            - width of the DIB
 *
 * Description:
 *
 * This function gets the width of the DIB from the BITMAPINFOHEADER
 * width field if it is a Windows 3.0-style DIB or from the BITMAPCOREHEADER
 * width field if it is an other-style DIB.
 *
 ************************************************************************/

DWORD WINAPI DIBWidth(LPSTR lpDIB)
{
	LPBITMAPINFOHEADER lpbmi;  // pointer to a Win 3.0-style DIB
	LPBITMAPCOREHEADER lpbmc;  // pointer to an other-style DIB

	/* point to the header (whether Win 3.0 and old) */

	lpbmi = (LPBITMAPINFOHEADER)lpDIB;
	lpbmc = (LPBITMAPCOREHEADER)lpDIB;

	/* return the DIB width if it is a Win 3.0 DIB */
	if (IS_WIN30_DIB(lpDIB))
		return lpbmi->biWidth;
	else  /* it is an other-style DIB, so return its width */
		return (DWORD)lpbmc->bcWidth;
}

/*************************************************************************
 *
 * DIBHeight()
 *
 * Parameter:
 *
 * LPSTR lpbi       - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * DWORD            - height of the DIB
 *
 * Description:
 *
 * This function gets the height of the DIB from the BITMAPINFOHEADER
 * height field if it is a Windows 3.0-style DIB or from the BITMAPCOREHEADER
 * height field if it is an other-style DIB.
 *
 ************************************************************************/
DWORD WINAPI DIBHeight(LPSTR lpDIB)
{
	LPBITMAPINFOHEADER lpbmi;  // pointer to a Win 3.0-style DIB
	LPBITMAPCOREHEADER lpbmc;  // pointer to an other-style DIB

	/* point to the header (whether old or Win 3.0 */

	lpbmi = (LPBITMAPINFOHEADER)lpDIB;
	lpbmc = (LPBITMAPCOREHEADER)lpDIB;

	/* return the DIB height if it is a Win 3.0 DIB */
	if (IS_WIN30_DIB(lpDIB))
		return lpbmi->biHeight;
	else  /* it is an other-style DIB, so return its height */
		return (DWORD)lpbmc->bcHeight;
}

DWORD WINAPI DIBSize(LPSTR lpDIB)
{
	LPBITMAPINFOHEADER lpbmi;  // pointer to a Win 3.0-style DIB
	LPBITMAPCOREHEADER lpbmc;  // pointer to an other-style DIB

	/* point to the header (whether Win 3.0 and old) */

	lpbmi = (LPBITMAPINFOHEADER)lpDIB;
	lpbmc = (LPBITMAPCOREHEADER)lpDIB;

	/* return the DIB width if it is a Win 3.0 DIB */
	if (IS_WIN30_DIB(lpDIB))
		return lpbmi->biBitCount*DIBWidth(lpDIB)*DIBHeight(lpDIB);
	else  /* it is an other-style DIB, so return its width */
		return (DWORD)lpbmc->bcWidth*DIBWidth(lpDIB)*DIBHeight(lpDIB);
}

/*************************************************************************
 *
 * PaletteSize()
 *
 * Parameter:
 *
 * LPSTR lpbi       - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * WORD             - size of the color palette of the DIB
 *
 * Description:
 *
 * This function gets the size required to store the DIB's palette by
 * multiplying the number of colors by the size of an RGBQUAD (for a
 * Windows 3.0-style DIB) or by the size of an RGBTRIPLE (for an other-
 * style DIB).
 *
 ************************************************************************/
WORD WINAPI CBitmap::PaletteSize(LPSTR lpbi)
{
   /* calculate the size required by the palette */
   if (IS_WIN30_DIB (lpbi))
	  return (WORD)(DIBNumColors(lpbi) * sizeof(RGBQUAD));
   else
	  return (WORD)(DIBNumColors(lpbi) * sizeof(RGBTRIPLE));
}

/*************************************************************************
 *
 * DIBNumColors()
 *
 * Parameter:
 *
 * LPSTR lpbi       - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * WORD             - number of colors in the color table
 *
 * Description:
 *
 * This function calculates the number of colors in the DIB's color table
 * by finding the bits per pixel for the DIB (whether Win3.0 or other-style
 * DIB). If bits per pixel is 1: colors=2, if 4: colors=16, if 8: colors=256,
 * if 24, no colors in color table.
 *
 ************************************************************************/
WORD WINAPI CBitmap::DIBNumColors(LPSTR lpbi)
{
	WORD wBitCount;  // DIB bit count

	/*  If this is a Windows-style DIB, the number of colors in the
	 *  color table can be less than the number of bits per pixel
	 *  allows for (i.e. lpbi->biClrUsed can be set to some value).
	 *  If this is the case, return the appropriate value.
	 */

	if (IS_WIN30_DIB(lpbi))
	{
		DWORD dwClrUsed;

		dwClrUsed = ((LPBITMAPINFOHEADER)lpbi)->biClrUsed;
		if (dwClrUsed != 0)
			return (WORD)dwClrUsed;
	}

	/*  Calculate the number of colors in the color table based on
	 *  the number of bits per pixel for the DIB.
	 */
	if (IS_WIN30_DIB(lpbi))
		wBitCount = ((LPBITMAPINFOHEADER)lpbi)->biBitCount;
	else
		wBitCount = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;

	/* return number of colors based on bits per pixel */
	switch (wBitCount)
	{
		case 1:
			return 2;

		case 4:
			return 16;

		case 8:
			return 256;

		default:
			return 0;
	}
}

/*************************************************************************/
/* Function: PutImage                                                    */
/* Description: Reads the DIB file (from file or resource) into a DIB,   */
/* updates palette and rects of the internal bitmap.                     */
/*************************************************************************/
HRESULT CBitmap::PutImage(BSTR strFilename, HINSTANCE hRes, IUnknown* pUnk, bool fGrayOut, TransparentBlitType blitType){

	USES_CONVERSION;
    HRESULT hr = S_OK;

    TCHAR strBuffer[MAX_PATH] = TEXT("\0");

    if(NULL == hRes){
        // do not bother to resolve files if loading from resources
        // use this API to resolve http:/ file:/ html:/
        hr = ::URLDownloadToCacheFile(pUnk, OLE2T(strFilename), strBuffer, MAX_PATH, 0, NULL);

        if(FAILED(hr)){
#if _DEBUG
            TCHAR strTmpBuffer[MAX_PATH + 25];
            wsprintf(strTmpBuffer, TEXT("Failed to download %s, if it is a local file it might not exist"), OLE2T(strFilename));
            ::MessageBox(::GetFocus(), strTmpBuffer, TEXT("Error"), MB_OK);
#endif
            return(hr);
        }/* end of if statement */

        ATLTRACE(TEXT("Loading new button image %s \n"), strBuffer);
    }/* end of if statement */

    if (lstrlen(strBuffer) == 0){

	    hr = SetImage(OLE2T(strFilename), hRes);
    }
    else {

	    hr = SetImage(strBuffer, hRes);
    }/* end of if statement */

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */
	
    // we succeded
    if(m_fLoadPalette){

	    CreateDIBPalette();
    }/* end of if statement */
    
    if (fGrayOut) {
        ConvertDIBGray(blitType);
        ConvertColorTableGray();
    }/* end of if statement */
    

    return(hr);
}/* end of function PutImage */

//----------------------------------------------------------------------------
// CWMPBitmap::GetRegion
//
// Purpose:
//   This method will create a region based on each transparent color found
//   within the bitmap.
// Parameters:
//   phRgn - pointer to the return of a region created from the bitmap
//   crTransparentColor - RGB based COLORREF of the color that is considered 
//                        transparent
//   fInvert - Set to TRUE, to invert the region created based on the transparent 
//             color
// Returns:
//   HRESULT
//
//----------------------------------------------------------------------------
#pragma optimize( "t", on )
HRESULT CBitmap::GetRegion(HDC hDC, HRGN *phRgn, RECT* pRect, COLORREF crTransparentColor, bool fInvert/*=FALSE*/) const
{

    //DASSERTMSG(NULL != m_hBMP, "CWMPBitmap::GetRegion(), no bitmap has been created yet. Call a create method first.");
    //DASSERTMSG(OBJ_BITMAP == ::GetObjectType(m_hBMP), "CWMPBitmap::GetRegion(), m_hBMP is invalid");
    //DASSERTMSG(NULL != phRgn, "CWMPBitmap::GetRegion(), parameter phRgn is invalid");
    //DASSERTMSG(0 == (crTransparentColor&0xFF000000), "CWMPBitmap::GetRegion(), crTransparentColor must be RGB values");

    *phRgn = NULL;

    //if (NULL == m_hBMP)    // no bitmap has been created yet
        //return E_WMP_BMP_BITMAP_NOT_CREATED;

    HRESULT hr = S_OK;
    const COLORREF kcrTolerance = RGB(0,0,0);


    // For better performances, we will use the ExtCreateRegion() function to create the
    // region. This function take a RGNDATA structure on entry. 

    const int knMaxRect = 2000;   // do not make bigger then 2000, see below


    // alloc the rects on the stack 2000*sizeof(rect) = 32k

    RGNDATA *pData = reinterpret_cast<RGNDATA*>(_alloca(sizeof(RGNDATAHEADER) + (sizeof(RECT) * knMaxRect)));

    pData->rdh.dwSize = sizeof(RGNDATAHEADER);
    pData->rdh.iType = RDH_RECTANGLES;
    pData->rdh.nCount = 0;
    pData->rdh.nRgnSize = 0;
    SetRect(&pData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);


    // precompute highest and lowest values for the "transparent" pixels

    BYTE ubLowRed = (BYTE)__max(0, GetRValue(crTransparentColor) - GetRValue(kcrTolerance));
    BYTE ubLowGreen = (BYTE)__max(0, GetGValue(crTransparentColor) - GetGValue(kcrTolerance));
    BYTE ubLowBlue = (BYTE)__max(0, GetBValue(crTransparentColor) - GetBValue(kcrTolerance));

    BYTE ubHighRed = (BYTE)__min(0xFF, GetRValue(crTransparentColor) + GetRValue(kcrTolerance));
    BYTE ubHighGreen = (BYTE)__min(0xFF, GetGValue(crTransparentColor) + GetGValue(kcrTolerance));
    BYTE ubHighBlue = (BYTE)__min(0xFF, GetBValue(crTransparentColor) + GetBValue(kcrTolerance));


    // scan the bitmap from top to bottom

    for (int y = 0; y < RECTHEIGHT(pRect); y++)
    {
        // scan each bitmap pixel from left to right

        for (int x = 0; x < RECTWIDTH(pRect); x++)
        {

            // search for a continuous range of "non transparent pixels"

            int nStartX = x;
            while (x < RECTWIDTH(pRect))
            {

                COLORREF crPixel = ::GetPixel(hDC, x, y);

                BYTE ubRed = GetRValue(crPixel);
                if (ubRed >= ubLowRed && ubRed <= ubHighRed)
                {
                    BYTE ubGreen = GetGValue(crPixel);
                    if (ubGreen >= ubLowGreen && ubGreen <= ubHighGreen)
                    {
                        BYTE ubBlue = GetBValue(crPixel);
                        if (ubBlue >= ubLowBlue && ubBlue <= ubHighBlue)
                            break;    // This pixel is "transparent"
                    }
                }

                x++;  // next horz. pixel
            }


            if (x > nStartX)
            {
                // add the pixels (nStartX, y) to (x, y+1) as a new rectangle in the region

                RECT *pr = reinterpret_cast<RECT*>(&pData->Buffer);
                SetRect(&pr[pData->rdh.nCount], nStartX, y, x, y+1);
                
                if (nStartX < pData->rdh.rcBound.left)
                    pData->rdh.rcBound.left = nStartX;

                if (y < pData->rdh.rcBound.top)
                    pData->rdh.rcBound.top = y;

                if (x > pData->rdh.rcBound.right)
                    pData->rdh.rcBound.right = x;

                if (y+1 > pData->rdh.rcBound.bottom)
                    pData->rdh.rcBound.bottom = y+1;


                // ericwol: warning to optimization people. NT4.0 is very buggy creating regions out of rects!!!
                // test any changes you make here!!!

                pData->rdh.nCount++;


                // on Windows98, ExtCreateRegion() may fail if the number of rectangles is too
                // large (ie: > 4000). Therefore, we have to create the region by multiple steps.

                if (pData->rdh.nCount == knMaxRect)
                {
                    HRGN hrgnNew = ::ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * pData->rdh.nCount), pData);
                    //HRWIN32(hr, NULL == hrgnNew, "ExtCreateRegion");

                    if (NULL != hrgnNew) 
                    {
                        // if we already have a region from a previous pass,
                        // combine the new region with the old region

                        if (*phRgn)
                        {
                            ::CombineRgn(*phRgn, *phRgn, hrgnNew, RGN_OR);
                            ::DeleteObject(hrgnNew);
                        }
                        else
                        {
                            *phRgn = hrgnNew;
                        }
                    }


                    // reset the rect count for another pass

                    pData->rdh.nCount = 0;
                    SetRect(&pData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);
                }
            }


        }  // x loop

    }  // y loop



    // create or extend the region with the remaining rectangles from the final pass

    HRGN hrgnNew = ::ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * pData->rdh.nCount), pData);
    //HRWIN32(hr, NULL == hrgnNew, "ExtCreateRegion");

    if (NULL != hrgnNew) 
    {

        // if we already have a region from a previous pass,
        // combine the new region with the old region

        if (*phRgn)
        {
            ::CombineRgn(*phRgn, *phRgn, hrgnNew, RGN_OR);
            ::DeleteObject(hrgnNew);
        }
        else
        {
            *phRgn = hrgnNew;
        }
    }


    // does the user want the a region inverted based on the transparent color

    if (SUCCEEDED(hr) && true == fInvert)
    {

        HRGN hRgnInverted = NULL;
        RECT rc = { 0, 0, RECTWIDTH(pRect), RECTHEIGHT(pRect) };

        hr = XORRegion( &hRgnInverted, *phRgn, rc);
        //DPF_HR( A, hr, "XORRegion" );

        if (SUCCEEDED(hr))
        {
            ::DeleteObject(*phRgn);
            *phRgn = hRgnInverted;
        }
    }

    return hr;
}
#pragma optimize( "", on )




//----------------------------------------------------------------------------
// CWMPBitmap::XORRegion
//
// Purpose:
//   This parivate method will invert a given region.
// Parameters:
//   phRgn - pointer to the return of the inverted region 
//   hRgn - the region to invert
//   rc - max outside dimensions of the inverted region
// Returns:
//   HRESULT
//
//----------------------------------------------------------------------------

HRESULT CBitmap::XORRegion(HRGN *phRgn, HRGN hRgn, const RECT &rc) const
{
    //DASSERTMSG(NULL != phRgn, "CWMPBitmap::XORRegion(), 'phRgn' parameteris invalid");
    //DASSERTMSG(NULL != hRgn, "CWMPBitmap::XORRegion(), 'hRgn' parameter is inavlid");
    //DASSERTMSG(OBJ_REGION == ::GetObjectType(hRgn), "CWMPBitmap::XORRegion(), 'hRgn' parameter is inavlid");


    HRESULT hr = S_OK;

    // create the region based on the destination rect

    HRGN hRgnTemp = ::CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);
    //HRWIN32ERR(hr, NULL == hRgnTemp, "CreateRectRgn");

    if (SUCCEEDED(hr))
    {
        
        // create a region to invert into

        HRGN hRgnResult = ::CreateRectRgn(0, 0, 0, 0);
        //HRWIN32ERR(hr, NULL == hRgnResult, "CreateRectRgn");

        if (SUCCEEDED(hr))
        {
            // invert the passed region into hRgnResult

            int nResult = ::CombineRgn(hRgnResult, hRgn, hRgnTemp, RGN_XOR);
            //HRWIN32ERR(hr, ERROR == nResult, "CreateRectRgn");
            
            if (SUCCEEDED(hr))
            {
                *phRgn = hRgnResult;    // success, return the inverted region
            }
            else
            {
                ::DeleteObject(hRgnResult);
            }
        }

        ::DeleteObject(hRgnTemp);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//// Clipboard support

//---------------------------------------------------------------------
//
// Function:   CopyHandle (from SDK DibView sample clipbrd.c)
//
// Purpose:    Makes a copy of the given global memory block.  Returns
//             a handle to the new memory block (NULL on error).
//
//             Routine stolen verbatim out of ShowDIB.
//
// Parms:      h == Handle to global memory to duplicate.
//
// Returns:    Handle to new global memory block.
//
//---------------------------------------------------------------------
HGLOBAL WINAPI CopyHandle (HGLOBAL h)
{
	if (h == NULL)
		return NULL;

	DWORD dwLen = ::GlobalSize((HGLOBAL) h);
	HGLOBAL hCopy = ::GlobalAlloc(GHND, dwLen);

	if (hCopy != NULL)
	{
		void* lpCopy = ::GlobalLock((HGLOBAL) hCopy);
		void* lp     = ::GlobalLock((HGLOBAL) h);
		memcpy(lpCopy, lp, dwLen);
		::GlobalUnlock(hCopy);
		::GlobalUnlock(h);
	}

	return hCopy;
}

BYTE RGBtoL(BYTE R, BYTE G, BYTE B) {
    /* calculate lightness */
    BYTE cMax = max( max(R,G), B);
    BYTE cMin = min( min(R,G), B);
    BYTE L = (BYTE) (( cMax + cMin + 1 )/2);
    return L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\ccobj.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CCObj.h                                                         */
/* Description: Contains holder for container objects.                   */
/*************************************************************************/
#ifndef __CCOBJ_H
#define __CCOBJ_H

//#include "BBtn.h"
#include "chobj.h"
/*************************************************************************/
/* Class: CContainerObject                                               */
/* Description: Object that contains container. This is a simple wrapper */
/* inorder to have really just one cobtainer site, but at the same time  */
/* support the windowless activation. We pass in this object instead of  */
/* the real site, so we can track which windowless object has focus and  */
/* or capture.                                                           */
/*************************************************************************/
class CContainerObject:	
// ####  BEGIN CONTAINER SUPPORT ####
    public IOleClientSite,    
    //public IOleInPlaceFrame,
    //public IOleControlSite,
    public IOleInPlaceSiteWindowless,
    public IOleContainer,
//    public IMFOleInPlaceSiteWindowless,
    public IObjectWithSite,
    public IPropertyBag
// ####  END CONTAINER SUPPORT ####
{
    protected:
        
        CContainerObject(){Init();};
    public:
        virtual ~CContainerObject(){ATLTRACE(TEXT("In the CContainerObject object destructor \n")); ;};
        CContainerObject(IUnknown* pUnknown, CHostedObject* pObj);
    
        STDMETHOD(QueryInterface)(const IID& iid, void**ppv);
        STDMETHOD_(ULONG,AddRef)( void);
        STDMETHOD_(ULONG,Release)( void);

        // needed to initialize this object
        HRESULT SetObjects(IUnknown* pUnknown, CHostedObject* pObj);
        HRESULT InvalidateObjectRect();

        // IOleClientSite
        STDMETHOD(SaveObject)(){ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));}
        STDMETHOD(GetMoniker)(DWORD /*dwAssign*/, DWORD /*dwWhichMoniker*/, IMoniker** /*ppmk*/){ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));}
        STDMETHOD(GetContainer)(IOleContainer** ppContainer);
        STDMETHOD(ShowObject)();	        
        STDMETHOD(OnShowWindow)(BOOL fShow);
        STDMETHOD(RequestNewObjectLayout)(){ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));}        
        // IOleWindow
        STDMETHOD(GetWindow)(HWND *phwnd);
        STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);
        //IOleInPlaceSite
        STDMETHOD(CanInPlaceActivate)();
        STDMETHOD(OnUIActivate)();
        STDMETHOD(OnInPlaceActivate)();
        STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo);
        STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
	    STDMETHOD(OnInPlaceDeactivate)();
    	STDMETHOD(DiscardUndoState)();
	    STDMETHOD(DeactivateAndUndo)();
	    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);	
        STDMETHOD(Scroll)(SIZE scrollExtant);
        //IOleInPlaceSiteEx
	    STDMETHOD(OnInPlaceActivateEx)(BOOL* pfNoRedraw, DWORD dwFlags);
	    STDMETHOD(OnInPlaceDeactivateEx)(BOOL fNoRedraw);
	    STDMETHOD(RequestUIActivate)();
        STDMETHOD(CanWindowlessActivate)();
	    STDMETHOD(GetCapture)();
	    STDMETHOD(SetCapture)(BOOL fCapture);
	    STDMETHOD(GetFocus)();
	    STDMETHOD(SetFocus)(BOOL fFocus);
	    STDMETHOD(GetDC)(LPCRECT /*pRect*/, DWORD /*grfFlags*/, HDC* phDC);
	    STDMETHOD(ReleaseDC)(HDC hDC);
	    STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase);
	    STDMETHOD(InvalidateRgn)(HRGN hRGN = NULL, BOOL fErase = FALSE);	
	    STDMETHOD(ScrollRect)(INT /*dx*/, INT /*dy*/, LPCRECT /*pRectScroll*/, LPCRECT /*pRectClip*/);
	    STDMETHOD(AdjustRect)(LPRECT /*prc*/);
	    STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
        // IMFOleInPlaceSiteWindowless
	    STDMETHOD(SetHostedObject)(LONG lVoid);
        // IOleContainer
        STDMETHOD(ParseDisplayName)(IBindCtx* /*pbc*/, LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/);
	    STDMETHOD(EnumObjects)(DWORD /*grfFlags*/, IEnumUnknown** ppenum);
	    STDMETHOD(LockContainer)(BOOL fLock);
	    //IObjectWithSite
        STDMETHOD(SetSite)(IUnknown *pUnkSite){ATLTRACENOTIMPL(_T("IObjectWithSite::SetSite"));}
        STDMETHOD(GetSite)(REFIID riid, void  **ppvSite);
        //IPropertyBag
        STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog* pErrorLog);
        STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT* pVar){ATLTRACENOTIMPL(_T("IPropertyBag::Write"));}        
    protected: // helper functions
        void Init();
        inline HRESULT GetWindowlessSite(CComPtr<IOleInPlaceSiteWindowless>& pSite);
        inline HRESULT GetContainer(CComPtr<IOleContainer>& pContainer);
        HRESULT ParsePropertyBag(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog*  pErrorLog);

    private: // private member variables
        CHostedObject* m_pObj; // object which we are hosting
        CComPtr<IUnknown> m_pUnkContainer; // pointer to our container
        CComPtr<IOleInPlaceFrame> m_spInPlaceFrame; // cached up pointer
        CComPtr<IOleInPlaceUIWindow> m_spInPlaceUIWindow; // cached up pointer
        long m_lRefCount;
        unsigned long m_bLocked:1;
};/* end of class CContainerObject */

#endif // end of __CCOBJ_H
/*************************************************************************/
/* End of file: CCObj.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\ctext.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ctext.h                                                         */
/* Description: header file for class CText.                             */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/

#ifndef __CTEXT_H_
#define __CTEXT_H_

// font style flags for internal use

#define FS_NORMAL     0x00
#define FS_BOLD       0x01
#define FS_ITALIC     0x02
#define FS_UNDERLINE  0x04
#define FS_STRIKEOUT  0x08

class CText
{
public:
    CText();
    ~CText();
    void SetTextAlignment(BSTR pwszAlignment);
    void SetTextColor(COLORREF clrColor);
	void SetFontStyle(BSTR pwszFontStyle);
	void SetFontFace(BSTR pwszFontFace);
    void SetFontSize(long lSize);
    void SetFixedSizeFont(bool fFixed);

    HRESULT RealizeFont(HDC hdc);
    HRESULT Write(HDC hdc, const RECT & rc, const WCHAR * pwszText);
    HRESULT GetTextWidth(HDC hdc, const WCHAR * pwszText, SIZE *pSize);

private:    
    HFONT       m_hFont;
    bool        m_fDirty; //true when we need to recalc font and bounding rect
    UINT        m_uiState;
    CComBSTR    m_bstrFontFace;
    CComBSTR    m_bstrFontStyle;
    UINT        m_uiFontSize;
    UINT        m_uiAlignment;
    COLORREF    m_clrTextColor;
    BYTE        m_fFontStyleFlags;
    bool        m_fFixedSizeFont;
};

#endif //__CTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\eobj.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: EObj.h                                                          */
/* Description: Declaration of CEventObject, which is used to hold event */
/* descriptions.                                                         */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __EOBJ_H
#define __EOBJ_H

/*************************************************************************/
/* Class: CEventObject                                                   */
/* Description: Object that contains the events.                         */
/*************************************************************************/
class CEventObject{
public: 
    CEventObject(BSTR strObjectID, BSTR strEvent, BSTR strEventCode) :
    m_strObjectID(strObjectID), 
    m_strEvent(strEvent), 
    m_strEventCode(strEventCode){}
    
    CComBSTR m_strObjectID; 
    CComBSTR m_strEvent;
    CComBSTR m_strEventCode;
}; /* end of class CEventObject */

#endif //__EOBJ_H
/*************************************************************************/
/* End of file: EObj.h                                                   */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\cstutils.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: CstUtils.h                                                      */
/* Description: Utilities that we can share across mutliple modules.     */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFCSTUTILS_H_
#define __MSMFCSTUTILS_H_

#ifdef _WMP
#include "wmp.h" // for wmp integration
#endif

const bool gcfGrayOut = false;

#define WM_USER_FOCUS (WM_USER + 0x10)

#define USE_MF_OVERWRITES \
HRESULT InvalidateRgn(bool fErase = false){return MFInvalidateRgn(fErase);} \
HRESULT FireViewChange(){return MFFireViewChange();} \
HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect){return MFInPlaceActivate(iVerb, prcPosRect);} \
HRESULT SetCapture(bool bCapture){return MFSetCapture(bCapture);} \
HRESULT SetFocus(bool bFocus){return MFSetFocus(bFocus);} \
HWND    GetWindow(){return MFGetWindow();} \
HRESULT ForwardWindowMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LONG& lRes,\
         bool fForwardInWndls = false){return MFForwardWindowMessage(uMsg, wParam, lParam, lRes, \
                                        fForwardInWndls);}


#define USE_MF_RESOURCEDLL \
STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal){return get_MFResourceDLL(pVal);} \
STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal){return put_MFResourceDLL(newVal);}

#define USE_MF_WINDOWLESS_ACTIVATION \
STDMETHOD(get_Windowless)(VARIANT_BOOL *pVal){return get_MFWindowless(pVal);} \
STDMETHOD(put_Windowless)(VARIANT_BOOL newVal){return put_MFWindowless(newVal);}

#define USE_MF_TRANSPARENT_FLAG \
STDMETHOD(get_TransparentBlit)(TransparentBlitType *pVal){return  get_MFTransparentBlit(pVal);}\
STDMETHOD(put_TransparentBlit)(TransparentBlitType newVal){return put_MFTransparentBlit(newVal);}

#define USE_MF_CLASSSTYLE \
static CWndClassInfo& GetWndClassInfo(){ \
    static HBRUSH wcBrush = ::CreateSolidBrush(RGB(0,0,0)); \
	    static CWndClassInfo wc = {{ sizeof(WNDCLASSEX), 0 /*CS_OWNDC*/, StartWindowProc, \
		      0, 0, NULL, NULL, NULL,  wcBrush /* (HBRUSH)(COLOR_WINDOW + 1) */, \
              NULL, TEXT("MSMFCtlClass"), NULL }, \
		    NULL, NULL, IDC_ARROW, TRUE, 0, _T("") }; \
	    return wc; \
    }/* end of function GetWndClassInfo */

/*************************************************************************/
/* Defines                                                               */
/* Could not find these under windows headers, so if there is a conflict */
/* it is good idea to ifdef these out.                                   */
/*************************************************************************/
#define GET_X_LPARAM(lp)   ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)   ((int)(short)HIWORD(lp))

	
template <class T>
class ATL_NO_VTABLE CMSMFCntrlUtils{

/*************************************************************************/
/* PUBLIC MEMBER FUNCTIONS                                               */
/*************************************************************************/
public:

/*************************************************************************/
/* Function: CMSMFCntrlUtils                                             */
/*************************************************************************/
CMSMFCntrlUtils(){

    m_hRes = NULL;
    m_blitType = TRANSPARENT_TOP_LEFT; // DISABLE used to be the correct default TODO
    m_fNoFocusGrab = true; // to enable standalone "windowed" focus handeling please
                           // make this flag a property
}/* end of function CMSMFCntrlUtils */

/*************************************************************************/
/* Function: ~CMSMFCntrlUtils                                            */
/*************************************************************************/
virtual ~CMSMFCntrlUtils(){

    if(NULL != m_hRes){

        ::FreeLibrary(m_hRes); // unload our resource library
    }/* end of if statement */

    m_hRes = NULL;
}/* end of function ~CMSMFCntrlUtils */

/*************************************************************************/
/* Message Map                                                           */
/*************************************************************************/  
typedef CMSMFCntrlUtils< T >	thisClass;

BEGIN_MSG_MAP(thisClass)
	MESSAGE_HANDLER(WM_ERASEBKGND, CMSMFCntrlUtils::MFOnErase)		
END_MSG_MAP()

/*************************************************************************/  
/* Function: MFOnErase                                                   */
/* Description: Avoids erasing backround to avoid flashing.              */
/*************************************************************************/  
LRESULT MFOnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
	return 0;
}/* end of function MFOnErase */

/*************************************************************************/
/* Function: get_MFResourceDLL                                           */
/* Description: Returns the string of the loaded resource DLL.           */
/*************************************************************************/
STDMETHOD(get_MFResourceDLL)(BSTR *pVal){

    *pVal = m_strResDLL.Copy();
	return S_OK;
}/* end of function get_MFResourceDLL */

/*************************************************************************/
/* Function: put_MFResourceDLL                                           */
/* Description: Loads the resource DLL.                                  */
/*************************************************************************/
STDMETHOD(put_MFResourceDLL)(BSTR strFileName){

	HRESULT hr = LoadResourceDLL(strFileName);

    // see if we loaded it
    if(FAILED(hr)){    

	    return(hr);
    }/* end of if statement */

    // update the cached variable value
    m_strResDLL = strFileName;

    return(hr);
}/* end of function put_MFResourceDLL */

/*************************************************************************/
/* Function: get_MFWindowless                                            */
/* Description: Gets if we we tried to be windowless activated or not.   */
/*************************************************************************/
STDMETHODIMP get_MFWindowless(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {
        T* pT = static_cast<T*>(this);

        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = pT->m_bWindowOnly == FALSE ? VARIANT_FALSE: VARIANT_TRUE; 
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function get_MFWindowless */

/*************************************************************************/
/* Function: put_MFWindowless                                            */
/* Description: This sets the windowless mode, should be set from the    */
/* property bag.                                                         */
/*************************************************************************/
STDMETHODIMP put_MFWindowless(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {
        T* pT = static_cast<T*>(this);

        if(VARIANT_FALSE == newVal){

            pT->m_bWindowOnly = TRUE; 
        }
        else {

            pT->m_bWindowOnly = FALSE; 
        }/* end of if statement */

        // TODO: This function should fail after we inplace activated !!
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function put_MFWindowless */

/*************************************************************************/
/* Function: get_MFTransparentBlit                                       */
/* Description: Gets current state of the transperent blit.              */
/*************************************************************************/
STDMETHODIMP get_MFTransparentBlit(TransparentBlitType *pVal){

    HRESULT hr = S_OK;

    try {
    	T* pT = static_cast<T*>(this);

        *pVal = pT->m_blitType;
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function get_MFTransparentBlit */

/*************************************************************************/
/* Function: put_MFTransparentBlit                                       */
/* Description: Sets the state of the transperent blit.                  */
/*************************************************************************/
STDMETHODIMP put_MFTransparentBlit(TransparentBlitType newVal){

    HRESULT hr = S_OK;

    try {    
        T* pT = static_cast<T*>(this);

        pT->m_blitType = newVal;
    }
     catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function put_MFTransparentBlit */

/*************************************************************************/
/* Function: MFInvalidateRgn                                             */
/* Description: Invalidates the whole rect in case we need to repaint it.*/
/*************************************************************************/
HRESULT MFInvalidateRgn(bool fErase = false){

    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess){

        pT->m_spInPlaceSite->InvalidateRgn(NULL ,fErase ? TRUE: FALSE);
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

		    ::InvalidateRgn(pT->m_hWnd, NULL, fErase ? TRUE: FALSE); // see if we can get by by not erasing..
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function MFInvalidateRgn */

/*************************************************************************/
/* Function: MFFireViewChange                                            */
/* Description: Overloaded base function, which would try to repaint the */
/* whole container. Just like to repaint the control area instead.       */
/*************************************************************************/
inline HRESULT MFFireViewChange(){ // same as FireView change but optimized

    T* pT = static_cast<T*>(this);

	if (pT->m_bInPlaceActive){
		// Active
        if (pT->m_hWndCD != NULL){

			::InvalidateRect(pT->m_hWndCD, NULL, TRUE); // Window based
        }
        else if (pT->m_spInPlaceSite != NULL){

			pT->m_spInPlaceSite->InvalidateRect(&pT->m_rcPos, TRUE); // Do not invalidate the whole container
        }/* end of if statement */
	}
    else {// Inactive
		pT->SendOnViewChange(DVASPECT_CONTENT);
    }/* end of if statement */

	return S_OK;
}/* end of function MFFireViewChange */

/*************************************************************************/
/* Function: MFForwardWindowMessage                                      */
/* Description: Forward the message to the parent window.                */
/*************************************************************************/
HRESULT MFForwardWindowMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LONG& lRes,
                               bool fForwardInWndls = false){

    HRESULT hr = S_OK;
    T* pT = static_cast<T*>(this);
    lRes = 0;

    if(false == fForwardInWndls){

        if(pT->m_bWndLess || (!::IsWindow(pT->m_hWnd))){

            hr = S_FALSE;
            return (hr);
        }/* end of if statement */

    }/*  end of if statement */

    HWND hwnd = NULL;

    hr = GetParentHWND(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    lRes = ::SendMessage(hwnd, uMsg, wParam, lParam);

    return(hr);
}/* end of function MFForwardWindowMessage */

/*************************************************************************/
/* Function: InPlaceActivate                                             */
/* Description: Modified InPlaceActivate so WMP can startup.             */
/*************************************************************************/
HRESULT MFInPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/){

    HRESULT hr;
    T* pT = static_cast<T*>(this);

    if (pT->m_spClientSite == NULL){

        return S_OK;
    }/* end of if statement */

    CComPtr<IOleInPlaceObject> pIPO;
    pT->ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
    ATLASSERT(pIPO != NULL);

    if (!pT->m_bNegotiatedWnd){

        if (!pT->m_bWindowOnly)
            // Try for windowless site
            hr = pT->m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&pT->m_spInPlaceSite);

        if (pT->m_spInPlaceSite){

            pT->m_bInPlaceSiteEx = TRUE;
            // CanWindowlessActivate returns S_OK or S_FALSE
            if ( pT->m_spInPlaceSite->CanWindowlessActivate() == S_OK ){

                pT->m_bWndLess = TRUE;
                pT->m_bWasOnceWindowless = TRUE;
            }
            else
            {
                pT->m_bWndLess = FALSE;
            }/* end of if statement */
        }
        else {
            pT->m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pT->m_spInPlaceSite);
            if (pT->m_spInPlaceSite)
                pT->m_bInPlaceSiteEx = TRUE;
            else
                hr = pT->m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&pT->m_spInPlaceSite);
        }/* end of if statement */
    }/* end of if statement */

    ATLASSERT(pT->m_spInPlaceSite);
    if (!pT->m_spInPlaceSite)
        return E_FAIL;

    pT->m_bNegotiatedWnd = TRUE;

    if (!pT->m_bInPlaceActive){

        BOOL bNoRedraw = FALSE;
        if (pT->m_bWndLess)
            pT->m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
        else {

            if (pT->m_bInPlaceSiteEx)
                pT->m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
            else {
                hr = pT->m_spInPlaceSite->CanInPlaceActivate();
                // CanInPlaceActivate returns S_FALSE or S_OK
                if (FAILED(hr))
                    return hr;
                if ( hr != S_OK )
                {
                   // CanInPlaceActivate returned S_FALSE.
                   return( E_FAIL );
                }
                pT->m_spInPlaceSite->OnInPlaceActivate();
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    pT->m_bInPlaceActive = TRUE;

    // get location in the parent window,
    // as well as some information about the parent
    //
    OLEINPLACEFRAMEINFO frameInfo;
    RECT rcPos, rcClip;
    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    HWND hwndParent;

    // DJ - GetParentHWND per MNnovak

    if (SUCCEEDED( GetParentHWND(&hwndParent) )){

        pT->m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
            &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

        if (!pT->m_bWndLess){

            if (pT->m_hWndCD){

                ::ShowWindow(pT->m_hWndCD, SW_SHOW);
                if (!::IsChild(pT->m_hWndCD, ::GetFocus()))
                    ::SetFocus(pT->m_hWndCD);
            }
            else{

                HWND h = pT->CreateControlWindow(hwndParent, rcPos);
                ATLASSERT(h != NULL);   // will assert if creation failed
                ATLASSERT(h == pT->m_hWndCD);
                h;  // avoid unused warning
            }/* end of if statement */
        }/* end of if statement */

        pIPO->SetObjectRects(&rcPos, &rcClip);
    }/* end of if statement */

    CComPtr<IOleInPlaceActiveObject> spActiveObject;
    pT->ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

    // Gone active by now, take care of UIACTIVATE
    if (pT->DoesVerbUIActivate(iVerb)){

        if (!pT->m_bUIActive){

            pT->m_bUIActive = TRUE;
            hr = pT->m_spInPlaceSite->OnUIActivate();
            if (FAILED(hr))
                return hr;

            pT->SetControlFocus(TRUE);
            // set ourselves up in the host.
            //
            if (spActiveObject)
            {
                if (spInPlaceFrame)
                    spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
                if (spInPlaceUIWindow)
                    spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
            }

            if (spInPlaceFrame)
                spInPlaceFrame->SetBorderSpace(NULL);
            if (spInPlaceUIWindow)
                spInPlaceUIWindow->SetBorderSpace(NULL);
        }/* end of if statement */
    }/* end of if statement */

    pT->m_spClientSite->ShowObject();

    return S_OK;
}/* end of function MFInPlaceActivate */

/*************************************************************************/
/* PROTECTED MEMBER FUNCTIONS                                            */
/*************************************************************************/
protected:

/*************************************************************************/
/* Function: MFGetWindow                                                 */
/* Description:  Gets the window. If we are windowless we pass           */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HWND MFGetWindow(){

  HWND hwnd = NULL;

  T* pT = static_cast<T*>(this);

  if(pT->m_bWndLess){

      GetParentHWND(&hwnd);
      return(hwnd);
  }/* end of if statement */

  //ATLASSERT(::IsWindow(m_hWnd));
  return pT->m_hWnd;
}/* end of function MFGetWindow */

/*************************************************************************/
/* Function: GetParentHWND                                               */
/* Description: Gets the parent window HWND where we are operating.      */
/*************************************************************************/
HRESULT GetParentHWND(HWND* pWnd){

    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);

    IOleClientSite *pClientSite;
    IOleContainer *pContainer;
    IOleObject *pObject;

    hr = pT->GetClientSite(&pClientSite);

    if(FAILED(hr)){

		return(hr);	
    }/* end of if statement */

    IOleWindow *pOleWindow;
    
    do {
        hr = pClientSite->QueryInterface(IID_IOleWindow, (LPVOID *) &pOleWindow);
        
        if(FAILED(hr)){
            
            return(hr);	
        }/* end of if statement */
        
        hr = pOleWindow->GetWindow(pWnd);
        
        pOleWindow->Release();

        // if pClientSite is windowless, go get its container
        if (FAILED(hr)) {
            HRESULT hrTemp = pClientSite->GetContainer(&pContainer);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            pClientSite->Release();
            
            hrTemp = pContainer->QueryInterface(IID_IOleObject, (LPVOID*)&pObject);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            pContainer->Release();
            
            hrTemp = pObject->GetClientSite(&pClientSite);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
        }
    } while (FAILED(hr));

    pClientSite->Release();
    return(hr);
}/* end of function GetParentHWND */

/*************************************************************************/
/* Function: GetCapture                                                  */
/* Description: Gets the capture state. S_FALSE no capture S_OK has      */
/* capture.                                                              */
/*************************************************************************/
HRESULT GetCapture(){

    HRESULT hr = E_UNEXPECTED;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess){

        hr = pT->m_spInPlaceSite->GetCapture();
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            HWND h = ::GetCapture();

            if(pT->m_hWnd == h){

                hr = S_OK;
            }
            else {

                hr = S_FALSE;
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function GetCapture */

/*************************************************************************/
/* Function: GetFocus                                                    */
/* Description: Gets the focus state. S_FALSE no capture S_OK has        */
/* a focus.                                                              */
/*************************************************************************/
HRESULT GetFocus(){

    HRESULT hr = E_UNEXPECTED;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess || m_fNoFocusGrab){

        hr = pT->m_spInPlaceSite->GetFocus();
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            HWND h = ::GetFocus();

            if(pT->m_hWnd == h){

                hr = S_OK;
            }
            else {

                hr = S_FALSE;
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function GetFocus */

/*************************************************************************/
/* Function: MFSetFocus                                                  */
/* Description: Sets the focus for the keyboard.                         */
/*************************************************************************/
HRESULT MFSetFocus(bool fFocus){
    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);

    if(pT->m_bWndLess || m_fNoFocusGrab){

        pT->m_spInPlaceSite->SetFocus(fFocus ? TRUE: FALSE);
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            if(fFocus){

		        ::SetFocus(pT->m_hWnd);
            }
            else {
                    
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function MFSetFocus */

/*************************************************************************/
/* Function: MFSetCapture                                                  */
/* Description: Sets the capture for the mouse.                          */
/*************************************************************************/
HRESULT MFSetCapture(bool bCapture){
    HRESULT hr = S_OK;

    T* pT = static_cast<T*>(this);
#ifdef _DEBUG
    if(bCapture){

        ATLTRACE("SETTING mouse capture! \n");
    }
    else {

        ATLTRACE("RELEASING mouse capture! \n");
    }/* end of if statement */

#endif 

    if(pT->m_bWndLess){

        pT->m_spInPlaceSite->SetCapture(bCapture ? TRUE: FALSE);
    }
    else {
        if(NULL == pT->m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(pT->m_hWnd)){

            if(bCapture){

		        ::SetCapture(pT->m_hWnd);
            }
            else {
                    // note this might case problems if multiple ActiveX controls
                    // in the container have a capture
                    ::ReleaseCapture();                
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function MFSetCapture */

/*************************************************************************/
/* Function: LoadResourceDLL                                             */
/* Description: The path is relative to this module exe                  */
/*************************************************************************/
HRESULT LoadResourceDLL(BSTR strResDLLName){
	
    HRESULT hr = E_UNEXPECTED;
    
    if(NULL != m_hRes){

        ::FreeLibrary(m_hRes); // unload our resource library if we had some loaded
    }/* end of if statement */

#if 0 // use relative path
     TCHAR szModule[_MAX_PATH+10];
     ::GetModuleFileName(_Module.m_hInstResource, szModule, _MAX_PATH);
        *( _tcsrchr( szModule, '\\' ) + 1 ) = TEXT('\0');


    // now attempt to load the library, since it is not ActiveX control
    USES_CONVERSION;

     _tcscat( szModule, OLE2T(strResDLLName));

    m_hRes = ::LoadLibrary(szModule);
#else 
    USES_CONVERSION;
    m_hRes = ::LoadLibrary(OLE2T(strResDLLName));
#endif
    if (!m_hRes){

        hr = HRESULT_FROM_WIN32(::GetLastError());
        ATLTRACE(TEXT("Failed to load resource DLL\n"));
    }
    else {
        hr = S_OK;
    }/* end of if statement */

    return (hr);
}/* end of function LoadResourceDLL */


// variables
protected:
     HINSTANCE m_hRes;
     CComBSTR m_strResDLL;
     TransparentBlitType m_blitType;
     bool     m_fNoFocusGrab; // disable grabbing focus for windowed controls
};
#endif //__MSMFCSTUTILS_H_
/*************************************************************************/
/* End of file: CstUtils.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\cbitmap.h ===
// CBitmap.h
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef _INC_CBITMAP
#define _INC_CBITMAP

#include "MSMFCnt.h" // for definitions of the blit types

/* Handle to a DIB */
DECLARE_HANDLE(HDIB);

/* DIB constants */
#define PALVERSION   0x300

/* DIB Macros*/

#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

// WIDTHBYTES performs DWORD-aligning of DIB scanlines.  The "bits"
// parameter is the bit count for the scanline (biWidth * biBitCount),
// and this macro returns the number of DWORD-aligned bytes needed
// to hold those bits.

#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)

// Some helper functions
inline DWORD     WINAPI DIBSize(LPSTR lpDIB);
inline DWORD     WINAPI  DIBWidth (LPSTR lpDIB);
inline DWORD     WINAPI  DIBHeight (LPSTR lpDIB);
inline BYTE      RGBtoL(BYTE R, BYTE G, BYTE B);
HGLOBAL WINAPI CopyHandle (HGLOBAL h);

class CBitmap {

public:
    /* Function prototypes */

    CBitmap(){ Init();}
    virtual ~CBitmap() {CleanUp();}
    void Init();
    void CleanUp();
    HPALETTE GetPal() { return m_hPal;}
    RECT GetDIBRect() {return m_rc;}

  BOOL      CreateMemDC(HDC, LPRECT);
  BOOL      DeleteMemDC();
  BOOL      CreateTransDC(HDC, LPRECT);
  BOOL      DeleteTransDC();
  BOOL      BlitMemDC(HDC hDc, LPRECT lpDCRect, LPRECT lpDIBRect);
  HRESULT   WINAPI  SetImage(TCHAR* strFilename, HINSTANCE hRes);
  BOOL      WINAPI  PaintDIB (HDC, LPRECT, LPRECT, LPRECT, bool complex=false);
  BOOL      WINAPI  PaintTransparentDIB(HDC, LPRECT, LPRECT, TransparentBlitType, bool complex=false, HWND hWnd=NULL);
  BOOL      WINAPI  CreateDIBPalette();
  BOOL      WINAPI  ConvertColorTableGray();
  BOOL      WINAPI  ConvertDIBGray(TransparentBlitType blitType);
  LPSTR     WINAPI  FindDIBBits (LPSTR lpbi);
  WORD      WINAPI  PaletteSize (LPSTR lpbi);
  WORD      WINAPI  DIBNumColors (LPSTR lpbi);
  HGLOBAL   WINAPI  CopyHandle (HGLOBAL h);
  bool      IsEmpty(){return(NULL == m_hDIB);};
  bool      IsPaletteLoaded(){return(m_fLoadPalette);}
  void      LoadPalette(bool fLoadPalette){m_fLoadPalette = fLoadPalette;};
  
  HDIB      WINAPI  ReadDIBFile(LPCTSTR pszFileName, HINSTANCE hRes);
  HRESULT   PutImage(BSTR strFilename, HINSTANCE hRes = NULL, IUnknown* pUnk = NULL, bool fGrayOut=false, TransparentBlitType=DISABLE);
  HRESULT   XORRegion(HRGN *phRgn, HRGN hRgn, const RECT &rc) const;
  HRESULT   GetRegion(HDC hDC, HRGN *phRgn, RECT* pRect, COLORREF, bool fInvert=FALSE) const;

protected:

  HDIB      m_hDIB;
  HPALETTE  m_hPal;
  RECT      m_rc;
  HDC       m_hMemDC;
  HBITMAP   m_hMemBMP;
  LONG      m_iMemDCWidth;
  LONG      m_iMemDCHeight;
  HDC       m_hTransDC;
  HBITMAP   m_hTransBMP;
  LONG      m_iTransDCWidth;
  LONG      m_iTransDCHeight;
  HRGN      m_hRgn;
  bool     m_fLoadPalette;
};

#endif //!_INC_CBITMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfcnt.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFCnt.cpp                                                     */
/* Description: Implementation of DLL Exports.                           */
/* Author: David Janecek                                                 */
/*************************************************************************/
// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSMFCntps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSMFCnt.h"

#include "MSMFCnt_i.c"
#include "MFBar.h"
#include "MSMFBBtn.h"
#include "MSMFImg.h"
#include "MSMFSldr.h"
#include "MSMFText.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MSMFBar, CMFBar)
OBJECT_ENTRY(CLSID_MSMFBBtn, CMSMFBBtn)
OBJECT_ENTRY(CLSID_MSMFImg, CMSMFImg)
OBJECT_ENTRY(CLSID_MSMFSldr, CMSMFSldr)
OBJECT_ENTRY(CLSID_MSMFText, CMSMFText)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSMFCNTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}

/*************************************************************************/
/* End of file: MSMFCnt.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\ctext.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ctext.cpp                                                       */
/* Description: Implementation of ctext class for drawing text.          */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/
#include "stdafx.h"
#include "ctext.h"

/*************************************************************************/
/* Function: CText::CText()                                              */
/* Description: Initialize the properties and states.                    */
/*************************************************************************/
CText::CText()
{
    m_fDirty = true;
    m_hFont = NULL;

    //properties
    m_uiFontSize = 10;
    m_uiAlignment = TA_CENTER;
    m_clrTextColor = GetSysColor(COLOR_WINDOWTEXT);
    m_bstrFontFace = L"Arial";
    m_bstrFontStyle = L"Normal";
    m_fFontStyleFlags = FS_NORMAL;
    m_fFixedSizeFont = false;
}


/*************************************************************************/
/* Function: CText::~CText()                                             */
/* Description: Destroy the cached font.                                 */
/*************************************************************************/
CText::~CText()
{
    if (m_hFont)
    {
        ::DeleteObject(m_hFont);
        m_hFont = NULL;
    }
}


/*************************************************************************/
/* Function: Write                                                       */
/* Description: Draw text in the specified rectangle.                    */
/*   The font is not created until drawing text for the first time.      */
/*   Assume the following settings:                                      */
/*     - Use Transparent background mode; no change of bg color          */
/*     - Vertical alignment is always centered                           */
/*************************************************************************/
HRESULT CText::Write(HDC hdc, const RECT & rc, const WCHAR * pwszText)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    const int cBorderMargin = 2; // 2 pixel margin on left or right border

    // set drawing attributes, save the old ones

    UINT uiOldAlign = ::SetTextAlign(hdc, m_uiAlignment|TA_BOTTOM);
    COLORREF crOldTextColor = ::SetTextColor(hdc, m_clrTextColor);
    int iOldBkMode = ::SetBkMode(hdc, TRANSPARENT);

    // create the required font

    if (m_fDirty)
    {
        hr = RealizeFont(hdc);
    }

    HFONT hOldFont = NULL;
    if (m_hFont)
    {
        hOldFont = (HFONT) ::SelectObject(hdc, m_hFont);
    }

    // set position of text based on alignment

    TEXTMETRIC tm;
    GetTextMetrics(hdc, &tm);

    int x = (rc.left + rc.right)/2;
    if (m_uiAlignment == TA_LEFT)
    {
        x = rc.left + cBorderMargin;
    }
    else if (m_uiAlignment == TA_RIGHT)
    {
        x = rc.right - cBorderMargin;
    }

    // text is aligned at the bottom. Adding half of text height makes
    // it to position at the center vertically

    int y = (rc.top + rc.bottom)/2 + tm.tmHeight/2;

    ::TextOut(hdc, x, y, W2CT(pwszText), wcslen(pwszText));

    // restore original font

    if (hOldFont)
    {
        ::SelectObject(hdc, hOldFont);
    }

    ::SetTextAlign(hdc, uiOldAlign);
    ::SetTextColor(hdc, crOldTextColor);
    ::SetBkMode(hdc, iOldBkMode);

	return hr;
}


/*************************************************************************/
/* Function: GetTextWidth                                                */
/* Description: Get the width of text string based on the current font   */
/* and settings.                                                         */
/*************************************************************************/
HRESULT CText::GetTextWidth(HDC hdc, const WCHAR * pwszText, SIZE *pSize)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    const int cBorderMargin = 2; // 2 pixel margin on left or right border

    // create the required font

    if (m_fDirty)
    {
        hr = RealizeFont(hdc);
    }

    HFONT hOldFont = NULL;
    if (m_hFont)
    {
        hOldFont = (HFONT) ::SelectObject(hdc, m_hFont);
    }

    ::GetTextExtentPoint32(hdc, W2CT(pwszText), wcslen(pwszText), pSize);
    
    pSize->cx += 2*cBorderMargin;

    if (hOldFont)
    {
        ::SelectObject(hdc, hOldFont);
    }

    return hr;
}

/*************************************************************************/
/* Function: RealizeFont                                                 */
/* Description: create a font based on the current font style, size etc. */
/* Cache the font.                                                       */
/*************************************************************************/
HRESULT CText::RealizeFont(HDC hdc)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    if( NULL != m_hFont)
    {
        ::DeleteObject(m_hFont);
        m_hFont = NULL;
    }

    // by default, font size changes with system font size which
    // depends on the system screen resolution

    int nPixelsPerInch = GetDeviceCaps(hdc, LOGPIXELSY);

    // if we fixed the font size, we assume always small font (96 pixels per inch)
    if (m_fFixedSizeFont)
    {
        nPixelsPerInch = 96;
    }

    int nHeight = -MulDiv(m_uiFontSize, nPixelsPerInch, 72);

    m_hFont =  ::CreateFont(
        nHeight,                    // logical height of font
        0,                          // logical average character width
        0,                          // angle of escapement
        0,                          // base-line orientation angle
        (m_fFontStyleFlags&FS_BOLD)?FW_BOLD:FW_NORMAL,// font weight
        (m_fFontStyleFlags&FS_ITALIC)?1:0,    // italic attribute flag
        (m_fFontStyleFlags&FS_UNDERLINE)?1:0, // underline attribute flag
        (m_fFontStyleFlags&FS_STRIKEOUT)?1:0, // strikeout attribute flag
        DEFAULT_CHARSET,            // character set identifier
        OUT_DEFAULT_PRECIS,         // output precision
        CLIP_DEFAULT_PRECIS,        // clipping precision
        ANTIALIASED_QUALITY,        // output quality
        DEFAULT_PITCH,              // pitch and family
        W2T(m_bstrFontFace.m_str)          // pointer to typeface name string
    );

    if( NULL == m_hFont )
    {
        DWORD dwErr;
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    
    m_fDirty = false;

    return hr;
}


/*************************************************************************/
/* Function: SetFontSize                                                 */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
void CText::SetFontSize(long lSize)
{
    if ((UINT)lSize != m_uiFontSize)
    {
        m_uiFontSize = (UINT)lSize;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFixedSizeFont                                            */
/* Description: set flag which indicates whether the font size is fixed  */
/*   or variable with system font.                                       */
/*************************************************************************/
void CText::SetFixedSizeFont(bool fFixed)
{
    if (fFixed != m_fFixedSizeFont)
    {
        m_fFixedSizeFont = fFixed;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFontFace                                                 */
/* Description: set the FontFace property.                               */
/*************************************************************************/
void CText::SetFontFace(BSTR pwszFontFace)
{
    if (_wcsicmp(m_bstrFontFace, pwszFontFace) != 0)
    {
        m_bstrFontFace = pwszFontFace;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFontStyle                                                */
/* Description: set the FontStyle property. The style string should      */
/* contain either "Normal", or concatenation of one or more strings of:  */
/* "Bold", "Italic", "Underline", "Strikeout". Default is "Normal".      */
/*************************************************************************/
void CText::SetFontStyle(BSTR pwszFontStyle)
{
    BYTE fFontStyleFlags = FS_NORMAL;

    //find a match
    if( NULL != wcsstr(pwszFontStyle, L"Normal"))
    {
        fFontStyleFlags = FS_NORMAL;
    }
    else
    {
        // Turn on all styles that match
        if( NULL != wcsstr(pwszFontStyle, L"Bold"))
        {
            fFontStyleFlags |= FS_BOLD;
        }

        if( NULL != wcsstr(pwszFontStyle, L"Italic"))
        {
            fFontStyleFlags |= FS_ITALIC;
        }

        if( NULL != wcsstr(pwszFontStyle, L"Underline"))
        {
            fFontStyleFlags |= FS_UNDERLINE;
        }

        if( NULL != wcsstr(pwszFontStyle, L"Strikeout"))
        {
            fFontStyleFlags |= FS_STRIKEOUT;
        }
    }

    if (fFontStyleFlags != m_fFontStyleFlags)
    {
        m_fFontStyleFlags = fFontStyleFlags;
        m_bstrFontStyle = pwszFontStyle;
        m_fDirty = true;
    }
}


/*************************************************************************/
/* Function: SetFontSize                                                 */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
void CText::SetTextColor(COLORREF clrColor)
{
    if (clrColor != m_clrTextColor)
    {
        m_clrTextColor = clrColor;
    }
}


/*************************************************************************/
/* Function: SetTextAlignment                                            */
/* Description: set the TextAlignment property. It controls the          */
/* horizontal text alignment. Must be one of "Left", "Center", or        */
/* "Right". Default is "Center".                                         */
/*************************************************************************/
void CText::SetTextAlignment(BSTR pwszAlignment)
{
    UINT uiAlignment = 0;

    //set the text alignment
    if (!_wcsicmp(pwszAlignment, L"Right"))
    {
        uiAlignment = TA_RIGHT;
    }
    else if (!_wcsicmp(pwszAlignment, L"Center"))
    {
        uiAlignment = TA_CENTER;
    }
    else if (!_wcsicmp(pwszAlignment, L"Left"))
    {
        uiAlignment = TA_LEFT;
    }

    if (m_uiAlignment != uiAlignment)
    {
        m_uiAlignment = uiAlignment;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\makefile.inc ===
buildidl : $(O)\msmfcnt.h

$(O)\msmfcnt.h : msmfcnt.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header $(O)\msmfcnt.h \
    -tlb     $O\msmfcnt.tlb \
    -iid     $O\msmfcnt_i.c  \
    -dlldata $(PROXY_DIR)\dlldata.c  \
    -proxy   $(PROXY_DIR)\msmfcnt_p.c  \
    msmfcnt.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfbbtn.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFBBtn.h                                                      */
/* Description: Declaration of CMSMFBBtn                                 */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFBBTN_H_
#define __MSMFBBTN_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "CstUtils.h"
#include "ctext.h"
#include "cbitmap.h"
#include "MSMFCntCP.h"

/*************************************************************************/
/* Consts                                                                */
/*************************************************************************/
const int cgMaxBtnStates = 5; // the number of button states
 
/*************************************************************************/
/* Class: CMSMFBBtn                                                      */
/*************************************************************************/
class ATL_NO_VTABLE CMSMFBBtn : 
	public CComObjectRootEx<CComSingleThreadModel>,
	//public IDispatchImpl<IMSMFBBtn, &IID_IMSMFBBtn, &LIBID_BBTNLib>,
	public CStockPropImpl<CMSMFBBtn, IMSMFBBtn, &IID_IMSMFBBtn, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFBBtn>,
	public IPersistStreamInitImpl<CMSMFBBtn>,
	public IOleControlImpl<CMSMFBBtn>,
	public IOleObjectImpl<CMSMFBBtn>,
	public IOleInPlaceActiveObjectImpl<CMSMFBBtn>,
	public IViewObjectExImpl<CMSMFBBtn>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFBBtn>,
    public IPersistPropertyBagImpl<CMSMFBBtn>,
	public CComCoClass<CMSMFBBtn, &CLSID_MSMFBBtn>,
    public IProvideClassInfo2Impl<&CLSID_MSMFBBtn, &DIID__IMSMFBBtn, &LIBID_MSMFCNTLib>,
    public IObjectSafetyImpl<CMSMFBBtn, INTERFACESAFE_FOR_UNTRUSTED_CALLER| INTERFACESAFE_FOR_UNTRUSTED_DATA>,    
#ifdef _WMP
    public IWMPUIPluginImpl<CMSMFBBtn>,
    public IWMPUIPluginEventsImpl,
#endif
    public IConnectionPointContainerImpl<CMSMFBBtn>,
    public CProxy_IMSMFBBtn< CMSMFBBtn >,
    public CMSMFCntrlUtils<CMSMFBBtn> // custom utilities we share across controls        
{
public:
	CMSMFBBtn();
	virtual ~CMSMFBBtn();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFBBTN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFBBtn)
	COM_INTERFACE_ENTRY(IMSMFBBtn)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
#ifdef _WMP
    COM_INTERFACE_ENTRY(IWMPUIPlugin)
    COM_INTERFACE_ENTRY(IWMPUIPlugin2)
    COM_INTERFACE_ENTRY(IWMPUIPluginEvents)
#endif
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMFBBtn)    
	CONNECTION_POINT_ENTRY(DIID__IMSMFBBtn)
END_CONNECTION_POINT_MAP()

BEGIN_PROP_MAP(CMSMFBBtn)
    // the properties are loaded in order below
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
    PROP_ENTRY("TransparentBlitType", 4, CLSID_NULL)
    PROP_ENTRY("ResourceDLL", 12, CLSID_NULL)
	PROP_ENTRY("ImageStatic",1, CLSID_NULL)
	PROP_ENTRY("ImageHover", 2, CLSID_NULL)
	PROP_ENTRY("ImagePush",  3, CLSID_NULL)
    PROP_ENTRY("ImageDisabled",  14, CLSID_NULL)
    PROP_ENTRY("ImageActive",  15, CLSID_NULL)
    PROP_ENTRY("ToolTip",    9, CLSID_NULL)
    PROP_ENTRY("ToolTipMaxWidth", 13, CLSID_NULL)
    PROP_ENTRY("Windowless", 20, CLSID_NULL)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CMSMFBBtn)    
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseToolTip)
	MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
    MESSAGE_HANDLER(WM_SETFOCUS,    OnSetFocus)    
    MESSAGE_HANDLER(WM_KILLFOCUS,    OnKillFocus)    
    MESSAGE_HANDLER(WM_KEYUP,  OnKeyUp)
    MESSAGE_HANDLER(WM_KEYDOWN,  OnKeyDown)
    MESSAGE_HANDLER(WM_SIZE,  OnSize)
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFBBtn>)
	CHAIN_MSG_MAP(CComControl<CMSMFBBtn>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
  
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseToolTip(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKillFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSMFBBtn
public:
	STDMETHOD(get_TextHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TextWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_ColorActive)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorActive)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorDisable)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorDisable)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorStatic)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorStatic)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorHover)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorHover)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorPush)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorPush)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ImagePush)(/*[out, retval]*/ BSTR *pstrFilename);
	STDMETHOD(put_ImagePush)(/*[in]*/ BSTR strFilename);
	STDMETHOD(get_ImageHover)(/*[out, retval]*/ BSTR *pstrFilename);
	STDMETHOD(put_ImageHover)(/*[in]*/ BSTR strFilename);
	STDMETHOD(get_ImageStatic)(/*[out, retval]*/ BSTR *pstrFilename);
	STDMETHOD(put_ImageStatic)(/*[in]*/ BSTR strFilename);    
	STDMETHOD(get_Disable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Disable)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_BtnState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_BtnState)(/*[in]*/ long newVal);    
    STDMETHOD(get_ToolTip)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ToolTip)(/*[in]*/ BSTR newVal);    
    USE_MF_RESOURCEDLL  // replaces the two lines below
    //STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal);
	//STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal);
	STDMETHOD(GetDelayTime)(/*[in]*/ long delayType, /*[out, retval]*/ long *pVal);
	STDMETHOD(SetDelayTime)(/*[in]*/ long delayType, /*[in]*/ long newVal);	
    STDMETHOD(get_ImageActive)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ImageActive)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ImageDisabled)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ImageDisabled)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ToolTipMaxWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_ToolTipMaxWidth)(/*[in]*/ long newVal);
	STDMETHOD(get_FontStyle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontStyle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontFace)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontFace)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Text)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Text)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontSize)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_FontSize)(/*[in]*/ long newVal);
    STDMETHOD(About)();
    USE_MF_WINDOWLESS_ACTIVATION // replaces the two lines below
	//STDMETHOD(get_Windowless)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	//STDMETHOD(put_Windowless)(/*[in]*/ VARIANT_BOOL newVal);
    USE_MF_TRANSPARENT_FLAG
	HRESULT OnDraw(ATL_DRAWINFO& di);

// IOleInPlaceObjectWindowlessImpl
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);

// IOleObjectImp
    HRESULT OnPostVerbInPlaceActivate();
   
public:			
	enum BtnState {Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4};

    USE_MF_OVERWRITES

    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers

public: // member variable that have to be public due to ATL
    OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl
	
private: // data member variables
    CComBSTR m_bstrFilename[cgMaxBtnStates]; // filenames containing the images
    CBitmap* m_pBitmap[cgMaxBtnStates];

    BtnState m_nEntry;
    HWND m_hWndTip;         // Tooltip window
    LONG m_nTTMaxWidth;     // Max tooltip width
    CComBSTR m_bstrToolTip; // Tooltip string
    BOOL m_bTTCreated;      // Has tooltip been created yet
    CText       m_cText;   // text drawing object
    bool        m_fDirty; // if any attribute for the text drawing object changes
    CComBSTR    m_bstrTextValue;
    CComBSTR    m_bstrFontFace;
    CComBSTR    m_bstrFontStyle;
    UINT        m_uiFontSize;
    OLE_COLOR   m_clrColorActive;
    OLE_COLOR   m_clrColorStatic;
    OLE_COLOR   m_clrColorHover;
    OLE_COLOR   m_clrColorPush;
    OLE_COLOR   m_clrColorDisable;

protected: // helper functions
    void Init();
    bool PtOnButton(LONG x, LONG y);
    bool PtOnButton(POINT pos);
    HRESULT CreateToolTip(void);
    HRESULT PutImage(BSTR strFilename, int nEntry);
    HRESULT SetButtonState(BtnState btnState);        
    HRESULT SetTextProperties();
};

#endif //__MSMFBBTN_H_
/*************************************************************************/
/* End of file: MSMFBBtn.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfcnt.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for msmfcnt.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msmfcnt_h__
#define __msmfcnt_h__

/* Forward Declarations */ 

#ifndef __IMSMFBar_FWD_DEFINED__
#define __IMSMFBar_FWD_DEFINED__
typedef interface IMSMFBar IMSMFBar;
#endif 	/* __IMSMFBar_FWD_DEFINED__ */


#ifndef __IMSMFBBtn_FWD_DEFINED__
#define __IMSMFBBtn_FWD_DEFINED__
typedef interface IMSMFBBtn IMSMFBBtn;
#endif 	/* __IMSMFBBtn_FWD_DEFINED__ */


#ifndef __IMSMFImg_FWD_DEFINED__
#define __IMSMFImg_FWD_DEFINED__
typedef interface IMSMFImg IMSMFImg;
#endif 	/* __IMSMFImg_FWD_DEFINED__ */


#ifndef __IMSMFSldr_FWD_DEFINED__
#define __IMSMFSldr_FWD_DEFINED__
typedef interface IMSMFSldr IMSMFSldr;
#endif 	/* __IMSMFSldr_FWD_DEFINED__ */


#ifndef __IMSMFText_FWD_DEFINED__
#define __IMSMFText_FWD_DEFINED__
typedef interface IMSMFText IMSMFText;
#endif 	/* __IMSMFText_FWD_DEFINED__ */


#ifndef ___IMSMFBar_FWD_DEFINED__
#define ___IMSMFBar_FWD_DEFINED__
typedef interface _IMSMFBar _IMSMFBar;
#endif 	/* ___IMSMFBar_FWD_DEFINED__ */


#ifndef __MSMFBar_FWD_DEFINED__
#define __MSMFBar_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMFBar MSMFBar;
#else
typedef struct MSMFBar MSMFBar;
#endif /* __cplusplus */

#endif 	/* __MSMFBar_FWD_DEFINED__ */


#ifndef ___IMSMFBBtn_FWD_DEFINED__
#define ___IMSMFBBtn_FWD_DEFINED__
typedef interface _IMSMFBBtn _IMSMFBBtn;
#endif 	/* ___IMSMFBBtn_FWD_DEFINED__ */


#ifndef __MSMFBBtn_FWD_DEFINED__
#define __MSMFBBtn_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMFBBtn MSMFBBtn;
#else
typedef struct MSMFBBtn MSMFBBtn;
#endif /* __cplusplus */

#endif 	/* __MSMFBBtn_FWD_DEFINED__ */


#ifndef __MSMFImg_FWD_DEFINED__
#define __MSMFImg_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMFImg MSMFImg;
#else
typedef struct MSMFImg MSMFImg;
#endif /* __cplusplus */

#endif 	/* __MSMFImg_FWD_DEFINED__ */


#ifndef ___IMSMFSldr_FWD_DEFINED__
#define ___IMSMFSldr_FWD_DEFINED__
typedef interface _IMSMFSldr _IMSMFSldr;
#endif 	/* ___IMSMFSldr_FWD_DEFINED__ */


#ifndef __MSMFSldr_FWD_DEFINED__
#define __MSMFSldr_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMFSldr MSMFSldr;
#else
typedef struct MSMFSldr MSMFSldr;
#endif /* __cplusplus */

#endif 	/* __MSMFSldr_FWD_DEFINED__ */


#ifndef ___IMSMFText_FWD_DEFINED__
#define ___IMSMFText_FWD_DEFINED__
typedef interface _IMSMFText _IMSMFText;
#endif 	/* ___IMSMFText_FWD_DEFINED__ */


#ifndef __MSMFText_FWD_DEFINED__
#define __MSMFText_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMFText MSMFText;
#else
typedef struct MSMFText MSMFText;
#endif /* __cplusplus */

#endif 	/* __MSMFText_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_msmfcnt_0000 */
/* [local] */ 

typedef /* [public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_msmfcnt_0000_0001
    {	DISABLE	= 0,
	TRANSPARENT_TOP_LEFT	= 1,
	TRANSPARENT_BOTTOM_RIGHT	= 2,
	TOP_LEFT_WINDOW_REGION	= 3,
	BOTTOM_RIGHT_WINDOW_REGION	= 4,
	TOP_LEFT_WITH_BACKCOLOR	= 5,
	BOTTOM_RIGHT_WITH_BACKCOLOR	= 6
    }	TransparentBlitType;



extern RPC_IF_HANDLE __MIDL_itf_msmfcnt_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msmfcnt_0000_v0_0_s_ifspec;

#ifndef __IMSMFBar_INTERFACE_DEFINED__
#define __IMSMFBar_INTERFACE_DEFINED__

/* interface IMSMFBar */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMSMFBar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54B56DEC-639B-4D6C-9266-583A8E5BF7A4")
    IMSMFBar : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ BSTR strStatement) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE About( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR strObjectID,
            /* [in] */ BSTR strProgID,
            /* [in] */ long lx,
            /* [in] */ long ly,
            /* [in] */ long lWidth,
            /* [in] */ long lHeight,
            /* [defaultvalue][in] */ BSTR strPropBag = L"",
            /* [defaultvalue][in] */ VARIANT_BOOL fDisabled = 0,
            /* [defaultvalue][in] */ BSTR strEventHookScript = L"") = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddScriptlet( 
            /* [in] */ BSTR strObjectID,
            /* [in] */ BSTR strEvent,
            /* [in] */ BSTR strEventCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddObject( 
            /* [in] */ BSTR strObjectID,
            /* [in] */ LPDISPATCH pDisp) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetObjectUnknown( 
            /* [in] */ BSTR strObjectID,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableObject( 
            /* [in] */ BSTR strObjectID,
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptLanguage( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScriptLanguage( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptFile( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScriptFile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ObjectEnabled( 
            /* [in] */ BSTR strObjectID,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetupSelfSite( 
            /* [in] */ long lx,
            /* [in] */ long ly,
            /* [in] */ long lWitdh,
            /* [in] */ long lHeight,
            /* [in] */ BSTR strPropBag,
            /* [defaultvalue][in] */ VARIANT_BOOL fDisabled = 0,
            /* [defaultvalue][in] */ VARIANT_BOOL fHelpDisabled = -1,
            /* [defaultvalue][in] */ VARIANT_BOOL fWindowDisabled = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DestroyScriptEngine( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HookScriptlet( 
            /* [in] */ BSTR strObjectID,
            /* [in] */ BSTR strEvent,
            /* [in] */ BSTR strEventCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetObjectPosition( 
            /* [in] */ BSTR strObjectID,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [in] */ long lWidth,
            /* [in] */ long lHeight) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinHeight( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinHeight( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WinHelp( 
            long lCommand,
            long dwData,
            BSTR strHelpFile) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackgroundImage( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BackgroundImage( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransparentBlit( 
            /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TransparentBlit( 
            /* [in] */ TransparentBlitType newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowSelfSite( 
            long nCmd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ long lPriority) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPriorityClass( 
            /* [in] */ long lPriorityClass) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoLoad( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoLoad( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRoundRectRgn( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2,
            /* [in] */ long width,
            /* [in] */ long height) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRectRgn( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetObjectFocus( 
            /* [in] */ BSTR strObjectID,
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ForceKey( 
            /* [in] */ LONG lVirtKey,
            /* [in] */ LONG lKeyData,
            /* [defaultvalue][in] */ VARIANT_BOOL fEat = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MessageBox( 
            BSTR strText,
            BSTR strCaption,
            /* [defaultvalue][in] */ long lType = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetObjectExtent( 
            BSTR strID,
            long lWidth,
            long lHeight) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResourceDLL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ResourceDLL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivityTimeout( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActivityTimeout( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetTimeout( 
            /* [in] */ long lMilliseconds,
            /* [defaultvalue][in] */ long lId = 1) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Sleep( 
            /* [in] */ long lMiliseconds) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CmdLine( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CmdLine( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFocusObject( 
            BSTR strObjectID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResetFocusArray( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUserLCID( 
            /* [retval][out] */ long __RPC_FAR *pLcid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasObjectFocus( 
            BSTR strObjectID,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfFocus) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Window( 
            /* [in] */ long hwnd) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Window( 
            /* [retval][out] */ long __RPC_FAR *pHwnd) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR strCaption) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pstrCaption) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMFBarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSMFBar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSMFBar __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMSMFBar __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IMSMFBar __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strStatement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *About )( 
            IMSMFBar __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [in] */ BSTR strProgID,
            /* [in] */ long lx,
            /* [in] */ long ly,
            /* [in] */ long lWidth,
            /* [in] */ long lHeight,
            /* [defaultvalue][in] */ BSTR strPropBag,
            /* [defaultvalue][in] */ VARIANT_BOOL fDisabled,
            /* [defaultvalue][in] */ BSTR strEventHookScript);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScriptlet )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [in] */ BSTR strEvent,
            /* [in] */ BSTR strEventCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddObject )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [in] */ LPDISPATCH pDisp);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectUnknown )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableObject )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptLanguage )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptLanguage )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptFile )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptFile )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ObjectEnabled )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetupSelfSite )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long lx,
            /* [in] */ long ly,
            /* [in] */ long lWitdh,
            /* [in] */ long lHeight,
            /* [in] */ BSTR strPropBag,
            /* [defaultvalue][in] */ VARIANT_BOOL fDisabled,
            /* [defaultvalue][in] */ VARIANT_BOOL fHelpDisabled,
            /* [defaultvalue][in] */ VARIANT_BOOL fWindowDisabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyScriptEngine )( 
            IMSMFBar __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HookScriptlet )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [in] */ BSTR strEvent,
            /* [in] */ BSTR strEventCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectPosition )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [in] */ long lWidth,
            /* [in] */ long lHeight);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinWidth )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MinWidth )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinHeight )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MinHeight )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WinHelp )( 
            IMSMFBar __RPC_FAR * This,
            long lCommand,
            long dwData,
            BSTR strHelpFile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackgroundImage )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackgroundImage )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TransparentBlit )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TransparentBlit )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ TransparentBlitType newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowSelfSite )( 
            IMSMFBar __RPC_FAR * This,
            long nCmd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IMSMFBar __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriority )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long lPriority);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriorityClass )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long lPriorityClass);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoLoad )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoLoad )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoundRectRgn )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2,
            /* [in] */ long width,
            /* [in] */ long height);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRectRgn )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectFocus )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strObjectID,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ForceKey )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ LONG lVirtKey,
            /* [in] */ LONG lKeyData,
            /* [defaultvalue][in] */ VARIANT_BOOL fEat);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IMSMFBar __RPC_FAR * This,
            BSTR strText,
            BSTR strCaption,
            /* [defaultvalue][in] */ long lType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectExtent )( 
            IMSMFBar __RPC_FAR * This,
            BSTR strID,
            long lWidth,
            long lHeight);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceDLL )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ResourceDLL )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivityTimeout )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivityTimeout )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimeout )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long lMilliseconds,
            /* [defaultvalue][in] */ long lId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sleep )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long lMiliseconds);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CmdLine )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CmdLine )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFocusObject )( 
            IMSMFBar __RPC_FAR * This,
            BSTR strObjectID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetFocusArray )( 
            IMSMFBar __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserLCID )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pLcid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HasObjectFocus )( 
            IMSMFBar __RPC_FAR * This,
            BSTR strObjectID,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfFocus);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackColor )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ OLE_COLOR clr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackColor )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Window )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ long hwnd);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Window )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHwnd);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Caption )( 
            IMSMFBar __RPC_FAR * This,
            /* [in] */ BSTR strCaption);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstrCaption);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadyState )( 
            IMSMFBar __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        END_INTERFACE
    } IMSMFBarVtbl;

    interface IMSMFBar
    {
        CONST_VTBL struct IMSMFBarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMFBar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMFBar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMFBar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMFBar_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMFBar_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMFBar_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMFBar_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMFBar_Load(This)	\
    (This)->lpVtbl -> Load(This)

#define IMSMFBar_Run(This,strStatement)	\
    (This)->lpVtbl -> Run(This,strStatement)

#define IMSMFBar_About(This)	\
    (This)->lpVtbl -> About(This)

#define IMSMFBar_CreateObject(This,strObjectID,strProgID,lx,ly,lWidth,lHeight,strPropBag,fDisabled,strEventHookScript)	\
    (This)->lpVtbl -> CreateObject(This,strObjectID,strProgID,lx,ly,lWidth,lHeight,strPropBag,fDisabled,strEventHookScript)

#define IMSMFBar_AddScriptlet(This,strObjectID,strEvent,strEventCode)	\
    (This)->lpVtbl -> AddScriptlet(This,strObjectID,strEvent,strEventCode)

#define IMSMFBar_AddObject(This,strObjectID,pDisp)	\
    (This)->lpVtbl -> AddObject(This,strObjectID,pDisp)

#define IMSMFBar_GetObjectUnknown(This,strObjectID,ppUnk)	\
    (This)->lpVtbl -> GetObjectUnknown(This,strObjectID,ppUnk)

#define IMSMFBar_EnableObject(This,strObjectID,fEnable)	\
    (This)->lpVtbl -> EnableObject(This,strObjectID,fEnable)

#define IMSMFBar_get_ScriptLanguage(This,pVal)	\
    (This)->lpVtbl -> get_ScriptLanguage(This,pVal)

#define IMSMFBar_put_ScriptLanguage(This,newVal)	\
    (This)->lpVtbl -> put_ScriptLanguage(This,newVal)

#define IMSMFBar_get_ScriptFile(This,pVal)	\
    (This)->lpVtbl -> get_ScriptFile(This,pVal)

#define IMSMFBar_put_ScriptFile(This,newVal)	\
    (This)->lpVtbl -> put_ScriptFile(This,newVal)

#define IMSMFBar_ObjectEnabled(This,strObjectID,pfEnabled)	\
    (This)->lpVtbl -> ObjectEnabled(This,strObjectID,pfEnabled)

#define IMSMFBar_SetupSelfSite(This,lx,ly,lWitdh,lHeight,strPropBag,fDisabled,fHelpDisabled,fWindowDisabled)	\
    (This)->lpVtbl -> SetupSelfSite(This,lx,ly,lWitdh,lHeight,strPropBag,fDisabled,fHelpDisabled,fWindowDisabled)

#define IMSMFBar_DestroyScriptEngine(This)	\
    (This)->lpVtbl -> DestroyScriptEngine(This)

#define IMSMFBar_HookScriptlet(This,strObjectID,strEvent,strEventCode)	\
    (This)->lpVtbl -> HookScriptlet(This,strObjectID,strEvent,strEventCode)

#define IMSMFBar_SetObjectPosition(This,strObjectID,xPos,yPos,lWidth,lHeight)	\
    (This)->lpVtbl -> SetObjectPosition(This,strObjectID,xPos,yPos,lWidth,lHeight)

#define IMSMFBar_get_MinWidth(This,pVal)	\
    (This)->lpVtbl -> get_MinWidth(This,pVal)

#define IMSMFBar_put_MinWidth(This,newVal)	\
    (This)->lpVtbl -> put_MinWidth(This,newVal)

#define IMSMFBar_get_MinHeight(This,pVal)	\
    (This)->lpVtbl -> get_MinHeight(This,pVal)

#define IMSMFBar_put_MinHeight(This,newVal)	\
    (This)->lpVtbl -> put_MinHeight(This,newVal)

#define IMSMFBar_WinHelp(This,lCommand,dwData,strHelpFile)	\
    (This)->lpVtbl -> WinHelp(This,lCommand,dwData,strHelpFile)

#define IMSMFBar_get_BackgroundImage(This,pVal)	\
    (This)->lpVtbl -> get_BackgroundImage(This,pVal)

#define IMSMFBar_put_BackgroundImage(This,newVal)	\
    (This)->lpVtbl -> put_BackgroundImage(This,newVal)

#define IMSMFBar_get_TransparentBlit(This,pVal)	\
    (This)->lpVtbl -> get_TransparentBlit(This,pVal)

#define IMSMFBar_put_TransparentBlit(This,newVal)	\
    (This)->lpVtbl -> put_TransparentBlit(This,newVal)

#define IMSMFBar_ShowSelfSite(This,nCmd)	\
    (This)->lpVtbl -> ShowSelfSite(This,nCmd)

#define IMSMFBar_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IMSMFBar_SetPriority(This,lPriority)	\
    (This)->lpVtbl -> SetPriority(This,lPriority)

#define IMSMFBar_SetPriorityClass(This,lPriorityClass)	\
    (This)->lpVtbl -> SetPriorityClass(This,lPriorityClass)

#define IMSMFBar_get_AutoLoad(This,pVal)	\
    (This)->lpVtbl -> get_AutoLoad(This,pVal)

#define IMSMFBar_put_AutoLoad(This,newVal)	\
    (This)->lpVtbl -> put_AutoLoad(This,newVal)

#define IMSMFBar_SetRoundRectRgn(This,x1,y1,x2,y2,width,height)	\
    (This)->lpVtbl -> SetRoundRectRgn(This,x1,y1,x2,y2,width,height)

#define IMSMFBar_SetRectRgn(This,x1,y1,x2,y2)	\
    (This)->lpVtbl -> SetRectRgn(This,x1,y1,x2,y2)

#define IMSMFBar_SetObjectFocus(This,strObjectID,fEnable)	\
    (This)->lpVtbl -> SetObjectFocus(This,strObjectID,fEnable)

#define IMSMFBar_ForceKey(This,lVirtKey,lKeyData,fEat)	\
    (This)->lpVtbl -> ForceKey(This,lVirtKey,lKeyData,fEat)

#define IMSMFBar_MessageBox(This,strText,strCaption,lType)	\
    (This)->lpVtbl -> MessageBox(This,strText,strCaption,lType)

#define IMSMFBar_SetObjectExtent(This,strID,lWidth,lHeight)	\
    (This)->lpVtbl -> SetObjectExtent(This,strID,lWidth,lHeight)

#define IMSMFBar_get_ResourceDLL(This,pVal)	\
    (This)->lpVtbl -> get_ResourceDLL(This,pVal)

#define IMSMFBar_put_ResourceDLL(This,newVal)	\
    (This)->lpVtbl -> put_ResourceDLL(This,newVal)

#define IMSMFBar_get_ActivityTimeout(This,pVal)	\
    (This)->lpVtbl -> get_ActivityTimeout(This,pVal)

#define IMSMFBar_put_ActivityTimeout(This,newVal)	\
    (This)->lpVtbl -> put_ActivityTimeout(This,newVal)

#define IMSMFBar_SetTimeout(This,lMilliseconds,lId)	\
    (This)->lpVtbl -> SetTimeout(This,lMilliseconds,lId)

#define IMSMFBar_Sleep(This,lMiliseconds)	\
    (This)->lpVtbl -> Sleep(This,lMiliseconds)

#define IMSMFBar_get_CmdLine(This,pVal)	\
    (This)->lpVtbl -> get_CmdLine(This,pVal)

#define IMSMFBar_put_CmdLine(This,newVal)	\
    (This)->lpVtbl -> put_CmdLine(This,newVal)

#define IMSMFBar_AddFocusObject(This,strObjectID)	\
    (This)->lpVtbl -> AddFocusObject(This,strObjectID)

#define IMSMFBar_ResetFocusArray(This)	\
    (This)->lpVtbl -> ResetFocusArray(This)

#define IMSMFBar_GetUserLCID(This,pLcid)	\
    (This)->lpVtbl -> GetUserLCID(This,pLcid)

#define IMSMFBar_HasObjectFocus(This,strObjectID,pfFocus)	\
    (This)->lpVtbl -> HasObjectFocus(This,strObjectID,pfFocus)

#define IMSMFBar_put_BackColor(This,clr)	\
    (This)->lpVtbl -> put_BackColor(This,clr)

#define IMSMFBar_get_BackColor(This,pclr)	\
    (This)->lpVtbl -> get_BackColor(This,pclr)

#define IMSMFBar_put_Window(This,hwnd)	\
    (This)->lpVtbl -> put_Window(This,hwnd)

#define IMSMFBar_get_Window(This,pHwnd)	\
    (This)->lpVtbl -> get_Window(This,pHwnd)

#define IMSMFBar_put_Caption(This,strCaption)	\
    (This)->lpVtbl -> put_Caption(This,strCaption)

#define IMSMFBar_get_Caption(This,pstrCaption)	\
    (This)->lpVtbl -> get_Caption(This,pstrCaption)

#define IMSMFBar_get_ReadyState(This,pVal)	\
    (This)->lpVtbl -> get_ReadyState(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_Load_Proxy( 
    IMSMFBar __RPC_FAR * This);


void __RPC_STUB IMSMFBar_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_Run_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strStatement);


void __RPC_STUB IMSMFBar_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_About_Proxy( 
    IMSMFBar __RPC_FAR * This);


void __RPC_STUB IMSMFBar_About_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_CreateObject_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [in] */ BSTR strProgID,
    /* [in] */ long lx,
    /* [in] */ long ly,
    /* [in] */ long lWidth,
    /* [in] */ long lHeight,
    /* [defaultvalue][in] */ BSTR strPropBag,
    /* [defaultvalue][in] */ VARIANT_BOOL fDisabled,
    /* [defaultvalue][in] */ BSTR strEventHookScript);


void __RPC_STUB IMSMFBar_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_AddScriptlet_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [in] */ BSTR strEvent,
    /* [in] */ BSTR strEventCode);


void __RPC_STUB IMSMFBar_AddScriptlet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_AddObject_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [in] */ LPDISPATCH pDisp);


void __RPC_STUB IMSMFBar_AddObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_GetObjectUnknown_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IMSMFBar_GetObjectUnknown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_EnableObject_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB IMSMFBar_EnableObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_ScriptLanguage_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_ScriptLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_ScriptLanguage_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBar_put_ScriptLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_ScriptFile_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_ScriptFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_ScriptFile_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBar_put_ScriptFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_ObjectEnabled_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IMSMFBar_ObjectEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetupSelfSite_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long lx,
    /* [in] */ long ly,
    /* [in] */ long lWitdh,
    /* [in] */ long lHeight,
    /* [in] */ BSTR strPropBag,
    /* [defaultvalue][in] */ VARIANT_BOOL fDisabled,
    /* [defaultvalue][in] */ VARIANT_BOOL fHelpDisabled,
    /* [defaultvalue][in] */ VARIANT_BOOL fWindowDisabled);


void __RPC_STUB IMSMFBar_SetupSelfSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_DestroyScriptEngine_Proxy( 
    IMSMFBar __RPC_FAR * This);


void __RPC_STUB IMSMFBar_DestroyScriptEngine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_HookScriptlet_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [in] */ BSTR strEvent,
    /* [in] */ BSTR strEventCode);


void __RPC_STUB IMSMFBar_HookScriptlet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetObjectPosition_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [in] */ long xPos,
    /* [in] */ long yPos,
    /* [in] */ long lWidth,
    /* [in] */ long lHeight);


void __RPC_STUB IMSMFBar_SetObjectPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_MinWidth_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_MinWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_MinWidth_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFBar_put_MinWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_MinHeight_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_MinHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_MinHeight_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFBar_put_MinHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_WinHelp_Proxy( 
    IMSMFBar __RPC_FAR * This,
    long lCommand,
    long dwData,
    BSTR strHelpFile);


void __RPC_STUB IMSMFBar_WinHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_BackgroundImage_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_BackgroundImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_BackgroundImage_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBar_put_BackgroundImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_TransparentBlit_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_TransparentBlit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_TransparentBlit_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ TransparentBlitType newVal);


void __RPC_STUB IMSMFBar_put_TransparentBlit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_ShowSelfSite_Proxy( 
    IMSMFBar __RPC_FAR * This,
    long nCmd);


void __RPC_STUB IMSMFBar_ShowSelfSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_Close_Proxy( 
    IMSMFBar __RPC_FAR * This);


void __RPC_STUB IMSMFBar_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetPriority_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long lPriority);


void __RPC_STUB IMSMFBar_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetPriorityClass_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long lPriorityClass);


void __RPC_STUB IMSMFBar_SetPriorityClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_AutoLoad_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_AutoLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_AutoLoad_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFBar_put_AutoLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetRoundRectRgn_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long x1,
    /* [in] */ long y1,
    /* [in] */ long x2,
    /* [in] */ long y2,
    /* [in] */ long width,
    /* [in] */ long height);


void __RPC_STUB IMSMFBar_SetRoundRectRgn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetRectRgn_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long x1,
    /* [in] */ long y1,
    /* [in] */ long x2,
    /* [in] */ long y2);


void __RPC_STUB IMSMFBar_SetRectRgn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetObjectFocus_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strObjectID,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB IMSMFBar_SetObjectFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_ForceKey_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ LONG lVirtKey,
    /* [in] */ LONG lKeyData,
    /* [defaultvalue][in] */ VARIANT_BOOL fEat);


void __RPC_STUB IMSMFBar_ForceKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_MessageBox_Proxy( 
    IMSMFBar __RPC_FAR * This,
    BSTR strText,
    BSTR strCaption,
    /* [defaultvalue][in] */ long lType);


void __RPC_STUB IMSMFBar_MessageBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetObjectExtent_Proxy( 
    IMSMFBar __RPC_FAR * This,
    BSTR strID,
    long lWidth,
    long lHeight);


void __RPC_STUB IMSMFBar_SetObjectExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_ResourceDLL_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_ResourceDLL_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBar_put_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_ActivityTimeout_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_ActivityTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_ActivityTimeout_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFBar_put_ActivityTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_SetTimeout_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long lMilliseconds,
    /* [defaultvalue][in] */ long lId);


void __RPC_STUB IMSMFBar_SetTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_Sleep_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long lMiliseconds);


void __RPC_STUB IMSMFBar_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_CmdLine_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_CmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_CmdLine_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBar_put_CmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_AddFocusObject_Proxy( 
    IMSMFBar __RPC_FAR * This,
    BSTR strObjectID);


void __RPC_STUB IMSMFBar_AddFocusObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_ResetFocusArray_Proxy( 
    IMSMFBar __RPC_FAR * This);


void __RPC_STUB IMSMFBar_ResetFocusArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_GetUserLCID_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pLcid);


void __RPC_STUB IMSMFBar_GetUserLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBar_HasObjectFocus_Proxy( 
    IMSMFBar __RPC_FAR * This,
    BSTR strObjectID,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfFocus);


void __RPC_STUB IMSMFBar_HasObjectFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_BackColor_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ OLE_COLOR clr);


void __RPC_STUB IMSMFBar_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_BackColor_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);


void __RPC_STUB IMSMFBar_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_Window_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ long hwnd);


void __RPC_STUB IMSMFBar_put_Window_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_Window_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHwnd);


void __RPC_STUB IMSMFBar_get_Window_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBar_put_Caption_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [in] */ BSTR strCaption);


void __RPC_STUB IMSMFBar_put_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_Caption_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstrCaption);


void __RPC_STUB IMSMFBar_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBar_get_ReadyState_Proxy( 
    IMSMFBar __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IMSMFBar_get_ReadyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMFBar_INTERFACE_DEFINED__ */


#ifndef __IMSMFBBtn_INTERFACE_DEFINED__
#define __IMSMFBBtn_INTERFACE_DEFINED__

/* interface IMSMFBBtn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMSMFBBtn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A43B9418-A9BC-4888-97D5-48717A3D2FE0")
    IMSMFBBtn : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageStatic( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ImageStatic( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageHover( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ImageHover( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImagePush( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ImagePush( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransparentBlit( 
            /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TransparentBlit( 
            /* [in] */ TransparentBlitType newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE About( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Disable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Disable( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BtnState( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BtnState( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ToolTip( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ToolTip( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDelayTime( 
            /* [in] */ long delayType,
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetDelayTime( 
            /* [in] */ long delayType,
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResourceDLL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ResourceDLL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ToolTipMaxWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ToolTipMaxWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageDisabled( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ImageDisabled( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageActive( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ImageActive( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FontSize( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FontSize( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FontFace( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FontFace( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FontStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FontStyle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Windowless( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Windowless( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorPush( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorPush( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorHover( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorHover( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorStatic( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorStatic( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorDisable( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorDisable( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorActive( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorActive( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TextWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TextHeight( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMFBBtnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSMFBBtn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSMFBBtn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageStatic )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ImageStatic )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageHover )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ImageHover )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImagePush )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ImagePush )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TransparentBlit )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TransparentBlit )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ TransparentBlitType newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *About )( 
            IMSMFBBtn __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Disable )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Disable )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BtnState )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BtnState )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolTip )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolTip )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDelayTime )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ long delayType,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDelayTime )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ long delayType,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceDLL )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ResourceDLL )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolTipMaxWidth )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolTipMaxWidth )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageDisabled )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ImageDisabled )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageActive )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ImageActive )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontSize )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontSize )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Text )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Text )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontFace )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontFace )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontStyle )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontStyle )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windowless )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Windowless )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackColor )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ OLE_COLOR clr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackColor )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorPush )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorPush )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorHover )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorHover )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorStatic )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorStatic )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorDisable )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorDisable )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorActive )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorActive )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextWidth )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextHeight )( 
            IMSMFBBtn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        END_INTERFACE
    } IMSMFBBtnVtbl;

    interface IMSMFBBtn
    {
        CONST_VTBL struct IMSMFBBtnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMFBBtn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMFBBtn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMFBBtn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMFBBtn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMFBBtn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMFBBtn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMFBBtn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMFBBtn_get_ImageStatic(This,pVal)	\
    (This)->lpVtbl -> get_ImageStatic(This,pVal)

#define IMSMFBBtn_put_ImageStatic(This,newVal)	\
    (This)->lpVtbl -> put_ImageStatic(This,newVal)

#define IMSMFBBtn_get_ImageHover(This,pVal)	\
    (This)->lpVtbl -> get_ImageHover(This,pVal)

#define IMSMFBBtn_put_ImageHover(This,newVal)	\
    (This)->lpVtbl -> put_ImageHover(This,newVal)

#define IMSMFBBtn_get_ImagePush(This,pVal)	\
    (This)->lpVtbl -> get_ImagePush(This,pVal)

#define IMSMFBBtn_put_ImagePush(This,newVal)	\
    (This)->lpVtbl -> put_ImagePush(This,newVal)

#define IMSMFBBtn_get_TransparentBlit(This,pVal)	\
    (This)->lpVtbl -> get_TransparentBlit(This,pVal)

#define IMSMFBBtn_put_TransparentBlit(This,newVal)	\
    (This)->lpVtbl -> put_TransparentBlit(This,newVal)

#define IMSMFBBtn_About(This)	\
    (This)->lpVtbl -> About(This)

#define IMSMFBBtn_get_Disable(This,pVal)	\
    (This)->lpVtbl -> get_Disable(This,pVal)

#define IMSMFBBtn_put_Disable(This,newVal)	\
    (This)->lpVtbl -> put_Disable(This,newVal)

#define IMSMFBBtn_get_BtnState(This,pVal)	\
    (This)->lpVtbl -> get_BtnState(This,pVal)

#define IMSMFBBtn_put_BtnState(This,newVal)	\
    (This)->lpVtbl -> put_BtnState(This,newVal)

#define IMSMFBBtn_get_ToolTip(This,pVal)	\
    (This)->lpVtbl -> get_ToolTip(This,pVal)

#define IMSMFBBtn_put_ToolTip(This,newVal)	\
    (This)->lpVtbl -> put_ToolTip(This,newVal)

#define IMSMFBBtn_GetDelayTime(This,delayType,pVal)	\
    (This)->lpVtbl -> GetDelayTime(This,delayType,pVal)

#define IMSMFBBtn_SetDelayTime(This,delayType,newVal)	\
    (This)->lpVtbl -> SetDelayTime(This,delayType,newVal)

#define IMSMFBBtn_get_ResourceDLL(This,pVal)	\
    (This)->lpVtbl -> get_ResourceDLL(This,pVal)

#define IMSMFBBtn_put_ResourceDLL(This,newVal)	\
    (This)->lpVtbl -> put_ResourceDLL(This,newVal)

#define IMSMFBBtn_get_ToolTipMaxWidth(This,pVal)	\
    (This)->lpVtbl -> get_ToolTipMaxWidth(This,pVal)

#define IMSMFBBtn_put_ToolTipMaxWidth(This,newVal)	\
    (This)->lpVtbl -> put_ToolTipMaxWidth(This,newVal)

#define IMSMFBBtn_get_ImageDisabled(This,pVal)	\
    (This)->lpVtbl -> get_ImageDisabled(This,pVal)

#define IMSMFBBtn_put_ImageDisabled(This,newVal)	\
    (This)->lpVtbl -> put_ImageDisabled(This,newVal)

#define IMSMFBBtn_get_ImageActive(This,pVal)	\
    (This)->lpVtbl -> get_ImageActive(This,pVal)

#define IMSMFBBtn_put_ImageActive(This,newVal)	\
    (This)->lpVtbl -> put_ImageActive(This,newVal)

#define IMSMFBBtn_get_FontSize(This,pVal)	\
    (This)->lpVtbl -> get_FontSize(This,pVal)

#define IMSMFBBtn_put_FontSize(This,newVal)	\
    (This)->lpVtbl -> put_FontSize(This,newVal)

#define IMSMFBBtn_get_Text(This,pVal)	\
    (This)->lpVtbl -> get_Text(This,pVal)

#define IMSMFBBtn_put_Text(This,newVal)	\
    (This)->lpVtbl -> put_Text(This,newVal)

#define IMSMFBBtn_get_FontFace(This,pVal)	\
    (This)->lpVtbl -> get_FontFace(This,pVal)

#define IMSMFBBtn_put_FontFace(This,newVal)	\
    (This)->lpVtbl -> put_FontFace(This,newVal)

#define IMSMFBBtn_get_FontStyle(This,pVal)	\
    (This)->lpVtbl -> get_FontStyle(This,pVal)

#define IMSMFBBtn_put_FontStyle(This,newVal)	\
    (This)->lpVtbl -> put_FontStyle(This,newVal)

#define IMSMFBBtn_get_Windowless(This,pVal)	\
    (This)->lpVtbl -> get_Windowless(This,pVal)

#define IMSMFBBtn_put_Windowless(This,newVal)	\
    (This)->lpVtbl -> put_Windowless(This,newVal)

#define IMSMFBBtn_put_BackColor(This,clr)	\
    (This)->lpVtbl -> put_BackColor(This,clr)

#define IMSMFBBtn_get_BackColor(This,pclr)	\
    (This)->lpVtbl -> get_BackColor(This,pclr)

#define IMSMFBBtn_get_ColorPush(This,pVal)	\
    (This)->lpVtbl -> get_ColorPush(This,pVal)

#define IMSMFBBtn_put_ColorPush(This,newVal)	\
    (This)->lpVtbl -> put_ColorPush(This,newVal)

#define IMSMFBBtn_get_ColorHover(This,pVal)	\
    (This)->lpVtbl -> get_ColorHover(This,pVal)

#define IMSMFBBtn_put_ColorHover(This,newVal)	\
    (This)->lpVtbl -> put_ColorHover(This,newVal)

#define IMSMFBBtn_get_ColorStatic(This,pVal)	\
    (This)->lpVtbl -> get_ColorStatic(This,pVal)

#define IMSMFBBtn_put_ColorStatic(This,newVal)	\
    (This)->lpVtbl -> put_ColorStatic(This,newVal)

#define IMSMFBBtn_get_ColorDisable(This,pVal)	\
    (This)->lpVtbl -> get_ColorDisable(This,pVal)

#define IMSMFBBtn_put_ColorDisable(This,newVal)	\
    (This)->lpVtbl -> put_ColorDisable(This,newVal)

#define IMSMFBBtn_get_ColorActive(This,pVal)	\
    (This)->lpVtbl -> get_ColorActive(This,pVal)

#define IMSMFBBtn_put_ColorActive(This,newVal)	\
    (This)->lpVtbl -> put_ColorActive(This,newVal)

#define IMSMFBBtn_get_TextWidth(This,pVal)	\
    (This)->lpVtbl -> get_TextWidth(This,pVal)

#define IMSMFBBtn_get_TextHeight(This,pVal)	\
    (This)->lpVtbl -> get_TextHeight(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ImageStatic_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ImageStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ImageStatic_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_ImageStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ImageHover_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ImageHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ImageHover_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_ImageHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ImagePush_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ImagePush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ImagePush_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_ImagePush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_TransparentBlit_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_TransparentBlit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_TransparentBlit_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ TransparentBlitType newVal);


void __RPC_STUB IMSMFBBtn_put_TransparentBlit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_About_Proxy( 
    IMSMFBBtn __RPC_FAR * This);


void __RPC_STUB IMSMFBBtn_About_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_Disable_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_Disable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_Disable_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFBBtn_put_Disable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_BtnState_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_BtnState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_BtnState_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFBBtn_put_BtnState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ToolTip_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ToolTip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ToolTip_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_ToolTip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_GetDelayTime_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ long delayType,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_GetDelayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_SetDelayTime_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ long delayType,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFBBtn_SetDelayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ResourceDLL_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ResourceDLL_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ToolTipMaxWidth_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ToolTipMaxWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ToolTipMaxWidth_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFBBtn_put_ToolTipMaxWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ImageDisabled_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ImageDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ImageDisabled_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_ImageDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ImageActive_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ImageActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ImageActive_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_ImageActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_FontSize_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_FontSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_FontSize_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFBBtn_put_FontSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_Text_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_Text_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_FontFace_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_FontFace_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_FontStyle_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_FontStyle_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFBBtn_put_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_Windowless_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_Windowless_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFBBtn_put_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_BackColor_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ OLE_COLOR clr);


void __RPC_STUB IMSMFBBtn_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_BackColor_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);


void __RPC_STUB IMSMFBBtn_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ColorPush_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ColorPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ColorPush_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFBBtn_put_ColorPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ColorHover_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ColorHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ColorHover_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFBBtn_put_ColorHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ColorStatic_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ColorStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ColorStatic_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFBBtn_put_ColorStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ColorDisable_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ColorDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ColorDisable_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFBBtn_put_ColorDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_ColorActive_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_ColorActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_put_ColorActive_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFBBtn_put_ColorActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_TextWidth_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_TextWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFBBtn_get_TextHeight_Proxy( 
    IMSMFBBtn __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFBBtn_get_TextHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMFBBtn_INTERFACE_DEFINED__ */


#ifndef __IMSMFImg_INTERFACE_DEFINED__
#define __IMSMFImg_INTERFACE_DEFINED__

/* interface IMSMFImg */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMSMFImg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B0C2A59F-39FA-4D60-BB1E-EBE409E57BAC")
    IMSMFImg : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResourceDLL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ResourceDLL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Windowless( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Windowless( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransparentBlit( 
            /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TransparentBlit( 
            /* [in] */ TransparentBlitType newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMFImgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSMFImg __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSMFImg __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMSMFImg __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackColor )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ OLE_COLOR clr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackColor )( 
            IMSMFImg __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Image )( 
            IMSMFImg __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Image )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceDLL )( 
            IMSMFImg __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ResourceDLL )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windowless )( 
            IMSMFImg __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Windowless )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TransparentBlit )( 
            IMSMFImg __RPC_FAR * This,
            /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TransparentBlit )( 
            IMSMFImg __RPC_FAR * This,
            /* [in] */ TransparentBlitType newVal);
        
        END_INTERFACE
    } IMSMFImgVtbl;

    interface IMSMFImg
    {
        CONST_VTBL struct IMSMFImgVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMFImg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMFImg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMFImg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMFImg_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMFImg_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMFImg_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMFImg_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMFImg_put_BackColor(This,clr)	\
    (This)->lpVtbl -> put_BackColor(This,clr)

#define IMSMFImg_get_BackColor(This,pclr)	\
    (This)->lpVtbl -> get_BackColor(This,pclr)

#define IMSMFImg_get_Image(This,pVal)	\
    (This)->lpVtbl -> get_Image(This,pVal)

#define IMSMFImg_put_Image(This,newVal)	\
    (This)->lpVtbl -> put_Image(This,newVal)

#define IMSMFImg_get_ResourceDLL(This,pVal)	\
    (This)->lpVtbl -> get_ResourceDLL(This,pVal)

#define IMSMFImg_put_ResourceDLL(This,newVal)	\
    (This)->lpVtbl -> put_ResourceDLL(This,newVal)

#define IMSMFImg_get_Windowless(This,pVal)	\
    (This)->lpVtbl -> get_Windowless(This,pVal)

#define IMSMFImg_put_Windowless(This,newVal)	\
    (This)->lpVtbl -> put_Windowless(This,newVal)

#define IMSMFImg_get_TransparentBlit(This,pVal)	\
    (This)->lpVtbl -> get_TransparentBlit(This,pVal)

#define IMSMFImg_put_TransparentBlit(This,newVal)	\
    (This)->lpVtbl -> put_TransparentBlit(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFImg_put_BackColor_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [in] */ OLE_COLOR clr);


void __RPC_STUB IMSMFImg_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFImg_get_BackColor_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);


void __RPC_STUB IMSMFImg_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFImg_get_Image_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFImg_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFImg_put_Image_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFImg_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFImg_get_ResourceDLL_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFImg_get_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFImg_put_ResourceDLL_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFImg_put_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFImg_get_Windowless_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFImg_get_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFImg_put_Windowless_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFImg_put_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFImg_get_TransparentBlit_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [retval][out] */ TransparentBlitType __RPC_FAR *pVal);


void __RPC_STUB IMSMFImg_get_TransparentBlit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFImg_put_TransparentBlit_Proxy( 
    IMSMFImg __RPC_FAR * This,
    /* [in] */ TransparentBlitType newVal);


void __RPC_STUB IMSMFImg_put_TransparentBlit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMFImg_INTERFACE_DEFINED__ */


#ifndef __IMSMFSldr_INTERFACE_DEFINED__
#define __IMSMFSldr_INTERFACE_DEFINED__

/* interface IMSMFSldr */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMSMFSldr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("845F36EE-5C8D-418A-B4D7-7B5468AEDCCC")
    IMSMFSldr : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Min( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Min( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Max( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Max( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ThumbWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ThumbWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ThumbStatic( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ThumbStatic( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ThumbHover( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ThumbHover( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPush( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPush( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ThumbDisabled( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ThumbDisabled( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ThumbActive( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ThumbActive( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackStatic( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BackStatic( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackHover( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BackHover( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackPush( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BackPush( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackDisabled( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BackDisabled( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackActive( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BackActive( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SldrState( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SldrState( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Disable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Disable( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_XOffset( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_XOffset( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_YOffset( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_YOffset( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResourceDLL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ResourceDLL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Windowless( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Windowless( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArrowKeyIncrement( 
            /* [retval][out] */ FLOAT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArrowKeyIncrement( 
            /* [in] */ FLOAT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArrowKeyDecrement( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArrowKeyDecrement( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMFSldrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSMFSldr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSMFSldr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMSMFSldr __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Min )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Min )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Max )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Max )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ThumbWidth )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ThumbWidth )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ThumbStatic )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ThumbStatic )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ThumbHover )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ThumbHover )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ThumbPush )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ThumbPush )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ThumbDisabled )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ThumbDisabled )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ThumbActive )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ThumbActive )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackStatic )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackStatic )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackHover )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackHover )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackPush )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackPush )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackDisabled )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackDisabled )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackActive )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackActive )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SldrState )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SldrState )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Disable )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Disable )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XOffset )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XOffset )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YOffset )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YOffset )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackColor )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ OLE_COLOR clr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackColor )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceDLL )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ResourceDLL )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windowless )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Windowless )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ArrowKeyIncrement )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ FLOAT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ArrowKeyIncrement )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ FLOAT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ArrowKeyDecrement )( 
            IMSMFSldr __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ArrowKeyDecrement )( 
            IMSMFSldr __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IMSMFSldrVtbl;

    interface IMSMFSldr
    {
        CONST_VTBL struct IMSMFSldrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMFSldr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMFSldr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMFSldr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMFSldr_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMFSldr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMFSldr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMFSldr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMFSldr_get_Value(This,pVal)	\
    (This)->lpVtbl -> get_Value(This,pVal)

#define IMSMFSldr_put_Value(This,newVal)	\
    (This)->lpVtbl -> put_Value(This,newVal)

#define IMSMFSldr_get_Min(This,pVal)	\
    (This)->lpVtbl -> get_Min(This,pVal)

#define IMSMFSldr_put_Min(This,newVal)	\
    (This)->lpVtbl -> put_Min(This,newVal)

#define IMSMFSldr_get_Max(This,pVal)	\
    (This)->lpVtbl -> get_Max(This,pVal)

#define IMSMFSldr_put_Max(This,newVal)	\
    (This)->lpVtbl -> put_Max(This,newVal)

#define IMSMFSldr_get_ThumbWidth(This,pVal)	\
    (This)->lpVtbl -> get_ThumbWidth(This,pVal)

#define IMSMFSldr_put_ThumbWidth(This,newVal)	\
    (This)->lpVtbl -> put_ThumbWidth(This,newVal)

#define IMSMFSldr_get_ThumbStatic(This,pVal)	\
    (This)->lpVtbl -> get_ThumbStatic(This,pVal)

#define IMSMFSldr_put_ThumbStatic(This,newVal)	\
    (This)->lpVtbl -> put_ThumbStatic(This,newVal)

#define IMSMFSldr_get_ThumbHover(This,pVal)	\
    (This)->lpVtbl -> get_ThumbHover(This,pVal)

#define IMSMFSldr_put_ThumbHover(This,newVal)	\
    (This)->lpVtbl -> put_ThumbHover(This,newVal)

#define IMSMFSldr_get_ThumbPush(This,pVal)	\
    (This)->lpVtbl -> get_ThumbPush(This,pVal)

#define IMSMFSldr_put_ThumbPush(This,newVal)	\
    (This)->lpVtbl -> put_ThumbPush(This,newVal)

#define IMSMFSldr_get_ThumbDisabled(This,pVal)	\
    (This)->lpVtbl -> get_ThumbDisabled(This,pVal)

#define IMSMFSldr_put_ThumbDisabled(This,newVal)	\
    (This)->lpVtbl -> put_ThumbDisabled(This,newVal)

#define IMSMFSldr_get_ThumbActive(This,pVal)	\
    (This)->lpVtbl -> get_ThumbActive(This,pVal)

#define IMSMFSldr_put_ThumbActive(This,newVal)	\
    (This)->lpVtbl -> put_ThumbActive(This,newVal)

#define IMSMFSldr_get_BackStatic(This,pVal)	\
    (This)->lpVtbl -> get_BackStatic(This,pVal)

#define IMSMFSldr_put_BackStatic(This,newVal)	\
    (This)->lpVtbl -> put_BackStatic(This,newVal)

#define IMSMFSldr_get_BackHover(This,pVal)	\
    (This)->lpVtbl -> get_BackHover(This,pVal)

#define IMSMFSldr_put_BackHover(This,newVal)	\
    (This)->lpVtbl -> put_BackHover(This,newVal)

#define IMSMFSldr_get_BackPush(This,pVal)	\
    (This)->lpVtbl -> get_BackPush(This,pVal)

#define IMSMFSldr_put_BackPush(This,newVal)	\
    (This)->lpVtbl -> put_BackPush(This,newVal)

#define IMSMFSldr_get_BackDisabled(This,pVal)	\
    (This)->lpVtbl -> get_BackDisabled(This,pVal)

#define IMSMFSldr_put_BackDisabled(This,newVal)	\
    (This)->lpVtbl -> put_BackDisabled(This,newVal)

#define IMSMFSldr_get_BackActive(This,pVal)	\
    (This)->lpVtbl -> get_BackActive(This,pVal)

#define IMSMFSldr_put_BackActive(This,newVal)	\
    (This)->lpVtbl -> put_BackActive(This,newVal)

#define IMSMFSldr_get_SldrState(This,pVal)	\
    (This)->lpVtbl -> get_SldrState(This,pVal)

#define IMSMFSldr_put_SldrState(This,newVal)	\
    (This)->lpVtbl -> put_SldrState(This,newVal)

#define IMSMFSldr_get_Disable(This,pVal)	\
    (This)->lpVtbl -> get_Disable(This,pVal)

#define IMSMFSldr_put_Disable(This,newVal)	\
    (This)->lpVtbl -> put_Disable(This,newVal)

#define IMSMFSldr_get_XOffset(This,pVal)	\
    (This)->lpVtbl -> get_XOffset(This,pVal)

#define IMSMFSldr_put_XOffset(This,newVal)	\
    (This)->lpVtbl -> put_XOffset(This,newVal)

#define IMSMFSldr_get_YOffset(This,pVal)	\
    (This)->lpVtbl -> get_YOffset(This,pVal)

#define IMSMFSldr_put_YOffset(This,newVal)	\
    (This)->lpVtbl -> put_YOffset(This,newVal)

#define IMSMFSldr_put_BackColor(This,clr)	\
    (This)->lpVtbl -> put_BackColor(This,clr)

#define IMSMFSldr_get_BackColor(This,pclr)	\
    (This)->lpVtbl -> get_BackColor(This,pclr)

#define IMSMFSldr_get_ResourceDLL(This,pVal)	\
    (This)->lpVtbl -> get_ResourceDLL(This,pVal)

#define IMSMFSldr_put_ResourceDLL(This,newVal)	\
    (This)->lpVtbl -> put_ResourceDLL(This,newVal)

#define IMSMFSldr_get_Windowless(This,pVal)	\
    (This)->lpVtbl -> get_Windowless(This,pVal)

#define IMSMFSldr_put_Windowless(This,newVal)	\
    (This)->lpVtbl -> put_Windowless(This,newVal)

#define IMSMFSldr_get_ArrowKeyIncrement(This,pVal)	\
    (This)->lpVtbl -> get_ArrowKeyIncrement(This,pVal)

#define IMSMFSldr_put_ArrowKeyIncrement(This,newVal)	\
    (This)->lpVtbl -> put_ArrowKeyIncrement(This,newVal)

#define IMSMFSldr_get_ArrowKeyDecrement(This,pVal)	\
    (This)->lpVtbl -> get_ArrowKeyDecrement(This,pVal)

#define IMSMFSldr_put_ArrowKeyDecrement(This,newVal)	\
    (This)->lpVtbl -> put_ArrowKeyDecrement(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_Value_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_Value_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IMSMFSldr_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_Min_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_Min_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_Min_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IMSMFSldr_put_Min_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_Max_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_Max_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_Max_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IMSMFSldr_put_Max_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ThumbWidth_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ThumbWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ThumbWidth_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFSldr_put_ThumbWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ThumbStatic_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ThumbStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ThumbStatic_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_ThumbStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ThumbHover_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ThumbHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ThumbHover_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_ThumbHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ThumbPush_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ThumbPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ThumbPush_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_ThumbPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ThumbDisabled_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ThumbDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ThumbDisabled_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_ThumbDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ThumbActive_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ThumbActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ThumbActive_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_ThumbActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_BackStatic_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_BackStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_BackStatic_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_BackStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_BackHover_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_BackHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_BackHover_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_BackHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_BackPush_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_BackPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_BackPush_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_BackPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_BackDisabled_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_BackDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_BackDisabled_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_BackDisabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_BackActive_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_BackActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_BackActive_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_BackActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_SldrState_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_SldrState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_SldrState_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFSldr_put_SldrState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_Disable_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_Disable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_Disable_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFSldr_put_Disable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_XOffset_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_XOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_XOffset_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFSldr_put_XOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_YOffset_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_YOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_YOffset_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFSldr_put_YOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_BackColor_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ OLE_COLOR clr);


void __RPC_STUB IMSMFSldr_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_BackColor_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);


void __RPC_STUB IMSMFSldr_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ResourceDLL_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ResourceDLL_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFSldr_put_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_Windowless_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_Windowless_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFSldr_put_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ArrowKeyIncrement_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ FLOAT __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ArrowKeyIncrement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ArrowKeyIncrement_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ FLOAT newVal);


void __RPC_STUB IMSMFSldr_put_ArrowKeyIncrement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_get_ArrowKeyDecrement_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IMSMFSldr_get_ArrowKeyDecrement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFSldr_put_ArrowKeyDecrement_Proxy( 
    IMSMFSldr __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IMSMFSldr_put_ArrowKeyDecrement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMFSldr_INTERFACE_DEFINED__ */


#ifndef __IMSMFText_INTERFACE_DEFINED__
#define __IMSMFText_INTERFACE_DEFINED__

/* interface IMSMFText */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMSMFText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5DB6854E-5CA4-4756-BE2F-DD31CE5DF0ED")
    IMSMFText : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FontSize( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FontSize( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FontFace( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FontFace( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FontStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FontStyle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorPush( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorPush( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorHover( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorHover( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorStatic( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorStatic( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorDisable( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorDisable( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorActive( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorActive( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TextState( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TextState( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Disable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Disable( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResourceDLL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ResourceDLL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TextAlignment( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TextAlignment( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EdgeStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EdgeStyle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TextWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TextHeight( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransparentText( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TransparentText( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Windowless( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Windowless( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMFTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSMFText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSMFText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMSMFText __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BackColor )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ OLE_COLOR clr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BackColor )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontSize )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontSize )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Text )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Text )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontFace )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontFace )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontStyle )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontStyle )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorPush )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorPush )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorHover )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorHover )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorStatic )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorStatic )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorDisable )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorDisable )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorActive )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorActive )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextState )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TextState )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Disable )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Disable )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ResourceDLL )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ResourceDLL )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextAlignment )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TextAlignment )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EdgeStyle )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EdgeStyle )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextWidth )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TextHeight )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TransparentText )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TransparentText )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windowless )( 
            IMSMFText __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Windowless )( 
            IMSMFText __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IMSMFTextVtbl;

    interface IMSMFText
    {
        CONST_VTBL struct IMSMFTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMFText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMFText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMFText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMFText_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMFText_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMFText_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMFText_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMFText_put_BackColor(This,clr)	\
    (This)->lpVtbl -> put_BackColor(This,clr)

#define IMSMFText_get_BackColor(This,pclr)	\
    (This)->lpVtbl -> get_BackColor(This,pclr)

#define IMSMFText_get_FontSize(This,pVal)	\
    (This)->lpVtbl -> get_FontSize(This,pVal)

#define IMSMFText_put_FontSize(This,newVal)	\
    (This)->lpVtbl -> put_FontSize(This,newVal)

#define IMSMFText_get_Text(This,pVal)	\
    (This)->lpVtbl -> get_Text(This,pVal)

#define IMSMFText_put_Text(This,newVal)	\
    (This)->lpVtbl -> put_Text(This,newVal)

#define IMSMFText_get_FontFace(This,pVal)	\
    (This)->lpVtbl -> get_FontFace(This,pVal)

#define IMSMFText_put_FontFace(This,newVal)	\
    (This)->lpVtbl -> put_FontFace(This,newVal)

#define IMSMFText_get_FontStyle(This,pVal)	\
    (This)->lpVtbl -> get_FontStyle(This,pVal)

#define IMSMFText_put_FontStyle(This,newVal)	\
    (This)->lpVtbl -> put_FontStyle(This,newVal)

#define IMSMFText_get_ColorPush(This,pVal)	\
    (This)->lpVtbl -> get_ColorPush(This,pVal)

#define IMSMFText_put_ColorPush(This,newVal)	\
    (This)->lpVtbl -> put_ColorPush(This,newVal)

#define IMSMFText_get_ColorHover(This,pVal)	\
    (This)->lpVtbl -> get_ColorHover(This,pVal)

#define IMSMFText_put_ColorHover(This,newVal)	\
    (This)->lpVtbl -> put_ColorHover(This,newVal)

#define IMSMFText_get_ColorStatic(This,pVal)	\
    (This)->lpVtbl -> get_ColorStatic(This,pVal)

#define IMSMFText_put_ColorStatic(This,newVal)	\
    (This)->lpVtbl -> put_ColorStatic(This,newVal)

#define IMSMFText_get_ColorDisable(This,pVal)	\
    (This)->lpVtbl -> get_ColorDisable(This,pVal)

#define IMSMFText_put_ColorDisable(This,newVal)	\
    (This)->lpVtbl -> put_ColorDisable(This,newVal)

#define IMSMFText_get_ColorActive(This,pVal)	\
    (This)->lpVtbl -> get_ColorActive(This,pVal)

#define IMSMFText_put_ColorActive(This,newVal)	\
    (This)->lpVtbl -> put_ColorActive(This,newVal)

#define IMSMFText_get_TextState(This,pVal)	\
    (This)->lpVtbl -> get_TextState(This,pVal)

#define IMSMFText_put_TextState(This,newVal)	\
    (This)->lpVtbl -> put_TextState(This,newVal)

#define IMSMFText_get_Disable(This,pVal)	\
    (This)->lpVtbl -> get_Disable(This,pVal)

#define IMSMFText_put_Disable(This,newVal)	\
    (This)->lpVtbl -> put_Disable(This,newVal)

#define IMSMFText_get_ResourceDLL(This,pVal)	\
    (This)->lpVtbl -> get_ResourceDLL(This,pVal)

#define IMSMFText_put_ResourceDLL(This,newVal)	\
    (This)->lpVtbl -> put_ResourceDLL(This,newVal)

#define IMSMFText_get_TextAlignment(This,pVal)	\
    (This)->lpVtbl -> get_TextAlignment(This,pVal)

#define IMSMFText_put_TextAlignment(This,newVal)	\
    (This)->lpVtbl -> put_TextAlignment(This,newVal)

#define IMSMFText_get_EdgeStyle(This,pVal)	\
    (This)->lpVtbl -> get_EdgeStyle(This,pVal)

#define IMSMFText_put_EdgeStyle(This,newVal)	\
    (This)->lpVtbl -> put_EdgeStyle(This,newVal)

#define IMSMFText_get_TextWidth(This,pVal)	\
    (This)->lpVtbl -> get_TextWidth(This,pVal)

#define IMSMFText_get_TextHeight(This,pVal)	\
    (This)->lpVtbl -> get_TextHeight(This,pVal)

#define IMSMFText_get_TransparentText(This,pVal)	\
    (This)->lpVtbl -> get_TransparentText(This,pVal)

#define IMSMFText_put_TransparentText(This,newVal)	\
    (This)->lpVtbl -> put_TransparentText(This,newVal)

#define IMSMFText_get_Windowless(This,pVal)	\
    (This)->lpVtbl -> get_Windowless(This,pVal)

#define IMSMFText_put_Windowless(This,newVal)	\
    (This)->lpVtbl -> put_Windowless(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_BackColor_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ OLE_COLOR clr);


void __RPC_STUB IMSMFText_put_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_BackColor_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr);


void __RPC_STUB IMSMFText_get_BackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_FontSize_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_FontSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_FontSize_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFText_put_FontSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_Text_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_Text_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFText_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_FontFace_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_FontFace_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFText_put_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_FontStyle_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_FontStyle_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFText_put_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_ColorPush_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_ColorPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_ColorPush_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFText_put_ColorPush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_ColorHover_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_ColorHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_ColorHover_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFText_put_ColorHover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_ColorStatic_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_ColorStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_ColorStatic_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFText_put_ColorStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_ColorDisable_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_ColorDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_ColorDisable_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFText_put_ColorDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_ColorActive_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_ColorActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_ColorActive_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IMSMFText_put_ColorActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_TextState_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_TextState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_TextState_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSMFText_put_TextState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_Disable_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_Disable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_Disable_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFText_put_Disable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_ResourceDLL_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_ResourceDLL_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFText_put_ResourceDLL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_TextAlignment_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_TextAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_TextAlignment_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFText_put_TextAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_EdgeStyle_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_EdgeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_EdgeStyle_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSMFText_put_EdgeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_TextWidth_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_TextWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_TextHeight_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_TextHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_TransparentText_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_TransparentText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_TransparentText_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFText_put_TransparentText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSMFText_get_Windowless_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IMSMFText_get_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSMFText_put_Windowless_Proxy( 
    IMSMFText __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSMFText_put_Windowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMFText_INTERFACE_DEFINED__ */



#ifndef __MSMFCNTLib_LIBRARY_DEFINED__
#define __MSMFCNTLib_LIBRARY_DEFINED__

/* library MSMFCNTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_MSMFCNTLib;

#ifndef ___IMSMFBar_DISPINTERFACE_DEFINED__
#define ___IMSMFBar_DISPINTERFACE_DEFINED__

/* dispinterface _IMSMFBar */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IMSMFBar;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("681537db-4c4e-434a-9bb9-df8083387731")
    _IMSMFBar : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IMSMFBarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IMSMFBar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IMSMFBar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IMSMFBar __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IMSMFBar __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IMSMFBar __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IMSMFBar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IMSMFBar __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IMSMFBarVtbl;

    interface _IMSMFBar
    {
        CONST_VTBL struct _IMSMFBarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IMSMFBar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IMSMFBar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IMSMFBar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IMSMFBar_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IMSMFBar_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IMSMFBar_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IMSMFBar_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IMSMFBar_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMFBar;

#ifdef __cplusplus

class DECLSPEC_UUID("13832181-50FD-4D8D-86C3-0139644E0706")
MSMFBar;
#endif

#ifndef ___IMSMFBBtn_DISPINTERFACE_DEFINED__
#define ___IMSMFBBtn_DISPINTERFACE_DEFINED__

/* dispinterface _IMSMFBBtn */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IMSMFBBtn;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("a391ed89-b4a6-453b-8ea5-d529af4b5770")
    _IMSMFBBtn : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IMSMFBBtnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IMSMFBBtn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IMSMFBBtn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IMSMFBBtn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IMSMFBBtn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IMSMFBBtn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IMSMFBBtn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IMSMFBBtn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IMSMFBBtnVtbl;

    interface _IMSMFBBtn
    {
        CONST_VTBL struct _IMSMFBBtnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IMSMFBBtn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IMSMFBBtn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IMSMFBBtn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IMSMFBBtn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IMSMFBBtn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IMSMFBBtn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IMSMFBBtn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IMSMFBBtn_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMFBBtn;

#ifdef __cplusplus

class DECLSPEC_UUID("7A136DD3-BEBE-47BE-B6D9-E2CC7F816D43")
MSMFBBtn;
#endif

EXTERN_C const CLSID CLSID_MSMFImg;

#ifdef __cplusplus

class DECLSPEC_UUID("34734599-9B11-4456-A607-F906485C31D7")
MSMFImg;
#endif

#ifndef ___IMSMFSldr_DISPINTERFACE_DEFINED__
#define ___IMSMFSldr_DISPINTERFACE_DEFINED__

/* dispinterface _IMSMFSldr */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IMSMFSldr;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("823c1403-53dd-4e82-ba17-5c4afabc9026")
    _IMSMFSldr : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IMSMFSldrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IMSMFSldr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IMSMFSldr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IMSMFSldr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IMSMFSldr __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IMSMFSldr __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IMSMFSldr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IMSMFSldr __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IMSMFSldrVtbl;

    interface _IMSMFSldr
    {
        CONST_VTBL struct _IMSMFSldrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IMSMFSldr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IMSMFSldr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IMSMFSldr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IMSMFSldr_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IMSMFSldr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IMSMFSldr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IMSMFSldr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IMSMFSldr_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMFSldr;

#ifdef __cplusplus

class DECLSPEC_UUID("E2909DE3-0EE0-46E6-9258-E1CFE5AC73F9")
MSMFSldr;
#endif

#ifndef ___IMSMFText_DISPINTERFACE_DEFINED__
#define ___IMSMFText_DISPINTERFACE_DEFINED__

/* dispinterface _IMSMFText */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IMSMFText;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("4981b0dd-5f02-41f0-acff-4617d9c25b45")
    _IMSMFText : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IMSMFTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IMSMFText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IMSMFText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IMSMFText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IMSMFText __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IMSMFText __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IMSMFText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IMSMFText __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IMSMFTextVtbl;

    interface _IMSMFText
    {
        CONST_VTBL struct _IMSMFTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IMSMFText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IMSMFText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IMSMFText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IMSMFText_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IMSMFText_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IMSMFText_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IMSMFText_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IMSMFText_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMFText;

#ifdef __cplusplus

class DECLSPEC_UUID("F2A6C42D-5515-4013-85F4-1EC3D33950DA")
MSMFText;
#endif
#endif /* __MSMFCNTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfcntcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSMFCNTCP_H_
#define _MSMFCNTCP_H_


template <class T>
class CProxy_IMSMFBBtn : public IConnectionPointImpl<T, &DIID__IMSMFBBtn, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
};

template <class T>
class CProxy_IMSMFSldr : public IConnectionPointImpl<T, &DIID__IMSMFSldr, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnValueChange(FLOAT flNewVal)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = flNewVal;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnMouseDown()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnMouseUp()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
};

template <class T>
class CProxy_IMSMFText : public IConnectionPointImpl<T, &DIID__IMSMFText, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
};





template <class T>
class CProxy_IMSMFBar : public IConnectionPointImpl<T, &DIID__IMSMFBar, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnResize(LONG lWidth, LONG lHeight, LONG lCode)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = lWidth;
				pvars[1] = lHeight;
				pvars[0] = lCode;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnHelp(BSTR strObjectID, BSTR strExtraInfo = ::SysAllocString(L""))
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = strObjectID;
				pvars[0] = strExtraInfo;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnKeyUp(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnKeyDown(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ActivityDeclined()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_ActivityStarted()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_Timeout(LONG lTimerID)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = lTimerID;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnDblClick()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_OnSysKeyUp(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0xa, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnSysKeyDown(LONG lVirtKey, LONG lKeyData)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = lVirtKey;
				pvars[0] = lKeyData;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0xb, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReadyStateChange(LONG ReadyState)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = ReadyState;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(DISPID_READYSTATECHANGE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfbbtn.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFBBtn.cpp                                                    */
/* Description: Implementation of CMSMFBBtn Bitmap Button                */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFBBtn.h"
#include <commctrl.h>
#include "ocidl.h"	// Added by ClassView
extern CComModule _Module;

/////////////////////////////////////////////////////////////////////////////
// CMSMFBBtn
/*************************************************************************/
/* Function:  CMSMFBBtn                                                  */
/*************************************************************************/
CMSMFBBtn::CMSMFBBtn(){

    Init();    
    for(INT i = 0; i < cgMaxBtnStates; i++){

	    m_pBitmap[i] = new CBitmap;
    }/* end of for loop */
}/* end of function CMSMFBBtn */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes variable states.                             */
/*************************************************************************/
void CMSMFBBtn::Init(){

    m_nEntry = BtnState::Static;    
    m_hWndTip = NULL;
    m_nTTMaxWidth = 200;
    m_bTTCreated = FALSE;

    m_fDirty = true;   // to refresh text property, font etc.
    m_uiFontSize = 10;
    m_bstrTextValue = L"";
    m_bstrFontFace = L"Arial";
    m_bstrFontStyle = L"Normal";
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    m_clrColorActive = 0x00ff0000; // blue
    m_clrColorStatic = 0x00000000; // black
    m_clrColorHover = 0x00ff0000;  // blue
    m_clrColorPush = 0x00ffffff;   // white
    m_clrColorDisable = 0x00808080; // grey
   
#if 0 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
#endif
}/* end of function Init */

/*************************************************************************/
/* Function: ~CMSMFBBtn                                                  */
/* Description: Cleanup the bitmap and pallete arrays, unload resource   */
/* DLL.                                                                  */
/*************************************************************************/
CMSMFBBtn::~CMSMFBBtn(){

    for(INT i = 0; i < cgMaxBtnStates; i++){
        if (m_pBitmap[i]){

            delete m_pBitmap[i];
            m_pBitmap[i] = NULL;
        }/* end of if statement */
        //CComBSTR m_bstrFilename[..] should get destructed on the stack
    }/* end of for loop */

    Init();
}/* end of function ~CMSMFBBtn */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Does the basic drawing                                   */
/*************************************************************************/
HRESULT CMSMFBBtn::OnDraw(ATL_DRAWINFO& di){

    USES_CONVERSION;
	RECT& rc = *(RECT*)di.prcBounds;
    HRESULT hr = S_OK;

    if (m_pBitmap[m_nEntry]){
        BOOL bRet;

        if (::IsWindow(m_hWnd) && m_blitType != DISABLE) {

            
            // TODO: Optimaze palette handling
#if 0
            HPALETTE hNewPal = m_pBitmap[m_nEntry]->GetPal();

            if(hNewPal){

                HPALETTE hPal = ::SelectPalette(di.hdcDraw, hNewPal, TRUE);
                ::RealizePalette(di.hdcDraw);
            }/* end of if statement */
#endif
            
            COLORREF clr;
            HPALETTE hNewPal = m_pBitmap[m_nEntry]->GetPal();
            ::OleTranslateColor (m_clrBackColor, hNewPal, &clr);        
            
            // fill background of specific color
            HBRUSH hbrBack = ::CreateSolidBrush(clr);            
            //::FillRect(hdc, &rcClient, hbrBack);
            ::FillRect(di.hdcDraw, (LPRECT)di.prcBounds, hbrBack);
            ::DeleteObject(hbrBack);
        }

        bRet = m_pBitmap[m_nEntry]->PaintTransparentDIB(di.hdcDraw, NULL, 
            (LPRECT) di.prcBounds, m_blitType, FALSE, m_hWnd);
        
        if (m_fDirty)
        {
            SetTextProperties();
        }

        hr = m_cText.Write(di.hdcDraw, rc, m_bstrTextValue);

        hr = GetFocus();

        // THIS ASSUMES WE ARE REPAINTING THE WHOLE CONTROL
        // WHICH IS WHAT ATL AT THIS INCARNATION DOES
        if(S_OK == hr){

            ::DrawFocusRect(di.hdcDraw, (LPRECT)di.prcBounds);
        }/* end of if statement */

        if(!bRet){

            hr = E_UNEXPECTED;
        }/* end of if statement */
    }/* end of if statement */
	
	return (hr);
}/* end of function OnDraw */

/*************************************************************************/
/* Function: SetTextProperties                                           */
/* Description: Set the properties for the CText object.                 */
/*************************************************************************/
HRESULT CMSMFBBtn::SetTextProperties()
{
    HRESULT hr = S_OK;

    m_cText.SetFontFace(m_bstrFontFace);
    m_cText.SetFontSize(m_uiFontSize);
    m_cText.SetFontStyle(m_bstrFontStyle);
    m_cText.SetFixedSizeFont(true);

    // set the font color based on the current state

    OLE_COLOR clrColorCurrent = m_clrColorStatic;
    switch(m_nEntry)
    {
        case(BtnState::Static):
            clrColorCurrent = m_clrColorStatic;
            break;
        case(BtnState::Hover):
            clrColorCurrent = m_clrColorHover;
            break;
        case(BtnState::Active):
            clrColorCurrent = m_clrColorActive;
            break;
        case(BtnState::Push):
            clrColorCurrent = m_clrColorPush;
            break;
        case(BtnState::Disabled):
            clrColorCurrent = m_clrColorDisable;
            break;
    }

    // translate OLE_COLOR to COLORREF
    COLORREF crCurrentState;

    hr = OleTranslateColor(clrColorCurrent, NULL, &crCurrentState);

    if (FAILED(hr))
    {
        crCurrentState = GetSysColor(COLOR_WINDOWTEXT);
    }
    
    m_cText.SetTextColor(crCurrentState);

    m_fDirty = false;

    return hr;
}


STDMETHODIMP CMSMFBBtn::get_TextWidth(long *pVal)
{
    // special case early return
    if (m_bstrTextValue.Length() == 0)
    {
        *pVal = 0;
        return S_OK;
    }

    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    *pVal = size.cx;

    ::ReleaseDC(hwnd, hdc); // do not forget to free DC

	return S_OK;
}

STDMETHODIMP CMSMFBBtn::get_TextHeight(long *pVal)
{
    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    *pVal = size.cy;

    ::ReleaseDC(hwnd, hdc); // do not forget to free DC

	return S_OK;
}

/*************************************************************************/
/* Function: get_ColorPush                                               */
/* Description: return the ColorPush property.                           */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorPush(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorPush;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Push state.                                                    */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorPush(OLE_COLOR clrColor)
{
    m_clrColorPush = clrColor;

    if (m_nEntry == BtnState::Push)
    {
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_ColorHover                                              */
/* Description: return the ColorHover property.                          */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorHover(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorHover;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorHover                                              */
/* Description: set the ColorHover property. This is the color of text   */
/* in the Hover state.                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorHover(OLE_COLOR clrColor)
{
    m_clrColorHover = clrColor;

    if (m_nEntry == BtnState::Hover)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorStatic                                             */
/* Description: return the ColorStatic property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorStatic(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorStatic;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Static (normal) state.                                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorStatic(OLE_COLOR clrColor)
{
    m_clrColorStatic = clrColor;

    if (m_nEntry == BtnState::Static)
    {
        m_fDirty = true;
    }
	
    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorDisable                                            */
/* Description: return the ColorDisable property.                        */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorDisable(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorDisable;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorDisable                                            */
/* Description: set the ColorDisable property. This is the color of text */
/* in the Disabled state.                                                */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorDisable(OLE_COLOR clrColor)
{
    m_clrColorDisable = clrColor;

    if (m_nEntry == BtnState::Disabled)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorActive                                             */
/* Description: return the ColorActive property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ColorActive(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorActive;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorActive                                             */
/* Description: set the ColorActive property. This is the color of text  */
/* in the Active state.                                                  */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ColorActive(OLE_COLOR clrColor)
{
    m_clrColorActive = clrColor;

    if (m_nEntry == BtnState::Active)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_FontSize                                                */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_FontSize(long *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_uiFontSize;

	return S_OK;
}


/*************************************************************************/
/* Function: put_FontSize                                                */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_FontSize(long lSize)
{
    if ((UINT)lSize != m_uiFontSize)
    {
        m_uiFontSize = (UINT)lSize;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_Text                                                    */
/* Description: return the Text that is displayed in the control.        */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_Text(BSTR *pText)
{
    if (!pText)
    {
        return E_POINTER;
    }

    *pText = m_bstrTextValue.Copy();

    return S_OK;
}


/*************************************************************************/
/* Function: put_Text                                                    */
/* Description: set the text to be displayed in the control.             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_Text(BSTR wsText)
{
    if (_wcsicmp(m_bstrTextValue, wsText) != 0)
    {
        m_bstrTextValue = wsText;
        FireViewChange();
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontFace                                                */
/* Description: return the FontFace property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_FontFace(BSTR *pFontFace)
{
    if (!pFontFace)
    {
        return E_POINTER;
    }

    *pFontFace = m_bstrFontFace.Copy();
    
	return S_OK;
}


/*************************************************************************/
/* Function: put_FontFace                                                */
/* Description: set the FontFace property.                               */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_FontFace(BSTR wsFontFace)
{
    if (_wcsicmp(m_bstrFontFace, wsFontFace) != 0)
    {
        m_bstrFontFace = wsFontFace;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontStyle                                               */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_FontStyle(BSTR *pFontStyle)
{
    if (!pFontStyle)
    {
        return E_POINTER;
    }

    *pFontStyle = m_bstrFontStyle.Copy();
    
    return S_OK;
}


/*************************************************************************/
/* Function: put_FontStyle                                               */
/* Description: set the FontStyle property. The style string should      */
/* contain either "Normal", or concatenation of one or more strings of:  */
/* "Bold", "Italic", "Underline", "Strikeout". Default is "Normal".      */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_FontStyle(BSTR wsFontStyle)
{
    if (_wcsicmp(m_bstrFontStyle, wsFontStyle) != 0)
    {
        m_bstrFontStyle = wsFontStyle;
        m_fDirty = true;
    }

    return S_OK;
}

/*************************************************************************/
/* Function: get_ImageStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageStatic(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Static].Copy();
	return S_OK;
}/* end of function get_ImageStatic */

/*************************************************************************/
/* Function: put_ImageStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageStatic(BSTR strFilename){

    if (!m_bstrFilename[BtnState::Disabled])
        PutImage(strFilename, BtnState::Disabled);
	return (PutImage(strFilename, BtnState::Static));
}/* end of function put_ImageStatic */

/*************************************************************************/
/* Function: get_ImageHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageHover(BSTR *pstrFilename){

    *pstrFilename = m_bstrFilename[BtnState::Hover].Copy();    
    return S_OK;
}/* end of function get_ImageHover */

/*************************************************************************/
/* Function: put_ImageHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageHover(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Hover));
}/* end of function put_ImageHover */

/*************************************************************************/
/* Function: get_ImagePush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImagePush(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Push].Copy();    
    return S_OK;
}/* end of function get_ImagePush */

/*************************************************************************/
/* Function: put_ImagePush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImagePush(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Push));
}/* end of function put_ImagePush */

/*************************************************************************/
/* Function: get_ImageDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageDisabled(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Disabled].Copy();    
    return S_OK;
}/* end of function get_ImagePush */

/*************************************************************************/
/* Function: put_ImageDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageDisabled(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Disabled));
}/* end of function put_ImagePush */

/*************************************************************************/
/* Function: get_ImageActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ImageActive(BSTR *pstrFilename){

	*pstrFilename = m_bstrFilename[BtnState::Active].Copy();    
    return S_OK;
}/* end of function get_ImagePush */

/*************************************************************************/
/* Function: put_ImageActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ImageActive(BSTR strFilename){

	return (PutImage(strFilename, BtnState::Active));
}/* end of function put_ImagePush */

/*************************************************************************/
/* Function: PutImage                                                    */
/* Description: Reads the DIB file (from file or resource) into a DIB,   */
/* updates palette and rects of the internal bitmap.                     */
/* Also forces redraw if changing the active image.                      */
/*************************************************************************/
HRESULT CMSMFBBtn::PutImage(BSTR strFilename, int nEntry){

	USES_CONVERSION;
    HRESULT hr = S_OK;

	m_bstrFilename[nEntry] = strFilename;

    TCHAR strBuffer[MAX_PATH] = TEXT("\0");

     bool fGrayOut = false;

    if(BtnState::Disabled == nEntry){

        fGrayOut = gcfGrayOut;
    }/* end of if statement */

    hr = m_pBitmap[nEntry]->PutImage(strFilename, m_hRes, GetUnknown(),fGrayOut ,m_blitType);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(nEntry == m_nEntry ){
        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function PutImage */

/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Handles when buttons is selected. Captures the mouse     */
/* movents (supported for windowless, via interfaces).                   */
/*************************************************************************/
LRESULT CMSMFBBtn::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == BtnState::Disabled){
        
        return 0;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if(PtOnButton(xPos, yPos)){

        // we are really on the buttons bitmap and we pushed it

        if(BtnState::Hover !=  m_nEntry){
            // in hover case we already have captured the mouse, so do not do
            // that again
            SetCapture(true); // capture the mouse messages
        }/* end of if statement */

	    SetButtonState(BtnState::Push);
    }/* end of if statement */

	return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Releases the capture, updates the button visual state,   */
/* and if release on the buttons image fire the event.                   */
/*************************************************************************/
LRESULT CMSMFBBtn::OnButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    LONG lRes = 0;

    if (m_nEntry == BtnState::Disabled){

        ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);
        
        return lRes;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool bOnButtonImage = PtOnButton(xPos, yPos);
    bool bFire = (m_nEntry == BtnState::Push);
	
    if(bOnButtonImage){

        SetButtonState(BtnState::Static); //change to static even 
        SetCapture(false); // release the capture of the mouse messages
    }
    else {

        SetButtonState(BtnState::Static);
        // do it only when we do not hower, if we hower, then keep the capture
        SetCapture(false); // release the capture of the mouse messages
    }/* end of if statement */

    if (bFire){

        if(bOnButtonImage){

            Fire_OnClick();
        }/* end of if statement */
    }/* end of if statement */

    ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);

	return lRes;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSMFBBtn::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == BtnState::Disabled)
        return 0;

	LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if (m_nEntry != BtnState::Push){    
    
        if(PtOnButton(xPos, yPos)){
            if(BtnState::Hover != m_nEntry || S_OK != GetCapture()){

                SetCapture(true); // capture the mouse messages
		        SetButtonState(BtnState::Hover);
            }/* end of if statement */
        }
        else {

            if(BtnState::Static != m_nEntry){

                SetCapture(false); // release the capture of the mouse messages
		        SetButtonState(BtnState::Static);
            }/* end of if statement */
        }/* end of if statement */
	}/* end of if statement */

	return 0;
}/* end of function OnMouseMove */

/*************************************************************************/
/* Function: OnMouseToolTip                                              */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSMFBBtn::OnMouseToolTip(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    MSG mssg;
    mssg.hwnd = GetWindow();
    ATLASSERT(mssg.hwnd);
    mssg.message = msg;
    mssg.wParam = wParam;
    mssg.lParam = lParam;
    if (m_hWndTip)
        ::SendMessage(m_hWndTip, TTM_RELAYEVENT, 0, (LPARAM) &mssg); 
    bHandled = FALSE;
    return 0;
}/* end of function OnMouseToolTip */

/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFBBtn::OnSetFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == BtnState::Disabled){

        if(GetFocus() == S_OK){

            SetFocus(false);
        }/* end of if statement */

        FireViewChange();
        return(-1);
    }/* end of if statement */

    FireViewChange();
    return 0;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: OnKillFocus                                                 */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFBBtn::OnKillFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    FireViewChange();
    return 0;
}/* end of function OnKillFocus */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFBBtn::PtOnButton(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnButton(pos));
}/* end of function PtOnButton */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Determines if the point is located on the button.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFBBtn::PtOnButton(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    //TODO: Add also if we are on bitmap itsels possibly

#ifdef _DEBUG
if(bRet)
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d in Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
else
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d NOT ON RECT Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
#endif

    return(bRet);
}/* end of function PtOnButton */

/*************************************************************************/
/* Function: OnKeyDown                                                   */
/* Description: Depresses the button.                                    */
/*************************************************************************/
LRESULT CMSMFBBtn::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    LONG lRes = 0;

    if (m_nEntry == BtnState::Disabled){
        
        return 0;
    }/* end of if statement */


    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 

            SetButtonState(BtnState::Push);

            break;
    }/* end of if statement */    
    return(lRes);
}/* end of function OnKeyDown */

/*************************************************************************/
/* Function: OnKeyUp                                                     */
/* Description: Distrubutes the keyboard messages properly.              */
/*************************************************************************/
LRESULT CMSMFBBtn::OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    LONG lRes = 0;

    if (m_nEntry == BtnState::Disabled){
        
        return 0;
    }/* end of if statement */

    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 

            Fire_OnClick();

            SetButtonState(BtnState::Static);

            break;
    }/* end of if statement */    
    return(lRes);
}/* end of function OnKeyUp */

/*************************************************************************/
/* Function: OnSize                                                      */
/* Description: Invalidate region since size has changed                 */
/*************************************************************************/
LRESULT CMSMFBBtn::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    InvalidateRgn();
    return 0;
}

/*************************************************************************/
/* Function: SetButtonState                                              */
/* Description: Sets the button states forces redraw.                    */
/*************************************************************************/
HRESULT CMSMFBBtn::SetButtonState(BtnState btnState){

    HRESULT hr = S_OK;

    bool fRedraw = false;
    
    if(btnState != m_nEntry ){

        fRedraw = true;
    }/* end of if statement */

    m_nEntry = btnState;    
    
    if(fRedraw){

        if (m_nEntry == BtnState::Disabled){
            
            SetFocus(false); // disable the focus
            SetCapture(false);
        }/* end of if statement */

        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        m_fDirty = true;  // to force an update of font color
	    FireViewChange(); // update the display
        //InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function SetButtonState */

/*************************************************************************/
/* Function: About                                                       */
/* Description: Displays the AboutBox                                    */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::About(){

	 HRESULT hr = S_OK;

     const INT ciMaxBuffSize = MAX_PATH; // enough for the text
     TCHAR strBuffer[ciMaxBuffSize];
     TCHAR strBufferAbout[ciMaxBuffSize];

     if(!::LoadString(_Module.m_hInstResource, IDS_BTN_ABOUT, strBuffer, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

     if(!::LoadString(_Module.m_hInstResource, IDS_ABOUT, strBufferAbout, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

    ::MessageBox(::GetFocus(), strBuffer, strBufferAbout, MB_OK);

	return (hr);
}/* end of function About */

/*************************************************************/
/* Function: get_Disable                                     */
/* Description: Returns OLE-BOOL if disabled or enabled.     */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::get_Disable(VARIANT_BOOL *pVal){

    *pVal =  BtnState::Disabled == m_nEntry ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}/* end of function get_Disable */

/*************************************************************/
/* Function: put_Disable                                     */
/* Description: Disable or enable the buttons (disabled      */
/* are greyed out and do not except mouse clicks).           */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::put_Disable(VARIANT_BOOL newVal){

    // TODO: Right Now We Get Restored Automatically into Static state
    // we could detect the mouse and see if we are in static 
    // or hower state
    BtnState  btnSt =  VARIANT_FALSE == newVal ? BtnState::Static : BtnState::Disabled;	
    HRESULT hr = SetButtonState(btnSt);

	return (hr);
}/* end of function put_Disable */

/*************************************************************/
/* Function: get_BtnState                                    */
/* Description: Gets current button state.                   */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::get_BtnState(long *pVal){

    *pVal =  (long) m_nEntry;
	return S_OK;
}/* end of function get_BtnState */

/*************************************************************/
/* Function: put_BtnState                                    */
/* Description: Sets the button state manually.              */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::put_BtnState(long newVal){

    HRESULT hr = SetButtonState((BtnState)newVal);
	return(hr);
}/* end of function put_BtnState */

/*************************************************************/
/* Name: get_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::get_ToolTip(BSTR *pVal){

	*pVal = m_bstrToolTip.Copy();
    return 0;
}/* end of function get_ToolTip */

/*************************************************************/
/* Name: put_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*  Cache the tooltip string if there is no window available */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::put_ToolTip(BSTR newVal){

    m_bstrToolTip = newVal;
    return CreateToolTip();
}

/*************************************************************/
/* Name: SetObjectRects                                      */
/* Description: Update tooltip rect object is being moved    */
/*************************************************************/
STDMETHODIMP CMSMFBBtn::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){

    // Call the default method first
    IOleInPlaceObjectWindowlessImpl<CMSMFBBtn>::SetObjectRects(prcPos, prcClip);

    if (!m_hWndTip) return S_OK;

    HWND hwnd = GetWindow();
    if (!hwnd) return S_FALSE;

    TOOLINFO ti;        // tool information 
    ti.cbSize = sizeof(TOOLINFO); 
    ti.uFlags = 0; 
    ti.hwnd = hwnd; 
    ti.hinst = _Module.GetModuleInstance(); 
    ti.uId = (UINT) 0; 
    ti.rect = *prcPos;  // new tooltip position

    if (!SendMessage(m_hWndTip, TTM_NEWTOOLRECT, 0, 
        (LPARAM) (LPTOOLINFO) &ti)) 
        return S_FALSE; 

    return S_OK;
}/* end of function SetObjectRects */

/*************************************************************/
/* Name: OnPostVerbInPlaceActivate
/* Description: Overwrite IOleObjectImp::OnPostVerbInPlaceActivate
/*  to actually create the tooltip for the button
/*************************************************************/
HRESULT CMSMFBBtn::OnPostVerbInPlaceActivate(){

    // Return if tooltip is already created
    if (m_bTTCreated) return S_OK;

    HRESULT hr = CreateToolTip();
    if (SUCCEEDED(hr))
        m_bTTCreated = TRUE;
    
    return hr;
}/* end of function OnPostVerbInPlaceActivate */

/*************************************************************/
/* Name: CreateToolTip
/* Description: create a tool tip for the button
/*************************************************************/
HRESULT CMSMFBBtn::CreateToolTip(void){

    HWND hwnd = GetWindow();
    if (!hwnd) return S_FALSE;

 	USES_CONVERSION;
    // If tool tip is to be created for the first time
    if (m_hWndTip == (HWND) NULL) {
        // Ensure that the common control DLL is loaded, and create 
        // a tooltip control. 
        InitCommonControls(); 
        
        m_hWndTip = CreateWindow(TOOLTIPS_CLASS, (LPCTSTR) NULL, TTS_ALWAYSTIP, 
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
            hwnd, (HMENU) NULL, _Module.GetModuleInstance(), NULL); 
    }

    if (m_hWndTip == (HWND) NULL) 
        return S_FALSE; 
 
    TOOLINFO ti;    // tool information 
    ti.cbSize = sizeof(TOOLINFO); 
    ti.uFlags = 0; 
    ti.hwnd = hwnd; 
    ti.hinst = _Module.GetModuleInstance(); 
    ti.uId = (UINT) 0; 
    ti.lpszText = OLE2T(m_bstrToolTip); 

    // if the button is a windowed control, the tool tip is added to 
    // the button's own window, and the tool tip area should just be
    // the client rect of the window
    if (hwnd == m_hWnd)
        ::GetClientRect(hwnd, &ti.rect);

    // otherwise the tool tip is added to the closet windowed parent of
    // the button, and the tool tip area should be the relative postion
    // of the button in the parent window
    else {
        ti.rect.left = m_rcPos.left; 
        ti.rect.top = m_rcPos.top; 
        ti.rect.right = m_rcPos.right; 
        ti.rect.bottom = m_rcPos.bottom; 
    }

    if (!SendMessage(m_hWndTip, TTM_ADDTOOL, 0, 
        (LPARAM) (LPTOOLINFO) &ti)) 
        return S_FALSE; 

    // Set initial delay time
    put_ToolTipMaxWidth(m_nTTMaxWidth);
    SetDelayTime(TTDT_AUTOPOP, 10000); 
    SetDelayTime(TTDT_INITIAL, 10);

    return S_OK;
}/* end of function CreateToolTip */

/*************************************************************/
/* Name: GetDelayTime
/* Description: Get the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
STDMETHODIMP CMSMFBBtn::GetDelayTime(long delayType, long *pVal){

    if (delayType>TTDT_INITIAL || delayType<TTDT_RESHOW)
        return S_FALSE;

    if (m_hWndTip)
        *pVal = SendMessage(m_hWndTip, TTM_GETDELAYTIME, 
            (WPARAM) (DWORD) delayType, 0);
	return S_OK;
}/* end of function GetDelayTime */

/*************************************************************/
/* Name: SetDelayTime
/* Description: Set the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_AUTOMATIC          0
/*              TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
STDMETHODIMP CMSMFBBtn::SetDelayTime(long delayType, long newVal){

    if (delayType>TTDT_INITIAL || delayType<TTDT_AUTOMATIC)
        return S_FALSE;

    if (m_hWndTip) {
        if (!SendMessage(m_hWndTip, TTM_SETDELAYTIME, 
            (WPARAM) (DWORD) delayType, 
            (LPARAM) (INT) newVal))
            return S_FALSE; 
    }
	return S_OK;
}/* end of function SetDelayTime */

/*************************************************************************/
/* Function: get_ToolTipMaxWidth                                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::get_ToolTipMaxWidth(long *pVal){

    if (m_hWndTip){

        *pVal = ::SendMessage(m_hWndTip, TTM_GETMAXTIPWIDTH, 0, 0);
    }/* end of if statement */

	return S_OK;
}/* end of function get_ToolTipMaxWidth */

/*************************************************************************/
/* Function: put_ToolTipMaxWidth                                         */
/*************************************************************************/
STDMETHODIMP CMSMFBBtn::put_ToolTipMaxWidth(long newVal){

    m_nTTMaxWidth = newVal;
    if (m_hWndTip){

        ::SendMessage(m_hWndTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)(INT) newVal);
    }/* end of if statement */

	return S_OK;
}/* end of function put_ToolTipMaxWidth */

/*************************************************************************/
/* End of file: MSMFBBtn.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\mfbar.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MFBar.h                                                         */
/* Description: Declaration of CMFBar                                    */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MFBAR_H_
#define __MFBAR_H_

#include "resource.h"       // main symbols
#include "MSMFCnt.h"
#include <atlctl.h>
#include <activscp.h>
#include <list>
#include "chobj.h"
#include "eobj.h"
#include "cbitmap.h"
#include "CstUtils.h"
#include "MSMFCntCP.h"

using namespace std;

/*************************************************************************/
/* Template list containing contained objects.                           */
/*************************************************************************/
typedef list<CHostedObject*> CNTOBJ;
typedef list<CEventObject*> CNTEVNT;

/*************************************************************************/
/* Class: CMFBar                                                         */
/*************************************************************************/
class ATL_NO_VTABLE CMFBar : 
	public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CMFBar, IMSMFBar, &IID_IMSMFBar, &LIBID_MSMFCNTLib>,
	//public IDispatchImpl<IMFBar, &IID_IMFBar, &LIBID_BBTNLib>,
	public CComControl<CMFBar>,
	public IPersistStreamInitImpl<CMFBar>,
	public IOleControlImpl<CMFBar>,
	public IOleObjectImpl<CMFBar>,
	public IOleInPlaceActiveObjectImpl<CMFBar>,
	public IViewObjectExImpl<CMFBar>,
	public IOleInPlaceObjectWindowlessImpl<CMFBar>,
    public IPersistPropertyBagImpl<CMFBar>,
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
    public IActiveScriptSite, 
    public IActiveScriptSiteWindow,
    // public IProvideMultipleClassInfo, // Implemented via template above
// #####  END  ACTIVEX SCRIPTING SUPPORT #####
    public IObjectSafetyImpl<CMFBar, INTERFACESAFE_FOR_UNTRUSTED_CALLER| INTERFACESAFE_FOR_UNTRUSTED_DATA>,    
    //public IProvideMultipleClassInfoImpl<CMFBar, &CLSID_MFBar, &DIID__MFBar, &LIBID_BBTNLib>,
    public IProvideClassInfo2Impl<&CLSID_MSMFBar, &DIID__IMSMFBar, &LIBID_MSMFCNTLib>,
// ####  BEGIN CONTAINER SUPPORT ####
    public IOleClientSite,
    public IOleContainer,
    public IOleInPlaceFrame,
    public IOleControlSite,
    public IOleInPlaceSiteWindowless,
// ####  END CONTAINER SUPPORT ####
	public CComCoClass<CMFBar, &CLSID_MSMFBar>,
    public IConnectionPointContainerImpl<CMFBar>,    
    public CProxy_IMSMFBar<CMFBar>,
    public CMSMFCntrlUtils<CMFBar> // custom utilities we share across controls
{
public:
    CMFBar(){Init();};
    virtual ~CMFBar();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFBAR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMFBar)
	COM_INTERFACE_ENTRY(IMSMFBar)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
    COM_INTERFACE_ENTRY(IActiveScriptSite)
    COM_INTERFACE_ENTRY(IActiveScriptSiteWindow)
   // COM_INTERFACE_ENTRY(IProvideMultipleClassInfo)
// #####  END  ACTIVEX SCRIPTING SUPPORT #####
	COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
// ####  BEGIN CONTAINER SUPPORT ####
    COM_INTERFACE_ENTRY(IOleClientSite)
    COM_INTERFACE_ENTRY(IOleContainer)
    COM_INTERFACE_ENTRY(IOleInPlaceFrame)
	COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)	
    COM_INTERFACE_ENTRY(IOleControlSite)    
    COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
	COM_INTERFACE_ENTRY(IOleInPlaceSite)
// ####  END CONTAINER SUPPORT #### 
END_COM_MAP()

BEGIN_PROP_MAP(CMFBar)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("TransparentBlitType", 20, CLSID_NULL)
    PROP_ENTRY("ScriptFile", 10, CLSID_NULL) 
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("Window", DISPID_HWND, CLSID_NULL)              
    PROP_ENTRY("Caption", DISPID_CAPTION, CLSID_NULL)
    PROP_ENTRY("ResourceDLL", 32, CLSID_NULL)    
    PROP_ENTRY("BackgroundImage", 19, CLSID_NULL)
    PROP_ENTRY("AutoLoad", 25, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)    
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CMFBar)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_ERASEBKGND,  OnErase)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_SIZING, OnSizing)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)
    MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
    MESSAGE_HANDLER(WM_SETICON, OnSetIcon)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnHelp)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnQueryNewPalette)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
    MESSAGE_RANGE_HANDLER(WM_KEYFIRST, WM_KEYLAST, OnKeyMessage)
    MESSAGE_HANDLER(WM_USER_FOCUS, OnUserFocus)
    // add m_bMessageReflect
    lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled);
	if(bHandled) return TRUE;
    MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
	CHAIN_MSG_MAP(CComControl<CMFBar>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSizing(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysCommand(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCaptureChanged(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnHelp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetIcon(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled);
    LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled);
    LRESULT OnUserFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
   	LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/);
    LRESULT OnQueryNewPalette(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

BEGIN_CONNECTION_POINT_MAP(CMFBar)
	CONNECTION_POINT_ENTRY(DIID__IMSMFBar)
END_CONNECTION_POINT_MAP()

// IMFBar
public:
	STDMETHOD(Load)();
    STDMETHOD(Run)(BSTR strStatement);
	STDMETHOD(About)();
    STDMETHOD(CreateObject)(BSTR strObjectID, BSTR strProgID, long lx, long ly, long lWidth, 
        long lHeight,BSTR strPropBag, VARIANT_BOOL fDisabled, BSTR strScriptHook);
    STDMETHOD(ShowSelfSite)(long nCmd); 
    STDMETHOD(SetupSelfSite)(long lx, long ly, long lWitdh, long lHeight, BSTR strPropBag, 
        VARIANT_BOOL fDisabled, VARIANT_BOOL fHelpDisabled,VARIANT_BOOL fWindowDisabled);
    STDMETHOD(AddObject)(BSTR strObjectID, LPDISPATCH pDisp);
    STDMETHOD(AddScriptlet)(BSTR strObjectID, BSTR strEvent, BSTR strEventCode);
    STDMETHOD(EnableObject)(BSTR strObjectID, VARIANT_BOOL fEnable);
   	STDMETHOD(ObjectEnabled)(BSTR strObjectID, VARIANT_BOOL* pfEnabled);
   	STDMETHOD(SetObjectPosition)(BSTR strObjectID, long xPos, long yPos, long lWidth, long lHeight);
    STDMETHOD(GetObjectPosition)(BSTR strObjectID, long* pxPos, long* pyPos, long* plWidth, long* plHeight);
	STDMETHOD(GetObjectUnknown)(BSTR strObjectID, IUnknown** ppUnk);
   	STDMETHOD(get_ScriptFile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ScriptFile)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ScriptLanguage)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ScriptLanguage)(/*[in]*/ BSTR newVal);    
    STDMETHOD(HookScriptlet)(BSTR strObjectID, BSTR strEvent, BSTR strEventCode);
	STDMETHOD(DestroyScriptEngine)();
    STDMETHOD(get_MinHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_MinHeight)(/*[in]*/ long newVal);
	STDMETHOD(get_MinWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_MinWidth)(/*[in]*/ long newVal);
    STDMETHOD(put_Caption)(BSTR bstrCaption);
   	STDMETHOD(WinHelp)(long lCommand, long dwData, BSTR strHelpFile);
    LRESULT OnPaint(UINT /* uMsg */, WPARAM wParam, LPARAM /* lParam */, BOOL& /* lResult */);
    HRESULT OnDraw(ATL_DRAWINFO& di);
    STDMETHOD(Close)(DWORD dwSaveOption);        
    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip){
        HRESULT hr = IOleInPlaceObjectWindowlessImpl<CMFBar>::SetObjectRects(prcPos, prcClip);
        if(FAILED(hr)) return(hr);
        AdjustRects(prcPos); return (hr);
    }/* end of function SetObjectRects */
    STDMETHOD(Close)();
	STDMETHOD(get_BackgroundImage)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackgroundImage)(/*[in]*/ BSTR newVal);
    STDMETHOD(SetPriority)(long lPriority);
    STDMETHOD(SetPriorityClass)(long lPriorityClass);
   	STDMETHOD(get_AutoLoad)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_AutoLoad)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(SetRoundRectRgn)(long x1, long y1, long x2, long y2, long width, long height);
	STDMETHOD(SetRectRgn)(long x1, long y1, long x2, long y2 );
    STDMETHOD(SetObjectFocus)(BSTR strObjectID, VARIANT_BOOL fEnable);
    STDMETHOD(ForceKey)(LONG lVirtKey, LONG lKeyData, VARIANT_BOOL fEat);
    STDMETHOD(SetObjectExtent)(BSTR strID, long lWidth, long lHeight);
	STDMETHOD(MessageBox)(BSTR strText, BSTR strCaption, long lType);
    STDMETHOD(get_ActivityTimeout)(/*[out, retval]*/ long *plTimeout);
	STDMETHOD(put_ActivityTimeout)(/*[in]*/ long lTimout);
    STDMETHOD(Sleep)(long lMiliseconds);
	STDMETHOD(SetTimeout)(long lMilliseconds, long lId);	
    STDMETHOD(GetUserLCID)(long *plcid);
    USE_MF_TRANSPARENT_FLAG
    //STDMETHOD(get_TransparentBlit)(/*[out, retval]*/ TransparentBlitType *pVal);
	//STDMETHOD(put_TransparentBlit)(/*[in]*/ TransparentBlitType newVal);
    USE_MF_RESOURCEDLL  // replaces the two lines below
    //STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal);
	//STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_CmdLine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CmdLine)(/*[in]*/ BSTR newVal);
    STDMETHOD(ResetFocusArray)();
	STDMETHOD(AddFocusObject)(BSTR strObjectID);
	
    HRESULT OnPostVerbInPlaceActivate();

    static HICON m_hIcon;

    static CWndClassInfo& GetWndClassInfo(){ 
        static HBRUSH wcBrush = ::CreateSolidBrush(RGB(0,0,0));         
	    static CWndClassInfo wc = {{ sizeof(WNDCLASSEX), CS_DBLCLKS /*CS_OWNDC*/, StartWindowProc, 
		      0, 0, NULL, m_hIcon, NULL, wcBrush /* (HBRUSH)(COLOR_BTNFACE + 1) */, 
              NULL, TEXT("MSMFVideoClass"), NULL }, 
		    NULL, NULL, IDC_ARROW, TRUE, 0, _T("") };
	    return wc; 
    }/* end of function GetWndClassInfo */
		
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
  // *** IActiveScriptSite methods ***
  STDMETHOD(GetLCID)(LCID *plcid);
  STDMETHOD(GetItemInfo)(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppiunkItem, ITypeInfo **ppti);
  STDMETHOD(GetDocVersionString)(BSTR *pszVersion);
  //STDMETHOD(RequestItems)(void);
  //STDMETHOD(RequestTypeLibs)(void);
  STDMETHOD(OnScriptTerminate)(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo);
  STDMETHOD(OnStateChange)(SCRIPTSTATE ssScriptState);
  STDMETHOD(OnScriptError)(IActiveScriptError *pscripterror);
  STDMETHOD(OnEnterScript)(void);
  STDMETHOD(OnLeaveScript)(void);

  // *** IActiveScriptSiteWindow methods ***
  STDMETHOD(GetWindow)(HWND *phwnd);
  STDMETHOD(EnableModeless)(BOOL fEnable);

  // *** IProvideMultipleClassInfo methods ***
  // Implemented in the template above
  //STDMETHOD(GetMultiTypeInfoCount)(ULONG *pcti);
  //STDMETHOD(GetInfoOfIndex)(ULONG iti, DWORD dwFlags, ITypeInfo** pptiCoClass, DWORD* pdwTIFlags, ULONG* pcdispidReserved, IID* piidPrimary, IID* piidSource);
// #####  END  ACTIVEX SCRIPTING SUPPORT #####


// ####  BEGIN CONTAINER SUPPORT ####
  // IOleClientSite
  STDMETHOD(SaveObject)(){ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));}
  STDMETHOD(GetMoniker)(DWORD /*dwAssign*/, DWORD /*dwWhichMoniker*/, IMoniker** /*ppmk*/){ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));}
  STDMETHOD(GetContainer)(IOleContainer** ppContainer){ATLTRACENOTIMPL(_T("IOleClientSite::GetContainer"));}
  STDMETHOD(ShowObject)(){ATLTRACENOTIMPL(_T("IOleClientSite::ShowObject"));}
  STDMETHOD(OnShowWindow)(BOOL /*fShow*/){ATLTRACENOTIMPL(_T("IOleClientSite::OnShowWindow"));}
  STDMETHOD(RequestNewObjectLayout)(){ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));}
  // IOleContainer
  STDMETHOD(ParseDisplayName)(IBindCtx* /*pbc*/, LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/){ATLTRACENOTIMPL(_T("IOleClientSite::ParseDisplayName"));}
  STDMETHOD(EnumObjects)(DWORD /*grfFlags*/, IEnumUnknown** ppenum);		
  STDMETHOD(LockContainer)(BOOL fLock){ATLTRACENOTIMPL(_T("IOleClientSite::LockContainer"));}

    // IOleInPlaceFrameWindow
	STDMETHOD(InsertMenus)(HMENU /*hmenuShared*/, LPOLEMENUGROUPWIDTHS /*lpMenuWidths*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::InsertMenus\n"));
		return S_OK;
	}

	STDMETHOD(SetMenu)(HMENU /*hmenuShared*/, HOLEMENU /*holemenu*/, HWND /*hwndActiveObject*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::SetMenu\n"));
		return S_OK;
	}

	STDMETHOD(RemoveMenus)(HMENU /*hmenuShared*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::RemoveMenus\n"));
		return S_OK;
	}

	STDMETHOD(SetStatusText)(LPCOLESTR /*pszStatusText*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::SetStatusText\n"));
		return S_OK;
	}

    /********** Implemented somewhere Else ***/
#if 0
	STDMETHOD(EnableModeless)(BOOL /*fEnable*/)
	{
		return S_OK;
	}
#endif

	STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, WORD /*wID*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::TranslateAccelerator\n"));
		return S_FALSE;
	}


    // IOleWindow
#if 0 // implemented somwhere else, but implementation might need to be revised
	STDMETHOD(GetWindow)(HWND* phwnd){
        
		*phwnd = m_hWnd;
		return S_OK;
	}
#endif

	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::ContextSensitiveHelp\n"));
        return S_OK;
	}

// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
	{
		ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::GetBorder\n"));
        return S_OK;
	}

	STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::RequestBorderSpace\n"));
		return INPLACE_E_NOTOOLSPACE;
	}

	STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::SetBorderSpace\n"));
		return S_OK;
	}

	STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/){

        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleInPlaceUIWindow::SetActiveObject\n"));
		m_spActiveObject = pActiveObject;
		return S_OK;
	}

    // IOleControlSite
	STDMETHOD(OnControlInfoChanged)()
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::OnControlInfoChanged\n"));
		return S_OK;
	}
	STDMETHOD(LockInPlaceActive)(BOOL /*fLock*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::LockInPlaceActive\n"));
		return S_OK;
	}
	STDMETHOD(GetExtendedControl)(IDispatch** ppDisp)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::GetExtendedControl\n"));
        ATLASSERT(FALSE); // TODO, this interface needs to be moved to the hosted object
		if (ppDisp == NULL)
			return E_POINTER;
		return m_spOleObject.QueryInterface(ppDisp);
	}
	STDMETHOD(TransformCoords)(POINTL* /*pPtlHimetric*/, POINTF* /*pPtfContainer*/, DWORD /*dwFlags*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::TransformCoords\n"));
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, DWORD /*grfModifiers*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::TranslateAccelerator\n"));
		return S_FALSE;
	}
	STDMETHOD(OnFocus)(BOOL /*fGotFocus*/)
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::OnFocus\n"));
		return S_OK;
	}
	STDMETHOD(ShowPropertyFrame)()
	{
        ATLTRACE2(atlTraceHosting, 2, TEXT("IOleControlSite::ShowPropertyFrame\n"));
		return E_NOTIMPL;
	}

    // IOleInPlaceSite
#if 0
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		*phwnd = m_hWnd;
		return S_OK;
	}

	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		ATLTRACENOTIMPL(_T("IOleWindow::CanInPlaceActivate"));
	}
#endif

	STDMETHOD(CanInPlaceActivate)(){return S_OK;}
    STDMETHOD(OnInPlaceActivate)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnInPlaceActivate"));}
    STDMETHOD(OnInPlaceDeactivate)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnInPlaceDeactivate"));}
    STDMETHOD(OnUIDeactivate)(BOOL /*fUndoable*/){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnUIDeactivate\n"));}		
	STDMETHOD(OnUIActivate)()
	{
		ATLTRACE2(atlTraceHosting, 0, _T("IOleInPlaceSite::OnUIActivate\n"));
		m_bUIActive = TRUE;
		return S_OK;
	}
	STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo){
        ATLTRACENOTIMPL(_T("IOleInPlaceSite::GetWindowContext"));}
	STDMETHOD(Scroll)(SIZE /*scrollExtant*/){ATLTRACENOTIMPL(_T("IOleInPlaceSite::Scroll"));}
	STDMETHOD(DiscardUndoState)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::DiscardUndoState"));}
	STDMETHOD(DeactivateAndUndo)(){ATLTRACENOTIMPL(_T("IOleInPlaceSite::DeactivateAndUndo"));}
	STDMETHOD(OnPosRectChange)(LPCRECT /*lprcPosRect*/){ATLTRACENOTIMPL(_T("IOleInPlaceSite::OnPosRectChange"));}

    // IOleInPlaceSiteEx
    STDMETHOD(OnInPlaceActivateEx)(BOOL* /*pfNoRedraw*/, DWORD dwFlags){ATLTRACENOTIMPL(_T("IOleInPlaceSiteEx::OnInPlaceActivateEx"));};
	STDMETHOD(OnInPlaceDeactivateEx)(BOOL /*fNoRedraw*/){ATLTRACENOTIMPL(_T("IOleInPlaceSiteEx::OnInPlaceDeactivateEx"));};
	STDMETHOD(RequestUIActivate)(){return S_OK;}
    STDMETHOD(CanWindowlessActivate)();
	STDMETHOD(GetCapture)();
	STDMETHOD(SetCapture)(BOOL fCapture);
	STDMETHOD(GetFocus)();
	STDMETHOD(SetFocus)(BOOL fFocus);
	STDMETHOD(GetDC)(LPCRECT /*pRect*/, DWORD /*grfFlags*/, HDC* phDC);
	STDMETHOD(ReleaseDC)(HDC hDC);
	STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase);
	STDMETHOD(InvalidateRgn)(HRGN hRGN = NULL, BOOL fErase = FALSE);	
	STDMETHOD(ScrollRect)(INT /*dx*/, INT /*dy*/, LPCRECT /*pRectScroll*/, LPCRECT /*pRectClip*/){return S_OK;}
	STDMETHOD(AdjustRect)(LPRECT /*prc*/){return S_OK;}
	STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);	
// ####  END CONTAINER SUPPORT ####


protected: // member variables
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
  CComPtr<IActiveScript>        m_ps;
  CComPtr<IActiveScriptParse>   m_psp;
// #####  END  ACTIVEX SCRIPTING SUPPORT #####
// ####  BEGIN CONTAINER SUPPORT ####
  // !!!!TODO: Take these out and implement the interfaces !!!!
  CComPtr<IOleObject> m_spOleObject; // TODO: Implement this in the outer container, move out
  CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
  CNTOBJ m_cntObj; // collection of contained controls
  CNTEVNT m_cntEvnt; // collection of events
  CNTOBJ m_cntFocus; // collection of contained controls
  CComBSTR m_strScriptLanguage;
  CComBSTR m_strScriptFile;
  bool m_fSelfHosted;  // see if we are hosting our self
  LONG m_lMinWidth; // the smallest Width we allow
  LONG m_lMinHeight; // the smallest Height we allow
  bool m_fHandleHelp; // flag to change the help
  //TransparentBlitType m_blitType; moved to common utils
  POINT m_ptMouse; // last mouse point
  // Ambient property storage
  unsigned long m_bCanWindowlessActivate:1;
  unsigned long m_ulCapture;
  CComBSTR m_bstrBackImageFilename;
  CBitmap  *m_pBackBitmap;
  VARIANT_BOOL m_fAutoLoad;
  bool m_fForceKey; // flag to see if the force Key method was fired
  VARIANT_BOOL m_fEat;
  LONG m_lVirtKey; // virt key passed down by the force key
  LONG m_lKeyData; // data passes by force key method
  RECT m_rcWnd;
  bool m_bMouseDown;
  int m_HitRegion;
  long m_lTimeout; // activity timeout
  bool m_fUserActivity; // flag if there is a user activity
  bool m_fWaitingForActivity; // flag which set when we wait for an activity

// ####  END CONTAINER SUPPORT ####
public: // member variables  				
	STDMETHOD(HasObjectFocus)(BSTR strObjectID, VARIANT_BOOL* pfFocus);
	OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl
    CComBSTR m_bstrCaption;     // stock property for caption
    CComBSTR m_strCmdLine;       // command line argument we set
    LONG m_nReadyState; // ready state change stock property


protected: // private helper functions
    HRESULT Init(); // Initializes the internal variables
    HRESULT Cleanup(); // End of function cleanup
    HRESULT AdjustRects(const LPCRECT prcPos); // calls all our contained objects and the adjusts their
                                 // rects in the case we have moved
    HRESULT CreateScriptEngine();
    HRESULT GetParentHWND(HWND* pWnd);
    BOOL GetClientRect(LPRECT lpRect) const;
    HWND GetParent();
    HRESULT GetToolbarName(BSTR* strToolbarName);
    HRESULT SendMessageToCtl(CHostedObject* pObj, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled, LONG& lRes, bool fWndwlsOnly = true);    
    HRESULT SetReadyState(LONG lReadyState);
    HRESULT ResetCaptureFlags();    
    HRESULT ResetFocusFlags(); 
	HRESULT SendMouseMessageToCtl(CHostedObject* pObj, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled, LONG& lRes);
    int     ResizeHitRegion(POINT p);
    HRESULT UpdateCursor(int hitRegion);
    HRESULT SetObjectFocus(CHostedObject* pObj, BOOL fSet, LONG& lRes);
    HRESULT FindObject(BSTR strObjectID, CHostedObject** ppObj);
    HRESULT MoveFocus(bool fForward, LONG& lRes);
    HRESULT SetClosestFocus(LONG& lRes, CH