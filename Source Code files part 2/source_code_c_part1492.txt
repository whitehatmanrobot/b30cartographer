    0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define ET_NOTEOFF      ( MIDI_NOTEOFF >> 4 )  // 0x08
#define ET_NOTEON       ( MIDI_NOTEON >> 4 )   // 0x09
#define ET_PTOUCH       ( MIDI_PTOUCH >> 4 )   // 0x0A
#define ET_CCHANGE      ( MIDI_CCHANGE >> 4 )  // 0x0B
#define ET_PCHANGE      ( MIDI_PCHANGE >> 4 )  // 0x0C
#define ET_MTOUCH       ( MIDI_MTOUCH >> 4 )   // 0x0D
#define ET_PBEND        ( MIDI_PBEND >> 4 )    // 0x0E
#define ET_SYSX         ( MIDI_SYSX >> 4 )     // 0x0F
#define ET_PBCURVE      0x03
#define ET_CCCURVE      0x04
#define ET_MATCURVE     0x05
#define ET_PATCURVE     0x06
#define ET_TEMPOEVENT   0x01
#define ET_NOTDEFINED   0

#define NUM_MIDI_CHANNELS 16

struct FSEBlock;

/* FullSeqEvent is SeqEvent plus next pointers*/
typedef struct FullSeqEvent : DMUS_IO_SEQ_ITEM
{
    struct FullSeqEvent* pNext;
    struct FullSeqEvent* pTempNext; /* used in the compresseventlist routine */
    long pos;    /* used to keep track of the order of events in the file */

private:
    DWORD dwPosInBlock;
    static FSEBlock* sm_pBlockList;
public:
    static void CleanUp();
    void* operator new(size_t n);
    void operator delete(void* p);
} FullSeqEvent;

#define BITMAPSPERBLOCK 8
struct FSEBlock
{
    FSEBlock()
    {
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            m_dwBitMap[i] = 0;
        }
    };
    FSEBlock* m_pNext;
    DWORD m_dwBitMap[BITMAPSPERBLOCK];
    FullSeqEvent m_Event[BITMAPSPERBLOCK][32];
};

FSEBlock* FullSeqEvent::sm_pBlockList;

void FullSeqEvent::CleanUp()
{
    FSEBlock* pBlock;
    FSEBlock* pNext;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pNext)
    {
#ifdef DEBUG
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0)
            {
                DebugBreak();
            }
        }
#endif
        pNext = pBlock->m_pNext;
        delete pBlock;
    }
    sm_pBlockList = NULL;
}

void* FullSeqEvent::operator new(size_t n)
{
    if(sm_pBlockList == NULL)
    {
        sm_pBlockList = new FSEBlock;
        if(sm_pBlockList == NULL)
        {
            return NULL;
        }
        sm_pBlockList->m_pNext = NULL;
        sm_pBlockList->m_dwBitMap[0] = 1;
        sm_pBlockList->m_Event[0][0].dwPosInBlock = 0;
        return &sm_pBlockList->m_Event[0][0];
    }

    FSEBlock* pBlock;
    int i;
    DWORD dw;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        for(i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0xffff)
            {
                break;
            }
        }
        if(i < BITMAPSPERBLOCK)
        {
            break;
        }
    }
    if(pBlock == NULL)
    {
        pBlock = new FSEBlock;
        if(pBlock == NULL)
        {
            return NULL;
        }
        pBlock->m_pNext = sm_pBlockList;
        sm_pBlockList = pBlock;
        pBlock->m_dwBitMap[0] = 1;
        pBlock->m_Event[0][0].dwPosInBlock = 0;
        return &pBlock->m_Event[0][0];
    }

    for(dw = 0 ; (pBlock->m_dwBitMap[i] & (1 << dw)) != 0 ; ++dw);
    pBlock->m_dwBitMap[i] |= (1 << dw);
    pBlock->m_Event[i][dw].dwPosInBlock = (i << 6) | dw;
    return &pBlock->m_Event[i][dw];
}

void FullSeqEvent::operator delete(void* p)
{
    FSEBlock* pBlock;
    int i;
    DWORD dw;
    FullSeqEvent* pEvent = (FullSeqEvent*)p;

    dw = pEvent->dwPosInBlock & 0x1f;
    i = pEvent->dwPosInBlock >> 6;
    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        if(p == &pBlock->m_Event[i][dw])
        {
            pBlock->m_dwBitMap[i] &= ~(1 << dw);
            return;
        }
    }
}

TList<StampedGMGSXG> gMidiModeList;

// One for each MIDI channel 0-15    
DMUS_IO_BANKSELECT_ITEM gBankSelect[NUM_MIDI_CHANNELS];
DWORD gPatchTable[NUM_MIDI_CHANNELS];
long gPos;                                          // Keeps track of order of events in the file
DWORD gdwLastControllerTime[NUM_MIDI_CHANNELS];     // Holds the time of the last CC event.
DWORD gdwControlCollisionOffset[NUM_MIDI_CHANNELS]; // Holds the index of the last CC.
DWORD gdwLastPitchBendValue[NUM_MIDI_CHANNELS];     // Holds the value of the last pbend event.
long glLastSysexTime;

void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord);


void InsertMidiMode( TListItem<StampedGMGSXG>* pPair )
{
    TListItem<StampedGMGSXG>* pScan = gMidiModeList.GetHead();
    if( NULL == pScan )
    {
        gMidiModeList.AddHead(pPair);
    }
    else
    {
        if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
        {
            gMidiModeList.AddHead(pPair);
        }
        else
        {
            pScan = pScan->GetNext();
            while( pScan )
            {
                if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
                {
                    gMidiModeList.InsertBefore( pScan, pPair );
                    break;
                }
                pScan = pScan->GetNext();
            }
            if( NULL == pScan )
            {
                gMidiModeList.AddTail(pPair);
            }
        }
    }
}

HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
                       IDirectMusicLoader* pIDMLoader)
{
    // Any changes made to this function should also be made to CDirectMusicBand::LoadCollection
    // in dmband.dll

    assert(ppIDMCollection);
    assert(pIDMLoader);

    DMUS_OBJECTDESC desc;
    memset(&desc, 0, sizeof(desc));
    desc.dwSize = sizeof(desc);

    desc.guidClass = CLSID_DirectMusicCollection;
    desc.guidObject = GUID_DefaultGMCollection;
    desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
    
    HRESULT hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)ppIDMCollection);

    return hr;
}

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
    LARGE_INTEGER li;

    if( lSeekTo < 0 )
    {
        li.HighPart = -1;
    }
    else
    {
    li.HighPart = 0;
    }
    li.LowPart = lSeekTo;
    return pStream->Seek( li, dwOrigin, NULL );
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
    {
        unsigned char buf[4];
    DWORD dw;
    } u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 4, NULL ) )
    {
    return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

// this function gets a short that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMShort( LPSTREAM pStream, short& n )
{
    union uShort
    {
    unsigned char buf[2];
    short n;
    } u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 2, NULL ) )
    {
    return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[1];
    u.buf[1] = ch;
#endif

    n = u.n;
    return TRUE;
}

static short snPPQN;
static IStream* gpTempoStream = NULL;
static IStream* gpSysExStream = NULL;
static IStream* gpTimeSigStream = NULL;
static DWORD gdwSizeTimeSigStream = 0;
static DWORD gdwSizeSysExStream = 0;
static DWORD gdwSizeTempoStream = 0;
static DMUS_IO_TIMESIGNATURE_ITEM gTimeSig; // holds the latest time sig
long    glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
    // this is needed because we only care about the time sigs on the first track to
    // contain them that we read
static IDirectMusicTrack* g_pChordTrack = NULL;
static DMUS_CHORD_PARAM g_Chord; // Holds the latest chord
static DMUS_CHORD_PARAM g_DefaultChord; // in case no chords are extracted from the track

static WORD GetVarLength( LPSTREAM pStream, DWORD& rfdwValue )
{
    BYTE b;
    WORD wBytes;

    if( S_OK != pStream->Read( &b, 1, NULL ) )
    {
        rfdwValue = 0;
        return 0;
    }
    wBytes = 1;
    rfdwValue = b & 0x7f;
    while( ( b & 0x80 ) != 0 )
    {
        if( S_OK != pStream->Read( &b, 1, NULL ) )
        {
            break;
        }
        ++wBytes;
        rfdwValue = ( rfdwValue << 7 ) + ( b & 0x7f );
    }
    return wBytes;
}

#ifdef _MAC
static DWORD ConvertTime( DWORD dwTime )
{
    wide d;
    long l;  // storage for the remainder

    if( snPPQN == DMUS_PPQ )  {
        return dwTime;
    }
    WideMultiply( dwTime, DMUS_PPQ, &d );
    return WideDivide( &d, snPPQN, &l );
}
#else
static DWORD ConvertTime( DWORD dwTime )
{
    __int64 d;

    if( snPPQN == DMUS_PPQ )
    {
        return dwTime;
    }
    d = dwTime;
    d *= DMUS_PPQ;
    d /= snPPQN;
    return (DWORD)d;
}
#endif

static FullSeqEvent* ScanForDuplicatePBends( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pEvent;
    FullSeqEvent* pNextEvent;
    MUSIC_TIME mtCurrentTime = 0x7FFFFFFF;  // We are scanning backwards in time, so start way in the future.
    WORD wDupeBits = 0;     // Keep a bit array of all channels that have active PBends at mtCurrentTime. 

    if( NULL == lstEvent ) return NULL;

    // Scan through the list of events. This list is in backwards order, with the first item read at the end
    // of the list. This makes it very easy to scan through and remove pitch bends that occur at the same time, since
    // we can remove the latter events (which occured earlier in the midi file.)
    for( pEvent = lstEvent ; pEvent ; pEvent = pNextEvent )
    {
        pNextEvent = pEvent->pNext;
        if( pNextEvent )
        {
            // If the time is not the same as the last, reset. 
            if (pNextEvent->mtTime != mtCurrentTime)
            {
                // Reset the time.
                mtCurrentTime = pNextEvent->mtTime;
                // No duplicate pbends at this time.
                wDupeBits = 0;
            }
            if ((pNextEvent->bStatus & 0xf0) == MIDI_PBEND)
            {
                DWORD dwChannel = pNextEvent->dwPChannel;
                if (wDupeBits & (1 << dwChannel))
                {
                    // There was a previous (therefore later in the file) pbend at this time. Delete this one.
                    pEvent->pNext = pNextEvent->pNext;
                    delete pNextEvent;
                    pNextEvent = pEvent;
                }
                else
                {
                    // This is the last instance of a pbend on this channel at this time, so hang on to it.
                    wDupeBits |= (1 << dwChannel);
                }
            }
        }
    }
    return lstEvent;
}


static FullSeqEvent* CompressEventList( FullSeqEvent* lstEvent )
{
    static FullSeqEvent* paNoteOnEvent[16][128];
    FullSeqEvent* pEvent;
    FullSeqEvent* pPrevEvent;
    FullSeqEvent* pNextEvent;
    FullSeqEvent* pHoldEvent;
    FullSeqEvent tempEvent;
    int nChannel;

    if( NULL == lstEvent ) return NULL;

    memset( paNoteOnEvent, 0, sizeof( paNoteOnEvent ) );
    pPrevEvent = NULL;

    // add an event to the beginning of the list as a place holder
    memset( &tempEvent, 0, sizeof(FullSeqEvent) );
    tempEvent.mtTime = -1;
    tempEvent.pNext = lstEvent;
    lstEvent = &tempEvent;
    // make sure that any events with the same time are sorted in order
    // they were read
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
        pNextEvent = pEvent->pNext;
        if( pNextEvent )
        {
            BOOL fSwap = TRUE;
            // bubble sort
            while( fSwap )
            {
                fSwap = FALSE;
                pPrevEvent = pEvent;
                pNextEvent = pEvent->pNext;
                while( pNextEvent->pNext && ( pNextEvent->mtTime == pNextEvent->pNext->mtTime ))
                {
                    if( pNextEvent->pNext->pos < pNextEvent->pos )
                    {
                        fSwap = TRUE;
                        pHoldEvent = pNextEvent->pNext;
                        pPrevEvent->pNext = pHoldEvent;
                        pNextEvent->pNext = pHoldEvent->pNext;
                        pHoldEvent->pNext = pNextEvent;
                        pPrevEvent = pHoldEvent;
                        continue;
                    }
                    pPrevEvent = pNextEvent;
                    pNextEvent = pNextEvent->pNext;
                }
            }
        }
    }
    // remove the first, temporary event, added above
    lstEvent = lstEvent->pNext;

    pPrevEvent = NULL;
    // combine note on and note offs
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
        pEvent->pTempNext = NULL;
        pNextEvent = pEvent->pNext;
        //nChannel = pEvent->bStatus & 0xf;
        nChannel = pEvent->dwPChannel;
        if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            // add this event to the end of the list of events based
            // on the event's pitch. Keeping track of multiple events
            // of the same pitch allows us to have overlapping notes
            // of the same pitch, choosing that note on's and note off's
            // follow in the same order.
            if( NULL == paNoteOnEvent[nChannel][pEvent->bByte1] )
            {
                paNoteOnEvent[nChannel][pEvent->bByte1] = pEvent;
            }
            else
            {
                FullSeqEvent* pScan;
                for( pScan = paNoteOnEvent[nChannel][pEvent->bByte1];
                     pScan->pTempNext != NULL; pScan = pScan->pTempNext );
                pScan->pTempNext = pEvent;
            }
        }
        else if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEOFF )
        {
            if( paNoteOnEvent[nChannel][pEvent->bByte1] != NULL )
            {
                paNoteOnEvent[nChannel][pEvent->bByte1]->mtDuration =
                    pEvent->mtTime - paNoteOnEvent[nChannel][pEvent->bByte1]->mtTime;
                paNoteOnEvent[nChannel][pEvent->bByte1] =
                    paNoteOnEvent[nChannel][pEvent->bByte1]->pTempNext;
            }
            if( pPrevEvent == NULL )
            {
                lstEvent = pNextEvent;
            }
            else
            {
                pPrevEvent->pNext = pNextEvent;
            }
            delete pEvent;
            continue;
        }
        pPrevEvent = pEvent;
    }

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pEvent->pNext )
    {
        pEvent->mtTime = pEvent->mtTime;
        if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            pEvent->mtDuration = pEvent->mtDuration;
            if( pEvent->mtDuration == 0 ) pEvent->mtDuration = 1;
        }
    }

    return lstEvent;
}

static int CompareEvents( FullSeqEvent* pEvent1, FullSeqEvent* pEvent2 )
{
    BYTE bEventType1 = static_cast<BYTE>( pEvent1->bStatus >> 4 );
    BYTE bEventType2 = static_cast<BYTE>( pEvent2->bStatus >> 4 );

    if( pEvent1->mtTime < pEvent2->mtTime )
    {
        return -1;
    }
    else if( pEvent1->mtTime > pEvent2->mtTime )
    {
        return 1;
    }
    else if( bEventType1 != ET_SYSX && bEventType2 != ET_SYSX )
    {
        BYTE bStatus1;
        BYTE bStatus2;

        bStatus1 = (BYTE)( pEvent1->bStatus & 0xf0 );
        bStatus2 = (BYTE)( pEvent2->bStatus & 0xf0 );
        if( bStatus1 == bStatus2 )
        {
            return 0;
        }
        else if( bStatus1 == MIDI_NOTEON )
        {
            return -1;
        }
        else if( bStatus2 == MIDI_NOTEON )
        {
            return 1;
        }
        else if( bStatus1 > bStatus2 )
        {
            return 1;
        }
        else if( bStatus1 < bStatus2 )
        {
            return -1;
        }
    }
    return 0;
}

static FullSeqEvent* MergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent )
{
    FullSeqEvent  anchorEvent;
    FullSeqEvent* pEvent;

    anchorEvent.pNext = NULL;
    pEvent = &anchorEvent;

    do
    {
    if( CompareEvents( lstLeftEvent, lstRightEvent ) < 0 )
    {
        pEvent->pNext = lstLeftEvent;
        pEvent = lstLeftEvent;
        lstLeftEvent = lstLeftEvent->pNext;
        if( lstLeftEvent == NULL )
        {
        pEvent->pNext = lstRightEvent;
        }
    }
    else
    {
        pEvent->pNext = lstRightEvent;
        pEvent = lstRightEvent;
        lstRightEvent = lstRightEvent->pNext;
        if( lstRightEvent == NULL )
        {
        pEvent->pNext = lstLeftEvent;
        lstLeftEvent = NULL;
        }
    }
    } while( lstLeftEvent != NULL );

    return anchorEvent.pNext;
}

static FullSeqEvent* SortEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pMidEvent;
    FullSeqEvent* pRightEvent;

    if( lstEvent != NULL && lstEvent->pNext != NULL )
    {
    pMidEvent = lstEvent;
    pRightEvent = pMidEvent->pNext->pNext;
    if( pRightEvent != NULL )
    {
        pRightEvent = pRightEvent->pNext;
    }
    while( pRightEvent != NULL )
    {
        pMidEvent = pMidEvent->pNext;
        pRightEvent = pRightEvent->pNext;
        if( pRightEvent != NULL )
        {
        pRightEvent = pRightEvent->pNext;
        }
    }
    pRightEvent = pMidEvent->pNext;
    pMidEvent->pNext = NULL;
    return MergeEvents( SortEventList( lstEvent ),
                SortEventList( pRightEvent ) );
    }
    return lstEvent;
}

static DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent )
{
    static BYTE bRunningStatus;

    gPos++;
    dwTime = ConvertTime(dwTime);

    DWORD dwBytes;
    DWORD dwLen;
    FullSeqEvent* pEvent;
    DMUS_IO_PATCH_ITEM* pPatchEvent;
    DMUS_IO_SYSEX_ITEM* pSysEx;
    BYTE b;

    BYTE* pbSysExData = NULL;

    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
    {
        return 0;
    }

    if( b < 0x80 )
    {
        StreamSeek( pStream, -1, STREAM_SEEK_CUR );
        b = bRunningStatus;
        dwBytes = 0;
    }
    else
    {
        dwBytes = 1;
    }

    if( b < 0xf0 )
    {
        bRunningStatus = (BYTE)b;

        switch( b & 0xf0 )
        {
        case MIDI_CCHANGE:
        case MIDI_PTOUCH:
        case MIDI_PBEND:
        case MIDI_NOTEOFF:
        case MIDI_NOTEON:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;

            pEvent = new FullSeqEvent;
            if( pEvent == NULL )
            {
                return 0;
            }

            pEvent->mtTime = dwTime;
            pEvent->nOffset = 0;
            pEvent->pos = gPos;
            pEvent->mtDuration = 0;
            pEvent->bStatus = bRunningStatus & 0xf0;
            pEvent->dwPChannel = bRunningStatus & 0xf;
            pEvent->bByte1 = b;
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                delete pEvent;
                return dwBytes;
            }
            ++dwBytes;
            pEvent->bByte2 = b;

            if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON &&
                pEvent->bByte2 == 0 )
            {
                pEvent->bStatus = (BYTE)( MIDI_NOTEOFF );
            }

            /*  If there are multiple controller events at the same time, seperate
                them by clock ticks. 
                gdwLastControllerTime holds the time of the last CC event.
                gdwControlCollisionOffset holds the number of colliding CCs.
            */

            if ((pEvent->bStatus & 0xf0) == MIDI_CCHANGE)
            {
                DWORD dwChannel = pEvent->dwPChannel;
                if (dwTime == gdwLastControllerTime[dwChannel])
                {
                    pEvent->mtTime += ++gdwControlCollisionOffset[dwChannel];
                }
                else
                {
                    gdwControlCollisionOffset[dwChannel] = 0;
                    gdwLastControllerTime[dwChannel] = dwTime;
                }
            }

            if(((pEvent->bStatus & 0xf0) == MIDI_CCHANGE) && (pEvent->bByte1 == 0 || pEvent->bByte1 == 0x20))
            {
                // We have a bank select or its LSB either of which are not added to event list
                if(pEvent->bByte1 == 0x20)
                {
                    gBankSelect[pEvent->dwPChannel].byLSB = pEvent->bByte2;
                }
                else // pEvent->bByte1 == 0
                {
                    gBankSelect[pEvent->dwPChannel].byMSB = pEvent->bByte2;
                }
                // We no longer need the event so we can free it
                delete pEvent;
            }
            else // Add to event list
            {
                pEvent->pNext = *plstEvent;
                *plstEvent = pEvent;
            }
            break;

        case MIDI_PCHANGE:
            if(FAILED(pStream->Read(&b, 1, NULL)))
            {
                return dwBytes;
            }
            
            ++dwBytes;

            pPatchEvent = new DMUS_IO_PATCH_ITEM;

            if(pPatchEvent == NULL)
            {
                return 0;
            }
            memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
            pPatchEvent->lTime = dwTime - 1;
            pPatchEvent->byStatus = bRunningStatus;
            pPatchEvent->byPChange = b;
            pPatchEvent->byMSB = gBankSelect[bRunningStatus & 0xF].byMSB;
            pPatchEvent->byLSB = gBankSelect[bRunningStatus & 0xF].byLSB;
            pPatchEvent->dwFlags |= DMUS_IO_INST_PATCH;

            if((pPatchEvent->byMSB != 0xFF) && (pPatchEvent->byLSB != 0xFF))
            {
                pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;                        
            }

            gPatchTable[bRunningStatus & 0xF] = 1;

            pPatchEvent->pNext = *pplstPatchEvent;
            pPatchEvent->pIDMCollection = NULL;

            *pplstPatchEvent = pPatchEvent;

            break;

        case MIDI_MTOUCH:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;
            pEvent = new FullSeqEvent;
            if( pEvent == NULL )
            {
                return 0;
            }


            pEvent->mtTime = dwTime;
            pEvent->nOffset = 0;
            pEvent->pos = gPos;
            pEvent->mtDuration = 0;
            pEvent->bStatus = bRunningStatus & 0xf0;
            pEvent->dwPChannel = bRunningStatus & 0xf;
            pEvent->bByte1 = b;
            pEvent->pNext = *plstEvent;
            *plstEvent = pEvent;
            break;
        default:
            // this should NOT be possible - unknown midi note event type
            ASSERT(FALSE);
            break;
        }
    }
    else
    {
        switch( b )
        {
        case 0xf0:
            dwBytes += GetVarLength( pStream, dwLen );
            pSysEx = new DMUS_IO_SYSEX_ITEM;
            if( pSysEx != NULL )
            {
                pbSysExData = new BYTE[dwLen + 1];
                if( pbSysExData != NULL )
                {
                    MUSIC_TIME mt = dwTime;
                    if (mt == 0)
                    {
                        mt = glLastSysexTime++;
                        if (mt > 0) mt = 0;
                    }
                    pbSysExData[0] = 0xf0;
                    if( FAILED( pStream->Read( pbSysExData + 1, dwLen, NULL ) ) )
                    {
                        delete [] pbSysExData;
                        delete pSysEx;
                        return dwBytes;
                    }

                    if( pbSysExData[1] == 0x43 )
                    {
                        // check for XG files
                        BYTE abXG[] = { 0xF0, 0x43, 0x10, 0x4C, 0x00, 0x00, 0x7E, 0x00, 0xF7 };
                        int i;
                        for( i = 0; i < 8; i++ )
                        {
                            if( i == 2 )
                            {
                                if( ( pbSysExData[i] & 0xF0 ) != abXG[i] )
                                    break;
                            }
                            else
                            {
                                if( pbSysExData[i] != abXG[i] )
                                    break;
                            }
                        }
                        if( i == 8 ) // we have an XG!
                        {
                            TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                            if (!pPair) return dwBytes;
                            pPair->GetItemValue().mtTime = mt;
                            pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_XG;
                            InsertMidiMode(pPair);
                        }
                    }
                    else if( pbSysExData[1] == 0x41 )
                    {
                        // check for GS files
                        BYTE abGS[] = { 0xF0,0x41,0x00,0x42,0x12,0x40,0x00,0x7F,0x00,0x41,0xF7 };
                        int i;
                        for( i = 0; i < 10; i++ )
                        {
                            if( i != 2 )
                            {
                                if( pbSysExData[i] != abGS[i] )
                                    break;
                            }
                        }
                        if( i == 10 ) // we have a GS!
                        {
                            TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                            if (!pPair) return dwBytes;
                            pPair->GetItemValue().mtTime = mt;
                            pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GS;
                            InsertMidiMode(pPair);
                        }
                    }
                    else if (( pbSysExData[1] == 0x7E ) && (pbSysExData[3] == 0x09))
                    {
                        TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                        if (!pPair) return dwBytes;
                        pPair->GetItemValue().mtTime = mt;
                        pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GM;
                        InsertMidiMode(pPair);
                    }
                    pSysEx->mtTime = mt;
                    pSysEx->dwPChannel = 0;
                    DWORD dwTempLen = dwLen + 1;
                    pSysEx->dwSysExLength = dwTempLen;
                    if( NULL == gpSysExStream )
                    {
                        // create a stream to hold sysex events
                        CreateStreamOnHGlobal( NULL, TRUE, &gpSysExStream );
                        if( gpSysExStream )
                        {
                            DWORD dwTemp;
                            // write the chunk header
                            dwTemp = DMUS_FOURCC_SYSEX_TRACK;
                            gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
                            // write the overall size. (Replace this later with the
                            // true overall size.)
                            dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                            // overall size (to be replaced later)
                            gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        }
                    }
                    if( gpSysExStream )
                    {
                        gpSysExStream->Write( &pSysEx->mtTime, sizeof(MUSIC_TIME), NULL );
                        gpSysExStream->Write( &pSysEx->dwPChannel, sizeof(DWORD), NULL );
                        gpSysExStream->Write( &pSysEx->dwSysExLength, sizeof(DWORD), NULL );
                        gpSysExStream->Write( pbSysExData, dwTempLen, NULL );
                        gdwSizeSysExStream += (sizeof(long) + sizeof(DWORD) + dwTempLen);
                    }
                    delete [] pbSysExData;
                    delete pSysEx;
                }
                else
                {
                    StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
                }
            }
            else
            {
                StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
            }
            dwBytes += dwLen;
            break;
        case 0xf7:
            // ignore sysex f7 chunks
            dwBytes += GetVarLength( pStream, dwLen );
            StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
            dwBytes += dwLen;
            break;
        case 0xff:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;
            dwBytes += GetVarLength( pStream, dwLen );
            if( b == 0x51 ) // tempo change
            {
                DWORD dw = 0;
                DMUS_IO_TEMPO_ITEM tempo;

                while( dwLen > 0 )
                {
                    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                    {
                        return dwBytes;
                    }
                    ++dwBytes;
                    --dwLen;
                    dw <<= 8;
                    dw += b;
                }
                if (dw < 1) dw = 1;
                tempo.dblTempo = 60000000.0 / ((double)dw);
                tempo.lTime = dwTime;
                if( NULL == gpTempoStream )
                {
                    // create a stream to hold tempo events
                    CreateStreamOnHGlobal( NULL, TRUE, &gpTempoStream );
                    if( gpTempoStream )
                    {
                        DWORD dwTemp;
                        // write the chunk header
                        dwTemp = DMUS_FOURCC_TEMPO_TRACK;
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // write the overall size. (Replace this later with the
                        // true overall size.) Also write the size of the individual
                        // structure.
                        dwTemp = sizeof(DMUS_IO_TEMPO_ITEM);
                        // overall size (to be replaced later)
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // individual structure.
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    }
                }
                if( gpTempoStream )
                {
                    gpTempoStream->Write( &tempo, sizeof(DMUS_IO_TEMPO_ITEM), NULL );
                    gdwSizeTempoStream += sizeof(DMUS_IO_TEMPO_ITEM);
                }
            }
            else if( b == 0x58 && glTimeSig )
            {
                // glTimeSig will be set to 0 inside the main calling function
                // once we no longer care about time sigs.
                DMUS_IO_TIMESIGNATURE_ITEM timesig;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                // set glTimeSig to 2 to signal to the main function that we've
                // read a time sig on this track
                glTimeSig = 2;
                gTimeSig.lTime = timesig.lTime = dwTime;
                gTimeSig.bBeatsPerMeasure = timesig.bBeatsPerMeasure = b;
                ++dwBytes;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                gTimeSig.bBeat = timesig.bBeat = (BYTE)( 1 << b ); // 0 means 256th note
                gTimeSig.wGridsPerBeat = timesig.wGridsPerBeat = 4; // this is irrelavent for MIDI files
                
                if( NULL == gpTimeSigStream )
                {
                    CreateStreamOnHGlobal( NULL, TRUE, &gpTimeSigStream );
                    if( gpTimeSigStream )
                    {
                        DWORD dwTemp;
                        // write the chunk header
                        dwTemp = DMUS_FOURCC_TIMESIGNATURE_TRACK;
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // write the overall size. (Replace this later with the
                        // true overall size.) Also write the size of the individual
                        // structure.
                        dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                        // overall size (to be replaced later)
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // individual structure.
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        gdwSizeTimeSigStream += sizeof(DWORD);
                    }
                }
                if( gpTimeSigStream )
                {
                    gpTimeSigStream->Write( &timesig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM), NULL );
                    gdwSizeTimeSigStream += sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                }
                ++dwBytes;
                StreamSeek( pStream, dwLen - 2, STREAM_SEEK_CUR );
                dwBytes += ( dwLen - 2 );
            }
            else if( b == 0x59 )
            {
                // Read sharps/flats and major/minor bytes
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                char cSharpsFlats = b;
                ++dwBytes;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                BYTE bMode = b;
                ++dwBytes;

                // Create a chord (with one subchord) from the key info
                CreateChordFromKey(cSharpsFlats, bMode, dwTime, g_Chord);

                // If the chord track is empty, create it.
                if (!g_pChordTrack)
                {
                    HRESULT hr = CoCreateInstance( 
                            CLSID_DirectMusicChordTrack, NULL, CLSCTX_INPROC,
                            IID_IDirectMusicTrack,
                            (void**)&g_pChordTrack );
                    if (!SUCCEEDED(hr)) return dwBytes;

                    // If dwTime > 0, use SetParam to insert the default chord at time 0
                    if (dwTime > 0)
                    {
                        g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
                    }
                }

                // Use SetParam to insert the new chord into the chord track
                g_pChordTrack->SetParam(GUID_ChordParam, dwTime, &g_Chord);

            }
            else
            {
                StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
                dwBytes += dwLen;
            }
            break;
        default:
            break;
        }
    }
    return dwBytes;
}

static void AddOffsets(FullSeqEvent* lstEvent, IDirectMusicTrack* pTimeSigTrack)
{
    HRESULT hr;
    MUSIC_TIME mtNext = 0;
    DMUS_IO_TIMESIGNATURE_ITEM timesig;
    timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
    timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
    timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
    timesig.lTime = 0;
    short nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;

    if (pTimeSigTrack)
    {
        hr = pTimeSigTrack->GetParam(GUID_TimeSignature, 0, &mtNext, (void*)&timesig);
        if (FAILED(hr))
        {
            mtNext = 0;
        }
        else
        {
            nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
        }
    }

    for( FullSeqEvent* pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
    {
        if ( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            if (mtNext && pTimeSigTrack && mtNext < pEvent->mtTime)
            {
                hr = pTimeSigTrack->GetParam(GUID_TimeSignature, mtNext, &mtNext, (void*)&timesig);
                if (FAILED(hr))
                {
                    mtNext = 0;
                }
                else
                {
                    nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
                }
            }
            ASSERT(nClocksPerGrid);
            if( 0 == nClocksPerGrid ) nClocksPerGrid = 1; // this should never happen, but just in case.
            pEvent->nOffset = (short) ((pEvent->mtTime - timesig.lTime) % nClocksPerGrid);
            pEvent->mtTime -= pEvent->nOffset;
            if (pEvent->nOffset > (nClocksPerGrid / 2))
            {
                // make it a negative offset and bump the time a corresponding amount
                pEvent->nOffset -= nClocksPerGrid;
                pEvent->mtTime += nClocksPerGrid;
            }
        }
    }

}

/*

  @method HRESULT | IDirectMusicPerformance | CreateSegmentFromMIDIStream |
  Given a MIDI stream, creates a Segment that can be played via
  <im IDirectMusicPerformance.PlaySegment>.

  @parm LPSTREAM | pStream |
  [in] The MIDI stream. It should be set to the correct seek to begin reading.
  @parm IDirectMusicSegment* | pSegment |
  [out] A pointer to contain the created Segment.

  @rvalue DMUS_E_CANNOTREAD | There was an error attempting to read the MIDI file.
  @rvalue S_OK

*/
HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream,
                                    IDirectMusicSegment* pSegment)
{
    if(pSegment == NULL || pStream == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = DMUS_E_CANNOTREAD;
    DWORD dwID;
    DWORD dwCurTime;
    DWORD dwLength;
    DWORD dwSize;
    short nFormat;
    short nNumTracks;
    short nTracksRead;
     FullSeqEvent* lstEvent;
    DMUS_IO_PATCH_ITEM* lstPatchEvent;
    FullSeqEvent* lstTrackEvent;
    HRESULT hrGM = S_OK;


    EnterCriticalSection(&g_CritSec);
    gpTempoStream = NULL;
    gpSysExStream = NULL;
    gpTimeSigStream = NULL;
    gdwSizeTimeSigStream = 0;
    gdwSizeSysExStream = 0;
    gdwSizeTempoStream = 0;
    glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
    // this is needed because we only care about the time sigs on the first track to
    // contain them that we read
    g_pChordTrack = NULL;

    lstEvent = NULL;
    lstPatchEvent = NULL;
    nNumTracks = nTracksRead = 0;
    dwLength = 0;
    gPos = 0;
    gMidiModeList.CleanUp();
    if (g_pChordTrack)
    {
        g_pChordTrack->Release();
        g_pChordTrack = NULL;
    }
    CreateChordFromKey(0, 0, 0, g_Chord);
    CreateChordFromKey(0, 0, 0, g_DefaultChord);

    memset(&gBankSelect, 0xFF, (sizeof(DMUS_IO_BANKSELECT_ITEM) * NUM_MIDI_CHANNELS));
    memset(&gPatchTable, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS));
    memset(&gTimeSig, 0, sizeof(DMUS_IO_TIMESIGNATURE_ITEM));
    memset(&gdwLastControllerTime, 0xFF, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
    memset(&gdwControlCollisionOffset, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
    glLastSysexTime = -5;

    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
        !GetMLong( pStream, dwSize ) )
    {
        Trace(1,"Error: Failure parsing MIDI file.\n");
        LeaveCriticalSection(&g_CritSec);
        return DMUS_E_CANNOTREAD;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
        StreamSeek( pStream, 12, STREAM_SEEK_CUR );
        if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
            Trace(1,"Error: Failure parsing MIDI file.\n");
            LeaveCriticalSection(&g_CritSec);
            return DMUS_E_CANNOTREAD;
        }
    }
// check for normal MIDI files
    if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
    {
        LeaveCriticalSection(&g_CritSec);
        Trace(1,"Error: Failure parsing MIDI file - can't find a valid header.\n");
        return DMUS_E_CANNOTREAD;
    }

    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, snPPQN );
    if( dwSize > 6 )
    {
        StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    while( dwID == mmioFOURCC( 'M', 'T', 'r', 'k' ) )
    {
        GetMLong( pStream, dwSize );
        dwCurTime = 0;
        lstTrackEvent = NULL;

        long lSize = (long)dwSize;
        while( lSize > 0 )
        {
            long lReturn;
            lSize -= GetVarLength( pStream, dwID );
            dwCurTime += dwID;
            if (lSize > 0)
            {
                lReturn = ReadEvent( pStream, dwCurTime, &lstTrackEvent, &lstPatchEvent );
                if( lReturn )
                {
                    lSize -= lReturn;
                }
                else
                {
                    Trace(1,"Error: Failure parsing MIDI file.\n");
                    hr = DMUS_E_CANNOTREAD;
                    goto END;
                }
            }
        }
        dwSize = lSize;
        if( glTimeSig > 1 )
        {
            // if glTimeSig is greater than 1, it means we've read some time sigs
            // from this track (it was set to 2 inside ReadEvent.) This means that
            // we no longer want ReadEvent to pay any attention to time sigs, so
            // we set this to 0.
            glTimeSig = 0;
        }
        if( dwCurTime > dwLength )
        {
            dwLength = dwCurTime;
        }
        lstTrackEvent = ScanForDuplicatePBends( lstTrackEvent );
        lstTrackEvent = SortEventList( lstTrackEvent );
        lstTrackEvent = CompressEventList( lstTrackEvent );
        lstEvent = List_Cat( lstEvent, lstTrackEvent );
        if( FAILED( pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) )
        {
            break;
        }
    }
    dwLength = ConvertTime(dwLength);

    lstEvent = SortEventList( lstEvent );

//    if( lstEvent ) Removed: this might be just a band, or sysex data, or whatever.
    {
        if(pSegment)
        {
            IPersistStream* pIPSTrack;
            IDirectMusicTrack*    pDMTrack;

            hr = S_OK;

            if (!g_pChordTrack)
            {
                hr = CoCreateInstance( 
                        CLSID_DirectMusicChordTrack, NULL, CLSCTX_INPROC,
                        IID_IDirectMusicTrack,
                        (void**)&g_pChordTrack );
                if (SUCCEEDED(hr))
                {
                    g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
                }
            }
            if (SUCCEEDED(hr))
            {
                pSegment->InsertTrack( g_pChordTrack, 1 );
                g_pChordTrack->Release();
                g_pChordTrack = NULL;
            }

            // Note: We could be checking to see if there are actually tempo events,
            // sysex events, etc. to see if it's really necessary to create these
            // tracks...
            // Create a Tempo Track in which to store the tempo events
            if( gpTempoStream )
            {
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    StreamSeek( gpTempoStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpTempoStream->Write( &gdwSizeTempoStream, sizeof(DWORD), NULL );
                    StreamSeek( gpTempoStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpTempoStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }

            // Add a patch event for each MIDI channel that does not have one
            DMUS_IO_PATCH_ITEM* pPatchEvent = NULL;
            for(DWORD i = 0; i < 16; i++)
            {
                if(gPatchTable[i] == 0)
                {
                    pPatchEvent = new DMUS_IO_PATCH_ITEM;

                    if(pPatchEvent == NULL)
                    {
                        continue;
                    }
                    
                    memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
                    pPatchEvent->lTime = ConvertTime(0);
                    pPatchEvent->byStatus = 0xC0 + (BYTE)(i & 0xf);
                    pPatchEvent->dwFlags |= (DMUS_IO_INST_PATCH);
                    pPatchEvent->pIDMCollection = NULL;
                    pPatchEvent->fNotInFile = TRUE;

                    pPatchEvent->pNext = lstPatchEvent;
                    lstPatchEvent = pPatchEvent;
                }
            }

            if(lstPatchEvent)
            {
                // Create Band Track in which to store patch change events
                IDirectMusicBandTrk* pBandTrack;

                if(SUCCEEDED(CoCreateInstance(CLSID_DirectMusicBandTrack,
                                              NULL, 
                                              CLSCTX_INPROC, 
                                              IID_IDirectMusicBandTrk,
                                              (void**)&pBandTrack)))
                {
                    // Get the loader from stream so we can open a required collections
                    IDirectMusicGetLoader* pIDMGetLoader = NULL;
                    IDirectMusicLoader* pIDMLoader = NULL;
    
                    hr = pStream->QueryInterface(IID_IDirectMusicGetLoader, (void**)&pIDMGetLoader);
                    if( SUCCEEDED(hr) )
                    {
                        hr = pIDMGetLoader->GetLoader(&pIDMLoader);
                        pIDMGetLoader->Release();
                    }
                    // IStream needs a loader attached
                    assert(SUCCEEDED(hr));

                    // Populate the the Band Track with patch change events
                    for(DMUS_IO_PATCH_ITEM* pEvent = lstPatchEvent; pEvent; pEvent = lstPatchEvent)
                    {
                        // Remove instrument from head of list and give to band
                        DMUS_IO_PATCH_ITEM* temp = pEvent->pNext;
                        pEvent->pNext = NULL;
                        lstPatchEvent = temp;

                        // We will try to load the collection but if we can not we will continure
                        // and use the default GM on the card
                        if(pIDMLoader)
                        {
                            HRESULT hrTemp = LoadCollection(&pEvent->pIDMCollection, pIDMLoader);
                            if (FAILED(hrTemp))
                            {
                                hrGM = hrTemp;
                            }
                        }

                        hr = pBandTrack->AddBand(pEvent);

                        // Release reference to collection
                        if(pEvent->pIDMCollection)
                        {
                            (pEvent->pIDMCollection)->Release();
                            pEvent->pIDMCollection = NULL;
                        }
                        delete pEvent;

                        if(FAILED(hr))
                        {
                            break;                        
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
        
                        TListItem<StampedGMGSXG>* pPair = gMidiModeList.GetHead();
                        if( NULL == pPair )
                        {
                            // if we had nothing, generate a GM one so the band knows
                            // it was loaded from a midi file
                            // since the first band is set to play at -1,
                            // this is when the default midi mode must occur.
                            pBandTrack->SetGMGSXGMode(-1, DMUS_MIDIMODEF_GM);
                        }
                        for ( ; pPair; pPair = pPair->GetNext() )
                        {
                            StampedGMGSXG& rPair = pPair->GetItemValue();
                            pBandTrack->SetGMGSXGMode(rPair.mtTime, rPair.dwMidiMode);
                        }
                        gMidiModeList.CleanUp();

                        if(SUCCEEDED(pBandTrack->QueryInterface(IID_IDirectMusicTrack, 
                                                                (void**)&pDMTrack)))
                        {
                            pSegment->InsertTrack(pDMTrack, 1);
                            pDMTrack->Release();
                        }
                    }
                    
                    if(pBandTrack)
                    {
                        pBandTrack->Release();
                    }

                    if(pIDMLoader)
                    {
                        pIDMLoader->Release();
                    }
                }

            }

            if( gpTimeSigStream )
            {
                // Create a TimeSig Track to store the TimeSig events
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTimeSigTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    // set the overall size to the correct size
                    StreamSeek( gpTimeSigStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpTimeSigStream->Write( &gdwSizeTimeSigStream, sizeof(DWORD), NULL );
                    // reset to beginning and persist to track.
                    StreamSeek( gpTimeSigStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpTimeSigStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        AddOffsets(lstEvent, pDMTrack);
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }
            else
            {
                AddOffsets(lstEvent, NULL);
            }

            lstEvent = SortEventList( lstEvent );

            // Create a Sequence Track in which to store the notes, curves,
            // and SysEx events.
            //
            if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicSeqTrack,
                NULL, CLSCTX_INPROC, IID_IPersistStream,
                (void**)&pIPSTrack )))
            {
                // Create a stream in which to place the events so we can
                // give it to the SeqTrack.Load.
                IStream* pEventStream;

                if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
                {
                    // angusg: The implementation of memory IStream interface on
                    // CE can be inefficient if the stream memory isn't allocated
                    // before. It will call LocalRealloc on every IStream->Write
                    // for the amount that is written (in this case a small amount)
                    // this is incredible inefficient here as Realloc can be called
                    // thousands of times....
                    // The solution is to pre calculate the size of the stream and
                    // call ISteam->SetSize(), which calls LocalAlloc, to alloc the
                    // memory in one call.

                    // calculate the size of the stream storage
                    DWORD   dwStreamStorageSize;
                    FullSeqEvent* pEvent;

                    // add the size of the chunk id's written below
                    dwStreamStorageSize = 5 * sizeof(DWORD);
                    // now count how many events need to be stored in the stream
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        dwStreamStorageSize += sizeof(DMUS_IO_SEQ_ITEM);
                    }

                    ULARGE_INTEGER liSize;

                    liSize.QuadPart = dwStreamStorageSize;
                    // make the stream allocate the complete amount of memory
                    pEventStream->SetSize(liSize);

                    // Save the events into the stream
                    ULONG    cb, cbWritten;

                    // Save the chunk id
                    DWORD dwTemp = DMUS_FOURCC_SEQ_TRACK;
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Save the overall size. Count the number of events to determine.
                    dwSize = 0;
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        dwSize++;
                    }
                    dwSize *= sizeof(DMUS_IO_SEQ_ITEM);
                    // add 8 for the subchunk
                    dwSize += 8;
                    pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
                    // Save the subchunk id
                    dwTemp = DMUS_FOURCC_SEQ_LIST;
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Subtract the previously added 8
                    dwSize -= 8;
                    // Save the size of the subchunk
                    pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
                    // Save the structure size.
                    dwTemp = sizeof(DMUS_IO_SEQ_ITEM);
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Save the events.
                    cb = sizeof(DMUS_IO_SEQ_ITEM); // doesn't have the next pointers
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        if( dwLength < (DWORD)(pEvent->mtTime + pEvent->mtDuration) )
                        {
                            dwLength = pEvent->mtTime + pEvent->mtDuration;
                        }
                        pEventStream->Write( pEvent, cb, &cbWritten );
                        if( cb != cbWritten ) // error!
                        {
                            pEventStream->Release();
                            pEventStream = NULL;
                            hr = DMUS_E_CANNOTREAD;
                            break;
                        }
                    }

                    if( pEventStream ) // may be NULL
                    {
                        StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
                        pIPSTrack->Load( pEventStream );
                        pEventStream->Release();
                    }
                }

                if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                    (void**)&pDMTrack ) ) )
                {
                    pSegment->InsertTrack( pDMTrack, 1 );
                    pDMTrack->Release();
                }
                pIPSTrack->Release();
            }
            // set the length of the segment. Set it to the measure boundary
            // past the last note.
            DWORD dwResolvedLength = gTimeSig.lTime;
            if( 0 == gTimeSig.bBeat ) gTimeSig.bBeat = 4;
            if( 0 == gTimeSig.bBeatsPerMeasure ) gTimeSig.bBeatsPerMeasure = 4;
            if( 0 == gTimeSig.wGridsPerBeat ) gTimeSig.wGridsPerBeat = 4;
            while( dwResolvedLength < dwLength )
            {
                dwResolvedLength += (((DMUS_PPQ * 4) / gTimeSig.bBeat) * gTimeSig.bBeatsPerMeasure);
            }
            pSegment->SetLength( dwResolvedLength );

            if( gpSysExStream )
            {
                // Create a SysEx Track in which to store the SysEx events
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicSysExTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    // write overall length
                    StreamSeek( gpSysExStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpSysExStream->Write( &gdwSizeSysExStream, sizeof(DWORD), NULL );
                    // seek to beginning and persist to track
                    StreamSeek( gpSysExStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpSysExStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }

        }
        else
        {
            hr = E_POINTER;
        }
    }
END:
    List_Free( lstEvent );
    List_Free( lstPatchEvent );

    FullSeqEvent::CleanUp();

    // release our hold on the streams
    RELEASE( gpTempoStream );
    RELEASE( gpSysExStream );
    RELEASE( gpTimeSigStream );
    gpTempoStream = NULL;
    gpSysExStream = NULL;
    gpTimeSigStream = NULL;
    gdwSizeTimeSigStream = 0;
    gdwSizeSysExStream = 0;
    gdwSizeTempoStream = 0;
    LeaveCriticalSection(&g_CritSec);

    if (SUCCEEDED(hrGM) || hr != S_OK )
    {
        return hr;
    }
    else
    {
        return DMUS_S_PARTIALLOAD;
    }
}

// Creates and returns (in rChord) a DMUS_CHORD_PARAM given the three input params.
// the new chord will have one subchord containing the root, third, fifth, and seventh
// of the key (as indicated by the sharps/flats and mode).  Scale will be either
// major or minor, depending on the mode (mode is 0 if major, 1 if minor).
void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord)
{
    static DWORD dwMajorScale = 0xab5ab5;    // 1010 1011 0101 1010 1011 0101
    static DWORD dwMinorScale = 0x5ad5ad;    // 0101 1010 1101 0101 1010 1101
    static DWORD dwMajor7Chord = 0x891;        // 1000 1001 0001
    static DWORD dwMinor7Chord = 0x489;        // 0100 1000 1001
    BYTE bScaleRoot = 0;
    switch (cSharpsFlats)
    {
    case  0: bScaleRoot = bMode ?  9 :  0; break;
    case  1: bScaleRoot = bMode ?  4 :  7; break;
    case  2: bScaleRoot = bMode ? 11 :  2; break;
    case  3: bScaleRoot = bMode ?  6 :  9; break;
    case  4: bScaleRoot = bMode ?  1 :  4; break;
    case  5: bScaleRoot = bMode ?  8 : 11; break;
    case  6: bScaleRoot = bMode ?  3 :  6; break;
    case  7: bScaleRoot = bMode ? 10 :  1; break;
    case -1: bScaleRoot = bMode ?  2 :  5; break;
    case -2: bScaleRoot = bMode ?  7 : 10; break;
    case -3: bScaleRoot = bMode ?  0 :  3; break;
    case -4: bScaleRoot = bMode ?  5 :  8; break;
    case -5: bScaleRoot = bMode ? 10 :  1; break;
    case -6: bScaleRoot = bMode ?  3 :  6; break;
    case -7: bScaleRoot = bMode ?  8 : 11; break;
    }
    if (bMode)
    {
        wcscpy(rChord.wszName, L"m7");
    }
    else
    {
        wcscpy(rChord.wszName, L"M7");
    }
    DMUS_IO_TIMESIGNATURE_ITEM timesig;
    timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
    timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
    timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
    DWORD dwAbsBeat = dwTime / ((DMUS_PPQ * 4) / timesig.bBeat);
    rChord.wMeasure = (WORD)(dwAbsBeat / timesig.bBeatsPerMeasure);
    rChord.bBeat = (BYTE)(dwAbsBeat % timesig.bBeatsPerMeasure);
    rChord.bSubChordCount = 1;
    rChord.SubChordList[0].dwChordPattern = bMode ? dwMinor7Chord : dwMajor7Chord;
    rChord.SubChordList[0].dwScalePattern = bMode ? dwMinorScale : dwMajorScale;
    rChord.SubChordList[0].dwInversionPoints = 0xffffff;    // inversions allowed everywhere
    rChord.SubChordList[0].dwLevels = 0xffffffff;            // supports all levels
    rChord.SubChordList[0].bChordRoot = bScaleRoot;
    rChord.SubChordList[0].bScaleRoot = bScaleRoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\pchmap.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */

#ifndef _PCHMAP__
#define _PCHMAP__
#include "dmusici.h"
#include "..\dmstyle\tlist.h"

struct PCHMAP_ITEM
{
	MUSIC_TIME	mtNext;
	DWORD		dwPChannel;
	DWORD		dwPChMap;
	BOOL		fMute;
};

class CPChMap
{
public:
	CPChMap();
	~CPChMap();
	void Reset(void);
	void GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
				  IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh , BOOL fClockTime);
private:
	TList<PCHMAP_ITEM>	m_PChMapList;
};
#endif // _PCHMAP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\ntfylist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// NtfyList.h

#include "alist.h"
#include "dmusici.h"
#include "debug.h"

#ifndef __NTFYLIST_H_
#define __NTFYLIST_H_

class CNotificationItem : public AListItem
{
public:
	CNotificationItem* GetNext()
	{
		return (CNotificationItem*)AListItem::GetNext();
	};
public:
	GUID	guidNotificationType;
    BOOL    fFromPerformance;
};

class CNotificationList : public AList
{
public:
    CNotificationItem* GetHead() 
	{
		return (CNotificationItem*)AList::GetHead();
	};
    CNotificationItem* RemoveHead() 
	{
		return (CNotificationItem*)AList::RemoveHead();
	};
    CNotificationItem* GetItem(LONG lIndex) 
	{
		return (CNotificationItem*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CNotificationItem* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
};

#endif // __NTFYLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\mutx.h ===
// Copyright (c) 1998 Microsoft Corporation
/* No longer used */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\paramtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

// This track holds curve information for automation (like automating sliders on a mixing board -- not OLE automation)
// of effects and tools in the audio path.

#pragma once

#include "trackhelp.h"
//#include "imediaobjectparams.h"
//#include "mediaobj.h" //  need to get this from public\sdk\inc
#include "medparam.h"
#include "dmusicf.h"

// {827F0437-9ED6-4107-8494-49976FF5B642}
DEFINE_GUID(IID_CParamControlTrack, 0x827f0437, 0x9ed6, 0x4107, 0x84, 0x94, 0x49, 0x97, 0x6f, 0xf5, 0xb6, 0x42);

class CParamControlTrack
  : public CBasicTrack
{
    // types for track data...

    struct ParamInfo
    {
        ParamInfo() : curves(NULL), curvesEnd(NULL), fAlreadyTracedPlaybackError(false) { Zero(&header); }
        ~ParamInfo() { delete[] curves; }

        DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER header;
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curves; // pointer to first curve
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curvesEnd; // pointer one past last curve
        bool fAlreadyTracedPlaybackError;
    };

    struct ObjectInfo
    {
        ObjectInfo() : fAlreadyTracedPlaybackError(false) { Zero(&header); }

        DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER header;
        TList<ParamInfo> listParams;
        bool fAlreadyTracedPlaybackError;
    };

    struct ParamState // the state data we need to keep track of for each parameter we're controlling
    {
        ParamState() : pCurrentCurve(NULL), fLast(false), rtStartPointOfLastCurve(0) {}

        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurrentCurve; // current seek pointer in the array of control points
        bool fLast; // true if the last envelope was sent successfully
        REFERENCE_TIME rtStartPointOfLastCurve; // time (in the object's time) of the start point of the last envelope we sent
        TList<REFERENCE_TIME> listStartTimes; // start times of all envelopes that have been sent 
    };

    struct StateData
    {
        StateData() : prgpIMediaParams(NULL), prgParam(NULL), fFlushInAbort(false) {}

        IMediaParams **prgpIMediaParams; // Array of size m_cObjects.
        ParamState *prgParam; // Array of size m_cParams.
        DWORD dwValidate;
        bool fFlushInAbort;
    };

public:
    CParamControlTrack(HRESULT *pHr) : m_dwValidate(0), m_cObjects(0), m_cParams(0), CBasicTrack(&g_cComponent, CLSID_DirectMusicParamControlTrack) {}

    STDMETHOD(QueryInterface)(const IID &iid, void **ppv);

    STDMETHOD(Init)(IDirectMusicSegment *pSegment);
    STDMETHOD(Load)(IStream* pIStream);
    STDMETHOD(InitPlay)(
        IDirectMusicSegmentState *pSegmentState,
        IDirectMusicPerformance *pPerformance,
        void **ppStateData,
        DWORD dwTrackID,
        DWORD dwFlags);
    STDMETHOD(EndPlay)(void *pStateData);
    STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
    virtual HRESULT PlayMusicOrClock(
        void *pStateData,
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        bool fClockTime);

    virtual HRESULT OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData);

private:
    HRESULT LoadObject(SmartRef::RiffIter ri);
    HRESULT LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams);
    HRESULT TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt);
    HRESULT PlayEnvelope(
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime);
    HRESULT PlayTruncatedEnvelope(
        MUSIC_TIME mtTruncStart,
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        DWORD dwFlags);
        HRESULT InitStateData(
            StateData *pStateData,
            IDirectMusicSegmentState *pSegmentState);

    DWORD m_dwValidate; // Increment this counter in Load, causing the state data to synchonize with the new events
    TList<ObjectInfo> m_listObjects;
    int m_cObjects;
    int m_cParams;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\paramtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

#include "dmime.h"
#include "ParamTrk.h"
#include "..\shared\Validate.h"
#include "miscutil.h"
#include "limits.h"
#include "math.h"


STDMETHODIMP 
CParamControlTrack::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CParamControlTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
		*ppv = static_cast<IDirectMusicTrack8*>(this);
	else if (iid == IID_IPersistStream)
		*ppv = static_cast<IPersistStream*>(this);
	else if (iid == IID_IPersist)
		*ppv = static_cast<IPersist*>(this);
    else if (iid == IID_CParamControlTrack)
    {
        *ppv = static_cast<CParamControlTrack*>(this);
    }
	else
	{
		*ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP
CParamControlTrack::Init(IDirectMusicSegment *pSegment)
{
    V_INAME(CBasicTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Load(IStream* pIStream)
{
    V_INAME(CPlayingTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    // Increment counter so the next play will update state data with the new list.
    ++m_dwValidate;
    // Clear the objects/params/curves in case we're being reloaded.
    m_listObjects.CleanUp();
    m_cObjects = 0;
    m_cParams = 0;

    SmartRef::RiffIter ri(pIStream);
    if (!ri)
        return ri.hr();

    // find <prmt>
    hr = ri.FindRequired(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: List 'prmt' not found.\n");
        }
#endif
        return hr;
    }
    SmartRef::RiffIter riTrack = ri.Descend();

    // for each <prol>
    while (riTrack && riTrack.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST))
    {
        hr = this->LoadObject(riTrack.Descend());
        if (FAILED(hr))
            return hr;
        ++riTrack;
    }
    hr = riTrack.hr();

    return hr;
}

STDMETHODIMP
CParamControlTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,
    IDirectMusicPerformance *pPerformance,
    void **ppStateData,
    DWORD dwTrackID,
    DWORD dwFlags)
{
    V_INAME(CParamControlTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    SmartRef::CritSec CS(&m_CriticalSection);

    // Set up state data
    StateData *pStateData = new StateData;
    if (!pStateData)
        return E_OUTOFMEMORY;

    HRESULT hr = InitStateData(pStateData, pSegmentState);
    if (FAILED(hr))
    {
        delete pStateData;
    }
    else
    {
        pStateData->dwValidate = m_dwValidate;
        *ppStateData = pStateData;
    }

    return hr;
}

STDMETHODIMP
CParamControlTrack::EndPlay(void *pStateData)
{
    V_INAME(CParamControlTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(StateData));

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (!pSD->fFlushInAbort)
    {
        // For each object, flush all curves on each parameter up to the start time of the last one we sent.
        //    (This allows the DMO being controlled to free up memory associated with any previous curves
        //     while still keeping the last one around so that the next thing played picks up that parameter
        //     value how it was left.)
        // Then release the object's params interface.
        int iObj = 0;
        for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
                pObject && iObj < m_cObjects;
                pObject = pObject->GetNext(), ++iObj)
        {
            IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
            if (pIMediaParams)
            {
                ObjectInfo &obj = pObject->GetItemValue();
                int iParam = 0;
                for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                        pParam && iParam < m_cParams;
                        pParam = pParam->GetNext(), ++iParam)
                {
                    ParamInfo &param = pParam->GetItemValue();
                    ParamState &paramstate = pSD->prgParam[iParam];
                    if (paramstate.fLast)
                    {
                        HRESULT hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                        if (FAILED(hrFlush))
                        {
                            assert(false);
                            TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                        }
                    }
                }
            }
            SafeRelease(pIMediaParams);
        }
    }
    delete[] pSD->prgpIMediaParams;
    delete[] pSD->prgParam;
    delete pSD;

    return S_OK;
}

HRESULT CParamControlTrack::OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData)
{
    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    // For each object, flush all curves on each parameter up to the start time of the last one we sent
    // (if that started before segment end) or flush everything up to the last one to start before
    // segment end, and flush everything after segment end (if the start time was after segment end).
    //    (This allows the DMO being controlled to free up memory associated with any previous curves
    //     while still keeping the last one around so that the next thing played picks up that parameter
    //     value how it was left.)
    // Then release the object's params interface.
    int iObj = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObj < m_cObjects;
            pObject = pObject->GetNext(), ++iObj)
    {
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
        if (pIMediaParams)
        {
            ObjectInfo &obj = pObject->GetItemValue();
            int iParam = 0;
            for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                    pParam && iParam < m_cParams;
                    pParam = pParam->GetNext(), ++iParam)
            {
                ParamInfo &param = pParam->GetItemValue();
                ParamState &paramstate = pSD->prgParam[iParam];
                if (paramstate.fLast)
                {
                    HRESULT hrFlush = S_OK;
                    if (paramstate.rtStartPointOfLastCurve < rtEnd)
                    {
                        hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                    }
                    else
                    {
                        // first, look for the largest start time less than rtEnd and
                        // flush up to there.  The loop assumes the list is ordered largest to smallest.
                        TListItem<REFERENCE_TIME>* pStartTime = paramstate.listStartTimes.GetHead();
                        for (; pStartTime; pStartTime = pStartTime->GetNext())
                        {
                            if (pStartTime->GetItemValue() < rtEnd)
                            {
                                hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, pStartTime->GetItemValue());
                                break;
                            }
                        }
                        // Then, flush from rtEnd on.
                        if (SUCCEEDED(hrFlush))
                        {
                            hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, rtEnd, _I64_MAX);
                        }
                    }
                    if (FAILED(hrFlush))
                    {
                        assert(false);
                        TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                    }
                }
            }
        }
        SafeRelease(pIMediaParams);
        pSD->prgpIMediaParams[iObj] = NULL;
    }

    pSD->fFlushInAbort = true;

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, IDirectMusicTrack** ppTrack)
{
    //  Test more thoroughly when we have multiple working params/objects.

    V_INAME(CParamControlTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    SmartRef::CritSec CS(&m_CriticalSection);

    HRESULT hr = S_OK;

    SmartRef::ComPtr<CParamControlTrack> scomTrack = new CParamControlTrack(&hr);
    if (FAILED(hr))
        return hr;
    if (!scomTrack)
        return E_OUTOFMEMORY;
    scomTrack->AddRef();

    // Copy each object
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext())
    {
        ObjectInfo &obj = pObject->GetItemValue();
        TListItem<ObjectInfo> *pNewObject = new TListItem<ObjectInfo>;
        if (!pNewObject)
            return E_OUTOFMEMORY;
        ObjectInfo &newobj = pNewObject->GetItemValue();
        newobj.header = obj.header;

        // Copy each parameter
        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam;
                pParam = pParam->GetNext())
        {
            ParamInfo &param = pParam->GetItemValue();
            TListItem<ParamInfo> *pNewParam = new TListItem<ParamInfo>;
            if (!pNewParam)
                return E_OUTOFMEMORY;
            ParamInfo &newparam = pNewParam->GetItemValue();
            newparam.header = param.header;

            // Copy the curves from mtStart to mtEnd
            // These should include curves that overlap the start and end, though this
            // leave some issues we still need to work out (what happens with overlapping curves?)
            // So, first find the first curve whose end time is at or after mtStart...
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveStart = param.curves;
                    (pCurveStart < param.curvesEnd) && (pCurveStart->mtEndTime < mtStart);
                    ++pCurveStart)
            {}
            // Then, find the curve whose start time is after mtEnd.
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveEnd = pCurveStart;
                    (pCurveEnd < param.curvesEnd) && (pCurveEnd->mtStartTime < mtEnd);
                    ++pCurveEnd)
            {}
            int cCurves = (int)(pCurveEnd - pCurveStart);
            newparam.curves = new DMUS_IO_PARAMCONTROLTRACK_CURVEINFO[cCurves];
            if (!newparam.curves)
                return E_OUTOFMEMORY;
            memcpy(newparam.curves, pCurveStart, cCurves * sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO));
            newparam.curvesEnd = newparam.curves + cCurves;
            // Now, scan through the new curve array and adjust the times by subtracting mtStart from everything.
            for (pCurveStart = newparam.curves; pCurveStart < newparam.curvesEnd; pCurveStart++)
            {
                pCurveStart->mtStartTime -= mtStart;
                pCurveStart->mtEndTime -= mtStart;
            }

            newobj.listParams.AddHead(pNewParam);
        }

        newobj.listParams.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different parameters in the exact same order just in case.
        scomTrack->m_listObjects.AddHead(pNewObject);
    }
    scomTrack->m_listObjects.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different objects in the exact same order just in case.
    ++scomTrack->m_dwValidate;

    scomTrack->m_cObjects = m_cObjects;
    scomTrack->m_cParams = m_cParams;

    *ppTrack = scomTrack.disown();
    return hr;
}

HRESULT
CParamControlTrack::PlayMusicOrClock(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    bool fClockTime)
{
    V_INAME(CParamControlTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(StateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
        return S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (m_dwValidate != pSD->dwValidate)
    {
        HRESULT hr = InitStateData(pSD, pSegSt);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    // envelope structure we'll fill for sending each envelope segment.
    MP_ENVELOPE_SEGMENT envCurve;
    Zero(&envCurve);
    MP_ENVELOPE_SEGMENT *const penvCurve = &envCurve;

    bool fMoreCurves = false; // set to true by any parameter that has more curves to play

    // for each parameter...
    int iParam = 0;
    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObject < m_cObjects;
            pObject = pObject->GetNext(), ++iObject)
    {
        ObjectInfo &obj = pObject->GetItemValue();
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObject];

        bool fObjClockTime = !!(obj.header.guidTimeFormat == GUID_TIME_REFERENCE);
        if (!fObjClockTime && obj.header.guidTimeFormat != GUID_TIME_MUSIC)
        {
            // track can only handle music and clock time
            assert(false);
            // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
            TraceI(
                obj.fAlreadyTracedPlaybackError ? 3 : 1,
                "Parameter control track unable to control object -- unknown time format (must be GUID_TIME_MUSIC or GUID_TIME_REFERENCE).\n");
            obj.fAlreadyTracedPlaybackError = true;
            continue;
        }

        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam && iParam < m_cParams;
                pParam = pParam->GetNext(), ++iParam)
        {
            ParamInfo &param = pParam->GetItemValue();
            ParamState &paramstate = pSD->prgParam[iParam];

            DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *&pCurrentCurve = paramstate.pCurrentCurve;

            // We're going to seek through the event list to find the proper next control curve for each parameter if
            // the track's data has been reloaded or if playback has made a jump to a different position in the track.
            if (m_dwValidate != pSD->dwValidate || dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH | DMUS_TRACKF_START))
            {
                assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are

                // find first curve that begins at or after the start time we're currently playing
                for (pCurrentCurve = param.curves; pCurrentCurve < param.curvesEnd && pCurrentCurve->mtStartTime < mtStart; ++pCurrentCurve)
                {}

                if (pIMediaParams && pCurrentCurve > param.curves)
                {
                    // check the previous curve to see if we ended up in the middle of it
                    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPrevCurve = pCurrentCurve - 1;
                    // Send a curve chopped off at the start time we're currently playing.
                    // We can't send the whole curve because it would take effect too early.
                    HRESULT hrEnv = this->PlayTruncatedEnvelope(mtStart, pIMediaParams, penvCurve, pPrevCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime, dwFlags);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            // Send curves until the next curve is after mtEnd
            for ( ; pCurrentCurve < param.curvesEnd; ++pCurrentCurve )
            {
                if (pCurrentCurve->mtStartTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
                    continue;
                if (pCurrentCurve->mtStartTime >= mtEnd)
                    break;

                // send this curve
                if (pIMediaParams)
                {
                    HRESULT hrEnv = this->PlayEnvelope(pIMediaParams, penvCurve, pCurrentCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            if (pCurrentCurve < param.curvesEnd)
                fMoreCurves = true;
        }
        assert(!pParam); // we should have gotten all the way through this param list
    }
    assert(!pObject && iParam == m_cParams && iObject == m_cObjects); // we should have gotten all the way through the object list and done the expected number of objects and parameters

    pSD->dwValidate = m_dwValidate; // if we weren't in sync with new track data before, we are now
    return fMoreCurves ? S_OK : DMUS_S_END;
}

HRESULT CParamControlTrack::LoadObject(SmartRef::RiffIter ri)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ObjectInfo> > spItem = new TListItem<ObjectInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ObjectInfo &ritem = spItem->GetItemValue();

    // find <proh>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'proh' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;
    if (!(ritem.header.guidTimeFormat == GUID_TIME_MUSIC || ritem.header.guidTimeFormat == GUID_TIME_REFERENCE))
    {
        Trace(1, "Error: Unable to load parameter control track: guidTimeFormat in chunk 'proh' must be either GUID_TIME_MUSIC or GUID_TIME_REFERENCE.\n");
        return DMUS_E_INVALID_PARAMCONTROLTRACK;
    }

    // for each <prpl>
    while (ri && ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST))
    {
        hr = this->LoadParam(ri.Descend(), ritem.listParams);
        if (FAILED(hr))
            return hr;
        ++ri;
    }
    hr = ri.hr();

    if (SUCCEEDED(hr))
    {
        m_listObjects.AddHead(spItem.disown());
        ++m_cObjects;
    }
    return hr;
}

HRESULT CParamControlTrack::LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ParamInfo> > spItem = new TListItem<ParamInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ParamInfo &ritem = spItem->GetItemValue();

    // find <prph>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'prph' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;

    // find <prcc>
    if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK))
    {
        // It is OK if we read to the end without finding the chunk--we succeed without finding any curves.
        // Or it could be a failure because there was a problem reading from the stream.
        // The RiffIter's hr method reflects this.
        return ri.hr();
    }

    // read the array of control curves
    int cRecords;
    hr = SmartRef::RiffIterReadArrayChunk(ri, &ritem.curves, &cRecords);
    if (FAILED(hr))
        return hr;
    ritem.curvesEnd = ritem.curves + cRecords;

    listParams.AddHead(spItem.disown());
    ++m_cParams;
    return hr;
}

HRESULT CParamControlTrack::TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt)
{
    HRESULT hr = S_OK;

    // set the time (reference time variable is used to hold either music or reference time in different contexts)
    REFERENCE_TIME rtEnv = mt;

    // add the correct offset and if necessary convert from millisecond time 
    rtEnv = fTrkClockTime
                ? rtEnv * gc_RefPerMil + rtOffset
                : rtEnv = rtEnv + mtOffset;

    if (fTrkClockTime != fObjClockTime)
    {
        // need to convert between out track's time format and the audio object's time format
        if (fObjClockTime)
        {
            MUSIC_TIME mtEnv = static_cast<MUSIC_TIME>(rtEnv);
            hr = pPerf->MusicToReferenceTime(mtEnv, &rtEnv);
            if (FAILED(hr))
                return hr;
        }
        else
        {
            MUSIC_TIME mtEnv = 0;
            hr = pPerf->ReferenceToMusicTime(rtEnv, &mtEnv);
            rtEnv = mtEnv;
            if (FAILED(hr))
                return hr;
        }
    }

    *rt = rtEnv;
    return hr;
}

HRESULT
CParamControlTrack::PlayEnvelope(
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime)
{
    HRESULT hr = S_OK;

    // set the curve type and flags
    pEnv->iCurve = static_cast<MP_CURVE_TYPE>(pPt->dwCurveType);
    pEnv->flags = pPt->dwFlags;

    pEnv->valEnd = pPt->fltEndValue;
    pEnv->valStart = pPt->fltStartValue;

    // set the time (used to hold either music or reference time in different contexts)

    REFERENCE_TIME &rtEnvStart = pEnv->rtStart;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtStartTime, &rtEnvStart);
    if (FAILED(hr))
        return hr;

    REFERENCE_TIME &rtEnvEnd = pEnv->rtEnd;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtEndTime, &rtEnvEnd);
    if (FAILED(hr))
        return hr;

    hr = pIMediaParams->AddEnvelope(param.header.dwIndex, 1, pEnv);
    if (SUCCEEDED(hr))
    {
        paramstate.rtStartPointOfLastCurve = rtEnvStart;
        TListItem<REFERENCE_TIME>* pStartTime = new TListItem<REFERENCE_TIME>;
        if (pStartTime)
        {
            pStartTime->GetItemValue() = rtEnvStart;
            // Adding to the head maintains a largest-to-smallest ordering.
            paramstate.listStartTimes.AddHead(pStartTime);
        }
        paramstate.fLast = true;
    }

    return hr;
}

HRESULT
CParamControlTrack::PlayTruncatedEnvelope(
    MUSIC_TIME mtTruncStart,
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime,
    DWORD dwFlags)
{
    // Copy info from the curve
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO curveinfo = *pPt;
    // Cut the start to the designated time
    curveinfo.mtStartTime = mtTruncStart;
    bool fSkip = false;

    if (mtTruncStart >= curveinfo.mtEndTime)
    {
        // Curve happened in the past.  Send a jump curve right at the current (truncate) time picking up with
        // that value.
        // if we're looping and we passed the end of this curve, just skip it.
        if ( (dwFlags & DMUS_TRACKF_LOOP) )
        {
            fSkip = true;
        }
        else
        {
            curveinfo.mtEndTime = mtTruncStart;
            curveinfo.dwCurveType = MP_CURVE_JUMP;
        }
    }
    else if (pPt->dwCurveType != MP_CURVE_JUMP)
    {
        // Find the point at that time and pick up with a linear curve from there.
        // (For the nonlinear curves, there's no way to pick them up part-way along.)
        curveinfo.dwCurveType = MP_CURVE_LINEAR;

        MUSIC_TIME mtTimeChange = pPt->mtEndTime - pPt->mtStartTime;
        MUSIC_TIME mtTimeIntermediate = mtTruncStart - pPt->mtStartTime;

        float fltScalingX = static_cast<float>(mtTimeIntermediate) / mtTimeChange; // horizontal distance along curve between 0 and 1
        float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
        switch (pPt->dwCurveType)
        {
        case MP_CURVE_SQUARE:
            fltScalingY = fltScalingX * fltScalingX;
            break;
        case MP_CURVE_INVSQUARE:
            fltScalingY = (float) sqrt(fltScalingX);
            break;
        case MP_CURVE_SINE:
            //  Maybe we should have a lookup table here?
            fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
            break;
        case MP_CURVE_LINEAR:
        default:
            fltScalingY = fltScalingX;
        }

        // Apply that scaling to the range of the actual points
        curveinfo.fltStartValue = (pPt->fltEndValue - pPt->fltStartValue) * fltScalingY + pPt->fltStartValue;
    }

    if (fSkip) return S_OK;

    return this->PlayEnvelope(pIMediaParams, pEnv, &curveinfo, obj, param, paramstate, mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime);
}

HRESULT CParamControlTrack::InitStateData(StateData *pStateData,
                                          IDirectMusicSegmentState *pSegmentState)
{
    if (pStateData->prgpIMediaParams)
    {
        delete [] pStateData->prgpIMediaParams;
        pStateData->prgpIMediaParams = NULL;
    }
    if (pStateData->prgParam)
    {
        delete [] pStateData->prgParam;
        pStateData->prgParam = NULL;
    }

    pStateData->prgpIMediaParams = new IMediaParams *[m_cObjects];
    if (!pStateData->prgpIMediaParams)
    {
        return E_OUTOFMEMORY;
    }
    pStateData->prgParam = new ParamState[m_cParams];
    if (!pStateData->prgParam)
    {
        delete [] pStateData->prgpIMediaParams;
        return E_OUTOFMEMORY;
    }

    // Get the IMediaParams interface for each object
    SmartRef::ComPtr<IDirectMusicSegmentState8> scomSegSt8;
    HRESULT hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&scomSegSt8));
    if (FAILED(hr))
    {      
        delete [] pStateData->prgParam;
        delete [] pStateData->prgpIMediaParams;
        return hr;
    }

    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext(), ++iObject)
    {
        IMediaParams *pIMediaParams = NULL;
        ObjectInfo &rinfo = pObject->GetItemValue();
        HRESULT hrObject = scomSegSt8->GetObjectInPath(
                                rinfo.header.dwPChannel,
                                rinfo.header.dwStage,
                                rinfo.header.dwBuffer,
                                rinfo.header.guidObject,
                                rinfo.header.dwIndex,
                                IID_IMediaParams,
                                reinterpret_cast<void**>(&pIMediaParams));
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            TraceI(1, "Parameter control track was unable to find audio path object, HRESULT 0x%08x.\n", hrObject);
        }
        else
        {
            hrObject = pIMediaParams->SetTimeFormat(rinfo.header.guidTimeFormat, rinfo.header.guidTimeFormat == GUID_TIME_MUSIC ? 768 : 0);
        }
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            Trace(1, "Unable to set time format of object in parameter control track, HRESULT 0x%08x.\n", hrObject);
        }
        if (FAILED(hrObject))
        {
            SafeRelease(pIMediaParams);
        }
        pStateData->prgpIMediaParams[iObject] = pIMediaParams;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\queue.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// queue.cpp
#include "debug.h"
#define ASSERT	assert
#include "dmime.h"
#include "dmperf.h"

CPMsgQueue::CPMsgQueue()

{
    m_pTop = NULL;
    m_pLastAccessed = NULL;
}

CPMsgQueue::~CPMsgQueue()

{
}

static PRIV_PMSG * sortevents( PRIV_PMSG * pEvents, long lLen )

{
    PRIV_PMSG * pLeft;
    PRIV_PMSG * pRight ;
    long        lLeft;
    long        lRight ;
    PRIV_PMSG * pTop ;

    if( lLen < 3 )
    {
        if( !pEvents )
            return( 0 ) ;
        if( lLen == 1 )
            return( pEvents ) ;
        pLeft  = pEvents ;
        pRight = pEvents->pNext ;
        if( !pRight )
            return( pLeft ) ;
        if( pLeft->rtTime > pRight->rtTime )
        {
            pLeft->pNext = NULL ;
            pRight->pNext = pLeft ;
            return( pRight ) ;
        }
        return( pLeft ) ;
    }

    lLeft = lLen >> 1 ;
    lRight = lLen - lLeft;
    pLeft = pEvents ;
    for (;lLeft > 1;pEvents = pEvents->pNext) lLeft--;
    pRight = sortevents( pEvents->pNext, lRight ) ;
    pEvents->pNext = NULL ;
    pLeft = sortevents( pLeft, lLen - lRight ) ;
    pTop = NULL ;

    for( ;  pLeft && pRight ;  )
    {
        if( pLeft->rtTime < pRight->rtTime )
        {
            if( !pTop )
                pTop = pLeft ;
            else
                pEvents->pNext = pLeft ;
            pEvents = pLeft ;
            pLeft   = pEvents->pNext ;
        }
        else
        {
            if( !pTop )
                pTop = pRight ;
            else
                pEvents->pNext = pRight ;
            pEvents = pRight ;
            pRight  = pEvents->pNext ;
        }
    }

    if( pLeft )
        pEvents->pNext = pLeft ;
    else
        pEvents->pNext = pRight ;

    return( pTop ) ;

}   

void CPMsgQueue::Sort() 

{
    m_pTop = sortevents(m_pTop, GetCount()) ;
    m_pLastAccessed = NULL;
}  

long CPMsgQueue::GetCount()

{
    long lCount = 0;
    PRIV_PMSG *pScan = GetHead();
    for (;pScan;pScan = pScan->pNext)
    {
        lCount++;
    }
    return lCount;
}

void CPMsgQueue::Enqueue(PRIV_PMSG *pItem)

{
    if (!pItem)
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a NULL pItem!\n");
        return;
    }
    // Ensure not already queued...
    if (pItem->dwPrivFlags & PRIV_FLAG_QUEUED)
    {
        TraceI(0,"ENQUEUE: Item thinks it is still in a queue!\n");
        return;
    }
	pItem->dwPrivFlags |= PRIV_FLAG_QUEUED;
    PRIV_PMSG *pScan; 
#ifdef DBG
    // Verify robustness of list. Check that the event is not already in the list
    // and that the time stamps are all in order.
    REFERENCE_TIME rtTime = 0;
    for (pScan = m_pTop;pScan;pScan = pScan->pNext)
    {
        if (pScan == pItem)
        {
            TraceI(0,"ENQUEUE: Item is already in the queue!\n"); 
            return;
        }
    	// this must queue events in time sorted order
        if (pScan->rtTime < rtTime)
        {
            TraceI(0,"ENQUEUE: Queue is not in time order!\n");
            pScan->rtTime = rtTime;
        }
        else if (pScan->rtTime > rtTime)
        {
            rtTime = pScan->rtTime;
        }
    }
#endif
    if ( !(pItem->dwFlags & DMUS_PMSGF_REFTIME) ) // sorting on reftime, so this must be valid 
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a pItem with a bogus RefTime!\n");
        return;
    }
    if (m_pLastAccessed && (m_pLastAccessed->rtTime <= pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    if ( pScan && ( pScan->rtTime <= pItem->rtTime ) )
	{
		for (;pScan->pNext; pScan = pScan->pNext )
		{
			if( pScan->pNext->rtTime > pItem->rtTime )
			{
				break;
			}
		}
		pItem->pNext = pScan->pNext;
		pScan->pNext = pItem;
    }
	else 
	{
		pItem->pNext = m_pTop;
		m_pTop = pItem;
	}
    m_pLastAccessed = pItem;
}

/*  Remove the oldest event before time rtTime, making sure that there is still
    at minimum one event prior to that time stamp. 
    This ensures that there is a sufficiently old event, but gets rid of old
    stale events. This is used by the timesig and tempomap lists.
*/

PRIV_PMSG *CPMsgQueue::FlushOldest(REFERENCE_TIME rtTime)

{
    PRIV_PMSG *pNext;
    if (m_pTop && (pNext = m_pTop->pNext))
    {
        if (pNext->rtTime < rtTime)
        {
            PRIV_PMSG *pDelete = m_pTop;
            if (m_pLastAccessed == m_pTop)
            {
                m_pLastAccessed = pNext;
            }
            m_pTop = pNext;
			pDelete->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
			pDelete->pNext = NULL;
            return pDelete;
        }
    }
    return NULL;
}

PRIV_PMSG *CPMsgQueue::Dequeue()

{
    PRIV_PMSG *pItem = m_pTop;

    if (pItem != NULL)
	{
        m_pTop = pItem->pNext;
		pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
        pItem->pNext = NULL;
        if (m_pLastAccessed == pItem)
        {
            m_pLastAccessed = m_pTop;
        }
    }

    return pItem;
}

PRIV_PMSG *CPMsgQueue::Dequeue(PRIV_PMSG *pItem)

{
    ASSERT(pItem);

    if (pItem == m_pTop)
    {
        return Dequeue();
    }
    PRIV_PMSG *pScan;
    PRIV_PMSG *pNext;
    if (m_pLastAccessed && 
        (m_pLastAccessed->rtTime < pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    for (;pScan;pScan = pNext)
    {
        pNext = pScan->pNext;
        if (pNext == pItem)
        {
            pScan->pNext = pItem->pNext;
            pItem->pNext = NULL;
            pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
            if (m_pLastAccessed == pItem)
            {
                m_pLastAccessed = pScan;
            }
            return pItem;
        }
    }
    if (m_pLastAccessed)
    {
        // This happens every now and then as a result of a curve setting rtTime to 0
        // in the middle of FlushEventQueue. 
        // This should be fixed, but this patch will work for now.
        m_pLastAccessed = NULL;
        return Dequeue(pItem);
    }
    return NULL;
}

// queue Segment nodes in time order. pItem must be in the same
// time base as all items in ppList (RefTime or Music Time.)

void CSegStateList::Insert(CSegState* pItem)

{
    CSegState *pScan = GetHead();
    CSegState *pNext;
    pItem->SetNext(NULL);
    if (pScan)
	{
		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
		{
			ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_rtGivenStart < pScan->m_rtGivenStart )
			{
                AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( ( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_rtGivenStart > pNext->m_rtGivenStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_rtGivenStart < pNext->m_rtGivenStart )
					{
						break;
					}
					pScan = pNext;
				}
				if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
		else
		{
			ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_mtResolvedStart < pScan->m_mtResolvedStart )
			{
				AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( !( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_mtResolvedStart > pNext->m_mtResolvedStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_mtResolvedStart < pNext->m_mtResolvedStart )
					{
						break;
					}
					pScan = pNext;
				}
                if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
    }
	else
	{
		m_pHead = pItem;
	}
}

/*


void enqueue(CSegState **ppList, CSegState *pItem)
{
    CSegState *li = *ppList;

    if (li)
	{
		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
		{
			ASSERT( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
			// Avoid putting circularities in the list
			if (pItem == *ppList)
			{
				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_rtGivenStart < li->m_rtGivenStart )
			{
				pItem->pNext = li;
				*ppList = pItem;
			}
			else
			{
				while( li->pNext )
				{
					ASSERT( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
					// Am I trying to insert something that's already in the list?
					if (pItem == li)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( ( li->pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 li->m_rtGivenStart > li->pNext->m_rtGivenStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						li->pNext = NULL;
						break;
					}
					if( pItem->m_rtGivenStart < li->pNext->m_rtGivenStart )
					{
						break;
					}
					li = li->pNext;
				}
				if (pItem != li)
				{
					pItem->pNext = li->pNext;
					li->pNext = pItem;
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
		else
		{
			ASSERT( !( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
			// Avoid putting circularities in the list
			if (pItem == *ppList)
			{
				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_mtResolvedStart < li->m_mtResolvedStart )
			{
				pItem->pNext = li;
				*ppList = pItem;
			}
			else
			{
				while( li->pNext )
				{
					ASSERT( !( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
					// Am I trying to insert something that's already in the list?
					if (pItem == li)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( !( li->pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 li->m_mtResolvedStart > li->pNext->m_mtResolvedStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						li->pNext = NULL;
						break;
					}
					if( pItem->m_mtResolvedStart < li->pNext->m_mtResolvedStart )
					{
						break;
					}
					li = li->pNext;
				}
				if (pItem != li)
				{
					pItem->pNext = li->pNext;
					li->pNext = pItem;
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
    }
	else
	{
		*ppList = pItem;
	}
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\segtrtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

#include "dmime.h"
#include "segtrtrk.h"
#include "..\shared\Validate.h"
#include "dmperf.h"
#include "miscutil.h"

//////////////////////////////////////////////////////////////////////
// SetParam

STDMETHODIMP
CSegTriggerTrack::SetParam(REFGUID rguid, MUSIC_TIME mtTime, void *pData)
{
	HRESULT hr = S_OK;
    // Allow a certain amount of recursion. If it gets to 10, something is obviously broken.
    if (m_dwRecursionCount < 10)
    {
        m_dwRecursionCount++;
	    TListItem<TriggerInfo> *li = m_EventList.GetHead();
	    for (; li; li = li->GetNext())
	    {
		    TriggerInfo &rinfo = li->GetItemValue();
		    rinfo.pIDMSegment->SetParam(rguid, 0xFFFFFFFF, DMUS_SEG_ALLTRACKS, mtTime - rinfo.lTimePhysical, pData);
	    }
        m_dwRecursionCount--;
    }

	return hr;
}

STDMETHODIMP
CSegTriggerTrack::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	// Call PlayingTrack base class, which sets up our state data.
	HRESULT hr = CSegTriggerTrackBase::InitPlay(pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
	if (SUCCEEDED(hr))
	{
		// Get the audiopath being used by our segment state and save it in our state data.
		assert(*ppStateData); // base class should have created state data
		assert(pSegmentState); // base class should have returned E_POINTER if it wasn't given a segment state

		CSegTriggerTrackState *pState = static_cast<CSegTriggerTrackState *>(*ppStateData);

		IDirectMusicSegmentState8 *pSegSt8 = NULL;
		hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
		if (SUCCEEDED(hr))
		{
			hr = pSegSt8->GetObjectInPath(
							0,							// pchannel doesn't apply
							DMUS_PATH_AUDIOPATH,		// get the audiopath
							0,							// buffer index doesn't apply
							CLSID_NULL,					// clsid doesn't apply
							0,							// there should be only one audiopath
							IID_IDirectMusicAudioPath,
							reinterpret_cast<void**>(&pState->pAudioPath));

        	pSegSt8->Release();

			// If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
			// pAudioPath stays NULL and we'll play our triggered segments on the general performance.
			if (hr == DMUS_E_NOT_FOUND)
				hr = S_OK;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Load

// Helper used by the Load functions when we expected to find something
// but a RiffIter becomes false.  In this case, if it has a success HR
// indicating there were no more items then we return DMUS_E_INVALID_SEGMENTTRIGGERTRACK
// because the stream didn't contain the data we expected.  If it has a
// failure hr, it was unable to read from the stream and we return its HR.
HRESULT LoadHrFailOK(const SmartRef::RiffIter &ri)
{
	HRESULT hr = ri.hr();
	return SUCCEEDED(hr) ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
};

HRESULT
CSegTriggerTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGTRACK_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: List 'segt' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
	}

	SmartRef::RiffIter riTrackForm = ri.Descend();
	if (!riTrackForm)
		return riTrackForm.hr();

	for ( ; riTrackForm; ++riTrackForm)
	{
		if (riTrackForm.type() == SmartRef::RiffIter::Chunk)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGTRACK_CHUNK)
			{
				DMUS_IO_SEGMENT_TRACK_HEADER ioItem;
				hr = SmartRef::RiffIterReadChunk(riTrackForm, &ioItem);
				if (FAILED(hr))
					return hr;

				m_dwFlags = ioItem.dwFlags;
			}
		}
		else if (riTrackForm.type() == SmartRef::RiffIter::List)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGMENTS_LIST)
			{
				SmartRef::RiffIter riSegList = riTrackForm.Descend();
				while (riSegList && riSegList.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGMENT_LIST))
				{
					hr = LoadTrigger(riSegList.Descend(), pIDMLoader);
					if (FAILED(hr))
						return hr;
					++riSegList;
				}
				hr = riSegList.hr();
				if (FAILED(hr))
					return hr;
			}
		}
	}
	return riTrackForm.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CSegTriggerTrack::PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime)
{
	IDirectMusicPerformance8 *pPerf8 = NULL;
	HRESULT hr = pPerf->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void**>(&pPerf8));
	if (FAILED(hr))
		return hr;

	hr = pPerf8->PlaySegmentEx(
					item.pIDMSegment,
					NULL,														// not a song
					NULL,														// no transition
					item.dwPlayFlags | (fClockTime ? DMUS_SEGF_REFTIME : 0),	// flags
					fClockTime
						? item.lTimePhysical * REF_PER_MIL + rtOffset
						: item.lTimePhysical + mtOffset,						// time
					NULL,														// ignore returned segment state
					NULL,														// no replacement
					state.pAudioPath											// audio path to use (may be NULL indicating defualt)
					);
	pPerf8->Release();
    if (FAILED(hr))
    {
        Trace(0,"Segment Trigger Track failed segment playback\n");
        hr = S_OK; // Avoid an assert.
    }
	return hr;
}

HRESULT
CSegTriggerTrack::LoadTrigger(
		SmartRef::RiffIter ri,
		IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri)
		return ri.hr();

	// Create an event
	TListItem<TriggerInfo> *pItem = new TListItem<TriggerInfo>;
	if (!pItem)
		return E_OUTOFMEMORY;
	TriggerInfo &rinfo = pItem->GetItemValue();

	// find the item header (we can't interpret the other chunks until we've found it)
	if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SEGMENTITEM_CHUNK))
    {
        delete pItem;
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: Chunk 'sgih' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
    }

	// read the header
	DMUS_IO_SEGMENT_ITEM_HEADER ioItem;
	hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
	if (FAILED(hr))
    {
        delete pItem;
		return hr;
    }
	rinfo.lTriggerTime = ioItem.lTimeLogical;
	rinfo.lTimePhysical = ioItem.lTimePhysical;
	rinfo.dwPlayFlags = ioItem.dwPlayFlags;
	rinfo.dwFlags = ioItem.dwFlags;
	++ri;
	if (!ri)
	{
		// If there's nothing more then this is an empty trigger we should ignore because the user hasn't specified
		// the style or segment to play from.
		delete pItem;
		return ri.hr();
	}

	if (!(rinfo.dwFlags & DMUS_SEGMENTTRACKF_MOTIF))
	{
		// find the referenced segment
		if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_REF_LIST))
		{
			// If there's no DMRF then we should ignore this trigger because the user hasn't specified a segment.
			delete pItem;
			return ri.hr();
        }

		hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicSegment, reinterpret_cast<void**>(&rinfo.pIDMSegment));
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }
	}
	else
	{
		// find the segment from the referenced style and motif name
		SmartRef::ComPtr<IDirectMusicStyle> scomStyle;
		SmartRef::Buffer<WCHAR> wbufMotifName;
		for ( ; ri; ++ri)
		{
			if (ri.type() == SmartRef::RiffIter::List)
			{
				if (ri.id() == DMUS_FOURCC_REF_LIST)
				{
					hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicStyle, reinterpret_cast<void**>(&scomStyle));
					if (FAILED(hr))
                    {
                        delete pItem;
						return hr;
                    }
				}
			}
			else if (ri.type() == SmartRef::RiffIter::Chunk)
			{
				if (ri.id() == DMUS_FOURCC_SEGMENTITEMNAME_CHUNK)
				{
					hr = ri.ReadText(&wbufMotifName);
					if (FAILED(hr))
                    {
                        delete pItem;
#ifdef DBG
						if (hr == E_FAIL)
						{
							Trace(1, "Error: Unable to load segment trigger track: Problem reading 'snam' chunk.\n");
						}
#endif
						return hr == E_FAIL ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
                    }
				}
			}
		}
		hr = ri.hr();
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }

		if (!(scomStyle && wbufMotifName))
		{
			// This happens if the track didn't contain a DMRF list or snam chunk.	We allow
			// this as a means of representing an empty trigger track item or where the
			// motif to play hasn't been specified.  When loading we'll simply ignore
			// this item and continue reading the track.
			delete pItem;
			return S_OK;
		}

		hr = scomStyle->GetMotif(wbufMotifName, &rinfo.pIDMSegment);
		if (hr == S_FALSE)
		{
			Trace(1, "Error: The segment trigger track couldn't load because the motif %S was not found in the style.\n", wbufMotifName);
			hr = DMUS_E_NOT_FOUND;
		}
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }
	}

	m_EventList.AddHead(pItem);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\pchmap.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */
#include "PChMap.h"
#include "dmusicf.h"

CPChMap::CPChMap()
{
}

CPChMap::~CPChMap()
{
}

// Reset sets all item's mtNext time values to -1, so they are gotten again.
void CPChMap::Reset(void)
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rItem = pItem->GetItemValue();
		rItem.mtNext = -1;
		rItem.dwPChMap = rItem.dwPChannel;
        rItem.fMute = 0;
	}
}

// GetInfo calls the performance's GetData to get the current Mute Track information.
// Reset() will be called upon any invalidation or seek, which will set the
// internal times to -1 so this will be accurate in case of a new controlling segment.
// You must provide the pfMute and pdwNewPCh parameters to this function, or
// it will crash.
void CPChMap::GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
					   IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh, BOOL fClockTime )
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rCheck = pItem->GetItemValue();
		if( rCheck.dwPChannel == dwPCh ) break;
	}
	if( NULL == pItem )
	{
		PCHMAP_ITEM item;
		item.mtNext = -1;
		item.dwPChannel = item.dwPChMap = dwPCh;
		item.fMute = FALSE;
		pItem = new TListItem<PCHMAP_ITEM>(item);
		if( NULL == pItem )
		{
			// error, out of memory.
			*pfMute = FALSE;
			*pdwNewPCh = dwPCh;
			return;
		}
		m_PChMapList.AddHead(pItem);
	}
	PCHMAP_ITEM& rItem = pItem->GetItemValue();
	if( mtTime >= rItem.mtNext )
	{
		DMUS_MUTE_PARAM muteParam;
		MUSIC_TIME mtNext;
		muteParam.dwPChannel = dwPCh;
        if (fClockTime)
        {
            MUSIC_TIME mtMusic;
            REFERENCE_TIME rtTime = (mtTime + mtOffset) * 10000;
            pPerf->ReferenceToMusicTime(rtTime,&mtMusic);
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtMusic, 
			    &mtNext, (void*)&muteParam )))
		    {
                REFERENCE_TIME rtNext;
                // Convert to absolute reference time.
                pPerf->MusicToReferenceTime(mtNext + mtMusic,&rtNext);
                rtNext -= rtTime;   // Subtract out to get the delta.
			    rItem.mtNext = (MUSIC_TIME)(rtNext / 10000);  // Convert to delta in milliseconds. BUGBUG What if there's a tempo change?
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }

        }
        else
        {
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtTime + mtOffset, 
			    &mtNext, (void*)&muteParam )))
		    {
			    rItem.mtNext = mtNext;
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }
        }
	}
	*pfMute = rItem.fMute;
	*pdwNewPCh = rItem.dwPChMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\segtrtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

// This track type holds events that cause other segments to be cued at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct TriggerInfo
{
	TriggerInfo() : lTriggerTime(0), lTimePhysical(0), dwPlayFlags(0), dwFlags(0), pIDMSegment(NULL) {}
	~TriggerInfo() {
		RELEASE(pIDMSegment);
	}

	HRESULT Clone(const TriggerInfo &o, MUSIC_TIME mtStart)
	{
		lTriggerTime = o.lTriggerTime - mtStart;
		lTimePhysical = o.lTimePhysical - mtStart;
		dwPlayFlags = o.dwPlayFlags;
		dwFlags = o.dwFlags;
		pIDMSegment = o.pIDMSegment;
		pIDMSegment->AddRef();
		return S_OK;
	}

	// from event header chunk <scrh>
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	DWORD dwPlayFlags;
	DWORD dwFlags;
	// from reference <DMRF>
	IDirectMusicSegment *pIDMSegment;
};

// State data.  This track needs to get the audio path that's currently playing so that it
// can use it when playing triggered segments.
struct CSegTriggerTrackState : public CStandardStateData<TriggerInfo>
{
	CSegTriggerTrackState() : pAudioPath(NULL) {};
	~CSegTriggerTrackState() { if (pAudioPath) pAudioPath->Release(); }
	IDirectMusicAudioPath *pAudioPath;
};

//////////////////////////////////////////////////////////////////////
// CSegTriggerTrack

class CSegTriggerTrack;
typedef CPlayingTrack<CSegTriggerTrack, TriggerInfo, CSegTriggerTrackState> CSegTriggerTrackBase;

class CSegTriggerTrack
  : public CSegTriggerTrackBase
{
public:
	// When the segment trigger track plays one of its items, it plays a segment.  If an invalidation occurs, that Play operation
	// can't be retracted.  Then the track is played again (with the FLUSH bit set).  This was causing it to trigger the segment
	// a second time.  To fix this, the last parameter to the CSegTriggerTrackBase is false, which instructs it not to call play
	// a second time when the FLUSH bit is set.
	CSegTriggerTrack(HRESULT *pHr) : CSegTriggerTrackBase(&g_cComponent, CLSID_DirectMusicSegmentTriggerTrack, true, false), m_dwFlags(NULL), m_dwRecursionCount(0) {}

	// Implement SetParam by calling SetParam in turn on all the child segments.  This is needed, for example so that downloading a segment with a segment trigger track will download all the triggered segments as well.
	STDMETHOD(IsParamSupported)(REFGUID rguid) { return S_OK; } // Once or more of our child segments could potentially support any type of parameter.
	STDMETHOD(SetParam)(REFGUID rguid, MUSIC_TIME mtTime, void *pData);

	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);

protected:
	HRESULT PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadTrigger(SmartRef::RiffIter ri, IDirectMusicLoader *pIDMLoader);

	// Data
	DWORD m_dwFlags; // from track header (sgth chunk)
    BOOL  m_dwRecursionCount; // Used to keep track of recursive calls to self.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\seqtrack.cpp ===
//
// seqtrack.cpp
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
#pragma warning(disable:4530)

// SeqTrack.cpp : Implementation of CSeqTrack
#include "dmime.h"
#include "dmperf.h"
#include "SeqTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT assert

// @doc EXTERNAL
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define MIDI_CC_BS_MSB  0x00
#define MIDI_CC_BS_LSB  0x20

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
void CSeqTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_pSeqPartCache = NULL;
    m_dwPChannelsUsed = 0;
    m_aPChannels = NULL;
    m_dwValidate = 0;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
    m_cRef = 1;
}

CSeqTrack::CSeqTrack()
{
    Construct();
}

CSeqTrack::CSeqTrack(
        const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    m_dwPChannelsUsed = rTrack.m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (m_aPChannels)
        {
            memcpy( m_aPChannels, rTrack.m_aPChannels, sizeof(DWORD) * m_dwPChannelsUsed );
        }
    }

    TListItem<SEQ_PART>* pPart = rTrack.m_SeqPartList.GetHead();
    for( ; pPart; pPart = pPart->GetNext() )
    {
        TListItem<SEQ_PART>* pNewPart = new TListItem<SEQ_PART>;
        if( pNewPart )
        {
            pNewPart->GetItemValue().dwPChannel = pPart->GetItemValue().dwPChannel;
            TListItem<DMUS_IO_SEQ_ITEM>* pScan = pPart->GetItemValue().seqList.GetHead();

            for(; pScan; pScan = pScan->GetNext())
            {
                DMUS_IO_SEQ_ITEM& rScan = pScan->GetItemValue();
                if( rScan.mtTime < mtStart )
                {
                    continue;
                }
                if (rScan.mtTime < mtEnd)
                {
                    TListItem<DMUS_IO_SEQ_ITEM>* pNew = new TListItem<DMUS_IO_SEQ_ITEM>;
                    if (pNew)
                    {
                        DMUS_IO_SEQ_ITEM& rNew = pNew->GetItemValue();
                        memcpy( &rNew, &rScan, sizeof(DMUS_IO_SEQ_ITEM) );
                        rNew.mtTime = rScan.mtTime - mtStart;
                        pNewPart->GetItemValue().seqList.AddHead(pNew); // AddTail can get expensive (n^2), so
                                                    // AddHead instead and Reverse later.
                    }
                }
                else break;
            }
            pNewPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier.

            TListItem<DMUS_IO_CURVE_ITEM>* pScanCurve = pPart->GetItemValue().curveList.GetHead();

            for(; pScanCurve; pScanCurve = pScanCurve->GetNext())
            {
                DMUS_IO_CURVE_ITEM& rScan = pScanCurve->GetItemValue();
                if( rScan.mtStart < mtStart )
                {
                    continue;
                }
                if (rScan.mtStart < mtEnd)
                {
                    TListItem<DMUS_IO_CURVE_ITEM>* pNew = new TListItem<DMUS_IO_CURVE_ITEM>;
                    if (pNew)
                    {
                        DMUS_IO_CURVE_ITEM& rNew = pNew->GetItemValue();
                        memcpy( &rNew, &rScan, sizeof(DMUS_IO_CURVE_ITEM) );
                        rNew.mtStart = rScan.mtStart - mtStart;
                        pNewPart->GetItemValue().curveList.AddHead(pNew); // AddTail can get expensive (n^2), so
                                                    // AddHead instead and Reverse later.
                    }
                }
                else break;
            }
            pNewPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier.
            m_SeqPartList.AddHead(pNewPart);
        }
        m_SeqPartList.Reverse();
    }
}

CSeqTrack::~CSeqTrack()
{
    if (m_fCSInitialized)
    {
        DeleteSeqPartList();                // This will be empty if critical section
                                            // never got initialized.
        DeleteCriticalSection(&m_CrSec);
    }

    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CSeqTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSeqTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
    if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sequence Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSeqTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CSeqTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicSeqTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSeqTrack::IsDirty()
{
    return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | LoadSeq |
  Call this with an IStream filled with SeqEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SeqEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SeqEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SeqTrack is released.
*/
HRESULT CSeqTrack::LoadSeq( IStream* pIStream, long lSize )
{
    HRESULT hr = S_OK;
    TListItem<SEQ_PART>* pPart;

    EnterCriticalSection(&m_CrSec);

    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_SEQ_ITEM seqEvent;
    DWORD dwSubSize;
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_SEQ_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_SEQ_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        if( dwSubSize == 0 )
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( 0 == dwRead )
    {
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize > 0 )
    {
        if( FAILED( pIStream->Read( &seqEvent, dwRead, NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        lSize -= dwRead;
        if( dwSeek )
        {
            if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
            {
                hr = DMUS_E_CANNOTSEEK;
                goto END;
            }
            lSize -= dwSeek;
        }
        pPart = FindPart(seqEvent.dwPChannel);
        if( pPart )
        {
            TListItem<DMUS_IO_SEQ_ITEM>* pEvent = new TListItem<DMUS_IO_SEQ_ITEM>(seqEvent);
            if( pEvent )
            {
                pPart->GetItemValue().seqList.AddHead(pEvent); // AddTail can get
                                                            // expensive (n pow 2) so
                                                            // AddHead instead and reverse later.
            }
        }
    }
END:
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        pPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier
    }
    m_dwValidate++; // used to validate state data that's out there
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
  method HRESULT | LoadCurve
  Call this with an IStream filled with CurveEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of CurveEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only CurveEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
There are also other error codes.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the CurveTrack is released.
*/
HRESULT CSeqTrack::LoadCurve( IStream* pIStream, long lSize )
{
    HRESULT hr = S_OK;
    TListItem<SEQ_PART>* pPart;

    EnterCriticalSection(&m_CrSec);

    DWORD dwSubSize;
    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_CURVE_ITEM curveEvent;
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_CURVE_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_CURVE_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        if( dwSubSize == 0 )
        {
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( 0 == dwRead )
    {
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize > 0 )
    {
        curveEvent.wMergeIndex = 0; // Older format doesn't support this.
        if( FAILED( pIStream->Read( &curveEvent, dwRead, NULL )))
        {
            hr = DMUS_E_CANNOTREAD;
            break;
        }
        lSize -= dwRead;
        if( dwSeek )
        {
            pIStream->Seek( li, STREAM_SEEK_CUR, NULL );
            lSize -= dwSeek;
        }
        pPart = FindPart(curveEvent.dwPChannel);
        if( pPart )
        {
            TListItem<DMUS_IO_CURVE_ITEM>* pEvent = new TListItem<DMUS_IO_CURVE_ITEM>(curveEvent);
            if( pEvent )
            {
                pPart->GetItemValue().curveList.AddHead(pEvent); // AddTail can get
                                                            // expensive (n pow 2) so
                                                            // AddHead instead and reverse later.
            }
        }
    }
END:
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        pPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier
    }
    m_dwValidate++; // used to validate state data that's out there
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CSeqTrack::Load( IStream* pIStream )
{
    V_INAME(CSeqTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    DeleteSeqPartList();
    LeaveCriticalSection(&m_CrSec);

    // read in the chunk id
    long lSize;
    DWORD dwChunk;
    if( FAILED( pIStream->Read( &dwChunk, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    if( dwChunk != DMUS_FOURCC_SEQ_TRACK )
    {
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
        goto END;
    }
    // read in the overall size
    if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))
    {
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize )
    {
        DWORD dwSubChunk, dwSubSize;
        if( FAILED( pIStream->Read( &dwSubChunk, sizeof(DWORD), NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        lSize -= sizeof(DWORD);
        // read in the overall size
        if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        if( (dwSubSize == 0) || (dwSubSize > (DWORD)lSize) )
        {
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        lSize -= sizeof(DWORD);
        switch( dwSubChunk )
        {
        case DMUS_FOURCC_SEQ_LIST:
            if( FAILED( hr = LoadSeq( pIStream, dwSubSize )))
            {
                goto END;
            }
            break;
        case DMUS_FOURCC_CURVE_LIST:
            if( FAILED( hr = LoadCurve( pIStream, dwSubSize )))
            {
                goto END;
            }
            break;
        default:
            LARGE_INTEGER li;
            li.HighPart = 0;
            li.LowPart = dwSubSize;
            if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
            {
                hr = DMUS_E_CANNOTREAD;
                goto END;
            }
            break;
        }
        lSize -= dwSubSize;
    }
END:
    return hr;
}

HRESULT CSeqTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSeqTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::IsParamSupported(
    REFGUID rguidType)    // @parm The guid identifying the type of data to check.
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CSeqTrack::Init(
    IDirectMusicSegment *pSegment)    // @parm Pointer to the Segment to which this Track belongs.
{
    if( m_dwPChannelsUsed && m_aPChannels )
    {
        pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
    }
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CSeqTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,    // @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf,    // @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,        // @parm This method can return state data information here.
    DWORD dwTrackID,        // @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerf);

    SeqStateData* pStateData;
    pStateData = new SeqStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *ppStateData = pStateData;
    SetUpStateCurrentPointers(pStateData);
    // need to know the group this track is in, for the mute track GetParam
    IDirectMusicSegment* pSegment;
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
        pSegment->Release();
    }
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CSeqTrack::EndPlay(
    void *pStateData)    // @parm The state data returned from <om .InitPlay>.
{
    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(SeqStateData));
        SeqStateData* pSD = (SeqStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

void CSeqTrack::SetUpStateCurrentPointers(SeqStateData* pStateData)
{
    ASSERT(pStateData);
    pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        if( pStateData->apCurrentSeq )
        {
            delete [] pStateData->apCurrentSeq;
            pStateData->apCurrentSeq = NULL;
        }
        if( pStateData->apCurrentCurve )
        {
            delete [] pStateData->apCurrentCurve;
            pStateData->apCurrentCurve = NULL;
        }
        pStateData->apCurrentSeq = new TListItem<DMUS_IO_SEQ_ITEM>* [m_dwPChannelsUsed];
        pStateData->apCurrentCurve = new TListItem<DMUS_IO_CURVE_ITEM>* [m_dwPChannelsUsed];
        if( pStateData->apCurrentSeq )
        {
            memset( pStateData->apCurrentSeq, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * m_dwPChannelsUsed );
        }
        if( pStateData->apCurrentCurve )
        {
            memset( pStateData->apCurrentCurve, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * m_dwPChannelsUsed );
        }
    }
    pStateData->dwValidate = m_dwValidate;
}

// DeleteSeqPartList() - delete all parts in m_SeqPartList, and associated events.
void CSeqTrack::DeleteSeqPartList(void)
{
    EnterCriticalSection(&m_CrSec);
    m_dwPChannelsUsed = 0;
    if (m_aPChannels) delete [] m_aPChannels;
    m_aPChannels = NULL;
    m_pSeqPartCache = NULL;
    if( m_SeqPartList.GetHead() )
    {
        TListItem<SEQ_PART>* pItem;
        while( pItem = m_SeqPartList.RemoveHead() )
        {
            TListItem<DMUS_IO_SEQ_ITEM>* pEvent;
            while( pEvent = pItem->GetItemValue().seqList.RemoveHead() )
            {
                delete pEvent;
            }
            TListItem<DMUS_IO_CURVE_ITEM>* pCurve;
            while( pCurve = pItem->GetItemValue().curveList.RemoveHead() )
            {
                delete pCurve;
            }
            delete pItem;
        }
    }
    LeaveCriticalSection(&m_CrSec);
}

// FindPart() - return the SEQ_PART corresponding to dwPChannel, or create one.
TListItem<SEQ_PART>* CSeqTrack::FindPart( DWORD dwPChannel )
{
    TListItem<SEQ_PART>* pPart;

    if( m_pSeqPartCache && (m_pSeqPartCache->GetItemValue().dwPChannel == dwPChannel) )
    {
        return m_pSeqPartCache;
    }
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        if( pPart->GetItemValue().dwPChannel == dwPChannel )
        {
            break;
        }
    }
    if( NULL == pPart )
    {
        pPart = new TListItem<SEQ_PART>;
        if( pPart )
        {
            pPart->GetItemValue().dwPChannel = dwPChannel;
            m_SeqPartList.AddHead( pPart );
        }
        m_dwPChannelsUsed++;

        DWORD* aPChannels = new DWORD[m_dwPChannelsUsed];
        if( aPChannels )
        {
            if( m_aPChannels )
            {
                memcpy( aPChannels, m_aPChannels, sizeof(DWORD) * (m_dwPChannelsUsed - 1) );
            }
            aPChannels[m_dwPChannelsUsed - 1] = dwPChannel;
        }
        if( m_aPChannels )
        {
            delete [] m_aPChannels;
        }
        m_aPChannels = aPChannels;
    }
    m_pSeqPartCache = pPart;
    return pPart;
}

void CSeqTrack::UpdateTimeSig(IDirectMusicSegmentState* pSegSt,
                                         SeqStateData* pSD,
                                         MUSIC_TIME mt)
{
    // get a new time sig if needed
    if( (mt >= pSD->mtNextTimeSig) || (mt < pSD->mtCurTimeSig) )
    {
        IDirectMusicSegment* pSeg;
        DMUS_TIMESIGNATURE timesig;
        MUSIC_TIME mtNext;
        HRESULT hr;
        if(SUCCEEDED(hr = pSegSt->GetSegment(&pSeg)))
        {
            DWORD dwGroup;
            if( SUCCEEDED(hr = pSeg->GetTrackGroup( this, &dwGroup )))
            {
                if(SUCCEEDED(hr = pSeg->GetParam( GUID_TimeSignature, dwGroup,
                    0, mt, &mtNext, (void*)&timesig )))
                {
                    timesig.mtTime += mt;
                    if( pSD->dwlnMeasure )
                    {
                        pSD->dwMeasure = (timesig.mtTime - pSD->mtCurTimeSig) / pSD->dwlnMeasure;
                    }
                    else
                    {
                        pSD->dwMeasure = 0;
                    }
                    pSD->mtCurTimeSig = timesig.mtTime;
                    if( mtNext == 0 ) mtNext = 0x7fffffff;
                    pSD->mtNextTimeSig = mtNext;
                    if( timesig.bBeat )
                    {
                        pSD->dwlnBeat = DMUS_PPQ * 4 / timesig.bBeat;
                    }
                    pSD->dwlnMeasure = pSD->dwlnBeat * timesig.bBeatsPerMeasure;
                    if( timesig.wGridsPerBeat )
                    {
                        pSD->dwlnGrid = pSD->dwlnBeat / timesig.wGridsPerBeat;
                    }
                }
            }
            pSeg->Release();
        }
        if( FAILED(hr) )
        {
            // couldn't get time sig, default to 4/4
            pSD->mtNextTimeSig = 0x7fffffff;
            pSD->dwlnBeat = DMUS_PPQ;
            pSD->dwlnMeasure = DMUS_PPQ * 4;
            pSD->dwlnGrid = DMUS_PPQ / 4;
            pSD->dwMeasure = 0;
            pSD->mtCurTimeSig = 0;
        }
    }
    // make absolutely sure there is no way these can be 0, since we divide
    // by them.
    if( 0 == pSD->dwlnGrid ) pSD->dwlnGrid = DMUS_PPQ / 4;
    if( 0 == pSD->dwlnBeat ) pSD->dwlnBeat = DMUS_PPQ;
    if( 0 == pSD->dwlnMeasure ) pSD->dwlnMeasure = DMUS_PPQ * 4;
}

STDMETHODIMP CSeqTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CSeqTrack::Play(
    void *pStateData,    // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart,    // @parm The start time to play.
    MUSIC_TIME mtEnd,    // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,        // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf,    // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,    // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID    // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT    hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode.
*/

HRESULT CSeqTrack::Play(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT    hr = S_OK;
    IDirectMusicGraph* pGraph = NULL;
    DMUS_PMSG* pEvent = NULL;
    SeqStateData* pSD = (SeqStateData*)pStateData;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        m_PChMap.Reset();
    }

    if( pSD->dwValidate != m_dwValidate )
    {
        SetUpStateCurrentPointers(pSD);
        fSeek = TRUE;
    }

    if( fSeek )
    {
        if( dwFlags & DMUS_TRACKF_START )
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, TRUE, mtOffset, rtOffset, fClockTime );
        }
        else
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, FALSE, mtOffset, rtOffset, fClockTime );
        }
    }

    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    DWORD dwIndex;
    DWORD dwPChannel;
    DWORD dwMutePChannel;
    BOOL fMute;
    TListItem<SEQ_PART>* pPart = m_SeqPartList.GetHead();
    for( dwIndex = 0; pPart && (dwIndex < m_dwPChannelsUsed); dwIndex++,pPart = pPart->GetNext() )
    {
        dwPChannel = pPart->GetItemValue().dwPChannel;
        if( pSD->apCurrentCurve )
        {
            for( ; pSD->apCurrentCurve[dwIndex];
                pSD->apCurrentCurve[dwIndex] = pSD->apCurrentCurve[dwIndex]->GetNext() )
            {
                DMUS_IO_CURVE_ITEM& rItem = pSD->apCurrentCurve[dwIndex]->GetItemValue();
                if( rItem.mtStart >= mtEnd )
                {
                    break;
                }
                m_PChMap.GetInfo( dwPChannel, rItem.mtStart, mtOffset, pSD->dwGroupBits,
                    pPerf, &fMute, &dwMutePChannel, fClockTime );
                if( !fMute )
                {
                    DMUS_CURVE_PMSG* pCurve;
                    if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                        (DMUS_PMSG**)&pCurve )))
                    {
                        pEvent = (DMUS_PMSG*)pCurve;
                        if (fClockTime)
                        {
                            pCurve->wMeasure = 0;
                            pCurve->bBeat = 0;
                            pCurve->bGrid = 0;
                            pCurve->nOffset = rItem.nOffset;
                            pCurve->rtTime = ((rItem.mtStart + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
                        }
                        else
                        {
                            UpdateTimeSig( pSegSt, pSD, rItem.mtStart);
                            long lTemp = (rItem.mtStart - pSD->mtCurTimeSig);
                            pCurve->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                            lTemp = lTemp % pSD->dwlnMeasure;
                            pCurve->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                            lTemp = lTemp % pSD->dwlnBeat;
                            pCurve->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                            //pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid);
                            pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
                            pCurve->mtTime = rItem.mtStart + mtOffset + rItem.nOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                            pCurve->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8;
                        }
                        pCurve->dwPChannel = dwMutePChannel;
                        pCurve->dwVirtualTrackID = dwVirtualID;
                        pCurve->dwType = DMUS_PMSGT_CURVE;
                        pCurve->mtDuration = rItem.mtDuration;
                        pCurve->mtResetDuration = rItem.mtResetDuration;
                        pCurve->nStartValue = rItem.nStartValue;
                        pCurve->nEndValue = rItem.nEndValue;
                        pCurve->nResetValue = rItem.nResetValue;
                        pCurve->bType = rItem.bType;
                        pCurve->bCurveShape = rItem.bCurveShape;
                        pCurve->bCCData = rItem.bCCData;
                        pCurve->bFlags = rItem.bFlags;
                        pCurve->wParamType = rItem.wParamType;
                        pCurve->wMergeIndex = rItem.wMergeIndex;
                        pCurve->dwGroupID = pSD->dwGroupBits;

                        if( pGraph )
                        {
                            pGraph->StampPMsg( pEvent );
                        }
                        if(FAILED(pPerf->SendPMsg( pEvent )))
                        {
                            pPerf->FreePMsg(pEvent);
                        }
                    }
                }
            }
        }
        if( pSD->apCurrentSeq )
        {
            for( ; pSD->apCurrentSeq[dwIndex];
                pSD->apCurrentSeq[dwIndex] = pSD->apCurrentSeq[dwIndex]->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rItem = pSD->apCurrentSeq[dwIndex]->GetItemValue();
                if( rItem.mtTime >= mtEnd )
                {
                    break;
                }
                m_PChMap.GetInfo( dwPChannel, rItem.mtTime, mtOffset, pSD->dwGroupBits,
                                  pPerf, &fMute, &dwMutePChannel, fClockTime );
                if( !fMute )
                {
                    if( (rItem.bStatus & 0xf0) == 0x90 )
                    {
                        // this is a note event
                        DMUS_NOTE_PMSG* pNote;
                        if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_NOTE_PMSG),
                            (DMUS_PMSG**)&pNote )))
                        {
                            pNote->bFlags = DMUS_NOTEF_NOTEON;
                            pNote->mtDuration = rItem.mtDuration;
                            pNote->bMidiValue = rItem.bByte1;
                            pNote->bVelocity = rItem.bByte2;
                            pNote->dwType = DMUS_PMSGT_NOTE;
                            pNote->bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                            pNote->wMusicValue = pNote->bMidiValue;
                            pNote->bSubChordLevel = 0;  // SUBCHORD_BASS
                            if (fClockTime)
                            {
                                pNote->rtTime = ((rItem.mtTime + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                                pNote->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                pNote->wMeasure = 0;
                                pNote->bBeat = 0;
                                pNote->bGrid = 0;
                                pNote->nOffset = rItem.nOffset;
                            }
                            else
                            {
                                pNote->mtTime = rItem.mtTime + mtOffset + rItem.nOffset;
                                UpdateTimeSig( pSegSt, pSD, rItem.mtTime );
                                pNote->dwFlags = DMUS_PMSGF_MUSICTIME;
                                long lTemp = (rItem.mtTime - pSD->mtCurTimeSig);
                                pNote->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                                lTemp = lTemp % pSD->dwlnMeasure;
                                pNote->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                                lTemp = lTemp % pSD->dwlnBeat;
                                pNote->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                                //pNote->nOffset = (short)(lTemp % pSD->dwlnGrid);
                                pNote->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
                            }
                            pNote->bTimeRange = 0;
                            pNote->bDurRange = 0;
                            pNote->bVelRange = 0;
                            pNote->cTranspose = 0;
                            pEvent = (DMUS_PMSG*)pNote;
                        }
                    }
                    else
                    {
                        // it's a MIDI short that's not a note
                        DMUS_MIDI_PMSG* pMidi;
                        if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
                            (DMUS_PMSG**)&pMidi )))
                        {
                            pMidi->bStatus = rItem.bStatus & 0xf0;
                            pMidi->bByte1 = rItem.bByte1;
                            pMidi->bByte2 = rItem.bByte2;
                            pMidi->dwType = DMUS_PMSGT_MIDI;
                            if (fClockTime)
                            {
                                pMidi->rtTime = (rItem.mtTime * REF_PER_MIL) + rtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                            }
                            else
                            {
                                pMidi->mtTime = rItem.mtTime + mtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                            }
                            pEvent = (DMUS_PMSG*)pMidi;
                        }
                    }
                    if( pEvent )
                    {
                        pEvent->dwPChannel = dwMutePChannel;
                        pEvent->dwVirtualTrackID = dwVirtualID;
                        pEvent->dwGroupID = pSD->dwGroupBits;
                        if( pGraph )
                        {
                            pGraph->StampPMsg( pEvent );
                        }
                        if(FAILED(pPerf->SendPMsg( pEvent )))
                        {
                            pPerf->FreePMsg(pEvent);
                        }
                    }
                }
            }
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// SendSeekItem() - sends either the pSeq or pCurve, depending on which occurs
// latest. Sends the item at mtTime + mtOffset.
void CSeqTrack::SendSeekItem( IDirectMusicPerformance* pPerf,
                                        IDirectMusicGraph* pGraph,
                                        IDirectMusicSegmentState* pSegSt,
                                        SeqStateData* pSD,
                                        DWORD dwVirtualID,
                                        MUSIC_TIME mtTime,
                                        MUSIC_TIME mtOffset,
                                        REFERENCE_TIME rtOffset,
                                        TListItem<DMUS_IO_SEQ_ITEM>* pSeq,
                                        TListItem<DMUS_IO_CURVE_ITEM>* pCurve,
                                        BOOL fClockTime)
{
    DWORD dwMutePChannel;
    BOOL fMute;

    if( pSeq )
    {
        DMUS_IO_SEQ_ITEM& rSeq = pSeq->GetItemValue();
        if( pCurve )
        {
            DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
            if( rSeq.mtTime >= rCurve.mtStart + rCurve.mtDuration )
            {
                // the seq item happens after the curve item. Send the
                // seq item and clear the curve item so it doesn't go out.
                pCurve = NULL;
            }
        }
        // if pCurve is NULL or was set to NULL, send out the seq item
        if( NULL == pCurve )
        {
            m_PChMap.GetInfo( rSeq.dwPChannel, rSeq.mtTime, mtOffset, pSD->dwGroupBits,
                pPerf, &fMute, &dwMutePChannel, fClockTime );
            if( !fMute )
            {
                DMUS_MIDI_PMSG* pMidi;
                if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
                    (DMUS_PMSG**)&pMidi )))
                {
                    pMidi->bStatus = rSeq.bStatus & 0xf0;
                    pMidi->bByte1 = rSeq.bByte1;
                    pMidi->bByte2 = rSeq.bByte2;
                    pMidi->dwType = DMUS_PMSGT_MIDI;

                    ASSERT( mtTime > rSeq.mtTime ); // this is true for back-seeking
                    if (fClockTime)
                    {
                        pMidi->rtTime = (mtTime * REF_PER_MIL) + rtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pMidi->mtTime = mtTime + mtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                    }
                    pMidi->dwPChannel = dwMutePChannel;
                    pMidi->dwVirtualTrackID = dwVirtualID;
                    pMidi->dwGroupID = pSD->dwGroupBits;
                    if( pGraph )
                    {
                        pGraph->StampPMsg( (DMUS_PMSG*)pMidi );
                    }
                    if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pMidi )))
                    {
                        pPerf->FreePMsg((DMUS_PMSG*)pMidi);
                    }
                }
            }
        }
    }

    if( pCurve )
    {
        DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
        m_PChMap.GetInfo( rCurve.dwPChannel, rCurve.mtStart, mtOffset, pSD->dwGroupBits,
            pPerf, &fMute, &dwMutePChannel, fClockTime );
        if( !fMute )
        {
            DMUS_CURVE_PMSG* pCurvePmsg;
            if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                (DMUS_PMSG**)&pCurvePmsg )))
            {
                if (fClockTime) // If clock time, don't fill in time signature info, it's useless.
                {
                    pCurvePmsg->wMeasure = 0;
                    pCurvePmsg->bBeat = 0;
                    pCurvePmsg->bGrid = 0;
                    pCurvePmsg->nOffset = 0;
                    pCurvePmsg->rtTime = ((mtTime + rCurve.nOffset) * REF_PER_MIL) + rtOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    UpdateTimeSig( pSegSt, pSD, rCurve.mtStart);
                    long lTemp = (rCurve.mtStart - pSD->mtCurTimeSig);
                    pCurvePmsg->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                    lTemp = lTemp % pSD->dwlnMeasure;
                    pCurvePmsg->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                    lTemp = lTemp % pSD->dwlnBeat;
                    pCurvePmsg->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                    pCurvePmsg->nOffset = (short)(lTemp % pSD->dwlnGrid) + rCurve.nOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_MUSICTIME;
                    ASSERT( mtTime > rCurve.mtStart );// this is true for back-seeking
                    // in any case, play curve at mtTime + mtOffset + pCurvePmsg->nOffset
                    pCurvePmsg->mtTime = mtTime + mtOffset + rCurve.nOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_MUSICTIME;
                }

                pCurvePmsg->dwPChannel = dwMutePChannel;
                pCurvePmsg->dwVirtualTrackID = dwVirtualID;
                pCurvePmsg->dwType = DMUS_PMSGT_CURVE;
                pCurvePmsg->bType = rCurve.bType;
                pCurvePmsg->bCCData = rCurve.bCCData;
                pCurvePmsg->bFlags = rCurve.bFlags;
                pCurvePmsg->dwGroupID = pSD->dwGroupBits;
                pCurvePmsg->nStartValue = rCurve.nStartValue;
                pCurvePmsg->nEndValue = rCurve.nEndValue;
                pCurvePmsg->nResetValue = rCurve.nResetValue;

                if( mtTime >= rCurve.mtStart + rCurve.mtDuration )
                {
                    // playing at a time past the curve's duration. Just play
                    // an instant curve at that time instead. Instant curves
                    // play at their endvalue. Duration is irrelavant.
                    pCurvePmsg->bCurveShape = DMUS_CURVES_INSTANT;
                    if( pCurvePmsg->bFlags & DMUS_CURVE_RESET )
                    {
                        if( mtTime >= rCurve.mtStart + rCurve.mtDuration +
                            rCurve.mtResetDuration + rCurve.nOffset )
                        {
                            // don't need the curve reset any more
                            pCurvePmsg->bFlags &= ~DMUS_CURVE_RESET;
                        }
                        else
                        {
                            // otherwise make sure the reset event happens at the same time
                            // it would have if we weren't seeking back.
                            pCurvePmsg->mtResetDuration = rCurve.mtStart + rCurve.mtDuration +
                                rCurve.mtResetDuration + rCurve.nOffset - mtTime;
                        }
                    }
                }
                else
                {
                    // playing at a time in the middle of a curve.
                    pCurvePmsg->bCurveShape = rCurve.bCurveShape;
                    if (fClockTime)
                    {
                        pCurvePmsg->mtOriginalStart = mtTime - (rCurve.mtStart + mtOffset + rCurve.nOffset);
                    }
                    else
                    {
                        pCurvePmsg->mtOriginalStart = rCurve.mtStart + mtOffset + rCurve.nOffset;
                    }
                    if( pCurvePmsg->bCurveShape != DMUS_CURVES_INSTANT )
                    {
                        pCurvePmsg->mtDuration = rCurve.mtStart + rCurve.mtDuration - mtTime;
                    }
                    pCurvePmsg->mtResetDuration = rCurve.mtResetDuration;
                }

                if( pGraph )
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pCurvePmsg );
                }
                if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pCurve )))
                {
                    pPerf->FreePMsg((DMUS_PMSG*)pCurve);
                }
            }
        }
    }
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// also send control change, pitch bend, curves, etc. that are in the past so the
// state at mtTime is as if we played from the beginning of the track.
HRESULT CSeqTrack::Seek( IDirectMusicSegmentState* pSegSt,
    IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    SeqStateData* pSD, MUSIC_TIME mtTime, BOOL fGetPrevious,
    MUSIC_TIME mtOffset, REFERENCE_TIME rtOffset, BOOL fClockTime)
{
    DWORD dwIndex;
    TListItem<SEQ_PART>* pPart;
    TListItem<DMUS_IO_SEQ_ITEM>* pSeqItem;
    TListItem<DMUS_IO_CURVE_ITEM>* pCurveItem;

    // in the case of mtTime == 0 and fGetPrevious (which means DMUS_SEGF_START was
    // set in Play() ) we want to reset all lists to the beginning regardless of time.
    if( fGetPrevious && ( mtTime == 0 ) )
    {
        pPart = m_SeqPartList.GetHead();
        for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            if( pPart )
            {
                pSeqItem = pPart->GetItemValue().seqList.GetHead();
                if( pSeqItem && pSD->apCurrentSeq )
                {
                    pSD->apCurrentSeq[dwIndex] = pSeqItem;
                }
                pCurveItem = pPart->GetItemValue().curveList.GetHead();
                if( pCurveItem && pSD->apCurrentCurve )
                {
                    pSD->apCurrentCurve[dwIndex] = pCurveItem;
                }
                pPart = pPart->GetNext();
            }
            else
            {
                break;
            }
        }
        return S_OK;
    }

#define CC_1    96
    // CC_1 is the limit of the CC#'s we pay attention to. CC#96 through #101
    // are registered and non-registered parameter #'s, and data increment and
    // decrement, which we are choosing to ignore.

    TListItem<DMUS_IO_SEQ_ITEM>*    apSeqItemCC[ CC_1 ];
    TListItem<DMUS_IO_CURVE_ITEM>*    apCurveItemCC[ CC_1 ];
    TListItem<DMUS_IO_SEQ_ITEM>*    pSeqItemMonoAT;
    TListItem<DMUS_IO_CURVE_ITEM>*    pCurveItemMonoAT;
    TListItem<DMUS_IO_SEQ_ITEM>*    pSeqItemPBend;
    TListItem<DMUS_IO_CURVE_ITEM>*    pCurveItemPBend;
    IDirectMusicGraph* pGraph;
    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    pPart = m_SeqPartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        if( pPart )
        {
            memset(apSeqItemCC, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * CC_1);
            memset(apCurveItemCC, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * CC_1);
            pSeqItemMonoAT = NULL;
            pCurveItemMonoAT = NULL;
            pSeqItemPBend = NULL;
            pCurveItemPBend = NULL;

            // scan the seq event list in this part, storing any CC, MonoAT, and PBend
            // events we come across.
            for( pSeqItem = pPart->GetItemValue().seqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rSeqItem = pSeqItem->GetItemValue();
                if( rSeqItem.mtTime >= mtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
                switch( rSeqItem.bStatus & 0xf0 )
                {
                case MIDI_CCHANGE:
                    // ignore Registered and Non-registered Parameters,
                    // Data increment, Data decrement, and Data entry MSB and LSB.
                    if( ( rSeqItem.bByte1 < CC_1 ) && ( rSeqItem.bByte1 != 6 ) &&
                        ( rSeqItem.bByte1 != 38 ) )
                    {
                        apSeqItemCC[ rSeqItem.bByte1 ] = pSeqItem;
                    }
                    break;
                case MIDI_MTOUCH:
                    pSeqItemMonoAT = pSeqItem;
                    break;
                case MIDI_PBEND:
                    pSeqItemPBend = pSeqItem;
                    break;
                default:
                    break;
                }
            }
            if( pSD->apCurrentSeq )
            {
                pSD->apCurrentSeq[dwIndex] = pSeqItem;
            }
            // scan the curve event list in this part, storing any CC, MonoAT, and PBend
            // events we come across
            for( pCurveItem = pPart->GetItemValue().curveList.GetHead(); pCurveItem; pCurveItem = pCurveItem->GetNext() )
            {
                DMUS_IO_CURVE_ITEM& rCurveItem = pCurveItem->GetItemValue();
                if( rCurveItem.mtStart >= mtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
                switch( rCurveItem.bType )
                {
                case DMUS_CURVET_CCCURVE:
                    if( ( rCurveItem.bCCData < CC_1 ) && ( rCurveItem.bCCData != 6 ) &&
                        ( rCurveItem.bCCData != 38 ) )
                    {
                        if( apCurveItemCC[ rCurveItem.bCCData ] )
                        {
                            DMUS_IO_CURVE_ITEM& rTemp = apCurveItemCC[ rCurveItem.bCCData ]->GetItemValue();
                            if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                                rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                            {
                                apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
                            }
                        }
                        else
                        {
                            apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
                        }
                    }
                    break;
                case DMUS_CURVET_MATCURVE:
                    if( pCurveItemMonoAT )
                    {
                        DMUS_IO_CURVE_ITEM& rTemp = pCurveItemMonoAT->GetItemValue();
                        if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                            rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                        {
                            pCurveItemMonoAT = pCurveItem;
                        }
                    }
                    else
                    {
                        pCurveItemMonoAT = pCurveItem;
                    }
                    break;
                case DMUS_CURVET_PBCURVE:
                    if( pCurveItemPBend )
                    {
                        DMUS_IO_CURVE_ITEM& rTemp = pCurveItemPBend->GetItemValue();
                        if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                            rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                        {
                            pCurveItemPBend = pCurveItem;
                        }
                    }
                    else
                    {
                        pCurveItemPBend = pCurveItem;
                    }
                    break;
                default:
                    break;
                }
            }
            if( pSD->apCurrentCurve )
            {
                pSD->apCurrentCurve[dwIndex] = pCurveItem;
            }
            if( fGetPrevious )
            {
                DWORD dwCC;
                // create and send past events appropriately
                SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemPBend, pCurveItemPBend, fClockTime );
                SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemMonoAT, pCurveItemMonoAT, fClockTime );
                for( dwCC = 0; dwCC < CC_1; dwCC++ )
                {
                    SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, apSeqItemCC[dwCC], apCurveItemCC[dwCC], fClockTime );
                }
            }
            pPart = pPart->GetNext();
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::GetParam(
    REFGUID rguidType,    // @parm The type of data to obtain.
    MUSIC_TIME mtTime,    // @parm The time, in Track time, to obtain the data.
    MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
                        // may be NULL. If this returns a value of 0, it means that this
                        // data will either be always valid, or it is unknown when it will
                        // become invalid.
    void *pData)        // @parm The struture in which to return the data. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::SetParam(
    REFGUID rguidType,    // @parm The type of data to set.
    MUSIC_TIME mtTime,    // @parm The time, in Track time, to set the data.
    void *pData)        // @parm The struture containing the data to set. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::AddNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to add.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to remove.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::Clone(
    MUSIC_TIME mtStart,    // @parm The start of the part to clone. It should be 0 or greater,
                        // and less than the length of the Track.
    MUSIC_TIME mtEnd,    // @parm The end of the part to clone. It should be greater than
                        // <p mtStart> and less than the length of the Track.
    IDirectMusicTrack** ppTrack)    // @parm Returns the cloned Track.
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time is %ld.\n",mtStart);
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time %ld is greater than end %ld.\n",mtStart,mtEnd);
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);
    CSeqTrack *pDM;

    try
    {
        pDM = new CSeqTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    return hr;
}


STDMETHODIMP CSeqTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\seqtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SeqTrack.h : Declaration of the CSeqTrack

#ifndef __SEQTRACK_H_
#define __SEQTRACK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\tlist.h"
#include "PChMap.h"

struct SeqStateData
{
	DWORD						dwPChannelsUsed; // number of PChannels
	// the following two arrays are allocated to the size of dwNumPChannels, which
	// must match the SeqTrack's m_dwPChannelsUsed. The arrays match one-for-one with
	// the parts inside the SeqTrack.
	TListItem<DMUS_IO_SEQ_ITEM>**	apCurrentSeq; // array of size dwNumPChannels
	TListItem<DMUS_IO_CURVE_ITEM>**	apCurrentCurve; // array of size dwNumPChannels
	DWORD						dwValidate;
	MUSIC_TIME					mtCurTimeSig; // time the current timesig started
	MUSIC_TIME					mtNextTimeSig; // time for the next timesig
	DWORD						dwMeasure; // starting measure # of the timesig
	DWORD						dwlnBeat; // length of a beat
	DWORD						dwlnMeasure; // length of a measure
	DWORD						dwlnGrid; // length of a grid
	DWORD						dwGroupBits; // the group bits of this track

	SeqStateData()
	{
		mtCurTimeSig = 0;
		mtNextTimeSig = 0;
		dwMeasure = 0;
		dwlnBeat = DMUS_PPQ;
		dwlnMeasure = DMUS_PPQ * 4;
		dwlnGrid = DMUS_PPQ / 4;
		apCurrentSeq = NULL;
		apCurrentCurve = NULL;
	}
	~SeqStateData()
	{
		if( apCurrentSeq )
		{
			delete [] apCurrentSeq;
		}
		if( apCurrentCurve )
		{
			delete [] apCurrentCurve;
		}
	}
};

// SEQ_PART represents all of the DMUS_PMSG's inside the SeqTrack for one PChannel
struct SEQ_PART
{
	SEQ_PART*			pNext;
	DWORD				dwPChannel;
	TList<DMUS_IO_SEQ_ITEM>	seqList;
	TList<DMUS_IO_CURVE_ITEM>	curveList;

	SEQ_PART() : pNext(NULL) {}; // always initialize pNext to NULL
};

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
class CSeqTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSeqTrack();
	CSeqTrack(
		const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSeqTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT STDMETHODCALLTYPE Seek( 
		IDirectMusicSegmentState*,
		IDirectMusicPerformance*,
		DWORD dwVirtualID,
		SeqStateData*,
		MUSIC_TIME mtTime,
		BOOL fGetPrevious,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
	void SendSeekItem( 
		IDirectMusicPerformance*,
		IDirectMusicGraph*,
		IDirectMusicSegmentState*,
		SeqStateData* pSD,
		DWORD dwVirtualID,
		MUSIC_TIME mtTime,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
		TListItem<DMUS_IO_SEQ_ITEM>*,
		TListItem<DMUS_IO_CURVE_ITEM>*,
        BOOL fClockTime);
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	void Construct(void);
	HRESULT LoadCurve( IStream* pIStream, long lSize );
	HRESULT LoadSeq( IStream* pIStream, long lSize );
	void UpdateTimeSig(IDirectMusicSegmentState*, SeqStateData* pSD, MUSIC_TIME mt);
	TListItem<SEQ_PART>* FindPart( DWORD dwPChannel );
	void DeleteSeqPartList(void);
	void SetUpStateCurrentPointers(SeqStateData* pStateData);

// member variables
private:
	TList<SEQ_PART>			m_SeqPartList;
	TListItem<SEQ_PART>*	m_pSeqPartCache;	// used to time-optimize FindPart()
	DWORD					m_dwPChannelsUsed;
	DWORD*					m_aPChannels;
	long					m_cRef;
	DWORD					m_dwValidate; // used to validate state data
	CRITICAL_SECTION		m_CrSec;
    BOOL                    m_fCSInitialized;
	CPChMap					m_PChMap;
};

#endif //__SEQTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\sysextrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// SysExTrk.cpp : Implementation of CSysExTrk
#include "dmime.h"
#include "SysExTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmperf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert

/////////////////////////////////////////////////////////////////////////////
// CSysExTrack
void CSysExTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
	m_dwValidate = 0;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CSysExTrack::CSysExTrack()
{
	Construct();
}

CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
	SysExListItem* pScan = rTrack.m_SysExEventList.GetHead();

	for(; pScan; pScan = pScan->GetNext())
	{
		FullSysexEvent* pItem = pScan->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		else if( pItem->mtTime < mtStart )
		{
			continue;
		}
		else if (pItem->mtTime < mtEnd)
		{
			SysExListItem* pNew = new SysExListItem;
			if (pNew)
			{
				FullSysexEvent item;
				item.mtTime = pItem->mtTime - mtStart;
				item.dwSysExLength = pItem->dwSysExLength;
				if (item.dwSysExLength && (item.pbSysExData = new BYTE[item.dwSysExLength]))
                {
					memcpy( item.pbSysExData, pItem->pbSysExData, item.dwSysExLength );
					pNew->SetItem(item);
					m_SysExEventList.AddTail(pNew);
				}
                else
                {
                    delete pNew;
                }
			}
		}
		else break;
	}
}

CSysExTrack::~CSysExTrack()
{
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }

	InterlockedDecrement(&g_cComponent);
}

// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSysExTrack>
//
// parm const IID & | iid | Interface to query for
// parm void ** | ppv | The requested interface will be returned here
//
// rdesc Returns one of the following:
//
// flag S_OK | If the interface is supported and was returned
// flag E_NOINTERFACE | If the object does not support the given interface.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP CSysExTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CSysExTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sysex Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | Release | Standard Release implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSysExTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CSysExTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicSysExTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSysExTrack::IsDirty()
{
	return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | Load |
  Call this with an IStream filled with SysExEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SysExEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SysExEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SysExTrack is released.
*/
HRESULT CSysExTrack::Load( IStream* pIStream )
{
	V_INAME(CSysExTrack::Load);
	V_INTERFACE(pIStream);

	EnterCriticalSection(&m_CrSec);
	HRESULT hr = S_OK;

	m_dwValidate++;
	if( m_SysExEventList.GetHead() )
	{
		m_SysExEventList.DeleteAll();
	}

	// copy contents of the stream into the list.
	//DMUS_IO_SYSEX_ITEM sysexEvent;
	FullSysexEvent sysexEvent;
	// read in the chunk id
	DWORD dwChunk;
	long lSize;
	pIStream->Read( &dwChunk, sizeof(DWORD), NULL);
	if( dwChunk != DMUS_FOURCC_SYSEX_TRACK )
	{
        Trace(1,"Error: Invalid data in sysex track.\n");
        LeaveCriticalSection(&m_CrSec);
		return DMUS_E_CHUNKNOTFOUND;
	}
	// read in the overall size
	if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))
	{
        Trace(1,"Error: Unable to read sysex track.\n");
		LeaveCriticalSection(&m_CrSec);
		return DMUS_E_CANNOTREAD;
	}

	DMUS_IO_SYSEX_ITEM SysexItem;
	BYTE* pbSysExData;
	while( lSize > 0 )
	{
		if( FAILED( pIStream->Read( &SysexItem, sizeof(DMUS_IO_SYSEX_ITEM), NULL )))
		{
            Trace(1,"Error: Unable to read sysex track.\n");
			hr = DMUS_E_CANNOTREAD;
			break;
		}
		lSize -= sizeof(DMUS_IO_SYSEX_ITEM);
		pbSysExData = new BYTE[SysexItem.dwSysExLength];
		if( NULL == pbSysExData )
		{
			hr = E_OUTOFMEMORY;
			break;
		}
		if( FAILED( pIStream->Read( pbSysExData, SysexItem.dwSysExLength, NULL )))
		{
            Trace(1,"Error: Unable to read sysex track.\n");
			hr = DMUS_E_CANNOTREAD;
			break;
		}
		lSize -= SysexItem.dwSysExLength;
		sysexEvent.mtTime = SysexItem.mtTime;
		sysexEvent.dwPChannel = SysexItem.dwPChannel;
		sysexEvent.dwSysExLength = SysexItem.dwSysExLength;
		sysexEvent.pbSysExData = pbSysExData;
		SysExListItem* pNew = new SysExListItem;
		if (pNew)
		{
			if( FAILED( pNew->SetItem(sysexEvent)))
			{
				delete [] pbSysExData;
				hr = E_OUTOFMEMORY;
				break;
			}
			m_SysExEventList.AddTail(pNew);
		}
		else
		{
			delete [] pbSysExData;
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CSysExTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CSysExTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CSysExTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a Segment, it's Init() routine is called
by that Segment.

parm IDirectMusicSegment* | pSegment |
[in] Pointer to the Segment to which this Track belongs.

rvalue S_OK
*/
HRESULT CSysExTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CSysExTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SysExStateData* pStateData;
	pStateData = new SysExStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
	pStateData->dwVirtualTrackID = dwTrackID;
	pStateData->pPerformance = pPerformance; // weak reference, no addref.
	pStateData->pSegState = pSegmentState; // weak reference, no addref.
	pStateData->pCurrentSysEx = m_SysExEventList.GetHead();
	pStateData->dwValidate = m_dwValidate;
	return S_OK;
}

HRESULT CSysExTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(IDirectMusicTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(SysExStateData));
		SysExStateData* pSD = (SysExStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

/*

  method HRESULT | CSysExTrack | Play |
  Play method.
  rvalue S_FALSE | If there has been no stream loaded into the Track.
  rvalue S_OK
*/
HRESULT CSysExTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	EnterCriticalSection(&m_CrSec);
	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode. 
*/

HRESULT CSysExTrack::Play( 
    void *pStateData,	
    MUSIC_TIME mtStart,	
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
	DWORD dwFlags,		
	IDirectMusicPerformance* pPerf,	
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
	    return S_OK;
    }
	IDirectMusicGraph* pGraph = NULL;
	DMUS_SYSEX_PMSG* pSysEx;
	SysExStateData* pSD = (SysExStateData*)pStateData;
	HRESULT	hr = S_OK;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	// if pSD->pCurrentSysEx is NULL, and we're in a normal Play call (dwFlags is 0)
	// this means that we either have no events, or we got to the end of the event
	// list previously. So, it's safe to just return.
	if( (pSD->pCurrentSysEx == NULL) && (dwFlags == 0) )
	{
		return S_FALSE;
	}

	if( pSD->dwValidate != m_dwValidate )
	{
		pSD->dwValidate = m_dwValidate;
		pSD->pCurrentSysEx = NULL;
	}
	if( NULL == m_SysExEventList.GetHead() )
	{
		return DMUS_S_END;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->mtPrevEnd != mtStart ))
	{
		Seek( pStateData, mtStart );
	}
	else if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	pSD->mtPrevEnd = mtEnd;

	if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		if( pItem->mtTime >= mtEnd )
		{
			// this time is in the future. Return now to retain the same
			// seek pointers for next time.
			hr = S_OK;
			break;
		}
		if( (pItem->mtTime < mtStart) && !fSeek )
		{
			break;
		}
		// allocate a DMUS_SYSEX_PMSG of the approriate size and read 
		// the sysex data into it
		if( SUCCEEDED( hr = pSD->pPerformance->AllocPMsg( 
			sizeof(DMUS_SYSEX_PMSG) + pItem->dwSysExLength, (DMUS_PMSG**)&pSysEx ) ) )
		{
			memcpy( pSysEx->abData, pItem->pbSysExData, pItem->dwSysExLength );
            if (fClockTime)
            {
                pSysEx->rtTime = (pItem->mtTime  * REF_PER_MIL) + rtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

            }
            else
            {
			    pSysEx->mtTime = pItem->mtTime + mtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_MUSICTIME;
            }
			pSysEx->dwLen = pItem->dwSysExLength;
			pSysEx->dwPChannel = 0;
			pSysEx->dwVirtualTrackID = pSD->dwVirtualTrackID;
			pSysEx->dwType = DMUS_PMSGT_SYSEX;
			pSysEx->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pSysEx );
			}
			if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pSysEx )))
			{
				pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pSysEx );
			}
		}
        else
        {
            hr = DMUS_S_END;
            break;
        }
	}
	if( pGraph )
	{
		pGraph->Release();
	}
	return hr;
}

HRESULT CSysExTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime)
{
	SysExStateData* pSD = (SysExStateData*)pStateData;

	if( NULL == m_SysExEventList.GetHead() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
	if( pItem->mtTime >= mtTime )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		pItem = pSD->pCurrentSysEx->m_pItem;
		if( pItem->mtTime >= mtTime )
		{
			break;
		}
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if((mtStart < 0 ) || (mtStart > mtEnd))
	{
        Trace(1,"Error: Unable to clone sysex track, invalid start parameter.\n",mtStart);
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);

    CSysExTrack *pDM;
    
    try
    {
        pDM = new CSysExTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}


STDMETHODIMP CSysExTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\song.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSONGOBJECT_H_
#define __DIRECTMUSICSONGOBJECT_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"
#include "TrkList.h"
#include "dmgraph.h"
#include "dmsegobj.h"
#include "tlist.h"
#include "..\shared\dmusicp.h"

class CVirtualSegment : public AListItem
{
friend class CSong;
friend class ComposingTrack;
public:
    CVirtualSegment();
    ~CVirtualSegment();
    CVirtualSegment* GetNext() { return (CVirtualSegment*)AListItem::GetNext();}
    CTrack * GetTrackByParam( CTrack * pCTrack,
        REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
private:
    CTrackList              m_TrackList;        // List of tracks that this segment uses.
    CSegment *              m_pSourceSegment;   // Segment that is used as basis for this segment.
    CSegment *              m_pPlaySegment;     // Resulting segment that will be played.
    CGraph *                m_pGraph;           // Optional tool graph.
    DWORD                   m_dwFlags;          // Various control flags.
    DWORD                   m_dwID;             // Unique ID.
    DWORD                   m_dwNextPlayID;     // ID of next segment, to chain segments into a song.
    DWORD                   m_dwNextPlayFlags;  // DMUS_SEGF flags for playing next segment, when chaining a song.
    DMUS_IO_SEGMENT_HEADER  m_SegHeader;        // Segment header, used to define the segment that it creates, or change the one it references.
    MUSIC_TIME              m_mtTime;           // Start time of this segment.
    DWORD                   m_dwTransitionCount;// How many transitions are defined. 
    DMUS_IO_TRANSITION_DEF *m_pTransitions;     // Array of transitions from other segments.
	WCHAR	                m_wszName[DMUS_MAX_NAME];// Name of generated segment.
};

class CVirtualSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CVirtualSegment* pVirtualSegment) { AList::AddHead((AListItem*)pVirtualSegment);}
    void Insert(CVirtualSegment* pVirtualSegment);
    CVirtualSegment* GetHead(){return (CVirtualSegment*)AList::GetHead();}
    CVirtualSegment* GetItem(LONG lIndex){return (CVirtualSegment*)AList::GetItem(lIndex);}
    CVirtualSegment* RemoveHead()  { return (CVirtualSegment *)AList::RemoveHead();};
    void Remove(CVirtualSegment* pVirtualSegment){AList::Remove((AListItem*)pVirtualSegment);}
    void AddTail(CVirtualSegment* pVirtualSegment){AList::AddTail((AListItem*)pVirtualSegment);}
    CVirtualSegment* GetTail(){ return (CVirtualSegment*)AList::GetTail();}
};

class CSongSegment : public AListItem
{
public:
    CSongSegment();
    ~CSongSegment();
    CSongSegment* GetNext() { return (CSongSegment*)AListItem::GetNext();}
    CSegment *              m_pSegment;   
    DWORD                   m_dwLoadID;
};

class CSongSegmentList : public AList
{
public:
    HRESULT AddSegment(CSegment *pSegment, DWORD dwLoadID);
    void Clear();
    void AddHead(CSongSegment* pSongSegment) { AList::AddHead((AListItem*)pSongSegment);}
    void Insert(CSongSegment* pSongSegment);
    CSongSegment* GetHead(){return (CSongSegment*)AList::GetHead();}
    CSongSegment* GetItem(LONG lIndex){return (CSongSegment*)AList::GetItem(lIndex);}
    CSongSegment* RemoveHead()  { return (CSongSegment *)AList::RemoveHead();};
    void Remove(CSongSegment* pSongSegment){AList::Remove((AListItem*)pSongSegment);}
    void AddTail(CSongSegment* pSongSegment){AList::AddTail((AListItem*)pSongSegment);}
    CSongSegment* GetTail(){ return (CSongSegment*)AList::GetTail();}
};


class CSong;

DEFINE_GUID(IID_CSong,0xb06c0c22, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CSong
class CSong : 
	public IDirectMusicSong,
	public IPersistStream,
	public IDirectMusicObject,
    public IDirectMusicObjectP
{
public:
	CSong();
	~CSong();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSong
    STDMETHODIMP Compose( );
    STDMETHODIMP GetParam( REFGUID rguidType, 
                            DWORD dwGroupBits, 
                            DWORD dwIndex, 
                            MUSIC_TIME mtTime, 
                            MUSIC_TIME* pmtNext, 
                            void* pParam) ;
    STDMETHODIMP GetSegment( WCHAR *wszName,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppAudioPathConfig);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

public:
    HRESULT GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
        DMUS_IO_TRANSITION_DEF *pTransDef);
    HRESULT GetPlaySegment( DWORD dwIndex,CSegment **ppSegment) ;
private:
    void                Clear();
    HRESULT				Instantiate() ;
    HRESULT             LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser);
    HRESULT             LoadSegmentList(CRiffParser *pParser);
    HRESULT             LoadGraphList(CRiffParser *pParser);
    HRESULT             LoadVirtualSegmentList(CRiffParser *pParser);
    HRESULT             LoadTrackRefList(CRiffParser *pParser, CVirtualSegment *pVirtualSegment);
    HRESULT             LoadAudioPath(IStream *pStream);

    void GetGraph(CGraph **ppGraph,DWORD dwGraphID);
    void GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID);
    BOOL GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID);
    CAudioPathConfig*   m_pAudioPathConfig;     // Optional audio path loaded from file. 
    CGraphList          m_GraphList;            // List of graphs for use by segments in the song.
    CSongSegmentList    m_SegmentList;          // List of source segments.
    CSegmentList        m_PlayList;             // List of composed segments.
    CVirtualSegmentList m_VirtualSegmentList;   // List of segment references. This is what is used to compose the finished song.         
    CRITICAL_SECTION    m_CriticalSection;      
	DWORD	            m_fPartialLoad;
    DWORD               m_dwFlags;
    DWORD               m_dwStartSegID;         // ID of first segment, in play list, that should play.
	long                m_cRef;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    DWORD               m_dwVersion;        // Which version of the interfaces is the app requesting?
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch

    bool                m_fZombie;
};


struct CompositionComponent
{
	CVirtualSegment*	pVirtualSegment;			// composing track came from here
	CTrack*		pComposingTrack;	// used for composition
	MUSIC_TIME	mtTime;
};

class ComposingTrack
{
public:
	ComposingTrack();
	~ComposingTrack();
	DWORD GetTrackGroup() { return m_dwTrackGroup; }
	GUID GetTrackID() { return m_guidClassID; }
	DWORD GetPriority() { return m_dwPriority; }
	void SetPriority(DWORD dwPriority) { m_dwPriority = dwPriority; }
	void SetTrackGroup(DWORD dwTrackGroup) { m_dwTrackGroup = dwTrackGroup; }
	void SetTrackID(GUID& rguidClassID) { m_guidClassID = rguidClassID; }
	HRESULT AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack);
	HRESULT Compose(IDirectMusicSong* pSong);
private:
	GUID						m_guidClassID;		// composing track's class id
	DWORD						m_dwTrackGroup;		// track will be composed from these groups
    DWORD						m_dwPriority;		// Track priority, to order the composition process.
	TList<CompositionComponent>	m_Components;		// list of components making up the master
};

#endif //__DIRECTMUSICSONGOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\smartref.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

#include "smartref.h"
using namespace SmartRef;
#include <xutility>
#include "miscutil.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// AString

AString::AString(const char *psz, UINT cch)
{
    assert(psz);
    m_psz = new char[cch + 1];
    if (m_psz)
    {
        strncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }
}

AString &
AString::operator =(const char *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        m_psz = new char[strlen(psz) + 1];
        if (m_psz)
            strcpy(m_psz, psz);
    }

    return *this;
}

AString &AString::Assign(const char *psz, UINT cch)
{
    assert(psz);
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    m_psz = new char[cch + 1];
    if (m_psz)
    {
        strncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }

    return *this;
}

AString &
AString::AssignFromW(const WCHAR *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        int cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);
        if (cch)
        {
            m_psz = new char[cch];
            if (m_psz)
            {
                cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, m_psz, cch, NULL, NULL);
                if (!cch)
                {
                    assert(false);
                    delete[] m_psz;
                    m_psz = NULL;
                }
            }
        }
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////
// WString

WString &
WString::operator =(const WCHAR *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        m_psz = new WCHAR[wcslen(psz) + 1];
        if (m_psz)
            wcscpy(m_psz, psz);
    }

    return *this;
}

WString &WString::Assign(const WCHAR *psz, UINT cch)
{
    assert(psz);
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    m_psz = new WCHAR[cch + 1];
    if (m_psz)
    {
        wcsncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }

    return *this;
}

WString &
WString::AssignFromA(const char *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        int cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
        if (cch)
        {
            m_psz = new WCHAR[cch];
            if (m_psz)
            {
                cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, m_psz, cch);
                if (!cch)
                {
                    assert(false);
                    delete[] m_psz;
                    m_psz = NULL;
                }
            }
        }
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////
// RiffIter

RiffIter::RiffIter(IStream *pStream)
  : m_hr(S_OK),
    m_pIStream(pStream),
    m_pIDMStream(NULL),
    m_fParent(false)
{
    m_pIStream->AddRef();

    ZeroMemory(&m_ckParent, sizeof(m_ckParent));
    ZeroMemory(&m_ckChild, sizeof(m_ckChild));

    m_hr = ::AllocDirectMusicStream(m_pIStream, &m_pIDMStream);
    if (FAILED(m_hr))
        return;

    m_hr = m_pIDMStream->Descend(&m_ckChild, NULL, 0);
}

RiffIter::~RiffIter()
{
    if (!m_fParent)
    {
        SafeRelease(m_pIStream);
        SafeRelease(m_pIDMStream);
    }
}

RiffIter
&RiffIter::operator ++()
{
    if (validate())
        return *this;

    m_hr = m_pIDMStream->Ascend(&m_ckChild, 0);
    if (FAILED(m_hr))
        return *this;

    m_ckChild.ckid = 0;
    m_ckChild.fccType = 0;
    m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);
    return *this;
}

RiffIter
&RiffIter::Find(RiffType t, FOURCC idFind)
{
    if (validate())
        return *this;

    while (*this && (type() != t || id() != idFind))
        ++*this;

    return *this;
}

HRESULT
RiffIter::ReadChunk(
        void *pv,
        UINT cb)
{
    if (type() != Chunk)
    {
        assert(false);
        return DMUS_E_CANNOTREAD;
    }

    ZeroMemory(pv, cb);
    DWORD cbRead = 0;
    DWORD cbSize = std::_cpp_min<DWORD>(cb, m_ckChild.cksize);
    HRESULT hr = m_pIStream->Read(pv, cbSize, &cbRead);
    if (FAILED(hr) || cbRead != cbSize)
    {
        Trace(1, "Error: Unable to read file.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    return hr;
}

HRESULT
RiffIter::ReadArrayChunk(
    DWORD cbSize,
    void **ppv,
    int *pcRecords)
{
    // zero the out params
    *ppv = NULL;
    *pcRecords = 0;

    // get the size of the chunk and its records

    UINT cbChunk = size();
    if (cbChunk < sizeof(DWORD))
    {
        assert(false);
        return E_FAIL;
    }

    DWORD cbChunkRecord = 0;
    HRESULT hr = RiffIterReadChunk(*this, &cbChunkRecord);
    if (FAILED(hr))
        return hr;
    cbChunk -= sizeof(DWORD);

    if (cbChunk % cbChunkRecord != 0)
    {
        // array is not divisible by size of records!
        assert(false);
        return E_FAIL;
    }

    UINT cRecords = cbChunk / cbChunkRecord;

    // Get the whole rest of the chunk
    PtrArray<char> sprgChunk = new char[cbChunk];
    if (!sprgChunk)
        return E_OUTOFMEMORY;
    hr = ReadChunk(sprgChunk, cbChunk);
    if (FAILED(hr))
        return hr;

    // Return the chunk and its info.

    if (cbChunkRecord == cbSize)
    {
        // Great!  Return the chunk as is.
        *ppv = sprgChunk.disown();
    }
    else
    {
        // make an array of the requested size
        char *pArray = new char[cbSize * cRecords];
        if (!pArray)
            return E_OUTOFMEMORY;
        ZeroMemory(pArray, cbSize * cRecords);

        // copy each record
        char *pRec = sprgChunk; // iterate reading each record of the chunk
        char *pEnd = pRec + cbChunkRecord * cRecords; // stop before this (nonexistant) record
        char *pOut = pArray; // iterate writing into the array
        while (pRec < pEnd)
        {
            memcpy(pOut, pRec, std::_cpp_min<DWORD>(cbChunkRecord, cbSize));
            pRec += cbChunkRecord;
            pOut += cbSize;
        }
        *ppv = pArray;
    }

    *pcRecords = cRecords;
    return hr;
}

HRESULT RiffIter::FindAndGetEmbeddedObject(
        RiffType t,
        FOURCC idFind,
        HRESULT hrOnNotFound,
        IDirectMusicLoader *pLoader,
        REFCLSID rclsid,
        REFIID riid,
        LPVOID *ppv)
{
    if (validate() || !pLoader || !ppv)
    {
        assert(false);
        return E_FAIL;
    }

    *ppv = NULL;
    MMCKINFO ckLast;
    ZeroMemory(&ckLast, sizeof(ckLast));

    while (*this && (type() != t || id() != idFind))
    {
        ckLast = m_ckChild;
        ++*this;
    }

    if (!*this)
        return hrOnNotFound;

    // Ascend in such a way that the stream can be used to find this chunk.
    m_hr = m_pIDMStream->Ascend(&ckLast, 0);
    if (FAILED(m_hr))
        return m_hr;

    // Call GetObject using the stream
    DMUS_OBJECTDESC desc;
    ZeroAndSize(&desc);
    desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
    desc.guidClass = rclsid;
    desc.pStream = m_pIStream;
    HRESULT hrLoad = pLoader->GetObject(&desc, riid, ppv);

    // Descend again to leave the stream at the next chunk
    m_ckChild.ckid = 0;
    m_ckChild.fccType = 0;
    m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

    HRESULT hrDescend = this->hr();
    if (FAILED(hrDescend))
    {
        // Give precedence to reporting failure in the stream even though getting the
        // object succeeded before the failure.
        if (*ppv)
        {
            IUnknown *punk = static_cast<IUnknown *>(*ppv);
            if (punk)
                punk->Release();
            *ppv = NULL;
        }
        return hrDescend;
    }
    else
    {
        return hrLoad;
    }
}

HRESULT
RiffIter::ReadReference(DMUS_OBJECTDESC *pDESC)
{
    HRESULT hr = S_OK;

    assert(this->type() == List && this->id() == DMUS_FOURCC_REF_LIST);

    ZeroAndSize(pDESC);

    for (RiffIter ri = this->Descend(); ri; ++ri)
    {
        switch (ri.id())
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = SmartRef::RiffIterReadChunk(ri, &ioDMRef);
                if (SUCCEEDED(hr))
                {
                    pDESC->guidClass = ioDMRef.guidClassID;
                    pDESC->dwValidData |= ioDMRef.dwValidData;
                    pDESC->dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->guidObject);
                if (SUCCEEDED(hr))
                    pDESC->dwValidData |=  DMUS_OBJ_OBJECT;
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->ftDate);
                if (SUCCEEDED(hr))
                    pDESC->dwValidData |=  DMUS_OBJ_DATE;
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszName);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszName[DMUS_MAX_NAME - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_NAME;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszFileName);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszCategory);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = SmartRef::RiffIterReadChunk(ri, &ioDMObjVer);
                if (SUCCEEDED(hr))
                {
                    pDESC->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    pDESC->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    pDESC->dwValidData |= DMUS_OBJ_VERSION;
                }
                else
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    }
    return ri.hr();
}

HRESULT RiffIter::LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop)
{
    assert(pObjInfo);
    pObjInfo->Clear();

    HRESULT hr = S_OK;

    if (!(*this))
        return this->hr();

    for ( ; *this; ++(*this))
    {
        RiffType rtype = type();
        FOURCC fcc = id();
        if (rtype == rtypeStop && fcc == ridStop)
            return S_OK;

        if (rtype == SmartRef::RiffIter::Chunk)
        {
            if (fcc == DMUS_FOURCC_GUID_CHUNK)
                hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->guid);
            else if (fcc == DMUS_FOURCC_VERSION_CHUNK)
                hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->vVersion);
        }
        else if (rtype == SmartRef::RiffIter::List)
        {
            if (fcc == DMUS_FOURCC_UNFO_LIST)
            {
                RiffIter riUnfo = this->Descend();
                if (!riUnfo)
                    return riUnfo.hr();
                if (riUnfo.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_UNAM_CHUNK))
                {
                    hr = riUnfo.ReadTextTrunc(pObjInfo->wszName, DMUS_MAX_NAME);
                    if (FAILED(hr))
                        return hr;
                }
            }
        }

        if (FAILED(hr))
            return hr;
    }
    
    Trace(1, "Error: Unable to read file.\n");
    return E_FAIL;
}

HRESULT RiffIter::ReadText(WCHAR **ppwsz)
{
    DWORD dwSize = this->size();
    if (dwSize % 2 != 0)
    {
        assert(false);
        return E_FAIL;
    }
    *ppwsz = new WCHAR[dwSize / 2];
    if (!*ppwsz)
        return E_OUTOFMEMORY;
    HRESULT hr = this->ReadChunk(*ppwsz, dwSize);
    return hr;
}

HRESULT RiffIter::ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize)
{
    DWORD dwSize = this->size();
    if (dwSize % 2 != 0)
    {
        assert(false);
        return E_FAIL;
    }
    HRESULT hr = this->ReadChunk(pwsz, std::_MIN<DWORD>(dwSize, (cbBufSize - 1) * 2));
    pwsz[cbBufSize - 1] = L'\0';
    return hr;
}

RiffIter::RiffIter(const RiffIter &other, MMCKINFO ckParent)
  : m_hr(S_OK),
    m_pIStream(other.m_pIStream),
    m_pIDMStream(other.m_pIDMStream),
    m_fParent(true),
    m_ckParent(ckParent)
{
    other.validate();
    ZeroMemory(&m_ckChild, sizeof(m_ckChild));

    m_hr = m_pIDMStream->Descend(&m_ckChild, &m_ckParent, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmime

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmime.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2

INCLUDES=$(INCLUDES);   \
    ..\..\shared

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
           $(SDK_LIB_PATH)\winmm.lib        \
	   $(SDK_LIB_PATH)\advapi32.lib		\
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\user32.lib       \
           $(SDK_LIB_PATH)\dsound.lib       \
           $(SDK_LIB_PATH)\dmoguids.lib


SOURCES=..\alist.cpp           \
..\debug.cpp           \
..\dmgraph.cpp         \
..\dmhall.cpp          \
..\dmperf.cpp          \
..\dmprfdll.cpp        \
..\dmsegobj.cpp        \
..\dmsstobj.cpp        \
..\midifile.cpp        \
..\mutx.cpp            \
..\oledll.cpp          \
..\queue.cpp           \
..\seqtrack.cpp        \
..\sysextrk.cpp        \
..\tempotrk.cpp        \
..\tsigtrk.cpp         \
..\dmstrm.cpp		   \
..\curvetrk.cpp        \
..\pchmap.cpp          \
..\dmime.rc            \
..\opnew.cpp           \
..\audpath.cpp         \
..\lyrictrk.cpp        \
..\marktrk.cpp         \
..\paramtrk.cpp        \
..\segtrtrk.cpp        \
..\smartref.cpp        \
..\song.cpp            \
..\trackhelp.cpp       \
..\wavtrack.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\song.cpp ===
//
// Copyright (c) 1998-2001 Microsoft Corporation
// song.cpp : Implementation of CSong
//

#include "dmime.h"
#include "song.h"
#include "..\shared\validp.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "debug.h"

CTrack::CTrack()
{
    m_pTrack = NULL;
    m_pTrack8 = NULL;
    m_pTrackState = NULL;
    m_bDone = FALSE;
    m_dwPriority = 0;
    m_dwPosition = 0;
    m_dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    m_dwInternalFlags = 0;
    m_dwGroupBits = 0xFFFFFFFF;
    m_dwVirtualID = 0;
    m_guidClassID = GUID_NULL;
}

CTrack::~CTrack()
{
    assert( !( m_pTrackState && !m_pTrack ) ); // if we have state but no track, something's wrong
    if( m_pTrack )
    {
        if( m_pTrackState )
        {
            m_pTrack->EndPlay( m_pTrackState ); // allow the track to delete its state data
        }
        m_pTrack->Release();
    }
    if ( m_pTrack8 )
    {
        m_pTrack8->Release();
    }
}

HRESULT CTrackList::CreateCopyWithBlankState(CTrackList* pTrackList)
{
    if( pTrackList )
    {
        CTrack* pTrack;
        CTrack* pCopy;
        pTrackList->Clear();
        pTrack = (CTrack*)m_pHead;
        while( pTrack )
        {
            pCopy = new CTrack;
            if( pCopy )
            {
                // copy the IDirectMusicTrack pointer, but leave
                // the track state blank.
                *pCopy = *pTrack;
                pCopy->SetNext(NULL);
                pCopy->m_pTrackState = NULL;
                assert( pCopy->m_pTrack );
                pCopy->m_pTrack->AddRef();
                if (pCopy->m_pTrack8)
                {
                    pCopy->m_pTrack8->AddRef();
                }
                pTrackList->Cat( pCopy );
            }
            else
            {
                assert(FALSE); // out of memory
                return E_OUTOFMEMORY;
            }
            pTrack = pTrack->GetNext();
        }
    }
    else
    {
        assert(FALSE); // out of memory
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

CVirtualSegment::CVirtualSegment()
{
    m_wszName[0] = 0;
    m_pSourceSegment = NULL;
    m_pPlaySegment = NULL;
    m_pGraph = NULL;
    m_dwFlags = 0;
    m_dwID = 0;
    m_dwNextPlayID = DMUS_SONG_NOSEG;
    m_dwNextPlayFlags = 0;
    m_mtTime = 0;
    m_dwTransitionCount = 0;
    m_pTransitions = NULL;
    m_SegHeader.rtLength = 0;
    m_SegHeader.dwFlags = 0;
    m_SegHeader.dwRepeats = 0;      /* Number of repeats. By default, 0. */
    m_SegHeader.mtLength = 0xC00;   /* Length, in music time. */
    m_SegHeader.mtPlayStart = 0;    /* Start of playback. By default, 0. */
    m_SegHeader.mtLoopStart = 0;    /* Start of looping portion. By default, 0. */
    m_SegHeader.mtLoopEnd = 0;      /* End of loop. Must be greater than dwPlayStart. By default equal to length. */
    m_SegHeader.dwResolution = 0;   /* Default resolution. */
}

CVirtualSegment::~CVirtualSegment()
{
    if (m_pSourceSegment)
    {
        m_pSourceSegment->Release();
    }
    if (m_pPlaySegment)
    {
        m_pPlaySegment->Release();
    }
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pTransitions)
    {
        delete [] m_pTransitions;
    }
    m_TrackList.Clear();
}

CTrack * CVirtualSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) &&
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
        {
            if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

void CVirtualSegmentList::Clear()
{
    CVirtualSegment *pVirtualSegment;
    while (pVirtualSegment = RemoveHead())
    {
        delete pVirtualSegment;
    }
}

CSongSegment::CSongSegment()
{
    m_pSegment = NULL;
    m_dwLoadID = 0;
}

CSongSegment::~CSongSegment()
{
    if (m_pSegment)
    {
        m_pSegment->Release();
    }
}

HRESULT CSongSegmentList::AddSegment(CSegment *pSegment, DWORD dwLoadID)
{
    CSongSegment *pSeg = new CSongSegment;
    if (pSeg)
    {
        pSeg->m_dwLoadID = dwLoadID;
        pSeg->m_pSegment = pSegment;
        pSegment->AddRef();
        AddTail(pSeg);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

void CSongSegmentList::Clear()
{
    CSongSegment *pSongSegment;
    while (pSongSegment = RemoveHead())
    {
        delete pSongSegment;
    }
}


CSong::CSong()
{
    InitializeCriticalSection(&m_CriticalSection);
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_pAudioPathConfig = NULL;
    m_fPartialLoad = FALSE;
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_pUnkDispatch = NULL;
    InterlockedIncrement(&g_cComponent);
    m_fZombie = false;
    TraceI(2, "Song %lx created\n", this );
}

CSong::~CSong()
{
    Clear();

    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
    TraceI(2, "Song %lx destroyed\n", this );
}


void CSong::Clear()
{
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    m_GraphList.Clear();
    m_PlayList.Clear();
    m_SegmentList.Clear();
    m_VirtualSegmentList.Clear();
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_fPartialLoad = FALSE;
    m_dwFlags = 0;
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
}

STDMETHODIMP_(void) CSong::Zombie()
{
    Clear();
    m_fZombie = true;
}

STDMETHODIMP CSong::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSong::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSong)
    {
        *ppv = static_cast<IDirectMusicSong*>(this);
    }
    else if (iid == IID_CSong)
    {
        *ppv = static_cast<CSong*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDirectMusicObjectP)
    {
        *ppv = static_cast<IDirectMusicObjectP*>(this);
    }
    else if(iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSong,
                static_cast<IDirectMusicSong*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Song object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSong::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSong::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSong::Compose( )
{
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Compose after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    // Go through the seg ref list and create master composition tracks for each composing track.
    TList<ComposingTrack> MasterTrackList;
    CVirtualSegment* pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (; pVirtualSegment; pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (!pVirtualSegment->m_pPlaySegment)
        {
            Trace(1,"Error: Corrupt song, one or more virtual segments do not resolve to real segments. Unable to compose.\n");
            hr = E_POINTER;
            break;
        }
        CSegment *pSegment = pVirtualSegment->m_pPlaySegment;
        CTrack* pTrack = pSegment->m_TrackList.GetHead();
        for (; pTrack; pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
            {
                DWORD dwTrackGroup = pTrack->m_dwGroupBits;
                // filter out any group bits already covered by other master tracks of same type
                TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
                for (; pMaster; pMaster = pMaster->GetNext())
                {
                    ComposingTrack& rMaster = pMaster->GetItemValue();
                    if (rMaster.GetTrackID() == pTrack->m_guidClassID)
                    {
                        DWORD dwMaster = rMaster.GetTrackGroup();
                        if (dwMaster == dwTrackGroup)
                        {
                            // Exact match: put the track here.
                            hr = rMaster.AddTrack(pVirtualSegment, pTrack);
                            dwTrackGroup = 0;
                            break;
                        }
                        DWORD dwIntersection = dwMaster & dwTrackGroup;
                        if (dwIntersection)
                        {
                            dwTrackGroup |= ~dwIntersection;
                        }
                    }
                }
                // If we've still got any group bits left, add a new composing track
                if (dwTrackGroup)
                {
                    TListItem<ComposingTrack>* pTrackItem = new TListItem<ComposingTrack>;
                    if (!pTrackItem)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        ComposingTrack& rTrack = pTrackItem->GetItemValue();
                        rTrack.SetTrackGroup(dwTrackGroup);
                        rTrack.SetTrackID(pTrack->m_guidClassID);
                        rTrack.SetPriority(pTrack->m_dwPriority);
                        // Add tracks in priority order (higher priority first)
                        pMaster = MasterTrackList.GetHead();
                        TListItem<ComposingTrack>* pPrevious = NULL;
                        for (; pMaster; pMaster = pMaster->GetNext())
                        {
                            ComposingTrack& rMaster = pMaster->GetItemValue();
                            if (pTrack->m_dwPriority > rMaster.GetPriority()) break;
                            pPrevious = pMaster;
                        }
                        if (!pPrevious) // this has higher priority than anything in the list
                        {
                            MasterTrackList.AddHead(pTrackItem);
                        }
                        else // lower priority than pPrevious, higher than pMaster
                        {
                            pTrackItem->SetNext(pMaster);
                            pPrevious->SetNext(pTrackItem);
                        }
                        hr = pTrackItem->GetItemValue().AddTrack(pVirtualSegment, pTrack);
                    }
                }
            }
            if (FAILED(hr)) break;
        }
        if (FAILED(hr)) break;
    }

    // Call compose on each master composition track
    if (SUCCEEDED(hr))
    {
        TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
        if (pMaster)
        {
            for (; pMaster; pMaster = pMaster->GetNext())
            {
                hr = pMaster->GetItemValue().Compose(this);
            }
        }
        else hr = S_FALSE;
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::Download(IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicSong::Download);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Download after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Download(pAudioPath)))
        {
            // count partial successes, so that S_FALSE will be returned if we have, e.g.,
            // one partial success followed by one failure
            dwSuccess++;
        }
        if (hr != S_OK)
        {
            // keep track of partial successes so that they always percolate up
            hrFail = hr;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (hrFail != S_OK && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully downloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP CSong::Unload(IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicSong::Unload);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Unload after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Unload(pAudioPath)))
        {
            dwSuccess++;
        }
        else
        {
            hrFail = hr;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (FAILED(hrFail) && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully unloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}


/*STDMETHODIMP CSong::Clone(IDirectMusicSong **ppSong)

{
    V_INAME(IDirectMusicSong::Clone);
    V_PTRPTR_WRITE_OPT(ppSong);
    HRESULT hr = E_OUTOFMEMORY;
    CSong *pSong = new CSong();
    if (*ppSong)
    {
        *ppSong = pSong;
        EnterCriticalSection(&m_CriticalSection);
        CSegment *pSegment = m_PlayList.GetHead();
        for (;pSegment;pSegment = pSegment->GetNext())
        {
            IDirectMusicSegment *pISeg;
            hr = pSegment->Clone(0,pSegment->m_mtLength,&pISeg);
            if (SUCCEEDED(hr))
            {
                CSegment *pCopy = (CSegment *) pISeg;
                pSong->m_PlayList.AddTail(pCopy);
                pCopy->m_pSong = pSong;
            }
        }
        pSong->m_dwValidData = m_dwValidData;
        pSong->m_guidObject = m_guidObject;
        pSong->m_ftDate = m_ftDate;
        pSong->m_vVersion = m_vVersion;
        wcscpy(pSong->m_wszName,m_wszName);
        wcscpy(pSong->m_wszCategory,m_wszCategory);
        wcscpy(pSong->m_wszFileName,m_wszFileName);
        pSong->m_dwVersion = m_dwVersion;
        pSong->m_dwFlags = m_dwFlags;
        pSong->m_pAudioPathConfig = m_pAudioPathConfig;
        if (m_pAudioPathConfig)
            m_pAudioPathConfig->AddRef();
        LeaveCriticalSection(&m_CriticalSection);
    }
    return hr;
}
*/

STDMETHODIMP CSong::GetParam( REFGUID rguidType,
                        DWORD dwGroupBits,
                        DWORD dwIndex,
                        MUSIC_TIME mtTime,
                        MUSIC_TIME* pmtNext,
                        void* pParam)
{
    V_INAME(IDirectMusiCSong::GetParam);
    V_REFGUID(rguidType);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetParam after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
/*    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        fMultipleTry = TRUE;
    }*/
    EnterCriticalSection(&m_CriticalSection);
    /*CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_mtStart <= mtTime &&
            mtTime < pSegment->m_mtStart + pSegment->m_mtLength)
        {
            hr = pSegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pSegment->m_mtStart, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }*/
    CVirtualSegment *pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime &&
            pVirtualSegment->m_pPlaySegment &&
            mtTime < pVirtualSegment->m_mtTime + pVirtualSegment->m_pPlaySegment->m_mtLength)
        {
            hr = pVirtualSegment->m_pPlaySegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }
/*    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime)
        {
            CTrack* pCTrack;
            pCTrack = pVirtualSegment->GetTrackByParam(NULL, rguidType,dwGroupBits, dwIndex);
            while (pCTrack)
            {
                if (pCTrack->m_pTrack8)
                {
                    REFERENCE_TIME rtNext, *prtNext;
                    // We need to store the next time in a 64 bit pointer. But, don't
                    // make 'em fill it in unless the caller requested it.
                    if (pmtNext)
                    {
                        prtNext = &rtNext;
                    }
                    else
                    {
                        prtNext = NULL;
                    }
                    hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime - pVirtualSegment->m_mtTime, prtNext, pParam,
                        NULL, 0 );
                    if (pmtNext)
                    {
                        *pmtNext = (MUSIC_TIME) rtNext;
                    }
                }
                else
                {
                    hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam );
/ *                 if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
                    {
                        *pmtNext = m_mtLength - mtTime;
                    }* /
                }
                // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
                if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
                {
                    pCTrack = pVirtualSegment->GetTrackByParam(pCTrack, rguidType,dwGroupBits, dwIndex);
                }
                else
                {
                    pCTrack = NULL;
                }
            }
        }
    }*/
    if (FAILED(hr) && pmtNext)
    {
        // return the time of the first segment after mtTime (or 0 if there is no such segment)
        pVirtualSegment = m_VirtualSegmentList.GetHead();
        for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
        {
            if (pVirtualSegment->m_mtTime > mtTime)
            {
                *pmtNext = pVirtualSegment->m_mtTime;
                break;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSong::Instantiate()
{
    V_INAME(IDirectMusicSong::Instantiate);
    EnterCriticalSection(&m_CriticalSection);
    CVirtualSegment *pRef = m_VirtualSegmentList.GetHead();
    m_PlayList.Clear();
    for (;pRef;pRef = pRef->GetNext())
    {
        // the constructor below does an AddRef.
        CSegment *pSegment = new CSegment(&pRef->m_SegHeader,pRef->m_pSourceSegment);
        if (pSegment)
        {
            if (pRef->m_wszName[0])
            {
                wcscpy(pSegment->m_wszName,pRef->m_wszName);
                pSegment->m_dwValidData |= DMUS_OBJ_NAME;
            }
            CTrack *pTrack;
            for (pTrack = pRef->m_TrackList.GetHead();pTrack;pTrack = pTrack->GetNext())
            {
                CTrack *pCopy = new CTrack;
                if( pCopy )
                {
                    *pCopy = *pTrack;
                    pCopy->SetNext(NULL);
                    pCopy->m_pTrackState = NULL;
                    pCopy->m_pTrack->AddRef();
                    if (pCopy->m_pTrack8)
                    {
                        pCopy->m_pTrack8->AddRef();
                    }
                    // The tracks were in backwards order. This puts them back in order, and ahead of the segment tracks.
                    pSegment->m_TrackList.AddHead( pCopy );
                }
            }
            pSegment->m_pSong = this;
            pSegment->m_dwPlayID = pRef->m_dwID;
//Trace(0,"Intantiating PlaySegment %ls with ID %ld.\n",pRef->m_wszName,pRef->m_dwID);
            pSegment->m_dwNextPlayFlags = pRef->m_dwNextPlayFlags;
            pSegment->m_dwNextPlayID = pRef->m_dwNextPlayID;
            m_PlayList.AddTail(pSegment);
            if (pRef->m_pPlaySegment) pRef->m_pPlaySegment->Release();
            pRef->m_pPlaySegment = pSegment;
            pRef->m_pPlaySegment->AddRef();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSong::EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment)
{
    V_INAME(IDirectMusicSong::EnumSegment);
    V_PTRPTR_WRITE (ppSegment);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::EnumSegment after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment && dwIndex;pSegment = pSegment->GetNext()) dwIndex--;
    if (pSegment)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
        pSegment->AddRef();
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSong::GetPlaySegment( DWORD dwIndex,CSegment **ppSegment)
{
    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_dwPlayID == dwIndex)
        {
            *ppSegment = pSegment;
            pSegment->AddRef();
            hr = S_OK;
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::GetSegment(WCHAR *wszName, IDirectMusicSegment **ppSegment)
{
    V_INAME(IDirectMusicSong::GetSegment);
    V_PTRPTR_WRITE(ppSegment);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetSegment after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    CSegment *pSegment;
    if (wszName)
    {
        V_BUFPTR_READ(wszName,2);
        EnterCriticalSection(&m_CriticalSection);
        pSegment = m_PlayList.GetHead();
        for (;pSegment;pSegment = pSegment->GetNext())
        {
            if (_wcsicmp(pSegment->m_wszName, wszName) == 0)
            {
                pSegment->AddRef();
                hr = S_OK;
                break;
            }
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        hr = GetPlaySegment( m_dwStartSegID,&pSegment);
    }
    if (hr == S_OK)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
    }
    else
    {
#ifdef DBG
        if (wszName)
        {
            Trace(1,"Error: Unable to find segment %ls in song.\n",wszName);
        }
        else
        {
            Trace(1,"Error: Unable to find starting segment in the song.\n");
        }
#endif
    }
    return hr;
}

STDMETHODIMP CSong::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)
{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
    V_PTRPTR_WRITE(ppAudioPathConfig);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetAudioPathConfig after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the song.\n");
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSong::GetClassID( CLSID* pClassID )
{
    V_INAME(CSong::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetClassID after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pClassID = CLSID_DirectMusicSong;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSong::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CSong::Load( IStream* pIStream )
{
    V_INAME(CSong::Load);
    V_INTERFACE(pIStream);

    // Song format temporarily turned off for DX8 release.
    return E_NOTIMPL;
    /*
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Load after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Create RIFF parser.
    CRiffParser Parser(pIStream);

    RIFFIO ckMain;
    HRESULT hr = S_OK;
    // First, clear the song in case it is being read into a second time.
    Clear();

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SONG_FORM)
        {
            EnterCriticalSection(&m_CriticalSection);
            RIFFIO ckNext;
            RIFFIO ckChild;
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
            while(Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                    case DMUS_FOURCC_SONG_CHUNK:
                        DMUS_IO_SONG_HEADER ioSongHdr;
                        ioSongHdr.dwFlags = 0;
                        hr = Parser.Read(&ioSongHdr, sizeof(DMUS_IO_SONG_HEADER));
                        if(SUCCEEDED(hr))
                        {
                            m_dwFlags = ioSongHdr.dwFlags;
                            m_dwStartSegID = ioSongHdr.dwStartSegID;
                        }
                        break;

                    case DMUS_FOURCC_GUID_CHUNK:
                        if( ckNext.cksize == sizeof(GUID) )
                        {
                            hr = Parser.Read(&m_guidObject, sizeof(GUID));
                            if( SUCCEEDED(hr) )
                            {
                                m_dwValidData |= DMUS_OBJ_OBJECT;
                            }
                        }
                        break;

                    case DMUS_FOURCC_VERSION_CHUNK:
                        hr = Parser.Read( &m_vVersion, sizeof(DMUS_VERSION) );
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_VERSION;
                        }
                        break;

                    case DMUS_FOURCC_CATEGORY_CHUNK:
                        hr = Parser.Read( m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_CATEGORY;
                        }
                        break;

                    case DMUS_FOURCC_DATE_CHUNK:
                        if( sizeof(FILETIME) == ckNext.cksize )
                        {
                            hr = Parser.Read( &m_ftDate, sizeof(FILETIME) );
                            if( SUCCEEDED(hr) )
                            {
                                m_dwValidData |= DMUS_OBJ_DATE;
                            }
                        }
                        break;

                    case FOURCC_LIST:
                    case FOURCC_RIFF:
                        switch(ckNext.fccType)
                        {
                            case DMUS_FOURCC_UNFO_LIST:
                                Parser.EnterList(&ckChild);
                                while(Parser.NextChunk(&hr))
                                {
                                    switch( ckChild.ckid )
                                    {
                                        case DMUS_FOURCC_UNAM_CHUNK:
                                        {
                                            hr = Parser.Read(&m_wszName, sizeof(m_wszName));
                                            if(SUCCEEDED(hr) )
                                            {
                                                m_dwValidData |= DMUS_OBJ_NAME;
                                            }
                                            break;
                                        }
                                        default:
                                            break;
                                    }
                                }
                                Parser.LeaveList();
                                break;
                            case DMUS_FOURCC_CONTAINER_FORM:
                                // An embedded container RIFF chunk which includes a bunch
                                // of objects referenced by the song. This should precede the
                                // segments and gets loaded prior to them. Loading this
                                // causes all of its objects to get SetObject'd in the loader,
                                // so they later get pulled in as requested by the tracks in the segments.
                                // After the tracks are loaded, the loader references are
                                // released by a call to release the IDirectMusicContainer.
                                {
                                    DMUS_OBJECTDESC Desc;
                                    IDirectMusicLoader *pLoader;
                                    IDirectMusicGetLoader *pGetLoader;
                                    HRESULT hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                        {
                                            // Move back stream's current position
                                            Parser.SeekBack();
                                            Desc.dwSize = sizeof(Desc);
                                            Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                            Desc.guidClass = CLSID_DirectMusicContainer;
                                            Desc.pStream = pIStream;
                                            pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                            if (pContainer)
                                            {
                                                // Don't cache the container object! We want it and the
                                                // objects it references to go away when the segment is done loading.
                                                IDirectMusicObject *pObject = NULL;
                                                pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                                if (pObject)
                                                {
                                                    pLoader->ReleaseObject(pObject);
                                                    pObject->Release();
                                                }
                                            }
                                            // Now, seek to the end of this chunk.
                                            Parser.SeekForward();
                                            pLoader->Release();
                                        }
                                        pGetLoader->Release();
                                    }
                                }
                                break;
                            case DMUS_FOURCC_SONGSEGMENTS_LIST:
                                hr = LoadSegmentList(&Parser); //pIStream, pIDirectMusicStream, ckNext);
                                break;
                            case DMUS_FOURCC_SEGREFS_LIST:
                                hr = LoadVirtualSegmentList(&Parser);
                                break;
                            case DMUS_FOURCC_AUDIOPATH_FORM:
                                // Move back to start of this chunk.
                                Parser.SeekBack();
                                hr = LoadAudioPath(pIStream);
                                // Now, seek to the end of this chunk.
                                Parser.SeekForward();
                                break;
                            default:
                                break;
                        }
                        break;

                    default:
                        break;

                }
            }
            Parser.LeaveList();
            LeaveCriticalSection(&m_CriticalSection);

            if (pContainer)
            {
                pContainer->Release();
            }

            if( SUCCEEDED(hr) )
            {
                if( m_fPartialLoad & PARTIALLOAD_E_FAIL )
                {
                    if( m_fPartialLoad & PARTIALLOAD_S_OK )
                    {
                        Trace(1,"Error: Song load was incomplete, some components failed loading.\n");
                        hr = DMUS_S_PARTIALLOAD;
                    }
                    else
                    {
                        Trace(1,"Error: Song load failed because all components failed loading.\n");
                        hr = DMUS_E_ALL_TRACKS_FAILED;
                    }
                }
            }
        }
        else
        {
            // Couldn't find the chunk header for a song.
            // But, maybe this is actually a segment, in which case see if
            // the segment object will load it.
            CSegment *pSegment = new CSegment;
            if (pSegment)
            {
                pSegment->AddRef(); // Segment::Load (and possibly others) may need the refcount
                // Force the version so audiopath functionality will be supported.
                pSegment->m_dwVersion = 8;
                Parser.SeekBack();
                hr = pSegment->Load(pIStream);
                if (SUCCEEDED(hr))
                {
                    DMUS_OBJECTDESC Desc;
                    Desc.dwSize = sizeof (Desc);
                    pSegment->GetDescriptor(&Desc);
                    Desc.guidClass = CLSID_DirectMusicSong;
                    SetDescriptor(&Desc);
                    // AddSegment addref's by one.
                    m_SegmentList.AddSegment(pSegment,0);
                    pSegment->GetAudioPathConfig((IUnknown **) &m_pAudioPathConfig);
                    m_dwStartSegID = 0; // Points to this segment.
                    CVirtualSegment *pVirtual = new CVirtualSegment;
                    if (pVirtual)
                    {
                        pVirtual->m_pSourceSegment = pSegment;
                        pSegment->AddRef();
                        pVirtual->m_SegHeader.dwRepeats = pSegment->m_dwRepeats;
                        pVirtual->m_SegHeader.dwResolution = pSegment->m_dwResolution;
                        pVirtual->m_SegHeader.mtLength = pSegment->m_mtLength;
                        pVirtual->m_SegHeader.mtLoopEnd = pSegment->m_mtLoopEnd;
                        pVirtual->m_SegHeader.mtLoopStart = pSegment->m_mtLoopStart;
                        pVirtual->m_SegHeader.mtPlayStart = pSegment->m_mtStart;
                        pVirtual->m_SegHeader.rtLength = pSegment->m_rtLength;
                        pVirtual->m_SegHeader.dwFlags = pSegment->m_dwSegFlags;
                        if (pSegment->m_dwValidData & DMUS_OBJ_NAME)
                        {
                            wcscpy(pVirtual->m_wszName,pSegment->m_wszName);
                        }
                        m_VirtualSegmentList.AddHead(pVirtual);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    pSegment->Release(); // release the initial AddRef
                }
                if (FAILED(hr))
                {
                    delete pSegment;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    // If there are no virtual segments, clear the song and fail the load
    if ( !m_VirtualSegmentList.GetHead() )
    {
        Clear();
        hr = DMUS_E_NOT_INIT;
    }
    if (SUCCEEDED(hr)) Instantiate();
    return hr;*/
}

HRESULT CSong::LoadAudioPath(IStream *pStream)
{
    assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    EnterCriticalSection(&m_CriticalSection);
    if(m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
    }
    m_pAudioPathConfig = pPath;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSong::LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser)
{

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pParser->GetStream()->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    RIFFIO ckNext;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
                if(SUCCEEDED(hr))
                {
                    if (ioDMRef.guidClassID != CLSID_DirectMusicSegment)
                    {
                        Trace(1,"Error: Invalid segment reference in song.\n");
                        hr = DMUS_E_CANNOTREAD;
                    }
                    else
                    {
                        desc.guidClass = ioDMRef.guidClassID;
                        desc.dwValidData |= ioDMRef.dwValidData;
                        desc.dwValidData |= DMUS_OBJ_CLASS;
                    }
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pParser->Read(&(desc.guidObject), sizeof(GUID));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                hr = pParser->Read(desc.wszName, sizeof(desc.wszName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                hr = pParser->Read(desc.wszFileName, sizeof(desc.wszFileName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = pParser->Read(desc.wszCategory, sizeof(desc.wszCategory));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            default:
                break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_CSegment, (void**)ppSegment);
        // Once we get the object, we need to ensure that the same object is never
        // connected up to any other songs (or this one, too.)
        // So, we ensure that the loader doesn't keep it around.
        if (SUCCEEDED(hr))
        {
            IDirectMusicObject *pObject;
            if (SUCCEEDED((*ppSegment)->QueryInterface(IID_IDirectMusicObject,(void **)&pObject)))
            {
                pLoader->ReleaseObject(pObject);
                pObject->Release();
            }
            // If the segment has a next pointer, it still must be in another song. This
            // should never happen, but being paranoid...
            if ((*ppSegment)->GetNext())
            {
                *ppSegment = NULL;
                hr = E_FAIL;
                TraceI(0,"Error: Attempt to load song segment that is already referenced by another song. \n");
            }
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT CSong::LoadSegmentList(CRiffParser *pParser)
{
    assert(pParser);

    RIFFIO ckNext, ckChild;
    DWORD dwSegmentCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_LIST:
            if (ckNext.fccType == DMUS_FOURCC_SONGSEGMENT_LIST)
            {
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    switch(ckChild.ckid)
                    {
                    case FOURCC_RIFF:
                    case FOURCC_LIST:
                        if ((ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM) ||
                            (ckChild.fccType == DMUS_FOURCC_REF_LIST))
                        {
                            CSegment *pSegment = NULL;
                            if (ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM)
                            {
                                pSegment = new CSegment;
                                if (pSegment)
                                {
                                    pSegment->AddRef(); // Segment::Load may need a refcount
                                    // Force the version so audiopath functionality will be supported.
                                    pSegment->m_dwVersion = 8;
                                    // Move back to start of this chunk.
                                    pParser->SeekBack();
                                    hr = pSegment->Load(pParser->GetStream());
                                    pParser->SeekForward();
                                }
                                else
                                {
                                    return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                // This will increment the refcount for the segment
                                hr = LoadReferencedSegment( &pSegment, pParser );
                            }
                            if (SUCCEEDED(hr))
                            {
                                // This increments the refcount.
                                m_SegmentList.AddSegment(pSegment,dwSegmentCount);
                            }
                            pSegment->Release(); // Release the extra AddRef
                            dwSegmentCount++;
                            if(SUCCEEDED(hr) && hr != DMUS_S_PARTIALLOAD)
                            {
                                m_fPartialLoad |= PARTIALLOAD_S_OK;
                            }
                            else
                            {
                                m_fPartialLoad |= PARTIALLOAD_E_FAIL;
                                hr = S_OK;
                            }

                        }
                        break;
                    }
                }
                pParser->LeaveList();
            }

        default:
            break;

        }
    }
    pParser->LeaveList();

    return hr;
}

HRESULT CSong::LoadGraphList(CRiffParser *pParser)
{
    RIFFIO ckNext;
    DWORD dwGraphCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
                switch(ckNext.fccType)
                {
                    CGraph *pGraph;
                    case DMUS_FOURCC_TOOLGRAPH_FORM :
                        // Move back to start of this chunk.
                        pParser->SeekBack();
                        pGraph = new CGraph;
                        if (pGraph)
                        {
                            hr = pGraph->Load(pParser->GetStream());
                            dwGraphCount++;
                            if (SUCCEEDED(hr))
                            {
                                m_GraphList.AddTail(pGraph);
                                pGraph->m_dwLoadID = dwGraphCount;
                            }
                            if(SUCCEEDED(hr) && hr != DMUS_S_PARTIALLOAD)
                            {
                                m_fPartialLoad |= PARTIALLOAD_S_OK;
                            }
                            else
                            {
                                m_fPartialLoad |= PARTIALLOAD_E_FAIL;
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        pParser->SeekForward();
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
                                    DMUS_IO_TRANSITION_DEF *pTransDef)
{
    HRESULT hr = DMUS_E_NOT_FOUND;
//    if (pSource) Trace(0,"Transitioning from %ls ",pSource->m_wszName);
//    if (pDestination) Trace(0,"to %ls",pDestination->m_wszName);
//    Trace(0,"\n");
    EnterCriticalSection(&m_CriticalSection);
    // Default values for other fields, in case we don't find a match.
    pTransDef->dwPlayFlags = 0;
    pTransDef->dwTransitionID = DMUS_SONG_NOSEG;
    pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
    CVirtualSegment *pVSource = NULL;
    // If there is a source segment, look to see if it's in this song
    // and pull the matchin virtual segment.
    if (pSource)
    {
        pVSource = m_VirtualSegmentList.GetHead();
        for (;pVSource;pVSource = pVSource->GetNext())
        {
            if (pVSource->m_pPlaySegment == pSource)
            {
//                Trace(0,"Found match for source segment %ls in song\n",pSource->m_wszName);
                break;
            }
        }
    }
    CVirtualSegment *pVDestination = NULL;
    // If there is a destination segment, look to see if it's in this song
    // and pull the matching virtual segment.
    if (pDestination)
    {
        pVDestination = m_VirtualSegmentList.GetHead();
        for (;pVDestination;pVDestination = pVDestination->GetNext())
        {
            if (pVDestination->m_pPlaySegment == pDestination)
            {
//                Trace(0,"Found match for destination segment %ls in song\n",pDestination->m_wszName);
                break;
            }
        }
    }

    if (pVSource)
    {
        if (pVDestination)
        {
            pTransDef->dwSegmentID = pVDestination->m_dwID;
        }
        else
        {
            // If there is no destination, mark this to transition to nothing.
            pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
        }
        if (pVSource->m_dwTransitionCount)
        {
            ASSERT(pVSource->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement.
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
                else if ((pVSource->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_ANYSEG) && !dwMatchCount)
                {
                    // Mark the segment and flags, but don't break because we might still have the matched segment in the list.
                    pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                    pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
//Trace(0,"Found default transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    else if (pVDestination)
    {
        // This is the special case where there is no source segment, perhaps because we are starting
        // playback or we are starting from a different song. In this case, look for a transition in the destination
        // segment for the special case of DMUS_SONG_NOFROMSEG. Typically, this represents a transition
        // segment that is an intro.
        if (pVDestination->m_dwTransitionCount)
        {
            ASSERT(pVDestination->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement.
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from NONE with Transition %lx, flags %lx\n",
//    pVDestination->m_pTransitions[dwIndex].dwTransitionID,pVDestination->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVDestination->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVDestination->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(2,"Warning: No transition segment was found in song.\n");
    }
#endif
    return hr;
}


void CSong::GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID)
{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                pSongSegment->m_pSegment->AddRef();
                *ppSegment = pSongSegment->m_pSegment;
                return;
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
}

void CSong::GetGraph(CGraph **ppGraph,DWORD dwGraphID)
{
    CGraph *pGraph = m_GraphList.GetHead();
    while (pGraph)
    {
        if (pGraph->m_dwLoadID == dwGraphID)
        {
            pGraph->AddRef();
            *ppGraph = pGraph;
            return;
        }
        pGraph = pGraph->GetNext();
    }
}

BOOL CSong::GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID)
{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                return (pSongSegment->m_pSegment->GetTrack(guidClassID,dwGroupBits,dwIndex,ppTrack) == S_OK);
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
    return FALSE;
}


HRESULT CSong::LoadVirtualSegmentList(CRiffParser *pParser)
{
    RIFFIO ckNext;
    RIFFIO ckChild;
    RIFFIO ckUNFO;
    DWORD dwSegmentCount = 0;
    CVirtualSegment *pVirtualSegment;
    MUSIC_TIME mtTime = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    case DMUS_FOURCC_SEGREF_LIST:
                        pVirtualSegment = new CVirtualSegment;
                        if (pVirtualSegment)
                        {
                            BOOL fGotHeader = FALSE;
                            BOOL fGotSegmentHeader = FALSE;
                            pVirtualSegment->m_mtTime = mtTime; // Give the start time, an accumulation of all preceding segments.
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case FOURCC_RIFF:
                                    case FOURCC_LIST:
                                        switch(ckChild.fccType)
                                        {
                                        case DMUS_FOURCC_TRACKREFS_LIST:
                                            hr = LoadTrackRefList(pParser, pVirtualSegment);
                                            break;
                                        case DMUS_FOURCC_UNFO_LIST:
                                            pParser->EnterList(&ckUNFO);
                                            while(pParser->NextChunk(&hr))
                                            {
                                                switch( ckUNFO.ckid )
                                                {
                                                    case DMUS_FOURCC_UNAM_CHUNK:
                                                    {
                                                        hr = pParser->Read(pVirtualSegment->m_wszName, sizeof(pVirtualSegment->m_wszName));
                                                        break;
                                                    }
                                                    default:
                                                        break;
                                                }
                                            }
                                            pParser->LeaveList();
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGREF_CHUNK:
                                    {
                                        DMUS_IO_SEGREF_HEADER ioVirtualSegment;
                                        hr = pParser->Read(&ioVirtualSegment,sizeof(ioVirtualSegment));
                                        if(SUCCEEDED(hr) )
                                        {
                                            pVirtualSegment->m_dwFlags = ioVirtualSegment.dwFlags;
                                            pVirtualSegment->m_dwID = ioVirtualSegment.dwID;
                                            pVirtualSegment->m_dwNextPlayID = ioVirtualSegment.dwNextPlayID;
                                            if (ioVirtualSegment.dwSegmentID != DMUS_SONG_NOSEG)
                                            {
                                                GetSourceSegment(&pVirtualSegment->m_pSourceSegment,ioVirtualSegment.dwSegmentID);
                                            }
                                            if (ioVirtualSegment.dwToolGraphID != DMUS_SONG_NOSEG)
                                            {
                                                GetGraph(&pVirtualSegment->m_pGraph,ioVirtualSegment.dwToolGraphID);
                                            }
                                            fGotHeader = TRUE;
                                        }
                                        break;
                                    }
                                    case DMUS_FOURCC_SEGTRANS_CHUNK:
                                        {
                                            DWORD dwTransCount;
                                            dwTransCount = ckChild.cksize / sizeof(DMUS_IO_TRANSITION_DEF);
                                            if (dwTransCount > 0)
                                            {
                                                pVirtualSegment->m_pTransitions = new DMUS_IO_TRANSITION_DEF[dwTransCount];
                                                if (pVirtualSegment->m_pTransitions)
                                                {
                                                    pVirtualSegment->m_dwTransitionCount = dwTransCount;
                                                    hr = pParser->Read(pVirtualSegment->m_pTransitions,sizeof(DMUS_IO_TRANSITION_DEF)*dwTransCount);
                                                }
                                                else
                                                {
                                                    return E_OUTOFMEMORY;
                                                }
                                            }
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGMENT_CHUNK:
                                        fGotSegmentHeader = TRUE;
                                        hr = pParser->Read(&pVirtualSegment->m_SegHeader, sizeof(DMUS_IO_SEGMENT_HEADER));
                                        mtTime += (pVirtualSegment->m_SegHeader.dwRepeats * (pVirtualSegment->m_SegHeader.mtLoopEnd - pVirtualSegment->m_SegHeader.mtLoopStart)) +
                                            pVirtualSegment->m_SegHeader.mtLength - pVirtualSegment->m_SegHeader.mtPlayStart;
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotSegmentHeader)
                            {
//Trace(0,"Adding VSegment %ls with ID %ld to song.\n",pVirtualSegment->m_wszName,pVirtualSegment->m_dwID);
                                m_VirtualSegmentList.AddTail(pVirtualSegment);
                            }
                            else
                            {
                                delete pVirtualSegment;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

struct ClassGuidCounts
{
    GUID guidClass;
    DWORD dwCount;
};

HRESULT CSong::LoadTrackRefList(CRiffParser *pParser,CVirtualSegment *pVirtualSegment)
{
    RIFFIO ckNext;
    RIFFIO ckChild;

    HRESULT hr = S_OK;
    TList<ClassGuidCounts> GuidCountList;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    CTrack *pTrack;
                    case DMUS_FOURCC_TRACKREF_LIST :
                        pTrack = new CTrack;
                        if (pTrack)
                        {
                            TListItem<ClassGuidCounts>* pCountItem = NULL;
                            DMUS_IO_TRACKREF_HEADER ioTrackRef;
                            DMUS_IO_TRACK_HEADER ioTrackHdr;
                            DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
                            ioTrackExtrasHdr.dwPriority = 0;
                            ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
                            ioTrackHdr.dwPosition = 0;
                            BOOL fGotHeader = FALSE;
                            BOOL fGotRef = FALSE;
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case DMUS_FOURCC_TRACKREF_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackRef, sizeof(ioTrackRef));
                                        fGotRef = SUCCEEDED(hr);
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackHdr, sizeof(ioTrackHdr));
                                        fGotHeader = SUCCEEDED(hr);
                                        pTrack->m_guidClassID = ioTrackHdr.guidClassID;
                                        pTrack->m_dwGroupBits = ioTrackHdr.dwGroup;
                                        pTrack->m_dwPosition = ioTrackHdr.dwPosition;
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_EXTRAS_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackExtrasHdr, sizeof(ioTrackExtrasHdr));
                                        pTrack->m_dwPriority = ioTrackExtrasHdr.dwPriority;
                                        pTrack->m_dwFlags = ioTrackExtrasHdr.dwFlags;
                                        break;

                                    }
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotRef)
                            {
                                if (ioTrackRef.dwSegmentID != DMUS_SONG_NOSEG)
                                {
                                    DWORD dwID = 0;
                                    for (pCountItem = GuidCountList.GetHead(); pCountItem; pCountItem = pCountItem->GetNext())
                                    {
                                        if (pCountItem->GetItemValue().guidClass == pTrack->m_guidClassID)
                                        {
                                            break;
                                        }
                                    }
                                    if (pCountItem)
                                    {
                                        dwID = pCountItem->GetItemValue().dwCount;
                                    }
                                    fGotHeader = GetSegmentTrack(&pTrack->m_pTrack,ioTrackRef.dwSegmentID,pTrack->m_dwGroupBits,dwID,pTrack->m_guidClassID);
                                }
                            }
                            if (fGotHeader && pTrack->m_pTrack)
                            {
                                pTrack->m_pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pTrack->m_pTrack8);
                                // Add the track based on position.
                                CTrack* pScan = pVirtualSegment->m_TrackList.GetHead();
                                CTrack* pPrevTrack = NULL;
                                for (; pScan; pScan = pScan->GetNext())
                                {
                                    if (pTrack->Less(pScan))
                                    {
                                        break;
                                    }
                                    pPrevTrack = pScan;
                                }
                                if (pPrevTrack)
                                {
                                    pPrevTrack->SetNext(pTrack);
                                    pTrack->SetNext(pScan);
                                }
                                else
                                {
                                    pVirtualSegment->m_TrackList.AddHead( pTrack );
                                }
                                if (pCountItem)
                                {
                                    pCountItem->GetItemValue().dwCount++;
                                }
                                else
                                {
                                    TListItem<ClassGuidCounts>* pNew = new TListItem<ClassGuidCounts>;
                                    if (pNew)
                                    {
                                        pNew->GetItemValue().dwCount = 1;
                                        pNew->GetItemValue().guidClass = pTrack->m_guidClassID;
                                        GuidCountList.AddHead(pNew);
                                    }
                                    else return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                delete pTrack;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;

                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSong::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSong::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicSong;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CSong::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::SetDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: Song::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CSong::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CSong::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::ParseDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_SONG_FORM))
    {
        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicSong;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    else
    {
        // Couldn't find the chunk header for a song.
        // But, maybe this is actually a segment, in which case see if
        // the segment object will parse it.
        CSegment *pSegment = new CSegment;
        if (pSegment)
        {
            pSegment->AddRef(); // just to be safe...
            // Force the version so audiopath functionality will be supported.
            pSegment->m_dwVersion = 8;
            Parser.SeekBack();
            hr = pSegment->ParseDescriptor(pIStream,pDesc);
            pDesc->guidClass = CLSID_DirectMusicSong;
            // Done with the segment, say bye bye.
            delete pSegment;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

ComposingTrack::ComposingTrack() : m_dwTrackGroup(0), m_dwPriority(0)
{
    memset((void*) &m_guidClassID, 0, sizeof(m_guidClassID));
}

ComposingTrack::~ComposingTrack()
{
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (rComponent.pVirtualSegment && rComponent.pVirtualSegment->m_pPlaySegment)
        {
            rComponent.pVirtualSegment->m_pPlaySegment->Release();
        }
        if (rComponent.pComposingTrack && rComponent.pComposingTrack->m_pTrack8)
        {
            rComponent.pComposingTrack->m_pTrack8->Release();
        }
    }
}

HRESULT ComposingTrack::AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack)
{
    HRESULT hr = S_OK;
    if (!pVirtualSegment || !pVirtualSegment->m_pPlaySegment || !pTrack || !pTrack->m_pTrack8)
    {
        Trace(1,"Error: Unable to compose song because of a required segment or track is missing.\n");
        return E_INVALIDARG;
    }
    TListItem<CompositionComponent>* pComponent = new TListItem<CompositionComponent>;
    if (!pComponent)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pVirtualSegment->m_pPlaySegment->AddRef();
        pTrack->m_pTrack8->AddRef();
        CompositionComponent& rComponent = pComponent->GetItemValue();
        rComponent.pVirtualSegment = pVirtualSegment;
        rComponent.pComposingTrack = pTrack;
        rComponent.mtTime = pVirtualSegment->m_mtTime;
        m_Components.AddHead(pComponent);
    }
    return hr;
}

BOOL Less(CompositionComponent& Comp1, CompositionComponent& Comp2)
{
    return Comp1.mtTime < Comp2.mtTime;
}

// Compose does the joining, composing, successive splitting, and adding to segments
HRESULT ComposingTrack::Compose(IDirectMusicSong* pSong)
{
    HRESULT hr = S_OK;
    IDirectMusicTrack8* pMasterTrack = NULL;
    IDirectMusicTrack8* pComposedTrack = NULL;
    m_Components.MergeSort(Less);
    // Join the tracks together according to the ordering of their associated segments.
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (!pMasterTrack)
        {
            //MUSIC_TIME mtEnd = 0;
            //if (pComponent->GetNext())
            //{
            //  mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
            //}
            //else
            //{
            //  rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtEnd);
            //}
            //hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, mtEnd, (IDirectMusicTrack**)&pMasterTrack);
            hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, 0, (IDirectMusicTrack**)&pMasterTrack);
        }
        //else
        if (SUCCEEDED(hr))
        {
            hr = pMasterTrack->Join(rComponent.pComposingTrack->m_pTrack8, rComponent.mtTime, pSong, m_dwTrackGroup, NULL);
        }
        if (FAILED(hr)) break;
    }

    // Call Compose on the joined track.
    if (SUCCEEDED(hr))
    {
        hr = pMasterTrack->Compose(pSong, m_dwTrackGroup, (IDirectMusicTrack**)&pComposedTrack);
    }

    // Split the composed result according to the original segments.
    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtStart = 0;
        MUSIC_TIME mtEnd = 0;
        pComponent = m_Components.GetHead();
        for (; pComponent; pComponent = pComponent->GetNext())
        {
            CompositionComponent& rComponent = pComponent->GetItemValue();
            mtStart = rComponent.mtTime;
            // only split off a composed track if the original segment contained a composing track
            IDirectMusicTrack* pOldTrack = NULL;
            IPersistStream* pPersist = NULL;
            GUID guidClassId;
            memset(&guidClassId, 0, sizeof(guidClassId));
            if (SUCCEEDED(pMasterTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) &&
                SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) )  )
            {
                pPersist->Release();
                pOldTrack->Release();
                if (pComponent->GetNext())
                {
                    mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
                }
                else
                {
                    MUSIC_TIME mtLength = 0;
                    rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtLength);
                    mtEnd = mtStart + mtLength;
                }
                IDirectMusicTrack8* pComposedFragment = NULL;
                hr = pComposedTrack->Clone(mtStart, mtEnd, (IDirectMusicTrack**)&pComposedFragment);
                if (SUCCEEDED(hr))
                {
                    // Remove any tracks of this type (in the same group) from the segment.
                    pOldTrack = NULL;
                    pPersist = NULL;
                    memset(&guidClassId, 0, sizeof(guidClassId));
                    if (SUCCEEDED(pComposedFragment->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
                    {
                        if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                            SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) ) )
                        {
                            rComponent.pVirtualSegment->m_pPlaySegment->RemoveTrack( pOldTrack );
                            pOldTrack->Release();
                        }
                        pPersist->Release();
                    }
                    hr = rComponent.pVirtualSegment->m_pPlaySegment->InsertTrack(pComposedFragment, m_dwTrackGroup);
                    pComposedFragment->Release(); // release from the Clone
                }

                if (FAILED(hr)) break;
            }
            else // the QI to pPersist might have succeeded, so clean it up
            {
                if (pPersist) pPersist->Release();
            }
        }
        if (pComposedTrack) pComposedTrack->Release();
    }

    if (pMasterTrack) pMasterTrack->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\sysextrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SysExTrk.h : Declaration of the CSysExTrk

#ifndef __SYSEXTRK_H_
#define __SYSEXTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

// FullSysexEvent is DMUS_IO_SYSEX_ITEM plus data pointer
struct FullSysexEvent : DMUS_IO_SYSEX_ITEM
{
	BYTE* pbSysExData;
};

class SysExListItem : public AListItem
{
public:
	SysExListItem()
	{
		m_pItem = NULL;
	};

	HRESULT SetItem( FullSysexEvent item )
	{
		if( m_pItem )
		{
			delete [] m_pItem->pbSysExData;
		}
		else
		{
			m_pItem = new FullSysexEvent;
		}
		if( m_pItem )
		{
			m_pItem->mtTime = item.mtTime;
			m_pItem->dwSysExLength = item.dwSysExLength;
			m_pItem->pbSysExData = item.pbSysExData;
			return S_OK;
		}
		else
		{
			return E_OUTOFMEMORY;
		}
	};

	~SysExListItem()
	{
		if( m_pItem )
		{
			if( m_pItem->pbSysExData )
			{
				delete [] m_pItem->pbSysExData;
			}
			delete m_pItem;
		}
	};

	SysExListItem* GetNext()
	{
		return (SysExListItem*)AListItem::GetNext();
	};
public:
	FullSysexEvent* m_pItem;
};

class SysExList : public AList
{
public:
	~SysExList()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

	void DeleteAll()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

    SysExListItem* GetHead() 
	{
		return (SysExListItem*)AList::GetHead();
	};
};

struct SysExStateData
{
	SysExListItem*				pCurrentSysEx;
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	DWORD						dwValidate;
	MUSIC_TIME					mtPrevEnd;

	SysExStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CSysExTrk
class CSysExTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSysExTrack();
	CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSysExTrack();

// ISysExTrk
public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT Seek(void *pStateData,MUSIC_TIME mtTime);
    HRESULT Play(void *pStateData,MUSIC_TIME mtStart,MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,REFERENCE_TIME rtOffset,DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,BOOL fClockTime);
	void Construct(void);

// private member variables
protected:
	SysExList	m_SysExEventList;
	long	m_cRef;
	DWORD	m_dwValidate;
	CRITICAL_SECTION m_CrSec;
    BOOL    m_fCSInitialized;
};

#endif //__SYSEXTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\template.h ===
// Copyright (c) 1998 Microsoft Corporation
// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__

#include <windows.h>

template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\tempotrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// TempoTrk.cpp : Implementation of CTempoTrack
#include "dmime.h"
#include "TempoTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "dmperf.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT  assert

/////////////////////////////////////////////////////////////////////////////
// CTempoTrack

void CTempoTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_cRef = 1;
    m_dwValidate = 0;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CTempoTrack::CTempoTrack()
{
    Construct();
    m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTempoTrack::CTempoTrack(
        const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    m_fActive = rTrack.m_fActive;
    m_fStateSetBySetParam = rTrack.m_fStateSetBySetParam;
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = rTrack.m_TempoEventList.GetHead();
    //1////////////////////////////////////////
    TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
    //1////////////////////////////////////////
    for(; pScan; pScan = pScan->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
        //2////////////////////////////////////////
        if (rScan.lTime < mtStart)
        {
            pPrevious = pScan;
        }
        //2////////////////////////////////////////
        else if (rScan.lTime < mtEnd)
        {
            //3////////////////////////////////////////
            if (rScan.lTime == mtStart)
            {
                pPrevious = NULL;
            }
            //3////////////////////////////////////////
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
            if (pNew)
            {
                DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
                memcpy( &rNew, &rScan, sizeof(DMUS_IO_TEMPO_ITEM) );
                rNew.lTime = rScan.lTime - mtStart;
                m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
            }
        }
        else break;
    }
    m_TempoEventList.Reverse(); // for above AddHead.
    //4////////////////////////////////////////
    if (pPrevious)
    {
        DMUS_IO_TEMPO_ITEM& rPrevious = pPrevious->GetItemValue();
        TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
        if (pNew)
        {
            DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
            memcpy( &rNew, &rPrevious, sizeof(DMUS_IO_TEMPO_ITEM) );
            rNew.lTime = 0;
            m_TempoEventList.AddHead(pNew);
        }
    }
    //4////////////////////////////////////////
}

CTempoTrack::~CTempoTrack()
{
    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_CrSec);
    }
    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTempoTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTempoTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CTempoTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    } else
    if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Tempo Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | Release | Standard Release implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTempoTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CTempoTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicTempoTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTempoTrack::IsDirty()
{
    return S_FALSE;
}

/*

  @method HRESULT | ITempoTrack | Load |
  Call this with an IStream filled with DMUS_IO_TEMPO_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TEMPO_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain Tempo events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TempoTrack is released.
*/
HRESULT CTempoTrack::Load( IStream* pIStream )
{
    V_INAME(CTempoTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    if( m_TempoEventList.GetHead() )
    {
        TListItem<DMUS_IO_TEMPO_ITEM>* pItem;
        while( pItem = m_TempoEventList.RemoveHead() )
        {
            delete pItem;
        }
    }

    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_TEMPO_ITEM tempoEvent;
    // read in the chunk id
    DWORD dwChunk, dwSubSize;
    long lSize;
    pIStream->Read( &dwChunk, sizeof(DWORD), NULL );
    if( dwChunk != DMUS_FOURCC_TEMPO_TRACK )
    {
        Trace(1,"Error: Invalid data in tempo track.\n");
        LeaveCriticalSection(&m_CrSec);
        return DMUS_E_CHUNKNOTFOUND;
    }
    // read in the overall size
    pIStream->Read( &lSize, sizeof(long), NULL );
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        // Check to make sure our reads are succeeding (we can safely
        // assume the previous reads worked if we got this far.)
        Trace(1,"Error: Unable to read tempo track.\n");
        LeaveCriticalSection(&m_CrSec);
        return DMUS_E_CANNOTREAD;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_TEMPO_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_TEMPO_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( dwRead )
    {
        while( lSize > 0 )
        {
            if( FAILED( pIStream->Read( &tempoEvent, dwRead, NULL )))
            {
                Trace(1,"Error: Failure reading tempo track.\n");
                hr = DMUS_E_CANNOTREAD;
                break;
            }
            lSize -= dwRead;
            if( dwSeek )
            {
                if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
                {
                    Trace(1,"Error: Failure reading tempo track.\n");
                    hr = DMUS_E_CANNOTSEEK;
                    break;
                }                                             
                lSize -= dwSeek;
            }
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = 
                new TListItem<DMUS_IO_TEMPO_ITEM>(tempoEvent);
            if (pNew)
            {
                m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
            }
        }
        m_TempoEventList.Reverse();
    }
    else
    {
        Trace(1,"Error: Failure reading tempo track.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CTempoTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
HRESULT STDMETHODCALLTYPE CTempoTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
    V_INAME(IDirectMusicTrack::IsParamSupported);
    V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
        if( m_fActive )
        {
            if( rguid == GUID_DisableTempo ) return S_OK;
            if( rguid == GUID_TempoParam ) return S_OK;
            if( rguid == GUID_PrivateTempoParam ) return S_OK;
            if( rguid == GUID_EnableTempo ) return DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( rguid == GUID_EnableTempo ) return S_OK;
            if( rguid == GUID_DisableTempo ) return DMUS_E_TYPE_DISABLED;
            if( rguid == GUID_PrivateTempoParam ) return DMUS_E_TYPE_DISABLED;
            if( rguid == GUID_TempoParam ) return DMUS_E_TYPE_DISABLED;
        }
    }
    else
    {
        if(( rguid == GUID_DisableTempo ) ||
            ( rguid == GUID_TempoParam ) ||
            ( rguid == GUID_PrivateTempoParam ) ||
            ( rguid == GUID_EnableTempo )) return S_OK;
    }

    return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTempoTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
    return S_OK;
}

HRESULT CTempoTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    TempoStateData* pStateData;
    pStateData = new TempoStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->fActive = m_fActive;
    }
    else
    {
        pStateData->fActive = ((dwFlags & DMUS_SEGF_CONTROL) ||
            !(dwFlags & DMUS_SEGF_SECONDARY));
    }
    pStateData->dwVirtualTrackID = dwTrackID;
    pStateData->pPerformance = pPerformance; // weak reference, no addref.
    pStateData->pSegState = pSegmentState; // weak reference, no addref.
    pStateData->pCurrentTempo = m_TempoEventList.GetHead();
    pStateData->dwValidate = m_dwValidate;
    return S_OK;
}

HRESULT CTempoTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(TempoStateData));
        TempoStateData* pSD = (TempoStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

STDMETHODIMP CTempoTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTempoTrack::Play( 
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    DWORD dwFlags,  
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,   
    DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::Play( 
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,      
    IDirectMusicPerformance* pPerf, 
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT hr = DMUS_S_END;
    IDirectMusicGraph* pGraph = NULL;
    TempoStateData* pSD = (TempoStateData*)pStateData;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

    // if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
    // send out any negative time events. So, we'll set mtStart to -768.
    if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
    {
        mtStart = -768;
    }

    // if pSD->pCurrentTempo is NULL, and we're in a normal Play call (dwFlags is 0)
    // this means that we either have no events, or we got to the end of the event
    // list previously. So, it's safe to just return.
    if( (pSD->pCurrentTempo == NULL) && (dwFlags == 0) )
    {
        return S_FALSE;
    }

    if( pSD->dwValidate != m_dwValidate )
    {
        pSD->dwValidate = m_dwValidate;
        pSD->pCurrentTempo = NULL;
    }
    if (!pSD->pCurrentTempo)
    {
        pSD->pCurrentTempo = m_TempoEventList.GetHead();
    }
    if (!pSD->pCurrentTempo)
    {
        return DMUS_S_END;
    }
    // if the previous end time isn't the same as the current start time,
    // we need to seek to the right position.
    if( fSeek || ( pSD->mtPrevEnd != mtStart ))
    {
        TempoStateData tempData;
        BOOL fFlag = TRUE;
        tempData = *pSD; // put this in so we can use Seek in other functions such as GetParam
        if( !fSeek && (dwFlags & DMUS_TRACKF_DIRTY ))
        {
            fFlag = FALSE;
        }
        Seek( &tempData, mtStart, fFlag );
        *pSD = tempData;
    }
    pSD->mtPrevEnd = mtEnd;

    if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    for (; pSD->pCurrentTempo; pSD->pCurrentTempo = pSD->pCurrentTempo->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rTempoEvent = pSD->pCurrentTempo->GetItemValue();
        if( rTempoEvent.lTime >= mtEnd )
        {
            // this time is in the future. Return now to retain the same
            // seek pointers for next time.
            hr = S_OK;
            break;
        }
        if( rTempoEvent.lTime < mtStart )
        {
            if( dwFlags & DMUS_TRACKF_FLUSH )
            {
                // this time is in the past, and this call to Play is in response to an
                // invalidate. We don't want to replay stuff before the start time.
                continue;
            }
            else if( !( dwFlags & DMUS_TRACKF_START) && !(dwFlags & DMUS_TRACKF_SEEK) )
            {
                // we really only want to play events earlier than mtStart on account
                // of a START or SEEK (that isn't a FLUSH.)
                continue;
            }
        }
        if( pSD->fActive )
        {
            DMUS_TEMPO_PMSG* pTempo;
            if( SUCCEEDED( pSD->pPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
                (DMUS_PMSG**)&pTempo )))
            {
                if( rTempoEvent.lTime < mtStart )
                {
                    // this only happens in the case where we've puposefully seeked
                    // and need to time stamp this event with the start time
                    if (fClockTime)
                    {
                        pTempo->rtTime = (mtStart * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pTempo->mtTime = mtStart + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
                }
                else
                {
                    if (fClockTime)
                    {
                        pTempo->rtTime = (rTempoEvent.lTime  * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pTempo->mtTime = rTempoEvent.lTime + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
                }
                pTempo->dblTempo = rTempoEvent.dblTempo;
                pTempo->dwVirtualTrackID = pSD->dwVirtualTrackID;
                pTempo->dwType = DMUS_PMSGT_TEMPO;
                pTempo->dwGroupID = 0xffffffff;
                if( pGraph )
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pTempo );
                }
                if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pTempo )))
                {
                    pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pTempo );
                }
            }
        }
    }
    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// if fGetPrevious is TRUE, seek to the event prior to mtTime. Otherwise, seek to
// the event on or after mtTime
HRESULT CTempoTrack::Seek( 
    /* [in] */ TempoStateData *pSD,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pSD->pCurrentTempo;
    if (!pScan)
    {
        pScan = m_TempoEventList.GetHead();
    }
    if (!pScan)
    {
        return S_FALSE;
    }
    // if the event's time is on or past mtTime, we need to go to the beginning
    if (pScan->GetItemValue().lTime >= mtTime)
    {
        pScan = m_TempoEventList.GetHead();
    }
    pSD->pCurrentTempo = pScan;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (pScan->GetItemValue().lTime >= mtTime)
        {
            if (!fGetPrevious)
            {
                pSD->pCurrentTempo = pScan;
            }
            break;
        }
        pSD->pCurrentTempo = pScan;
    }
    return S_OK;
}

STDMETHODIMP CTempoTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CTempoTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{    
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}


HRESULT CTempoTrack::GetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(IDirectMusicTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rguid);

    HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    if( NULL == pData )
    {
        return E_POINTER;
    }
    if( rguid == GUID_PrivateTempoParam )
    {
        DMUS_TEMPO_PARAM TempoData;
        PrivateTempo* pPrivateTempoData = (PrivateTempo*)pData;
        hr = GetParam(GUID_TempoParam, mtTime, pmtNext, (void*)&TempoData);
        if (hr == S_OK)
        {
            pPrivateTempoData->dblTempo = TempoData.dblTempo;
            pPrivateTempoData->mtTime = 0; // must be set by the caller
            pPrivateTempoData->mtDelta = TempoData.mtTime;
            pPrivateTempoData->fLast = (pmtNext && !*pmtNext);
        }
        else if (hr == DMUS_E_NOT_FOUND) // the tempo track was empty
        {
            pPrivateTempoData->fLast = true;
        }
    }
    else if( rguid == GUID_TempoParam )
    {
        if( !m_fActive )
        {
            return DMUS_E_TYPE_DISABLED;
        }
        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
        TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
        TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = pScan;
        if (!pScan)
        {
            return DMUS_E_NOT_FOUND;
        }
        for (; pScan; pScan = pScan->GetNext())
        {
            if (pScan->GetItemValue().lTime > mtTime)
            {
                break;
            }
            pPrevious = pScan;
        }
        DMUS_IO_TEMPO_ITEM& rTempoEvent = pPrevious->GetItemValue();
        pTempoData->dblTempo = rTempoEvent.dblTempo;
        pTempoData->mtTime = rTempoEvent.lTime - mtTime;
        if (pmtNext)
        {
            *pmtNext = 0;
        }
        if (pScan)
        {
            DMUS_IO_TEMPO_ITEM& rNextTempoEvent = pScan->GetItemValue();
            if (pmtNext)
            {
                *pmtNext = rNextTempoEvent.lTime - mtTime;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// Q: if all tracks are time-stamped, why do we need mtTime?
HRESULT CTempoTrack::SetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
    V_INAME(IDirectMusicTrack::SetParam);
    V_REFGUID(rguid);

    EnterCriticalSection(&m_CrSec);

    HRESULT hr = DMUS_E_SET_UNSUPPORTED;

    if( rguid == GUID_DisableTempo )
    {
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_EnableTempo )
    {
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_TempoParam )
    {
        if (!m_fActive)
        {   // Oops, app intentionally disabled tempo.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( NULL == pData )
            {
                LeaveCriticalSection(&m_CrSec);
                return E_POINTER;
            }
            DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
            TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
            TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
            for (; pScan; pScan = pScan->GetNext())
            {
                if (pScan->GetItemValue().lTime >= mtTime)
                {
                    break;
                }
                pPrevious = pScan;
            }
            // Make a new DMUS_IO_TEMPO_ITEM and insert it after pPrevious
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
            if (!pNew)
            {
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
            DMUS_IO_TEMPO_ITEM& rTempoEvent = pNew->GetItemValue();
            rTempoEvent.dblTempo = pTempoData->dblTempo;
            /*
            // I believe the fix for 204160 was supposed to change this line to what 
            // follows the comment.  RSW
            rTempoEvent.lTime = pTempoData->mtTime;
            */
            rTempoEvent.lTime = mtTime;
            if (pPrevious)
            {
                pNew->SetNext(pScan);
                pPrevious->SetNext(pNew);
            }
            else
            {
                m_TempoEventList.AddHead(pNew);
            }
            if (pScan && pScan->GetItemValue().lTime == mtTime)
            {
                // remove it
                pNew->SetNext(pScan->GetNext());
                pScan->SetNext(NULL);
                delete pScan;
            }
            m_dwValidate++;
            hr = S_OK;
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::AddNotificationType(
    /* [in] */  REFGUID rguidNotification)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::RemoveNotificationType(
    /* [in] */  REFGUID rguidNotification)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);

    CTempoTrack *pDM;
    
    try
    {
        pDM = new CTempoTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }


    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    return hr;
}

STDMETHODIMP CTempoTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CTempoTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CTempoTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    CTempoTrack* pOtherTrack = (CTempoTrack*)pNewTrack;
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pOtherTrack->m_TempoEventList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
        TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
        if (pNew)
        {
            DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
            rNew.lTime = rScan.lTime + mtJoin;
            rNew.dblTempo = rScan.dblTempo;
            m_TempoEventList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\trklist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// TrkList.h

#include "alist.h"
#include "dmusici.h"
#include "debug.h"
#define ASSERT	assert

#ifndef __TRACKLIST_H_
#define __TRACKLIST_H_

#define TRACKINTERNAL_START_PADDED 0x1
#define TRACKINTERNAL_END_PADDED 0x2

class CSegment;

class CTrack : public AListItem
{
public:
	CTrack();
	~CTrack();
	CTrack* GetNext()
	{
		return (CTrack*)AListItem::GetNext();
	};
    bool Less(CTrack* pCTrack)
    {
        // Give the sysex track priority over any other track at the same position,
        // and the band track priority over any track but the sysex track. 
        return
            ( m_dwPosition < pCTrack->m_dwPosition ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicSysExTrack) ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicBandTrack &&
               pCTrack->m_guidClassID != CLSID_DirectMusicSysExTrack) );
    }
public:
    CLSID               m_guidClassID;  // Class ID of track.
	IDirectMusicTrack*	m_pTrack;       // Standard track interface.
    IDirectMusicTrack8* m_pTrack8;      // Extra DX8 functions.
    void*				m_pTrackState; // state pointer returned by IDirectMusicTrack::InitPerformance
	BOOL				m_bDone;
	DWORD				m_dwVirtualID; // only valid inside segment states
	DWORD				m_dwGroupBits;
    DWORD               m_dwPriority;  // Track priority, to order the composition process.
    DWORD               m_dwPosition;  // Track position, to determine the Play order.
    DWORD               m_dwFlags;     // DMUS_TRACKCONFIG_ flags. 
    DWORD               m_dwInternalFlags;     // TRACKINTERNAL_ flags. 
};

class CTrackList : public AList
{
public:
    CTrack* GetHead() 
	{
		return (CTrack*)AList::GetHead();
	};
    CTrack* RemoveHead() 
	{
		return (CTrack*)AList::RemoveHead();
	};
    CTrack* GetItem(LONG lIndex) 
	{
		return (CTrack*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CTrack* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
	HRESULT CreateCopyWithBlankState(CTrackList* pTrackList);
};

#endif // __TRACKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\trackhelp.cpp ===
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CBasicTrack.
//

#include "trackhelp.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Creation

CBasicTrack::CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid)
  : m_cRef(0),
    m_plModuleLockCounter(plModuleLockCounter),
    m_rclsid(rclsid)
{
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    InterlockedIncrement(plModuleLockCounter);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CBasicTrack::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBasicTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    else if (iid == IID_IPersistStream)
        *ppv = static_cast<IPersistStream*>(this);
    else if (iid == IID_IPersist)
        *ppv = static_cast<IPersist*>(this);
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CBasicTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CBasicTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        DeleteCriticalSection(&m_CriticalSection);
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CBasicTrack::GetClassID(CLSID* pClassID)
{
    V_INAME(CBasicTrack::GetClassID);
    V_PTR_WRITE(pClassID, sizeof(pClassID));
    *pClassID = m_rclsid;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CBasicTrack::Init(IDirectMusicSegment *pSegment)
{
    V_INAME(CBasicTrack::Init);
    V_INTERFACE(pSegment);
    return S_OK;
}

STDMETHODIMP
CBasicTrack::Play(
        void *pStateData,
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID)
{
    return this->PlayMusicOrClock(
                    pStateData,
                    mtStart,
                    mtEnd,
                    mtOffset,
                    0,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    false);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8

STDMETHODIMP CBasicTrack::PlayEx(
        void* pStateData,
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtEnd,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID)
{
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times and then just use them as if this were MUSIC_TIME.
        return this->PlayMusicOrClock(
                    pStateData,
                    static_cast<MUSIC_TIME>(rtStart / gc_RefPerMil),
                    static_cast<MUSIC_TIME>(rtEnd / gc_RefPerMil),
                    static_cast<MUSIC_TIME>(rtOffset / gc_RefPerMil),
                    rtOffset,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    true);
    }
    else
    {
        return this->PlayMusicOrClock(
                    pStateData,
                    static_cast<MUSIC_TIME>(rtStart),
                    static_cast<MUSIC_TIME>(rtEnd),
                    static_cast<MUSIC_TIME>(rtOffset),
                    0,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    false);
    }
}

STDMETHODIMP CBasicTrack::GetParamEx(
        REFGUID rguidType,
        REFERENCE_TIME rtTime,
        REFERENCE_TIME* prtNext,
        void* pParam,
        void * pStateData,
        DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime / gc_RefPerMil), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * gc_RefPerMil;
        }
    }
    else
    {
        hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CBasicTrack::SetParamEx(
        REFGUID rguidType,
        REFERENCE_TIME rtTime,
        void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= gc_RefPerMil;
    }
    return SetParam(rguidType, static_cast<MUSIC_TIME>(rtTime ), pParam);
}

STDMETHODIMP CBasicTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasicTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\tsigtrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TSigTrk.h : Declaration of the CTimeSigTrack

#ifndef __TSIGTRK_H_
#define __TSIGTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

class CRiffParser;

class CTimeSigItem : public AListItem
{
public:
    CTimeSigItem();
    CTimeSigItem* GetNext(){ return (CTimeSigItem*)AListItem::GetNext(); };
    DMUS_IO_TIMESIGNATURE_ITEM  m_TimeSig;
};

   
class CTimeSigList : public AList
{
public:
    CTimeSigItem* GetHead() {return (CTimeSigItem*)AList::GetHead();};
    CTimeSigItem* RemoveHead() {return (CTimeSigItem*)AList::RemoveHead();};
    CTimeSigItem* GetItem(LONG lIndex) { return (CTimeSigItem*) AList::GetItem(lIndex);};
};

class CTimeSigStateData
{
public:
    CTimeSigStateData()
	{
		m_mtPrevEnd = 0;
		m_bBeat = 4;
		m_bBeatsPerMeasure = 4;
		m_mtTimeSig = 0;
        m_fActive = TRUE;
		/* don't need these since they are always initialized
		m_pPerformance = NULL;
		m_pSegState = NULL;
		m_dwVirtualTrackID = 0;
		*/
	}
    CTimeSigItem *	            m_pCurrentTSig;
	IDirectMusicPerformance*	m_pPerformance;
	IDirectMusicSegmentState*	m_pSegState;
	DWORD						m_dwVirtualTrackID;
	DWORD						m_dwValidate; // used to validate state data
	MUSIC_TIME					m_mtPrevEnd;
	MUSIC_TIME					m_mtTimeSig; // previous time sig time
    BOOL                        m_fActive;
    BYTE						m_bBeat; // previous beat
	BYTE						m_bBeatsPerMeasure; // previous beats per measure
};

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack
class CTimeSigTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CTimeSigTrack();
	CTimeSigTrack(CTimeSigTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTimeSigTrack();

// member variables
protected:
	CTimeSigList	    m_TSigEventList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL		        m_fNotificationMeasureBeat;
	BOOL		        m_fActive;              // Track is active for generating time signatures
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	HRESULT STDMETHODCALLTYPE Seek( void *pStateData,MUSIC_TIME mtTime,BOOL fGetPrevious);
	void Construct(void);
    void Clear();
    HRESULT LoadTimeSigList( CRiffParser *pParser, long lChunkSize );
protected:
	MUSIC_TIME NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
			CTimeSigStateData* pSD, MUSIC_TIME mtOffset );
};

#endif //__TSIGTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\wavtrack.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// WavTrack.cpp : Implementation of CWavTrack
#include "dmime.h"
#include "dmperf.h"
#include "WavTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#include "..\dswave\dswave.h"
#include "dmsegobj.h"
#define ASSERT  assert
#include <math.h>

// @doc EXTERNAL

TList<TaggedWave> WaveItem::st_WaveList;
CRITICAL_SECTION WaveItem::st_WaveListCritSect;
long CWavTrack::st_RefCount = 0;

BOOL PhysicalLess(WaveItem& WI1, WaveItem& WI2)
{
    return WI1.m_rtTimePhysical < WI2.m_rtTimePhysical;
}

BOOL LogicalLess(WaveItem& WI1, WaveItem& WI2)
{
    return WI1.m_mtTimeLogical < WI2.m_mtTimeLogical;
}

/////////////////////////////////////////////////////////////////////////////
// CWavTrack

void CWavTrack::FlushWaves()
{
    UnloadAllWaves(NULL);
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    while (!WaveItem::st_WaveList.IsEmpty())
    {
        TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.RemoveHead();
        delete pScan;
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
}

HRESULT CWavTrack::UnloadAllWaves(IDirectMusicPerformance* pPerformance)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.GetHead();
    TListItem<TaggedWave>* pNext = NULL;
    for (; pScan; pScan = pNext)
    {
        pNext = pScan->GetNext();
        TaggedWave& rScan = pScan->GetItemValue();
        if (!pPerformance || rScan.m_pPerformance == pPerformance)
        {
            if (rScan.m_pPort)
            {
                if (rScan.m_pDownloadedWave)
                {
                    Trace(1, "Error: Wave was downloaded but never unloaded.\n");
                    rScan.m_pPort->UnloadWave(rScan.m_pDownloadedWave);
                    rScan.m_pDownloadedWave = NULL;
                }
                rScan.m_pPort->Release();
                rScan.m_pPort = NULL;
            }
            if (rScan.m_pPerformance)
            {
                rScan.m_pPerformance->Release();
                rScan.m_pPerformance = NULL;
            }
            if (rScan.m_pWave)
            {
                rScan.m_pWave->Release();
                rScan.m_pWave = NULL;
            }
            WaveItem::st_WaveList.Remove(pScan);
            delete pScan;
        }
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
    return hr;
}

// This SHOULD NOT be called except from a constructor.
void CWavTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;

    m_dwPChannelsUsed = 0;
    m_aPChannels = NULL;
    m_dwTrackFlags = 0;
    m_dwValidate = 0;
    m_cRef = 1;
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    m_fAutoDownload = FALSE;
    m_fLockAutoDownload = FALSE;
    st_RefCount++;
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    m_dwWaveItems = 0;
}

void CWavTrack::CleanUp()
{
    m_dwPChannelsUsed = 0;
    if (m_aPChannels) delete [] m_aPChannels;
    if (m_pdwVariations) delete [] m_pdwVariations;
    if (m_pdwRemoveVariations) delete [] m_pdwRemoveVariations;
    m_aPChannels = NULL;
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WavePartList.CleanUp();
    RemoveDownloads(NULL);
}

void CWavTrack::CleanUpTempParts()
{
    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_TempWavePartList.CleanUp();
}

void CWavTrack::MovePartsToTemp()
{
    CleanUpTempParts();
    TListItem<WavePart>* pScan = m_WavePartList.RemoveHead();
    for (; pScan; pScan = m_WavePartList.RemoveHead() )
    {
        m_TempWavePartList.AddHead(pScan);
    }
}

// NULL for non-streaming waves.
// For streaming waves, return the DownLoadedWave that's associated with the same wave
// with the same start offset (and remove it from the Item list so it's not returned again).
IDirectSoundDownloadedWaveP* CWavTrack::FindDownload(TListItem<WaveItem>* pItem)
{
    if (!pItem || !pItem->GetItemValue().m_pWave || !pItem->GetItemValue().m_fIsStreaming)
    {
        return NULL;
    }

    WaveItem& rWaveItem = pItem->GetItemValue();

    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan ; pScan = pScan->GetNext())
    {
        TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
        TListItem<WaveItem>* pNext = NULL;
        for (; pItemScan; pItemScan = pNext)
        {
            pNext = pItemScan->GetNext();
            WaveItem& rTempItem = pItemScan->GetItemValue();
            if (rTempItem.m_fIsStreaming &&
                rWaveItem.m_pWave == rTempItem.m_pWave &&
                rWaveItem.m_rtStartOffset == rTempItem.m_rtStartOffset)
            {
                IDirectSoundDownloadedWaveP* pReturn = rTempItem.m_pDownloadedWave;
                if (rTempItem.m_pWave)
                {
                    rTempItem.m_pWave->Release();
                    rTempItem.m_pWave = NULL;
                }
                rTempItem.m_pDownloadedWave = NULL;
                pScan->GetItemValue().m_WaveItemList.Remove(pItemScan);
                delete pItemScan;
                return pReturn;
            }
        }
    }
    return NULL;
}

HRESULT CWavTrack::GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice)
{
    HRESULT hr = S_OK;
    TListItem<WaveDLOnPlay>* pNew = NULL;
    if (!pWaveDL || !pStateData) return E_POINTER;

    IDirectSoundDownloadedWaveP* pNewWaveDL = NULL;
    if (rItem.m_fIsStreaming)
    {
        bool fPair = false;
        TListItem<WavePair>* pPair = m_WaveList.GetHead();
        for (; pPair; pPair = pPair->GetNext())
        {
            if (pWaveDL == pPair->GetItemValue().m_pWaveDL)
            {
                if (!pNewWaveDL)
                {
                    // download a new one (to be returned), and put it in the state data's list.
                    if (FAILED(hr = pPortP->DownloadWave( pWave, &pNewWaveDL, rtStartOffset )))
                    {
                        return hr;
                    }
                    pNew = new TListItem<WaveDLOnPlay>;
                    if (!pNew)
                    {
                        pPortP->UnloadWave(pNewWaveDL);
                        return E_OUTOFMEMORY;
                    }
                    pNew->GetItemValue().m_pWaveDL = pNewWaveDL;
                    pNew->GetItemValue().m_pPort = pPortP;
                    pPortP->AddRef();
                    pStateData->m_WaveDLList.AddHead(pNew);
                }
                if (pStateData == pPair->GetItemValue().m_pStateData)
                {
                    fPair = true;
                    break;
                }
            }
        }
        if (!fPair)
        {
            // create one and add it to m_WaveList
            pPair = new TListItem<WavePair>;
            if (!pPair)
            {
                return E_OUTOFMEMORY;
            }
            pPair->GetItemValue().m_pStateData = pStateData;
            pPair->GetItemValue().m_pWaveDL = pWaveDL;
            pWaveDL->AddRef();
            m_WaveList.AddHead(pPair);
        }
    }
    if (SUCCEEDED(hr))
    {
        if (!pNewWaveDL) pNewWaveDL = pWaveDL;
        hr = pPortP->AllocVoice(pNewWaveDL,
            dwMChannel, dwGroup, rtStartOffset,
            rItem.m_dwLoopStart, rItem.m_dwLoopEnd,
            ppVoice);
        if (SUCCEEDED(hr))
        {
            if (pNew)
            {
                pNew->GetItemValue().m_pVoice = *ppVoice;
            }
            else
            {
                if (pStateData->m_apVoice[rItem.m_dwVoiceIndex])
                {
                    pStateData->m_apVoice[rItem.m_dwVoiceIndex]->Release();
                }
                pStateData->m_apVoice[rItem.m_dwVoiceIndex] = *ppVoice;
            }
        }
    }
    return hr;
}

void CWavTrack::RemoveDownloads(WaveStateData* pStateData)
{
    TListItem<WavePair>* pPair = m_WaveList.GetHead();
    TListItem<WavePair>* pNextPair = NULL;
    for (; pPair; pPair = pNextPair)
    {
        pNextPair = pPair->GetNext();
        if (!pStateData || pPair->GetItemValue().m_pStateData == pStateData)
        {
            m_WaveList.Remove(pPair);
            delete pPair;
        }
    }

    if (pStateData)
    {
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!pStateData->m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = pStateData->m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
    }
}

CWavTrack::CWavTrack()
{
    Construct();
}

CWavTrack::CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    CopyParts(rTrack.m_WavePartList, mtStart, mtEnd);
    m_lVolume = rTrack.m_lVolume;
    m_dwTrackFlags = rTrack.m_dwTrackFlags;
}

HRESULT CWavTrack::InitTrack(DWORD dwPChannels)
{
    HRESULT hr = S_OK;

    m_dwPChannelsUsed = dwPChannels;
    m_dwWaveItems = 0;
    if( m_dwPChannelsUsed )
    {
        m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (!m_aPChannels) hr = E_OUTOFMEMORY;
        else if (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL)
        {
            m_pdwVariations = new DWORD[m_dwPChannelsUsed];
            m_pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
            if (!m_pdwVariations || !m_pdwRemoveVariations) hr = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pScan = m_WavePartList.GetHead();
            for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
            {
                m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
                if (m_pdwVariations) m_pdwVariations[dw] = 0;
                if (m_pdwRemoveVariations) m_pdwRemoveVariations[dw] = 0;
                TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
                for (; pItemScan; pItemScan = pItemScan->GetNext())
                {
                    pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
                    m_dwWaveItems++;
                }
            }
        }
        else CleanUp();
    }
    return hr;
}

CWavTrack::~CWavTrack()
{
    if (m_fCSInitialized)
    {
        CleanUpTempParts();
        CleanUp();
        st_RefCount--;
        if (st_RefCount <= 0)
        {
            // if there's still something in the wave list, it means there are waves that
            // haven't been unloaded; but at this point we've gotten rid of all wave tracks,
            // so unload and release everything now.
            UnloadAllWaves(NULL);
            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
            WaveItem::st_WaveList.CleanUp();
            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
        }
        DeleteCriticalSection(&m_CrSec);
    }

    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CWavTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CWavTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IPrivateWaveTrack)
    {
        *ppv = static_cast<IPrivateWaveTrack*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CWavTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CSeqTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicWaveTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CWavTrack::IsDirty()
{
    return S_FALSE;
}

HRESULT CWavTrack::Load( IStream* pIStream )
{
    V_INAME(CWavTrack::Load);
    V_INTERFACE(pIStream);

    DWORD dwSize;
    DWORD dwByteCount;

    // Verify that the stream pointer is non-null
    if( pIStream == NULL )
    {
        Trace(1,"Error: Null stream passed to wave track.\n");
        return E_POINTER;
    }

    IDMStream* pIRiffStream;
    HRESULT hr = E_FAIL;

    // Try and allocate a RIFF stream
    if( FAILED( hr = AllocDirectMusicStream( pIStream, &pIRiffStream ) ) )
    {
        return hr;
    }

    // Variables used when loading the Wave track
    MMCKINFO ckTrack;
    MMCKINFO ckList;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    MovePartsToTemp();
    CleanUp();

    // Interate through every chunk in the stream
    while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == S_OK )
    {
        switch( ckTrack.ckid )
        {
            case FOURCC_LIST:
                switch( ckTrack.fccType )
                {
                    case DMUS_FOURCC_WAVETRACK_LIST:
                        while( pIRiffStream->Descend( &ckList, &ckTrack, 0 ) == S_OK )
                        {
                            switch( ckList.ckid )
                            {
                                case DMUS_FOURCC_WAVETRACK_CHUNK:
                                {
                                    DMUS_IO_WAVE_TRACK_HEADER iTrackHeader;

                                    // Read in the item's header structure
                                    dwSize = min( sizeof( DMUS_IO_WAVE_TRACK_HEADER ), ckList.cksize );
                                    hr = pIStream->Read( &iTrackHeader, dwSize, &dwByteCount );

                                    // Handle any I/O error by returning a failure code
                                    if( FAILED( hr ) ||  dwByteCount != dwSize )
                                    {
                                        if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                                        goto ON_ERROR;
                                    }

                                    m_lVolume = iTrackHeader.lVolume;
                                    m_dwTrackFlags = iTrackHeader.dwFlags;
                                    break;
                                }

                                case FOURCC_LIST:
                                    switch( ckList.fccType )
                                    {
                                        case DMUS_FOURCC_WAVEPART_LIST:
                                        {
                                            TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
                                            if( !pNewPart )
                                            {
                                                hr = E_OUTOFMEMORY;
                                                goto ON_ERROR;
                                            }
                                            hr = pNewPart->GetItemValue().Load( pIRiffStream, &ckList );
                                            if( FAILED ( hr ) )
                                            {
                                                delete pNewPart;
                                                goto ON_ERROR;
                                            }
                                            InsertByAscendingPChannel( pNewPart );
                                            break;
                                        }
                                    }
                                    break;
                            }

                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;
                }
                break;
        }

        pIRiffStream->Ascend( &ckTrack, 0 );
    }
    hr = InitTrack(m_WavePartList.GetCount());
    if (SUCCEEDED(hr))
    {
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (; pScan ; pScan = pScan->GetNext())
        {
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
                pItemScan->GetItemValue().m_pDownloadedWave = FindDownload(pItemScan);
            }
        }
    }
    else CleanUp();

ON_ERROR:
    CleanUpTempParts();
    LeaveCriticalSection(&m_CrSec);
    pIRiffStream->Release();
    return hr;
}

HRESULT CWavTrack::CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WavePart>* pScan = rParts.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        TListItem<WavePart>* pNew = new TListItem<WavePart>;
        if (pNew)
        {
            WavePart& rNew = pNew->GetItemValue();
            rNew.m_dwLockToPart = rScan.m_dwLockToPart;
            rNew.m_dwPChannel = rScan.m_dwPChannel;
            rNew.m_dwIndex = rScan.m_dwIndex;
            rNew.m_dwPChannelFlags = rScan.m_dwPChannelFlags;
            rNew.m_lVolume = rScan.m_lVolume;
            rNew.m_dwVariations = rScan.m_dwVariations;
            if (SUCCEEDED(hr = rNew.CopyItems(rScan.m_WaveItemList, mtStart, mtEnd)))
            {
                m_WavePartList.AddHead(pNew);
            }
            else
            {
                delete pNew;
                break;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WavePartList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

void CWavTrack::InsertByAscendingPChannel( TListItem<WavePart>* pPart )
{
    if (pPart)
    {
        DWORD dwPChannel = pPart->GetItemValue().m_dwPChannel;
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        TListItem<WavePart>* pPrevious = NULL;
        for (; pScan; pScan = pScan->GetNext())
        {
            if (dwPChannel < pScan->GetItemValue().m_dwPChannel)
            {
                break;
            }
            pPrevious = pScan;
        }
        if (pPrevious)
        {
            pPart->SetNext(pScan);
            pPrevious->SetNext(pPart);
        }
        else
        {
            m_WavePartList.AddHead(pPart);
        }
    }
}

HRESULT CWavTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::IsParamSupported(
    REFGUID rguidType)  // @parm The guid identifying the type of data to check.
{
    if(rguidType == GUID_Download ||
       rguidType == GUID_DownloadToAudioPath ||
       rguidType == GUID_UnloadFromAudioPath ||
       rguidType == GUID_Enable_Auto_Download ||
       rguidType == GUID_Disable_Auto_Download ||
       rguidType == GUID_Unload )
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CWavTrack::Init(
    IDirectMusicSegment *pSegment)  // @parm Pointer to the Segment to which this Track belongs.
{
    EnterCriticalSection(&m_CrSec);
    if( m_dwPChannelsUsed && m_aPChannels )
    {
        pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
    }
    CSegment* pCSegment = NULL;
    bool fSortLogical = false;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment, (void**)&pCSegment)))
    {
        DWORD dwGroupBits = 0;
        if (FAILED(pSegment->GetTrackGroup( this, &dwGroupBits )))
        {
            dwGroupBits = 0xffffffff;
        }
        DWORD dwConfig = 0;
        if (SUCCEEDED(pCSegment->GetTrackConfig(CLSID_DirectMusicWaveTrack, dwGroupBits, 0, &dwConfig)))
        {
            if ( !(dwConfig & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) )
            {
                fSortLogical = true;
            }
        }
        pCSegment->Release();
    }
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        if (fSortLogical)
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(LogicalLess);
        }
        else
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(PhysicalLess);
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CWavTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,    // @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf, // @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,     // @parm This method can return state data information here.
    DWORD dwTrackID,        // @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerf);
    HRESULT hr = E_OUTOFMEMORY;
    IDirectMusicSegmentState8 *pSegSt8 = NULL;

    EnterCriticalSection(&m_CrSec);
    WaveStateData* pStateData = new WaveStateData;
    if( NULL == pStateData )
    {
        goto ON_END;
    }

    // Get the audiopath being used by our segment state and save it in our state data.
    hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
    if (SUCCEEDED(hr))
    {
        hr = pSegSt8->GetObjectInPath(
                        0,                          // pchannel doesn't apply
                        DMUS_PATH_AUDIOPATH,        // get the audiopath
                        0,                          // buffer index doesn't apply
                        CLSID_NULL,                 // clsid doesn't apply
                        0,                          // there should be only one audiopath
                        IID_IDirectMusicAudioPath,
                        reinterpret_cast<void**>(&pStateData->m_pAudioPath));

        // If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
        // pAudioPath stays NULL and we'll play our triggered segments on the general performance.
        if (hr == DMUS_E_NOT_FOUND)
            hr = S_OK;

        pSegSt8->Release();
    }

    pStateData->m_pPerformance = pPerf;
    {
        *ppStateData = pStateData;
        StatePair SP(pSegmentState, pStateData);
        TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
        if (!pPair)
        {
            goto ON_END;
        }
        m_StateList.AddHead(pPair);
    }
    SetUpStateCurrentPointers(pStateData);

    // Set up arrays for variations
    if (m_dwPChannelsUsed)
    {
        pStateData->pdwVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwVariations)
        {
            goto ON_END;
        }
        pStateData->pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwRemoveVariations)
        {
            goto ON_END;
        }
        for (DWORD dw = 0; dw < m_dwPChannelsUsed; dw++)
        {
            if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
                 m_pdwVariations &&
                 m_pdwRemoveVariations )
            {
                pStateData->pdwVariations[dw] = m_pdwVariations[dw];
                pStateData->pdwRemoveVariations[dw] = m_pdwRemoveVariations[dw];
            }
            else
            {
                pStateData->pdwVariations[dw] = 0;
                pStateData->pdwRemoveVariations[dw] = 0;
            }
        }
    }

    // need to know the group this track is in, for the mute track GetParam
    IDirectMusicSegment* pSegment;
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
        pSegment->Release();
    }

    // for auditioning variations...
    pStateData->InitVariationInfo(m_dwVariation, m_dwPart, m_dwIndex, m_dwLockID, m_fAudition);
    hr = S_OK;

    BOOL fGlobal; // if the performance has been set with an autodownload preference,
                // use that. otherwise, assume autodownloading is off, unless it has
                // been locked (i.e. specified on the band track.)
    if( SUCCEEDED( pPerf->GetGlobalParam( GUID_PerfAutoDownload, &fGlobal, sizeof(BOOL) )))
    {
        if( !m_fLockAutoDownload )
        {
            // it might seem like we can just assign m_fAutoDownload = fGlobal,
            // but that's bitten markburt before, so I'm being paranoid today.
            if( fGlobal )
            {
                m_fAutoDownload = TRUE;
            }
            else
            {
                m_fAutoDownload = FALSE;
            }
        }
    }
    else if( !m_fLockAutoDownload )
    {
        m_fAutoDownload = FALSE;
    }
    // Call SetParam to download all waves used by the track
    // This is the auto-download feature that can be turned off with a call to SetParam
    if(m_fAutoDownload)
    {
        hr = SetParam(GUID_Download, 0, (void *)pPerf);
        if (FAILED(hr)) goto ON_END;
    }

    ///////////////// pre-allocate voices for all waves in the track ////////////////
    pStateData->m_dwVoices = m_dwWaveItems;
    pStateData->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
    if (!pStateData->m_apVoice)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
        {
            pStateData->m_apVoice[dw] = NULL;
        }
        Seek( pSegmentState, pPerf, dwTrackID, pStateData, 0, TRUE, 0, FALSE );
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        DWORD dwPChannel = 0;
        for( DWORD dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            long lPartVolume = 0;
            if( pPart )
            {
                WavePart& rPart = pPart->GetItemValue();
                dwPChannel = rPart.m_dwPChannel;
                lPartVolume = rPart.m_lVolume;
            }
            if( pStateData->apCurrentWave )
            {
                for( ; pStateData->apCurrentWave[dwIndex];
                    pStateData->apCurrentWave[dwIndex] = pStateData->apCurrentWave[dwIndex]->GetNext() )
                {
                    WaveItem& rItem = pStateData->apCurrentWave[dwIndex]->GetItemValue();
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    hr = rItem.PChannelInfo(pPerf, pStateData->m_pAudioPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave &&
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                if (rItem.m_dwVoiceIndex == 0xffffffff)
                                {
                                    hr = DMUS_E_NOT_INIT;
                                    TraceI(0, "Voice index not initialized!\n");
                                }
                                else if(!rItem.m_fIsStreaming || (rItem.m_fIsStreaming && rItem.m_fUseNoPreRoll == FALSE))
                                {
                                    IDirectMusicVoiceP *pVoice = NULL;
                                    hr = GetDownload(
                                        rDLWave.m_pDownloadedWave,
                                        pStateData,
                                        pPortP,
                                        rDLWave.m_pWave,
                                        rtStartOffset,
                                        rItem,
                                        dwMChannel, dwGroup,
                                        &pVoice);
                                }
                            }
                            else
                            {
                                hr = DMUS_E_NOT_INIT;
                                Trace(1, "Error: Attempt to play wave that has not been downloaded.\n");

                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                            // Release the private interface
                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
            }
            if( pPart )
            {
                pPart = pPart->GetNext();
            }
        }
    }

ON_END:
    if (FAILED(hr) && pStateData)
    {
        delete pStateData;
        pStateData = NULL;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CWavTrack::EndPlay(
    void *pStateData)   // @parm The state data returned from <om .InitPlay>.
{
    EnterCriticalSection(&m_CrSec);

    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(WaveStateData));
        WaveStateData* pSD = (WaveStateData*)pStateData;
        RemoveDownloads(pSD);
        if(m_fAutoDownload)
        {
            SetParam(GUID_Unload, 0, (void *)pSD->m_pPerformance);
        }
        for (TListItem<StatePair>* pScan = m_StateList.GetHead(); pScan; pScan = pScan->GetNext())
        {
            StatePair& rPair = pScan->GetItemValue();
            if (pSD == rPair.m_pStateData)
            {
                rPair.m_pSegState = NULL;
                rPair.m_pStateData = NULL;
                break;
            }
        }
        delete pSD;
    }

    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

void CWavTrack::SetUpStateCurrentPointers(WaveStateData* pStateData)
{
    ASSERT(pStateData);
    pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        if( pStateData->apCurrentWave )
        {
            delete [] pStateData->apCurrentWave;
            pStateData->apCurrentWave = NULL;
        }
        pStateData->apCurrentWave = new TListItem<WaveItem>* [m_dwPChannelsUsed];
        if( pStateData->apCurrentWave )
        {
            memset( pStateData->apCurrentWave, 0, sizeof(TListItem<WavePart>*) * m_dwPChannelsUsed );
        }
    }
    pStateData->dwValidate = m_dwValidate;
}

REFERENCE_TIME ConvertOffset(REFERENCE_TIME rtOffset, long lPitch)
{
    if (lPitch)
    {
        double dblPitch = (double) lPitch;
        double dblStart = (double) rtOffset;
        dblStart *= pow(2, (dblPitch / 1200.0));
        rtOffset = (REFERENCE_TIME) dblStart;
    }
    return rtOffset;
}

STDMETHODIMP CWavTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    BOOL fClock = (dwFlags & DMUS_TRACKF_CLOCK) ? TRUE : FALSE;
/*    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else*/
    {
        hr = Play(pStateData, rtStart, rtEnd, rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, fClock);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CWavTrack::Play(
    void *pStateData,   // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart, // @parm The start time to play.
    MUSIC_TIME mtEnd,   // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,      // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf, // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,   // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID   // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT hr = Play(pStateData, mtStart, mtEnd, mtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode.
*/

// BUGBUG go through all the times and make sure music time/reference time stuff
// all makes sense

HRESULT CWavTrack::Play(
    void *pStateData,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtEnd,
    //MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT hr = S_OK;
    IDirectMusicGraph* pGraph = NULL;
    WaveStateData* pSD = (WaveStateData*)pStateData;
    if ( dwFlags & DMUS_TRACKF_LOOP )
    {
        REFERENCE_TIME rtPerfStart = rtStart + rtOffset;
        MUSIC_TIME mtPerfStart = 0;
        if (fClockTime)
        {
            pPerf->ReferenceToMusicTime(rtPerfStart, &mtPerfStart);
        }
        else
        {
            mtPerfStart = (MUSIC_TIME)rtPerfStart;
        }
        CPerformance* pCPerf = NULL;
        if (SUCCEEDED(pPerf->QueryInterface(IID_CPerformance, (void**)&pCPerf)))
        {
            pCPerf->FlushVirtualTrack(dwVirtualID, mtPerfStart, FALSE);
            pCPerf->Release();
        }
        pSD->m_fLoop = true;
    }
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    if ( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
    {
        pSD->rtNextVariation = 0;
    }

    // if we're sync'ing variations to the pattern track, get the current variations
    if ( (m_dwTrackFlags & DMUS_WAVETRACKF_SYNC_VAR) &&
         (!pSD->rtNextVariation || (rtStart <= pSD->rtNextVariation && rtEnd > pSD->rtNextVariation)) )
    {
        hr = SyncVariations(pPerf, pSD, rtStart, rtOffset, fClockTime);
    }
    else if (dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP))
    {
        hr = ComputeVariations(pSD);
    }

    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        m_PChMap.Reset();
    }
    if( pSD->dwValidate != m_dwValidate )
    {
        if (pSD->m_apVoice)
        {
            for (DWORD dw = 0; dw < pSD->m_dwVoices; dw++)
			{
				if (pSD->m_apVoice[dw])
				{
					pSD->m_apVoice[dw]->Release();
				}
            }
            delete [] pSD->m_apVoice;
        }
        pSD->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
        if (!pSD->m_apVoice)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
            {
                pSD->m_apVoice[dw] = NULL;
            }
        }
        pSD->m_dwVoices = m_dwWaveItems;
        SetUpStateCurrentPointers(pSD);
        fSeek = TRUE;
    }

    if( fSeek )
    {
        if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, TRUE, rtOffset, fClockTime );
        }
        else
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, FALSE, rtOffset, fClockTime );
        }
    }

    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    DWORD dwIndex;
    DWORD dwPChannel;
    DWORD dwMutePChannel;
    BOOL fMute;

    TListItem<WavePart>* pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        long lPartVolume = 0;
        if( pPart )
        {
            WavePart& rPart = pPart->GetItemValue();
            dwPChannel = rPart.m_dwPChannel;
            lPartVolume = rPart.m_lVolume;
        }
        if( pSD->apCurrentWave )
        {
            for( ; pSD->apCurrentWave[dwIndex];
                pSD->apCurrentWave[dwIndex] = pSD->apCurrentWave[dwIndex]->GetNext() )
            {
                DWORD dwItemVariations = 0;
                WaveItem& rItem = pSD->apCurrentWave[dwIndex]->GetItemValue();
                REFERENCE_TIME rtTime = fClockTime ? rItem.m_rtTimePhysical : rItem.m_mtTimeLogical;
                if( rtTime >= rtEnd )
                {
                    break;
                }
                if (pPart)
                {
                    dwItemVariations = pSD->Variations(pPart->GetItemValue(), dwIndex) & rItem.m_dwVariations;
                }
                MUSIC_TIME mtTime = 0;
                MUSIC_TIME mtOffset = 0;
                if (fClockTime)
                {
                    MUSIC_TIME mtPerfTime = 0;
                    pPerf->ReferenceToMusicTime(rtOffset, &mtOffset);
                    pPerf->ReferenceToMusicTime(rItem.m_rtTimePhysical + rtOffset, &mtPerfTime);
                    mtTime = mtPerfTime - mtOffset;
                }
                else
                {
                    mtTime = rItem.m_mtTimeLogical;
                    mtOffset = (MUSIC_TIME)rtOffset;
                }
                m_PChMap.GetInfo( dwPChannel, mtTime, mtOffset, pSD->dwGroupBits,
                    pPerf, &fMute, &dwMutePChannel, FALSE );
                if( !fMute && dwItemVariations )
                {
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    hr = rItem.PChannelInfo(pPerf, pSD->m_pAudioPath, dwMutePChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP);
                        if (SUCCEEDED(hr))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave &&
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                REFERENCE_TIME rtDurationMs = 0;
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                REFERENCE_TIME rtDuration = rItem.m_rtDuration;
                                DMUS_WAVE_PMSG* pWave;
                                if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_WAVE_PMSG),
                                    (DMUS_PMSG**)&pWave )))
                                {
                                    pWave->dwType = DMUS_PMSGT_WAVE;
                                    pWave->dwPChannel = dwMutePChannel;
                                    pWave->dwVirtualTrackID = dwVirtualID;
                                    pWave->dwGroupID = pSD->dwGroupBits;
                                    if (fClockTime)
                                    {
                                        REFERENCE_TIME rtPlay = rItem.m_rtTimePhysical;
                                        rtDuration -= ConvertOffset(rtStartOffset, -rItem.m_lPitch);
                                        if (rtPlay < rtStart)
                                        {
                                            REFERENCE_TIME rtPlayOffset = ConvertOffset(rtStart - rtPlay, rItem.m_lPitch);
                                            rtStartOffset += rtPlayOffset;
                                            rtDuration -= (rtStart - rtPlay);
                                            rtPlay = rtStart;
                                        }
                                        pWave->rtTime = rtPlay + rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                        pWave->lOffset = 0;
                                        rtDurationMs = rtDuration / REF_PER_MIL;
                                    }
                                    else
                                    {
                                        REFERENCE_TIME rtPlay = 0;
                                        MUSIC_TIME mtPlay = (MUSIC_TIME)rItem.m_rtTimePhysical;
                                        pPerf->MusicToReferenceTime(mtPlay + (MUSIC_TIME)rtOffset, &rtPlay);
                                        MUSIC_TIME mtRealPlay = 0;
                                        pPerf->ReferenceToMusicTime(rtPlay + rtStartOffset, &mtRealPlay);
                                        if (mtRealPlay > rtOffset + mtPlay)
                                        {
                                            rtDuration -= ConvertOffset(mtRealPlay - (rtOffset + mtPlay), -rItem.m_lPitch);

                                        }
                                        if (mtPlay < (MUSIC_TIME) rtStart)
                                        {
                                            // Calculate distance from wave start to segment start, but begin
                                            // the calculation at segment start to avoid strangeness
                                            // when attempting to do conversions at times earlier than
                                            // segment start.
                                            REFERENCE_TIME rtRefStartPlus = 0;
                                            REFERENCE_TIME rtRefPlayPlus = 0;
                                            MUSIC_TIME mtNewDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rtStart + (MUSIC_TIME)rtOffset, &rtRefStartPlus);
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + mtPlay + (MUSIC_TIME)rtOffset, &rtRefPlayPlus);
                                            rtStartOffset += ConvertOffset((rtRefStartPlus - rtRefPlayPlus), rItem.m_lPitch);
                                            mtPlay = (MUSIC_TIME) rtStart;
                                            REFERENCE_TIME rtRealDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rItem.m_rtDuration + (MUSIC_TIME)rtOffset, &rtRealDuration);
                                            pPerf->ReferenceToMusicTime(rtRealDuration - (ConvertOffset(rItem.m_rtStartOffset, -rItem.m_lPitch) + (rtRefStartPlus - rtRefPlayPlus)), &mtNewDuration);
                                            rtDuration = (REFERENCE_TIME)mtNewDuration - (rtStart + rtOffset);
                                        }
                                        pWave->mtTime = mtPlay + (MUSIC_TIME)rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_MUSICTIME;
                                        pWave->lOffset = (MUSIC_TIME)rItem.m_rtTimePhysical - rItem.m_mtTimeLogical;
                                        REFERENCE_TIME rtZero = 0;
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)rtOffset + mtPlay, &rtZero);
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)(rtDuration + rtOffset) + mtPlay, &rtDurationMs);
                                        rtDurationMs -= rtZero;
                                        rtDurationMs /= REF_PER_MIL;
                                    }
                                    // If we're either past the end of the wave, or we're within
                                    // 150 ms of the end of a looping wave (and we've just started
                                    // playback), don't play the wave.
                                    if ( rtDurationMs <= 0 ||
                                         (rItem.m_dwLoopEnd && (dwFlags & DMUS_TRACKF_START) && rtDurationMs < 150) )
                                    {
                                        pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                    }
                                    else
                                    {
                                        pWave->rtStartOffset = rtStartOffset;
                                        pWave->rtDuration = rtDuration;
                                        pWave->lVolume = rItem.m_lVolume + lPartVolume + m_lVolume;
                                        pWave->lPitch = rItem.m_lPitch;
                                        pWave->bFlags = (BYTE)(rItem.m_dwFlags & 0xff);
                                        IDirectMusicVoiceP *pVoice = NULL;
                                        if (rItem.m_dwVoiceIndex == 0xffffffff)
                                        {
                                            hr = DMUS_E_NOT_INIT;
                                            TraceI(0, "Voice index not initialized!\n");
                                        }
                                        else
                                        {
                                            if ( pSD->m_fLoop ||
                                                 !pSD->m_apVoice[rItem.m_dwVoiceIndex] ||
                                                 rtStartOffset != rItem.m_rtStartOffset ||
                                                 dwMutePChannel != dwPChannel)
                                            {
                                                hr = GetDownload(
                                                    pDLWave->GetItemValue().m_pDownloadedWave,
                                                    pSD,
                                                    pPortP,
                                                    pDLWave->GetItemValue().m_pWave,
                                                    pWave->rtStartOffset,
                                                    rItem,
                                                    dwMChannel, dwGroup,
                                                    &pVoice);
                                            }
                                            else
                                            {
                                                pVoice = pSD->m_apVoice[rItem.m_dwVoiceIndex];
                                            }
                                        }
                                        if (SUCCEEDED(hr))
                                        {
                                            pWave->punkUser = (IUnknown*)pVoice;
                                            pVoice->AddRef();
                                            if( pGraph )
                                            {
                                                pGraph->StampPMsg( (DMUS_PMSG*)pWave );
                                            }
                                            hr = pPerf->SendPMsg( (DMUS_PMSG*)pWave );
                                        }
                                        if(FAILED(hr))
                                        {
                                            pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                        }
                                    }
                                }
                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
            }
        }
        if( pPart )
        {
            pPart = pPart->GetNext();
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// it's legal to start in the middle of a wave.
HRESULT CWavTrack::Seek( IDirectMusicSegmentState* pSegSt,
    IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    WaveStateData* pSD, REFERENCE_TIME rtTime, BOOL fGetPrevious,
    REFERENCE_TIME rtOffset, BOOL fClockTime)
{
    DWORD dwIndex;
    TListItem<WavePart>* pPart;
    TListItem<WaveItem>* pWaveItem;

    // in the case of fGetPrevious (which means DMUS_SEGF_START/LOOP was
    // set in Play() ) we want to reset all lists to the beginning regardless of time.
    if( fGetPrevious )//&& ( rtTime == 0 ) )
    {
        pPart = m_WavePartList.GetHead();
        for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            if( pPart )
            {
                pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead();
                if( pWaveItem && pSD->apCurrentWave )
                {
                    pSD->apCurrentWave[dwIndex] = pWaveItem;
                }
                pPart = pPart->GetNext();
            }
            else
            {
                break;
            }
        }
        return S_OK;
    }

    pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        if( pPart )
        {
            // scan the wave event list in this part.
            for( pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead(); pWaveItem; pWaveItem = pWaveItem->GetNext() )
            {
                WaveItem& rWaveItem = pWaveItem->GetItemValue();
                REFERENCE_TIME rtWaveTime = fClockTime ? rWaveItem.m_rtTimePhysical : rWaveItem.m_mtTimeLogical;
                if( rtWaveTime >= rtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
            }
            if( pSD->apCurrentWave )
            {
                pSD->apCurrentWave[dwIndex] = pWaveItem;
            }
            pPart = pPart->GetNext();
        }
    }

    return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::GetParam(
    REFGUID rguidType,  // @parm The type of data to obtain.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to obtain the data.
    MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
                        // may be NULL. If this returns a value of 0, it means that this
                        // data will either be always valid, or it is unknown when it will
                        // become invalid.
    void *pData)        // @parm The struture in which to return the data. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::SetParam(
    REFGUID rguidType,  // @parm The type of data to set.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to set the data.
    void *pData)        // @parm The struture containing the data to set. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return SetParamEx(rguidType, mtTime, pData, NULL, 0);
}

STDMETHODIMP CWavTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    V_INAME(CBandTrk::SetParamEx);
    V_REFGUID(rguidType);

    HRESULT hr = S_OK;

    if((pParam == NULL) &&
       (rguidType != GUID_Enable_Auto_Download) &&
       (rguidType != GUID_Disable_Auto_Download))
    {
        return E_POINTER;
    }

    EnterCriticalSection(&m_CrSec);

    if(rguidType == GUID_Download)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, NULL, NULL, GUID_NULL)) )
            {
                hrFail = hr;
            }
            else
            {
                dwSuccess++;
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
    }
    else if(rguidType == GUID_DownloadToAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, pPath, NULL, GUID_NULL)) )
                {
                    hrFail = hr;
                }
                else
                {
                    dwSuccess++;
                }
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Unload)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            pPart->GetItemValue().Unload(pPerf, NULL, NULL);
        }
    }
    else if(rguidType == GUID_UnloadFromAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                pPart->GetItemValue().Unload(pPerf, pPath, NULL);
            }
        }
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Enable_Auto_Download)
    {
        m_fAutoDownload = TRUE;
        m_fLockAutoDownload = TRUE;
    }
    else if(rguidType == GUID_Disable_Auto_Download)
    {
        m_fAutoDownload = FALSE;
        m_fLockAutoDownload = TRUE;
    }
    else
    {
        hr = DMUS_E_TYPE_UNSUPPORTED;
    }

    LeaveCriticalSection(&m_CrSec);

    return hr;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::AddNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to add.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to remove.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CWavTrack::Clone(
    MUSIC_TIME mtStart, // @parm The start of the part to clone. It should be 0 or greater,
                        // and less than the length of the Track.
    MUSIC_TIME mtEnd,   // @parm The end of the part to clone. It should be greater than
                        // <p mtStart> and less than the length of the Track.
    IDirectMusicTrack** ppTrack)    // @parm Returns the cloned Track.
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if((mtStart < 0 )||(mtStart > mtEnd))
    {
        Trace(1,"Error: Wave track clone failed because of invalid start or end time.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);
    CWavTrack *pDM;

    try
    {
        pDM = new CWavTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pDM->InitTrack(m_dwPChannelsUsed);
        if (SUCCEEDED(hr))
        {
            hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
        }
        pDM->Release();
    }

    LeaveCriticalSection(&m_CrSec);
    return hr;
}


STDMETHODIMP CWavTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::ComputeVariations(WaveStateData* pSD)
{
    if (!pSD)
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // First, initialize the array of variation groups.
    for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
    {
        pSD->adwVariationGroups[i] = 0;
    }
    // Now, compute the variations for each part.
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (i = 0; pScan && i < (int)m_dwPChannelsUsed; pScan = pScan->GetNext(), i++)
    {
        hr = ComputeVariation(i, pScan->GetItemValue(), pSD);
        if (FAILED(hr))
        {
            break;
        }
    }
    return hr;
}

HRESULT CWavTrack::SyncVariations(IDirectMusicPerformance* pPerf,
                                  WaveStateData* pSD,
                                  REFERENCE_TIME rtStart,
                                  REFERENCE_TIME rtOffset,
                                  BOOL fClockTime)
{
    if (!pSD)
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // Get the current variations
    DMUS_VARIATIONS_PARAM Variations;
    memset(&Variations, 0, sizeof(Variations));
    // Call GetParam for variations to sync to
    MUSIC_TIME mtNow = 0;
    MUSIC_TIME mtNext = 0;
    REFERENCE_TIME rtNext = 0;
    if (fClockTime)
    {
        pPerf->ReferenceToMusicTime(pSD->rtNextVariation + rtOffset, &mtNow);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr) &&
            SUCCEEDED(pPerf->MusicToReferenceTime(mtNext + mtNow, &rtNext)) )
        {
            pSD->rtNextVariation += rtNext;
        }
    }
    else
    {
        mtNow = (MUSIC_TIME) (pSD->rtNextVariation + rtOffset);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr))
        {
            pSD->rtNextVariation += mtNext;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Initialize the array of variation groups.
        for (int nGroup = 0; nGroup < MAX_WAVE_VARIATION_LOCKS; nGroup++)
        {
            pSD->adwVariationGroups[nGroup] = 0;
        }
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dwPart = 0; pScan && dwPart < m_dwPChannelsUsed; pScan = pScan->GetNext(), dwPart++)
        {
            WavePart& rPart = pScan->GetItemValue();
            for (DWORD dwSyncPart = 0; dwSyncPart < Variations.dwPChannelsUsed; dwSyncPart++)
            {
                if (rPart.m_dwPChannel == Variations.padwPChannels[dwSyncPart])
                {
                    pSD->pdwVariations[dwPart] = Variations.padwVariations[dwSyncPart];
                    break;
                }
            }
            if (dwSyncPart == Variations.dwPChannelsUsed) // no part to sync to
            {
                hr = ComputeVariation((int)dwPart, rPart, pSD);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
    }
    else
    {
        return ComputeVariations(pSD);
    }
    return hr;
}

HRESULT CWavTrack::ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD)
{
    BYTE bLockID = (BYTE)rWavePart.m_dwLockToPart;
    if (bLockID && pSD->adwVariationGroups[bLockID - 1] != 0)
    {
        pSD->pdwVariations[nPart] = pSD->adwVariationGroups[bLockID - 1];
    }
    else if (!rWavePart.m_dwVariations)
    {
        // No variations; clear the flags for this part.
        pSD->pdwVariations[nPart] = 0;
        pSD->pdwRemoveVariations[nPart] = 0;
    }
    else
    {
        // First, collect all matches.
        DWORD dwMatches = rWavePart.m_dwVariations;
        int nMatchCount = 0;
        for (int n = 0; n < 32; n++)
        {
            if (dwMatches & (1 << n)) nMatchCount++;
        }
        // Now, select a variation based on the part's variation mode.
        BYTE bMode = (BYTE)(rWavePart.m_dwPChannelFlags & 0xf);
        DWORD dwTemp = dwMatches;
        if ( bMode == DMUS_VARIATIONT_RANDOM_ROW )
        {
            dwTemp &= ~pSD->pdwRemoveVariations[nPart];
            if (!dwTemp)
            {
                // start counting all over, but don't repeat this one
                pSD->pdwRemoveVariations[nPart] = 0;
                dwTemp = dwMatches;
                bMode = DMUS_VARIATIONT_NO_REPEAT;
            }
        }
        if ( bMode == DMUS_VARIATIONT_NO_REPEAT && pSD->pdwVariations[nPart] != 0 )
        {
            dwTemp &= ~pSD->pdwVariations[nPart];
        }
        if (dwTemp != dwMatches)
        {
            if (dwTemp) // otherwise, keep what we had
            {
                for (int i = 0; i < 32; i++)
                {
                    if ( ((1 << i) & dwMatches) && !((1 << i) & dwTemp) )
                    {
                        nMatchCount--;
                    }
                }
                dwMatches = dwTemp;
            }
        }
        int nV = 0;
        switch (bMode)
        {
        case DMUS_VARIATIONT_RANDOM_ROW:
        case DMUS_VARIATIONT_NO_REPEAT:
        case DMUS_VARIATIONT_RANDOM:
            {
                short nChoice = (short) (rand() % nMatchCount);
                short nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nChoice == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
                if (bMode == DMUS_VARIATIONT_RANDOM_ROW)
                {
                    pSD->pdwRemoveVariations[nPart] |= pSD->pdwVariations[nPart];
                }
                TraceI(3, "New variation: %d\n", nV);
                break;
            }
        case DMUS_VARIATIONT_RANDOM_START:
            // Choose an initial value
            if (pSD->pdwVariations[nPart] == 0)
            {
                int nStart = 0;
                nStart = (BYTE) (rand() % nMatchCount);
                int nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nStart == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
            }
            // Now, go directly to the sequential case (no break)
        case DMUS_VARIATIONT_SEQUENTIAL:
            {
                if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                else
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                }
                while (!(pSD->pdwVariations[nPart] & dwMatches))
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                }
                TraceI(3, "New variation: %d\n", pSD->pdwVariations[nPart]);
                break;
            }
        }
        // If this is a locked variation, it's the first in its group, so record it.
        if (bLockID)
        {
            pSD->adwVariationGroups[bLockID - 1] = pSD->pdwVariations[nPart];
        }
        if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
             m_pdwVariations &&
             m_pdwRemoveVariations )
        {
            m_pdwVariations[nPart] = pSD->pdwVariations[nPart];
            m_pdwRemoveVariations[nPart] = pSD->pdwRemoveVariations[nPart];
        }
    }
    return S_OK;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
HRESULT CWavTrack::SetVariation(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart, DWORD dwIndex)
{
    WaveStateData* pState = NULL;
    EnterCriticalSection( &m_CrSec );
    m_dwVariation = dwVariationFlags;
    m_dwPart = dwPart;
    m_dwIndex = dwIndex;
    m_fAudition = TRUE;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        if (rScan.m_dwPChannel == dwPart && rScan.m_dwIndex == dwIndex)
        {
            m_dwLockID = rScan.m_dwLockToPart;
        }
    }
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(dwVariationFlags, dwPart, dwIndex, m_dwLockID, m_fAudition);
    }
    LeaveCriticalSection( &m_CrSec );

    return S_OK;
}

// Clears the variations to be played for a part, so that all parts use the MOAW.
HRESULT CWavTrack::ClearVariations(IDirectMusicSegmentState* pSegState)
{
    WaveStateData* pState = NULL;
    EnterCriticalSection( &m_CrSec );
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(0, 0, 0, 0, m_fAudition);
    }
    LeaveCriticalSection( &m_CrSec );

    return S_OK;
}

WaveStateData* CWavTrack::FindState(IDirectMusicSegmentState* pSegState)
{
    TListItem<StatePair>* pPair = m_StateList.GetHead();
    for (; pPair; pPair = pPair->GetNext())
    {
        if (pPair->GetItemValue().m_pSegState == pSegState)
        {
            return pPair->GetItemValue().m_pStateData;
        }
    }
    return NULL;
}

// Adds a wave at mtTime to part dwIndex on PChannel dwPChannel
// If there was already a wave there, the two will co-exist
HRESULT CWavTrack::AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    EnterCriticalSection(&m_CrSec);
    HRESULT hr = S_OK;
    m_lVolume = 0;
    m_dwTrackFlags = 0;
    TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
    if( !pNewPart )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewPart->GetItemValue().Add(pWave, rtTime, dwPChannel, dwIndex, prtLength);
    if( FAILED ( hr ) )
    {
        delete pNewPart;
        goto ON_ERROR;
    }
    InsertByAscendingPChannel( pNewPart );
    m_dwWaveItems = 0;
    m_dwPChannelsUsed = m_WavePartList.GetCount();
    if (m_aPChannels)
    {
        delete [] m_aPChannels;
        m_aPChannels = NULL;
    }
    m_aPChannels = new DWORD[m_dwPChannelsUsed];
    if (m_aPChannels)
    {
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
        {
            m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
                pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
                m_dwWaveItems++;
            }
        }
    }
    else
    {
        CleanUp();
        hr = E_OUTOFMEMORY;
    }
ON_ERROR:
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CWavTrack::DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::DownloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);
    V_REFGUID(rguidVersion);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, download is only partial.
            if (pPart->GetItemValue().Download(pPerf, pPath, pWave, rguidVersion) != S_OK)
            {
                Trace(1,"Error: Wave download was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk)
{
    V_INAME(CWavTrack::UnloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, unload is only partial.
            if (pPart->GetItemValue().Unload(pPerf, pPath, pWave) != S_OK)
            {
                Trace(1,"Error: Wavetrack unload was only partially successful.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::RefreshWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, refresh is only partial.
            if (pPart->GetItemValue().Refresh(pPerf, pPath, pWave, dwPChannel, rguidVersion) != S_OK)
            {
                Trace(1,"Error: Wavetrack refresh was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::FlushAllWaves()
{
    FlushWaves();
    return S_OK;
}

HRESULT CWavTrack::OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)
{
    HRESULT hr = S_OK;
    if( pStateData && pVoice )
    {
        EnterCriticalSection(&m_CrSec);

        WaveStateData* pSD = (WaveStateData*)pStateData;
        TListItem<WaveDLOnPlay>* pWDLOnPlay = pSD->m_WaveDLList.GetHead();
        TListItem<WaveDLOnPlay>* pWDLNext = NULL;
        for (; pWDLOnPlay; pWDLOnPlay = pWDLNext)
        {
            pWDLNext = pWDLOnPlay->GetNext();
            if (pWDLOnPlay->GetItemValue().m_pVoice == pVoice)
            {
                pSD->m_WaveDLList.Remove(pWDLOnPlay);
                delete pWDLOnPlay;
                break;
            }
        }

        LeaveCriticalSection(&m_CrSec);
    }
    else
    {
        hr = E_POINTER;
    }
    return hr;
}

////////////////////////////////////////////////////////////////////
// WavePart

HRESULT WavePart::Load( IDMStream* pIRiffStream, MMCKINFO* pckParent )
{
    MMCKINFO        ck;
    MMCKINFO        ckList;
    DWORD           dwByteCount;
    DWORD           dwSize;
    HRESULT         hr = E_FAIL;

    // LoadPChannel does not expect to be called twice on the same object!

    if( pIRiffStream == NULL ||  pckParent == NULL )
    {
        ASSERT( 0 );
        return DMUS_E_CANNOTREAD;
    }

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    // Load the PChannel
    while( pIRiffStream->Descend( &ck, pckParent, 0 ) == S_OK )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_WAVEPART_CHUNK:
            {
                DMUS_IO_WAVE_PART_HEADER iPartHeader;
                memset(&iPartHeader, 0, sizeof(iPartHeader));

                // Read in the item's header structure
                dwSize = min( sizeof( DMUS_IO_WAVE_PART_HEADER ), ck.cksize );
                hr = pIStream->Read( &iPartHeader, dwSize, &dwByteCount );

                // Handle any I/O error by returning a failure code
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1,"Error: Unable to read wave track - bad file.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_ERROR;
                }

                m_dwPChannel = iPartHeader.dwPChannel;
                m_dwIndex = iPartHeader.dwIndex;

                m_lVolume = iPartHeader.lVolume;
                m_dwLockToPart = iPartHeader.dwLockToPart;
                m_dwPChannelFlags = iPartHeader.dwFlags;
                m_dwVariations = iPartHeader.dwVariations;
                break;
            }

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_WAVEITEM_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == S_OK )
                        {
                            switch( ckList.ckid )
                            {
                                case FOURCC_LIST:
                                    switch( ckList.fccType )
                                    {
                                        case DMUS_FOURCC_WAVE_LIST:
                                        {
                                            TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
                                            if( pNewItem == NULL )
                                            {
                                                hr = E_OUTOFMEMORY;
                                                goto ON_ERROR;
                                            }
                                            hr = pNewItem->GetItemValue().Load( pIRiffStream, &ckList );
                                            if( FAILED ( hr ) )
                                            {
                                                delete pNewItem;
                                                goto ON_ERROR;
                                            }
                                            m_WaveItemList.AddHead( pNewItem );
                                            //InsertByAscendingTime( pNewItem );
                                            break;
                                        }
                                    }
                            }

                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;
                }
                break;
        }

        // Ascend out of the chunk
        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}

void WavePart::CleanUp()
{
    TListItem<WaveItem>* pScan = m_WaveItemList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WaveItemList.CleanUp();
}

HRESULT WavePart::CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WaveItem>* pScan = rItems.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WaveItem& rScan = pScan->GetItemValue();
        if (mtStart <= (MUSIC_TIME) rScan.m_rtTimePhysical &&
            (!mtEnd || (MUSIC_TIME) rScan.m_rtTimePhysical < mtEnd) )
        {
            TListItem<WaveItem>* pNew = new TListItem<WaveItem>;
            if (pNew)
            {
                WaveItem& rNew = pNew->GetItemValue();
                rNew.m_rtTimePhysical = rScan.m_rtTimePhysical - mtStart;
                rNew.m_lVolume = rScan.m_lVolume;
                rNew.m_lPitch = rScan.m_lPitch;
                rNew.m_dwVariations = rScan.m_dwVariations;
                rNew.m_rtStartOffset = rScan.m_rtStartOffset;
                rNew.m_rtDuration = rScan.m_rtDuration;
                rNew.m_mtTimeLogical = rScan.m_mtTimeLogical;
                rNew.m_dwFlags = rScan.m_dwFlags;
                rNew.m_pWave = rScan.m_pWave;
                rNew.m_dwLoopStart = rScan.m_dwLoopStart;
                rNew.m_dwLoopEnd = rScan.m_dwLoopEnd;
                rNew.m_fIsStreaming = rScan.m_fIsStreaming;
                if (rNew.m_pWave)
                {
                    rNew.m_pWave->AddRef();
                }
                if (SUCCEEDED(hr))
                {
                    m_WaveItemList.AddHead(pNew);
                }
                else
                {
                    delete pNew;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WaveItemList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

HRESULT WavePart::Download(IDirectMusicPerformance* pPerformance,
                           IDirectMusicAudioPath* pPath,
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Download(pPerformance, pPath, m_dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep downloading)
        }
    }
    return hr;
}

HRESULT WavePart::Unload(IDirectMusicPerformance* pPerformance, IDirectMusicAudioPath* pPath, IDirectSoundWave* pWave)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Unload(pPerformance, pPath, m_dwPChannel, pWave);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep unloading)
        }
    }
    return hr;
}

HRESULT WavePart::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          IDirectSoundWave* pWave,
                          DWORD dwPChannel,
                          REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Refresh(pPerformance, pPath, m_dwPChannel, dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep refreshing)
        }
    }
    return hr;
}

HRESULT WavePart::Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    m_dwPChannel = dwPChannel;
    m_dwIndex = dwIndex;

    m_lVolume = 0;
    m_dwLockToPart = 0;
    m_dwPChannelFlags = 0;
    m_dwVariations = 0xffffffff;

    TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
    if( pNewItem == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewItem->GetItemValue().Add( pWave, rtTime, prtLength );
    if( FAILED ( hr ) )
    {
        delete pNewItem;
        goto ON_ERROR;
    }
    m_WaveItemList.AddHead( pNewItem );
ON_ERROR:
    return hr;
}

////////////////////////////////////////////////////////////////////
// WaveItem

HRESULT WaveItem::Load( IDMStream* pIRiffStream, MMCKINFO* pckParent )
{
    MMCKINFO        ck;
    DWORD           dwByteCount;
    DWORD           dwSize;
    HRESULT         hr = E_FAIL;

    // LoadListItem does not expect to be called twice on the same object
    // Code assumes item consists of initial values
    ASSERT( m_rtTimePhysical == 0 );

    if( pIRiffStream == NULL ||  pckParent == NULL )
    {
        ASSERT( 0 );
        return DMUS_E_CANNOTREAD;
    }

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    // Load the track item
    while( pIRiffStream->Descend( &ck, pckParent, 0 ) == S_OK )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_WAVEITEM_CHUNK:
            {
                DMUS_IO_WAVE_ITEM_HEADER iItemHeader;

                // Read in the item's header structure
                dwSize = min( sizeof( DMUS_IO_WAVE_ITEM_HEADER ), ck.cksize );
                hr = pIStream->Read( &iItemHeader, dwSize, &dwByteCount );

                // Handle any I/O error by returning a failure code
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1,"Error: Unable to read wave track - bad file.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_ERROR;
                }

                m_lVolume = iItemHeader.lVolume;
                m_lPitch = iItemHeader.lPitch;
                m_dwVariations = iItemHeader.dwVariations;
                m_rtTimePhysical = iItemHeader.rtTime;
                m_rtStartOffset = iItemHeader.rtStartOffset;
                m_rtDuration = iItemHeader.rtDuration;
                m_mtTimeLogical = iItemHeader.mtLogicalTime;
                m_dwFlags = iItemHeader.dwFlags;
                m_dwLoopStart = iItemHeader.dwLoopStart;
                m_dwLoopEnd = iItemHeader.dwLoopEnd;
                if (m_dwLoopEnd) m_dwLoopEnd++; // fix for bug 38505
                break;
            }

            case FOURCC_LIST:
                if( ck.fccType == DMUS_FOURCC_REF_LIST )
                {
                    hr = LoadReference( pIStream, pIRiffStream, ck );
                }
                break;
        }

        // Ascend out of the chunk
        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}

HRESULT WaveItem::LoadReference(IStream *pStream,
                                         IDMStream *pIRiffStream,
                                         MMCKINFO& ckParent)
{
    if (!pStream || !pIRiffStream) return E_INVALIDARG;

    IDirectSoundWave* pWave;
    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;

    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == S_OK )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.wszName[DMUS_MAX_NAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, NULL);
                if(SUCCEEDED(hr))
                {
                    desc.wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            default:
                break;
        }

        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == S_OK)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
    }

    if (!(desc.dwValidData &  DMUS_OBJ_NAME) &&
        !(desc.dwValidData &  DMUS_OBJ_FILENAME) &&
        !(desc.dwValidData &  DMUS_OBJ_OBJECT) )
    {
        Trace(1,"Error: Wave track is unable to reference a wave because it doesn't have any valid reference information.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_IDirectSoundWave, (void**)&pWave);
        if (SUCCEEDED(hr))
        {
            if (m_pWave) m_pWave->Release();
            m_pWave = pWave; // no need to AddRef; GetObject did that
            REFERENCE_TIME rtReadAhead = 0;
            DWORD dwFlags = 0;
            m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
            m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
            m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT WaveItem::Download(IDirectMusicPerformance* pPerformance,
                           IDirectMusicAudioPath* pPath,
                           DWORD dwPChannel,
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if ( rDLWave.m_pWave == m_pWave &&
                         rDLWave.m_pPerformance == pPerformance &&
                         rDLWave.m_pPort == pPortP &&
                         ( !m_fIsStreaming ||
                           rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        break;
                    }
                }
                // only download the wave if:
                // 1) it hasn't already been downloaded to the port, or
                // 2) its version doesn't match the currently downloaded version.
                if (!pDLWave)
                {
                    pDLWave = new TListItem<TaggedWave>;
                    if (!pDLWave)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        TaggedWave& rDLWave = pDLWave->GetItemValue();
                        hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                        if (SUCCEEDED(hr))
                        {
                            rDLWave.m_pPort = pPortP;
                            rDLWave.m_pPort->AddRef();
                            rDLWave.m_pPerformance = pPerformance;
                            rDLWave.m_pPerformance->AddRef();
                            rDLWave.m_pWave = m_pWave;
                            rDLWave.m_pWave->AddRef();
                            rDLWave.m_lRefCount = 1;
                            rDLWave.m_guidVersion = rguidVersion;
                            st_WaveList.AddHead(pDLWave);
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                            }
                            if(m_fIsStreaming)
                            {
                                m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                                m_pDownloadedWave->AddRef();
                            }
                        }
                        else
                        {
                            delete pDLWave;
                        }
                    }
                }
                else if (rguidVersion != pDLWave->GetItemValue().m_guidVersion)
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pDownloadedWave)
                    {
                        pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                        rDLWave.m_pDownloadedWave = NULL;
                    }
                    if (rDLWave.m_pPort)
                    {
                        rDLWave.m_pPort->Release();
                        rDLWave.m_pPort = NULL;
                    }
                    if (rDLWave.m_pPerformance)
                    {
                        rDLWave.m_pPerformance->Release();
                        rDLWave.m_pPerformance = NULL;
                    }
                    hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                    if (SUCCEEDED(hr))
                    {
                        rDLWave.m_pPort = pPortP;
                        rDLWave.m_pPort->AddRef();
                        rDLWave.m_pPerformance = pPerformance;
                        rDLWave.m_pPerformance->AddRef();
                        rDLWave.m_lRefCount = 1;
                        rDLWave.m_guidVersion = rguidVersion;
                        if (m_pDownloadedWave)
                        {
                            m_pDownloadedWave->Release();
                        }

                        if(m_fIsStreaming)
                        {
                            m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                            m_pDownloadedWave->AddRef();
                        }
                    }
                    else
                    {
                        if (rDLWave.m_pWave)
                        {
                            rDLWave.m_pWave->Release();
                            rDLWave.m_pWave = NULL;
                        }
                        st_WaveList.Remove(pDLWave);
                        delete pDLWave;
                    }
                }
                else // keep track of this, but return S_FALSE (indicates wave wasn't downloaded)
                {
                    pDLWave->GetItemValue().m_lRefCount++;
                    hr = S_FALSE;
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for download.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        Trace(1,"Error: Wavetrack download failed, initialization error.\n");
        hr = DMUS_E_NOT_INIT;
    }

    return hr;
}

HRESULT WaveItem::Unload(IDirectMusicPerformance* pPerformance,
                         IDirectMusicAudioPath* pPath,
                         DWORD dwPChannel,
                         IDirectSoundWave* pWave)
{
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pWave == m_pWave &&
                        rDLWave.m_pPerformance == pPerformance &&
                        rDLWave.m_pPort == pPortP &&
                        ( !m_fIsStreaming ||
                          rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        rDLWave.m_lRefCount--;
                        if (rDLWave.m_lRefCount <= 0)
                        {
                            if (rDLWave.m_pWave)
                            {
                                rDLWave.m_pWave->Release();
                                rDLWave.m_pWave = NULL;
                            }
                            if (rDLWave.m_pPort)
                            {
                                rDLWave.m_pPort->Release();
                                rDLWave.m_pPort = NULL;
                            }
                            if (rDLWave.m_pPerformance)
                            {
                                rDLWave.m_pPerformance->Release();
                                rDLWave.m_pPerformance = NULL;
                            }
                            if (rDLWave.m_pDownloadedWave)
                            {
                                pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                                rDLWave.m_pDownloadedWave = NULL;
                            }
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                                m_pDownloadedWave = NULL;
                            }
                            st_WaveList.Remove(pDLWave);
                            delete pDLWave;
                        }
                        else
                        {
                            hr = S_FALSE; // indicates wave wasn't actually unloaded
                        }
                        break;
                    }
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for unload.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }

    return hr;
}

HRESULT WaveItem::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          DWORD dwOldPChannel,
                          DWORD dwNewPChannel,
                          IDirectSoundWave* pWave,
                          REFGUID rguidVersion)
{
    IDirectMusicPort* pOldPort = NULL;
    IDirectMusicPort* pNewPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    hr = PChannelInfo(pPerformance, pPath, dwOldPChannel, &pOldPort, &dwGroup, &dwMChannel);
    if (SUCCEEDED(hr))
    {
        hr = PChannelInfo(pPerformance, pPath, dwNewPChannel, &pNewPort, &dwGroup, &dwMChannel);
    }
    if (SUCCEEDED(hr))
    {
        // if the old port and new port are different, unload the wave from the old port
        // and download to the new one.
        if (pOldPort != pNewPort)
        {
            Unload(pPerformance, pPath, dwOldPChannel, pWave);
            hr = Download(pPerformance, pPath, dwNewPChannel, pWave, rguidVersion);
        }
    }
    if (pOldPort) pOldPort->Release();
    if (pNewPort) pNewPort->Release();
    return hr;
}

HRESULT WaveItem::PChannelInfo(
    IDirectMusicPerformance* pPerformance,
    IDirectMusicAudioPath* pAudioPath,
    DWORD dwPChannel,
    IDirectMusicPort** ppPort,
    DWORD* pdwGroup,
    DWORD* pdwMChannel)
{
    HRESULT hr = S_OK;
    DWORD dwConvertedPChannel = dwPChannel;
    if (pAudioPath)
    {
        hr = pAudioPath->ConvertPChannel(dwPChannel, &dwConvertedPChannel);
    }
    if (SUCCEEDED(hr))
    {
        hr = pPerformance->PChannelInfo(dwConvertedPChannel, ppPort, pdwGroup, pdwMChannel);
    }
    return hr;
}

void WaveItem::CleanUp()
{
    if (m_pWave)
    {
        m_pWave->Release();
        m_pWave = NULL;
    }
    if (m_pDownloadedWave)
    {
        m_pDownloadedWave->Release();
        m_pDownloadedWave = NULL;
    }
}

HRESULT WaveItem::Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    IPrivateWave* pPrivWave = NULL;
    *prtLength = 0; // in case GetLength fails...
    REFERENCE_TIME rtLength = 0;
    m_rtDuration = 0;
    if (SUCCEEDED(hr = pWave->QueryInterface(IID_IPrivateWave, (void**)&pPrivWave)))
    {
        if (SUCCEEDED(hr = pPrivWave->GetLength(&rtLength)))
        {
            // Assumes the track is clock time
            m_rtDuration = rtLength * REF_PER_MIL;
            *prtLength = rtLength; // NOTE: length in milliseconds; duration in Ref time
        }
        pPrivWave->Release();
    }
    if (SUCCEEDED(hr))
    {
        m_lVolume = 0;
        m_lPitch = 0;
        m_dwVariations = 0xffffffff;
        m_rtTimePhysical = rtTime;
        m_rtStartOffset = 0;
        m_mtTimeLogical = 0;
        m_dwFlags = 0;
        m_dwLoopStart = 0;
        m_dwLoopEnd = 0;
        if (m_pWave)
        {
            m_pWave->Release();
            m_pWave = NULL;
        }
        m_pWave = pWave;
        if (m_pWave)
        {
            m_pWave->AddRef();
            REFERENCE_TIME rtReadAhead = 0;
            DWORD dwFlags = 0;
            m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
            m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
            m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        }
        if (m_pDownloadedWave)
        {
            m_pDownloadedWave->Release();
        }
        m_pDownloadedWave = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\tsigtrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// TimeSigTrk.cpp : Implementation of CTimeSigTrack

#include "dmime.h"
#include "TSigTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert

CTimeSigItem::CTimeSigItem()

{ 
    m_TimeSig.lTime = 0;
    m_TimeSig.bBeatsPerMeasure = 0; 
    m_TimeSig.bBeat = 0;
    m_TimeSig.wGridsPerBeat = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack

void CTimeSigTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
	m_fNotificationMeasureBeat = FALSE;
}

CTimeSigTrack::CTimeSigTrack()
{
	Construct();
	m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTimeSigTrack::CTimeSigTrack(
		CTimeSigTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
	m_fActive = pSourceTrack->m_fActive;
    m_fStateSetBySetParam = pSourceTrack->m_fStateSetBySetParam;
    // Clone the time signature list.
	CTimeSigItem* pScan = pSourceTrack->m_TSigEventList.GetHead();
	CTimeSigItem* pPrevious = NULL;
	for(; pScan; pScan = pScan->GetNext())
	{
		if (pScan->m_TimeSig.lTime < mtStart)
		{
			pPrevious = pScan;
		}
		else if (pScan->m_TimeSig.lTime < mtEnd)
		{
			if (pScan->m_TimeSig.lTime == mtStart)
			{
				pPrevious = NULL;
			}
			CTimeSigItem* pNew = new CTimeSigItem;
			if (pNew)
			{
				pNew->m_TimeSig = pScan->m_TimeSig;
				pNew->m_TimeSig.lTime = pScan->m_TimeSig.lTime - mtStart;
				m_TSigEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_TSigEventList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPrevious)
	{
		CTimeSigItem* pNew = new CTimeSigItem;
		if (pNew)
		{
			pNew->m_TimeSig = pPrevious->m_TimeSig;
			pNew->m_TimeSig.lTime = 0;
			m_TSigEventList.AddHead(pNew);
		}
	}
}

void CTimeSigTrack::Clear()

{
    CTimeSigItem* pItem;
	while( pItem = m_TSigEventList.RemoveHead() )
	{
		delete pItem;
	}
}

CTimeSigTrack::~CTimeSigTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }
	InterlockedDecrement(&g_cComponent);
}

// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTimeSigTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTimeSigTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CTimeSigTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Time Signature Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | Release | Standard Release implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTimeSigTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CTimeSigTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicTimeSigTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTimeSigTrack::IsDirty()
{
	return S_FALSE;
}

/*

  @method HRESULT | ITimeSigTrack | Load |
  Call this with an IStream filled with DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain TimeSig events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TimeSigTrack is released.
*/

HRESULT CTimeSigTrack::Load( IStream* pIStream )
{
	V_INAME(CTimeSigTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	EnterCriticalSection(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    { 
 		if (ckMain.ckid == DMUS_FOURCC_TIMESIG_CHUNK)
        {
            hr = LoadTimeSigList(&Parser,ckMain.cksize);
        }
        else if ((ckMain.ckid == FOURCC_LIST) && 
            (ckMain.fccType == DMUS_FOURCC_TIMESIGTRACK_LIST))
        {
            Clear();
	        RIFFIO ckNext;    // Descends into the children chunks.
            Parser.EnterList(&ckNext);
            while (Parser.NextChunk(&hr))
            {
		        switch(ckNext.ckid)
		        {
                case DMUS_FOURCC_TIMESIG_CHUNK :
                    hr = LoadTimeSigList(&Parser,ckNext.cksize);
                    break;
                }    
            }
            Parser.LeaveList();
        }
        else
        {
            Trace(1,"Error: Failure reading bad data in time signature track.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
        }
    }

	LeaveCriticalSection(&m_CrSec);
	return hr;
}


HRESULT CTimeSigTrack::LoadTimeSigList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;

	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_TIMESIGNATURE_ITEM) )
	    {
		    dwRead = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Failure reading time signature track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CTimeSigItem *pNew = new CTimeSigItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_TimeSig, dwRead )))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
				    // make sure this time sig is OK
				    if (!pNew->m_TimeSig.bBeatsPerMeasure)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeatsPerMeasure\n");
					    pNew->m_TimeSig.bBeatsPerMeasure = 4;
				    }
				    if (!pNew->m_TimeSig.bBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeat\n");
					    pNew->m_TimeSig.bBeat = 4;
				    }
				    if (!pNew->m_TimeSig.wGridsPerBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.wGridsPerBeat\n");
					    pNew->m_TimeSig.wGridsPerBeat = 4;
				    }
                    m_TSigEventList.AddHead(pNew); 
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_TSigEventList.Reverse();
            // If there is no time signature at the start, make a copy of the 
            // first time signature and stick it there. This resolves a bug in 6.1 
            // where notification messages and GetParam() were inconsistent
            // in their behavior under this circumstance. This ensures they behave
            // the same.
            CTimeSigItem *pTop = m_TSigEventList.GetHead();
            if (pTop && (pTop->m_TimeSig.lTime > 0))
            {
                CTimeSigItem *pCopy = new CTimeSigItem;
                if (pCopy)
                {
                    *pCopy = *pTop;
                    pCopy->m_TimeSig.lTime = 0;
                    m_TSigEventList.AddHead(pCopy);
                }                
            }
        }
    }
	return hr;
}

HRESULT CTimeSigTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CTimeSigTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CTimeSigTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CTimeSigTrack::IsParamSupported);
	V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
	    if( m_fActive )
	    {
		    if( rguid == GUID_DisableTimeSig ) return S_OK;
		    if( rguid == GUID_TimeSignature ) return S_OK;
		    if( rguid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
	    }
	    else
	    {
		    if( rguid == GUID_EnableTimeSig ) return S_OK;
		    if( rguid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
		    if( rguid == GUID_TimeSignature ) return DMUS_E_TYPE_DISABLED;
	    }
    }
    else
    {
		if(( rguid == GUID_DisableTimeSig ) ||
		    ( rguid == GUID_TimeSignature ) ||
		    ( rguid == GUID_EnableTimeSig )) return S_OK;
    }
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTimeSigTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CTimeSigTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

    EnterCriticalSection(&m_CrSec);
	CTimeSigStateData* pStateData;
	pStateData = new CTimeSigStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fActive = m_fActive;
    }
    else
    {
        pStateData->m_fActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
	pStateData->m_dwVirtualTrackID = dwTrackID;
	pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
	pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
	pStateData->m_pCurrentTSig = m_TSigEventList.GetHead();
	pStateData->m_dwValidate = m_dwValidate;
    LeaveCriticalSection(&m_CrSec);
	return S_OK;
}

HRESULT CTimeSigTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(CTimeSigTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(CTimeSigStateData));
		CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

HRESULT CTimeSigTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(CTimeSigStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	EnterCriticalSection(&m_CrSec);
	HRESULT hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	DMUS_TIMESIG_PMSG* pTimeSig;
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
	MUSIC_TIME mtNotification = mtStart;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	if( pSD->m_dwValidate != m_dwValidate )
	{
		pSD->m_dwValidate = m_dwValidate;
		pSD->m_pCurrentTSig = NULL;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->m_mtPrevEnd != mtStart ))
	{
		if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
		{
			Seek( pStateData, mtStart, TRUE );
		}
		else
		{
			Seek( pStateData, mtStart, FALSE );
		}
	}
	pSD->m_mtPrevEnd = mtEnd;

	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}

	if( FAILED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->m_pCurrentTSig; pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext() )
	{
		DMUS_IO_TIMESIGNATURE_ITEM *pItem = &pSD->m_pCurrentTSig->m_TimeSig;
		if( pItem->lTime >= mtEnd )
		{
			break;
		}
		if( (pItem->lTime < mtStart) && !fSeek )
		{
			break;
		}
		if( pSD->m_fActive && !(dwFlags & DMUS_TRACKF_PLAY_OFF) && SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),
			(DMUS_PMSG**)&pTimeSig )))
		{
			if( pItem->lTime < mtStart )
			{
				// this only happens in the case where we've puposefully seeked
				// and need to time stamp this event with the start time
				pTimeSig->mtTime = mtStart + mtOffset;
			}
			else
			{
				pTimeSig->mtTime = pItem->lTime + mtOffset;
			}
			pTimeSig->bBeatsPerMeasure = pItem->bBeatsPerMeasure;
			pTimeSig->bBeat = pItem->bBeat;
			pTimeSig->wGridsPerBeat = pItem->wGridsPerBeat;
			pTimeSig->dwFlags |= DMUS_PMSGF_MUSICTIME;
			pTimeSig->dwVirtualTrackID = pSD->m_dwVirtualTrackID;
			pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
			pTimeSig->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pTimeSig );
			}
			TraceI(3, "TimeSigtrk: TimeSig event\n");
			if(FAILED(pSD->m_pPerformance->SendPMsg( (DMUS_PMSG*)pTimeSig )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pTimeSig );
			}
		}
		if( pSD->m_fActive && m_fNotificationMeasureBeat && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
		{
			// create beat and measure notifications for up to this time
            if (mtNotification < pItem->lTime)
            {
			    mtNotification = NotificationMeasureBeat( mtNotification, pItem->lTime, pSD, mtOffset );
            }
        }
		// set the state data to the new beat and beats per measure, and time
		pSD->m_bBeat = pItem->bBeat;
		pSD->m_bBeatsPerMeasure = pItem->bBeatsPerMeasure;
		pSD->m_mtTimeSig = pItem->lTime;
	}
	if( pSD->m_fActive && m_fNotificationMeasureBeat && ( mtNotification < mtEnd ) 
        && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
	{
		NotificationMeasureBeat( mtNotification, mtEnd, pSD, mtOffset );
	}
	if( pGraph )
	{
		pGraph->Release();
	}

	LeaveCriticalSection(&m_CrSec);
	return hr;
}

// seeks to the time sig. just before mtTime.
HRESULT CTimeSigTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;

	if( m_TSigEventList.IsEmpty() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	if( pSD->m_pCurrentTSig->m_TimeSig.lTime >= mtTime )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	CTimeSigItem*	pTSig;
	for( pTSig = pSD->m_pCurrentTSig; pTSig ; pTSig = pTSig->GetNext() )
	{
		if( pTSig->m_TimeSig.lTime >= mtTime )
		{
			break;
		}
		pSD->m_pCurrentTSig = pTSig;
	}
	if( !fGetPrevious && pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext();
	}
	return S_OK;
}

HRESULT CTimeSigTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CTimeSigTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    EnterCriticalSection(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_TimeSignature == rguid )
	{
		if( !m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
        else
        {
            DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
		    CTimeSigItem* pScan = m_TSigEventList.GetHead();
		    CTimeSigItem* pPrevious = pScan;
		    if (pScan)
		    {
		        for (; pScan; pScan = pScan->GetNext())
		        {
			        if (pScan->m_TimeSig.lTime > mtTime)
			        {
				        break;
			        }
			        pPrevious = pScan;
		        }
		        pTSigData->mtTime = pPrevious->m_TimeSig.lTime - mtTime;
		        pTSigData->bBeatsPerMeasure = pPrevious->m_TimeSig.bBeatsPerMeasure;
		        pTSigData->bBeat = pPrevious->m_TimeSig.bBeat;
		        pTSigData->wGridsPerBeat = pPrevious->m_TimeSig.wGridsPerBeat;
		        if (pmtNext)
		        {
			        *pmtNext = 0;
		        }
		        if (pScan)
		        {
			        if (pmtNext)
			        {
				        *pmtNext = pScan->m_TimeSig.lTime - mtTime;
			        }
		        }
		        hr = S_OK;
            }
            else
            {
                hr = DMUS_E_NOT_FOUND;
		    }
        }
	}
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CTimeSigTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	V_INAME(CTimeSigTrack::SetParam);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_SET_UNSUPPORTED;

	if( rguid == GUID_EnableTimeSig )
	{
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
		    hr = S_OK;
        }
	}
	else if( rguid == GUID_DisableTimeSig )
	{
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
		    hr = S_OK;
        }
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::AddNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = TRUE;
		hr = S_OK;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::RemoveNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = FALSE;
		hr = S_OK;
	}
	return hr;
}

// send measure and beat notifications
MUSIC_TIME CTimeSigTrack::NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
	CTimeSigStateData* pSD, MUSIC_TIME mtOffset )
{
	DMUS_NOTIFICATION_PMSG* pEvent = NULL;
	MUSIC_TIME mtTime;
	DWORD dwMeasure;
	BYTE bCurrentBeat;

	if( pSD->m_mtTimeSig >= mtEnd )
		return mtStart;

	if( pSD->m_mtTimeSig > mtStart )
	{
		mtStart = pSD->m_mtTimeSig;
	}

	// now actually generate the beat events.
	// Generate events that are on beat boundaries, from mtStart to mtEnd
	long lQuantize = ( DMUS_PPQ * 4 ) / pSD->m_bBeat;

	mtTime = mtStart - pSD->m_mtTimeSig;
	if( mtTime ) // 0 stays 0
	{
		// quantize to next boundary
		mtTime = ((( mtTime - 1 ) / lQuantize ) + 1 ) * lQuantize;
	}
	mtStart += mtTime - ( mtStart - pSD->m_mtTimeSig );
	
	bCurrentBeat = (BYTE)(( ( mtStart - pSD->m_mtTimeSig ) / lQuantize ) % pSD->m_bBeatsPerMeasure);
	dwMeasure = mtStart / (pSD->m_bBeatsPerMeasure * lQuantize );
	while( mtStart < mtEnd )
	{
		if( SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
			(DMUS_PMSG**)&pEvent )))
		{
			pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
			pEvent->mtTime = mtStart + mtOffset;
			pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
			pSD->m_pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

			pEvent->dwNotificationOption = DMUS_NOTIFICATION_MEASUREBEAT;
			pEvent->dwField1 = bCurrentBeat;
			pEvent->dwField2 = dwMeasure;
			pEvent->guidNotificationType = GUID_NOTIFICATION_MEASUREANDBEAT;
			pEvent->dwGroupID = 0xffffffff;

			IDirectMusicGraph* pGraph;
			if( SUCCEEDED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
				(void**)&pGraph )))
			{
				pGraph->StampPMsg((DMUS_PMSG*) pEvent );
				pGraph->Release();
			}
			if(FAILED(pSD->m_pPerformance->SendPMsg((DMUS_PMSG*) pEvent )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
			}
		}
		bCurrentBeat++;
		if( bCurrentBeat >= pSD->m_bBeatsPerMeasure )
		{
			bCurrentBeat = 0;
			dwMeasure += 1;
		}
		mtStart += lQuantize;
	}
	return mtEnd;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if((mtStart < 0 ) ||(mtStart > mtEnd))
	{
        Trace(1,"Error: Clone failed on time signature track because of invalid start or end time.\n");
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);
    CTimeSigTrack *pDM;
    
    try
    {
        pDM = new CTimeSigTrack(this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\tempotrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TempoTrk.h : Declaration of the CTempoTrack

#ifndef __TEMPOTRK_H_
#define __TEMPOTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\tlist.h"

struct PrivateTempo
{
    double      dblTempo;
    MUSIC_TIME  mtTime;
    MUSIC_TIME  mtDelta;
    bool        fLast;

    PrivateTempo() : dblTempo(120.), mtTime(0), mtDelta(0), fLast(false) {}
};

DEFINE_GUID(GUID_PrivateTempoParam, 0xe8dbd832, 0xbcf0, 0x4c8c, 0xa0, 0x75, 0xa3, 0xf1, 0x5e, 0x67, 0xfd, 0x63);

struct TempoStateData
{
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	MUSIC_TIME					mtPrevEnd;
	TListItem<DMUS_IO_TEMPO_ITEM>*		pCurrentTempo;
	DWORD						dwValidate;
    BOOL                        fActive;

	TempoStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CTempoTrack
class CTempoTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CTempoTrack();
	CTempoTrack(
		const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTempoTrack();

// member variables
protected:
	TList<DMUS_IO_TEMPO_ITEM>	m_TempoEventList;
	long				m_cRef;
	DWORD				m_dwValidate; // used to validate state data
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL				m_fActive; // if FALSE, disable output and param support
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	HRESULT Seek(TempoStateData *pSD,MUSIC_TIME mtTime,BOOL fGetPrevious );
	void Construct(void);
	HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);
};

#endif //__TEMPOTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmime\wavtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// WavTrack.h : Declaration of the CWavTrack

#ifndef __WAVTRACK_H_
#define __WAVTRACK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmstrm.h"
#include "tlist.h"
#include "PChMap.h"
#include "..\shared\dmusiccp.h"
#include "dsoundp.h"  // For IDirectSoundWave

interface IPrivateWaveTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex)=0;
    virtual HRESULT STDMETHODCALLTYPE ClearVariations(IDirectMusicSegmentState* pSegState)=0;
    virtual HRESULT STDMETHODCALLTYPE AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)=0;
    virtual HRESULT STDMETHODCALLTYPE DownloadWave(
        IDirectSoundWave* pWave,   // wave to download
        IUnknown* pUnk,            // performance or audio path
        REFGUID rguidVersion)=0;   // version of downloaded wave
    virtual HRESULT STDMETHODCALLTYPE UnloadWave(
        IDirectSoundWave* pWave,   // wave to unload
        IUnknown* pUnk)=0;         // performance or audio path
    virtual HRESULT STDMETHODCALLTYPE RefreshWave(
        IDirectSoundWave* pWave,   // wave to refresh
        IUnknown* pUnk,            // performance or audio path
        DWORD dwPChannel,          // new PChannel for the wave
        REFGUID rguidVersion)=0;  // version of refreshed wave
    virtual HRESULT STDMETHODCALLTYPE FlushAllWaves()=0;
    virtual HRESULT STDMETHODCALLTYPE OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)=0;
};

DEFINE_GUID(IID_IPrivateWaveTrack, 0x492abe2a, 0x38c8, 0x48a3, 0x8f, 0x3c, 0x1e, 0x13, 0xba, 0x1, 0x78, 0x4e);

const int MAX_WAVE_VARIATION_LOCKS = 255;  // max number of variation lock ids

struct TaggedWave
{
    IDirectSoundWave*               m_pWave;
    GUID                            m_guidVersion;
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    long                            m_lRefCount;
    IDirectMusicPortP*              m_pPort;
    IDirectMusicPerformance*        m_pPerformance;

    TaggedWave() : m_pWave(NULL), m_pDownloadedWave(NULL), m_lRefCount(0),
        m_pPort(NULL), m_pPerformance(NULL), m_guidVersion(GUID_NULL)
    {
    }

    ~TaggedWave()
    {
        if (m_pWave) m_pWave->Release();
        if (m_pPort) m_pPort->Release();
        if (m_pPerformance) m_pPerformance->Release();
        if (m_pDownloadedWave) m_pDownloadedWave->Release();
    }
};

struct WaveItem
{
    WaveItem() : m_rtTimePhysical(0), m_lVolume(0), m_lPitch(0), m_dwVariations(0),
        m_rtStartOffset(0), m_rtDuration(0), m_mtTimeLogical(0), m_dwFlags(0),
        m_pWave(NULL), m_dwLoopStart(0), m_dwLoopEnd(0), m_dwVoiceIndex(0xffffffff),
        m_pDownloadedWave(NULL), m_fIsStreaming(FALSE), m_fUseNoPreRoll(FALSE)
    {
    }

    ~WaveItem()
    {
        CleanUp();
    }

    HRESULT Load( IDMStream* pIRiffStream, MMCKINFO* pckParent );
    HRESULT LoadReference(IStream *pStream, IDMStream *pIRiffStream, MMCKINFO& ckParent);
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave, 
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwOldPChannel, 
        DWORD dwNewPChannel,
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    static HRESULT PChannelInfo(
        IDirectMusicPerformance* pPerformance,
        IDirectMusicAudioPath* pAudioPath,
        DWORD dwPChannel,
        IDirectMusicPort** ppPort,
        DWORD* pdwGroup,
        DWORD* pdwMChannel);

    void CleanUp();
    HRESULT Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime, REFERENCE_TIME* prtLength);

    REFERENCE_TIME                  m_rtTimePhysical;
    long                            m_lVolume;
    long                            m_lPitch;
    DWORD                           m_dwVariations; // variations this wave item responds to
    REFERENCE_TIME                  m_rtStartOffset;
    REFERENCE_TIME                  m_rtDuration;
    MUSIC_TIME                      m_mtTimeLogical;
    DWORD                           m_dwFlags;
    IDirectSoundWave*               m_pWave;
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    BOOL                            m_fIsStreaming;
    BOOL                            m_fUseNoPreRoll;
    DWORD                           m_dwLoopStart;
    DWORD                           m_dwLoopEnd;
    DWORD                           m_dwVoiceIndex; // unique (to the track) index for state data's vaoice array

    static TList<TaggedWave>        st_WaveList;
    static CRITICAL_SECTION         st_WaveListCritSect;
};

struct WavePart
{
    WavePart() : m_dwPChannel(0), m_lVolume(0), m_dwLockToPart(0), 
        m_dwPChannelFlags(0), m_dwVariations(0), m_dwIndex(0)
    {
    }

    ~WavePart()
    {
        CleanUp();
    }

    HRESULT Load( IDMStream* pIRiffStream, MMCKINFO* pckParent );
    HRESULT CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        DWORD dwPChannel,
        REFGUID rguidVersion);
    HRESULT Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);

    DWORD               m_dwPChannel;
    DWORD               m_dwIndex; // Index to distinguish different parts on the same PChannel
    DWORD               m_lVolume;
    DWORD               m_dwVariations;    // variations enabled for this part
    DWORD               m_dwLockToPart;    // all parts with this ID are locked (0 means no locking)
    DWORD               m_dwPChannelFlags; // lowest-order nibble holds DMUS_VARIATIONT_TYPES value
    TList<WaveItem>     m_WaveItemList;
};

struct WaveDLOnPlay
{
    WaveDLOnPlay() : m_pWaveDL(NULL), m_pPort(NULL), m_pVoice(NULL) {}
    ~WaveDLOnPlay()
    {
        if (m_pPort)
        {
            if (m_pWaveDL)
            {
                m_pPort->UnloadWave(m_pWaveDL);
            }
            m_pWaveDL = NULL;
            m_pPort->Release();
            m_pPort = NULL;
        }
        if (m_pVoice)
        {
            m_pVoice->Release();
            m_pVoice = NULL;
        }
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    IDirectMusicPortP*             m_pPort;
    IDirectMusicVoiceP*            m_pVoice;
};

struct WaveStateData
{
    DWORD                       dwPChannelsUsed; // number of PChannels
    // the following array is allocated to the size of dwNumPChannels, which
    // must match the Wave Track's m_dwPChannelsUsed. The array matches one-for-one with
    // the parts inside the Wave Track.
    TListItem<WaveItem>**       apCurrentWave; // array of size dwNumPChannels
    DWORD                       dwValidate;
    DWORD                       dwGroupBits; // the group bits of this track
    DWORD*                      pdwVariations;      // array of variations (1 per part)
    DWORD*                      pdwRemoveVariations;    // array of variations already played (1 per part)
    DWORD                       adwVariationGroups[MAX_WAVE_VARIATION_LOCKS];
    REFERENCE_TIME              rtNextVariation; // time of next variation
    DWORD                       m_dwVariation;   // selected variations to audition
    DWORD                       m_dwPart;        // PChannel of part for auditioning variations
    DWORD                       m_dwIndex;       // Index of part for auditioning variations
    DWORD                       m_dwLockID;      // For locking to the part being auditioned
    BOOL                        m_fAudition;     // Am I auditioning variations?
    IDirectMusicPerformance*    m_pPerformance;
    IDirectMusicVoiceP**        m_apVoice;      // array of voices (one per wave item in track)
    DWORD                       m_dwVoices;     // number of voices in m_apVoice
    bool                        m_fLoop;        // set after the wave loops
    IDirectMusicAudioPath*      m_pAudioPath;   // audio path in effect for this track state
    TList<WaveDLOnPlay>         m_WaveDLList;   // waves downloaded while the track was playing

    WaveStateData() : dwPChannelsUsed(0), apCurrentWave(NULL), dwGroupBits(0),
        pdwVariations(NULL), pdwRemoveVariations(NULL), rtNextVariation(0),
        m_dwVariation(0), m_dwPart(0), m_dwIndex(0), m_dwLockID(0), m_fAudition(FALSE),
        m_pPerformance(NULL), m_apVoice(NULL), m_dwVoices(0), m_fLoop(false), m_pAudioPath(NULL)
    {
        for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
        {
            adwVariationGroups[i] = 0;
        }
    }

    ~WaveStateData()
    {
        if( apCurrentWave )
        {
            delete [] apCurrentWave;
        }
        if( pdwVariations )
        {
            delete [] pdwVariations;
        }
        if( pdwRemoveVariations )
        {
            delete [] pdwRemoveVariations;
        }
        if (m_apVoice)
        {
            for (DWORD dw = 0; dw < m_dwVoices; dw++)
            {
                if (m_apVoice[dw])
                {
                    m_apVoice[dw]->Release();
                }
            }
            delete [] m_apVoice;
        }
        if( m_pAudioPath )
        {
            m_pAudioPath->Release();
        }
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
    }

    HRESULT InitVariationInfo(DWORD dwVariations, DWORD dwPart, DWORD dwIndex, DWORD dwLockID, BOOL fAudition)
    {
        HRESULT hr = S_OK;
        m_dwVariation = dwVariations;
        m_dwPart = dwPart;
        m_dwIndex = dwIndex;
        m_dwLockID = dwLockID;
        m_fAudition = fAudition;
        return hr;
    }

    DWORD Variations(WavePart& rPart, int nPartIndex)
    {
        if (m_dwLockID && rPart.m_dwLockToPart == m_dwLockID)
        {
            TraceI(4, "Variations for locked part\n");
            return m_dwVariation;
        }
        else if ( m_fAudition &&
                  (rPart.m_dwPChannel == m_dwPart) &&
                  (rPart.m_dwIndex == m_dwIndex) )
        {
            TraceI(4, "Variations for current part\n");
            return m_dwVariation;
        }
        else
        {
            TraceI(4, "Variations for a different part\n");
            return pdwVariations[nPartIndex];
        }
    }

};

struct StatePair
{
    StatePair() : m_pSegState(NULL), m_pStateData(NULL) {}
    StatePair(const StatePair& rPair)
    {
        m_pSegState = rPair.m_pSegState;
        m_pStateData = rPair.m_pStateData;
    }
    StatePair(IDirectMusicSegmentState* pSegState, WaveStateData* pStateData)
    {
        m_pSegState = pSegState;
        m_pStateData = pStateData;
    }
    StatePair& operator= (const StatePair& rPair)
    {
        if (this != &rPair)
        {
            m_pSegState = rPair.m_pSegState;
            m_pStateData = rPair.m_pStateData;
        }
        return *this;
    }
    ~StatePair()
    {
    }
    IDirectMusicSegmentState*   m_pSegState;
    WaveStateData*          m_pStateData;
};

struct WavePair
{
    WavePair() : m_pWaveDL(NULL), m_pStateData(NULL) {}
    ~WavePair()
    {
        if (m_pWaveDL) m_pWaveDL->Release();
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    WaveStateData*                 m_pStateData;
};

/////////////////////////////////////////////////////////////////////////////
// CWavTrack
class CWavTrack : 
    public IPersistStream,
    public IDirectMusicTrack8,
    public IPrivateWaveTrack
{
public:
    CWavTrack();
    CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
    ~CWavTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
// IPersist methods
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream methods
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
//  IPrivateWaveTrack methods
    STDMETHODIMP SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex);
    STDMETHODIMP ClearVariations(IDirectMusicSegmentState* pSegState);
    STDMETHODIMP AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);
    STDMETHODIMP DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion);
    STDMETHODIMP UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk);
    STDMETHODIMP RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion);
    STDMETHODIMP FlushAllWaves();
    STDMETHODIMP OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData);
    // misc
    static HRESULT UnloadAllWaves(IDirectMusicPerformance* pPerformance);

protected:
    void Construct(void);
    HRESULT Play(
        void *pStateData,   
        REFERENCE_TIME rtStart, 
        REFERENCE_TIME rtEnd,
      //  MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,      
        IDirectMusicPerformance* pPerf, 
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        BOOL fClockTime);
    void InsertByAscendingPChannel( TListItem<WavePart>* pPart );
    HRESULT CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
    void CleanUpTempParts();
    void MovePartsToTemp();
    IDirectSoundDownloadedWaveP* FindDownload(TListItem<WaveItem>* pItem);
    void SetUpStateCurrentPointers(WaveStateData* pStateData);
    HRESULT STDMETHODCALLTYPE Seek( 
        IDirectMusicSegmentState*,
        IDirectMusicPerformance*,
        DWORD dwVirtualID,
        WaveStateData*,
        REFERENCE_TIME rtTime,
        BOOL fGetPrevious,
//      MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
    HRESULT SyncVariations(IDirectMusicPerformance* pPerf, 
        WaveStateData* pSD, 
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtOffset,  
        BOOL fClockTime);
    HRESULT ComputeVariations(WaveStateData* pSD);
    HRESULT ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD);
    WaveStateData* FindState(IDirectMusicSegmentState* pSegState);
    HRESULT InitTrack(DWORD dwPChannels);
    HRESULT GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice);
    void RemoveDownloads(WaveStateData* pStateData);

    static void FlushWaves();

// member variables
private:
    long                m_cRef;
    CRITICAL_SECTION    m_CrSec;
    BOOL                m_fCSInitialized;

    long                m_lVolume;
    DWORD               m_dwTrackFlags; // Only current flag is DMUS_WAVETRACKF_SYNC_VAR
    DWORD               m_dwPChannelsUsed;
    DWORD*              m_aPChannels;
    TList<WavePart>     m_WavePartList;
    TList<WavePart>     m_TempWavePartList; // keep this around when reloading the track
    DWORD               m_dwValidate; // used to validate state data
    CPChMap             m_PChMap;

    DWORD               m_dwVariation;   // selected variations to audition
    DWORD               m_dwPart;        // PChannel of part for auditioning variations
    DWORD               m_dwIndex;       // Index of part for auditioning variations
    DWORD               m_dwLockID;      // For locking to the part being auditioned
    BOOL                m_fAudition;     // Am I auditioning variations?
    BOOL                m_fAutoDownload;
    BOOL                m_fLockAutoDownload; // if true, this flag indicates that we've specifically
                                // commanded the band to autodownload. Otherwise,
                                // it gets its preference from the performance via
                                // GetGlobalParam.
    DWORD*              m_pdwVariations;        // Track's array of variations (1 per part)
    DWORD*              m_pdwRemoveVariations;  // Track's array of variations already played (1 per part)
    DWORD               m_dwWaveItems;          // Total number of wave items in the track

    TList<StatePair>    m_StateList;            // The track's state information
    TList<WavePair>     m_WaveList;             // Information about waves downloaded to the track

    static long         st_RefCount;            // global count of # of instantiated wave tracks
};

#endif //__WAVTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\ima.h ===
// Copyright (c) 1998 Microsoft Corporation
// IMA.h : Declaration of private interface for IMA legacy mode.
//
//

#ifndef __IMA_H_
#define __IMA_H_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif


#undef  INTERFACE
#define INTERFACE  IDirectMusicIMA
DECLARE_INTERFACE_(IDirectMusicIMA, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicIMA */
	STDMETHOD(LegacyCaching)		(THIS_ BOOL fEnable) PURE;
};

DEFINE_GUID(IID_IDirectMusicIMA,0xd2ac28b3, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef __IMA_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\guids.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
#include <objbase.h>
#include "initguid.h"
#include "dmusicc.h" 
#include "dmusici.h"
#include "loader.h"
#include "dmscriptautguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\dll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// loader dll.cpp
//
// Dll entry points and CLoaderFactory, CContainerFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <objbase.h>
#include "debug.h"

#include "oledll.h"
#include "debug.h" 
#include "dmusicc.h"
#include "dmusici.h" 
#include "loader.h"
#include "container.h"

#ifndef UNDER_CE
#include <regstr.h>
#endif

// Globals
//

// Version information for our class
//
TCHAR g_szFriendlyName[]        = TEXT("DirectMusicLoader");
TCHAR g_szVerIndProgID[]        = TEXT("Microsoft.DirectMusicLoader");
TCHAR g_szProgID[]              = TEXT("Microsoft.DirectMusicLoader.1");
TCHAR g_szContFriendlyName[]    = TEXT("DirectMusicContainer");
TCHAR g_szContVerIndProgID[]    = TEXT("Microsoft.DirectMusicContainer");
TCHAR g_szContProgID[]          = TEXT("Microsoft.DirectMusicContainer.1");

// Dll's hModule
//
HMODULE g_hModule = NULL; 

#ifndef UNDER_CE
// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;
#endif

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;




// CLoaderFactory::QueryInterface
//
HRESULT __stdcall
CLoaderFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CLoaderFactory::CLoaderFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CLoaderFactory::~CLoaderFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CLoaderFactory::AddRef
//
ULONG __stdcall
CLoaderFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CLoaderFactory::Release
//
ULONG __stdcall
CLoaderFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CLoaderFactory::CreateInstance
//
//
HRESULT __stdcall
CLoaderFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CLoader *pLoader;
    
    try
    {
        pLoader = new CLoader;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pLoader == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pLoader->Init();
    if (!SUCCEEDED(hr)) {
        delete pLoader;
        return hr;
    }

    hr = pLoader->QueryInterface(iid, ppv);
    pLoader->Release();
    
    return hr;
}

// CLoaderFactory::LockServer
//
HRESULT __stdcall
CLoaderFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// CContainerFactory::QueryInterface
//
HRESULT __stdcall
CContainerFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CContainerFactory::CContainerFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CContainerFactory::~CContainerFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CContainerFactory::AddRef
//
ULONG __stdcall
CContainerFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CContainerFactory::Release
//
ULONG __stdcall
CContainerFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CContainerFactory::CreateInstance
//
//
HRESULT __stdcall
CContainerFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CContainer *pContainer;
    
    try
    {
        pContainer = new CContainer;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pContainer == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pContainer->QueryInterface(iid, ppv);
    pContainer->Release();
    
    return hr;
}

// CContainerFactory::LockServer
//
HRESULT __stdcall
CContainerFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;

        if(clsid == CLSID_DirectMusicLoader)
        {
            pIUnknown = static_cast<IUnknown*> (new CLoaderFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }
        else if(clsid == CLSID_DirectMusicContainer)
        {
            pIUnknown = static_cast<IUnknown*> (new CContainerFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }

        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicLoader,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);
    UnregisterServer(CLSID_DirectMusicContainer,
                     g_szContFriendlyName,
                     g_szContVerIndProgID,
                     g_szContProgID);
    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicLoader,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicContainer,
                   g_szContFriendlyName,
                   g_szContVerIndProgID,
                   g_szContProgID);
    return S_OK; 
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            g_hModule = (HMODULE)hModule;
#ifndef UNDER_CE
            OSVERSIONINFO osvi;

            DisableThreadLibraryCalls(hModule);
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#endif
#ifdef DBG
			DebugInit();
#endif
		}
    }
#ifdef DBG
    else if(dwReason == DLL_PROCESS_DETACH) {
        if (--nReferenceCount == 0)
        {
            TraceI(-1, "Unloading DMLoader : g_cLock = %d, g_cComponent = %d", g_cLock, g_cComponent);

            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
        }
    }
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\container.cpp ===
//
// Container.cpp: Implementation of CContainer
//
// Copyright (c) 1999-2001 Microsoft Corporation
//

#include "dmusicc.h" 
#include "dmusici.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "container.h"
#include "debug.h"
#include "riff.h"
#include "dmscriptautguids.h"
#include "smartref.h"
#include "miscutil.h"
#ifdef UNDER_CE
#include "dragon.h"
#endif

extern long g_cComponent;

CContainerItem::CContainerItem(bool fEmbedded)

{
    m_Desc.dwSize = sizeof(m_Desc);
    m_Desc.dwValidData = 0;
    m_dwFlags = 0;
    m_pObject = NULL;
    m_fEmbedded = fEmbedded;
    m_pwszAlias = NULL;
}

CContainerItem::~CContainerItem()

{
    if (m_pObject)
    {
        m_pObject->Release();
    }
    if (m_Desc.dwValidData & DMUS_OBJ_STREAM)
    {
        SafeRelease(m_Desc.pStream);
    }
    delete m_pwszAlias;
}

CContainer::CContainer()
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwPartialLoad = 0;
    m_dwValidData = 0;
    m_pStream = NULL;
    m_fZombie = false;
}

CContainer::~CContainer()
{
    Clear();
    if (m_pStream)
    {
        m_pStream->Release();
    }
}

void CContainer::Clear()
{
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicGetLoader *pGetLoader = NULL;
    if (m_pStream)
    {
        m_pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
        if (pGetLoader)
        {
            pGetLoader->GetLoader(&pLoader);
            pGetLoader->Release();
        }
    }
    CContainerItem *pItem = m_ItemList.GetHead();
    CContainerItem *pNext;
    for (;pItem;pItem = pNext)
    {
        pNext = pItem->GetNext();
        if (pItem->m_pObject)
        {
            if (pLoader && !(pItem->m_dwFlags & DMUS_CONTAINED_OBJF_KEEP))
            {
                pLoader->ReleaseObject(pItem->m_pObject);
            }
            pItem->m_pObject->Release();
            pItem->m_pObject = NULL;
        }
        delete pItem;
    }
    if (pLoader)
    {
        pLoader->Release();
    }
}

STDMETHODIMP_(void) CContainer::Zombie()
{
    Clear();
    if (m_pStream)
    {
        m_pStream->Release();
        m_pStream = NULL;
    }
    m_fZombie = true;
}

STDMETHODIMP_(ULONG) CContainer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CContainer::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP CContainer::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IDirectMusicContainer) {
        *ppvObj = static_cast<IDirectMusicContainer*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicObject)
    {
        *ppvObj = static_cast<IDirectMusicObject*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicObjectP)
    {
        *ppvObj = static_cast<IDirectMusicObjectP*>(this);
    }
    else if (riid == IID_IPersistStream) 
    {
        *ppvObj = static_cast<IPersistStream*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

HRESULT CContainer::EnumObject(REFGUID rguidClass,
                               DWORD dwIndex,
                               LPDMUS_OBJECTDESC pDesc,
                               WCHAR *pwszAlias)
{
    V_INAME(CContainer::EnumObject);
    V_PTR_WRITE_OPT(pDesc, LPDMUS_OBJECTDESC);
    V_BUFPTR_WRITE_OPT(pwszAlias, MAX_PATH);
    V_REFGUID(rguidClass);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::EnumObject after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    CContainerItem *pItem = m_ItemList.GetHead();
    DWORD dwCounter = 0;
    HRESULT hr = S_FALSE;
    for (;pItem;pItem = pItem->GetNext())
    {
        if ((rguidClass == GUID_DirectMusicAllTypes) || 
            (rguidClass == pItem->m_Desc.guidClass))
        {
            if (dwCounter == dwIndex)
            {
                hr = S_OK;
                if (pDesc)
                {
                    DWORD dwCopySize = min(pDesc->dwSize,pItem->m_Desc.dwSize);
                    memcpy(pDesc,&pItem->m_Desc,dwCopySize);
                    if (pDesc->dwValidData & DMUS_OBJ_STREAM && pDesc->pStream)
                        pDesc->pStream->AddRef();
                }
                if (pwszAlias)
                {
                    hr = wcsTruncatedCopy(pwszAlias, pItem->m_pwszAlias ? pItem->m_pwszAlias : L"", MAX_PATH);
                }
                break;
            }
            dwCounter++;
        }
    }
    return hr;
}

HRESULT CContainer::Load(IStream* pStream, IDirectMusicLoader *pLoader)

{
    IRIFFStream *pRiffStream = NULL;
    HRESULT hr = AllocRIFFStream(pStream, &pRiffStream);
    if(FAILED(hr))
    {
        return hr;
    }

    MMCKINFO ckMain;

    ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;
    hr = pRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF);

    if(FAILED(hr))
    {
        pRiffStream->Release();
        return hr;
    }

    m_dwPartialLoad = FALSE;

    MMCKINFO ckNext;
    MMCKINFO ckUNFO;
    DWORD cbRead;
    DWORD cbSize;
    DMUS_IO_CONTAINER_HEADER ioHeader;
    
    ckNext.ckid = 0;
    ckNext.fccType = 0;

    hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
    while(SUCCEEDED(hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_CONTAINER_CHUNK :
            cbSize = min( sizeof(DMUS_IO_CONTAINER_HEADER), ckNext.cksize );
            hr = pStream->Read(&ioHeader, cbSize, &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwFlags = ioHeader.dwFlags;
            }
            break;
        case DMUS_FOURCC_GUID_CHUNK:
            cbSize = sizeof(GUID);
            if( ckNext.cksize == cbSize )
            {
                hr = pStream->Read( &m_guidObject, cbSize, &cbRead );
                if( SUCCEEDED(hr) && (cbRead == cbSize) )
                {
                    m_dwValidData |= DMUS_OBJ_OBJECT;
                }
            }
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pStream->Read(&m_vVersion, sizeof(DMUS_IO_VERSION), &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwValidData |= DMUS_OBJ_VERSION;
            }
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
        {
            cbSize = min(sizeof(m_wszCategory), ckNext.cksize);
            hr = pStream->Read(m_wszCategory, cbSize, &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwValidData |=  DMUS_OBJ_CATEGORY;
            }
        }
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pStream->Read(&(m_ftDate), sizeof(FILETIME), &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwValidData |=  DMUS_OBJ_DATE;
            }
            break;
        case FOURCC_LIST:
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
                case DMUS_FOURCC_UNFO_LIST:
                    while( pRiffStream->Descend( &ckUNFO, &ckNext, 0 ) == S_OK )
                    {
                        switch( ckUNFO.ckid )
                        {
                            case DMUS_FOURCC_UNAM_CHUNK:
                            {
                                cbSize = min(sizeof(m_wszName), ckUNFO.cksize);
                                hr = pStream->Read(&m_wszName, cbSize, &cbRead);
                                if(SUCCEEDED(hr))
                                {
                                    m_dwValidData |= DMUS_OBJ_NAME;
                                }
                                break;
                            }
                            default:
                                break;
                        }
                        pRiffStream->Ascend( &ckUNFO, 0 );
                    }
                    break;
                case DMUS_FOURCC_CONTAINED_OBJECTS_LIST :
                    hr = LoadObjects(pStream, pRiffStream, ckNext, pLoader);
                    break;
            }
            break;
        }
    
        if(SUCCEEDED(hr))
        {
            hr = pRiffStream->Ascend(&ckNext, 0);
        }

        if(SUCCEEDED(hr))
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
            hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
        }
    }

    // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
    // was reached before the desired chunk was found. In the usage 
    // above we will also get this error if we have finished parsing the file. 
    // So we need to set hr to S_OK since we are done
    hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;

    if (SUCCEEDED(hr))
    {
        // Ascend completely out of the container.
        hr = pRiffStream->Ascend(&ckMain, 0);
        if (!(m_dwFlags & DMUS_CONTAINER_NOLOADS))
        {
            for (CContainerItem *pItem = m_ItemList.GetHead();pItem;pItem = pItem->GetNext())
            {
                if (FAILED(pLoader->GetObject(&pItem->m_Desc,
                    IID_IDirectMusicObject,
                    (void **)&pItem->m_pObject)))
                {
                    hr = DMUS_S_PARTIALLOAD;
                }
            }
        }

        if (m_pStream)
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        m_pStream->AddRef();
    }

    if(pRiffStream)
    {
        pRiffStream->Release();
    }
    
    return hr;
}

HRESULT CContainer::LoadObjects(IStream *pStream, 
                                IRIFFStream *pRiffStream, 
                                MMCKINFO ckParent,
                                IDirectMusicLoader *pLoader)

{
    MMCKINFO ckNext;

    ckNext.ckid = 0;
    ckNext.fccType = 0;
    
    HRESULT hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
    
    while(SUCCEEDED(hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_RIFF:
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_CONTAINED_OBJECT_LIST :
                hr = LoadObject(pStream, pRiffStream, ckNext, pLoader);
                break;
            }
            break;
        }
    
        if(SUCCEEDED(hr))
        {
            hr = pRiffStream->Ascend(&ckNext, 0);
        }

        if(SUCCEEDED(hr))
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
            hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
        }
    }

    // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
    // was reached before the desired chunk was found. In the usage 
    // above we will also get this error if we have finished parsing the file. 
    // So we need to set hr to S_OK since we are done
    hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;
    return hr;
}

HRESULT CContainer::LoadObject(IStream* pStream, 
                              IRIFFStream *pRiffStream, 
                              MMCKINFO ckParent,
                              IDirectMusicLoader *pLoader)
{
    MMCKINFO ckNext, ckLast;

    ckNext.ckid = 0;
    ckNext.fccType = 0;

    DWORD cbRead;
    DWORD cbSize;
    
    DMUS_IO_CONTAINED_OBJECT_HEADER ioHeader;

    HRESULT hr = pRiffStream->Descend(&ckNext, &ckParent, 0);

    SmartRef::Buffer<WCHAR> wbufAlias;
    if(SUCCEEDED(hr))
    {
        if(ckNext.ckid == DMUS_FOURCC_CONTAINED_ALIAS_CHUNK)
        {
            if(ckNext.cksize % 2 != 0)
            {
                assert(false); // should be WCHARs -- two byte pairs
            }
            else
            {
                wbufAlias.Alloc(ckNext.cksize / 2);
                if (!wbufAlias)
                    return E_OUTOFMEMORY;
                hr = pStream->Read(wbufAlias, ckNext.cksize, &cbRead);
                if (FAILED(hr))
                    return hr;
            }

            pRiffStream->Ascend(&ckNext, 0);
            hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
        }
    }

    if(SUCCEEDED(hr))
    {        
        if(ckNext.ckid != DMUS_FOURCC_CONTAINED_OBJECT_CHUNK)
        {    
            Trace(1,"Invalid object in Container - cobh is not first chunk.\n");
            return DMUS_E_INVALID_CONTAINER_OBJECT;
        }    
        
        cbSize = sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER);
            
        hr = pStream->Read(&ioHeader, cbSize, &cbRead);
        
        if(FAILED(hr))
        {
            return hr;
        }
                
        if(ioHeader.ckid == 0 && ioHeader.fccType == NULL)
        {
            Trace(1,"Invalid object header in Container.\n");
            return DMUS_E_INVALID_CONTAINER_OBJECT;
        }
        // Move to start of next chunk.
        pRiffStream->Ascend(&ckNext, 0);
        ckLast = ckNext;    // Memorize this position.

        hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
        
        while(SUCCEEDED(hr))
        {
            if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
                && ckNext.fccType == ioHeader.fccType) ||
                (ckNext.ckid == ioHeader.ckid))
            {
                // Okay, this is the chunk we are looking for.
                // Seek back to start of chunk.
                bool fEmbedded = !(ckNext.ckid == FOURCC_LIST && ckNext.fccType == DMUS_FOURCC_REF_LIST);
                CContainerItem *pItem = new CContainerItem(fEmbedded);
                if (!pItem)
                    hr = E_OUTOFMEMORY;
                else
                {
                    if (fEmbedded)
                    {
                        // This is an embedded object.  Ascend to the position where from which it will be loaded.
                        pRiffStream->Ascend(&ckLast, 0);
                        pItem->m_Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                        pItem->m_Desc.guidClass = ioHeader.guidClassID;
                        pItem->m_Desc.pStream = pStream;
                        pStream->AddRef();
                    }
                    else
                    {
                        // This is a reference chunk.  Read the object descriptor.
                        hr = this->ReadReference(pStream, pRiffStream, ckNext, &pItem->m_Desc);
                    }

                    if (SUCCEEDED(hr))
                    {
                        // We will call SetObject on items in the container here.  The items are loaded later.
                        // This ensures that out-of-order references between objects can be retrieved as the objects
                        // load themselves.
                        pLoader->SetObject(&pItem->m_Desc);
                        if (pItem->m_Desc.dwValidData & DMUS_OBJ_STREAM)
                        {
                            // The loader has the stream now so we don't need it any more.
                            pItem->m_Desc.dwValidData &= ~DMUS_OBJ_STREAM;
                            SafeRelease(pItem->m_Desc.pStream);
                        }

                        pItem->m_pwszAlias = wbufAlias.disown();
                        m_ItemList.AddTail(pItem);
                    }
                    else
                        delete pItem;
                }
            }

            if(SUCCEEDED(hr))
            {
                pRiffStream->Ascend(&ckNext, 0);
                ckLast = ckNext;
                {
                    ckNext.ckid = 0;
                    ckNext.fccType = 0;
                    hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
                }
            }
        }

        // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
        // was reached before the desired chunk was found. In the usage 
        // above we will also get this error if we have finished parsing the file. 
        // So we need to set hr to S_OK since we are done
        hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;
    }
    return hr;
}

HRESULT
CContainer::ReadReference(IStream* pStream, 
                          IRIFFStream *pRiffStream, 
                          MMCKINFO ckParent,
                          DMUS_OBJECTDESC *pDesc)
{
    // I can't believe I'm writing this function!  It's copied right out of WaveItem::LoadReference and modified to work here.
    // This really aught to be shared code, but the other components all use different stream reader thingies than IRIFFStream
    // so that won't work.

    if (!pStream || !pRiffStream || !pDesc)
    {
        assert(false);
        return E_INVALIDARG;
    }

    ZeroAndSize(pDesc);

    DWORD cbRead;

    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;

    HRESULT hr = S_OK;
    while( pRiffStream->Descend( &ckNext, &ckParent, 0 ) == S_OK )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->guidClass = ioDMRef.guidClassID;
                    pDesc->dwValidData |= ioDMRef.dwValidData;
                    pDesc->dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(pDesc->guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(pDesc->ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->dwValidData |=  DMUS_OBJ_DATE;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(pDesc->wszName), ckNext.cksize);
                hr = pStream->Read(pDesc->wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->wszName[DMUS_MAX_NAME - 1] = L'\0';
                    pDesc->dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(pDesc->wszFileName), ckNext.cksize);
                hr = pStream->Read(pDesc->wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    pDesc->dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(pDesc->wszCategory), ckNext.cksize);
                hr = pStream->Read(pDesc->wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    pDesc->dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    pDesc->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            default:
                break;
        }

        if(SUCCEEDED(hr) && pRiffStream->Ascend(&ckNext, 0) == S_OK)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
    }

    if (!(pDesc->dwValidData &  DMUS_OBJ_NAME) && 
        !(pDesc->dwValidData &  DMUS_OBJ_FILENAME) &&
        !(pDesc->dwValidData &  DMUS_OBJ_OBJECT) )
    {
        Trace(1,"Error: Incomplete object reference in Container - DMRF must specify an object name, filename, or GUID.\n");
        hr = DMUS_E_INVALID_CONTAINER_OBJECT;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CContainer::GetClassID( CLSID* pClassID )
{
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::GetClassID after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    if (pClassID)
    {
        *pClassID = CLSID_DirectMusicContainer;
        return S_OK;
    }
    return E_POINTER;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CContainer::IsDirty()
{
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::IsDirty after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    return S_FALSE;
}

HRESULT CContainer::Load( IStream* pStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pStream);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::Load after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicGetLoader *pGetLoader = NULL;
    if (pStream)
    {
        pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
        if (pGetLoader)
        {
            pGetLoader->GetLoader(&pLoader);
            pGetLoader->Release();
        }
    }
    if (pLoader)
    {
        HRESULT hr = Load(pStream, pLoader);
        pLoader->Release();
        return hr;
    }
    Trace(1, "Error: unable to load container from a stream because it doesn't support the IDirectMusicGetLoader interface.\n");
    return DMUS_E_UNSUPPORTED_STREAM;
}


HRESULT CContainer::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CContainer::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CContainer::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::GetDescriptor after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicContainer;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CContainer::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CContainer::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC); 
    
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::SetDescriptor after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    HRESULT hr = S_OK;
    DWORD dw = 0;

    if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
    {
        m_guidObject = pDesc->guidObject;
        dw |= DMUS_OBJ_OBJECT;
    }
    if( pDesc->dwValidData & DMUS_OBJ_NAME )
    {
        memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
        dw |= DMUS_OBJ_NAME;
    }
    if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
    {
        memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
        dw |= DMUS_OBJ_CATEGORY;
    }
    if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
        ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
    {
        memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
        dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
    }
    if( pDesc->dwValidData & DMUS_OBJ_VERSION )
    {
        m_vVersion = pDesc->vVersion;
        dw |= DMUS_OBJ_VERSION;
    }
    if( pDesc->dwValidData & DMUS_OBJ_DATE )
    {
        m_ftDate = pDesc->ftDate;
        dw |= DMUS_OBJ_DATE;
    }
    m_dwValidData |= dw;
    if( pDesc->dwValidData & (~dw) )
    {
        hr = S_FALSE; // there were extra fields we didn't parse;
        pDesc->dwValidData = dw;
    }

    return hr;
}

STDMETHODIMP CContainer::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CContainer::ParseDescriptor);
    V_INTERFACE(pStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::ParseDescriptor after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    IRIFFStream *pRiffStream = NULL;
    HRESULT hr = AllocRIFFStream(pStream, &pRiffStream);
    if (FAILED(hr))
        return hr;

    MMCKINFO ckMain;

    ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;
    hr = pRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF);

    if(FAILED(hr))
    {
        pRiffStream->Release();
        return hr;
    }

    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicContainer;

    MMCKINFO ckNext;
    MMCKINFO ckUNFO;
    DWORD cbRead;
    DWORD cbSize;
    
    ckNext.ckid = 0;
    ckNext.fccType = 0;

    hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
    while(SUCCEEDED(hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            cbSize = sizeof(GUID);
            if( ckNext.cksize == cbSize )
            {
                hr = pStream->Read( &pDesc->guidObject, cbSize, &cbRead );
                if( SUCCEEDED(hr) && (cbRead == cbSize) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
            }
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pStream->Read(&pDesc->vVersion, sizeof(DMUS_IO_VERSION), &cbRead);
            if(SUCCEEDED(hr))
            {
                pDesc->dwValidData |= DMUS_OBJ_VERSION;
            }
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
        {
            cbSize = min(sizeof(pDesc->wszCategory), ckNext.cksize);
            hr = pStream->Read(pDesc->wszCategory, cbSize, &cbRead);
            if(SUCCEEDED(hr))
            {
                pDesc->dwValidData |=  DMUS_OBJ_CATEGORY;
            }
        }
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pStream->Read(&(pDesc->ftDate), sizeof(FILETIME), &cbRead);
            if(SUCCEEDED(hr))
            {
                pDesc->dwValidData |=  DMUS_OBJ_DATE;
            }
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
                case DMUS_FOURCC_UNFO_LIST:
                    while( pRiffStream->Descend( &ckUNFO, &ckNext, 0 ) == S_OK )
                    {
                        switch( ckUNFO.ckid )
                        {
                            case DMUS_FOURCC_UNAM_CHUNK:
                            {
                                cbSize = min(sizeof(pDesc->wszName), ckUNFO.cksize);
                                hr = pStream->Read(&pDesc->wszName, cbSize, &cbRead);
                                if(SUCCEEDED(hr))
                                {
                                    pDesc->dwValidData |= DMUS_OBJ_NAME;
                                }
                                break;
                            }
                            default:
                                break;
                        }
                        pRiffStream->Ascend( &ckUNFO, 0 );
                    }
                    break;
            }
            break;
        }
    
        if(SUCCEEDED(hr))
        {
            hr = pRiffStream->Ascend(&ckNext, 0);
        }

        if(SUCCEEDED(hr))
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
            hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
        }
    }

    // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
    // was reached before the desired chunk was found. In the usage 
    // above we will also get this error if we have finished parsing the file. 
    // So we need to set hr to S_OK since we are done
    hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;

    if(pRiffStream)
    {
        pRiffStream->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\container.h ===
// Copyright (c) 1999 Microsoft Corporation
// container.h : Declaration of the CContainer

#ifndef __CONTAINER_H_
#define __CONTAINER_H_
#include "alist.h"
#include "riff.h"
#include "..\shared\dmusicp.h"

class CContainer;
class CContainerItem : public AListItem
{
public:
                        CContainerItem(bool fEmbedded);
                        ~CContainerItem();
    CContainerItem *    GetNext() {return(CContainerItem *)AListItem::GetNext();};
    IDirectMusicObject *m_pObject;
    DWORD               m_dwFlags;
    DMUS_OBJECTDESC     m_Desc;     // Stored description of object.
    bool                m_fEmbedded; // This is an embedded (as opposed to referenced) object.
    WCHAR *             m_pwszAlias;
};

class CContainerItemList : public AList
{
public:
    CContainerItem *	GetHead() {return (CContainerItem *)AList::GetHead();};
    CContainerItem *	RemoveHead() {return (CContainerItem *)AList::RemoveHead();};
    void                AddTail(CContainerItem * pItem) { AList::AddTail((AListItem *)pItem);};
};

class CContainer : 
    public IDirectMusicContainer,
    public IDirectMusicObject,
    public IPersistStream,
    public IDirectMusicObjectP
{
public:
    CContainer::CContainer();
    CContainer::~CContainer();
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicContainer
    STDMETHODIMP EnumObject(REFGUID rguidClass,
        DWORD dwIndex,
        LPDMUS_OBJECTDESC pDesc,
        WCHAR *pwszAlias);

    // IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

private:
    void    Clear();    // Remove all object references.
    HRESULT Load(IStream* pStream, IDirectMusicLoader *pLoader);
    HRESULT LoadObjects(IStream *pStream, 
                        IRIFFStream *pRiffStream, 
                        MMCKINFO ckParent,
                        IDirectMusicLoader *pLoader);
    HRESULT LoadObject(IStream* pStream, 
                      IRIFFStream *pRiffStream, 
                      MMCKINFO ckParent,
                      IDirectMusicLoader *pLoader);
    HRESULT ReadReference(IStream* pStream, 
                          IRIFFStream *pRiffStream, 
                          MMCKINFO ckParent,
                          DMUS_OBJECTDESC *pDesc);

    IStream *           m_pStream;  // Pointer to stream this was loaded from.
                                    // This also provides access to the loader, indirectly.
    CContainerItemList  m_ItemList; // List of objects that were loaded by container. 
    long                m_cRef;     // COM reference counter.
    DWORD               m_dwFlags;  // Flags loaded from file.
    DWORD               m_dwPartialLoad; // Used to keep track of partial load.
    // IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                           /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                         /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */

    bool                m_fZombie;
};

#endif //__CONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMLOADER"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\loader.cpp ===
//
// Loader.cpp : Implementation of CLoader
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "dmusicc.h" 
#include "dmusici.h" 
#include "validate.h"
#include "loader.h"
#include "debug.h"
#include "riff.h"
#include "dmscriptautguids.h"
#include "miscutil.h"
#ifdef UNDER_CE
#include "dragon.h"
#else
extern BOOL g_fIsUnicode;
#endif

extern long g_cComponent;

/////////////////////////////////////////////////////////////////////////////
// CLoader

static HRESULT GetRegStringW( HKEY hKey, WCHAR* lpSubKey, WCHAR* lpValueName, WCHAR* lpwzString )
{
    HKEY  hKeyOpen;
    DWORD dwType;
    DWORD dwCbData;
    LONG  lResult;

    lpwzString[0] = L'\0';
    lResult = RegOpenKeyExW( hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKeyOpen );
    if( lResult == ERROR_SUCCESS )
    {
        dwCbData = MAX_PATH * sizeof(WCHAR);
        lResult = RegQueryValueExW( hKeyOpen, lpValueName, NULL, &dwType, (LPBYTE)lpwzString, &dwCbData );
        if( lResult != ERROR_SUCCESS )
        {
            lpwzString[0] = L'\0';
        }
        else
        {
#ifndef UNDER_CE        
            if( dwType == REG_EXPAND_SZ )
            {
                WCHAR wzTemp[MAX_PATH];
                if( ExpandEnvironmentStringsW( lpwzString, wzTemp, MAX_PATH ) )
                {
                    wcscpy(lpwzString, wzTemp);
                }
                else
                {
                    lpwzString[0] = L'\0';
                }
            }
            else
#endif
            if( dwType != REG_SZ )
            {
                lpwzString[0] = L'\0';
            }
        }
        RegCloseKey( hKeyOpen );
    }
    return lResult;
}

#ifndef UNDER_CE

static HRESULT GetRegStringA( HKEY hKey, LPCSTR lpSubKey, LPSTR lpValueName, LPSTR lpszString )
{
    HKEY  hKeyOpen;
    DWORD dwType;
    DWORD dwCbData;
    LONG  lResult;

    lpszString[0] = '\0';
    lResult = RegOpenKeyEx( hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKeyOpen );
    if( lResult == ERROR_SUCCESS )
    {
        dwCbData = MAX_PATH;
        lResult = RegQueryValueExA( hKeyOpen, lpValueName, NULL, &dwType, (LPBYTE)lpszString, &dwCbData );
        if( lResult != ERROR_SUCCESS )
        {
            lpszString[0] = '\0';
        }
        else
        {
            if( dwType == REG_EXPAND_SZ )
            {
                char szTemp[MAX_PATH];
                if( ExpandEnvironmentStringsA( lpszString, szTemp, MAX_PATH ) )
                {
                    strcpy(lpszString, szTemp);
                }
                else
                {
                    lpszString[0] = '\0';
                }
            }
            else if( dwType != REG_SZ )
            {
                lpszString[0] = '\0';
            }
        }
        RegCloseKey( hKeyOpen );
    }
    return lResult;
}
#endif

HRESULT CLoader::Init()

{
#ifndef UNDER_CE
    char szGMFile[MAX_PATH];
#endif    
    WCHAR wzGMFile[MAX_PATH];
    // First, get the GM path from the registry, if it exists.
    HRESULT hr;
#ifndef UNDER_CE    
    if( g_fIsUnicode )
#endif
    {
        hr = GetRegStringW( HKEY_LOCAL_MACHINE,
              L"Software\\Microsoft\\DirectMusic",
              L"GMFilePath",
              wzGMFile );
    }
#ifndef UNDER_CE
    else
    {
        hr = GetRegStringA( HKEY_LOCAL_MACHINE,
              "Software\\Microsoft\\DirectMusic",
              "GMFilePath",
              szGMFile );
        mbstowcs(wzGMFile,szGMFile,MAX_PATH);
    }
#endif    
    if (hr == S_OK)
    {
        DMUS_OBJECTDESC DESC;                    // Descriptor to use to find it.
        memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
        DESC.dwSize = sizeof (DMUS_OBJECTDESC);
        DESC.guidClass = CLSID_DirectMusicCollection;  
        wcscpy(DESC.wszFileName,wzGMFile);
        DESC.guidObject = GUID_DefaultGMCollection;
        DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | 
            DMUS_OBJ_FULLPATH | DMUS_OBJ_OBJECT;
        SetObject(&DESC);
    }
    // prepare root node for garbage collection
    assert(!m_pApplicationObject); // this would fail if Init were called twice, which it shouldn't be
    m_pApplicationObject = new CObject(NULL);
    if (!m_pApplicationObject)
        return E_OUTOFMEMORY;
    hr = m_pApplicationObject->GC_Collectable();
    if (FAILED(hr))
    {
        delete m_pApplicationObject;
        m_pApplicationObject = NULL;
        return hr;
    }
    m_pLoadedObjectContext = m_pApplicationObject;

    return S_OK;
}


CLoader::CLoader()
  : m_pLoadedObjectContext(NULL),
    m_pApplicationObject(NULL)
{
    m_fCSInitialized = FALSE;

    InterlockedIncrement(&g_cComponent);
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    m_fPathValid = FALSE;
    m_fKeepObjects = TRUE;
    m_cRef = 1;
    m_cPRef = 0;
    m_fIMA = FALSE;
}

CLoader::~CLoader()

{
    if (m_fCSInitialized)
    {
        // If critical section never initialized, never got a chance
        // to put anything in this list
        //
        while (!m_ClassList.IsEmpty())
        {
            CClass *pClass = m_ClassList.RemoveHead();
            delete pClass;
        }

        while (!m_ReleasedObjectList.IsEmpty())
        {
            CObject *pObject = m_ReleasedObjectList.RemoveHead();
            delete pObject;
        }

        DeleteCriticalSection(&m_CriticalSection);
    }

    delete m_pApplicationObject;

    InterlockedDecrement(&g_cComponent);
}

// CLoader::QueryInterface
//
STDMETHODIMP
CLoader::QueryInterface(const IID &iid,
                                   void **ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicLoader || iid == IID_IDirectMusicLoader8) {
        *ppv = static_cast<IDirectMusicLoader8*>(this);
    }
    else if(iid == IID_IDirectMusicLoader8P)
    {
        *ppv = static_cast<IDirectMusicLoader8P*>(this);
    }
    else if(iid == IID_IDirectMusicIMA)
    {
        *ppv = static_cast<IDirectMusicIMA*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CLoader::AddRef
//
STDMETHODIMP_(ULONG)
CLoader::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CLoader::AddRefP()
{
    return InterlockedIncrement(&m_cPRef);
}

// CLoader::Release
//
STDMETHODIMP_(ULONG)
CLoader::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        // Ref count of zero indicates that no objects are currently using the loader except for streams.
        // Streams support the GetLoader method and hence we can't delete the loader yet.  These streams
        //    hold private references (AddRefP/ReleaseP).
        // Since no objects other than those streams are currently being used, we'll clear our cache.
        //    This will release any of the Loader's refs on the streams and (assuming nobody else is
        //    holding the streams) bring the private ref count down to zero so we can delete ourself.

        InterlockedIncrement(&m_cRef);        // Keep streams from deleting loader.
        ClearCacheInternal(GUID_DirectMusicAllTypes, true);
        CollectGarbage();
        if (!InterlockedDecrement(&m_cRef))
        {
            if (!m_cPRef)
            {
                delete this;
                return 0;
            }
        }
    }
    return m_cRef;
}

ULONG CLoader::ReleaseP()
{
    if (!InterlockedDecrement(&m_cPRef)) 
    {
        if (!m_cRef)
        {
            delete this;
            return 0;
        }
    }
    return m_cPRef;
}

HRESULT CLoader::GetClass(CDescriptor *pDesc, CClass **ppClass, BOOL fCreate)

/*    Scan the class list and find the matching class. 
    If the class can not be found AND fCreate is TRUE,
    create a new class.
*/

{
    *ppClass = NULL;
    if ((pDesc->m_dwValidData & DMUS_OBJ_CLASS) == 0) // We must have a valid class id.
    {
        Trace(1, "The class id field is required and missing in the DMUS_OBJECTDESC.\n");
        return DMUS_E_LOADER_NOCLASSID;
    }
    CClass *pClass = m_ClassList.GetHead();
    for (;pClass != NULL;pClass = pClass->GetNext())
    {
        if (pClass->m_ClassDesc.m_guidClass == pDesc->m_guidClass)
        {
            *ppClass = pClass;
            break;
        }
    }
    if (*ppClass == NULL)
    {
        if (fCreate)
        {
            pClass = new CClass(this, pDesc);
            if (pClass)
            {
                m_ClassList.AddHead(pClass);
                *ppClass = pClass;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
#ifdef DBG
            WCHAR *polestrClsid = NULL;
            if (S_OK != ProgIDFromCLSID(pDesc->m_guidClass, &polestrClsid))
            {
                StringFromCLSID(pDesc->m_guidClass, &polestrClsid);
            }
            if (polestrClsid)
                Trace(1, "There are no objects of type %S in the loader.\n", polestrClsid);
            CoTaskMemFree(polestrClsid);
#endif
            return DMUS_E_LOADER_OBJECTNOTFOUND;
        }
    }
    return S_OK;
}

#ifdef DBG
const int GC_Report_DebugLevel = 4;

void GC_Report(CLoader *pThis)
{
    struct LocalFunc
    {
        static void ReportObject(CObject *pObject, bool fReportGC, CObject *pApplicationObject)
        {
            if (!(pObject->m_dwScanBits & SCAN_GC) == !fReportGC)
            {
                DMUS_OBJECTDESC desc;
                ZeroMemory(&desc, sizeof(desc));
                pObject->m_ObjectDesc.Get(&desc);
                DebugTrace(GC_Report_DebugLevel, "   *%08X %S [%S]\n", pObject, desc.wszName, desc.wszFileName);
                if (!(desc.dwValidData & DMUS_OBJ_LOADED))
                {
                    DebugTrace(GC_Report_DebugLevel, "     Not loaded.\n");
                }

                if (fReportGC)
                {
                    // check if object is referenced by the app
                    for (UINT i = 0; i < pApplicationObject->m_pvecReferences->size(); ++i)
                    {
                        if (pObject == (*pApplicationObject->m_pvecReferences)[i])
                        {
                            DebugTrace(GC_Report_DebugLevel, "     In use by application.\n");
                        }
                    }

                    // output the object's references
                    assert(pObject->m_pvecReferences);
                    for (i = 0; i < pObject->m_pvecReferences->size(); ++i)
                    {
                        CObject *pObjectRef = (*pObject->m_pvecReferences)[i];
                        DMUS_OBJECTDESC descRef;
                        ZeroMemory(&descRef, sizeof(descRef));
                        pObjectRef->m_ObjectDesc.Get(&descRef);
                        DebugTrace(GC_Report_DebugLevel, "     -%08X %S (%S)\n", pObjectRef, descRef.wszName, descRef.wszFileName);
                    }
                }
            }
        }
    };

    SmartRef::CritSec CS(&pThis->m_CriticalSection);

    DebugTrace(GC_Report_DebugLevel, "Cached non-GC contents of DirectMusic Loader:\n");

    // Do two passes.  One to report non-GC items, one to report GC items.
    for (int fReportGC = 0; fReportGC < 2; ++fReportGC)
    {
        for (CClass *pClass = pThis->m_ClassList.GetHead(); pClass != NULL; pClass = pClass->GetNext())
        {
            for (CObject *pObject = pClass->m_ObjectList.GetHead(); pObject; pObject = pObject->GetNext())
            {
                LocalFunc::ReportObject(pObject, !!fReportGC, pThis->m_pApplicationObject);
            }
        }

        DebugTrace(GC_Report_DebugLevel, !fReportGC ? "Cached garbage-collected contents:\n" : "Contents released from the cache that aren't yet garbage or haven't been collected:\n");
    }

    for (CObject *pObject = pThis->m_ReleasedObjectList.GetHead(); pObject; pObject = pObject->GetNext())
    {
        assert(pObject->m_dwScanBits & SCAN_GC);
        LocalFunc::ReportObject(pObject, true, pThis->m_pApplicationObject);
    }

    DebugTrace(GC_Report_DebugLevel, "End of cache report.\n\n");
}
#endif

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | GetObject | Retrieves 
the specified object, potentially by loading it from a file.

@rdesc Returns one of the following

@flag S_OK | Success.
@flag E_OUTOFMEMORY | Insufficient memory to create the object.
@flag E_POINTER | Bad pointer. 
@flag E_INVALIDARG | The size of the passed <p pDESC> was too small.
@flag E_NOINTERFACE | The requested object does not support the requested interface.
@flag REGDB_E_CLASSNOTREG | Object class is not registered.
@flag DMUS_E_LOADER_NOCLASSID | No class id in <t DMUS_OBJECTDESC>.
@flag DMUS_E_LOADER_FAILEDOPEN | File open failed - either file doesn't exist or is locked.
@flag DMUS_E_LOADER_FORMATNOTSUPPORTED | Search data type is not supported.
@flag DMUS_E_LOADER_FAILEDCREATE | Unable to find or create object.
For example, DMUS_OBJ_URL will return this error in the initial
release of DirectMusic's loader.

@comm This is the heart of the DirectMusicLoader system. Typically, you
can use <om IDirectMusicLoader::GetObject> as a quick way to load
objects from disk. To do so, create a <t DMUS_OBJECTDESC> structure and
fill all appropriate fields. Usually, the file path will suffice,
though you can also request an object by name or GUID. 

<om IDirectMusicLoader::GetObject> compares its internal
database with the object described by <t DMUS_OBJECTDESC>. If it can
find it, it loads the object and returns a pointer to the 
requested interface of the requested object (all
DirectMusic compatible objects must implement an <i IDirectMusicObject>
interface as well as an <i IPersistStream> interface for loading
from a stream.)

<om IDirectMusicLoader::GetObject> prioritizes its search as follows:
1. DMUS_OBJ_OBJECT, 
2. DMUS_OBJ_FILENAME AND DMUS_OBJ_FULLPATH,
3. DMUS_OBJ_NAME AND DMUS_OBJ_CATEGORY,
4. DMUS_OBJ_NAME,
5. DMUS_OBJ_FILENAME

In other words, the highest priority goes to a unique GUID, followed by
the full file path name, followed by internal name plus category,
followed by internal name, followed by local file name.

@ex The following example uses <om IDirectMusicLoader::GetObject> to
load a DirectMusic style from a file on disk: |

    void myLoadStyle(
        IDirectMusicStyle **ppIStyle)        // Style that we wish to load.
    {
        IDirectMusicLoader *pILoader;        // Loader interface.

        // Typically, you should create the loader once, and use it
        // for the duration of the application. This reduces overhead and
        // takes advantage of the loader's ablilty to cache objects.
        // However, for purposes of this example, we create it dynamically
        // and throw it away once the style is loaded.

        CoCreateInstance(
            CLSID_DirectMusicLoader,NULL, 
            CLSCTX_INPROC_SERVER,
            IID_IDirectMusicLoader,
            (void **) &pILoader);

        if (pILoader)
        {
            DMUS_OBJECTDESC Desc;           // Descriptor.

            // Start by initializing Desc with the file name and GUID
            // for style object.

            wcscpy(Desc.wszFileName,L"c:\\mymusic\\funky\\polka.sty");
            Desc.guidClass = CLSID_DirectMusicStyle;   // Style class.
            Desc.dwSize = sizeof (DMUS_OBJECTDESC);
            Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH;

            pILoader->GetObject(&Desc, IID_IDirectMusicStyle, (void**) ppIStyle);
            pILoader->Release();
        }
    }

    // At this point, the style is loaded is returned in ppIStyle.

@xref <i IDirectMusicLoader>, <i IDirectMusicObject>, <t DMUS_OBJECTDESC>
*/

STDMETHODIMP CLoader::LoadObjectFromFile(REFGUID rguidClassID, 
                                            REFIID iidInterfaceID, 
                                            WCHAR *pwzFilePath, 
                                            void ** ppObject)

{
    V_INAME(IDirectMusicLoader8::LoadObjectFromFile);
    V_BUFPTR_READ(pwzFilePath,2);

    HRESULT hr;
    DMUS_OBJECTDESC DESC;
    DESC.dwSize = sizeof (DESC);
    DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH;
    wcscpy(DESC.wszFileName,pwzFilePath);
    DESC.guidClass = rguidClassID;  
    hr = GetObject(&DESC, iidInterfaceID, ppObject);
    if (FAILED(hr))
    {
        DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
        hr = GetObject(&DESC, iidInterfaceID, ppObject);
    }
    return hr;
}


STDMETHODIMP CLoader::GetObject(
    LPDMUS_OBJECTDESC pDESC,    // @parm Description of the requested object in <t DMUS_OBJECTDESC> structure.
    REFIID riid, //@parm The interface to return in <p ppv>
    LPVOID FAR *ppv)    // @parm Receives the interface on success.

{
    HRESULT hr = S_OK;
    HRESULT hrLoad = S_OK;
    CDescriptor Desc;

    V_INAME(IDirectMusicLoader::GetObject);
//    V_STRUCTPTR_READ(pDESC,DMUS_OLDOBJECTDESC); 
    V_PTRPTR_WRITE(ppv);

    IStream *pStream = pDESC->dwValidData & DMUS_OBJ_STREAM ? pDESC->pStream : NULL;
    if (pStream)
    {
        V_INTERFACE(pStream);
    }

    // if pDESC has DMUS_OBJ_FULLPATH set, set DMUS_OBJ_FILENAME as well.
    if( pDESC->dwValidData & DMUS_OBJ_FULLPATH )
    {
        pDESC->dwValidData |= DMUS_OBJ_FILENAME;
    }
    IDirectMusicObject* pDMObj;
    EnterCriticalSection(&m_CriticalSection);
    CClass *pClass;
    CObject *pObject = NULL;

    if (pStream)
    {
        // The loader will save a cloned stream so that it doesn't interfere with
        // the application reading from the stream.
        // Don't worry -- then we'll restore the original stream pointer.
        hr = pStream->Clone(&pDESC->pStream);
        if(FAILED(hr))
        {
            return E_OUTOFMEMORY;
        }
    }
    
    Desc.Set(pDESC);
    if (pStream)
    {
        // Restore the stream in the descriptor we were passed.
        pDESC->pStream->Release(); // release matching call to Clone (ref is now held in descriptor)
        pDESC->pStream = pStream;
    }

    hr = GetClass(&Desc,&pClass, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pClass->GetObject(&Desc,&pObject);
        if (SUCCEEDED(hr))
        {
            bool fKeep = !!pClass->m_fKeepObjects;
            bool fGC = fKeep && m_pLoadedObjectContext && m_pLoadedObjectContext->m_dwScanBits & SCAN_GC;

            if (pObject->m_pIDMObject) // Already loaded!
            {
                pObject->m_pIDMObject->AddRef();
                pDMObj = pObject->m_pIDMObject;
                hr = S_OK;
            }
            else
            {
                CObject *pPrevContext;
                if (fGC)
                {
                    // Save a pointer to the current object that will be used to track that it is
                    // the source object if nested calls to GetObject occur while it is loaded.
                    pPrevContext = m_pLoadedObjectContext;
                    m_pLoadedObjectContext = pObject;

                    // Set this object as garbage-collectable.
                    if (pObject->m_ObjectDesc.m_guidObject != GUID_DefaultGMCollection) // don't cache GM DLS set
                        hr = pObject->GC_Collectable();
                }
                if (SUCCEEDED(hr))
                    hrLoad = hr = pObject->Load();
                if (fGC)
                {
                    // Restore the context that was used to load this object.
                    m_pLoadedObjectContext = pPrevContext;
                }

#ifdef DBG
                if (FAILED(hrLoad) || m_pLoadedObjectContext == m_pApplicationObject)
                {
                    DebugTraceLoadFailure(pObject, hrLoad);
                }
#endif

                if (SUCCEEDED(hr))
                {
                    pDMObj = pObject->m_pIDMObject;
                    if (fKeep)
                    {
                        pObject->m_pIDMObject->AddRef();
                    }
                    else
                    {
                        pObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
                        pObject->m_pIDMObject = NULL;
                    }
                }
            }

            if (SUCCEEDED(hr) && fGC)
            {
                assert(m_pLoadedObjectContext);
                hr = m_pLoadedObjectContext->GC_AddReference(pObject);
            }

            if (FAILED(hr))
            {
                // This happens if either GC_AddReference or Load fails.
                pClass->RemoveObject(pObject);
                pObject = NULL;
                if (Desc.m_dwValidData & DMUS_OBJ_URL)
                {
                    Trace(1, "Error: Attempt to load an object via DMUS_OBJ_URL failed because the DirectMusic Loader doesn't currently support loading objects by URL.");
                    hr = DMUS_E_LOADER_FORMATNOTSUPPORTED;
                }
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if( SUCCEEDED(hr) )
    {
        hr = pDMObj->QueryInterface( riid, ppv );
        pDMObj->Release();
    }
    if( E_FAIL == hr )
    {
        hr = DMUS_E_LOADER_FAILEDCREATE;
    }

#ifdef DBG
    // After each top-level call to GetObject, report to debug output the contents of the cache.
    if (m_pLoadedObjectContext == m_pApplicationObject)
        GC_Report(this);
#endif

    if( SUCCEEDED(hr) )
    {
        return hrLoad;
    }
    else
    {
        return hr;
    }
}

STDMETHODIMP CLoader::SetObject(
    LPDMUS_OBJECTDESC pDESC)

{
    HRESULT hr = S_OK;
    HRESULT hrLoad = S_OK;
    CDescriptor Desc;

    V_INAME(IDirectMusicLoader::SetObject);
    V_STRUCTPTR_READ(pDESC,DMUS_OLDOBJECTDESC);

    IStream *pStream = NULL;
    if (pDESC->dwValidData & DMUS_OBJ_STREAM)
    {
        // Save the stream we were passed and verify it is a valid interface.
        pStream = pDESC->pStream;
        V_INTERFACE(pStream);

        // The loader will save a cloned stream so that the caller can contine
        // using the passed stream without intefering with the loader.
        // Don't worry -- we'll restore the original stream pointer before returning.
        hr = pStream->Clone(&pDESC->pStream);
        if (FAILED(hr))
            return hr;
    }

    // if pDESC has DMUS_OBJ_FULLPATH set, set DMUS_OBJ_FILENAME as well.
    if( pDESC->dwValidData & DMUS_OBJ_FULLPATH )
    {
        pDESC->dwValidData |= DMUS_OBJ_FILENAME;
    }
    EnterCriticalSection(&m_CriticalSection);
    CClass *pClass;
    Desc.Set(pDESC);
    hr = GetClass(&Desc,&pClass, TRUE);
    if (SUCCEEDED(hr))
    {
        CObject *pObject;
        hr = pClass->GetObject(&Desc,&pObject);
        if (SUCCEEDED(hr))
        {
            if (Desc.m_dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM))
            {
                pObject->m_ObjectDesc.m_dwValidData &= 
                    ~(DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM);
            }
            // Merge in any new things we've added
            pObject->m_ObjectDesc.Merge(&Desc);
            if (pObject->m_ObjectDesc.m_dwValidData & 
                (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM))
            {
                // If we can actually load this, have it give us its internal data.
                hr = pObject->Parse();
            }
            // Return the data.
            pObject->m_ObjectDesc.Get(pDESC);
        }
    }

    if (pStream)
    {
        // Restore the stream information in the descriptor we were passed.

        // Get will have cleared the stream bit (ordinarily we don't want to be returning these streams out of the loader).
        pDESC->dwValidData |= DMUS_OBJ_STREAM;
        // The stream pointer was changed to the cloned stream.
        pDESC->pStream->Release(); // release matching call to Clone (ref is now held in merged descriptor)
        pDESC->pStream = pStream;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | SetSearchDirectory | 
Sets a search path for finding object files. The search path can be set for
one object file type, or, alternatively, all files.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | The search directory was already set to the requested path.
@flag E_POINTER | Bad pointer passed in <p pszPath>.
@flag DMUS_E_LOADER_BADPATH | Path is invalid.
@flag E_OUTOFMEMORY | Running low on memory, unable to complete task.

@comm Once a search path is set, the loader does not need a full path
every time it is given an object to load by file name. 
However, the loader does not automatically becomes
aware of all files of the requested type within the search 
directory. After calling <om IDirectMusicLoader::SetSearchDirectory>,
call <om IDirectMusicLoader::ScanDirectory> to scan the
directory for all 
files of the requested class and compile a list of them. 
Once this is done, you can easily find
files within the directory by object name, or GUID, as well as 
file name.

@ex The following example sets the search path for style files, then
loads a style by file name. Although this seems a little redundant 
(it's simpler to just use the full path name), 
objects that indirectly reference other objects can
find them by file name without knowing the full path: |

    // The first function calls SetSearchDirectory to set the path.
    // All subsequant calls to load objects in the application
    // no longer need to know the full path.

    HRESULT mySetLoaderPath (
        IDirectMusicLoader *pILoader)    // Loader interface, previously created.
    {
        return pILoader->SetSearchDirectory(CLSID_DirectMusicStyle,
            L"c:\\mymusic\\funky",FALSE);
    }

    //    Later, the application wants to load a style by 
    //    local file name.


    HRESULT myLoadStyleFromPath (
        IDirectMusicStyle **ppIStyle,    // Style to load.
        IDirectMusicLoader *pILoader)    // Loader.
    {
        HRESULT hr;

        DMUS_OBJECTDESC Desc;           // Descriptor.

        // Start by initializing Desc with the local file name for the object.

        wcscpy(Desc.wszName,L"Polka");    // Name is wide char format.
        wcscpy(Desc.wszFileName,L"polka.sty");    // Use file name without full path.
        Desc.guidClass = CLSID_DirectMusicStyle;   // Style class.
        Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
        Desc.dwSize = sizeof (DMUS_OBJECTDESC);

        hr = pILoader->GetObject(&Desc, IID_IDirectMusicStyle, (void**) ppIStyle);
        return hr;
    }

@xref <i IDirectMusicLoader>, <i IDirectMusicObject>,
<om IDirectMusicLoader::GetObject>,
<om IDirectMusicLoader::ScanDirectory>,
<om IDirectMusicLoader::EnumObject>
*/
STDMETHODIMP CLoader::SetSearchDirectory(
    REFCLSID rguidClass,    // @parm Class id identifies which clas of objects this pertains to.
                    // Optionally, GUID_DirectMusicAllTypes specifies all classes. 
    WCHAR *pwzPath, // @parm File path for directory. Must be a valid directory and
                    // must be less than MAX_PATH in length.
    BOOL fClear)    // @parm If TRUE, clears all information about objects
                    // prior to setting directory. 
                    // This helps avoid accessing objects from the
                    // previous directory that may have the same name.
                    // However, this will not remove cached objects.
                                        
{


    V_INAME(IDirectMusicLoader::SetSearchDirectory);
    if (pwzPath)
    {
        V_BUFPTR_READ(pwzPath,2);
    }

    HRESULT hr = DMUS_E_LOADER_BADPATH;
    WCHAR wzMaxPath[MAX_PATH];

    if (pwzPath == NULL)
    {
        return E_POINTER;
    }
    wcscpy( wzMaxPath, pwzPath );
    if( wzMaxPath[wcslen( wzMaxPath ) - 1] != '\\' )
    {
        wcscat( wzMaxPath, L"\\" );
    }
    DWORD dwAttrib;
    if (g_fIsUnicode)
    {
        dwAttrib= GetFileAttributesW(wzMaxPath); 
    }
    else
    {
        char szPath[MAX_PATH];
        wcstombs( szPath, wzMaxPath, MAX_PATH );
        dwAttrib= GetFileAttributesA(szPath); 
    }
    if ((dwAttrib != 0xFFFFFFFF) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        EnterCriticalSection(&m_CriticalSection);
        if (rguidClass == GUID_DirectMusicAllTypes)
        {
            CClass *pClass = m_ClassList.GetHead();
            hr = S_OK;
            for (;pClass != NULL;pClass = pClass->GetNext())
            {
                if( S_FALSE == pClass->SetSearchDirectory(wzMaxPath,fClear))
                {
                    hr = S_FALSE;
                }
            }
            wcsncpy(m_wzPath,wzMaxPath,DMUS_MAX_FILENAME);
            m_fPathValid = TRUE;
        }
        else
        {
            CClass *pClass;
            CDescriptor Desc;
            Desc.m_guidClass = rguidClass;
            Desc.m_dwValidData = DMUS_OBJ_CLASS;
            hr = GetClass(&Desc,&pClass,TRUE);
            if (SUCCEEDED(hr))
            {
                hr = pClass->SetSearchDirectory(wzMaxPath,fClear);
            }
        }
        LeaveCriticalSection(&m_CriticalSection);
    }

#ifdef DBG
    if (hr == DMUS_E_LOADER_BADPATH)
    {
        Trace(1, "Error: SetSearchDirectory failed because '%S' is not a valid directory.\n", pwzPath);
    }
#endif

    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ScanDirectory | 
Searches a directory on disk for all files of a requested
class type and file extension. Once a directory has been scanned, all
files of the requested type become available for viewing with 
<om IDirectMusicLoader::EnumObject>.

Prior to calling <om IDirectMusicLoader::ScanDirectory>,
<om IDirectMusicLoader::SetSearchDirectory> must be called
first to set the location to search. 

Once a search path has been scanned, the loader automatically becomes
aware of all files within the search directory, and can easily find
files within that directory by object name, file name, or GUID.

Optionally, the scanned information can be stored in a 
cache file, defined by <p pszCacheFileName>. Once it has been
so stored, subsequant calls to <om IDirectMusicLoader::ScanDirectory>
are much quicker, because only files that have changed
are scanned (the cache file stores the file size and date for
each object, so it can identify if a file has changed.)

@comm If the file type has more than one extension, 
just call   
<om IDirectMusicLoader::ScanDirectory> multiple
times, once for each file extension.
  
<om IDirectMusicLoader::ScanDirectory> doesn't know
how to parse a particular object class's file and read 
the name, guid, and other information that retieves to idenity
files by. Instead, it lets the <i IDirectMusicObject> do the work, 
by calling the 
<om IDirectMusicObject::ParseDescriptor> method 
for the requested object type.


@rdesc Returns one of the following

@flag S_OK | Success.
@flag S_FALSE | Scanned, but no files.
@flag E_POINTER | Bad pointer passed in <p pszFileExtension> or <p pszCacheFileName>.
@flag DMUS_E_NOT_FOUND | Path is invalid.
@flag E_OUTOFMEMORY | Running low on memory, unable to complete task.
@flag REGDB_E_CLASSNOTREG | Object class is not registered, can't read files.

@ex The following example sets the search path for style files, scans the directory,
then uses the EnumObject call to display all available style files: |

    // First, scan the directory for all style files.

    void myScanDirectory(
        IDirectMusicLoader *pILoader)    // Loader.

    {
        HRESULT hr = pILoader->SetSearchDirectory(
            CLSID_DirectMusicStyle,L"c:\\mymusic\\wassup",TRUE);
        if (SUCCEEDED(hr))
        {
            hr = pILoader->ScanDirectory(
                CLSID_DirectMusicStyle,L"sty",L"stylecache");
            if (hr == S_OK)    // Only if files were found...
            {
                DWORD dwIndex;
                DMUS_OBJECTDESC Desc;
                Desc.dwSize = sizeof(DMUS_OBJECTDESC);
                for (dwIndex = 0; ;dwIndex++)
                {
                    if (S_OK ==(pILoader->EnumObject(CLSID_DirectMusicStyle,
                                               dwIndex,&Desc)))
                    {
                        TRACE("Name: %S, Category: %S, Path: %S\n",
                            Desc.wszName,Desc.wszCategory,Desc.wszFileName);
                    }
                    else break;
                }
            }
        }
    }


@xref <i IDirectMusicLoader>, <i IDirectMusicObject>,
<om IDirectMusicLoader::GetObject>,
<om IDirectMusicLoader::EnumObject>, <om IDirectMusicLoader::SetSearchDirectory>
*/

STDMETHODIMP CLoader::ScanDirectory(
    REFCLSID rguidClass,    // @parm Class id identifies which class of objects this pertains to.
    WCHAR *pszFileExtension,// @parm File extension for type of file to look for. 
                            // For example, L"sty" for style files. L"*" will look in all
                            // files. L"" or NULL will look for files without an
                            // extension.
    WCHAR *pszCacheFileName    // @parm Optional storage file to store and retrieve
                            // cached file information. This file is created by 
                            // the first call to <om IDirectMusicLoader::ScanDirectory>
                            // and used by subsequant calls. NULL if cache file
                            // not desired.
)

{

    V_INAME(IDirectMusicLoader::ScanDirectory);
    if (pszFileExtension)
    {
        V_BUFPTR_READ(pszFileExtension,2);
    }
    if (pszCacheFileName)
    {
        V_BUFPTR_READ(pszCacheFileName,2);
    }

    HRESULT hr = S_OK;
    //    First, mark all currently stored objects prior to scanning.
    CClass *pClass = m_ClassList.GetHead();
    for (;pClass != NULL;pClass = pClass->GetNext())
    {    
        pClass->PreScan();
    }
    if (pszCacheFileName != NULL)
    {
        LoadCacheFile(pszCacheFileName);
    }
    if (rguidClass == GUID_DirectMusicAllTypes)
    {
        Trace(1, "Error: ScanDirectory requires the clsid of a specific type of object to scan for. GUID_DirectMusicAllTypes is not valid.\n");
        return REGDB_E_CLASSNOTREG;
    }
    else
    {
        CDescriptor Desc;
        Desc.m_guidClass = rguidClass;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        EnterCriticalSection(&m_CriticalSection);
        GetClass(&Desc,&pClass,TRUE);
        if (pClass)
        {
            if( pszFileExtension )
            {
                hr = pClass->SearchDirectory(pszFileExtension);
            }
            else
            {
                hr = pClass->SearchDirectory(L"");
            }
//            if( hr == E_FAIL ) hr = DMUS_E_NOT_FOUND;
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pszCacheFileName != NULL)
    {
        SaveCacheFile(pszCacheFileName);
    }    
    return hr;
}

HRESULT CLoader::FindObject(CDescriptor *pDesc, CClass **ppClass, CObject ** ppObject)

// Scan through the classes and objects to find the object. 

{
    assert(pDesc);
    HRESULT hr = GetClass(pDesc,ppClass,FALSE);
    if (SUCCEEDED(hr))
    {
        hr = (*ppClass)->FindObject(pDesc,ppObject);
#ifdef DBG
        if (hr == DMUS_E_LOADER_OBJECTNOTFOUND)
        {
            DMUS_OBJECTDESC desc;
            ZeroAndSize(&desc);
            pDesc->Get(&desc);
            Trace(1, "Error: The following object could not be found in the loader: ");
            DebugTraceObject(&desc);
        }
#endif
    }
    return hr;
}

// Find the object in the cache.  S_FALSE if not loaded.  Error if not found.
HRESULT CLoader::FindObject(IDirectMusicObject *pIDMObject, CObject ** ppObject)

{
    // Potential optimization:
    //    The linear search to find the object could be eliminated by using
    // an efficient lookup structure such as a hash table.

    assert(pIDMObject && ppObject);

    HRESULT hr = S_OK;

    DMUS_OBJECTDESC DESC;
    ZeroMemory( &DESC, sizeof(DMUS_OBJECTDESC) );
    DESC.dwValidData = 0;
    DESC.dwSize = sizeof (DMUS_OBJECTDESC);

    hr = pIDMObject->GetDescriptor(&DESC);
    if (FAILED(hr))
        return hr;

    CDescriptor Desc;
    Desc.Set(&DESC);
    SmartRef::CritSec CS(&m_CriticalSection);
    CClass *pClass;
    CObject *pCObject;
    hr = FindObject(&Desc,&pClass,&pCObject);
    if (FAILED(hr))
        return hr;

    assert(pCObject);
    if (pCObject->m_pIDMObject == pIDMObject)
    {
        *ppObject = pCObject;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | CacheObject | 
Tells the loader to keep a reference to the object. This guarantees
that the object will not be loaded twice.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | Object already cached.
@flag E_POINTER | Bad pointer passed in <p pIObject>.
@flag DMUS_E_LOADER_OBJECTNOTFOUND | Object was not found.

@comm If you have an object that will be accessed in multiple places
throughout the life of your program, letting the loader cache the object
can significantly speed performance. 

Alternatively, tell the loader to automatically cache all objects of
a particular type with a call to 
<om IDirectMusicLoader::EnableCache>.

Remove the reference later with a call to 
<om IDirectMusicLoader::ReleaseObject> or 
<om IDirectMusicLoader::ClearCache>.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::ReleaseObject>,
<om IDirectMusicLoader::ClearCache>
*/
STDMETHODIMP CLoader::CacheObject(
    IDirectMusicObject * pObject)    // @parm Object to cache.

{
    HRESULT hr;
    DMUS_OBJECTDESC DESC;
    ZeroMemory( &DESC, sizeof(DMUS_OBJECTDESC) );
    DESC.dwSize = sizeof (DMUS_OBJECTDESC);

    V_INAME(IDirectMusicLoader::CacheObject);
    V_INTERFACE(pObject);

    if (pObject == NULL)
    {
        return E_POINTER;
    }
    DESC.dwValidData = 0;
    hr = pObject->GetDescriptor(&DESC);
    if (SUCCEEDED(hr))
    {
        CDescriptor Desc;
        Desc.Set(&DESC);
        CClass *pClass;
        CObject *pCObject;
        ::EnterCriticalSection(&m_CriticalSection);
        hr = FindObject(&Desc,&pClass,&pCObject);
        if (SUCCEEDED(hr))
        {
            if (pCObject->m_pIDMObject && (pCObject->m_pIDMObject != pObject))
            {
                pCObject->m_pIDMObject->Release();
                pCObject->m_pIDMObject = NULL;
            }
            if (pCObject->m_pIDMObject != pObject)
            {
                pCObject->m_pIDMObject = pObject;
                pCObject->m_ObjectDesc.m_dwValidData |= DMUS_OBJ_LOADED;
                pObject->AddRef();
            }
            else
            {
                hr = S_FALSE;
            }
        }
        ::LeaveCriticalSection(&m_CriticalSection);
    }
/*    if( E_FAIL == hr ) // Should never happen...
    {
        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    }*/
    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ReleaseObject | 
Tells the loader to release its reference to the object. 

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | Bad pointer passed in <p pIObject>.
@flag DMUS_E_LOADER_OBJECTNOTFOUND | Object was not found or was already released.

@comm <om IDirectMusicLoader::ReleaseObject> is the reciprocal
of <om IDirectMusicLoader::CacheObject>.

Objects can be cached explicitly via 
<om IDirectMusicLoader::CacheObject>,
or automatically via <om IDirectMusicLoader::EnableCache>.

To tell the loader to flush all objects of
a particular type, call
<om IDirectMusicLoader::ClearCache>.
 
@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ClearCache>
*/
STDMETHODIMP CLoader::ReleaseObject(
    IDirectMusicObject * pObject)    // @parm Object to release.

{

    V_INAME(IDirectMusicLoader::ReleaseObject);
    V_INTERFACE(pObject);

    HRESULT hr = S_OK;
    CObject *pCObject = NULL;
    SmartRef::CritSec CS(&m_CriticalSection);

    hr = FindObject(pObject, &pCObject);
    // Removed the following because it causes a regression from DX7, even though it is the better return.
//    if (hr == S_FALSE)
//        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    if (hr == S_OK)
    {
        if (pCObject->m_dwScanBits & SCAN_GC)
        {
            // Other objects may have references to this one so we need to keep this object around
            // and track its references.  We'll hold onto the DMObject pointer too because we may
            // later need to Zombie the object in order to break a cyclic reference.

            // We'll place an unloaded object with a duplicate descriptor in the cache to match the
            // non-GC behavior and then move the original object into a list of released objects that
            // will eventually be reclaimed by CollectGarbage.

            // Potential optimization:
            //   Here we re-iterate to remove from the list when we just iterated during FindObject.
            // Returning more info from FindObject, expanding it into this function, or using some
            // other technique would make this operation twice as fast.

            hr = pCObject->GC_RemoveAndDuplicateInParentList();
            if (FAILED(hr))
                return hr;

            GC_UpdateForReleasedObject(pCObject);
        }
        else
        {
            pCObject->m_pIDMObject->Release();
            pCObject->m_pIDMObject = NULL;
            pCObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
        }
    }

    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ClearCache | 
Tells the loader to release all references to a particular type
of object.  

@rdesc Returns just

@flag S_OK | Always succeeds

@comm <om IDirectMusicLoader::ClearCache> clears all objects
that are currently being held. However, if caching is enabled
via <om IDirectMusicLoader::EnableCache>, this does not
turn off caching so future file loads will continue to be cached.

Use <om IDirectMusicLoader::ReleaseObject> to release a specific
object.

Call <om IDirectMusicLoader::EnableCache> to turn off automatic
caching.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>
*/
STDMETHODIMP CLoader::ClearCache(
    REFCLSID rguidClass)    // @parm Class id identifies which class of objects to clear.
                    // Optionally, GUID_DirectMusicAllTypes specifies all types. 

{
    return ClearCacheInternal(rguidClass, false);
}

HRESULT CLoader::ClearCacheInternal(
    REFCLSID rguidClass,
    bool fClearStreams)

{
    SmartRef::CritSec CS(&m_CriticalSection);

    HRESULT hr = S_OK;
    CClass *pClass;
    if (rguidClass == GUID_DirectMusicAllTypes)
    {
        pClass = m_ClassList.GetHead();
        for (;pClass != NULL;pClass = pClass->GetNext())
        {
            hr = pClass->ClearCache(fClearStreams);
            if (FAILED(hr))
                return hr;
        }        
    }
    else
    {
        CDescriptor Desc;
        Desc.m_guidClass = rguidClass;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        GetClass(&Desc,&pClass,FALSE);
        if (pClass)
        {
            hr = pClass->ClearCache(fClearStreams);
            if (FAILED(hr))
                return hr;
        }
    }
    return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | EnableCache | 
Tells the loader to enable or disable automatic caching of
objects it loads. By default, caching is enabled for all
object classes. 

Once caching is enabled with a call to 
<om IDirectMusicLoader::EnableCache>, the loader keeps a reference to
all objects it loads subsequently,
either directly or indirectly (via a referenced load, for example, a
Section Segment that references a Style).

<om IDirectMusicLoader::EnableCache> can also be used to disable
caching by setting <p fEnable> to FALSE. Before disabling caching, think
twice. Caching is used extensively in the file loading process to 
resolve links to objects. If an object is not found in the cache, it
has to be reloaded, even if it already exists. For example, two segments
could reference the same style. When the first segment loads, it calls the
loader to get the style, which in turn creates a style, loads it from disk,
stores a pointer to the style in the cache, and returns it to the segment.
When the second segment loader, it asks for the style and the loader immediately
returns it, so both segments point to the same style. If caching is disabled, 
the second segment's request for the style results in a duplicate style
loaded from the file. This is very inefficient.

Another example: <i IDirectMusicBand> counts on the loader to keep the 
GM DLS collection cached. Every time it comes across a general MIDI instrument,
it gets the GM DLS collection from the loader by requesting it with 
GUID_DefaultGMCollection. If caching for CLSID_DirectMusicCollection is
disabled, every patch change in a general MIDI file will result in a
seperate copy of the entire GM collection being created! Not good!

However, with judicious use of <om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>, and <om IDirectMusicLoader::EnableCache>,
you can have the objects you don't need released, while others stick around 
in the cache.
 
To clear the cache without disabling caching, call 
<om IDirectMusicLoader::ClearCache>.

@ex The following example disables caching for just segment objects, so they
don't stay in memory after the application releases them. Yet, other objects
that should be shared, like styles, personalities and DLS collections, continue
to be cached. |

    void myPrepareLoader(IDirectMusicLoader *pILoader)
    
    {
        pILoader->EnableCache(GUID_DirectMusicAllTypes, TRUE);
        pILoader->EnableCache(CLSID_DirectMusicSegment, FALSE);
    }
        
@rdesc Returns just

@flag S_OK | Success.
@flag S_FALSE | The cache was already in the requested state.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::ClearCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>
*/
STDMETHODIMP CLoader::EnableCache(
    REFCLSID rguidClass,    // @parm Class id identifies which class of objects to cache.
                    // Optionally, GUID_DirectMusicAllTypes specifies all types. 
    BOOL fEnable)    // @parm TRUE to enable caching, FALSE to clear and disable.

{
    CClass *pClass;
    HRESULT hr = S_OK;
    if (rguidClass == GUID_DirectMusicAllTypes)
    {
        pClass = m_ClassList.GetHead();
        for (;pClass != NULL;pClass = pClass->GetNext())
        {
            if( S_FALSE == pClass->EnableCache(fEnable))
            {
                hr = S_FALSE;
            }
        }
        m_fKeepObjects = fEnable;
    }
    else
    {
        CDescriptor Desc;
        Desc.m_guidClass = rguidClass;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        GetClass(&Desc,&pClass,TRUE);
        if (pClass)
        {
            if( S_FALSE == pClass->EnableCache(fEnable))
            {
                hr = S_FALSE;
            }
        }
    }
    return hr;
}
/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | EnumObject | 
Enumerate through all available objects of the requested type. 

@rdesc Returns one of the following

@flag S_OK | Found object at request index.
@flag S_FALSE | Reached end of list.

@ex Use <om IDirectMusicLoader::EnumObject> to walk through all styles
that are already referenced by the loader. These might have been prepared
with a call to <om IDirectMusicLoader::ScanDirectory> or loaded
individually. |

    void myDisplayStyles(
        IDirectMusicLoader *pILoader)

    {
        DWORD dwIndex;
        DMUS_OBJECTDESC Desc;
        Desc.dwSize = sizeof(DMUS_OBJECTDESC);
        for (dwIndex = 0; ;dwIndex++)
        {
            if (S_OK ==(pILoader->EnumObject(CLSID_DirectMusicStyle,
                                       dwIndex,&Desc)))
            {
                TRACE("Name: %S, Category: %S, Path: %S\n",
                    Desc.wszName,Desc.wszCategory,Desc.wszFileName);
            }
            else break;
        }
    }

@xref <i IDirectMusicLoader>, <t DMUS_OBJECTDESC>

*/
STDMETHODIMP CLoader::EnumObject(
    REFCLSID rguidClass,            // @parm Class ID for class of objects to view. 
    DWORD dwIndex,            // @parm Index into list. Typically, starts with 0 and increments.
    LPDMUS_OBJECTDESC pDESC)    // @parm <t DMUS_OBJECTDESC> structure to be filled with data about object.
                                       
{
    HRESULT hr;
    CClass *pClass;
    CDescriptor Desc;

    V_INAME(IDirectMusicLoader::EnumObject);
    V_STRUCTPTR_WRITE(pDESC,DMUS_OLDOBJECTDESC);

    Desc.m_guidClass = rguidClass;
    Desc.m_dwValidData = DMUS_OBJ_CLASS;
    EnterCriticalSection(&m_CriticalSection);
    hr = GetClass(&Desc,&pClass,TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pClass->EnumerateObjects(dwIndex, &Desc);
        Desc.Get(pDESC);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

void
CLoader::GC_Mark(CObject *pObject)
{
    // mark pObject and everything it references
    GC_TraverseHelper(pObject, NULL, true);
}

bool
CLoader::GC_HasCycle(CObject *pObject)
{
    // see if pObject has a cyclical reference
    bool fFound = GC_TraverseHelper(pObject, pObject, true);
    // the search left marks while traversing, so clear them
    GC_TraverseHelper(pObject, pObject, false);
    return fFound;
}

// Function used to recursively traverse references.
// pObject:            Root to start the search from.
// pObjectToFind:    Stop marking and return true if a reference to this object is encountered.
//                    (Can be the same as pObject without being considered a match unless pObject has a reference to itself.)
// fMark:            If true, objects are marked as they are visited.  If false, the opposite occurs, clearing marks.
bool
CLoader::GC_TraverseHelper(CObject *pObject, CObject *pObjectToFind, bool fMark)
{
    // Potential optimization:
    //    This could be written using an explicit stack instead of recursion and
    // it might be significantly faster.  If this were done then this algorithm should
    // also be changed to use a fixed-size stack.  If the stack is exhausted, the
    // object would be marked as unexamined and these unexamined objects would be
    // marked in later passes.  However, since that's getting unnecessarily complex
    // we'll stick with recursion unless it proves to be a problem.

    if (!pObject || !(pObject->m_dwScanBits & SCAN_GC) || !pObject->m_pvecReferences)
    {
        Trace(1, "Error: Unexpected error encountered during garbage collection.\n");
        return false;
    }
    if (!!(pObject->m_dwScanBits & SCAN_GC_MARK) == fMark)
        return false; // already done

    if (fMark)
        pObject->m_dwScanBits |= SCAN_GC_MARK;
    else
        pObject->m_dwScanBits &= ~SCAN_GC_MARK;

    SmartRef::Vector<CObject*> &vecRefs = *pObject->m_pvecReferences;
    const UINT iEnd = vecRefs.size();

    // While we iterate over the references, we're going to write them back into the
    // vector, compacting away any NULL slots created by GC_RemoveReference.
    UINT iWrite = 0;

    for (UINT i = 0; i < iEnd; ++i)
    {
        CObject *pObjectRef = vecRefs[i];

        if (pObjectRef)
        {
            if (pObjectRef == pObjectToFind)
                return true;

            if (GC_TraverseHelper(pObjectRef, pObjectToFind, fMark))
                return true;

            if (!pObjectToFind)
            {
                // Compact empty slots only when just marking.  (Doing so while searching for an object could
                // return before the compacting loop is complete, leaving the vector in an inconsistent state.)
                vecRefs[iWrite++] = pObjectRef;
            }
        }
    }
    if (!pObjectToFind)
        vecRefs.Shrink(iWrite);
    return false;
}

STDMETHODIMP_(void)
CLoader::CollectGarbage()
{
    SmartRef::CritSec CS(&m_CriticalSection);

    if (m_pApplicationObject)
    {
#ifdef DBG
        DebugTrace(GC_Report_DebugLevel, "DirectMusic loader CollectGarbage...\n");
#endif

        GC_Mark(m_pApplicationObject);

        // sweep through everything looking for unmarked GC objects
        m_ReleasedObjectList.GC_Sweep(TRUE);
        for (CClass *pClass = m_ClassList.GetHead(); pClass != NULL; pClass = pClass->GetNext())
            pClass->GC_Sweep();
        m_ReleasedObjectList.GC_Sweep();

        // clear the application's mark for next time (the other marks are all cleared by sweep)
        m_pApplicationObject->m_dwScanBits &= ~SCAN_GC_MARK;

#ifdef DBG
        DebugTrace(GC_Report_DebugLevel, "End of garbage collection.\n\n");
#endif
    }

#ifdef DBG
    GC_Report(this);
#endif
}

STDMETHODIMP
CLoader::ReleaseObjectByUnknown(IUnknown *pObject)
{
    V_INAME(CLoader::ReleaseObjectByUnknown);
    V_INTERFACE(pObject);

    IDirectMusicObject *pIDMObject = NULL;
    HRESULT hr = pObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pIDMObject));
    if (FAILED(hr))
        return hr;

    hr = ReleaseObject(pIDMObject);
    pIDMObject->Release();
    return hr;
}

STDMETHODIMP
CLoader::GetDynamicallyReferencedObject(
    IDirectMusicObject *pSourceObject,
    LPDMUS_OBJECTDESC pDesc,
    REFIID riid,
    LPVOID FAR *ppv)
{
    V_INAME(CLoader::GetDynamicallyReferencedObject);
    V_INTERFACE(pSourceObject);

    CObject *pCSourceObject = NULL;

    SmartRef::CritSec CS(&m_CriticalSection);
    HRESULT hr = FindObject(pSourceObject, &pCSourceObject);
    if (FAILED(hr))
        return hr;
    if (!pCSourceObject)
    {
        assert(false);
        return DMUS_E_LOADER_OBJECTNOTFOUND;
    }

    CObject *pPrevContext = m_pLoadedObjectContext;
    m_pLoadedObjectContext = pCSourceObject;
    hr = this->GetObject(pDesc, riid, ppv);
    m_pLoadedObjectContext = pPrevContext;

#ifdef DBG
    GC_Report(this);
#endif

    return hr;
}

STDMETHODIMP
CLoader::ReportDynamicallyReferencedObject(
    IDirectMusicObject *pSourceObject,
    IUnknown *pReferencedObject)
{
    V_INAME(CLoader::GetDynamicallyReferencedObject);
    V_INTERFACE(pSourceObject);
    V_INTERFACE(pReferencedObject);

    CObject *pCSourceObject = NULL;

    SmartRef::CritSec CS(&m_CriticalSection);
    HRESULT hr = FindObject(pSourceObject, &pCSourceObject);
    if (hr == S_FALSE)
        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    if (FAILED(hr))
        return hr;
    assert(pCSourceObject);

    IDirectMusicObject *pReferencedIDMObject = NULL;
    hr = pReferencedObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pReferencedIDMObject));
    if (FAILED(hr))
    {
        if (hr == E_NOINTERFACE)
            hr = S_OK; // If the referenced object isn't a DirectMusic object then that's OK and we don't need to track it.
        return hr;
    }

    CObject *pCDestObject = NULL;
    hr = FindObject(pReferencedIDMObject, &pCDestObject);
    if (hr == S_FALSE)
        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    if (FAILED(hr))
        return hr;
    assert(pCDestObject);

    hr = pCSourceObject->GC_AddReference(pCDestObject);

#ifdef DBG
    GC_Report(this);
#endif

    return hr;
}

HRESULT CLoader::GetPath(WCHAR *pwzPath)

{
    if (m_fPathValid)
    {
        wcsncpy(pwzPath,m_wzPath,DMUS_MAX_FILENAME);
        return S_OK;
    }
    wcsncpy(pwzPath,L"",DMUS_MAX_FILENAME);
    return S_FALSE;
}

// Used by ReleaseObject and CClass::ClearCache in removing objects from the cache.
// The object must have already been removed from its list in the main cache.
// This method adds it to the released object list and removes it from the list of
// objects in use by the application.
void CLoader::GC_UpdateForReleasedObject(CObject *pObject)
{
    assert(!pObject->GetNext());

    m_ReleasedObjectList.AddHead(pObject);
    assert(m_pApplicationObject);
    m_pApplicationObject->GC_RemoveReference(pObject);

    if (!(pObject->m_ObjectDesc.m_guidClass == CLSID_DirectMusicScript) && !GC_HasCycle(pObject))
    {
        // Although we need to keep the record around (CObject), we know that this object
        // can't be involved in any cycles and therefore we can release it.
        // (If a cycle is possible we'd need to hold a ref on the object so we could break the
        //  reference by calling Zombie during CollectGarbage.)

        // bugbug: The hard-coded check for CLSID_IDirectMusicScript will need to be extended
        // if we publicly expose methods like IDirectMusicLoader8P::GetDynamicallyReferencedObject
        // so that objects other than scripts could dynamically load objects.
        //    Alternatively, we could assume all objects could be cyclical and always hold onto
        // them.  We would have done it this way, except that legacy applications won't ever call
        // CollectGarbage and that would cause them to leak everything they loaded even after calling
        // ReleaseObject.  That could be a better way (if we could detect legacy apps that don't
        // call CollectGarbage) because it would avoid calling GC_HasCycle every time
        // through ReleaseObject, which is (worst case) order N where N is the number of objects
        // in the loader.  In practice, this worst case only happens if all the objects are
        // arranged in one big cycle.

        pObject->m_pIDMObject->Release();
        pObject->m_pIDMObject = NULL;
    }
}

HRESULT CLoader::LoadCacheFile(WCHAR *pwzCacheFileName)

{
    HRESULT hr = S_OK;
    return hr;
}
#define FOURCC_LIST_CLASSLIST    mmioFOURCC('c','l','s','l')
#define FOURCC_CLASSHEADER        mmioFOURCC('c','l','s','h')
#define FOURCC_LIST_OBJLIST        mmioFOURCC('o','b','j','l')
#define FOURCC_OBJHEADER        mmioFOURCC('o','b','j','h')

HRESULT CLoader::SaveCacheFile(WCHAR *pwzCacheFileName)

{
    HRESULT hr = E_OUTOFMEMORY;
    MMCKINFO ckMain;

    ZeroMemory(&ckMain, sizeof(MMCKINFO));

    CFileStream *pStream = new CFileStream ( this );
    if (pStream)
    {
        hr = pStream->Open(pwzCacheFileName,GENERIC_WRITE);
        if (SUCCEEDED(hr))
        {
            IRIFFStream *pRiff;
            hr = AllocRIFFStream(pStream, &pRiff );
            if (SUCCEEDED(hr))
            {
                ckMain.fccType = FOURCC_RIFF_CACHE;
                if( pRiff->CreateChunk( &ckMain, MMIO_CREATERIFF ) == S_OK)
                {
                    MMCKINFO ckList;
                    
                    ZeroMemory(&ckList, sizeof(MMCKINFO));

                    ckList.fccType = FOURCC_LIST_CLASSLIST;
                    if( pRiff->CreateChunk(&ckList, MMIO_CREATELIST) == S_OK )
                    {
                        CClass *pClass = m_ClassList.GetHead();
                        for (;pClass != NULL;pClass = pClass->GetNext())
                        {
                            hr = pClass->SaveToCache(pRiff);
                            if (FAILED(hr))
                            {
                                Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
                                pRiff->Release();
                                pStream->Release();
                                return hr;
                            }
                        }
                        if( pRiff->Ascend( &ckList, 0 ) != S_OK )
                        {
                            Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
                            hr = DMUS_E_CANNOTSEEK;
                        }
                    }
                    if( pRiff->Ascend( &ckMain, 0 ) != S_OK )
                    {
                        Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
                        hr = DMUS_E_CANNOTSEEK;
                    }
                }
                pRiff->Release();
            }
        }
        pStream->Release();
    }

    return hr;
}


    // IDirectMusicIMA
STDMETHODIMP CLoader::LegacyCaching( BOOL fEnable)

{
    m_fIMA = fEnable;
    if (fEnable)
    {
        ScanDirectory(CLSID_DirectMusicStyle,L"sty",L"imafiles");
        ScanDirectory(CLSID_DirectMusicChordMap,L"per",L"imafiles");
    }
    else
    {
        CClass *pClass;
        CDescriptor Desc;
        Desc.m_guidClass = CLSID_DirectMusicStyle;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        EnterCriticalSection(&m_CriticalSection);
        GetClass(&Desc,&pClass,FALSE);
        if (pClass)    
        {
            pClass->ClearObjects(TRUE,L"sty");
        }
        LeaveCriticalSection(&m_CriticalSection);
        Desc.m_guidClass = CLSID_DirectMusicChordMap;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        EnterCriticalSection(&m_CriticalSection);
        GetClass(&Desc,&pClass,FALSE);
        if (pClass)    
        {
            pClass->ClearObjects(TRUE,L"per");
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    return S_OK;
}

#ifdef DBG
void CLoader::DebugTraceObject(DMUS_OBJECTDESC *pDesc)
{
    WCHAR *polestrType = NULL;
    if (pDesc->dwValidData & DMUS_OBJ_CLASS)
    {
        if (S_OK != ProgIDFromCLSID(pDesc->guidClass, &polestrType))
        {
            StringFromCLSID(pDesc->guidClass, &polestrType);
        }
    }
    WCHAR *polestrGUID = NULL;
    if (pDesc->dwValidData & DMUS_OBJ_OBJECT)
    {
        StringFromCLSID(pDesc->guidObject, &polestrGUID);
    }
    Trace(1,
            "   [file %S, name %S, type %S, guid %S]\n",
            (pDesc->dwValidData & DMUS_OBJ_FILENAME) ? pDesc->wszFileName : L"??",
            (pDesc->dwValidData & DMUS_OBJ_NAME) ? pDesc->wszName : L"??",
            polestrType ? polestrType : L"??",
            polestrGUID ? polestrGUID : L"??");
    CoTaskMemFree(polestrType);
    CoTaskMemFree(polestrGUID);
}

void CLoader::DebugTraceLoadFailure(CObject *pObject, HRESULT hrLoad)
{
    if (!pObject)
    {
        assert(false);
        return;
    }

    if (m_pLoadedObjectContext == m_pApplicationObject)
    {
        // This is the object loaded by the application.  Print the warning if anything failed to load.

        UINT iSize = m_vecdescDebugTraceLoadFailure.size();
        if (iSize > 0)
        {
            DMUS_OBJECTDESC desc;
            Zero(&desc);
            pObject->m_ObjectDesc.Get(&desc);

            Trace(1, "Load failure. While attempting to load the object\n");
            DebugTraceObject(&desc);
            Trace(1, "the following referenced objects could not be loaded:\n");
            for (UINT i = 0; i < iSize; ++i)
            {
                DebugTraceObject(&m_vecdescDebugTraceLoadFailure[i]);
            }

            m_vecdescDebugTraceLoadFailure.Shrink(0);
        }
    }
    else
    {
        // This is a referenced sub-object.  Save the desciptor of the failed object in the next slot.

        UINT uiNewPos = m_vecdescDebugTraceLoadFailure.size();
        if (m_vecdescDebugTraceLoadFailure.AccessTo(uiNewPos))
        {
            DMUS_OBJECTDESC *pdesc = &m_vecdescDebugTraceLoadFailure[uiNewPos];
            Zero(pdesc);
            pObject->m_ObjectDesc.Get(pdesc);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\loader.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// Loader.h : Declaration of CLoader
//
// @doc EXTERNAL
//

#ifndef __CDMLOADER_H_
#define __CDMLOADER_H_
#include <windows.h>
#define COM_NO_WINDOWS_H
#include <objbase.h>
#include "dmusici.h"
#include "Alist.h"
#include "riff.h"
#include "ima.h"
#include <mmreg.h>
#include <stdio.h>
#include "smartref.h"
#include "..\shared\dmusicp.h"

class CLoader;
class CClass;

#define FOURCC_RIFF_CACHE		mmioFOURCC('D','M','L','C')
#define FOURCC_LIST_CLASSLIST	mmioFOURCC('c','l','s','l')
#define FOURCC_CLASSHEADER		mmioFOURCC('c','l','s','h')
#define FOURCC_LIST_OBJLIST		mmioFOURCC('o','b','j','l')
#define FOURCC_OBJHEADER		mmioFOURCC('o','b','j','h')

// We need an older sized object descriptor for parameter validation. 

typedef struct _DMUS_OLDOBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
} DMUS_OLDOBJECTDESC;


class CDescriptor
{
public:
					CDescriptor();
					~CDescriptor();

	void			Get(LPDMUS_OBJECTDESC pDesc);
	void			Set(LPDMUS_OBJECTDESC pDesc);
	void			Merge(CDescriptor * pDesc);
	void			ClearName();
	void			SetName(WCHAR *pwzName);
	void			ClearCategory();
	void			SetCategory(WCHAR *pwzCategory);
	void			ClearFileName();
	HRESULT			SetFileName(WCHAR *pwzFileName);
	void     		SetIStream(IStream *pIStream);
    void            ClearIStream();
	void			Copy(CDescriptor *pDesc);
	BOOL			IsExtension(WCHAR *pwzExtension);
public:
	LONGLONG		m_llMemLength;			// Memory size.
	DWORD			m_dwValidData;			// Flags indicating which of above is valid.
	GUID			m_guidObject;			// Unique ID for this object.
	GUID			m_guidClass;			// GUID for the class of object.
	FILETIME		m_ftDate;				// File date of object.
	DMUS_VERSION	m_vVersion;				// Version, as set by authoring tool.
	WCHAR *			m_pwzName;				// Name of object.	
	WCHAR *			m_pwzCategory;			// Category for object (optional).
	WCHAR *			m_pwzFileName;			// File path.
	DWORD			m_dwFileSize;			// Size of file.
	BYTE *			m_pbMemData;			// Pointer to memory.
    IStream *       m_pIStream;             // Pointer to IStream object.
    LARGE_INTEGER   m_liStartPosition;      // Position in stream to start at.   
    CRITICAL_SECTION	m_CriticalSection;	// Critical section for the descriptor's stream.
    BOOL                m_fCSInitialized;
};

#define     SCAN_CACHE		1			// Was found in cache file.
#define     SCAN_PRIOR		2			// Was in list prior to scanning.
#define     SCAN_PARSED		4			// Was parsed in the directory.
#define     SCAN_SEARCH		8			// Type of object we are searching for.
const DWORD SCAN_GC =		1 << 12;	// Object was cached while garbage collection was enabled.
const DWORD SCAN_GC_MARK =	1 << 13;	// Bit set during marking phase of CollectGarbage.  Objects that remain unmarked are garbage.
										// Also used to detect cycles.


class CObject : public AListItem
{
public:
									CObject(CClass *pClass);
									CObject(CClass *pClass, CDescriptor *pDesc);
									~CObject();
    CObject *						GetNext() {return(CObject *)AListItem::GetNext();};
	HRESULT							Load();
	HRESULT							Parse();
	HRESULT							ParseFromFile();
	HRESULT							ParseFromMemory();
	HRESULT							ParseFromStream();
	HRESULT							GC_Collectable();
	HRESULT							GC_AddReference(CObject *pObject);
	HRESULT							GC_RemoveReference(CObject *pObject);
	HRESULT							GC_RemoveAndDuplicateInParentList();

	CDescriptor						m_ObjectDesc;
	IDirectMusicObject *			m_pIDMObject;
	DWORD							m_dwScanBits;
	SmartRef::Vector<CObject*> *	m_pvecReferences;
private:
	CClass *				m_pClass;
};

class CObjectList : public AList
{
public:
    CObject *	GetHead() {return (CObject *)AList::GetHead();};
    CObject *	RemoveHead() {return (CObject *)AList::RemoveHead();};
	void		GC_Sweep(BOOL bOnlyScripts = FALSE);
};


class CClass : public AListItem
{
public:
						CClass( CLoader *pLoader );
						CClass( CLoader *pLoader, CDescriptor *pDesc );
						~CClass();
	void				ClearObjects(BOOL fKeepCache,WCHAR *pwzExtension);
	void				RemoveObject(CObject* pRemoveObject);
    CClass *			GetNext() {return(CClass *)AListItem::GetNext();};
	HRESULT				GetPath(WCHAR *pwzPath);	// Finds path.
	HRESULT             FindObject(CDescriptor *pDesc,CObject **ppObject, CObject *NotThis = NULL);
	HRESULT				EnumerateObjects(
							DWORD dwIndex, 
							CDescriptor *pDesc) ;
	HRESULT				SetSearchDirectory(WCHAR *pwzPath,BOOL fClear);
	HRESULT				SearchDirectory(WCHAR *pwzFileExtension);
	HRESULT				EnableCache(BOOL fEnable);
	HRESULT				ClearCache(bool fClearStreams); // fClearStreams also clears the IStream members of all descriptors. It is used when shutting down the loader in Release.
	HRESULT				SaveToCache(IRIFFStream *pRiff);
	HRESULT				GetObject(CDescriptor *pDesc, CObject ** ppObject);
	void				PreScan();
	void				GC_Replace(CObject *pObject, CObject *pObjectReplacement);
	void				GC_Sweep() { m_ObjectList.GC_Sweep(); }

	CDescriptor			m_ClassDesc;
	CLoader *			m_pLoader;
	BOOL				m_fKeepObjects;		// Hang onto objects after loading them.

	friend void GC_Report(CLoader *);
private:
	CObjectList			m_ObjectList;
	DWORD				m_dwLastIndex;		// For tracking enumeration.
	CObject *			m_pLastObject;		// Last object enumerated.
	BOOL				m_fDirSearched;		// Directory has been searched for files.
};

class CClassList : public AList
{
public:
    CClass *	GetHead() {return (CClass *)AList::GetHead();};
    CClass *	RemoveHead() {return (CClass *)AList::RemoveHead();};
};


class CLoader : public IDirectMusicLoader8, public IDirectMusicLoader8P, public IDirectMusicIMA
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicLoader
	virtual STDMETHODIMP GetObject(LPDMUS_OBJECTDESC pDesc, REFIID, LPVOID FAR *) ;
	virtual STDMETHODIMP SetObject(LPDMUS_OBJECTDESC pDesc) ;
    virtual STDMETHODIMP SetSearchDirectory(REFGUID rguidClass, WCHAR *pwzPath, BOOL fClear) ;
	virtual STDMETHODIMP ScanDirectory(REFGUID rguidClass, WCHAR *pwzFileExtension, WCHAR *pwzScanFileName) ;
	virtual STDMETHODIMP CacheObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ReleaseObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ClearCache(REFGUID rguidClass) ;
	virtual STDMETHODIMP EnableCache(REFGUID rguidClass, BOOL fEnable) ;
	virtual STDMETHODIMP EnumObject(REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc) ;

	// IDirectMusicLoader8
	virtual STDMETHODIMP_(void) CollectGarbage() ;
	virtual STDMETHODIMP ReleaseObjectByUnknown(IUnknown *pObject) ;
	virtual STDMETHODIMP GetDynamicallyReferencedObject(IDirectMusicObject *pSourceObject,
														LPDMUS_OBJECTDESC pDesc,
														REFIID riid,
														LPVOID FAR *ppv) ;
	virtual STDMETHODIMP ReportDynamicallyReferencedObject(IDirectMusicObject *pSourceObject,
														   IUnknown *pReferencedObject);
    virtual STDMETHODIMP LoadObjectFromFile(REFGUID rguidClassID, 
                                            REFIID iidInterfaceID, 
                                            WCHAR *pwzFilePath, 
                                            void ** ppObject) ;
	virtual ULONG STDMETHODCALLTYPE AddRefP();			// Private AddRef, for streams and scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP();			// Private Release, for streams and scripts.

	// IDirectMusicIMA
	virtual STDMETHODIMP LegacyCaching( BOOL fEnable) ;

	CLoader();
	~CLoader();
	HRESULT				Init();
	HRESULT				GetPath(WCHAR *pwzPath);	// Finds path.
	void				GC_UpdateForReleasedObject(CObject *pObject); // Used by ReleaseObject and CClass::ClearCache in removing objects from the cache.
	BOOL				m_fIMA;				// Support IMA parsing of ini files, etc.
	BOOL				m_fKeepObjects;		// Hang on to objects after loading them.

	friend void GC_Report(CLoader *);

private:
	HRESULT				LoadCacheFile(WCHAR *pwzCacheFileName);
	HRESULT				SaveCacheFile(WCHAR *pwzCacheFileName);
	HRESULT				GetClass(CDescriptor *pDesc, CClass **ppClass, BOOL fCreate);
	HRESULT 			ClearCacheInternal(REFGUID rguidClass, bool fClearStreams); // fClearStreams also clears the IStream members of all descriptors. It is used when shutting down the loader in Release.
	HRESULT             FindObject(CDescriptor *pDesc, CClass **ppClass, CObject ** ppObject);
	HRESULT				FindObject(IDirectMusicObject *pIDMObject, CObject ** ppObject);

	void				GC_Mark(CObject *pObject);
	bool				GC_HasCycle(CObject *pObject);
	// Recursive function used to implement GC_Mark and GC_HasCycle
	bool				GC_TraverseHelper(CObject *pObject, CObject *pObjectToFind, bool fMark);

	CClassList			m_ClassList;		// Each type has its own list.
	WCHAR				m_wzPath[DMUS_MAX_FILENAME];	// Search directory.
	BOOL				m_fPathValid;		// Search dir is valid.
	long				m_cRef;
	long				m_cPRef;			// Private reference count.
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage lists.
    BOOL                m_fCSInitialized;

	CObject *			m_pApplicationObject; // Object used to track references to objects in use by the application.
	CObject *			m_pLoadedObjectContext; // Used to determine which object called GetObject.  Initially m_pApplicationContext, but set and restored as a cascade of GetObject calls occurs between components.
	CObjectList			m_ReleasedObjectList; // Holds objects that are released, but may still be referenced by other objects.

	// Debug-only functions used by GetObject to report load failures.
	// Frequently some file will fail to load because it depends on some other file
	// that is missing and this will print out trace statements helping the user
	// understand what's missing.
#ifdef DBG
	void DebugTraceLoadFailure(CObject *pObject, HRESULT hrLoad);
	static void DebugTraceObject(DMUS_OBJECTDESC *pDesc);
	SmartRef::Vector<DMUS_OBJECTDESC> m_vecdescDebugTraceLoadFailure; // accumulates the failed sub-items
#endif
};

/*
@interface IDirectMusicGetLoader | 
If a stream supports the loader, it must provide an
<i IDirectMusicGetLoader> interface so any object that is
parsing the stream can use it to access the loader when
it needs to load another object that is referenced by the
file.

@base public | IUnknown

@meth HRESULT | GetLoader | Returns the loader.
@xref <i IDirectMusicLoader>
*/


class CFileStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CFileStream( CLoader *pLoader );
						~CFileStream();
	HRESULT				Open( WCHAR *lpFileName, DWORD dwDesiredAccess );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
    WCHAR           m_wszFileName[DMUS_MAX_FILENAME]; // Save name for cloning.
#ifdef UNDER_CE
    HANDLE          m_hFile;
#else
	FILE*			m_pFile;		// file pointer
#endif
	CLoader *		m_pLoader;
};

class CMemStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CMemStream( CLoader *pLoader );
                        CMemStream( CLoader *pLoader,
                            LONGLONG llLength,
                            LONGLONG llPosition,
                            BYTE *pbData);
						~CMemStream();
	HRESULT				Open( BYTE *pbData, LONGLONG llLength );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
	BYTE*			m_pbData;		// memory pointer
	LONGLONG		m_llLength;
	LONGLONG		m_llPosition;	// Current file position.
	CLoader *		m_pLoader;
};


class CStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CStream( CLoader *pLoader );
                        CStream( CLoader *pLoader, IStream *pStream );
						~CStream();
	HRESULT				Open(IStream *pIStream,LARGE_INTEGER liStartPosition);
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
    IStream *       m_pIStream;
	CLoader *		m_pLoader;
};

// Class factory
// 
class CLoaderFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CLoaderFactory();

	// Destructor
	~CLoaderFactory(); 

private:
	long m_cRef;
};

class CContainerFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CContainerFactory();

	// Destructor
	~CContainerFactory(); 

private:
	long m_cRef;
};


/*
@interface IDirectMusicObject | 
All DirectMusic objects support the <i IDirectMusicObject> 
interface in order to
work with the DirectMusic loader. In addition to 
providing a standard generic interface that the loader can
communicate with, this provides a generic mechanism that
allows an application to query an object for information 
about it, including Name, Guid, file path, version info, 
and more.

If you are writing a DirectMusic compatible object, you
must support <i IDirectMusicObject>, along with <i IPersistStream>, 
which is used in
tandem with <i IDirectMusicObject> to load the object.

@base public | IUnknown

@meth HRESULT | GetDescriptor | Get the object's internal description, in <t DMUS_OBJECTDESC> format.
@meth HRESULT | SetDescriptor | Set the object's internal description, in <t DMUS_OBJECTDESC> format.
@meth HRESULT | ParseDescriptor | Parse into the supplied stream and find information about the file to store in <t DMUS_OBJECTDESC> format.

@xref  <t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/
#ifdef ONLYAUTODOCS
/* 
@method:(EXTERNAL) HRESULT | IDirectMusicObject | GetDescriptor | 
Get the object's internal description. 

This method takes a <t DMUS_OBJECTDESC> structure and fills in everything
it knows about itself. Depending on the implementation of the object and
how it was loaded from a file, some or all of the standard 
parameters will be filled by <om IDirectMusicObject::GetDescriptor>.
Be sure to check the flags in <e DMUS_OBJECTDESC.dwValidData> to understand
which fields are valid.

@rdesc Returns one of the following

@flag S_OK | Success

@ex The following example uses <om IDirectMusicObject::GetDescriptor> to
read the name from a DirectMusic style: |

	IDirectMusicStyle *pStyle;		// Style that was previously loaded.

	if (pStyle)
	{
		IDirectMusicObject *pIObject;  
		DMUS_OBJECTDESC Desc;              // Descriptor.

		if (SUCCEEDED(QueryInterface(IID_IDirectMusicObject,(void **) &pIObject); 
		{
			if (SUCCEEDED(pIObject->GetDescriptor(&Desc))
			{
				if (Desc.dwValidData & DMUS_OBJ_NAME)
				{
					TRACE("Style name is %S\n",Desc.wszName);
				}
			}
			pIObject->Release();
		}
	}

@xref <i IDirectMusicObject>, <om IDirectMusicObject::SetDescriptor>,
<om IDirectMusicObject::ParseDescriptor>,<t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/

HRESULT CDMStyle::GetDescriptor(
	LPDMUS_OBJECTDESC pDesc)	// @parm Descriptor to be filled with data about object.
{
	return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicObject | SetDescriptor | 
Set some or all fields of the object's internal description. 

This method takes a <t DMUS_OBJECTDESC> structure and copies the
fields that are enabled with by a flag in 
<e DMUS_OBJECTDESC.dwValidData>. 

Fields that are not copied keep their previous values. For example,
an object may already have its name and GUID stored internally. 
A call to its <om IDirectMusicObject::SetDescriptor> method with
a new name and file path (DMUS_OBJ_NAME and DMUS_OBJ_FILENAME)
would replace the name, give it a file name, and leave the
GUID alone.

This is primarily used by the loader when creating an object. 
However, it can be used by an application to rename an object.

If the object is unable to set one or more fields, it sets the
fields that it does support, clears the flags in <e DMUS_OBJECTDESC.dwValidData>
that it does not support, and returns S_FALSE. 

If nothing else, an object should support DMUS_OBJ_NAME and DMUS_OBJ_OBJECT.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | Was unable to set some parameters. The <p pDesc>'s dwValidData
field will contain only those flags that were successfully set.

@xref <i IDirectMusicObject>, <om IDirectMusicObject::GetDescriptor>,
<om IDirectMusicObject::ParseDescriptor>,<t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/

HRESULT CDMStyle::SetDescriptor(
	LPDMUS_OBJECTDESC pDesc)	// @parm Descriptor with data about object.
{
	return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicObject | ParseDescriptor | 
Given a file stream, <om IDirectMusicObject::ParseDescriptor> scans the 
file for data which it can store in the <t DMUS_OBJECTDESC> structure.
These include object name, GUID, version info, etc. All fields that
are supplied are marked with the appropriate bit flags in
<e DMUS_OBJECTDESC.dwValidData>.

This is primarily used by the loader when scanning a directory for
objects, and should not be of use to an application. However, if you
implement an object type in DirectMusic, you should support this.

@rdesc Returns one of the following

@flag S_OK | Success
@flag DMUS_E_INVALIDFILE | Not a valid file

@xref <i IDirectMusicObject>, <om IDirectMusicObject::SetDescriptor>,
<om IDirectMusicObject::GetDescriptor>,<t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/

HRESULT CDMStyle::ParseDescriptor(
	LPSTREAM pStream,		// @parm Stream source for file.
	LPDMUS_OBJECTDESC pDesc)	// @parm Descriptor to fill with data about file.
{

	return S_OK;
}

#endif // ONLYAUTODOCS

#endif //__CDMLOADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\object.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// Object.cpp : Implementations of CObject and CClass

#include "dmusici.h"
#include "loader.h"
#include "debug.h"
#include "miscutil.h"
#include <strsafe.h>
#ifdef UNDER_CE
#include "dragon.h"
#else
extern BOOL g_fIsUnicode;
#endif

CDescriptor::CDescriptor()

{
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;

    m_llMemLength = 0;
    m_pbMemData = NULL;         // Null pointer to memory.
    m_dwValidData = 0;          // Flags indicating which of above is valid.
    m_guidObject = GUID_NULL;           // Unique ID for this object.
    m_guidClass = GUID_NULL;            // GUID for the class of object.
    ZeroMemory( &m_ftDate, sizeof(FILETIME) );              // File date of object.
    ZeroMemory( &m_vVersion, sizeof(DMUS_VERSION) );                // Version, as set by authoring tool.
    m_pwzName = NULL;               // Name of object.  
    m_pwzCategory = NULL;           // Category for object (optional).
    m_pwzFileName = NULL;           // File path.
    m_dwFileSize = 0;           // Size of file.
    m_pIStream = NULL;
    m_liStartPosition.QuadPart = 0;
}

CDescriptor::~CDescriptor()

{
    if (m_fCSInitialized)
    {
        // If critical section never initialized, never got a chance
        // to do any other initializations
        //
        if (m_pwzFileName) delete[] m_pwzFileName;
        if (m_pwzCategory) delete[] m_pwzCategory;
        if (m_pwzName) delete[] m_pwzName;
        if (m_pIStream) m_pIStream->Release();
        DeleteCriticalSection(&m_CriticalSection);
    }
}

void CDescriptor::ClearName()

{
    if (m_pwzName) delete[] m_pwzName;
    m_pwzName = NULL;
    m_dwValidData &= ~DMUS_OBJ_NAME;
}

void CDescriptor::SetName(WCHAR *pwzName)

{
    if(pwzName == NULL)
    {
        return;
    }

    HRESULT hr = S_OK;
    
    WCHAR wszName[DMUS_MAX_NAME] = L"";

    ClearName();
    hr = StringCchCopyW(wszName, DMUS_MAX_NAME, pwzName);
    
    if(SUCCEEDED(hr))
    {
        size_t cLen = wcslen(wszName);
        m_pwzName = new WCHAR[cLen + 1];
        if(m_pwzName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        
        if(SUCCEEDED(hr))
        {
            wcsncpy(m_pwzName, wszName, cLen + 1);
        }
    }
    
    if(SUCCEEDED(hr))
    {
        m_dwValidData |= DMUS_OBJ_NAME;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_NAME;
    }
}

void CDescriptor::ClearCategory()

{
    if (m_pwzCategory) delete[] m_pwzCategory;
    m_pwzCategory = NULL;
    m_dwValidData &= ~DMUS_OBJ_CATEGORY;
}

void CDescriptor::SetCategory(WCHAR* pwzCategory)

{
    if(pwzCategory == NULL)
    {
        return;
    }

    HRESULT hr = S_OK;
    WCHAR wszCategory[DMUS_MAX_CATEGORY] = L"";

    ClearCategory();
    hr = StringCchCopyW(wszCategory, DMUS_MAX_CATEGORY, pwzCategory); 

    if(SUCCEEDED(hr))
    {
        size_t cLen = wcslen(wszCategory);
        m_pwzCategory = new WCHAR[cLen + 1];

        if(m_pwzCategory == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        
        if(SUCCEEDED(hr))
        {
            wcsncpy(m_pwzCategory, wszCategory, cLen + 1);
        }
    }

    if(SUCCEEDED(hr))
    {
        m_dwValidData |= DMUS_OBJ_CATEGORY;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_CATEGORY;
    }
}

void CDescriptor::ClearFileName()

{
    if (m_pwzFileName) delete[] m_pwzFileName;
    m_pwzFileName = NULL;
    m_dwValidData &= ~DMUS_OBJ_FILENAME;
}

// return S_FALSE if the filename is already set to this
HRESULT CDescriptor::SetFileName(WCHAR *pwzFileName)

{
    if(pwzFileName == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = E_FAIL;
    WCHAR wszFileName[DMUS_MAX_FILENAME] = L"";

    // Make a safe copy of the passed string
    hr = StringCchCopyW(wszFileName, DMUS_MAX_FILENAME, pwzFileName);
    if(FAILED(hr))
    {
        return E_INVALIDARG;
    }

    // We return without touching the valid data flags if we fail here
    if( m_pwzFileName )
    {
        if( !_wcsicmp( m_pwzFileName, wszFileName ))
        {
            return S_FALSE;
        }
    }

    // This is actually unnecessary since we're returning on failure above
    // But then that code might change. So to keep it absolutely clear... 
    if(SUCCEEDED(hr))
    {
        ClearFileName();

        size_t cLen = wcslen(wszFileName);
        m_pwzFileName = new WCHAR[cLen + 1];
        if (m_pwzFileName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            hr = StringCchCopyW(m_pwzFileName, cLen + 1, wszFileName);
        }
    }

    if(SUCCEEDED(hr))
    {
        m_dwValidData |= DMUS_OBJ_FILENAME;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_FILENAME;
    }

    return hr;
}

void CDescriptor::ClearIStream()

{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pIStream)
    {
        m_pIStream->Release();
    }
    m_pIStream      = NULL;
    m_liStartPosition.QuadPart = 0;
    m_dwValidData  &= ~DMUS_OBJ_STREAM;
    LeaveCriticalSection(&m_CriticalSection);
}

void CDescriptor::SetIStream(IStream *pIStream)

{
    EnterCriticalSection(&m_CriticalSection);
    ClearIStream();

    m_pIStream = pIStream;

    if (m_pIStream)
    {
        ULARGE_INTEGER  libNewPosition;
        m_liStartPosition.QuadPart = 0;
        m_pIStream->Seek( m_liStartPosition, STREAM_SEEK_CUR, &libNewPosition );
        m_liStartPosition.QuadPart = libNewPosition.QuadPart;
        m_pIStream->AddRef();
        m_dwValidData |= DMUS_OBJ_STREAM;
    }
    LeaveCriticalSection(&m_CriticalSection);
}

BOOL CDescriptor::IsExtension(WCHAR *pwzExtension)

{
    if (pwzExtension && m_pwzFileName)
    {
        DWORD dwX;
        DWORD dwLen = wcslen(m_pwzFileName);
        for (dwX = 0; dwX < dwLen; dwX++)
        {
            if (m_pwzFileName[dwX] == L'.') break;
        }
        dwX++;
        if (dwX < dwLen)
        {
            return !_wcsicmp(pwzExtension,&m_pwzFileName[dwX]);
        }
    }
    return FALSE;
}

void CDescriptor::Get(LPDMUS_OBJECTDESC pDesc)

{
    if(pDesc == NULL)
    {
        return;
    }

    // Don't return the IStream insterface. Once set, this becomes private to the loader.
    pDesc->dwValidData = m_dwValidData & ~DMUS_OBJ_STREAM;

    pDesc->guidObject = m_guidObject;
    pDesc->guidClass = m_guidClass;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    pDesc->llMemLength = m_llMemLength;
    pDesc->pbMemData = m_pbMemData;
    if (m_pwzName) 
    {
        wcsncpy( pDesc->wszName, m_pwzName, DMUS_MAX_NAME ); 
    }
    if (m_pwzCategory)
    {
        wcsncpy( pDesc->wszCategory,m_pwzCategory, DMUS_MAX_CATEGORY ); 
    }
    if (m_pwzFileName)
    {
        wcsncpy( pDesc->wszFileName, m_pwzFileName, DMUS_MAX_FILENAME);
    }
}

void CDescriptor::Set(LPDMUS_OBJECTDESC pDesc)

{
    m_dwValidData = pDesc->dwValidData;
    m_guidObject = pDesc->guidObject;
    m_guidClass = pDesc->guidClass;
    m_ftDate = pDesc->ftDate;
    m_vVersion = pDesc->vVersion;
    m_llMemLength = pDesc->llMemLength;
    m_pbMemData = pDesc->pbMemData;
    ClearName();
    if (pDesc->dwValidData & DMUS_OBJ_NAME)
    {
        pDesc->wszName[DMUS_MAX_NAME - 1] = 0;  // Force string length, in case of error.
        SetName(pDesc->wszName);
    }
    ClearCategory();
    if (pDesc->dwValidData & DMUS_OBJ_CATEGORY)
    {
        pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = 0;  // Force string length, in case of error.
        SetCategory(pDesc->wszCategory);
    }
    ClearFileName();
    if (pDesc->dwValidData & DMUS_OBJ_FILENAME)
    {
        pDesc->wszFileName[DMUS_MAX_FILENAME - 1] = 0;  // Force string length, in case of error.
        SetFileName(pDesc->wszFileName);
    }
    ClearIStream();
    if (pDesc->dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pDesc->pStream);
    }
}

void CDescriptor::Copy(CDescriptor *pDesc)

{
    m_dwValidData = pDesc->m_dwValidData;
    m_guidObject = pDesc->m_guidObject;
    m_guidClass = pDesc->m_guidClass;
    m_ftDate = pDesc->m_ftDate;
    m_vVersion = pDesc->m_vVersion;
    m_llMemLength = pDesc->m_llMemLength;
    m_pbMemData = pDesc->m_pbMemData;
    ClearName();
    if (pDesc->m_dwValidData & DMUS_OBJ_NAME)
    {
        SetName(pDesc->m_pwzName);
    }
    ClearCategory();
    if (pDesc->m_dwValidData & DMUS_OBJ_CATEGORY)
    {
        SetCategory(pDesc->m_pwzCategory);
    }
    ClearFileName();
    if (pDesc->m_dwValidData & DMUS_OBJ_FILENAME)
    {
        SetFileName(pDesc->m_pwzFileName);
    }
    ClearIStream();
    if (pDesc->m_dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pDesc->m_pIStream);
    }
}

void CDescriptor::Merge(CDescriptor *pSource)

{
    if (pSource->m_dwValidData & DMUS_OBJ_OBJECT)
    {
        m_dwValidData |= DMUS_OBJ_OBJECT;
        m_guidObject = pSource->m_guidObject;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_CLASS)
    {
        m_dwValidData |= DMUS_OBJ_CLASS;
        m_guidClass = pSource->m_guidClass;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_NAME)
    {
        m_dwValidData |= DMUS_OBJ_NAME;
        SetName(pSource->m_pwzName);
    }
    if (pSource->m_dwValidData & DMUS_OBJ_CATEGORY)
    {
        m_dwValidData |= DMUS_OBJ_CATEGORY;
        SetCategory(pSource->m_pwzCategory);
    }
    if (pSource->m_dwValidData & DMUS_OBJ_VERSION)
    {
        m_dwValidData |= DMUS_OBJ_VERSION;
        m_vVersion = pSource->m_vVersion;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_DATE)
    {
        m_dwValidData |= DMUS_OBJ_DATE;
        m_ftDate = pSource->m_ftDate; 
    }
    if (pSource->m_dwValidData & DMUS_OBJ_FILENAME)
    {
        if (!(m_dwValidData & DMUS_OBJ_FILENAME))
        {
            if (SUCCEEDED(SetFileName(pSource->m_pwzFileName)))
            {
                m_dwValidData |= (pSource->m_dwValidData & 
                    (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH | DMUS_OBJ_URL));
            }
        }
    }
    if (pSource->m_dwValidData & DMUS_OBJ_MEMORY)
    {
        m_pbMemData = pSource->m_pbMemData;
        m_llMemLength = pSource->m_llMemLength;
        if (m_llMemLength && m_pbMemData)
        {
            m_dwValidData |= DMUS_OBJ_MEMORY;
        }
        else
        {
            m_dwValidData &= ~DMUS_OBJ_MEMORY;
        }
    }
    if (pSource->m_dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pSource->m_pIStream);
    }
}

CObject::CObject(CClass *pClass)

{
    m_dwScanBits = 0;
    m_pClass = pClass;
    m_pIDMObject = NULL;
    m_pvecReferences = NULL;
}

CObject::CObject(CClass *pClass, CDescriptor *pDesc)

{
    m_dwScanBits = 0;
    m_pClass = pClass;
    m_pIDMObject = NULL;
    m_ObjectDesc.Copy(pDesc);
    m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
    if (!(m_ObjectDesc.m_dwValidData & DMUS_OBJ_CLASS))
    {
        m_ObjectDesc.m_guidClass = pClass->m_ClassDesc.m_guidClass;
        m_ObjectDesc.m_dwValidData |= 
            (pClass->m_ClassDesc.m_dwValidData & DMUS_OBJ_CLASS);
    }
    m_pvecReferences = NULL;
}


CObject::~CObject()

{
    if (m_pIDMObject)
    {
        m_pIDMObject->Release();
        m_pIDMObject = NULL;
    }
    delete m_pvecReferences;
}

HRESULT CObject::Parse()

{
    if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        return ParseFromFile();
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
    {
        return ParseFromMemory();
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
    {
        return ParseFromStream();
    }
    assert(false);
    return E_FAIL;
}

HRESULT CObject::ParseFromFile()

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        WCHAR wzFullPath[DMUS_MAX_FILENAME];
        ZeroMemory( wzFullPath, sizeof(WCHAR) * DMUS_MAX_FILENAME );
        CFileStream *pStream = new CFileStream ( m_pClass->m_pLoader );
        if (pStream)
        {
            if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH)
            {
                wcsncpy(wzFullPath, m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME);
            }
            else
            {
                m_pClass->GetPath(wzFullPath);
                wcsncat(wzFullPath, m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME - wcslen(wzFullPath) - 1);
            }
            hr = pStream->Open(wzFullPath,GENERIC_READ);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC DESC;
                memset((void *)&DESC,0,sizeof(DESC));
                DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,&DESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(&DESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


HRESULT CObject::ParseFromMemory()

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CMemStream *pStream = new CMemStream ( m_pClass->m_pLoader );
        if (pStream)
        {
            hr = pStream->Open(m_ObjectDesc.m_pbMemData,m_ObjectDesc.m_llMemLength);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC DESC;
                memset((void *)&DESC,0,sizeof(DESC));
                DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,&DESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(&DESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


HRESULT CObject::ParseFromStream()

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CStream *pStream = new CStream ( m_pClass->m_pLoader );
        if (pStream)
        {
            hr = pStream->Open(m_ObjectDesc.m_pIStream,
                m_ObjectDesc.m_liStartPosition);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC DESC;
                memset((void *)&DESC,0,sizeof(DESC));
                DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,&DESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(&DESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


// Record that this object can be garbage collected and prepare to store its references.
// Must be called before any of CObject's other routines.
HRESULT CObject::GC_Collectable()

{
    m_dwScanBits |= SCAN_GC;
    assert(!m_pvecReferences);

    m_pvecReferences = new SmartRef::Vector<CObject*>;
    if (!m_pvecReferences)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CObject::GC_AddReference(CObject *pObject)

{
    if(pObject == NULL)
    {
        return E_POINTER;
    }

    assert(m_dwScanBits & SCAN_GC && m_pvecReferences);

    // don't track references to objects that aren't garbage collected
    if (!(pObject->m_dwScanBits & SCAN_GC))
        return S_OK;

    UINT uiPosNext = m_pvecReferences->size();
    for (UINT i = 0; i < uiPosNext; ++i)
    {
        if ((*m_pvecReferences)[i] == pObject)
            return S_OK;
    }

    if (!m_pvecReferences->AccessTo(uiPosNext))
        return E_OUTOFMEMORY;
    (*m_pvecReferences)[uiPosNext] = pObject;
    return S_OK;
}

HRESULT CObject::GC_RemoveReference(CObject *pObject)

{
    assert(m_dwScanBits & SCAN_GC && m_pvecReferences);

    SmartRef::Vector<CObject*> &vecRefs = *m_pvecReferences;
    UINT iEnd = vecRefs.size();
    for (UINT i = 0; i < iEnd; ++i)
    {
        if (vecRefs[i] == pObject)
        {
            // Remove by clearing the pointer.
            // The open slot will be compacted during garbage collection (GC_Mark).
            vecRefs[i] = NULL;
            return S_OK;
        }
    }
    return S_FALSE;
}

// Helper method used to implement ReleaseObject.
HRESULT CObject::GC_RemoveAndDuplicateInParentList()
{
    CObject* pObjectToFind = NULL;
    HRESULT hr = m_pClass->FindObject(&m_ObjectDesc, &pObjectToFind, this);
    if (SUCCEEDED(hr) && pObjectToFind)
    {
        m_pClass->GC_Replace(this, NULL);
    }
    else
    {
        CObject *pObjectUnloaded = new CObject(m_pClass, &m_ObjectDesc);
        if (!pObjectUnloaded)
        {
            return E_OUTOFMEMORY;
        }

        m_pClass->GC_Replace(this, pObjectUnloaded);
    }
    return S_OK;
}

HRESULT CObject::Load()

{
    // See if we have one of the fields we need to load
    if (!(m_ObjectDesc.m_dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM)))
    {
        Trace(1, "Error: GetObject failed because the requested object was not already cached and the supplied desciptor did not specify a source to load the object from (DMUS_OBJ_FILENAME, DMUS_OBJ_MEMORY, or DMUS_OBJ_STREAM).");
        return DMUS_E_LOADER_NOFILENAME;
    }

    // Create the object
    SmartRef::ComPtr<IDirectMusicObject> scomIObject = NULL;
    HRESULT hr = CoCreateInstance(m_ObjectDesc.m_guidClass, NULL, CLSCTX_INPROC_SERVER, IID_IDirectMusicObject, reinterpret_cast<void**>(&scomIObject));
    if (FAILED(hr))
        return hr;

    // Create the stream the object will load from
    SmartRef::ComPtr<IStream> scomIStream;
    if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        WCHAR wzFullPath[DMUS_MAX_FILENAME];
        ZeroMemory( wzFullPath, sizeof(WCHAR) * DMUS_MAX_FILENAME );
        CFileStream *pStream = new CFileStream ( m_pClass->m_pLoader );
        if (!pStream)
            return E_OUTOFMEMORY;
        scomIStream = pStream;

        if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH)
        {
            wcsncpy(wzFullPath, m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME);
        }
        else
        {
            m_pClass->GetPath(wzFullPath);
            wcsncat(wzFullPath,m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME - wcslen(wzFullPath) - 1);
        }
        hr = pStream->Open(wzFullPath,GENERIC_READ);
        if (FAILED(hr))
            return hr;
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
    {
        CMemStream *pStream = new CMemStream ( m_pClass->m_pLoader );
        if (!pStream)
            return E_OUTOFMEMORY;
        scomIStream = pStream;
        hr = pStream->Open(m_ObjectDesc.m_pbMemData, m_ObjectDesc.m_llMemLength);
        if (FAILED(hr))
            return hr;
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
    {
        CStream *pStream = new CStream ( m_pClass->m_pLoader );
        if (!pStream)
            return E_OUTOFMEMORY;
        scomIStream = pStream;
        hr = pStream->Open(m_ObjectDesc.m_pIStream, m_ObjectDesc.m_liStartPosition);
        if (FAILED(hr))
            return hr;
    }

    // Load the object
    IPersistStream* pIPS = NULL;
    hr = scomIObject->QueryInterface( IID_IPersistStream, (void**)&pIPS );
    if (FAILED(hr))
        return hr;
    // Save the new object.  Needs to be done before loading because of circular references.  While this object
    // loads it could get other objects and those other objects could need to get this object.
    SafeRelease(m_pIDMObject);
    m_pIDMObject = scomIObject.disown();
    hr = pIPS->Load( scomIStream );
    pIPS->Release();
    if (FAILED(hr))
    {
        // Clear the object we set above.
        SafeRelease(m_pIDMObject);
        return hr;
    }

    // Merge in descriptor information from the object
    CDescriptor Desc;
    DMUS_OBJECTDESC DESC;
    memset((void *)&DESC,0,sizeof(DESC));
    DESC.dwSize = sizeof (DMUS_OBJECTDESC);
    m_pIDMObject->GetDescriptor(&DESC);
    Desc.Set(&DESC);
    m_ObjectDesc.Merge(&Desc);
    m_ObjectDesc.m_dwValidData |= DMUS_OBJ_LOADED;
    m_ObjectDesc.Get(&DESC);
    m_pIDMObject->SetDescriptor(&DESC);
    return hr;
}

// Collect everything that is unmarked.
void CObjectList::GC_Sweep(BOOL bOnlyScripts)

{
    // sweep through looking for unmarked GC objects
    CObject *pObjectPrev = NULL;
    CObject *pObjectNext = NULL;
    for (CObject *pObject = this->GetHead(); pObject; pObject = pObjectNext)
    {
        // get the next item now since we could be messing with the list
        pObjectNext = pObject->GetNext();

        bool fRemoved = false;
        if(bOnlyScripts && pObject->m_ObjectDesc.m_guidClass != CLSID_DirectMusicScript)
        {
            pObjectPrev = pObject;
            continue;
        }


        if (pObject->m_dwScanBits & SCAN_GC)
        {
            if (!(pObject->m_dwScanBits & SCAN_GC_MARK))
            {
                // the object is unused

                // Zombie it to break any cyclic references
                IDirectMusicObject *pIDMO = pObject->m_pIDMObject;
                if (pIDMO)
                {
                    IDirectMusicObjectP *pIDMO8 = NULL;
                    HRESULT hr = pIDMO->QueryInterface(IID_IDirectMusicObjectP, reinterpret_cast<void**>(&pIDMO8));
                    if (SUCCEEDED(hr))
                    {
                        pIDMO8->Zombie();
                        pIDMO8->Release();
                    }

#ifdef DBG
                    DebugTrace(4, SUCCEEDED(hr) ? "   *%08X Zombied\n" : "   *%08X no IDirectMusicObjectP interface\n", pObject);
#endif
                }

                // remove it from the list
                if (pObjectPrev)
                    pObjectPrev->Remove(pObject);
                else
                    this->RemoveHead();
                delete pObject;
                fRemoved = true;
            }
            else
            {
                // clear mark for next time
                pObject->m_dwScanBits &= ~SCAN_GC_MARK;
            }
        }

        if (!fRemoved)
            pObjectPrev = pObject;
    }
}

CClass::CClass(CLoader *pLoader)

{
    assert(pLoader);
    m_fDirSearched = FALSE;
    m_pLoader = pLoader;
    m_fKeepObjects = pLoader->m_fKeepObjects;
    m_dwLastIndex = NULL;
    m_pLastObject = NULL;
}

CClass::CClass(CLoader *pLoader, CDescriptor *pDesc)

{
    assert(pLoader);
    assert(pDesc);

    m_fDirSearched = FALSE;
    m_pLoader = pLoader;
    m_fKeepObjects = pLoader->m_fKeepObjects;
    m_dwLastIndex = NULL;
    m_pLastObject = NULL;

    // Set up this class's descritor with just the class id.
    m_ClassDesc.m_guidClass = pDesc->m_guidClass;
    m_ClassDesc.m_dwValidData = DMUS_OBJ_CLASS;
}


CClass::~CClass()

{
    ClearObjects(FALSE,NULL);
}

void CClass::ClearObjects(BOOL fKeepCache, WCHAR *pwzExtension)

//  Clear objects from the class list, optionally keep 
//  cached objects or objects that are not of the requested extension.

{
    m_fDirSearched = FALSE;
    CObjectList KeepList;   // Use to store objects to keep.
    while (!m_ObjectList.IsEmpty())
    {
        CObject *pObject = m_ObjectList.RemoveHead();
        DMUS_OBJECTDESC DESC;
        pObject->m_ObjectDesc.Get(&DESC);
        // If the keepCache flag is set, we want to hang on to the object
        // if it is GM.dls, an object that's currently cached, or
        // an object with a different extension from what we are looking for.
        if (fKeepCache && 
            ((DESC.guidObject == GUID_DefaultGMCollection)
#ifdef DRAGON
            || (DESC.guidObject == GUID_DefaultGMDrums)
#endif
            || pObject->m_pIDMObject 
            || !pObject->m_ObjectDesc.IsExtension(pwzExtension)))
        {
            KeepList.AddHead(pObject);
        }
        else
        {
            delete pObject;
        }
    }
    //  Now put cached objects back in list.
    while (!KeepList.IsEmpty())
    {
        CObject *pObject = KeepList.RemoveHead();
        m_ObjectList.AddHead(pObject);
    }
    m_pLastObject = NULL;
}


HRESULT CClass::FindObject(CDescriptor *pDesc,CObject ** ppObject, CObject *pNotThis)

{
    if(pDesc == NULL)
    {
        return E_POINTER;
    }

    DWORD dwSearchBy = pDesc->m_dwValidData;
    CObject *pObject = NULL;

    if (dwSearchBy & DMUS_OBJ_OBJECT)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_OBJECT)
            {
                if (pObject->m_ObjectDesc.m_guidObject == pDesc->m_guidObject)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_MEMORY)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
            {
                if (pObject->m_ObjectDesc.m_pbMemData == pDesc->m_pbMemData)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_STREAM)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
            {
                if (pObject->m_ObjectDesc.m_pIStream == pDesc->m_pIStream)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if ((dwSearchBy & DMUS_OBJ_FILENAME) && (dwSearchBy & DMUS_OBJ_FULLPATH))
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if ((pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME) &&
                (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH))
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzFileName,  pDesc->m_pwzFileName))
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if ((dwSearchBy & DMUS_OBJ_NAME) && (dwSearchBy & DMUS_OBJ_CATEGORY))
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if ((pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_NAME) &&
                (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_CATEGORY))
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzCategory,pDesc->m_pwzCategory))
                {
                    if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzName, pDesc->m_pwzName))
                    {
                        *ppObject = pObject;
                        return S_OK;
                    }
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_NAME)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_NAME)
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzName, pDesc->m_pwzName))
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_FILENAME)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
            {
                if ((dwSearchBy & DMUS_OBJ_FULLPATH) == (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH))
                {
                    if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzFileName, pDesc->m_pwzFileName))
                    {
                        *ppObject = pObject;
                        return S_OK;
                    }
                }
                else
                {
                    WCHAR *pC1 = pObject->m_ObjectDesc.m_pwzFileName;
                    WCHAR *pC2 = pDesc->m_pwzFileName;
                    if (dwSearchBy & DMUS_OBJ_FULLPATH)
                    {
                        pC1 = wcsrchr(pObject->m_ObjectDesc.m_pwzFileName, L'\\');
                    }
                    else
                    {
                        pC2 = wcsrchr(pDesc->m_pwzFileName, '\\');
                    }
                    if (pC1 && pC2)
                    {
                        if (!_wcsicmp(pC1,pC2))
                        {
                            *ppObject = pObject;
                            return S_OK;
                        }
                    }
                }
            }
        }
    }

    *ppObject = NULL;
    return DMUS_E_LOADER_OBJECTNOTFOUND;
}

HRESULT CClass::EnumerateObjects(DWORD dwIndex,CDescriptor *pDesc)

{
    if(pDesc == NULL)
    {
        return E_POINTER;
    }

    if (m_fDirSearched == FALSE)
    {
//      SearchDirectory();
    }
    if ((dwIndex < m_dwLastIndex) || (m_pLastObject == NULL))
    {
        m_dwLastIndex = 0;
        m_pLastObject = m_ObjectList.GetHead();
    }
    while (m_dwLastIndex < dwIndex)
    {
        if (!m_pLastObject) break;
        m_dwLastIndex++;
        m_pLastObject = m_pLastObject->GetNext();
    }
    if (m_pLastObject)
    {
        pDesc->Copy(&m_pLastObject->m_ObjectDesc);
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CClass::GetPath(WCHAR* pwzPath)

{
    if(pwzPath == NULL)
    {
        return E_POINTER;
    }

    if (m_ClassDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        wcsncpy(pwzPath, m_ClassDesc.m_pwzFileName, DMUS_MAX_FILENAME);
        return S_OK;
    }
    else 
    {
        return m_pLoader->GetPath(pwzPath);
    }
}

// returns S_FALSE if the search directory is already set to this.
HRESULT CClass::SetSearchDirectory(WCHAR * pwzPath,BOOL fClear)

{
    if(pwzPath == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr;

    hr = m_ClassDesc.SetFileName(pwzPath);
    if (SUCCEEDED(hr))
    {
        m_ClassDesc.m_dwValidData |= DMUS_OBJ_FULLPATH;
    }
    if (fClear)
    {
        CObjectList KeepList;   // Use to store objects to keep.
        while (!m_ObjectList.IsEmpty())
        {
            CObject *pObject = m_ObjectList.RemoveHead();
            if (pObject->m_pIDMObject)
            {
                KeepList.AddHead(pObject);
            }
            else
            {
                // check for the special case of the default gm collection.
                // don't clear that one out.
                DMUS_OBJECTDESC DESC;
                pObject->m_ObjectDesc.Get(&DESC);
                if( DESC.guidObject == GUID_DefaultGMCollection )
                {
                    KeepList.AddHead(pObject);
                }
                else
                {
                    delete pObject;
                }
            }
        }
        //  Now put cached objects back in list.
        while (!KeepList.IsEmpty())
        {
            CObject *pObject = KeepList.RemoveHead();
            m_ObjectList.AddHead(pObject);
        }
        m_pLastObject = NULL;
    }
    return hr;
}

HRESULT CClass::GetObject(CDescriptor *pDesc, CObject ** ppObject)

{
    if(pDesc == NULL)
    {
        return E_POINTER;
    }
    
    HRESULT hr = FindObject(pDesc,ppObject);
    if (SUCCEEDED(hr)) // Okay, found object in list.
    {
        return hr;
    }
    *ppObject = new CObject (this, pDesc);
    if (*ppObject)
    {
        m_ObjectList.AddHead(*ppObject);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

void CClass::RemoveObject(CObject* pRemoveObject)
//  Remove an object from the class list
{
    CObjectList KeepList;   // Use to store objects to keep.
    while (!m_ObjectList.IsEmpty())
    {
        CObject *pObject = m_ObjectList.RemoveHead();
        if( pObject == pRemoveObject )
        {
            delete pObject;
            // we can assume no duplicates, and we should avoid comparing the deleted
            // object to the remainder of the list
            break;
        }
        else
        {
            KeepList.AddHead(pObject);
        }
    }
    //  Now put cached objects back in list.
    while (!KeepList.IsEmpty())
    {
        CObject *pObject = KeepList.RemoveHead();
        m_ObjectList.AddHead(pObject);
    }
    m_pLastObject = NULL;
}

HRESULT CClass::ClearCache(bool fClearStreams)

{
    CObject *pObject = m_ObjectList.GetHead();
    CObject *pObjectPrev = NULL; // remember the previous object -- needed to quickly remove the current object from the list
    CObject *pObjectNext = NULL; // remember the next object -- needed because the current object may be removed from the list
    for (;pObject;pObject = pObjectNext)
    {
        if (fClearStreams)
            pObject->m_ObjectDesc.ClearIStream();
        pObjectNext = pObject->GetNext();
        if (pObject->m_pIDMObject)
        {
            if (pObject->m_dwScanBits & SCAN_GC)
            {
                // Other objects may have references to this one so we need to keep this object around
                // and track its references.  We'll hold onto the DMObject pointer too because we may
                // later need to Zombie the object in order to break a cyclic reference.

                // We'll place an unloaded object with a duplicate descriptor in the cache to match the
                // non-GC behavior and then move the original object into a list of released objects that
                // will eventually be reclaimed by CollectGarbage.

                CObject *pObjectUnloaded = new CObject(this, &pObject->m_ObjectDesc);
                if (!pObjectUnloaded)
                {
                    return E_OUTOFMEMORY;
                }

                if (!pObjectPrev)
                    m_ObjectList.Remove(pObject);
                else
                    pObjectPrev->Remove(pObject);
                m_ObjectList.AddHead(pObjectUnloaded);
                m_pLoader->GC_UpdateForReleasedObject(pObject);
            }
            else
            {
                pObject->m_pIDMObject->Release();
                pObject->m_pIDMObject = NULL;
                pObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;

                pObjectPrev = pObject;
            }
        }
    }

    return S_OK;
}

// return S_FALSE if the cache is already enabled according to fEnable,
// indicating it's already been done.
HRESULT CClass::EnableCache(BOOL fEnable)

{
    HRESULT hr = S_FALSE;
    if (!fEnable)
    {
        ClearCache(false);
    }
    if( m_fKeepObjects != fEnable )
    {
        hr = S_OK;
        m_fKeepObjects = fEnable;
    }
    return hr;
}

typedef struct ioClass
{
    GUID    guidClass;
} ioClass;


HRESULT CClass::SaveToCache(IRIFFStream *pRiff)

{
    if(pRiff == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    IStream* pIStream = NULL;
    MMCKINFO ck;
    WORD wStructSize = 0;
    DWORD dwBytesWritten = 0;
//  DWORD dwBufferSize;
    ioClass oClass;

    ZeroMemory(&ck, sizeof(MMCKINFO));

    pIStream = pRiff->GetStream();
    if( pIStream == NULL )
    {
        // I don't think anybody should actually be calling this function
        // if they don't have a stream.  Currently, this is only called by
        // SaveToCache file.  It definitely has a stream when it calls
        // AllocRIFFStream and the stream should still be there when
        // we arrive here.
        assert(false);

        return DMUS_E_LOADER_NOFILENAME;
    }

    // Write class chunk header
    ck.ckid = FOURCC_CLASSHEADER;
    if( pRiff->CreateChunk( &ck, 0 ) == S_OK )
    {
        wStructSize = sizeof(ioClass);
        hr = pIStream->Write( &wStructSize, sizeof(wStructSize), &dwBytesWritten );
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(wStructSize) )
        {
            pIStream->Release();
            return DMUS_E_CANNOTWRITE;
        }
        // Prepare ioClass structure
    //  memset( &oClass, 0, sizeof(ioClass) );
        memcpy( &oClass.guidClass, &m_ClassDesc.m_guidClass, sizeof(GUID) );

        // Write Class header data
        hr = pIStream->Write( &oClass, sizeof(oClass), &dwBytesWritten);
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(oClass) )
        {
            hr = DMUS_E_CANNOTWRITE;
        }
        else
        {
            if( pRiff->Ascend( &ck, 0 ) != S_OK )
            {
                hr = DMUS_E_CANNOTSEEK;
            }
        }

    }
    else
    {
        hr = DMUS_E_CANNOTSEEK;
    }
    pIStream->Release();
    return hr;
}

void CClass::PreScan()

/*  Prior to scanning a directory, mark all currently loaded objects
    so they won't be confused with objects loaded in the scan or
    referenced by the cache file.
*/

{
    CObject *pObject = m_ObjectList.GetHead();
    for (;pObject != NULL; pObject = pObject->GetNext())
    {
        // clear the lower fields and set SCAN_PRIOR
        pObject->m_dwScanBits &= ~(SCAN_CACHE | SCAN_PARSED | SCAN_SEARCH);
        pObject->m_dwScanBits |= SCAN_PRIOR;
    }
}

// Helper method used to implement RemoveAndDuplicateInParentList.
void CClass::GC_Replace(CObject *pObject, CObject *pObjectReplacement)

{
    m_ObjectList.Remove(pObject);
    if (pObjectReplacement)
    {
        m_ObjectList.AddHead(pObjectReplacement);
    }
}

HRESULT CClass::SearchDirectory(WCHAR *pwzExtension)

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ClassDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CFileStream *pStream = new CFileStream ( m_pLoader );
        if (pStream)
        {
            // We need the double the MAX_PATH size since we'll be catenating strings of MAX_PATH
            const int nBufferSize = 2 * MAX_PATH;
            WCHAR wzPath[nBufferSize];
            memset(wzPath, 0, sizeof(WCHAR) * nBufferSize);
            hr = GetPath(wzPath);
            if (SUCCEEDED(hr))
            {
                hr = S_FALSE;
                CObjectList TempList;
#ifndef UNDER_CE
                char szPath[nBufferSize];
                WIN32_FIND_DATAA fileinfoA;
#endif      
                WIN32_FIND_DATAW fileinfoW;
                HANDLE  hFindFile;
                CObject * pObject;
                
                // GetPath copies at most MAX_PATH number of chars to wzPath
                // This means that we have enough space to do a cat safely
                WCHAR wszWildCard[3] = L"*.";
                wcsncat(wzPath, wszWildCard, wcslen(wszWildCard));
                if (pwzExtension)
                {
                    // Make sure there's enough space left in wzPath to cat pwzExtension
                    size_t cPathLen = wcslen(wzPath);
                    size_t cExtLen = wcslen(pwzExtension);

                    // Do we have enough space to write the extension + the NULL char?
                    if((nBufferSize - cPathLen - 1) > cExtLen)
                    {
                        wcsncat(wzPath, pwzExtension, nBufferSize - wcslen(pwzExtension) - 1);
                    }
                }
#ifndef UNDER_CE
                if (g_fIsUnicode)
#endif
                {
                    hFindFile = FindFirstFileW( wzPath, &fileinfoW );
                }
#ifndef UNDER_CE
                else
                {
                    wcstombs( szPath, wzPath, nBufferSize );
                    hFindFile = FindFirstFileA( szPath, &fileinfoA );
                }
#endif          
                if( hFindFile == INVALID_HANDLE_VALUE )
                {
                    pStream->Release();
                    pIObject->Release();
                    return S_FALSE;
                }
                ClearObjects(TRUE, pwzExtension); // Clear everything but the objects currently loaded.
                for (;;)
                {
                    BOOL fGoParse = FALSE;
                    CDescriptor Desc;
                    GetPath(wzPath);
#ifndef UNDER_CE
                    if (g_fIsUnicode)
#endif
                    {
                        Desc.m_ftDate = fileinfoW.ftLastWriteTime;
                        wcsncat(wzPath, fileinfoW.cFileName, DMUS_MAX_FILENAME);
                    }
#ifndef UNDER_CE
                    else
                    {
                        Desc.m_ftDate = fileinfoA.ftLastWriteTime;
                        WCHAR wzFileName[MAX_PATH];
                        mbstowcs( wzFileName, fileinfoA.cFileName, MAX_PATH );
                        wcsncat(wzPath, wzFileName, DMUS_MAX_FILENAME);
                    }
#endif
                    HRESULT hrTemp = Desc.SetFileName(wzPath);
                    if (SUCCEEDED(hrTemp))
                    {
                        Desc.m_dwValidData = (DMUS_OBJ_DATE | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
                    }
                    else
                    {
                        // If we couldn't set the file name, we probably don't want to continue
                        hr = hrTemp;
                        break;
                    }
                    if (SUCCEEDED(FindObject(&Desc,&pObject))) // Make sure we don't already have it.
                    {
#ifndef UNDER_CE
                        if (g_fIsUnicode)
#endif
                        {
                            fGoParse = (fileinfoW.nFileSizeLow != pObject->m_ObjectDesc.m_dwFileSize);
                            if (!fGoParse)
                            {
                                fGoParse = !memcmp(&fileinfoW.ftLastWriteTime,&pObject->m_ObjectDesc.m_ftDate,sizeof(FILETIME));
                            }
                        }
#ifndef UNDER_CE
                        else
                        {
                            fGoParse = (fileinfoA.nFileSizeLow != pObject->m_ObjectDesc.m_dwFileSize);
                            if (!fGoParse)
                            {
                                fGoParse = !memcmp(&fileinfoA.ftLastWriteTime,&pObject->m_ObjectDesc.m_ftDate,sizeof(FILETIME));
                            }
                        }
#endif
                        // Yet, disregard if it is already loaded.
                        if (pObject->m_pIDMObject) fGoParse = FALSE;
                    }
                    else fGoParse = TRUE;
                    if (fGoParse)
                    {
                        hrTemp = pStream->Open(Desc.m_pwzFileName,GENERIC_READ);
                        if (SUCCEEDED(hrTemp))
                        {
                            DMUS_OBJECTDESC DESC;
                            memset((void *)&DESC,0,sizeof(DESC));
                            DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                            hrTemp = pIObject->ParseDescriptor(pStream,&DESC);
                            if (SUCCEEDED(hrTemp))
                            {
                                hr = S_OK;
                                CDescriptor ParseDesc;
                                ParseDesc.Set(&DESC);
                                Desc.Merge(&ParseDesc);
#ifndef UNDER_CE
                                if (g_fIsUnicode)
#endif
                                {
                                    Desc.m_dwFileSize = fileinfoW.nFileSizeLow;
                                    Desc.m_ftDate = fileinfoW.ftLastWriteTime;
                                }
#ifndef UNDER_CE
                                else
                                {
                                    Desc.m_dwFileSize = fileinfoA.nFileSizeLow;
                                    Desc.m_ftDate = fileinfoA.ftLastWriteTime;
                                }
#endif                          
                                if (pObject)
                                {
                                    pObject->m_ObjectDesc.Copy(&Desc);
                                    pObject->m_dwScanBits |= SCAN_PARSED | SCAN_SEARCH;
                                }
                                else
                                {
                                    pObject = new CObject(this, &Desc);
                                    if (pObject)
                                    {
                                        TempList.AddHead(pObject);
                                        pObject->m_dwScanBits |= SCAN_PARSED | SCAN_SEARCH;
                                    }
                                }
                            }
                            pStream->Close();
                        }
                    }
#ifndef UNDER_CE
                    if (g_fIsUnicode)
#endif
                    {
                        if ( !FindNextFileW( hFindFile, &fileinfoW ) ) break;
                    }
#ifndef UNDER_CE
                    else
                    {
                        if ( !FindNextFileA( hFindFile, &fileinfoA ) ) break;
                    }
#endif
                }
                FindClose(hFindFile );
                while (!TempList.IsEmpty())
                {
                    pObject = TempList.RemoveHead();
                    m_ObjectList.AddHead(pObject);
                }
                m_fDirSearched = TRUE;
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\riff.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// riff.h
//

#include <objbase.h>

#ifndef __RIFF__
#define __RIFF__
#include <windows.h>
#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IRIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IRIFFStream
DECLARE_INTERFACE_(IRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD(Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};



struct CRIFFStream : IRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IRIFFStream ) )
        {
            *ppvObj = (IRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT /*wFlags*/);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
*/
STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff );

#endif  // __RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\stream.cpp ===
// stream.cpp
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL

#include <objbase.h>
#include "debug.h"

#include "debug.h" 
#include "dmusicc.h" // Using specific path for now, since the headers are changing.
#include "dmusici.h" // Using specific path for now, since the headers are changing.
#include "loader.h"
#include <initguid.h>
#include "riff.h"

#ifndef UNDER_CE
#include <regstr.h>
#include <share.h>

extern BOOL g_fIsUnicode;

CFileStream::CFileStream( CLoader *pLoader)

{
    assert(pLoader);
    m_cRef = 1;
    m_pFile = NULL;
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CFileStream::~CFileStream() 

{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
    }
    Close();
}

HRESULT CFileStream::Open(WCHAR * lpFileName,DWORD dwDesiredAccess)

{
    Close();
    wcscpy(m_wszFileName,lpFileName);
    assert(dwDesiredAccess == GENERIC_READ || dwDesiredAccess == GENERIC_WRITE);
    if( dwDesiredAccess == GENERIC_READ )
    {
        if (g_fIsUnicode)
        {
            m_pFile = _wfsopen( lpFileName, L"rb", _SH_DENYWR );
        }
        else
        {
            char path[MAX_PATH];
            wcstombs( path, lpFileName, MAX_PATH );
            m_pFile = _fsopen( path, "rb", _SH_DENYWR );
        }
    }
    else if( dwDesiredAccess == GENERIC_WRITE )
    {
        if (g_fIsUnicode)
        {
            m_pFile = _wfsopen( lpFileName, L"wb", _SH_DENYNO );
        }
        else
        {
            char path[MAX_PATH];
            wcstombs( path, lpFileName, MAX_PATH );
            m_pFile = _fsopen( path, "wb", _SH_DENYNO );
        }   
    }
    if (m_pFile == NULL)
    {
        Trace(1, "Warning: The file %S couldn't be opened: %s. Try another path.\n", lpFileName, _strerror(NULL));
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    return S_OK;
}

HRESULT CFileStream::Close()

{
    if (m_pFile)
    {
        fclose(m_pFile);
    }
    m_pFile = NULL;
    return S_OK;
}

STDMETHODIMP CFileStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CFileStream::GetLoader(
    IDirectMusicLoader ** ppLoader)    // @parm Returns an AddRef'd pointer to the loader.
{
    if (m_pLoader)
    {
        return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
    }
    assert(false);
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CFileStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    size_t dw;
    dw = fread( pv, sizeof(char), cb, m_pFile );
    if( cb == dw )
    {
        if( pcbRead != NULL )
        {
            *pcbRead = cb;
        }
        return S_OK;
    }
    return E_FAIL ;
}

STDMETHODIMP CFileStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    if( cb == fwrite( pv, sizeof(char), cb, m_pFile ))
    {
        if( pcbWritten != NULL )
        {
            *pcbWritten = cb;
        }
        return S_OK;
    }
    Trace(1, "Error: An error occurred writing to %S.", m_wszFileName);
    return STG_E_MEDIUMFULL;
}

STDMETHODIMP CFileStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // fseek can't handle a LARGE_INTEGER seek...
    long lOffset;

    lOffset = dlibMove.LowPart;

    int i = fseek( m_pFile, lOffset, dwOrigin );
    if( i ) 
    {
        Trace(1, "Error: An error occurred while seeking in the file %S.\n", m_wszFileName);
        return E_FAIL;
    }

    if( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = ftell( m_pFile );
    }
    return S_OK;
}

STDMETHODIMP CFileStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Revert()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Clone( IStream** pStream )
{ 
    HRESULT hr = E_OUTOFMEMORY;
    CFileStream *pNewStream = new CFileStream( m_pLoader );
    if (pNewStream)
    {
        hr = pNewStream->Open(m_wszFileName,GENERIC_READ);
        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER   dlibMove;
            dlibMove.QuadPart = 0;
            ULARGE_INTEGER  libNewPosition;
            Seek( dlibMove, STREAM_SEEK_CUR, &libNewPosition );
            dlibMove.QuadPart = libNewPosition.QuadPart;
            pNewStream->Seek(dlibMove,STREAM_SEEK_SET,NULL);
            *pStream = (IStream *) pNewStream;
        }
        else
        {
            pNewStream->Release();
        }
    }
    return hr; 
}

#else

CFileStream::CFileStream(CLoader *pLoader)
{
    m_cRef = 1;
    m_hFile = NULL;
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CFileStream::~CFileStream() 
{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
    }
    Close();
}

HRESULT CFileStream::Open(WCHAR * lpFileName, DWORD dwDesiredAccess)
{
    Close();
    m_hFile = CreateFile(lpFileName, dwDesiredAccess, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if(m_hFile == NULL || m_hFile == INVALID_HANDLE_VALUE)
    {
#ifdef DBG
        LPVOID lpMsgBuf;
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                            NULL,
                            GetLastError(),
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR) &lpMsgBuf,
                            0,
                            NULL))
        {
            Trace(1, "Error: The file %S couldn't be opened: %S\n", lpFileName, lpMsgBuf);
            LocalFree( lpMsgBuf );
        }
#endif
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    return S_OK;
}

HRESULT CFileStream::Close()
{
    if(m_hFile)
    {
        CloseHandle(m_hFile);
    }
    m_hFile = NULL;
    return S_OK;
}

STDMETHODIMP CFileStream::QueryInterface(const IID &riid, void **ppvObj)
{
    if(riid == IID_IUnknown || riid == IID_IStream)
    {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CFileStream::GetLoader(
    IDirectMusicLoader ** ppLoader)    
{
    if(m_pLoader)
    {
        return m_pLoader->QueryInterface(IID_IDirectMusicLoader,(void **) ppLoader);
    }
    assert(false);
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CFileStream::Read(void* pv, ULONG cb, ULONG* pcbRead)
{
    if(ReadFile(m_hFile, pv, cb, pcbRead, NULL))
    {
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CFileStream::Write(const void* pv, ULONG cb, ULONG* pcbWritten)
{
    if(WriteFile(m_hFile, pv, cb, pcbWritten, NULL))
    {
        return S_OK;
    }
    Trace(1, "Error: An error occurred writing to %S.", m_wszFileName);
    return STG_E_MEDIUMFULL;
}

STDMETHODIMP CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition)
{
    DWORD dw;

    dw = SetFilePointer(m_hFile,dlibMove.LowPart, &dlibMove.HighPart, dwOrigin);
    if(dw == 0xffffffff && GetLastError() != NO_ERROR)
    {
        Trace(1, "Error: An error occurred while seeking in the file %S.\n", m_wszFileName);
        return E_FAIL;
    }
    if(plibNewPosition != NULL)
    {
        plibNewPosition->LowPart = dw;
        plibNewPosition->HighPart = dlibMove.HighPart;
    }
    return S_OK;
}

STDMETHODIMP CFileStream::SetSize(ULARGE_INTEGER /*libNewSize*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::CopyTo(IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                                 ULARGE_INTEGER* /*pcbRead*/,
                                 ULARGE_INTEGER* /*pcbWritten*/)
{
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Commit(DWORD /*grfCommitFlags*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Revert()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::LockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                                     DWORD /*dwLockType*/)
{
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::UnlockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                                       DWORD /*dwLockType*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileStream::Stat(STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Clone(IStream** /*ppstm*/)
{ 
    HRESULT hr = E_OUTOFMEMORY;
    CFileStream *pNewStream = new CFileStream( m_pLoader );
    if (pNewStream)
    {
        hr = pNewStream->Open(m_wszFileName,GENERIC_READ);
        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER   dlibMove;
            dlibMove.QuadPart = 0;
            ULARGE_INTEGER  libNewPosition;
            Seek( dlibMove, STREAM_SEEK_CUR, &libNewPosition );
            dlibMove.QuadPart = libNewPosition.QuadPart;
            pNewStream->Seek(dlibMove,STREAM_SEEK_SET,NULL);
        }
        else
        {
            pNewStream->Release();
        }
    }
    return hr;  
}

#endif
CMemStream::CMemStream( CLoader *pLoader)

{
    m_cRef = 1;
    m_pbData = NULL;
    m_llLength = 0;
    m_llPosition = 0;
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CMemStream::CMemStream( CLoader *pLoader,
                       LONGLONG llLength,
                       LONGLONG llPosition,
                       BYTE *pbData)

{
    m_cRef = 1;
    m_pbData = pbData;
    m_llLength = llLength;
    m_llPosition = llPosition;
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CMemStream::~CMemStream() 

{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
    }
    Close();
}

HRESULT CMemStream::Open(BYTE *pbData, LONGLONG llLength)

{
    Close();
    m_pbData = pbData;
    m_llLength = llLength;
    m_llPosition = 0;
    if ((pbData == NULL) || (llLength == 0))
    {
#ifdef DBG
        if (pbData)
        {
            Trace(1, "Error: Attempt to load an object from an invalid block of memory. A DMUS_OBJECTDESC has DMUS_OBJ_MEMORY set but pbMemData is NULL.");
        }
        else
        {
            Trace(1, "Error: Attempt to load an object from an invalid block of memory. A DMUS_OBJECTDESC has DMUS_OBJ_MEMORY set but llMemLength is 0.");
        }
#endif
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    if (IsBadReadPtr(pbData, (DWORD) llLength))
    {
        m_pbData = NULL;
        m_llLength = 0;
#ifdef DBG
        DWORD dwLength = (DWORD) llLength;
        Trace(1, "Error: Attempt to load an object from an invalid block of memory. A DMUS_OBJECTDESC has DMUS_OBJ_MEMORY, pbMemData=0x%08x, llMemLength=%lu, which isn't a block that can be read.", pbData, dwLength);
#endif
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    return S_OK;
}

HRESULT CMemStream::Close()

{
    m_pbData = NULL;
    m_llLength = 0;
    return S_OK;
}

STDMETHODIMP CMemStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP CMemStream::GetLoader(
    IDirectMusicLoader ** ppLoader)    

{
    if (m_pLoader)
    {
        return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
    }
    assert(false);
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMemStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMemStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CMemStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    if ((cb + m_llPosition) <= m_llLength)
    {
        memcpy(pv,&m_pbData[m_llPosition],cb);
        m_llPosition += cb;
        if( pcbRead != NULL )
        {
            *pcbRead = cb;
        }
        return S_OK;
    }
#ifdef DBG
    Trace(1, "Error: Unexpected end of data reading object from memory. Memory length is %ld, attempting to read to %ld\n", 
        (long) m_llLength, (long) (cb + m_llPosition));
#endif
    return E_FAIL ;
}

STDMETHODIMP CMemStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // Since we only parse RIFF data, we can't have a file over 
    // DWORD in length, so disregard high part of LARGE_INTEGER.

    LONGLONG llOffset;

    llOffset = dlibMove.QuadPart;
    if (dwOrigin == STREAM_SEEK_CUR)
    {
        llOffset += m_llPosition;
    } 
    else if (dwOrigin == STREAM_SEEK_END)
    {
        llOffset += m_llLength;
    }
    if ((llOffset >= 0) && (llOffset <= m_llLength))
    {
        m_llPosition = llOffset;
    }
    else
    {
#ifdef DBG
        Trace(1, "Error: Seek request %ld past end of memory file, size %ld.\n", 
            (long) llOffset, (long) m_llLength);
#endif
        return E_FAIL;
    }

    if( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = m_llPosition;
    }
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Revert()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Clone( IStream** ppStream )
{ 
    *ppStream = (IStream *) new CMemStream( m_pLoader, m_llLength, m_llPosition, m_pbData );
    if (*ppStream)
    {
        return S_OK;
    }
    return E_OUTOFMEMORY; 
}

STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff )
{
    if( ( *ppRiff = (IRIFFStream*) new CRIFFStream( pStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


STDMETHODIMP CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

    FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
    {
        ckidFind = lpck->ckid;
        fccTypeFind = NULL;
    }
    else if(wFlags & MMIO_FINDRIFF)
    {
        ckidFind = FOURCC_RIFF;
        fccTypeFind = lpck->fccType;
    }
    else if(wFlags & MMIO_FINDLIST)
    {
        ckidFind = FOURCC_LIST;
        fccTypeFind = lpck->fccType;
    }
    else
    {
        ckidFind = fccTypeFind = NULL;
    }

    lpck->dwFlags = 0L;

    for(;;)
    {
        HRESULT hr;
        LARGE_INTEGER li;
        ULARGE_INTEGER uli;
        ULONG cbRead;

        // Read the chunk header
        hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
        {
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // Store the offset of the data part of the chunk
        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1, "Error: Read error - unable to seek in a stream.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lpck->dwDataOffset = uli.LowPart;
        }

        // See if the chunk is within the parent chunk (if given)
        if((lpckParent != NULL) &&
           (lpck->dwDataOffset - 8L >=
           lpckParent->dwDataOffset + lpckParent->cksize))
        {
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // If the chunk is a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

            if(FAILED(hr) || (cbRead != sizeof(DWORD)))
            {
                return DMUS_E_DESCEND_CHUNK_FAIL;
            }
        }
        else
        {
            lpck->fccType = NULL;
        }

        // If this is the chunk we're looking for, stop looking
        if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
           ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
        {
            break;
        }

        // Ascend out of the chunk and try again
        HRESULT w = Ascend(lpck, 0);
        if(FAILED(w))
        {
            return w;
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CRIFFStream::Ascend

STDMETHODIMP CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    assert(lpck);

    HRESULT hr;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;
    
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG lOffset;           // current offset in file
        LONG lActualSize;   // actual size of chunk data

        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1, "Error: Read error - unable to seek in a stream.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lOffset = uli.LowPart;
        }
        
        if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
        {
            Trace(1, "Error: Unable to write to a stream.\n");
            return DMUS_E_CANNOTWRITE;
        }

        if(LOWORD(lActualSize) & 1)
        {
            ULONG cbWritten;

            // Chunk size is odd -- write a null pad byte
            hr = m_pStream->Write("\0", 1, &cbWritten); 
            
            if(FAILED(hr) || cbWritten != 1)
            {
                Trace(1, "Error: Unable to write to a stream.\n");
                return DMUS_E_CANNOTWRITE;
            }
        
        }
    
        if(lpck->cksize == (DWORD)lActualSize)
        {
            return S_OK;
        }

        // Fix the chunk header
        lpck->cksize = lActualSize;

        li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
        hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

        if(FAILED(hr))
        {
            Trace(1, "Error: Read error - unable to seek in a stream.\n");
            return DMUS_E_CANNOTSEEK;
        }

        ULONG cbWritten;

        hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
        
        if(FAILED(hr) || cbWritten != sizeof(DWORD))
        {
            Trace(1, "Error: Unable to write to a stream.\n");
            return DMUS_E_CANNOTWRITE;
        }
    }

    // Seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
    hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

    if(FAILED(hr))
    {
        Trace(1, "Error: Read error - unable to seek in a stream.\n");
        return DMUS_E_CANNOTSEEK;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CRIFFStream::CreateChunk

STDMETHODIMP CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

    // Store the offset of the data part of the chunk
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

    if(FAILED(hr))
    {
        Trace(1, "Error: Read error - unable to seek in a stream.\n");
        return DMUS_E_CANNOTSEEK;
    }
    else
    {
        lOffset = uli.LowPart;
    }
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
    {
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
    else if(wFlags & MMIO_CREATELIST)
    {
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    }
    else
    {
        iBytes = 2 * sizeof(DWORD);
    }

    // Write the chunk header
    ULONG cbWritten;

    hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
        
    if(FAILED(hr) || cbWritten != iBytes)
    {
        Trace(1, "Error: Unable to write to a stream.\n");
        return DMUS_E_CANNOTWRITE;
    }

    lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}


CStream::CStream( CLoader *pLoader, IStream *pStream )

{
    m_cRef = 1;
    m_pIStream = pStream;
    if (pStream)
    {
        pStream->AddRef();
    }
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CStream::CStream( CLoader *pLoader)

{
    m_cRef = 1;
    m_pIStream = NULL;
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CStream::~CStream() 

{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
    }
    Close();
}

HRESULT CStream::Open(IStream *pIStream,LARGE_INTEGER liStartPosition)

{
    Close();
           
    m_pIStream = pIStream;

    if (m_pIStream)
    {
        // Need to seek to point that was where we were in the stream
        // when the stream was first provided via GetObject or SetObject.
        pIStream->Seek(liStartPosition,STREAM_SEEK_SET,NULL);
        pIStream->AddRef();
    }

    return S_OK;
}

HRESULT CStream::Close()

{
    if (m_pIStream)
    {
        m_pIStream->Release();
    }
    m_pIStream = NULL;

    return S_OK;
}

STDMETHODIMP CStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP CStream::GetLoader(
    IDirectMusicLoader ** ppLoader)    

{
    if (m_pLoader)
    {
        return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
    }
    assert(false);
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        Close();
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    if (m_pIStream)
    {
        return m_pIStream->Read(pv, cb, pcbRead);
    }
    Trace(1, "Error: Attempt to read from a NULL stream.\n");
    return E_FAIL;
}

STDMETHODIMP CStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    if (m_pIStream)
    {
        return m_pIStream->Write(pv, cb, pcbWritten);
    }
    Trace(1, "Error: Attempt to write to a NULL stream.\n");
    return E_FAIL;
}

STDMETHODIMP CStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    if (m_pIStream)
    {
        return m_pIStream->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    Trace(1, "Error: Read error - attempt to seek in a NULL stream.\n");
    return E_FAIL;
}

STDMETHODIMP CStream::SetSize( ULARGE_INTEGER libNewSize)
{ 
    if (m_pIStream)
    {
        return m_pIStream->SetSize(libNewSize);
    }
    return E_FAIL; 
}

STDMETHODIMP CStream::CopyTo( IStream* pstm, ULARGE_INTEGER cb,
                     ULARGE_INTEGER* pcbRead,
                     ULARGE_INTEGER* pcbWritten)
{ 
    if (m_pIStream)
    {
        return m_pIStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
    }
    return E_FAIL; 
}

STDMETHODIMP CStream::Commit( DWORD grfCommitFlags)
{ 
    if (m_pIStream)
    {
        return m_pIStream->Commit(grfCommitFlags);
    }
    return E_FAIL; 
}

STDMETHODIMP CStream::Revert()
{ 
    if (m_pIStream)
    {
        return m_pIStream->Revert();
    }
    return E_FAIL; 
}

STDMETHODIMP CStream::LockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                         DWORD dwLockType)
{ 
    if (m_pIStream)
    {
        return m_pIStream->LockRegion(libOffset, cb, dwLockType);
    }
    return E_FAIL; 
}

STDMETHODIMP CStream::UnlockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                           DWORD dwLockType)
{ 
    if (m_pIStream)
    {
        return m_pIStream->UnlockRegion(libOffset, cb, dwLockType);
    }
    return E_FAIL; 
}

STDMETHODIMP CStream::Stat( STATSTG* pstatstg, DWORD grfStatFlag)
{ 
    if (m_pIStream)
    {
        return m_pIStream->Stat(pstatstg, grfStatFlag);
    }
    return E_FAIL; 
}

STDMETHODIMP CStream::Clone( IStream** ppStream)
{ 
    HRESULT hr = E_FAIL;
    if (m_pIStream)
    {
        IStream *pNewIStream = NULL;
        hr = m_pIStream->Clone(&pNewIStream);
        if (SUCCEEDED(hr))
        {
            CStream *pNewCStream = new CStream( m_pLoader, pNewIStream );
            if (pNewCStream)
            {
                *ppStream = (IStream *) pNewCStream;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            pNewIStream->Release();
        }
    }
    else
    {
        Trace(1, "Error: Attempt to clone a NULL stream.\n");
    }
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\activescript.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CActiveScriptManager.
//

#include "stdinc.h"
#include "activescript.h"
#include "dll.h"
#include "oleaut.h"
#include "dmscript.h"
#include "authelper.h"
#include "packexception.h"
#include <objsafe.h>

//////////////////////////////////////////////////////////////////////
// Global constants

const LCID lcidUSEnglish = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
const WCHAR g_wszGlobalDispatch[] = L"DirectMusic";

//////////////////////////////////////////////////////////////////////
// Static variables

SmartRef::Vector<CActiveScriptManager::ThreadContextPair> CActiveScriptManager::ms_svecContext;

//////////////////////////////////////////////////////////////////////
// ScriptNames

HRESULT
ScriptNames::Init(bool fUseOleAut, DWORD cNames)
{
	m_prgbstr = new BSTR[cNames];
	if (!m_prgbstr)
		return E_OUTOFMEMORY;
	ZeroMemory(m_prgbstr, sizeof(BSTR) * cNames);
	m_fUseOleAut = fUseOleAut;
	m_dwSize = cNames;
	return S_OK;
}

void
ScriptNames::Clear()
{
	if (m_prgbstr)
	{
		for (DWORD i = 0; i < m_dwSize; ++i)
		{
			DMS_SysFreeString(m_fUseOleAut, m_prgbstr[i]);
		}
	}
	delete[] m_prgbstr;
}

//////////////////////////////////////////////////////////////////////
// Public functions

CActiveScriptManager::CActiveScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
  : m_cRef(1),
	m_pParentScript(pParentScript),
	m_fUseOleAut(fUseOleAut),
	m_pActiveScript(NULL),
	m_pDispatchScript(NULL),
	m_bstrErrorSourceComponent(NULL),
	m_bstrErrorDescription(NULL),
	m_bstrErrorSourceLineText(NULL),
	m_bstrHelpFile(NULL),
	m_i64IntendedStartTime(0),
	m_dwIntendedStartTimeFlags(0)
{
	LockModule(true);
	this->ClearErrorInfo();

	IActiveScriptParse *pActiveScriptParse = NULL;

	if (!m_pParentScript)
	{
		assert(false);
		*phr = E_POINTER;
		goto Fail;
	}

	// Create the scripting engine

	CLSID clsid;
	*phr = CLSIDFromProgID(pwszLanguage, &clsid);
	if (FAILED(*phr))
		goto Fail;

	*phr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, reinterpret_cast<void **>(&m_pActiveScript));
	if (FAILED(*phr))
		goto Fail;

	// Initialize the scripting engine

    {
        IObjectSafety* pSafety = NULL;
        if (SUCCEEDED(m_pActiveScript->QueryInterface(IID_IObjectSafety, (void**) &pSafety)))
        {
            DWORD dwSafetySupported, dwSafetyEnabled;
        
            // Get the interface safety otions
            if (SUCCEEDED(*phr = pSafety->GetInterfaceSafetyOptions(IID_IActiveScript, &dwSafetySupported, &dwSafetyEnabled)))
            {
                // Only allow objects which say they are safe for untrusted data, and 
                // say that we require the use of a security manager.  This gives us much 
                // more control
                dwSafetyEnabled |= INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                   INTERFACE_USES_DISPEX | INTERFACE_USES_SECURITY_MANAGER;
                *phr = pSafety->SetInterfaceSafetyOptions(IID_IActiveScript, dwSafetySupported, dwSafetyEnabled);
            }
            pSafety->Release();
            if (FAILED(*phr)) goto Fail;
        }
    }

	*phr = m_pActiveScript->SetScriptSite(this);
	if (FAILED(*phr))
		goto Fail;

	// Add the default objects

	*phr = m_pActiveScript->AddNamedItem(g_wszGlobalDispatch, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_NOCODE | SCRIPTITEM_GLOBALMEMBERS);
	if (FAILED(*phr))
		goto Fail;

	// Parse the script

	*phr = m_pActiveScript->QueryInterface(IID_IActiveScriptParse, reinterpret_cast<void **>(&pActiveScriptParse));
	if (FAILED(*phr))
	{
		if (*phr == E_NOINTERFACE)
		{
			Trace(1, "Error: Scripting engine '%S' does not support the IActiveScriptParse interface required for use with DirectMusic.\n", pwszLanguage);
			*phr = DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
		}
		goto Fail;
	}

	*phr = pActiveScriptParse->InitNew();
	if (FAILED(*phr))
		goto Fail;

	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	*phr = pActiveScriptParse->ParseScriptText(
						pwszSource,
						NULL,
						NULL,
						NULL,
						NULL,
						0,
						0,
						NULL,
						&exinfo);
	if (*phr == DISP_E_EXCEPTION)
		this->ContributeErrorInfo(L"parsing script", L"", exinfo);
	if (FAILED(*phr))
		goto Fail;

	SafeRelease(pActiveScriptParse); // No longer needed
	return;

Fail:
	if (m_pActiveScript)
		m_pActiveScript->Close();
	SafeRelease(pActiveScriptParse);
	SafeRelease(m_pActiveScript);
	*phr = this->ReturnErrorInfo(*phr, pErrorInfo);
}

HRESULT
CActiveScriptManager::Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pActiveScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	// Start the script running

	// Set context to this script (VBScript runs global code and could play something when it starts)
	CActiveScriptManager *pASM = NULL;
	HRESULT hr = CActiveScriptManager::SetCurrentContext(this, &pASM);
	if (FAILED(hr))
		return hr;

	hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_STARTED); // We don't need to sink any events

	CActiveScriptManager::SetCurrentContext(pASM, NULL);

	if (FAILED(hr))
		goto Fail;
	assert(hr != S_FALSE);
	if (hr != S_OK)
	{
		assert(false);
		hr = DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
		goto Fail;
	}

	hr = m_pActiveScript->GetScriptDispatch(NULL, &m_pDispatchScript);
	if (FAILED(hr))
		goto Fail;

	return S_OK;

Fail:
	if (m_pActiveScript)
		m_pActiveScript->Close();
	SafeRelease(m_pActiveScript);
	SafeRelease(m_pDispatchScript);
	hr = this->ReturnErrorInfo(hr, pErrorInfo);
	return hr;
}

HRESULT
CActiveScriptManager::CallRoutine(
		const WCHAR *pwszRoutineName,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error calling script routine: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	DISPID dispid;
	HRESULT hr = this->GetIDOfName(pwszRoutineName, &dispid);
	if (hr == DISP_E_UNKNOWNNAME)
	{
		Trace(1, "Error: Attempt to call routine '%S' that is not defined in the script.\n", pwszRoutineName);
		return DMUS_E_SCRIPT_ROUTINE_NOT_FOUND;
	}
	if (FAILED(hr))
		return hr;

	this->ClearErrorInfo();
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));

	// Set context to this script
	CActiveScriptManager *pASM = NULL;
	hr = CActiveScriptManager::SetCurrentContext(this, &pASM);
	if (FAILED(hr))
		return hr;

	hr = m_pDispatchScript->Invoke(
			dispid,
			m_fUseOleAut ? IID_NULL : g_guidInvokeWithoutOleaut,
			lcidUSEnglish,
			DISPATCH_METHOD,
			&dispparamsNoArgs,
			NULL,
			&exinfo,
			NULL);

	// Restore previous context (the routine could have been called from another script,
	// whose context needs to be restored).
	CActiveScriptManager::SetCurrentContext(pASM, NULL);

	if (hr == DISP_E_EXCEPTION)
		this->ContributeErrorInfo(L"calling routine ", pwszRoutineName, exinfo);

	return this->ReturnErrorInfo(hr, pErrorInfo);
}

HRESULT
CActiveScriptManager::ScriptTrackCallRoutine(
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags)
{
	DMUS_SCRIPT_ERRORINFO ErrorInfo;
	if (fErrorPMsgsEnabled)
		ZeroAndSize(&ErrorInfo);

	// record current timing context
	__int64 i64IntendedStartTime_PreCall = m_i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags_PreCall = m_dwIntendedStartTimeFlags;
	// set designated timing context (used by play/stop methods if called within the routine)
	m_i64IntendedStartTime = i64IntendedStartTime;
	m_dwIntendedStartTimeFlags = dwIntendedStartTimeFlags;

	HRESULT hr = CallRoutine(pwszRoutineName, &ErrorInfo);

	// Restore the previous timing context.
	// This is important because when R finishes it will resore both fields to the values set in the
	//    constructor, which are music time 0.  This setting means that routines called via IDirectMusicScript
	//    will play segments at the current time.
	// It is also important because such calls can be nested.  Assume that track T calls a script routine R
	//    that plays a segment containing track T', which calls another script routine R'.  Statements
	//    in R should be associated with the time of R in T, but statements in R' get the time of R' in T'.
	m_i64IntendedStartTime = i64IntendedStartTime_PreCall;
	m_dwIntendedStartTimeFlags = dwIntendedStartTimeFlags_PreCall;

	if (fErrorPMsgsEnabled && hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
	{
		IDirectMusicPerformance *pPerf = m_pParentScript->GetPerformance();
		FireScriptTrackErrorPMsg(pPerf, pSegSt, dwVirtualTrackID, &ErrorInfo);
	}

	return hr;
}

HRESULT
CActiveScriptManager::SetVariable(
		const WCHAR *pwszVariableName,
		VARIANT varValue,
		bool fSetRef,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error setting script variable: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	DISPID dispid;
	HRESULT hr = this->GetIDOfName(pwszVariableName, &dispid);
	if (hr == DISP_E_UNKNOWNNAME)
	{
		Trace(1, "Error: Attempt to set variable '%S' that is not defined in the script.\n", pwszVariableName);
		return DMUS_E_SCRIPT_VARIABLE_NOT_FOUND;
	}
	if (FAILED(hr))
		return hr;

	this->ClearErrorInfo();
	DISPID dispidPropPut = DISPID_PROPERTYPUT;
	DISPPARAMS dispparams;
	dispparams.rgvarg = &varValue;
	dispparams.rgdispidNamedArgs = &dispidPropPut;
	dispparams.cArgs = 1;
	dispparams.cNamedArgs = 1;
	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	hr = m_pDispatchScript->Invoke(
			dispid,
			m_fUseOleAut ? IID_NULL : g_guidInvokeWithoutOleaut,
			lcidUSEnglish,
			fSetRef ? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT,
			&dispparams,
			NULL,
			&exinfo,
			NULL);
	if (hr == DISP_E_EXCEPTION)
	{
		this->ContributeErrorInfo(L"setting variable ", pwszVariableName, exinfo);

		// Check if it was more likely a malformed call to SetVariable rather than an error in the script, in which
		// case return a descriptive HRESULT rather than the textual error.
		bool fObject = varValue.vt == VT_DISPATCH || varValue.vt == VT_UNKNOWN;
		if (fObject)
		{
			if (!fSetRef)
			{
				// Theoretically an object could support the value property, which would allow it to be assigned by value.
				//    (Not that any of our built-in objects currently do this.)
				// But in this case we know that the set failed, so probably this is the fault of the caller, who forgot to use
				//    fSetRef when setting an object.
				this->ClearErrorInfo();
				return DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED;
			}
		}
		else
		{
			if (fSetRef)
			{
				// Setting by reference without using an object.
				this->ClearErrorInfo();
				return DMUS_E_SCRIPT_NOT_A_REFERENCE;
			}
		}
	}

	return this->ReturnErrorInfo(hr, pErrorInfo);
}

HRESULT
CActiveScriptManager::GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error getting script variable: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	assert(pvarValue->vt == VT_EMPTY);

	DISPID dispid;
	HRESULT hr = this->GetIDOfName(pwszVariableName, &dispid);
	if (hr == DISP_E_UNKNOWNNAME)
		return DMUS_E_SCRIPT_VARIABLE_NOT_FOUND;
	if (FAILED(hr))
		return hr;

	this->ClearErrorInfo();
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	hr = m_pDispatchScript->Invoke(
			dispid,
			m_fUseOleAut ? IID_NULL : g_guidInvokeWithoutOleaut,
			lcidUSEnglish,
			DISPATCH_PROPERTYGET,
			&dispparamsNoArgs,
			pvarValue,
			&exinfo,
			NULL);
	if (hr == DISP_E_EXCEPTION)
		this->ContributeErrorInfo(L"getting variable ", pwszVariableName, exinfo);

	return this->ReturnErrorInfo(hr, pErrorInfo);
}

HRESULT
CActiveScriptManager::EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems)
{
	HRESULT hr = this->EnsureEnumItemsCached(fRoutine);
	if (FAILED(hr))
		return hr;

	ScriptNames &snames = fRoutine ? m_snamesRoutines : m_snamesVariables;

	DWORD cNames = snames.size();
	// snames was allocated for the size of the most items there could be as reported by the script's type info.
	// However, the global "DirectMusic" variable may have been skipped, leaving a NULL entry at the end of snames.
	if (cNames > 0 && !snames[cNames - 1])
		--cNames;
	if (pcItems)
		*pcItems = cNames;
	if (dwIndex >= cNames)
		return S_FALSE;
	
	const BSTR bstrName = snames[dwIndex];
	if (!bstrName)
	{
		assert(false);
		return S_FALSE;
	}

	return wcsTruncatedCopy(pwszName, bstrName, MAX_PATH);
}

HRESULT CActiveScriptManager::DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	// handle the dummy load method
	HRESULT hr = AutLoadDispatchGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	if (SUCCEEDED(hr))
		return hr;

	// otherwise defer to the scripting engine
	return m_pDispatchScript->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
}

HRESULT CActiveScriptManager::DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	// handle the dummy load method
	HRESULT hr = AutLoadDispatchInvoke(NULL, dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	if (SUCCEEDED(hr))
		return hr;

	// otherwise defer to the scripting engine...

	CActiveScriptManager *pASM = NULL;
	hr = CActiveScriptManager::SetCurrentContext(this, &pASM);
	if (FAILED(hr))
		return hr;

	// If this is a property set of an object then we need to report it to garbage collecting loader if present.
	// Note that we do this before actually setting the property with Invoke.  We do this because if the garbage collector
	//    fails to track the reference then it won't necessarily keep the target object alive and we don't want to create
	//    a dangling reference in the script.
	if (wFlags & DISPATCH_PROPERTYPUTREF && pDispParams && pDispParams->cArgs == 1)
	{
		IDirectMusicLoader8P *pLoader8P = m_pParentScript->GetLoader8P();
		VARIANT &var = pDispParams->rgvarg[0];
		if (pLoader8P && (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH))
		{
			hr = pLoader8P->ReportDynamicallyReferencedObject(m_pParentScript, var.vt == VT_UNKNOWN ? var.punkVal : var.pdispVal);
			if (FAILED(hr))
				return hr;
		}
	}

	hr = m_pDispatchScript->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);

	bool fExceptionUsingOleAut = !!(riid != g_guidInvokeWithoutOleaut);

	if (hr == 0x80020101 && pExcepInfo) // supposedly this is SCRIPT_E_REPORTED
	{
		// See KB article ID: Q247784, INFO: '80020101' Returned From Some ActiveX Scripting Methods.
		// Sometimes VBScript just returns this undocumented HRESULT, which means the error has already been
		//   reported via OnScriptError.  Since it then doesn't give us the exception info via pExcepInfo, we have
		//   to take the info we saves from OnScriptError and put it back in.

		assert(fExceptionUsingOleAut && m_fUseOleAut); // We don't expect this to happen with a custom scripting engine.
		assert(!pExcepInfo->bstrSource && !pExcepInfo->bstrDescription && !pExcepInfo->bstrHelpFile); // We don't expect this will happen when the exception info has been filled in.

		pExcepInfo->scode = m_hrError;

		DMS_SysFreeString(fExceptionUsingOleAut, pExcepInfo->bstrSource);
		pExcepInfo->bstrSource = DMS_SysAllocString(fExceptionUsingOleAut, m_bstrErrorSourceComponent);

		DMS_SysFreeString(fExceptionUsingOleAut, pExcepInfo->bstrDescription);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fExceptionUsingOleAut, m_bstrErrorDescription);

		DMS_SysFreeString(fExceptionUsingOleAut, pExcepInfo->bstrHelpFile);
		pExcepInfo->bstrHelpFile = DMS_SysAllocString(fExceptionUsingOleAut, m_bstrHelpFile);

		hr = DISP_E_EXCEPTION;
	}

	if (hr == DISP_E_EXCEPTION)
	{
		// Hack: See packexception.h for more info
		PackExceptionFileAndLine(fExceptionUsingOleAut, pExcepInfo, m_pParentScript->GetFilename(), m_fError ? &m_ulErrorLineNumber : NULL);
	}

	CActiveScriptManager::SetCurrentContext(pASM, NULL);
	return hr;
}

void
CActiveScriptManager::Close()
{
	if (!m_pActiveScript)
	{
		assert(false); // Close being called if initialization failed.  Or Close was called twice.  Or else m_pActiveScript is getting cleared prematurely somehow.
		return;
	}

	HRESULT hr = m_pActiveScript->Close();
	assert(SUCCEEDED(hr) && hr != S_FALSE);
	SafeRelease(m_pDispatchScript);
	SafeRelease(m_pActiveScript);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CActiveScriptManager::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CActiveScriptManager::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IActiveScriptSite)
	{
		*ppv = static_cast<IActiveScriptSite*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
CActiveScriptManager::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CActiveScriptManager::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		SafeRelease(m_pDispatchScript);
		SafeRelease(m_pActiveScript);
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IActiveScriptSite

STDMETHODIMP
CActiveScriptManager::GetLCID(/* [out] */ LCID __RPC_FAR *plcid)
{
	V_INAME(CActiveScriptManager::GetLCID);
	V_PTR_WRITE(plcid, LCID);

	*plcid = lcidUSEnglish;

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::GetItemInfo(
	/* [in] */ LPCOLESTR pstrName,
	/* [in] */ DWORD dwReturnMask,
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
	/* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti)
{
	V_INAME(CActiveScriptManager::GetLCID);
	V_PTR_WRITE_OPT(ppti, ITypeInfo*);

	bool fGetUnknown = !!(dwReturnMask | SCRIPTINFO_IUNKNOWN);
	if (fGetUnknown || ppiunkItem)
	{
		V_PTR_WRITE(ppiunkItem, IUnknown*);
	}

	if (ppiunkItem)
		*ppiunkItem = NULL;
	if (ppti)
		*ppti = NULL;

	if (0 != wcscmp(g_wszGlobalDispatch, pstrName))
	{
		assert(false); // we should only be asked about the global object
		return TYPE_E_ELEMENTNOTFOUND;
	}

	if (fGetUnknown)
	{
		IDispatch *pDispGlobal = m_pParentScript->GetGlobalDispatch();
		pDispGlobal->AddRef();
		*ppiunkItem = pDispGlobal;
	}

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::GetDocVersionString(/* [out] */ BSTR __RPC_FAR *pbstrVersion)
{
	return E_NOTIMPL; // Not an issue for our scripts that don't persist their state and aren't edited at runtime.
}

STDMETHODIMP
CActiveScriptManager::OnScriptTerminate(
	/* [in] */ const VARIANT __RPC_FAR *pvarResult,
	/* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo)
{
	if (pexcepinfo)
		this->ContributeErrorInfo(L"terminating script", L"", *pexcepinfo);

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnStateChange(/* [in] */ SCRIPTSTATE ssScriptState)
{
	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnScriptError(/* [in] */ IActiveScriptError __RPC_FAR *pscripterror)
{
	V_INAME(CActiveScriptManager::OnScriptError);
	V_INTERFACE(pscripterror);

	BSTR bstrSource = NULL;
	pscripterror->GetSourceLineText(&bstrSource); // this may fail, in which case the source text will remain blank

	ULONG ulLine = 0;
	LONG lChar = 0;
	HRESULT hr = pscripterror->GetSourcePosition(NULL, &ulLine, &lChar);
	assert(SUCCEEDED(hr));

	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	hr = pscripterror->GetExceptionInfo(&exinfo);
	assert(SUCCEEDED(hr));

	this->SetErrorInfo(ulLine, lChar, bstrSource, exinfo);

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnEnterScript()
{
	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnLeaveScript()
{
	return S_OK;
}

IDirectMusicPerformance8 *
CActiveScriptManager::GetCurrentPerformanceNoAssertWEAK()
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
		return NULL;

	return pASM->m_pParentScript->GetPerformance();
}

IDirectMusicObject *
CActiveScriptManager::GetCurrentScriptObjectWEAK()
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
	{
		assert(false);
		return NULL;
	}

	assert(pASM->m_pParentScript);
	return pASM->m_pParentScript;
}

IDirectMusicComposer8 *CActiveScriptManager::GetComposerWEAK()
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
	{
		assert(false);
		return NULL;
	}

	assert(pASM->m_pParentScript);
	return pASM->m_pParentScript->GetComposer();
}

void CActiveScriptManager::GetCurrentTimingContext(__int64 *pi64IntendedStartTime, DWORD *pdwIntendedStartTimeFlags)
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
	{
		assert(false);
		*pi64IntendedStartTime = 0;
		*pdwIntendedStartTimeFlags = 0;
	}
	else
	{
		*pi64IntendedStartTime = pASM->m_i64IntendedStartTime;
		*pdwIntendedStartTimeFlags = pASM->m_dwIntendedStartTimeFlags;
	}
}

//////////////////////////////////////////////////////////////////////
// Private functions

HRESULT
CActiveScriptManager::GetIDOfName(const WCHAR *pwszName, DISPID *pdispid)
{
	V_INAME(CDirectMusicScript::GetIDOfName);
	V_BUFPTR_READ(pwszName, 2);
	V_PTR_WRITE(pdispid, DISPID);

	if (!m_pDispatchScript)
	{
		assert(false);
		return DMUS_E_NOT_INIT;
	}

	HRESULT hr = m_pDispatchScript->GetIDsOfNames(
					IID_NULL,
					const_cast<WCHAR **>(&pwszName),
					1,
					lcidUSEnglish,
					pdispid);
	return hr;
}

// Clears the error info and frees all cached BSTRs.
void
CActiveScriptManager::ClearErrorInfo()
{
	m_fError = false;
	if (m_bstrErrorSourceComponent)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrErrorSourceComponent);
		m_bstrErrorSourceComponent = NULL;
	}
	if (m_bstrErrorDescription)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrErrorDescription);
		m_bstrErrorDescription = NULL;
	}
	if (m_bstrErrorSourceLineText)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrErrorSourceLineText);
		m_bstrErrorSourceLineText = NULL;
	}
	if (m_bstrHelpFile)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrHelpFile);
		m_bstrHelpFile = NULL;
	}
}

// Saves the passed error values.
// Assumes ownership of the BSTRs so don't use them after this call since they may be freed!
void
CActiveScriptManager::SetErrorInfo(
		ULONG ulLineNumber,
		LONG ichCharPosition,
		BSTR bstrSourceLine,
		const EXCEPINFO &excepinfo)
{
	this->ClearErrorInfo();
	m_fError = true;
	m_hrError = excepinfo.scode;
	m_ulErrorLineNumber = ulLineNumber;
	m_ichErrorCharPosition = ichCharPosition;

	m_bstrErrorSourceComponent = excepinfo.bstrSource;
	m_bstrErrorDescription = excepinfo.bstrDescription;
	m_bstrErrorSourceLineText = bstrSourceLine;
	m_bstrHelpFile = excepinfo.bstrHelpFile;
}

// Sometimes a EXCEPINFO is returned when calling Invoke or on script termination.  Although
// there is no source code information, we still want to do our best to set info about
// the error.  If OnScriptError has already been called, then calling this function has
// no effect, since we prefer that information.
// Assumes ownership of the BSTRs so don't use them after this call since they may be freed!
void
CActiveScriptManager::ContributeErrorInfo(
		const WCHAR *pwszActivity,
		const WCHAR *pwszSubject,
		const EXCEPINFO &excepinfo)
{
	if (m_fError)
	{
		// Error info already set.  Just clear the BSTRs and bail.
		if (excepinfo.bstrSource)
			DMS_SysFreeString(m_fUseOleAut, excepinfo.bstrSource);
		if (excepinfo.bstrDescription)
			DMS_SysFreeString(m_fUseOleAut, excepinfo.bstrDescription);
		if (excepinfo.bstrHelpFile)
			DMS_SysFreeString(m_fUseOleAut, excepinfo.bstrHelpFile);
		return;
	}

	this->SetErrorInfo(0, 0, NULL, excepinfo);
}

// If no error occurred, hr is returned unchanged and pErrorInfo is unaffected.
// If an error did occur, DMUS_E_SCRIPT_ERROR_IN_SCRIPT is returned, the error
//    information is saved into pErrorInfo (if nonnull), and the error info is
//    cleared for next time.
HRESULT
CActiveScriptManager::ReturnErrorInfo(HRESULT hr, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_fError)
		return hr;

	assert(FAILED(hr));
	if (pErrorInfo)
	{
		// We'll fill in a structure with the error info and then copy it to pErrorInfo.
		// This is done because it will make things simpler if more fields are added
		// to DMUS_SCRIPT_ERRORINFO in the future.
		DMUS_SCRIPT_ERRORINFO dmei;
		ZeroAndSize(&dmei);
		dmei.hr = m_hrError;

		dmei.ulLineNumber = m_ulErrorLineNumber;
		dmei.ichCharPosition = m_ichErrorCharPosition;

		if (m_bstrErrorDescription)
		{
			// Hack: See packexception.h for more info
			UnpackExceptionFileAndLine(m_bstrErrorDescription, &dmei);
		}

		// The IActiveScript interfaces return zero-based line and column numbers, but we want
		// to return them from IDirectMusicScript using a one-based line and column that is
		// natural for users.
		++dmei.ulLineNumber;
		++dmei.ichCharPosition;

		if (dmei.wszSourceFile[0] == L'\0')
		{
			// if there was no filename packaged in the description, use this script's filename
			const WCHAR *pwszFilename = m_pParentScript->GetFilename();
			if (pwszFilename)
				wcsTruncatedCopy(dmei.wszSourceFile, pwszFilename, DMUS_MAX_FILENAME);
		}

		if (m_bstrErrorSourceComponent)
			wcsTruncatedCopy(dmei.wszSourceComponent, m_bstrErrorSourceComponent, DMUS_MAX_FILENAME);
		if (m_bstrErrorSourceLineText)
			wcsTruncatedCopy(dmei.wszSourceLineText, m_bstrErrorSourceLineText, DMUS_MAX_FILENAME);

		CopySizedStruct(pErrorInfo, &dmei);
	}
	this->ClearErrorInfo();

#ifdef DBG
    if (pErrorInfo)
    {
	    Trace(1, "Error: Script error in %S, line %u, column %i, near %S. %S: %S. Error code 0x%08X.\n",
		    pErrorInfo->wszSourceFile,
		    pErrorInfo->ulLineNumber,
		    pErrorInfo->ichCharPosition,
		    pErrorInfo->wszSourceLineText,
		    pErrorInfo->wszSourceComponent,
		    pErrorInfo->wszDescription,
		    pErrorInfo->hr);
    }
    else
    {
	    Trace(1, "Error: Unknown Script error.\n");
    }
#endif

	return DMUS_E_SCRIPT_ERROR_IN_SCRIPT;
}

CActiveScriptManager *CActiveScriptManager::GetCurrentContext()
{
	DWORD dwThreadId = GetCurrentThreadId();
	UINT uiSize = ms_svecContext.size();

	for (UINT i = 0; i < uiSize; ++i)
	{
		if (ms_svecContext[i].dwThreadId == dwThreadId)
			break;
	}

	if (i == uiSize)
		return NULL;

	return ms_svecContext[i].pActiveScriptManager;
}

HRESULT
CActiveScriptManager::SetCurrentContext(CActiveScriptManager *pActiveScriptManager, CActiveScriptManager **ppActiveScriptManagerPrevious)
{
	if (ppActiveScriptManagerPrevious)
		*ppActiveScriptManagerPrevious = NULL;

	DWORD dwThreadId = GetCurrentThreadId();
	UINT uiSize = ms_svecContext.size();

	for (UINT i = 0; i < uiSize; ++i)
	{
		if (ms_svecContext[i].dwThreadId == dwThreadId)
			break;
	}

	if (i == uiSize)
	{
		// add an entry
		if (!ms_svecContext.AccessTo(i))
			return E_OUTOFMEMORY;
	}

	ThreadContextPair &tcp = ms_svecContext[i];

	if (i == uiSize)
	{
		// initialize the new entry
		tcp.dwThreadId = dwThreadId;
		tcp.pActiveScriptManager = NULL;
	}

	if (ppActiveScriptManagerPrevious)
		*ppActiveScriptManagerPrevious = tcp.pActiveScriptManager;
	tcp.pActiveScriptManager = pActiveScriptManager;

	return S_OK;
}

HRESULT
CActiveScriptManager::EnsureEnumItemsCached(bool fRoutine)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	ScriptNames &snames = fRoutine ? m_snamesRoutines : m_snamesVariables;
	if (snames)
		return S_OK;

	UINT uiTypeInfoCount = 0;
	HRESULT hr = m_pDispatchScript->GetTypeInfoCount(&uiTypeInfoCount);
	if (SUCCEEDED(hr) && !uiTypeInfoCount)
		hr = E_NOTIMPL;
	if (FAILED(hr))
		return hr;

	SmartRef::ComPtr<ITypeInfo> scomITypeInfo;
	hr = m_pDispatchScript->GetTypeInfo(0, lcidUSEnglish, &scomITypeInfo);
	if (FAILED(hr))
		return hr;

	TYPEATTR *pattr = NULL;
	hr = scomITypeInfo->GetTypeAttr(&pattr);
	if (FAILED(hr))
		return hr;

	UINT cMaxItems = fRoutine ? pattr->cFuncs : pattr->cVars;
	hr = snames.Init(m_fUseOleAut, cMaxItems);
	if (FAILED(hr))
		return hr;

	// Iterate over the items
	DWORD dwCurIndex = 0; // Index position of next name to be saved in our cache
	for (UINT i = 0; i < cMaxItems; ++i)
	{
		FUNCDESC *pfunc = NULL;
		VARDESC *pvar = NULL;
		MEMBERID memid = DISPID_UNKNOWN;

		if (fRoutine)
		{
			hr = scomITypeInfo->GetFuncDesc(i, &pfunc);
			if (FAILED(hr))
				break;
			if (pfunc->funckind == FUNC_DISPATCH && pfunc->invkind == INVOKE_FUNC && pfunc->cParams == 0)
				memid = pfunc->memid;
		}
		else
		{
			hr = scomITypeInfo->GetVarDesc(i, &pvar);
			if (SUCCEEDED(hr) && pvar->varkind == VAR_DISPATCH)
				memid = pvar->memid;
		}

		if (memid != DISPID_UNKNOWN)
		{
			UINT cNames = 0;
			BSTR bstrName = NULL;
			hr = scomITypeInfo->GetNames(memid, &bstrName, 1, &cNames);
			if (SUCCEEDED(hr) && cNames == 1 && (fRoutine || 0 != wcscmp(bstrName, g_wszGlobalDispatch)))
				snames[dwCurIndex++] = bstrName;
			else
				DMS_SysFreeString(m_fUseOleAut, bstrName);
		}

		if (fRoutine)
			scomITypeInfo->ReleaseFuncDesc(pfunc);
		else
			scomITypeInfo->ReleaseVarDesc(pvar);
	}

	scomITypeInfo->ReleaseTypeAttr(pattr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\activescript.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CActiveScriptManager.
//

// CActiveScriptManager handles interfacing with VBScript or any activeX scripting
// language.  It intializes an IActiveScript object, sends it code, and sets and gets
// the values of variables.  Used by CDirectMusicScript.

#pragma once
#include "ole2.h"
#include "activscp.h"
#include "scriptthread.h"
#include "..\shared\dmusicp.h"

// forward declaration
class CDirectMusicScript;

// little helper class to cache routine and variable names for EnumItem
class ScriptNames
{
public:
	ScriptNames() : m_prgbstr(NULL) {}
	~ScriptNames() { Clear(); }
	HRESULT Init(bool fUseOleAut, DWORD cNames);
	operator bool() { return !!m_prgbstr; }
	DWORD size() { return m_dwSize; }
	void Clear();
	BSTR &operator[](DWORD dwIndex) { assert(m_prgbstr && dwIndex < m_dwSize); return m_prgbstr[dwIndex]; }

private:
	bool m_fUseOleAut;
	DWORD m_dwSize;
	BSTR *m_prgbstr;
};

class CActiveScriptManager
  : public IActiveScriptSite,
	public ScriptManager
{
public:
	CActiveScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT ScriptTrackCallRoutine(
				const WCHAR *pwszRoutineName,
				IDirectMusicSegmentState *pSegSt,
				DWORD dwVirtualTrackID,
				bool fErrorPMsgsEnabled,
				__int64 i64IntendedStartTime,
				DWORD dwIntendedStartTimeFlags);
	HRESULT SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems);
	HRESULT DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId);
	HRESULT DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr);
	void Close(); // Releases all references in preparation for shutdown

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IActiveScriptSite
	STDMETHOD(GetLCID)(/* [out] */ LCID __RPC_FAR *plcid);
	STDMETHOD(GetItemInfo)(
		/* [in] */ LPCOLESTR pstrName,
		/* [in] */ DWORD dwReturnMask,
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
		/* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);
	STDMETHOD(GetDocVersionString)(/* [out] */ BSTR __RPC_FAR *pbstrVersion);
	STDMETHOD(OnScriptTerminate)(
		/* [in] */ const VARIANT __RPC_FAR *pvarResult,
		/* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);
	STDMETHOD(OnStateChange)(/* [in] */ SCRIPTSTATE ssScriptState);
	STDMETHOD(OnScriptError)(/* [in] */ IActiveScriptError __RPC_FAR *pscripterror);
	STDMETHOD(OnEnterScript)();
	STDMETHOD(OnLeaveScript)();

	// Retrieve context for the currently running script.
	// Some automation model functions need access to the context from which the
	//    currently running routine was called.  For example, they may need to operate
	//    on the implied global performance.
	// Be sure to addref the returned pointer if holding onto it.
	static IDirectMusicPerformance8 *GetCurrentPerformanceNoAssertWEAK();
	static IDirectMusicPerformance8 *GetCurrentPerformanceWEAK() { IDirectMusicPerformance8 *pPerf = CActiveScriptManager::GetCurrentPerformanceNoAssertWEAK(); if (!pPerf) {assert(false);} return pPerf; }
	static IDirectMusicObject *GetCurrentScriptObjectWEAK();
	static IDirectMusicComposer8 *GetComposerWEAK();
	static void GetCurrentTimingContext(__int64 *pi64IntendedStartTime, DWORD *pdwIntendedStartTimeFlags);

private:
	// Functions
	HRESULT GetIDOfName(const WCHAR *pwszName, DISPID *pdispid); // returns S_FALSE for unknown name
	void ClearErrorInfo();
	void SetErrorInfo(ULONG ulLineNumber, LONG ichCharPosition, BSTR bstrSourceLine, const EXCEPINFO &excepinfo);
	void ContributeErrorInfo(const WCHAR *pwszActivity, const WCHAR *pwszSubject, const EXCEPINFO &excepinfo);
	HRESULT ReturnErrorInfo(HRESULT hr, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	static CActiveScriptManager *GetCurrentContext();
	static HRESULT SetCurrentContext(CActiveScriptManager *pActiveScriptManager, CActiveScriptManager **ppActiveScriptManagerPrevious); // remember to restore the previous pointer after the call
	HRESULT EnsureEnumItemsCached(bool fRoutine);

	// Data
	long m_cRef;

	// Pointer back to the containing script object
	CDirectMusicScript *m_pParentScript;

	// Active Scripting
	bool m_fUseOleAut;
	IActiveScript *m_pActiveScript;
	IDispatch *m_pDispatchScript;

	// Errors (managed via ClearErrorInfo, SetErrorInfo, and ContributeErrorInfo)
	bool m_fError;
	HRESULT m_hrError;
	ULONG m_ulErrorLineNumber;
	LONG m_ichErrorCharPosition;
	BSTR m_bstrErrorSourceComponent;
	BSTR m_bstrErrorDescription;
	BSTR m_bstrErrorSourceLineText;
	BSTR m_bstrHelpFile;

	// Context
	struct ThreadContextPair
	{
		DWORD dwThreadId;
		CActiveScriptManager *pActiveScriptManager;
	};
	static SmartRef::Vector<ThreadContextPair> ms_svecContext;

	// Timing context for a routine call from a script track.  (Sets the play/stop time of segments, songs, and playingsegments
	// to the time of the routine in the script track.)
	__int64 m_i64IntendedStartTime;
	DWORD m_dwIntendedStartTimeFlags;

	// cached names from enum methods
	ScriptNames m_snamesRoutines;
	ScriptNames m_snamesVariables;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autaudiopath.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicAudioPath.
//

#include "stdinc.h"
#include "autaudiopath.h"

const WCHAR CAutDirectMusicAudioPath::ms_wszClassName[] = L"AudioPath";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_SetVolume = 1;
const DISPID DMPDISP_GetVolume = 2;

const AutDispatchMethod CAutDirectMusicAudioPath::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_SetVolume,				L"SetVolume",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// volume
						ADT_Long,		true,	&IID_NULL,						// duration
						ADT_None },
		{ DMPDISP_GetVolume,				L"GetVolume",
						ADT_Long,		true,	&IID_NULL,						// returned volume
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicAudioPath> CAutDirectMusicAudioPath::ms_Handlers[] =
	{
		{ DMPDISP_SetVolume, SetVolume },
		{ DMPDISP_GetVolume, GetVolume },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicAudioPath::CAutDirectMusicAudioPath(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpAudioPath(pUnknownOuter, iid, ppv, phr),
	m_lVolume(0)
{
}

HRESULT
CAutDirectMusicAudioPath::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicAudioPath *pInst = new CAutDirectMusicAudioPath(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicAudioPath::SetVolume(AutDispatchDecodedParams *paddp)
{
	LONG lVol = paddp->params[0].lVal;
	LONG lDuration = paddp->params[1].lVal;

	m_lVolume = ClipLongRange(lVol, -9600, 0);
	return m_pITarget->SetVolume(m_lVolume, lDuration);
}

HRESULT
CAutDirectMusicAudioPath::GetVolume(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (plRet)
		*plRet = m_lVolume;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmloader\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmloader

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=dmloaded
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\loader.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32

INCLUDES=$(INCLUDES);   \
    ..\..\shared


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(SDK_LIB_PATH)\ole32.lib

SOURCES=..\alist.cpp   \
..\debug.cpp           \
..\dll.cpp             \
..\guids.cpp           \
..\loader.cpp          \
..\object.cpp          \
..\oledll.cpp          \
..\stream.cpp          \
..\dmloader.rc         \
..\opnew.cpp           \
..\container.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autaudiopathconfig.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicAudioPathConfig.
// IDispatch interface for IUnknown.
// Unly usable via aggregation within an IUnknown object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicAudioPathConfig;
typedef CAutBaseImp<CAutDirectMusicAudioPathConfig, IDirectMusicObject, &IID_IPersistStream> BaseImpAPConfig;

class CAutDirectMusicAudioPathConfig
  : public BaseImpAPConfig
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicAudioPathConfig(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT Load(AutDispatchDecodedParams *paddp);
	HRESULT Create(AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicAudioPathConfig> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autaudiopath.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicAudioPath.
// IDispatch interface for IDirectMusicAudioPath.
// Unly usable via aggregation within an IDirectMusicAudioPath object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicAudioPath;
typedef CAutBaseImp<CAutDirectMusicAudioPath, IDirectMusicAudioPath, &IID_IDirectMusicAudioPath> BaseImpAudioPath;

class CAutDirectMusicAudioPath
  : public BaseImpAudioPath
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicAudioPath(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT SetVolume(AutDispatchDecodedParams *paddp);
	HRESULT GetVolume(AutDispatchDecodedParams *paddp);

	LONG m_lVolume;

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicAudioPath> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autaudiopathconfig.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicAudioPathConfig.
//

#include "stdinc.h"
#include "autaudiopathconfig.h"
#include "activescript.h"

const WCHAR CAutDirectMusicAudioPathConfig::ms_wszClassName[] = L"AudioPathConfig";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_Load = 1;
const DISPID DMPDISP_Create = 2;

const AutDispatchMethod CAutDirectMusicAudioPathConfig::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_Load, 						L"Load",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_Create,						L"Create",
						ADT_Interface,	true,	&IID_IUnknown,					// returned audiopath
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicAudioPathConfig> CAutDirectMusicAudioPathConfig::ms_Handlers[] =
	{
		{ DMPDISP_Load, Load },
		{ DMPDISP_Create, Create },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicAudioPathConfig::CAutDirectMusicAudioPathConfig(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpAPConfig(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT
CAutDirectMusicAudioPathConfig::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicAudioPathConfig *pInst = new CAutDirectMusicAudioPathConfig(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicAudioPathConfig::Load(AutDispatchDecodedParams *paddp)
{
	// Loading is actually implemented generically by container items.
	// If we're here, we're already loaded and don't need to do anything.
	return S_OK;
}

HRESULT
CAutDirectMusicAudioPathConfig::Create(AutDispatchDecodedParams *paddp)
{
	IDirectMusicAudioPath **ppAudioPath = reinterpret_cast<IDirectMusicAudioPath **>(paddp->pvReturn);
	if (!ppAudioPath)
		return S_OK;

	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
	hr = pPerformance->CreateAudioPath(m_pITarget, TRUE, ppAudioPath);
	if (FAILED(hr))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autconstants.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Functions that implement the automation interfaces for the DirectMusic constants.
// This is a table of names and integer values that are implemented as read-only properties.
//

#pragma once

namespace ScriptConstants
{
	const LONG IsSecondary		= (1 << 0);
	const LONG IsControl		= (1 << 1);
	const LONG AtFinish			= (1 << 2);
	const LONG AtGrid			= (1 << 3);
	const LONG AtBeat			= (1 << 4);
	const LONG AtMeasure		= (1 << 5);
	const LONG AtMarker			= (1 << 6);
	const LONG AtImmediate		= (1 << 7);
	const LONG AlignToBar		= (1 << 8);
	const LONG AlignToBeat		= (1 << 9);
	const LONG AlignToSegment	= (1 << 10);
	const LONG PlayFill			= (1 << 11);
	const LONG PlayIntro		= (1 << 12);
	const LONG PlayBreak		= (1 << 13);
	const LONG PlayEnd			= (1 << 14);
	const LONG PlayEndAndIntro	= (1 << 15);
	const LONG PlayModulate		= (1 << 16);
	const LONG NoCutoff			= (1 << 17);
};

HRESULT AutConstantsGetIDsOfNames(
			REFIID riid,
			LPOLESTR __RPC_FAR *rgszNames,
			UINT cNames,
			LCID lcid,
			DISPID __RPC_FAR *rgDispId);

HRESULT AutConstantsInvoke(
			DISPID dispIdMember,
			REFIID riid,
			LCID lcid,
			WORD wFlags,
			DISPPARAMS __RPC_FAR *pDispParams,
			VARIANT __RPC_FAR *pVarResult,
			EXCEPINFO __RPC_FAR *pExcepInfo,
			UINT __RPC_FAR *puArgErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autbaseimp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Templated base class CAutBaseImp for constructing automation interfaces.
// Implements aggregation and IDispatched based on a table of method information.
//

#pragma once
#include "authelper.h"

// Inherit your class from CAutBaseImp with the following template types:
//	* T_derived is the type of your class itself.
//	* T_ITarget is the DirectMusic interface you are implemention automation for.
//	* T_piid is the address of the IID of T_ITarget.

// Your class must have the following public static members:
//	* static const AutDispatchMethod ms_Methods[];
//		This table describes your methods and their parameters.
//	* static const DispatchHandlerEntry<T_derived> ms_Handlers[];
//		This table designates member functions on your class that will be called when
//		your methods are invoked.
// 	* static const WCHAR ms_wszClassName[];
//		This is the name of your class that will be output in the debug log
//		as your functions are called.


// See autperformance.h and autperformance.cpp for an example of using this base class.

template <class T_derived>
struct DispatchHandlerEntry
	{
		typedef HRESULT (T_derived::* pmfnDispatchHandler)(AutDispatchDecodedParams *paddp);

		DISPID dispid;
		pmfnDispatchHandler pmfn;
	};

template <class T_derived, class T_ITarget, const IID *T_piid>
class CAutBaseImp
  : public CAutUnknown::CAutUnknownParent,
	public IDispatch
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

protected:
	CAutBaseImp(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr);
	virtual ~CAutBaseImp() {}

	T_ITarget *m_pITarget;

private:
	CAutUnknown m_UnkControl;
	virtual void Destroy();
};

#include "autbaseimp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\authelper.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper utilities for implementing automation interfaces.
//

#include "stdinc.h"
#include "authelper.h"
#include "oleaut.h"

//////////////////////////////////////////////////////////////////////
// CAutUnknown

CAutUnknown::CAutUnknown()
  : m_cRef(0),
	m_pParent(NULL),
	m_pDispatch(NULL)
{
}

void
CAutUnknown::Init(CAutUnknownParent *pParent, IDispatch *pDispatch)
{
	m_pParent = pParent;
	m_pDispatch = pDispatch;

	struct LocalFn
	{
		static HRESULT CheckParams(CAutUnknownParent *pParent, IDispatch *pDispatch)
		{
			V_INAME(CAutUnknown::CAutUnknown);
			V_PTR_READ(pParent, CAutUnknown::CAutUnknownParent);
			V_INTERFACE(pDispatch);
			return S_OK;
		}
	};
	assert(S_OK == LocalFn::CheckParams(m_pParent, m_pDispatch));
}

STDMETHODIMP 
CAutUnknown::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CAutUnknown::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	*ppv = NULL;
	if (iid == IID_IUnknown)
	{
		*ppv = this;
	}
	else if (iid == IID_IDispatch)
	{
		if (!m_pDispatch)
			return E_UNEXPECTED;
		*ppv = m_pDispatch;
	}

	if (*ppv == NULL)
		return E_NOINTERFACE;
	
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG)
CAutUnknown::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CAutUnknown::Release()
{
	if (!InterlockedDecrement(&m_cRef) && m_pParent) 
	{
		m_pParent->Destroy();
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDispatch implemented from type table

HRESULT
AutDispatchGetIDsOfNames(
		const AutDispatchMethod *pMethods,
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	V_INAME(AutDispatchGetIDsOfNames);
	V_PTR_READ(pMethods, AutDispatchMethod); // only 1 -- assume the rest are OK
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	for (c = 0; pMethods[c].dispid != DISPID_UNKNOWN; ++c)
	{
		if (0 == _wcsicmp(rgszNames[0], pMethods[c].pwszName))
		{
			rgDispId[0] = pMethods[c].dispid;
			break;
		}
	}

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

inline HRESULT
ConvertParameter(
		bool fUseOleAut,
		VARIANTARG *pvarActualParam, // pass null if param omitted
		const AutDispatchParam *pExpectedParam,
		AutDispatchDecodedParam *pparam)
{
	HRESULT hr = S_OK;

	if (!pvarActualParam)
	{
		// parameter omitted

		if (!pExpectedParam->fOptional)
			return DISP_E_PARAMNOTOPTIONAL;

		// set to default value
		switch (pExpectedParam->adt)
		{
		case ADT_Long:
			pparam->lVal = 0;
			break;
		case ADT_Interface:
			pparam->iVal = NULL;
			break;
		case ADT_Bstr:
			pparam->bstrVal = NULL;
			break;
		default:
			assert(false);
			return E_FAIL;
		}
	}
	else
	{
		// convert to expected type

		VARIANT varConvert;
		DMS_VariantInit(fUseOleAut, &varConvert);

		VARTYPE vtExpected;
		switch (pExpectedParam->adt)
		{
		case ADT_Long:
			vtExpected = VT_I4;
			break;
		case ADT_Interface:
			vtExpected = VT_UNKNOWN;
			break;
		case ADT_Bstr:
			vtExpected = VT_BSTR;
			break;
		default:
			assert(false);
			return E_FAIL;
		}

		hr = DMS_VariantChangeType(
				fUseOleAut,
				&varConvert,
				pvarActualParam,
				0,
				vtExpected);
		if (FAILED(hr) && !(hr == DISP_E_OVERFLOW || hr == DISP_E_TYPEMISMATCH))
		{
			assert(false); // something weird happened -- according to the OLE specs these are the only two conversion results we should get if we called VariantChangeType properly
			hr = DISP_E_TYPEMISMATCH; // the problem happened during type conversion problem, so call it a type mismatch
		}
		if (SUCCEEDED(hr))
		{
			// set the decoded pointer
			switch (vtExpected)
			{
			case VT_I4:
				pparam->lVal = varConvert.lVal;
				break;
			case VT_UNKNOWN:
				if (varConvert.punkVal)
					hr = varConvert.punkVal->QueryInterface(*pExpectedParam->piid, &pparam->iVal);
				else
					pparam->iVal = 0;
				if (FAILED(hr))
					hr = DISP_E_TYPEMISMATCH;
				break;
			case VT_BSTR:
				pparam->bstrVal = DMS_SysAllocString(fUseOleAut, varConvert.bstrVal);
				break;
			default:
				assert(false);
				return E_FAIL;
			}
		}
		DMS_VariantClear(fUseOleAut, &varConvert); // free possible resources allocated in conversion
	}

	return hr;
}

inline void
FreeParameters(
		bool fUseOleAut,
		const AutDispatchMethod *pMethod,
		AutDispatchDecodedParams *pDecodedParams,
		const AutDispatchParam *pParamStopBefore = NULL)
{
	for (const AutDispatchParam *pParam = pMethod->rgadpParams;
			pParam != pParamStopBefore;
			++pParam)
	{
		switch (pParam->adt)
		{
		case ADT_None:
			return;
		case ADT_Long:
			break;
		case ADT_Interface:
			{
				IUnknown *pUnknown = reinterpret_cast<IUnknown *>(pDecodedParams->params[pParam - pMethod->rgadpParams].iVal);
				SafeRelease(pUnknown);
				pDecodedParams->params[pParam - pMethod->rgadpParams].iVal = NULL;
				break;
			}
		case ADT_Bstr:
			{
				DMS_SysFreeString(fUseOleAut, pDecodedParams->params[pParam - pMethod->rgadpParams].bstrVal);
				pDecodedParams->params[pParam - pMethod->rgadpParams].bstrVal = NULL;
				break;
			}
		default:
			assert(false);
			return;
		}
	}
}

HRESULT
AutDispatchInvokeDecode(
		const AutDispatchMethod *pMethods,
		AutDispatchDecodedParams *pDecodedParams,
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		UINT __RPC_FAR *puArgErr,
		const WCHAR *pwszTraceTargetType,
		IUnknown *punkTraceTargetObject)
{
	V_INAME(AutDispatchInvokeDecode);
	V_PTR_READ(pMethods, AutDispatchMethod); // only 1 -- assume the rest are OK
	V_PTR_WRITE(pDecodedParams, AutDispatchDecodedParams);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(puArgErr, UINT);

	bool fUseOleAut = !!(riid == IID_NULL);

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_METHOD))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	ZeroMemory(pDecodedParams, sizeof(AutDispatchDecodedParams));

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	// Find the method

	for (const AutDispatchMethod *pMethodCalled = pMethods;
			pMethodCalled->dispid != DISPID_UNKNOWN && pMethodCalled->dispid != dispIdMember;
			++pMethodCalled)
	{
	}

	if (pMethodCalled->dispid == DISPID_UNKNOWN)
		return DISP_E_MEMBERNOTFOUND;

#ifdef DBG
	// Build a trace string for the method call
	struct LocalTraceFunc
	{
		static void CatTill(WCHAR *&rpwszWrite, const WCHAR *pwszCopy, const WCHAR *pwszUntil)
		{
			while (*pwszCopy != L'\0' && rpwszWrite < pwszUntil)
			{
				*rpwszWrite++ = *pwszCopy++;
			}
		}
	};

	WCHAR wszBuf[512];
	WCHAR *pwszWrite = wszBuf;
	const WCHAR *pwszUntil = wszBuf + ARRAY_SIZE(wszBuf) - 2; // leave space for CR and \0

	LocalTraceFunc::CatTill(pwszWrite, L"Call to ", pwszUntil);
	LocalTraceFunc::CatTill(pwszWrite, pwszTraceTargetType, pwszUntil);

	IDirectMusicObject *pIDMO = NULL;
	HRESULT hrTrace = punkTraceTargetObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pIDMO));
	if (SUCCEEDED(hrTrace))
	{
		DMUS_OBJECTDESC objdesc;
		ZeroMemory(&objdesc, sizeof(objdesc));
		hrTrace = pIDMO->GetDescriptor(&objdesc);
		pIDMO->Release();
		if (SUCCEEDED(hrTrace) && (objdesc.dwValidData & DMUS_OBJ_NAME))
		{
			LocalTraceFunc::CatTill(pwszWrite, L" \"", pwszUntil);
			LocalTraceFunc::CatTill(pwszWrite, objdesc.wszName, pwszUntil);
			LocalTraceFunc::CatTill(pwszWrite, L"\"", pwszUntil);
		}
	}

	LocalTraceFunc::CatTill(pwszWrite, L" ", pwszUntil);
	LocalTraceFunc::CatTill(pwszWrite, pMethodCalled->pwszName, pwszUntil);
	LocalTraceFunc::CatTill(pwszWrite, L"(", pwszUntil);
#endif

	// Count the expected parameters
	UINT cParamMin = 0;
	for (UINT cParamMax = 0;
			pMethodCalled->rgadpParams[cParamMax].adt != ADT_None;
			++cParamMax)
	{
		if (!pMethodCalled->rgadpParams[cParamMax].fOptional)
		{
			cParamMin = cParamMax + 1; // add one because max is currently zero-based
		}
	}

	if (pDispParams->cArgs < cParamMin || pDispParams->cArgs > cParamMax)
		return DISP_E_BADPARAMCOUNT;

	// Verify and prepare each parameter

	HRESULT hr = S_OK;
	for (UINT iParam = 0; iParam < cParamMax; ++iParam)
	{
		const int iParamActual = pDispParams->cArgs - iParam - 1; // dispparams are passed last to first
		const AutDispatchParam *pExpectedParam = &pMethodCalled->rgadpParams[iParam];
		VARIANTARG *pvarActualParam = (iParamActual >= 0)
										? &pDispParams->rgvarg[iParamActual]
										: NULL;
		// VT_ERROR with DISP_E_PARAMNOTFOUND is passed as placeholder for optional params
		if (pvarActualParam && pvarActualParam->vt == VT_ERROR && pvarActualParam->scode == DISP_E_PARAMNOTFOUND)
			pvarActualParam = NULL;

		hr = ConvertParameter(fUseOleAut, pvarActualParam, pExpectedParam, &pDecodedParams->params[iParam]);

		if (FAILED(hr))
		{
			if (puArgErr)
				*puArgErr = iParamActual;
			FreeParameters(fUseOleAut, pMethodCalled, pDecodedParams, pExpectedParam);
			return hr;
		}
	}

	// Prepare the return value

	if (pVarResult)
	{
		switch (pMethodCalled->adpReturn.adt)
		{
		case ADT_None:
			break;

		case ADT_Long:
			pVarResult->vt = VT_I4;
			pVarResult->lVal = 0;
			pDecodedParams->pvReturn = &pVarResult->lVal;
			break;

		case ADT_Interface:
			pVarResult->vt = VT_UNKNOWN;
			pVarResult->punkVal = NULL;
			pDecodedParams->pvReturn = &pVarResult->punkVal;
			break;

		case ADT_Bstr:
			pVarResult->vt = VT_BSTR;
			pVarResult->bstrVal = NULL;
			pDecodedParams->pvReturn = &pVarResult->bstrVal;

		default:
			assert(false);
			return E_FAIL;
		}
	}

#ifdef DBG
	LocalTraceFunc::CatTill(pwszWrite, L")", pwszUntil);
	pwszWrite[0] = L'\n';
	pwszWrite[1] = L'\0';
	DebugTrace(g_ScriptCallTraceLevel, "%S", wszBuf);
#endif

	return S_OK;
}

void
AutDispatchInvokeFree(
		const AutDispatchMethod *pMethods,
		AutDispatchDecodedParams *pDecodedParams,
		DISPID dispIdMember,
		REFIID riid)
{
	bool fUseOleAut = !!(riid == IID_NULL);
	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
	{
		assert(false);
		return;
	}

	// Find the method
	for (const AutDispatchMethod *pMethodCalled = pMethods;
			pMethodCalled->dispid != DISPID_UNKNOWN && pMethodCalled->dispid != dispIdMember;
			++pMethodCalled)
	{
	}

	if (pMethodCalled->dispid != DISPID_UNKNOWN)
	{
		FreeParameters(fUseOleAut, pMethodCalled, pDecodedParams); 
	}
}

HRESULT AutDispatchHrToException(
		const AutDispatchMethod *pMethods,
		DISPID dispIdMember,
		REFIID riid,
		HRESULT hr,
		EXCEPINFO __RPC_FAR *pExcepInfo)
{
	V_INAME(AutDispatchHrToException);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (SUCCEEDED(hr))
		return hr;

	if (!pExcepInfo)
		return DISP_E_EXCEPTION;

	// Find the method
	for (const AutDispatchMethod *pMethodCalled = pMethods;
			pMethodCalled->dispid != DISPID_UNKNOWN && pMethodCalled->dispid != dispIdMember;
			++pMethodCalled)
	{
	}

	if (pMethodCalled->dispid == DISPID_UNKNOWN)
	{
		assert(false);
		return hr;
	}

	pExcepInfo->wCode = 0;
	pExcepInfo->wReserved = 0;
	pExcepInfo->bstrSource = DMS_SysAllocString(fUseOleAut, L"Microsoft DirectMusic Runtime Error");
	static const WCHAR wszError[] = L"An error occurred in a call to ";
	static const UINT cchError = wcslen(wszError);
	WCHAR *pwszDescription = new WCHAR[cchError + wcslen(pMethodCalled->pwszName) + 1];
	if (!pwszDescription)
	{
		pExcepInfo->bstrDescription = NULL;
	}
	else
	{
		wcscpy(pwszDescription, wszError);
		wcscat(pwszDescription, pMethodCalled->pwszName);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fUseOleAut, pwszDescription);
		delete[] pwszDescription;
	}
	pExcepInfo->bstrHelpFile = NULL;
	pExcepInfo->pvReserved = NULL;
	pExcepInfo->pfnDeferredFillIn = NULL;
	pExcepInfo->scode = hr;

	return DISP_E_EXCEPTION;
}

//////////////////////////////////////////////////////////////////////
// Implementation of IDispatch for the standard Load method on objects.

HRESULT AutLoadDispatchGetIDsOfNames(
			REFIID riid,
			LPOLESTR __RPC_FAR *rgszNames,
			UINT cNames,
			LCID lcid,
			DISPID __RPC_FAR *rgDispId)
{
	V_INAME(AutLoadDispatchGetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	if (0 == _wcsicmp(rgszNames[0], L"Load"))
		rgDispId[0] = g_dispidLoad;

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

HRESULT AutLoadDispatchInvoke(
		bool *pfUseOleAut,
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	V_INAME(AutLoadDispatchInvoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(puArgErr, UINT);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);
	if (pfUseOleAut)
		*pfUseOleAut = fUseOleAut;

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_METHOD))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	// Find the method

	if (dispIdMember != g_dispidLoad)
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cArgs > 0)
		return DISP_E_BADPARAMCOUNT;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Miscellaneous little things

DWORD MapFlags(LONG lFlags, const FlagMapEntry *pfm)
{
	assert(pfm);
	DWORD dw = 0;
	for ( ; pfm->lSrc; ++pfm)
	{
		if (lFlags & pfm->lSrc)
			dw |= pfm->dwDest;
	}
	return dw;
}

BYTE VolumeToMidi(LONG lVolume)
{
	assert(lVolume >= -9600 && lVolume <= 0);
	static LONG s_lDBToMIDI[97] = { 0 };
	if (s_lDBToMIDI[0] == 0)
	{
		s_lDBToMIDI[0] = 127;
		for (int nIndex = 1; nIndex < 97; nIndex++)
		{
			double flTemp = 0.0 - nIndex;
			flTemp /= 10.0;
			flTemp = pow(10,flTemp);
			flTemp = sqrt(flTemp);
			flTemp = sqrt(flTemp);
			flTemp *= 127.0;
			s_lDBToMIDI[nIndex] = flTemp;
		}
	}

	lVolume = -lVolume;
	long lFraction = lVolume % 100;
	lVolume = lVolume / 100;
	long lResult = s_lDBToMIDI[lVolume];
	lResult += ((s_lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
	assert(lResult >= std::numeric_limits<BYTE>::min() && lResult <= std::numeric_limits<BYTE>::max());
	return lResult;
}

HRESULT SendVolumePMsg(LONG lVolume, LONG lDuration, DWORD dwPChannel, IDirectMusicGraph *pGraph, IDirectMusicPerformance *pPerf, short *pnNewVolume)
{
	assert(pGraph && pPerf && pnNewVolume);
	lVolume = ClipLongRange(lVolume, -9600, 0);
	BYTE bMIDIVol = VolumeToMidi(lVolume);

	SmartRef::PMsg<DMUS_CURVE_PMSG> pmsgCurve(pPerf);
	HRESULT hr = pmsgCurve.hr();
	if (FAILED(hr))
		return hr;

	// generic PMsg fields

	REFERENCE_TIME rtTimeNow = 0;
	hr = pPerf->GetLatencyTime(&rtTimeNow);
	if (FAILED(hr))
		return hr;
	pmsgCurve.p->rtTime = rtTimeNow;
	pmsgCurve.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
	pmsgCurve.p->dwPChannel = dwPChannel;
	// dwVirtualTrackID: this isn't a track so leave as 0
	pmsgCurve.p->dwType = DMUS_PMSGT_CURVE;
	pmsgCurve.p->dwGroupID = -1; // this isn't a track so just say all groups

	// curve PMsg fields
	pmsgCurve.p->mtDuration = lDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
	// mtResetDuration: no reset so leave as 0
	// nStartValue: will be ignored
	pmsgCurve.p->nEndValue = bMIDIVol;
	// nResetValue: no reset so leave as 0
	pmsgCurve.p->bType = DMUS_CURVET_CCCURVE;
	pmsgCurve.p->bCurveShape = lDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
	pmsgCurve.p->bCCData = 7; // MIDI volume controller number
	pmsgCurve.p->bFlags = DMUS_CURVE_START_FROM_CURRENT;
	// wParamType: leave as zero since this isn't a NRPN/RPN curve
	pmsgCurve.p->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

	// send it
	pmsgCurve.StampAndSend(pGraph);
	hr = pmsgCurve.hr();
	if (FAILED(hr))
		return hr;

	*pnNewVolume = lVolume;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autbaseimp.inl ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutBaseImp.
//

#include "dll.h"

//////////////////////////////////////////////////////////////////////
// Creation

template <class T_derived, class T_ITarget, const IID *T_piid>
CAutBaseImp<T_derived, T_ITarget, T_piid>::CAutBaseImp(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : m_pITarget(NULL)
{
	struct LocalFunc
	{
		static HRESULT CheckParams(IUnknown* pUnknownOuter, void** ppv)
		{ 
			V_INAME(CAutBaseImp::CAutBaseImp);
			V_INTERFACE(pUnknownOuter);
			V_PTR_WRITE(ppv, IUnknown *);
			return S_OK;
		}
	};
	*phr = LocalFunc::CheckParams(pUnknownOuter, ppv);
	if (FAILED(*phr))
		return;

	*ppv = NULL;

	// This class can only be created inside an aggregation.
	if (!pUnknownOuter || iid != IID_IUnknown)
	{
		Trace(1, "Error: The AutoImp objects are used by other DirectMusic objects, but are not designed to be instantiated on their own.\n");
		*phr = E_INVALIDARG;
		return;
	}

	// The outer object must have the target interface.
	*phr = pUnknownOuter->QueryInterface(*T_piid, reinterpret_cast<void**>(&m_pITarget));
	if (FAILED(*phr))
		return;

	// Due to the aggregation contract, our object is wholely contained in the lifetime of
	// the outer object and we shouldn't hold any references to it.
	ULONG ulCheck = m_pITarget->Release();
	assert(ulCheck);

	m_UnkControl.Init(this, this);
	LockModule(true);

	*phr = m_UnkControl.QueryInterface(iid, ppv);
	return;
}

//////////////////////////////////////////////////////////////////////
// IUnknown
//    Delegates to outer unknown.

template <class T_derived, class T_ITarget, const IID *T_piid>
STDMETHODIMP 
CAutBaseImp<T_derived, T_ITarget, T_piid>::QueryInterface(const IID &iid, void **ppv)
{
	return m_pITarget->QueryInterface(iid, ppv);
}

template <class T_derived, class T_ITarget, const IID *T_piid>
STDMETHODIMP_(ULONG)
CAutBaseImp<T_derived, T_ITarget, T_piid>::AddRef()
{
	return m_pITarget->AddRef();
}

template <class T_derived, class T_ITarget, const IID *T_piid>
STDMETHODIMP_(ULONG)
CAutBaseImp<T_derived, T_ITarget, T_piid>::Release()
{
	return m_pITarget->Release();
}

//////////////////////////////////////////////////////////////////////
// Private Functions

template <class T_derived, class T_ITarget, const IID *T_piid>
void
CAutBaseImp<T_derived, T_ITarget, T_piid>::Destroy()
{
	LockModule(false);
	delete this;
}

//////////////////////////////////////////////////////////////////////
// IDispatch

template <class T_derived, class T_ITarget, const IID *T_piid>
STDMETHODIMP
CAutBaseImp<T_derived, T_ITarget, T_piid>::GetTypeInfoCount(UINT *pctinfo)
{
	V_INAME(CAutBaseImp::GetTypeInfoCount);
	V_PTR_WRITE(pctinfo, UINT);

	*pctinfo = 0;
	return S_OK;
}

template <class T_derived, class T_ITarget, const IID *T_piid>
STDMETHODIMP
CAutBaseImp<T_derived, T_ITarget, T_piid>::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo)
{
	*ppTInfo = NULL;
	return E_NOTIMPL;
}

template <class T_derived, class T_ITarget, const IID *T_piid>
STDMETHODIMP
CAutBaseImp<T_derived, T_ITarget, T_piid>::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	return AutDispatchGetIDsOfNames(T_derived::ms_Methods, riid, rgszNames, cNames, lcid, rgDispId);
}

template <class T_derived, class T_ITarget, const IID *T_piid>
STDMETHODIMP
CAutBaseImp<T_derived, T_ITarget, T_piid>::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	// Decode the parameters

	AutDispatchDecodedParams addp;
	HRESULT hr = AutDispatchInvokeDecode(
					T_derived::ms_Methods,
					&addp,
					dispIdMember,
					riid,
					lcid,
					wFlags,
					pDispParams,
					pVarResult,
					puArgErr,
					T_derived::ms_wszClassName,
					m_pITarget);

	if (FAILED(hr))
		return hr;

	// Call the handler

	for (const DispatchHandlerEntry<T_derived> *pdhe = T_derived::ms_Handlers;
			pdhe->dispid != DISPID_UNKNOWN && pdhe->dispid != dispIdMember;
			++pdhe)
	{
	}

	if (pdhe->dispid == DISPID_UNKNOWN)
	{
		assert(false);
		return DISP_E_MEMBERNOTFOUND;
	}

	hr = ((static_cast<T_derived*>(this))->*pdhe->pmfn)(&addp);

	// Clean up and return

	AutDispatchInvokeFree(T_derived::ms_Methods, &addp, dispIdMember, riid);
	return AutDispatchHrToException(T_derived::ms_Methods, dispIdMember, riid, hr, pExcepInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autconstants.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Functions that implement the automation interfaces for the DirectMusic constants.
//

#include "stdinc.h"
#include "autconstants.h"
#include "oleaut.h"

struct AutConstantDef
{
	DISPID dispid;
	const WCHAR *pwszName;
	LONG lVal;
};

// Performance

const DISPID DMCONSTDISP_IsSecondary = 1;
const DISPID DMCONSTDISP_IsControl = 2;
const DISPID DMCONSTDISP_AtFinish = 3;
const DISPID DMCONSTDISP_AtGrid = 4;
const DISPID DMCONSTDISP_AtBeat = 5;
const DISPID DMCONSTDISP_AtMeasure = 6;
const DISPID DMCONSTDISP_AtMarker = 7;
const DISPID DMCONSTDISP_AtImmediate = 8;
const DISPID DMCONSTDISP_AlignToBar = 9;
const DISPID DMCONSTDISP_AlignToBeat = 10;
const DISPID DMCONSTDISP_AlignToSegment = 11;
const DISPID DMCONSTDISP_PlayFill = 12;
const DISPID DMCONSTDISP_PlayIntro = 13;
const DISPID DMCONSTDISP_PlayBreak = 14;
const DISPID DMCONSTDISP_PlayEnd = 15;
const DISPID DMCONSTDISP_PlayEndAndIntro = 16;
const DISPID DMCONSTDISP_PlayModulate = 17;
const DISPID DMCONSTDISP_UseClockTime = 18;
const DISPID DMCONSTDISP_NoCutoff = 19;

const AutConstantDef gs_Constants[] =
	{
		{ DMCONSTDISP_IsSecondary,						L"IsSecondary",						ScriptConstants::IsSecondary },
		{ DMCONSTDISP_IsControl,						L"IsControl",						ScriptConstants::IsControl },
		{ DMCONSTDISP_AtFinish,							L"AtFinish",						ScriptConstants::AtFinish },
		{ DMCONSTDISP_AtGrid,							L"AtGrid",							ScriptConstants::AtGrid },
		{ DMCONSTDISP_AtBeat,							L"AtBeat",							ScriptConstants::AtBeat },
		{ DMCONSTDISP_AtMeasure,						L"AtMeasure",						ScriptConstants::AtMeasure },
		{ DMCONSTDISP_AtMarker,							L"AtMarker",						ScriptConstants::AtMarker },
		{ DMCONSTDISP_AtImmediate,						L"AtImmediate",						ScriptConstants::AtImmediate },
		{ DMCONSTDISP_AlignToBar,						L"AlignToBar",						ScriptConstants::AlignToBar },
		{ DMCONSTDISP_AlignToBeat,						L"AlignToBeat",						ScriptConstants::AlignToBeat },
		{ DMCONSTDISP_AlignToSegment,					L"AlignToSegment",					ScriptConstants::AlignToSegment },
		{ DMCONSTDISP_PlayFill,							L"PlayFill",						ScriptConstants::PlayFill },
		{ DMCONSTDISP_PlayIntro,						L"PlayIntro",						ScriptConstants::PlayIntro },
		{ DMCONSTDISP_PlayBreak,						L"PlayBreak",						ScriptConstants::PlayBreak },
		{ DMCONSTDISP_PlayEnd,							L"PlayEnd",							ScriptConstants::PlayEnd },
		{ DMCONSTDISP_PlayEndAndIntro,					L"PlayEndAndIntro",					ScriptConstants::PlayEndAndIntro },
		{ DMCONSTDISP_PlayModulate,						L"PlayModulate",					ScriptConstants::PlayModulate },
		{ DMCONSTDISP_NoCutoff,							L"NoCutoff",						ScriptConstants::NoCutoff },
		{ DISPID_UNKNOWN }
	};

HRESULT
AutConstantsGetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	V_INAME(AutConstantsGetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	for (c = 0; gs_Constants[c].dispid != DISPID_UNKNOWN; ++c)
	{
		if (0 == _wcsicmp(rgszNames[0], gs_Constants[c].pwszName))
		{
			rgDispId[0] = gs_Constants[c].dispid;
			break;
		}
	}

	// Additional names requested (cNames > 1) are named parameters,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

HRESULT AutConstantsInvoke(
			DISPID dispIdMember,
			REFIID riid,
			LCID lcid,
			WORD wFlags,
			DISPPARAMS __RPC_FAR *pDispParams,
			VARIANT __RPC_FAR *pVarResult,
			EXCEPINFO __RPC_FAR *pExcepInfo,
			UINT __RPC_FAR *puArgErr)
{
	V_INAME(AutConstantsInvoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_PROPERTYGET))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cArgs > 0)
		return DISP_E_BADPARAMCOUNT;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	// Find the constant

	for (const AutConstantDef *pConst = gs_Constants;
			pConst->dispid != DISPID_UNKNOWN && pConst->dispid != dispIdMember;
			++pConst)
	{
	}

	if (pConst->dispid == DISPID_UNKNOWN)
		return DISP_E_MEMBERNOTFOUND;

	// Return the value value

	if (pVarResult)
	{
		pVarResult->vt = VT_I4;
		pVarResult->lVal = pConst->lVal;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autsegment.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicSegment.
// IDispatch interface for IDirectMusicSegment.
// Unly usable via aggregation within an IDirectMusicSegment object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicSegment;
typedef CAutBaseImp<CAutDirectMusicSegment, IDirectMusicSegment8, &IID_IDirectMusicSegment8> BaseImpSegment;

class CAutDirectMusicSegment
  : public BaseImpSegment
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicSegment(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	//  Methods that rely on an implied performance need testing in multithreaded situations
	HRESULT Load(AutDispatchDecodedParams *paddp);
	HRESULT Play(AutDispatchDecodedParams *paddp);
	HRESULT Stop(AutDispatchDecodedParams *paddp);
	HRESULT DownloadSoundData(AutDispatchDecodedParams *paddp) { return DownloadOrUnload(true, paddp); }
	HRESULT UnloadSoundData(AutDispatchDecodedParams *paddp) { return DownloadOrUnload(false, paddp); }
	HRESULT Recompose(AutDispatchDecodedParams *paddp);

	// Helpers
	HRESULT DownloadOrUnload(bool fDownload, AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicSegment> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autperformance.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicPerformance.
// IDispatch interface for IDirectMusicPerformance.
// Unly usable via aggregation within an IDirectMusicPerformance object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicPerformance;
typedef CAutBaseImp<CAutDirectMusicPerformance, IDirectMusicPerformance, &IID_IDirectMusicPerformance> BaseImpPerf;

class CAutDirectMusicPerformance
  : public BaseImpPerf
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicPerformance(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT SetMasterTempo(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterTempo(AutDispatchDecodedParams *paddp);
	HRESULT SetMasterVolume(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterVolume(AutDispatchDecodedParams *paddp);
	HRESULT SetMasterGrooveLevel(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterGrooveLevel(AutDispatchDecodedParams *paddp);
	HRESULT SetMasterTranspose(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterTranspose(AutDispatchDecodedParams *paddp);
	HRESULT _Trace(AutDispatchDecodedParams *paddp);
	HRESULT Rand(AutDispatchDecodedParams *paddp);

	// Helpers
	HRESULT GetMasterParam(const GUID &guid, void *pParam, DWORD dwSize); // Calls GetGlobalParam, but returns S_OK if the param hasn't been set previously.

	// data
	SmartRef::ComPtr<IDirectMusicGraph> m_scomGraph;
	short m_nTranspose;
	short m_nVolume;
	long m_lRand;

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicPerformance> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autsegmentstate.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicSegmentState.
// IDispatch interface for IDirectMusicSegmentState.
// Unly usable via aggregation within an IDirectMusicSegmentState object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicSegmentState;
typedef CAutBaseImp<CAutDirectMusicSegmentState, IDirectMusicSegmentState, &IID_IDirectMusicSegmentState> BaseImpSegSt;

class CAutDirectMusicSegmentState
  : public BaseImpSegSt
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicSegmentState(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT IsPlaying(AutDispatchDecodedParams *paddp);
	HRESULT Stop(AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicSegmentState> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autsegmentstate.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicSegmentState.
//

#include "stdinc.h"
#include "autsegmentstate.h"
#include "activescript.h"
#include "autconstants.h"
#include <limits>

const WCHAR CAutDirectMusicSegmentState::ms_wszClassName[] = L"SegmentState";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_IsPlaying = 1;
const DISPID DMPDISP_Stop = 2;

const AutDispatchMethod CAutDirectMusicSegmentState::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_IsPlaying,					L"IsPlaying",
						ADT_Long,		true,	&IID_NULL,						// returns true if playing
						ADT_None },
		{ DMPDISP_Stop,							L"Stop",
						ADPARAM_NORETURN,
						ADT_Long,		true,	&IID_NULL,						// flags
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicSegmentState> CAutDirectMusicSegmentState::ms_Handlers[] =
	{
		{ DMPDISP_IsPlaying, IsPlaying },
		{ DMPDISP_Stop, Stop },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicSegmentState::CAutDirectMusicSegmentState(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpSegSt(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT
CAutDirectMusicSegmentState::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicSegmentState *pInst = new CAutDirectMusicSegmentState(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation

HRESULT
CAutDirectMusicSegmentState::IsPlaying(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (!plRet)
		return S_OK;

	IDirectMusicPerformance *pPerf = CActiveScriptManager::GetCurrentPerformanceWEAK();
	HRESULT hr = pPerf->IsPlaying(NULL, m_pITarget);
	*plRet = ::BoolForVB(hr == S_OK);
	return hr;
}

const FlagMapEntry gc_flagmapStop[] =
	{
		{ ScriptConstants::AtGrid,			DMUS_SEGF_GRID },
		{ ScriptConstants::AtBeat,			DMUS_SEGF_BEAT },
		{ ScriptConstants::AtMeasure,		DMUS_SEGF_MEASURE },
		{ ScriptConstants::AtImmediate,		DMUS_SEGF_DEFAULT }, // this flag gets flipped later
		{ 0 }
	};

HRESULT
CAutDirectMusicSegmentState::Stop(AutDispatchDecodedParams *paddp)
{
	LONG lFlags = paddp->params[0].lVal;
	DWORD dwFlags = MapFlags(lFlags, gc_flagmapStop);
	// Reverse the default flag because our flag means the opposite.  Default is the default and immediate is the flag.
	dwFlags ^= DMUS_SEGF_DEFAULT;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();

	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

	HRESULT hr = pPerformance->Stop(NULL, m_pITarget, i64IntendedStartTime, dwFlags | dwIntendedStartTimeFlags);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autperformance.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicPerformance.
//

#include "stdinc.h"
#include "autperformance.h"
#include <limits>
#include "dmusicf.h"

const WCHAR CAutDirectMusicPerformance::ms_wszClassName[] = L"Performance";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_SetMasterTempo = 1;
const DISPID DMPDISP_GetMasterTempo = 2;
const DISPID DMPDISP_SetMasterVolume = 3;
const DISPID DMPDISP_GetMasterVolume = 4;
const DISPID DMPDISP_SetMasterGrooveLevel = 5;
const DISPID DMPDISP_GetMasterGrooveLevel = 6;
const DISPID DMPDISP_SetMasterTranspose = 7;
const DISPID DMPDISP_GetMasterTranspose = 8;
const DISPID DMPDISP_Trace = 9;
const DISPID DMPDISP_Rand = 10;

const AutDispatchMethod CAutDirectMusicPerformance::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_SetMasterTempo,				L"SetMasterTempo",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// tempo!New value for master tempo scaling factor as a percentage.  For example, 50 would halve the tempo and 200 would double it.
						ADT_None },
				/// Calls IDirectMusicPerformance::SetGlobalParam(GUID_PerfMasterTempo, tempo / 100, sizeof(float)).
		{ DMPDISP_GetMasterTempo,				L"GetMasterTempo",
						ADT_Long,		true,	&IID_NULL,						// Current master tempo scaling factor as a percentage.
						ADT_None },
				/// Calls IDirectMusicPerformance::GetGlobalParam(GUID_PerfMasterTempo, X, sizeof(float)) and returns X * 100.
		{ DMPDISP_SetMasterVolume,	L"SetMasterVolume",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// volume!New value for master volume attenuation.
						ADT_Long,		true,	&IID_NULL,						// duration
						ADT_None },
				/// Calls IDirectMusicPerformance::SetGlobalParam(GUID_PerfMasterVolume, volume, sizeof(long)).
				/// Range is 100th of a dB.  0 is full volume.
		{ DMPDISP_GetMasterVolume,	L"GetMasterVolume",
						ADT_Long,		true,	&IID_NULL,						// Current value of master volume attenuation.
						ADT_None },
				/// Calls IDirectMusicPerformance::GetGlobalParam(GUID_PerfMasterVolume, X, sizeof(long)) and returns X.
		{ DMPDISP_SetMasterGrooveLevel,			L"SetMasterGrooveLevel",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// groove level!New value for the global groove level, which is added to the level in the command track.
						ADT_None },
		{ DMPDISP_GetMasterGrooveLevel,			L"GetMasterGrooveLevel",
						ADT_Long,		true,	&IID_NULL,						// Current value of the global groove level, which is added to the level in the command track.
						ADT_None },
		{ DMPDISP_SetMasterTranspose,			L"SetMasterTranspose",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// transpose!Number of semitones to transpose everything.
						ADT_None },
		{ DMPDISP_GetMasterTranspose,			L"GetMasterTranspose",
						ADT_Long,		true,	&IID_NULL,						// Current global transposition (number of semitones).
						ADT_None },
		{ DMPDISP_Trace,						L"Trace",
						ADPARAM_NORETURN,
						ADT_Bstr,		false,	&IID_NULL,						// string!text to output to testing log
						ADT_None },
				/// This allocates, stamps, and sends a DMUS_LYRIC_PMSG with the following fields:
				/// <ul>
				/// <li> dwPChannel = channel
				/// <li> dwVirtualTrackID = 0
				/// <li> dwGroupID = -1
				/// <li> mtTime = GetTime(X, 0) is called and X * 10000 is used
				/// <li> dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME
				/// <li> dwType = DMUS_PMSGT_SCRIPTLYRIC
				/// <li> wszString = string
				/// </ul>
				/// This is used to send text to a trace log for debugging purposes.  Less commonly, a script could be
				/// running in an application that listens and reacts to the script's trace output.
		{ DMPDISP_Rand,							L"Rand",
						ADT_Long,		true,	&IID_NULL,						// Returns a randomly-generated number
						ADT_Long,		false,	&IID_NULL,						// Max value--returned number will be between 1 and this max.  Cannot be zero or negative.
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicPerformance> CAutDirectMusicPerformance::ms_Handlers[] =
	{
		{ DMPDISP_SetMasterTempo, SetMasterTempo },
		{ DMPDISP_GetMasterTempo, GetMasterTempo },
		{ DMPDISP_SetMasterVolume, SetMasterVolume },
		{ DMPDISP_GetMasterVolume, GetMasterVolume },
		{ DMPDISP_SetMasterGrooveLevel, SetMasterGrooveLevel },
		{ DMPDISP_GetMasterGrooveLevel, GetMasterGrooveLevel },
		{ DMPDISP_SetMasterTranspose, SetMasterTranspose },
		{ DMPDISP_GetMasterTranspose, GetMasterTranspose },
		{ DMPDISP_Trace, _Trace },
		{ DMPDISP_Rand, Rand },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicPerformance::CAutDirectMusicPerformance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpPerf(pUnknownOuter, iid, ppv, phr),
	m_nTranspose(0),
	m_nVolume(0)
{
	// set the random seed used by the Rand method
	m_lRand = GetTickCount();

	*phr = m_pITarget->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&m_scomGraph));

	if (SUCCEEDED(*phr))
	{
		// Due to the aggregation contract, our object is wholely contained in the lifetime of
		// the outer object and we shouldn't hold any references to it.
		ULONG ulCheck = m_pITarget->Release();
		assert(ulCheck);
	}
}

HRESULT
CAutDirectMusicPerformance::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicPerformance *pInst = new CAutDirectMusicPerformance(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicPerformance::SetMasterTempo(AutDispatchDecodedParams *paddp)
{
	LONG lTempo = paddp->params[0].lVal;
	float fltTempo = ConvertToTempo(lTempo);
	if (fltTempo < DMUS_MASTERTEMPO_MIN)
		fltTempo = DMUS_MASTERTEMPO_MIN;
	else if (fltTempo > DMUS_MASTERTEMPO_MAX)
		fltTempo = DMUS_MASTERTEMPO_MAX;
	return m_pITarget->SetGlobalParam(GUID_PerfMasterTempo, &fltTempo, sizeof(float));
}

HRESULT
CAutDirectMusicPerformance::GetMasterTempo(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (!plRet)
		return S_OK;

	float fltTempo = 1; // default value is 1 (multiplicative identity)
	HRESULT hr = this->GetMasterParam(GUID_PerfMasterTempo, &fltTempo, sizeof(float));
	if (SUCCEEDED(hr))
		*plRet = ConvertFromTempo(fltTempo);
	return hr;
}

HRESULT
CAutDirectMusicPerformance::SetMasterVolume(AutDispatchDecodedParams *paddp)
{
	if (!m_scomGraph)
	{
		assert(false);
		return E_FAIL;
	}

	LONG lVol = paddp->params[0].lVal;
	LONG lDuration = paddp->params[1].lVal;

	return SendVolumePMsg(lVol, lDuration, DMUS_PCHANNEL_BROADCAST_PERFORMANCE, m_scomGraph, m_pITarget, &m_nVolume);
}

HRESULT
CAutDirectMusicPerformance::GetMasterVolume(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (plRet)
		*plRet = m_nVolume;
	return S_OK;
}

HRESULT
CAutDirectMusicPerformance::SetMasterGrooveLevel(AutDispatchDecodedParams *paddp)
{
	LONG lGroove = paddp->params[0].lVal;
	char chGroove = ClipLongRangeToType<char>(lGroove, char());
	return m_pITarget->SetGlobalParam(GUID_PerfMasterGrooveLevel, reinterpret_cast<void*>(&chGroove), sizeof(char));
}

HRESULT
CAutDirectMusicPerformance::GetMasterGrooveLevel(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (!plRet)
		return S_OK;

	char chGroove = 0; // default value is 0 (additive identity)
	HRESULT hr = this->GetMasterParam(GUID_PerfMasterGrooveLevel, reinterpret_cast<void*>(&chGroove), sizeof(char));
	if (SUCCEEDED(hr))
		*plRet = chGroove;
	return hr;
}

HRESULT
CAutDirectMusicPerformance::SetMasterTranspose(AutDispatchDecodedParams *paddp)
{
	LONG lTranspose = paddp->params[0].lVal;
	short nTranspose = ClipLongRangeToType<short>(lTranspose, short());

	SmartRef::PMsg<DMUS_TRANSPOSE_PMSG> pmsg(m_pITarget);
	HRESULT hr = pmsg.hr();
	if FAILED(hr)
		return hr;

	// Generic PMSG stuff
	hr = m_pITarget->GetTime(&pmsg.p->rtTime, NULL);
	if (FAILED(hr))
		return hr;
	pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
	pmsg.p->dwType = DMUS_PMSGT_TRANSPOSE;
	pmsg.p->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
	pmsg.p->dwVirtualTrackID = 0;
	pmsg.p->dwGroupID = -1;

	// Transpose PMSG stuff
	pmsg.p->nTranspose = nTranspose;
	pmsg.p->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

	pmsg.StampAndSend(m_scomGraph);
	hr = pmsg.hr();
	if (SUCCEEDED(hr))
		m_nTranspose = nTranspose;
	return hr;
}

HRESULT
CAutDirectMusicPerformance::GetMasterTranspose(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (plRet)
		*plRet = m_nTranspose;
	return S_OK;
}

HRESULT
CAutDirectMusicPerformance::_Trace(AutDispatchDecodedParams *paddp)
{
	BSTR bstr = paddp->params[0].bstrVal;
	int cwch = wcslen(bstr);

	SmartRef::PMsg<DMUS_LYRIC_PMSG> pmsg(m_pITarget, cwch * sizeof(WCHAR));
	HRESULT hr = pmsg.hr();
	if (FAILED(hr))
		return hr;

	// Generic PMSG stuff
	hr = m_pITarget->GetTime(&pmsg.p->rtTime, NULL);
	if (FAILED(hr))
		return hr;
	pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
	pmsg.p->dwType = DMUS_PMSGT_SCRIPTLYRIC;
	pmsg.p->dwPChannel = 0;
	pmsg.p->dwVirtualTrackID = 0;
	pmsg.p->dwGroupID = -1;

	// Lyric PMSG stuff
	wcscpy(pmsg.p->wszString, bstr);

	pmsg.StampAndSend(m_scomGraph);
	return pmsg.hr();
}

HRESULT
CAutDirectMusicPerformance::Rand(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	LONG lMax = paddp->params[0].lVal;

	if (lMax < 1 || lMax > 0x7fff)
		return E_INVALIDARG;

	// Use random number generation lifted from the standard library's rand.c.  We don't just
	// use the rand function because the multithreaded library has a per-thread random chain,
	// but this function is called from various threads and it would be difficult to manage
	// getting them seeded.  Generates pseudo-random numbers 0 through 32767.
	long lRand = ((m_lRand = m_lRand * 214013L + 2531011L) >> 16) & 0x7fff;

	if (plRet)
		*plRet = lRand % lMax + 1; // trim to the requested range [1,lMax]
	return S_OK;
}

HRESULT
CAutDirectMusicPerformance::GetMasterParam(const GUID &guid, void *pParam, DWORD dwSize)
{
	HRESULT hr = m_pITarget->GetGlobalParam(guid, pParam, dwSize);
	if (SUCCEEDED(hr) || hr == E_INVALIDARG) // E_INVALIDARG is the performance's polite way of telling us the param hasn't been set yet
		return S_OK;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\authelper.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper utilities for implementing automation interfaces.
// Note that autbaseimp.h makes use of these utilities.  If you inherit from
//    CAutBaseImp then this is all implementated for you and you probably won't
//    need to use this file directly.
//

#pragma once

#include <limits>

//////////////////////////////////////////////////////////////////////
// Aggregation controlling unknown

// Class that implements the controlling unknown for aggregation.
// The interface should be returned only from CoCreate.
// This object will keep the reference count and call Destroy on its parent when 0.
//    The parent should then delete the CAutUnknown and itself.
// QI only returns IUnknown and IDispatch from the parent object.
class CAutUnknown : public IUnknown
{
public:
	// Virtual base class.  Inherit from CAutUnknown::CAutUnknownParent if you want to use an object with CAutUnknown.
	class CAutUnknownParent
	{
	public:
		virtual void Destroy() = 0;
	};

	CAutUnknown();
	// Call Init immediately.  The parent passes pointers to itself for both params.
	// I didn't put this on the constructor because VC warns about using 'this' in
	//    a member initializer list.
	void Init(CAutUnknownParent *pParent, IDispatch *pDispatch);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

private:
	// Data
	long m_cRef;
	CAutUnknownParent *m_pParent;
	IDispatch *m_pDispatch;
};

//////////////////////////////////////////////////////////////////////
// IDispatch implemented from type table

// Max params to any method -- increase this as needed
const int g_cDispatchMaxParams = 5;

// Parameters

enum AutDispatchType { ADT_None, ADT_Long, ADT_Interface, ADT_Bstr };

struct AutDispatchParam
{
	AutDispatchType adt;
	bool fOptional; // not relevant for return parameters
	const IID *piid; // only relevant if ADT_INTERFACE: specifies the IID of the desired interface (ignored for return parameters)
};

#define ADPARAM_NORETURN ADT_None, false, &IID_NULL

// Methods

struct AutDispatchMethod
{
	DISPID dispid;
	const WCHAR *pwszName;
	AutDispatchParam adpReturn;
	AutDispatchParam rgadpParams[g_cDispatchMaxParams]; // terminate with ADT_NONE for last param
};
// terminate an array of methods with dispid DISPID_UNKNOWN

// Decoded parameters -- read (write for return) void * as pointer to type specified in methods

union AutDispatchDecodedParam
{
	LONG lVal;		// ADT_Long
	void *iVal;		// ADT_Interface (cast to the interface specified by piid)
	BSTR bstrVal;	// ADT_Bstr
};

struct AutDispatchDecodedParams
{
	void *pvReturn; // set to NULL by AutDispatchInvokeDecode if no return specified or no return requested by caller, otherwise set to location to write return
	AutDispatchDecodedParam params[g_cDispatchMaxParams];
};

// Helper functions

HRESULT AutDispatchGetIDsOfNames(
			const AutDispatchMethod *pMethods,
			REFIID riid,
			LPOLESTR __RPC_FAR *rgszNames,
			UINT cNames,
			LCID lcid,
			DISPID __RPC_FAR *rgDispId);

HRESULT AutDispatchInvokeDecode(
			const AutDispatchMethod *pMethods,
			AutDispatchDecodedParams *pDecodedParams,
			DISPID dispIdMember,
			REFIID riid,
			LCID lcid,
			WORD wFlags,
			DISPPARAMS __RPC_FAR *pDispParams,
			VARIANT __RPC_FAR *pVarResult,
			UINT __RPC_FAR *puArgErr,
			const WCHAR *pwszTraceTargetType,
			IUnknown *punkTraceTargetObject);

void AutDispatchInvokeFree(
		const AutDispatchMethod *pMethods,
		AutDispatchDecodedParams *pDecodedParams,
		DISPID dispIdMember,
		REFIID riid);

HRESULT AutDispatchHrToException(
		const AutDispatchMethod *pMethods,
		DISPID dispIdMember,
		REFIID riid,
		HRESULT hr,
		EXCEPINFO __RPC_FAR *pExcepInfo);

// Implementation of IDispatch for the standard Load method on objects.
// Dummy implementation--does nothing.

// Assign Load a dispid that probably won't conflict with the wrapped object's methods.
// Probably it doesn't matter if two methods have the same dispid, but theoretically some scripting engine could
// be weirded out by that and hide a method with the same dispid that is exposed after the real object is loaded.
const DISPID g_dispidLoad = 10000000;

// Return S_OK and the dispid if this is a call to load.
HRESULT AutLoadDispatchGetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);

// Returns S_OK if this is a call to load.
HRESULT AutLoadDispatchInvoke(
		bool *pfUseOleAut,
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

//////////////////////////////////////////////////////////////////////
// Miscellaneous little things

inline LONG ClipLongRange(LONG lVal, LONG lMin, LONG lMax) { return lVal < lMin
																? lMin
																: (lVal > lMax ? lMax : lVal); }

// Trim the range of a LONG to the range of another data type.
//  compiler bug? need an extra unused parameter of the template type
template<class T>
LONG ClipLongRangeToType(LONG lVal, T t) { return ClipLongRange(lVal, std::numeric_limits<T>::min(), std::numeric_limits<T>::max()); }

const UINT g_uiRefTimePerMillisecond = 10000;

// Conversion between tempo normally represented in floating point and integers used by
// scripts that may not handle floating point numbers.

// 100 corresponds to 1 (no change), 1 corresponds to .01 (1/100th as fast), 10000 corresponds to 100 (100X as fast)
const float g_fltTempoScale = 100.0;

inline float
ConvertToTempo(LONG lTempo)
{
	return lTempo / g_fltTempoScale;
}

inline LONG
ConvertFromTempo(double dblTempo)
{
	LONG lTempo = static_cast<LONG>(dblTempo * g_fltTempoScale + .5);
	return lTempo ? lTempo : 1;
}

// Returns a proper VB boolean value (0 for false, -1 for true)
inline LONG
BoolForVB(bool f) { return f ? VARIANT_TRUE : VARIANT_FALSE; }

// Convert from one set of flags into another
struct FlagMapEntry
{
	LONG lSrc;
	DWORD dwDest;
};
DWORD MapFlags(LONG lFlags, const FlagMapEntry *pfm);

HRESULT SendVolumePMsg(LONG lVolume, LONG lDuration, DWORD dwPChannel, IDirectMusicGraph *pGraph, IDirectMusicPerformance *pPerf, short *pnNewVolume);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autsong.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicSong.
//

#include "stdinc.h"
#include "autsong.h"
#include "activescript.h"

const WCHAR CAutDirectMusicSong::ms_wszClassName[] = L"Song";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_Load = 1;
const DISPID DMPDISP_Recompose = 2;
const DISPID DMPDISP_Play = 3;
const DISPID DMPDISP_GetSegment = 4;
const DISPID DMPDISP_Stop = 5;
const DISPID DMPDISP_DownloadSoundData = 6;
const DISPID DMPDISP_UnloadSoundData = 7;

const AutDispatchMethod CAutDirectMusicSong::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_Load,							L"Load",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_Recompose,					L"Recompose",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_Play,							L"Play",
						ADT_Interface,	true,	&IID_IUnknown,					// returned segment state
						ADT_Bstr,		true,	&IID_NULL,						// name of segment to play
						ADT_None },
		{ DMPDISP_GetSegment,					L"GetSegment",
						ADT_Interface,	true,	&IID_IUnknown,					// returned segment
						ADT_Bstr,		true,	&IID_NULL,						// name of segment to retrieve
						ADT_None },
		{ DMPDISP_Stop,							L"Stop",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_DownloadSoundData,			L"DownloadSoundData",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_UnloadSoundData,				L"UnloadSoundData",
						ADPARAM_NORETURN,
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicSong> CAutDirectMusicSong::ms_Handlers[] =
	{
		{ DMPDISP_Load, Load },
		{ DMPDISP_Recompose, Recompose },
		{ DMPDISP_Play, Play },
		{ DMPDISP_GetSegment, GetSegment },
		{ DMPDISP_Stop, Stop },
		{ DMPDISP_DownloadSoundData, DownloadSoundData },
		{ DMPDISP_UnloadSoundData, UnloadSoundData },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicSong::CAutDirectMusicSong(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpSong(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT
CAutDirectMusicSong::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicSong *pInst = new CAutDirectMusicSong(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicSong::Load(AutDispatchDecodedParams *paddp)
{
	// Loading is actually implemented generically by container items.
	// If we're here, we're already loaded and don't need to do anything.
	return S_OK;
}

HRESULT
CAutDirectMusicSong::Recompose(AutDispatchDecodedParams *paddp)
{
	return m_pITarget->Compose();
}

HRESULT
CAutDirectMusicSong::Play(AutDispatchDecodedParams *paddp)
{
	IDirectMusicSegmentState **ppSegSt = reinterpret_cast<IDirectMusicSegmentState **>(paddp->pvReturn);
	BSTR bstrSegName = paddp->params[0].bstrVal;

	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();

	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

	hr = pPerformance->PlaySegmentEx(
							m_pITarget,
							bstrSegName,
							NULL,
							DMUS_SEGF_DEFAULT | DMUS_SEGF_AUTOTRANSITION | dwIntendedStartTimeFlags,
							i64IntendedStartTime,
							ppSegSt,
							NULL,
							NULL);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CAutDirectMusicSong::GetSegment(AutDispatchDecodedParams *paddp)
{
	IDirectMusicSegment **ppSeg = reinterpret_cast<IDirectMusicSegment **>(paddp->pvReturn);
	BSTR bstrSegName = paddp->params[0].bstrVal;

	HRESULT hr = S_OK;
	hr = m_pITarget->GetSegment(bstrSegName, ppSeg);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CAutDirectMusicSong::Stop(AutDispatchDecodedParams *paddp)
{
	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();

	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

	hr = pPerformance->StopEx(m_pITarget, i64IntendedStartTime, DMUS_SEGF_DEFAULT | dwIntendedStartTimeFlags);
	return hr;
}

HRESULT
CAutDirectMusicSong::DownloadSoundData(AutDispatchDecodedParams *paddp)
{
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
	return m_pITarget->Download(pPerformance);
}

HRESULT
CAutDirectMusicSong::UnloadSoundData(AutDispatchDecodedParams *paddp)
{
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
	return m_pITarget->Unload(pPerformance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autsegment.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicSegment.
//

#include "stdinc.h"
#include "autsegment.h"
#include "activescript.h"
#include "autconstants.h"
#include <limits>

const WCHAR CAutDirectMusicSegment::ms_wszClassName[] = L"Segment";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_Load = 1;
const DISPID DMPDISP_Play = 2;
const DISPID DMPDISP_Stop = 3;
const DISPID DMPDISP_DownloadSoundData = 4;
const DISPID DMPDISP_UnloadSoundData = 5;
const DISPID DMPDISP_Recompose = 6;

const AutDispatchMethod CAutDirectMusicSegment::ms_Methods[] =
    {
        // dispid,              name,
            // return:  type,   (opt),  (iid),
            // parm 1:  type,   opt,    iid,
            // parm 2:  type,   opt,    iid,
            // ...
            // ADT_None
        { DMPDISP_Load,                         L"Load",
                        ADPARAM_NORETURN,
                        ADT_None },
        { DMPDISP_Play,                         L"Play",
                        ADT_Interface,  true,   &IID_IUnknown,                  // returned segment state
                        ADT_Long,       true,   &IID_NULL,                      // flags
                        ADT_Interface,  true,   &IID_IDirectMusicAudioPath,     // audio path
                        ADT_Interface,  true,   &IID_IDirectMusicSegment,       // template segment for transition
                        ADT_Interface,  true,   &IID_IDirectMusicSegmentState,  // playing segment to replace
                        ADT_None },
        { DMPDISP_Stop,                         L"Stop",
                        ADPARAM_NORETURN,
                        ADT_Long,       true,   &IID_NULL,                      // flags
                        ADT_None },
        { DMPDISP_DownloadSoundData,                    L"DownloadSoundData",
                        ADPARAM_NORETURN,
                        ADT_Interface,  true,   &IID_IDirectMusicAudioPath,     // audio path
                        ADT_None },
        { DMPDISP_UnloadSoundData,                  L"UnloadSoundData",
                        ADPARAM_NORETURN,
                        ADT_Interface,  true,   &IID_IDirectMusicAudioPath,     // audio path
                        ADT_None },
        { DMPDISP_Recompose,                    L"Recompose",
                        ADPARAM_NORETURN,
                        ADT_None },
        { DISPID_UNKNOWN }
    };

const DispatchHandlerEntry<CAutDirectMusicSegment> CAutDirectMusicSegment::ms_Handlers[] =
    {
        { DMPDISP_Load, Load },
        { DMPDISP_Play, Play },
        { DMPDISP_Stop, Stop },
        { DMPDISP_DownloadSoundData, DownloadSoundData },
        { DMPDISP_UnloadSoundData, UnloadSoundData },
        { DMPDISP_Recompose, Recompose },
        { DISPID_UNKNOWN }
    };

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicSegment::CAutDirectMusicSegment(
        IUnknown* pUnknownOuter,
        const IID& iid,
        void** ppv,
        HRESULT *phr)
  : BaseImpSegment(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT CAutDirectMusicSegment::CreateInstance(
        IUnknown* pUnknownOuter,
        const IID& iid,
        void** ppv)
{
    HRESULT hr = S_OK;
    CAutDirectMusicSegment *pInst = new CAutDirectMusicSegment(pUnknownOuter, iid, ppv, &hr);
    if (FAILED(hr))
    {
        delete pInst;
        return hr;
    }
    if (pInst == NULL)
        return E_OUTOFMEMORY;
    return hr;
}

//////////////////////////////////////////////////////////////////////
// Private Functions

HRESULT
CAutDirectMusicSegment::Load(AutDispatchDecodedParams *paddp)
{
    // Loading is actually implemented generically by container items.
    // If we're here, we're already loaded and don't need to do anything.
    return S_OK;
}

const FlagMapEntry gc_flagmapPlay[] =
    {
        { ScriptConstants::IsSecondary,     DMUS_SEGF_SECONDARY },
        { ScriptConstants::IsControl,       DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY },
        { ScriptConstants::AtFinish,        DMUS_SEGF_QUEUE },
        { ScriptConstants::AtGrid,          DMUS_SEGF_GRID },
        { ScriptConstants::AtBeat,          DMUS_SEGF_BEAT },
        { ScriptConstants::AtMeasure,       DMUS_SEGF_MEASURE },
        { ScriptConstants::AtMarker,        DMUS_SEGF_MARKER },
        { ScriptConstants::AtImmediate,     DMUS_SEGF_DEFAULT }, // this flag gets flipped later
        { ScriptConstants::AlignToBar,      DMUS_SEGF_ALIGN | DMUS_SEGF_MEASURE | DMUS_SEGF_VALID_START_BEAT },
        { ScriptConstants::AlignToBeat,     DMUS_SEGF_ALIGN | DMUS_SEGF_BEAT | DMUS_SEGF_VALID_START_GRID },
        { ScriptConstants::AlignToSegment,  DMUS_SEGF_ALIGN | DMUS_SEGF_SEGMENTEND | DMUS_SEGF_VALID_START_MEASURE },
        { ScriptConstants::NoCutoff,        DMUS_SEGF_NOINVALIDATE },
        { 0 }
    };

const FlagMapEntry gc_flagmapPlayTransCommand[] =
    {
        { ScriptConstants::PlayFill,        DMUS_COMMANDT_FILL },
        { ScriptConstants::PlayIntro,       DMUS_COMMANDT_INTRO },
        { ScriptConstants::PlayBreak,       DMUS_COMMANDT_BREAK },
        { ScriptConstants::PlayEnd,         DMUS_COMMANDT_END },
        { ScriptConstants::PlayEndAndIntro, DMUS_COMMANDT_ENDANDINTRO },
        { 0 }
    };

const FlagMapEntry gc_flagmapPlayTransFlags[] =
    {
        { ScriptConstants::AtFinish,        DMUS_COMPOSEF_SEGMENTEND },
        { ScriptConstants::AtGrid,          DMUS_COMPOSEF_GRID },
        { ScriptConstants::AtBeat,          DMUS_COMPOSEF_BEAT },
        { ScriptConstants::AtMeasure,       DMUS_COMPOSEF_MEASURE },
        { ScriptConstants::AtMarker,        DMUS_COMPOSEF_MARKER },
        { ScriptConstants::AtImmediate,     DMUS_COMPOSEF_IMMEDIATE },
        { ScriptConstants::AlignToBar,      DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_MEASURE },
        { ScriptConstants::AlignToBeat,     DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_BEAT },
        { ScriptConstants::AlignToSegment,  DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_SEGMENTEND },
        { ScriptConstants::PlayModulate,    DMUS_COMPOSEF_MODULATE },
        { 0 }
    };

HRESULT
CAutDirectMusicSegment::Play(AutDispatchDecodedParams *paddp)
{
    IDirectMusicSegmentState **ppSegSt = reinterpret_cast<IDirectMusicSegmentState **>(paddp->pvReturn);
    LONG lFlags = paddp->params[0].lVal;
    IDirectMusicAudioPath *pAudioPath = reinterpret_cast<IDirectMusicAudioPath*>(paddp->params[1].iVal);
    IDirectMusicSegment *pTransitionSegment = reinterpret_cast<IDirectMusicSegment*>(paddp->params[2].iVal);
    IDirectMusicSegmentState *pFromSegmentState = reinterpret_cast<IDirectMusicSegmentState*>(paddp->params[3].iVal);

    const LONG lFlagsNonPrimary = ScriptConstants::IsSecondary | ScriptConstants::IsControl;
    const LONG lFlagsTransition = ScriptConstants::PlayFill | ScriptConstants::PlayIntro | ScriptConstants::PlayBreak | ScriptConstants::PlayEnd | ScriptConstants::PlayEndAndIntro;
    if ((lFlags & lFlagsNonPrimary) && (lFlags & lFlagsTransition))
    {
        // Transitions may only be used when playing primary segments.  Return a runtime error.
        Trace(1, "Error: Play called with IsSecondary or IsControl flag as well as a transition flag (PlayFill, PlayIntro, etc..). Transitions can only be used with primary segments.\n");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
    if (lFlags & lFlagsTransition)
    {
        // do a transition
        DWORD dwCommand = MapFlags(lFlags, gc_flagmapPlayTransCommand);
        assert(dwCommand < std::numeric_limits<WORD>::max()); // the command parameter is a WORD. this just checks that there's nothing truncated.
        DWORD dwFlags = MapFlags(lFlags, gc_flagmapPlayTransFlags);
        // Always play the entire transition instead of doing the old (slightly strange) 1 bar / long stuff.
        // Also, always use an embedded audio path if one exists.
        dwFlags |= (DMUS_COMPOSEF_ENTIRE_TRANSITION | DMUS_COMPOSEF_USE_AUDIOPATH);
        IDirectMusicComposer8 *pComposer = CActiveScriptManager::GetComposerWEAK();
        hr = pComposer->AutoTransition(pPerformance, m_pITarget, dwCommand, dwFlags, NULL, NULL, ppSegSt, NULL);
    }
    else
    {
        DWORD dwFlags = MapFlags(lFlags, gc_flagmapPlay);
        // Reverse the default flag because our flag means the opposite.  Default is the default and immediate is the flag.
        dwFlags ^= DMUS_SEGF_DEFAULT;

        if (pTransitionSegment)
            dwFlags |= DMUS_SEGF_AUTOTRANSITION;

        __int64 i64IntendedStartTime;
        DWORD dwIntendedStartTimeFlags;
        CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

        hr = pPerformance->PlaySegmentEx(m_pITarget, 0, pTransitionSegment, dwFlags | dwIntendedStartTimeFlags, i64IntendedStartTime, ppSegSt, pFromSegmentState, pAudioPath);
    }
    if (FAILED(hr))
        return hr;

    return S_OK;
}

const FlagMapEntry gc_flagmapStop[] =
    {
        { ScriptConstants::AtGrid,          DMUS_SEGF_GRID },
        { ScriptConstants::AtBeat,          DMUS_SEGF_BEAT },
        { ScriptConstants::AtMeasure,       DMUS_SEGF_MEASURE },
        { ScriptConstants::AtMarker,        DMUS_SEGF_MARKER },
        { ScriptConstants::AtImmediate,     DMUS_SEGF_DEFAULT }, // this flag gets flipped later
        { 0 }
    };

const FlagMapEntry gc_flagmapStopTransFlags[] =
    {
        { ScriptConstants::AtGrid,          DMUS_COMPOSEF_GRID },
        { ScriptConstants::AtBeat,          DMUS_COMPOSEF_BEAT },
        { ScriptConstants::AtMeasure,       DMUS_COMPOSEF_MEASURE },
        { ScriptConstants::AtMarker,        DMUS_COMPOSEF_MARKER },
        { ScriptConstants::AtImmediate,     DMUS_COMPOSEF_IMMEDIATE },
        { 0 }
    };

HRESULT
CAutDirectMusicSegment::Stop(AutDispatchDecodedParams *paddp)
{
    LONG lFlags = paddp->params[0].lVal;

    HRESULT hr = S_OK;
    IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
    if (lFlags & ScriptConstants::PlayEnd)
    {
        // do a transition to silence
        DWORD dwFlags = MapFlags(lFlags, gc_flagmapStopTransFlags);
        // Always play the entire transition instead of doing the old (slightly strange) 1 bar / long stuff.
        // Also, always use an embedded audio path if one exists.
        dwFlags |= (DMUS_COMPOSEF_ENTIRE_TRANSITION | DMUS_COMPOSEF_USE_AUDIOPATH);
        IDirectMusicComposer8 *pComposer = CActiveScriptManager::GetComposerWEAK();
        hr = pComposer->AutoTransition(pPerformance, NULL, DMUS_COMMANDT_END, dwFlags, NULL, NULL, NULL, NULL);
    }
    else
    {
        DWORD dwFlags = MapFlags(lFlags, gc_flagmapStop);
        // Reverse the default flag because our flag means the opposite.  Default is the default and immediate is the flag.
        dwFlags ^= DMUS_SEGF_DEFAULT;

        __int64 i64IntendedStartTime;
        DWORD dwIntendedStartTimeFlags;
        CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

        hr = pPerformance->Stop(m_pITarget, NULL, i64IntendedStartTime, dwFlags | dwIntendedStartTimeFlags);
    }
    return hr;
}

HRESULT
CAutDirectMusicSegment::Recompose(AutDispatchDecodedParams *paddp)
{
    IDirectMusicComposer8 *pComposer = CActiveScriptManager::GetComposerWEAK();
    IDirectMusicComposer8P *pComposerP = NULL;
    HRESULT hr = pComposer->QueryInterface(IID_IDirectMusicComposer8P, (void**)&pComposerP);
    if (SUCCEEDED(hr))
    {
        hr = pComposerP->ComposeSegmentFromTemplateEx(NULL, m_pITarget, 0, 0, NULL, NULL);
        pComposerP->Release();
    }
    return hr;
}

HRESULT
CAutDirectMusicSegment::DownloadOrUnload(bool fDownload, AutDispatchDecodedParams *paddp)
{
    IUnknown *pAudioPathOrPerf = reinterpret_cast<IDirectMusicAudioPath*>(paddp->params[0].iVal);
    if (!pAudioPathOrPerf)
        pAudioPathOrPerf = CActiveScriptManager::GetCurrentPerformanceWEAK();

    return fDownload
                ? m_pITarget->Download(pAudioPathOrPerf)
                : m_pITarget->Unload(pAudioPathOrPerf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\containerdisp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CContainerDispatch.
//

#pragma once

#include "smartref.h"
#include "unkhelp.h"
#include "dmusicp.h"

class CContainerItemDispatch
  : public IDispatch,
	public ComSingleInterface
{
public:
	CContainerItemDispatch(IDirectMusicLoader *pLoader, const WCHAR *wszAlias, const DMUS_OBJECTDESC &desc, bool fPreload, bool fAutodownload, HRESULT *phr);
	~CContainerItemDispatch();
	const WCHAR *Alias() { return m_wstrAlias; }
	IDispatch *Item() { if (m_pDispLoadedItem) return m_pDispLoadedItem; return this; } // returns the contained item when loaded, otherwise itself so Load can be called

	// IUnknown
	ComSingleInterfaceUnknownMethods(IDispatch)

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { return E_NOTIMPL; }
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo) { return E_NOTIMPL; }
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

	// If it is a segment or song, download it if needed.
	// If it is a script, init it.
	// If it is a song, compose it.
	enum InitWithPerfomanceFailureType { IWP_Success, IWP_DownloadFailed, IWP_ScriptInitFailed };
	HRESULT InitWithPerformance(IDirectMusicPerformance *pPerf, InitWithPerfomanceFailureType *peFailureType);

private:
	void ReleaseLoader();
	HRESULT Load(bool fDynamicLoad);
	HRESULT DownloadOrUnload(bool fDownload, IDirectMusicPerformance *pPerf);

	SmartRef::WString m_wstrAlias;
	IDirectMusicLoader *m_pLoader;		// note: use AddRefP/ReleaseP
	IDirectMusicLoader8P *m_pLoader8P;	// note: use AddRefP/ReleaseP
	DMUS_OBJECTDESC m_desc;

	bool m_fLoaded;
	IDispatch *m_pDispLoadedItem;

	bool m_fAutodownload;
	IDirectMusicPerformance *m_pPerfForUnload;
};

class CContainerDispatch
{
public:
	CContainerDispatch(IDirectMusicContainer *pContainer, IDirectMusicLoader *pLoader, DWORD dwScriptFlags, HRESULT *phr);
	~CContainerDispatch();
	HRESULT OnScriptInit(IDirectMusicPerformance *pPerf); // gives the container a chance to do auto downloading/composing during script initialization

	HRESULT GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	HRESULT Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

	// For use by the script object
	HRESULT EnumItem(DWORD dwIndex, WCHAR *pwszName);
	HRESULT GetVariableObject(WCHAR *pwszVariableName, IUnknown **ppunkValue);

private:
	SmartRef::Vector<CContainerItemDispatch *> m_vecItems;
	bool m_fDownloadOnInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\autsong.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicSong.
// IDispatch interface for IDirectMusicSong.
// Unly usable via aggregation within an IDirectMusicSong object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicSong;
typedef CAutBaseImp<CAutDirectMusicSong, IDirectMusicSong, &IID_IDirectMusicSong> BaseImpSong;

class CAutDirectMusicSong
  : public BaseImpSong
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicSong(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT Load(AutDispatchDecodedParams *paddp);
	HRESULT Recompose(AutDispatchDecodedParams *paddp);
	HRESULT Play(AutDispatchDecodedParams *paddp);
	HRESULT GetSegment(AutDispatchDecodedParams *paddp);
	HRESULT Stop(AutDispatchDecodedParams *paddp);
	HRESULT DownloadSoundData(AutDispatchDecodedParams *paddp);
	HRESULT UnloadSoundData(AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicSong> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\dll.h ===
// Copyright (c) 1999 Microsoft Corporation
// dll.h
//
// Class factory
//

#pragma once

void LockModule(bool fLock);
long *GetModuleLockCounter();

typedef HRESULT (PFN_CreateInstance)(IUnknown *pUnkOuter, const IID &iid, void **ppv);

class CDMScriptingFactory : public IClassFactory
{
public:
    // Constructor
    CDMScriptingFactory(PFN_CreateInstance *pfnCreate) : m_cRef(0), m_pfnCreate(pfnCreate) { assert(m_pfnCreate); }

    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock);

private:
    long m_cRef;
	PFN_CreateInstance *m_pfnCreate;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\dmscript.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CDirectMusicScript.
//

// CDirectMusicScript is the script object.  A script object is loaded from a script file
// using the loader's GetObject method.  A script file contains source code in VBScript
// or another activeX scripting language.  Once loaded, the script object can be used
// to set and get the value of variables and to call routines inside the script.  The
// script routines can in turn call DirectMusic's automation model (or any other
// IDispatch-based API's).
//
// This allows programmers to separate the application's core C++ code from the
// API calls that to manipulate the musical score.  The application core loads
// scripts and calls routines at the appropriate times.  Sound designers implement
// those routines using any activeX scripting language.  The resulting scripts can
// be modified and auditioned without changing any code in the core application and
// without recompiling.

#pragma once
#include "scriptthread.h"
#include "containerdisp.h"
#include "dmusicf.h"
#include "..\shared\dmusicp.h"
#include "trackshared.h"

class CGlobalDispatch;

class CDirectMusicScript
  : public IDirectMusicScript,
	public IDirectMusicScriptPrivate,
	public IPersistStream,
	public IDirectMusicObject,
	public IDirectMusicObjectP,
	public IDispatch
{
friend class CGlobalDispatch;

public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions (only Load is implemented)
	STDMETHOD(GetClassID)(CLSID* pClassID) {return E_NOTIMPL;}
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream);
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject
	STDMETHOD(GetDescriptor)(LPDMUS_OBJECTDESC pDesc);
	STDMETHOD(SetDescriptor)(LPDMUS_OBJECTDESC pDesc);
	STDMETHOD(ParseDescriptor)(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

	// IDirectMusicScript
	STDMETHOD(Init)(IDirectMusicPerformance *pPerformance, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(CallRoutine)(WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableVariant)(WCHAR *pwszVariableName, VARIANT varValue, BOOL fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableVariant)(WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableNumber)(WCHAR *pwszVariableName, LONG lValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableNumber)(WCHAR *pwszVariableName, LONG *plValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableObject)(WCHAR *pwszVariableName, IUnknown *punkValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableObject)(WCHAR *pwszVariableName, REFIID riid, LPVOID FAR *ppv, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(EnumRoutine)(DWORD dwIndex, WCHAR *pwszName);
	STDMETHOD(EnumVariable)(DWORD dwIndex, WCHAR *pwszName);

	// IDirectMusicScriptPrivate
	STDMETHOD(ScriptTrackCallRoutine)(
		WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags);

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

	// Methods that allow CActiveScriptManager access to private script interfaces
	IDispatch *GetGlobalDispatch();
	IDirectMusicPerformance8 *GetPerformance() { assert(m_pPerformance8); return m_pPerformance8; }
	IDirectMusicLoader8P *GetLoader8P() { return m_pLoader8P; }
	IDirectMusicComposer8 *GetComposer() { return m_pComposer8; }
	const WCHAR *GetFilename() { return m_info.wstrFilename; }

private:
	// Methods

	CDirectMusicScript();
	void ReleaseObjects();

	// Data

	CRITICAL_SECTION m_CriticalSection;
	bool m_fCriticalSectionInitialized;

	long m_cRef;
	bool m_fZombie;

	IDirectMusicPerformance8 *m_pPerformance8;
	IDirectMusicLoader8P *m_pLoader8P; // NULL if loader doesn't support private interface. Use AddRefP/ReleaseP.
	IDispatch *m_pDispPerformance;
	IDirectMusicComposer8 *m_pComposer8;

	// Standard object info
	struct HeaderInfo
	{
		// Descriptor info
		SmartRef::RiffIter::ObjectInfo oinfo;
		SmartRef::WString wstrFilename;
		bool fLoaded;
	} m_info;

	// Properties of the script
	DMUS_IO_SCRIPT_HEADER m_iohead;
	SmartRef::WString m_wstrLanguage;
	DMUS_VERSION m_vDirectMusicVersion;

	// Active Scripting
	bool m_fUseOleAut;
	ScriptManager *m_pScriptManager; // Reference-counted

	CContainerDispatch *m_pContainerDispatch;
	CGlobalDispatch *m_pGlobalDispatch;
	bool m_fInitError;
	DMUS_SCRIPT_ERRORINFO m_InitErrorInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\containerdisp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CContainerDispatch.
//

#include "stdinc.h"
#include "containerdisp.h"
#include "oleaut.h"
#include "dmusicf.h"
#include "activescript.h"
#include "authelper.h"
//#include "..\shared\dmusicp.h"

//////////////////////////////////////////////////////////////////////
// CContainerItemDispatch

CContainerItemDispatch::CContainerItemDispatch(
		IDirectMusicLoader *pLoader,
		const WCHAR *wszAlias,
		const DMUS_OBJECTDESC &desc,
		bool fPreload,
		bool fAutodownload,
		HRESULT *phr)
  : m_pLoader(pLoader),
	m_pLoader8P(NULL),
	m_wstrAlias(wszAlias),
	m_desc(desc),
	m_fLoaded(false),
	m_pDispLoadedItem(NULL),
	m_fAutodownload(fAutodownload),
	m_pPerfForUnload(NULL)
{
	assert(pLoader && phr);
	*phr = S_OK;

	HRESULT hr = m_pLoader->QueryInterface(IID_IDirectMusicLoader8P, reinterpret_cast<void**>(&m_pLoader8P));
	if (SUCCEEDED(hr))
	{
		// Hold only a private ref on the loader.  See IDirectMusicLoader8P::AddRefP for more info.
		m_pLoader8P->AddRefP();
		m_pLoader->Release(); // offset the QI
	}
	else
	{
		// It's OK if there's no private interface.  We just won't tell the garbage collector about stuff we load.
		// And we hold a normal reference.
		m_pLoader->AddRef();
	}

	if (fPreload)
		*phr = this->Load(false);
}

CContainerItemDispatch::~CContainerItemDispatch()
{
	if (m_pPerfForUnload)
	{
		// We need to unload to correspond with the automatic download done when we were loaded.
		this->DownloadOrUnload(false, m_pPerfForUnload);
	}

	SafeRelease(m_pPerfForUnload);
	ReleaseLoader();
	SafeRelease(m_pDispLoadedItem);
}

STDMETHODIMP
CContainerItemDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	// If we're loaded and have a dispatch interface, defer to the real object.
	if (m_pDispLoadedItem)
		return m_pDispLoadedItem->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);

	// Otherwise implement just the Load method.
	return AutLoadDispatchGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
}

STDMETHODIMP
CContainerItemDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	// If we're loaded and have a dispatch interface, defer to the real object.
	if (m_pDispLoadedItem)
		return m_pDispLoadedItem->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);

	// Otherwise implement just the Load method.
	bool fUseOleAut = false;
	HRESULT hr = AutLoadDispatchInvoke(&fUseOleAut, dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	if (FAILED(hr))
		return hr;

	InitWithPerfomanceFailureType eFailureType = IWP_Success;

	hr = m_fLoaded
			? S_OK					// if we've already been loaded, load can be called again and is a no-op
			: this->Load(true);		// otherwise, actually load the object

	if (SUCCEEDED(hr))
	{
		IDirectMusicPerformance *pPerf = CActiveScriptManager::GetCurrentPerformanceWEAK();
		if (pPerf)
		{
			hr = this->InitWithPerformance(pPerf, &eFailureType);
		}
		else
		{
			assert(false);
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr))
		return hr; // everything worked--we're done

	// From here on, we've failed and need to return an exception.
	if (!pExcepInfo)
		return DISP_E_EXCEPTION;

	pExcepInfo->wCode = 0;
	pExcepInfo->wReserved = 0;
	pExcepInfo->bstrSource = DMS_SysAllocString(fUseOleAut, L"Microsoft DirectMusic Runtime Error");

	const WCHAR *pwszErrorBeg = NULL;
	if (eFailureType == IWP_DownloadFailed)
	{
		pwszErrorBeg = L"Unable to download the requested content (";
	}
	else if (eFailureType == IWP_ScriptInitFailed && hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
	{
		pwszErrorBeg = L"Syntax error loading the requested script (";
	}
	else
	{
		// Must have been a problem before InitWithPerformance or a problem with the script
		// that wasn't a syntax error.
		pwszErrorBeg = L"Unable to load the requested content (";
	}

	static const WCHAR wszErrorEnd[] = L".Load)";
	WCHAR *pwszDescription = new WCHAR[wcslen(pwszErrorBeg) + wcslen(m_wstrAlias) + wcslen(wszErrorEnd) + 1];
	if (!pwszDescription)
	{
		pExcepInfo->bstrDescription = NULL;
	}
	else
	{
		wcscpy(pwszDescription, pwszErrorBeg);
		wcscat(pwszDescription, m_wstrAlias);
		wcscat(pwszDescription, wszErrorEnd);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fUseOleAut, pwszDescription);
		delete[] pwszDescription;
	}
	pExcepInfo->bstrHelpFile = NULL;
	pExcepInfo->pvReserved = NULL;
	pExcepInfo->pfnDeferredFillIn = NULL;
	pExcepInfo->scode = hr;

	return DISP_E_EXCEPTION;
}

HRESULT
CContainerItemDispatch::InitWithPerformance(IDirectMusicPerformance *pPerf, InitWithPerfomanceFailureType *peFailureType)
{
	if (!m_fLoaded || !pPerf || !peFailureType)
	{
		assert(false);
		return E_FAIL;
	}

	*peFailureType = IWP_Success;

	if (!m_pDispLoadedItem)
		return S_OK; // don't have an active item so no initialization is necessary

	HRESULT hr = S_OK;
	if (m_fAutodownload)
	{
		hr = this->DownloadOrUnload(true, pPerf);
		if (hr == S_OK)
		{
			m_pPerfForUnload = pPerf;
			m_pPerfForUnload->AddRef();
		}
		if (FAILED(hr))
		{
			*peFailureType = IWP_DownloadFailed;
			return hr;
		}
	}

	if (m_desc.guidClass == CLSID_DirectMusicScript)
	{
		IDirectMusicScript *pScript = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicScript, reinterpret_cast<void**>(&pScript));
		if (SUCCEEDED(hr))
		{
			hr = pScript->Init(pPerf, NULL);
			pScript->Release();
		}
		if (FAILED(hr))
		{
			*peFailureType = IWP_ScriptInitFailed;
			return hr;
		}
	}
	else if (m_desc.guidClass == CLSID_DirectMusicSong)
	{
		IDirectMusicSong *pSong = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicSong, reinterpret_cast<void**>(&pSong));
		if (SUCCEEDED(hr))
		{
			hr = pSong->Compose();
			pSong->Release();
		}
		if (FAILED(hr))
		{
			*peFailureType = IWP_DownloadFailed;
			return hr;
		}
	}

	return S_OK;
}

void CContainerItemDispatch::ReleaseLoader()
{
	if (m_pLoader8P)
	{
		// If we had the private interface, we just need to do a private release.
		m_pLoader8P->ReleaseP();
		m_pLoader8P = NULL;
		m_pLoader = NULL;
	}
	else
	{
		// We just have the public interface, so do a normal release.
		SafeRelease(m_pLoader);
	}
}

HRESULT
CContainerItemDispatch::Load(bool fDynamicLoad)
{
	HRESULT hr = S_OK;
	assert(m_pLoader);

	IUnknown *punkLoadedItem = NULL;
	if (fDynamicLoad && m_pLoader8P)
	{
		IDirectMusicObject *pScriptObject = CActiveScriptManager::GetCurrentScriptObjectWEAK();
		hr = m_pLoader8P->GetDynamicallyReferencedObject(pScriptObject, &m_desc, IID_IUnknown, reinterpret_cast<void**>(&punkLoadedItem));
	}
	else
	{
		// It's OK if there's no private interface.  We just won't tell the garbage collector about this load.
		hr = m_pLoader->GetObject(&m_desc, IID_IUnknown, reinterpret_cast<void**>(&punkLoadedItem));
	}

	if (SUCCEEDED(hr))
	{
		assert(punkLoadedItem);
		ReleaseLoader();
		m_fLoaded = true;

		// save the object's IDispatch interface, if it has one
		punkLoadedItem->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(&m_pDispLoadedItem));
		punkLoadedItem->Release();
	}
	return hr;
}

HRESULT
CContainerItemDispatch::DownloadOrUnload(bool fDownload, IDirectMusicPerformance *pPerf)
{
	HRESULT hr = S_OK;
	if (m_desc.guidClass == CLSID_DirectMusicSegment)
	{
		assert(pPerf);
		IDirectMusicSegment8 *pSegment = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicSegment8, reinterpret_cast<void**>(&pSegment));
		if (FAILED(hr))
			return hr;
		hr = fDownload
				? pSegment->Download(pPerf)
				: pSegment->Unload(pPerf);
		pSegment->Release();
	}
	else if (m_desc.guidClass == CLSID_DirectMusicSong)
	{
		assert(pPerf);
		IDirectMusicSong8 *pSong = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicSong8, reinterpret_cast<void**>(&pSong));
		if (FAILED(hr))
			return hr;
		hr = fDownload
				? pSong->Download(pPerf)
				: pSong->Unload(pPerf);
		pSong->Release();
	}
	else
	{
		hr = S_FALSE; // this type of object doesn't need to be downloaded
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CContainerDispatch

CContainerDispatch::CContainerDispatch(IDirectMusicContainer *pContainer, IDirectMusicLoader *pLoader, DWORD dwScriptFlags, HRESULT *phr)
{
	assert(pContainer && pLoader && phr);

	*phr = S_OK;
	DMUS_OBJECTDESC desc;
	ZeroAndSize(&desc);
	WCHAR wszAlias[MAX_PATH] = L"";

	// we need to download all the segments when the script is initialized if both loading and downloading are on
	bool fLoad = !!(dwScriptFlags & DMUS_SCRIPTIOF_LOAD_ALL_CONTENT);
	bool fDownload = !!(dwScriptFlags & DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS);
	m_fDownloadOnInit = fLoad && fDownload;

	DWORD i = 0;
	for (;;)
	{
		// Read an item out of the container
		*phr = pContainer->EnumObject(GUID_DirectMusicAllTypes, i, &desc, wszAlias);
		if (FAILED(*phr))
			return;
		if (*phr == S_FALSE)
		{
			// we've read all the items
			*phr = S_OK;
			return;
		}

		// Make an object to represent the item
		CContainerItemDispatch *pNewItem = new CContainerItemDispatch(
													pLoader,
													wszAlias,
													desc,
													fLoad,
													fDownload,
													phr);
		if (!pNewItem)
			*phr = E_OUTOFMEMORY;
		if (FAILED(*phr))
		{
            if(pNewItem)
            {
			    pNewItem->Release();
            }

			return;
		}

		// Add an entry to the table
		UINT iSlot = m_vecItems.size();
		if (!m_vecItems.AccessTo(iSlot))
		{
			pNewItem->Release();
			*phr = E_OUTOFMEMORY;
			return;
		}
		m_vecItems[iSlot] = pNewItem;

		// Set up for next iteration
		ZeroAndSize(&desc);
		wszAlias[0] = L'\0';
		++i;
	}
}

CContainerDispatch::~CContainerDispatch()
{
	UINT iEnd = m_vecItems.size();
	for (UINT i = 0; i < m_vecItems.size(); ++i)
	{
		m_vecItems[i]->Release();
	}
}

HRESULT
CContainerDispatch::OnScriptInit(IDirectMusicPerformance *pPerf)
{
	if (m_fDownloadOnInit)
	{
		UINT iEnd = m_vecItems.size();
		for (UINT i = 0; i < m_vecItems.size(); ++i)
		{
			CContainerItemDispatch::InitWithPerfomanceFailureType eFailureType;
			m_vecItems[i]->InitWithPerformance(pPerf, &eFailureType);
		}
	}

	return S_OK;
}

HRESULT
CContainerDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	// Otherwise implement just the Load method.
	V_INAME(CContainerDispatch::GetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	UINT cEnd = m_vecItems.size();
	for (c = 0; c < cEnd; ++c)
	{
		if (0 == _wcsicmp(rgszNames[0], m_vecItems[c]->Alias()))
		{
			rgDispId[0] = c + 1;
			break;
		}
	}

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

HRESULT
CContainerDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	V_INAME(CContainerDispatch::Invoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_PROPERTYGET))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cArgs > 0)
		return DISP_E_BADPARAMCOUNT;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	if (dispIdMember > m_vecItems.size())
		return DISP_E_MEMBERNOTFOUND;

	// Return the value
	if (pVarResult)
	{
		pVarResult->vt = VT_DISPATCH;
		pVarResult->pdispVal = m_vecItems[dispIdMember - 1]->Item();
		pVarResult->pdispVal->AddRef();
	}

	return S_OK;
}

HRESULT
CContainerDispatch::EnumItem(DWORD dwIndex, WCHAR *pwszName)
{
	if (dwIndex >= m_vecItems.size())
		return S_FALSE;

	CContainerItemDispatch *pItem = m_vecItems[dwIndex];
	return wcsTruncatedCopy(pwszName, pItem->Alias(), MAX_PATH);
}

HRESULT
CContainerDispatch::GetVariableObject(WCHAR *pwszVariableName, IUnknown **ppunkValue)
{
	assert(pwszVariableName && ppunkValue);
	UINT cEnd = m_vecItems.size();
	for (UINT c = 0; c < cEnd; ++c)
	{
		if (0 == _wcsicmp(pwszVariableName, m_vecItems[c]->Alias()))
		{
			*ppunkValue = m_vecItems[c]->Item();
			(*ppunkValue)->AddRef();
			return S_OK;
		}
	}
	return DMUS_E_SCRIPT_VARIABLE_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMSCRIPT"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\dll.cpp ===
//
// dll.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Note: Dll entry points as well as class factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include "stdinc.h"

#include "oledll.h"
#include "dll.h"
#include "dmscript.h"
#include "track.h"
#include "engine.h"
#include "autperformance.h"
#include "autsegment.h"
#include "autsong.h"
#include "autsegmentstate.h"
#include "autaudiopathconfig.h"
#include "autaudiopath.h"
#include "dmscriptautguids.h"
#include "sourcetext.h"
#include "scriptthread.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cLock = 0;

// Version information for our class
//
char g_szDMScriptFriendlyName[]						= "DirectMusic Script Object";
char g_szDMScriptVerIndProgID[]						= "Microsoft.DirectMusicScript";
char g_szDMScriptProgID[]							= "Microsoft.DirectMusicScript.1";

char g_szScriptTrackFriendlyName[]					= "DirectMusicScriptTrack";
char g_szScriptTrackVerIndProgID[]					= "Microsoft.DirectMusicScriptTrack";
char g_szScriptTrackProgID[]						= "Microsoft.DirectMusicScriptTrack.1";

char g_szAudioVBScriptFriendlyName[]				= "DirectMusic Audio VB Script Language";
char g_szAudioVBScriptVerIndProgID[]				= "AudioVBScript";
char g_szAudioVBScriptVerIndProgID_DMScript[]		= "AudioVBScript\\DMScript";
char g_szAudioVBScriptProgID[]						= "AudioVBScript.1";
char g_szAudioVBScriptProgID_DMScript[]				= "AudioVBScript.1\\DMScript";

char g_szDMScriptSourceTextFriendlyName[]			= "DirectMusic Script Source Code Loader";
char g_szDMScriptSourceTextVerIndProgID[]			= "Microsoft.DirectMusicScripSourceCodeLoader";
char g_szDMScriptSourceTextProgID[]					= "Microsoft.DirectMusicScripSourceCodeLoader.1";

char g_szDMScriptAutPerformanceFriendlyName[]		= "DirectMusic Script AutoImp Performance";
char g_szDMScriptAutPerformanceVerIndProgID[]		= "Microsoft.DirectMusicScriptAutoImpPerformance";
char g_szDMScriptAutPerformanceProgID[]				= "Microsoft.DirectMusicScriptAutoImpPerformance.1";

char g_szDMScriptAutSegmentFriendlyName[]			= "DirectMusic Script AutoImp Segment";
char g_szDMScriptAutSegmentVerIndProgID[]			= "Microsoft.DirectMusicScriptAutoImpSegment";
char g_szDMScriptAutSegmentProgID[]					= "Microsoft.DirectMusicScriptAutoImpSegment.1";

char g_szDMScriptAutSongFriendlyName[]				= "DirectMusic Script AutoImp Song";
char g_szDMScriptAutSongVerIndProgID[]				= "Microsoft.DirectMusicScriptAutoImpSong";
char g_szDMScriptAutSongProgID[]					= "Microsoft.DirectMusicScriptAutoImpSong.1";

char g_szDMScriptAutSegmentStateFriendlyName[]		= "DirectMusic Script AutoImp SegmentState";
char g_szDMScriptAutSegmentStateVerIndProgID[]		= "Microsoft.DirectMusicScriptAutoImpSegmentState";
char g_szDMScriptAutSegmentStateProgID[]			= "Microsoft.DirectMusicScriptAutoImpSegmentState.1";

char g_szDMScriptAutAudioPathConfigFriendlyName[]	= "DirectMusic Script AutoImp AudioPathConfig";
char g_szDMScriptAutAudioPathConfigVerIndProgID[]	= "Microsoft.DirectMusicScriptAutoImpAudioPathConfig";
char g_szDMScriptAutAudioPathConfigProgID[]			= "Microsoft.DirectMusicScriptAutoImpAudioPathConfig.1";

char g_szDMScriptAutAudioPathFriendlyName[]			= "DirectMusic Script AutoImp AudioPath";
char g_szDMScriptAutAudioPathVerIndProgID[]			= "Microsoft.DirectMusicScriptAutoImpAudioPath";
char g_szDMScriptAutAudioPathProgID[]				= "Microsoft.DirectMusicScriptAutoImpAudioPath.1";

//////////////////////////////////////////////////////////////////////
// CDMScriptingFactory IUnknown methods

HRESULT __stdcall
CDMScriptingFactory::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDMScriptingFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IClassFactory)
		*ppv = static_cast<IClassFactory*>(this);
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall
CDMScriptingFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CDMScriptingFactory::Release()
{
	if (!InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDMScriptingFactory IClassFactory methods

HRESULT __stdcall
CDMScriptingFactory::CreateInstance(IUnknown* pUnknownOuter,
									const IID& iid,
									void** ppv)
{
	V_INAME(CDMScriptingFactory::CreateInstance);
	V_INTERFACE_OPT(pUnknownOuter);
	V_PTR_WRITE(ppv, void*);

	try
	{
		return m_pfnCreate(pUnknownOuter, iid, ppv);
	}
	catch( ... )
	{
		return E_OUTOFMEMORY;
	}

	return E_NOINTERFACE;
}

HRESULT __stdcall
CDMScriptingFactory::LockServer(BOOL bLock)
{
	LockModule(!!bLock);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Dll entry points

STDAPI DllCanUnloadNow()
{
    if (g_cLock)
        return S_FALSE;

    return S_OK;
}

STDAPI DllGetClassObject
	(
	const CLSID& clsid,
	const IID& iid,
	void** ppv
	)
{
	IUnknown* pIUnknown = NULL;

	PFN_CreateInstance *pfnCreate = NULL;
	if (clsid == CLSID_DirectMusicScript)
	{
		pfnCreate = CDirectMusicScript::CreateInstance;
	}
	else if (clsid == CLSID_DirectMusicScriptTrack)
	{
		// I couldn't get it to compile if I just used TrackHelpCreateInstance<CDirectMusicScriptTrack>
		// for the function pointer so I created this function that calls it.
		struct LocalNonTemplateDeclaration
		{
			static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv)
			{
				return TrackHelpCreateInstance<CDirectMusicScriptTrack>(pUnknownOuter, iid, ppv);
			}
		};
		pfnCreate = LocalNonTemplateDeclaration::CreateInstance;
	}
	else if (clsid == CLSID_DirectMusicAudioVBScript)
	{
		pfnCreate = CAudioVBScriptEngine::CreateInstance;
	}
	else if (clsid == CLSID_DirectMusicSourceText)
	{
		pfnCreate = CSourceText::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicPerformance)
	{
		pfnCreate = CAutDirectMusicPerformance::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicSegment)
	{
		pfnCreate = CAutDirectMusicSegment::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicSong)
	{
		pfnCreate = CAutDirectMusicSong::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicSegmentState)
	{
		pfnCreate = CAutDirectMusicSegmentState::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicAudioPathConfig)
	{
		pfnCreate = CAutDirectMusicAudioPathConfig::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicAudioPath)
	{
		pfnCreate = CAutDirectMusicAudioPath::CreateInstance;
	}

	if (pfnCreate)
	{
		pIUnknown = static_cast<IUnknown*>(new CDMScriptingFactory(pfnCreate));
		if(!pIUnknown)
			return E_OUTOFMEMORY;
	}
	else
	{
		return CLASS_E_CLASSNOTAVAILABLE;
	}

	return pIUnknown->QueryInterface(iid, ppv);
}

STDAPI DllUnregisterServer()
{
	UnregisterServer(
		CLSID_DirectMusicScript,
		g_szDMScriptFriendlyName,
		g_szDMScriptVerIndProgID,
		g_szDMScriptProgID);
	UnregisterServer(CLSID_DirectMusicScriptTrack,
		g_szScriptTrackFriendlyName,
		g_szScriptTrackVerIndProgID,
		g_szScriptTrackProgID);
	UnregisterServer(CLSID_DirectMusicAudioVBScript,
		g_szAudioVBScriptFriendlyName,
		g_szAudioVBScriptVerIndProgID,
		g_szAudioVBScriptProgID);
	UnregisterServer(
		CLSID_DirectMusicSourceText,
		g_szDMScriptSourceTextFriendlyName,
		g_szDMScriptSourceTextVerIndProgID,
		g_szDMScriptSourceTextProgID);
	UnregisterServer(CLSID_AutDirectMusicPerformance,
		g_szDMScriptAutPerformanceFriendlyName,
		g_szDMScriptAutPerformanceVerIndProgID,
		g_szDMScriptAutPerformanceProgID);
	UnregisterServer(CLSID_AutDirectMusicSegment,
		g_szDMScriptAutSegmentFriendlyName,
		g_szDMScriptAutSegmentVerIndProgID,
		g_szDMScriptAutSegmentProgID);
	UnregisterServer(CLSID_AutDirectMusicSong,
		g_szDMScriptAutSongFriendlyName,
		g_szDMScriptAutSongVerIndProgID,
		g_szDMScriptAutSongProgID);
	UnregisterServer(CLSID_AutDirectMusicSegmentState,
		g_szDMScriptAutSegmentStateFriendlyName,
		g_szDMScriptAutSegmentStateVerIndProgID,
		g_szDMScriptAutSegmentStateProgID);
	UnregisterServer(CLSID_AutDirectMusicAudioPathConfig,
		g_szDMScriptAutAudioPathConfigFriendlyName,
		g_szDMScriptAutAudioPathConfigVerIndProgID,
		g_szDMScriptAutAudioPathConfigProgID);
	UnregisterServer(CLSID_AutDirectMusicAudioPath,
		g_szDMScriptAutAudioPathFriendlyName,
		g_szDMScriptAutAudioPathVerIndProgID,
		g_szDMScriptAutAudioPathProgID);
	return S_OK;
}

STDAPI DllRegisterServer()
{
	RegisterServer(
		g_hModule,
		CLSID_DirectMusicScript,
		g_szDMScriptFriendlyName,
		g_szDMScriptVerIndProgID,
		g_szDMScriptProgID);
	RegisterServer(
		g_hModule,
		CLSID_DirectMusicScriptTrack,
		g_szScriptTrackFriendlyName,
		g_szScriptTrackVerIndProgID,
		g_szScriptTrackProgID);
	RegisterServer(
		g_hModule,
		CLSID_DirectMusicSourceText,
		g_szDMScriptSourceTextFriendlyName,
		g_szDMScriptSourceTextVerIndProgID,
		g_szDMScriptSourceTextProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicPerformance,
		g_szDMScriptAutPerformanceFriendlyName,
		g_szDMScriptAutPerformanceVerIndProgID,
		g_szDMScriptAutPerformanceProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicSegment,
		g_szDMScriptAutSegmentFriendlyName,
		g_szDMScriptAutSegmentVerIndProgID,
		g_szDMScriptAutSegmentProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicSong,
		g_szDMScriptAutSongFriendlyName,
		g_szDMScriptAutSongVerIndProgID,
		g_szDMScriptAutSongProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicSegmentState,
		g_szDMScriptAutSegmentStateFriendlyName,
		g_szDMScriptAutSegmentStateVerIndProgID,
		g_szDMScriptAutSegmentStateProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicAudioPathConfig,
		g_szDMScriptAutAudioPathConfigFriendlyName,
		g_szDMScriptAutAudioPathConfigVerIndProgID,
		g_szDMScriptAutAudioPathConfigProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicAudioPath,
		g_szDMScriptAutAudioPathFriendlyName,
		g_szDMScriptAutAudioPathVerIndProgID,
		g_szDMScriptAutAudioPathProgID);

	RegisterServer(
		g_hModule,
		CLSID_DirectMusicAudioVBScript,
		g_szAudioVBScriptFriendlyName,
		g_szAudioVBScriptVerIndProgID,
		g_szAudioVBScriptProgID);
	// AudioVBScript also needs an additional DMScript key set to mark it as a custom scripting engine.
	HKEY hk;
	if (ERROR_SUCCESS == RegCreateKeyEx(
							HKEY_CLASSES_ROOT,
							g_szAudioVBScriptVerIndProgID_DMScript,
							0,
							NULL,
							0,
							KEY_ALL_ACCESS,
							NULL,
							&hk,
							NULL))
		RegCloseKey(hk);
	if (ERROR_SUCCESS == RegCreateKeyEx(
							HKEY_CLASSES_ROOT,
							g_szAudioVBScriptProgID_DMScript,
							0,
							NULL,
							0,
							KEY_ALL_ACCESS,
							NULL,
							&hk,
							NULL))
		RegCloseKey(hk);

	return S_OK;
}

#ifdef DBG
static char* aszReasons[] =
{
	"DLL_PROCESS_DETACH",
	"DLL_PROCESS_ATTACH",
	"DLL_THREAD_ATTACH",
	"DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY
DllMain
	(
	HINSTANCE hModule,
	DWORD dwReason,
	void *lpReserved
	)
{
	static int nReferenceCount = 0;

#ifdef DBG
	if (dwReason < nReasons)
	{
		Trace(1, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
	}
	else
	{
		Trace(1, "DllMain: Unknown dwReason <%u>\n", dwReason);
	}
#endif

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			if (++nReferenceCount == 1)
			{
				#ifdef DBG
					DebugInit();
				#endif

				if (!DisableThreadLibraryCalls(hModule))
				{
					Trace(1, "DisableThreadLibraryCalls failed.\n");
				}

				g_hModule = hModule;
			}
			break;

		case DLL_PROCESS_DETACH:
			if (--nReferenceCount == 0)
			{
				Trace(1, "Unloading\n");
                // Assert if we still have some objects hanging around
                assert(g_cLock == 0);
			}
			break;
			
	}
		
	return TRUE;
}


//////////////////////////////////////////////////////////////////////
// Global Functions

void
LockModule(bool fLock)
{
	if (fLock)
	{
		InterlockedIncrement(&g_cLock);
	}
	else
	{
		if (!InterlockedDecrement(&g_cLock))
		{
			// Clean up the shared thread used to talk to VBScript.  Needs to be done before the .dll could be unloaded,
			// which otherwise would make for problems because the thread could keep running while the .dll's address
			// space becomes invalid.
			CSingleThreadedScriptManager::TerminateThread();
		}
	}
}

long *GetModuleLockCounter()
{
	return &g_cLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\dmscript.cpp ===
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Implementation of CDirectMusicScript.
//

#include "stdinc.h"
#include "dll.h"
#include "dmscript.h"
#include "oleaut.h"
#include "globaldisp.h"
#include "activescript.h"
#include "sourcetext.h"

//////////////////////////////////////////////////////////////////////
// Creation

CDirectMusicScript::CDirectMusicScript()
  : m_cRef(0),
    m_fZombie(false),
    m_fCriticalSectionInitialized(false),
    m_pPerformance8(NULL),
    m_pLoader8P(NULL),
    m_pDispPerformance(NULL),
    m_pComposer8(NULL),
    m_fUseOleAut(true),
    m_pScriptManager(NULL),
    m_pContainerDispatch(NULL),
    m_pGlobalDispatch(NULL),
    m_fInitError(false)
{
    LockModule(true);
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCriticalSectionInitialized = TRUE;

    m_info.fLoaded = false;
    m_vDirectMusicVersion.dwVersionMS = 0;
    m_vDirectMusicVersion.dwVersionLS = 0;
    Zero(&m_iohead);
    ZeroAndSize(&m_InitErrorInfo);
}

void CDirectMusicScript::ReleaseObjects()
{
    if (m_pScriptManager)
    {
        m_pScriptManager->Close();
        SafeRelease(m_pScriptManager);
    }
    SafeRelease(m_pPerformance8);
    SafeRelease(m_pDispPerformance);
    if (m_pLoader8P)
    {
        m_pLoader8P->ReleaseP();
        m_pLoader8P = NULL;
    }
    SafeRelease(m_pComposer8);
    delete m_pContainerDispatch;
    m_pContainerDispatch = NULL;
    delete m_pGlobalDispatch;
    m_pGlobalDispatch = NULL;
}

HRESULT CDirectMusicScript::CreateInstance(
        IUnknown* pUnknownOuter,
        const IID& iid,
        void** ppv)
{
    *ppv = NULL;
    if (pUnknownOuter)
         return CLASS_E_NOAGGREGATION;

    CDirectMusicScript *pInst = new CDirectMusicScript;
    if (pInst == NULL)
        return E_OUTOFMEMORY;

    return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CDirectMusicScript::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CDirectMusicScript::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicScript)
    {
        *ppv = static_cast<IDirectMusicScript*>(this);
    }
    else if (iid == IID_IDirectMusicScriptPrivate)
    {
        *ppv = static_cast<IDirectMusicScriptPrivate*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDirectMusicObjectP)
    {
        *ppv = static_cast<IDirectMusicObjectP*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        *ppv = static_cast<IDispatch*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG)
CDirectMusicScript::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CDirectMusicScript::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        this->Zombie();
        DeleteCriticalSection(&m_CriticalSection);
        delete this;
        LockModule(false);
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP
CDirectMusicScript::Load(IStream* pStream)
{
    V_INAME(CDirectMusicScript::Load);
    V_INTERFACE(pStream);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::Load after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    // Clear any old info
    this->ReleaseObjects();
    m_info.fLoaded = false;
    m_info.oinfo.Clear();
    m_vDirectMusicVersion.dwVersionMS = 0;
    m_vDirectMusicVersion.dwVersionLS = 0;
    m_wstrLanguage = NULL;
    m_fInitError = false;

    // Get the loader from stream
    IDirectMusicGetLoader *pIDMGetLoader = NULL;
    SmartRef::ComPtr<IDirectMusicLoader> scomLoader;
    hr = pStream->QueryInterface(IID_IDirectMusicGetLoader, reinterpret_cast<void **>(&pIDMGetLoader));
    if (FAILED(hr))
    {
        Trace(1, "Error: unable to load script from a stream because it doesn't support the IDirectMusicGetLoader interface.\n");
        return DMUS_E_UNSUPPORTED_STREAM;
    }

    hr = pIDMGetLoader->GetLoader(&scomLoader);
    pIDMGetLoader->Release();
    if (FAILED(hr))
        return hr;

    hr = scomLoader->QueryInterface(IID_IDirectMusicLoader8P, reinterpret_cast<void **>(&m_pLoader8P)); // OK if this fails -- just means the scripts won't be garbage collected
    if (SUCCEEDED(hr))
    {
        // Hold only a private ref on the loader.  See IDirectMusicLoader8P::AddRefP for more info.
        m_pLoader8P->AddRefP();
        m_pLoader8P->Release(); // offset the QI
    }

    // Read the script's header information

    SmartRef::RiffIter riForm(pStream);
    if (!riForm)
    {
#ifdef DBG
        if (SUCCEEDED(riForm.hr()))
        {
            Trace(1, "Error: Unable to load script: Unexpected end of file.\n");
        }
#endif
        return SUCCEEDED(riForm.hr()) ? DMUS_E_SCRIPT_INVALID_FILE : riForm.hr();
    }
    hr = riForm.FindRequired(SmartRef::RiffIter::Riff, DMUS_FOURCC_SCRIPT_FORM, DMUS_E_SCRIPT_INVALID_FILE);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_SCRIPT_INVALID_FILE)
        {
            Trace(1, "Error: Unable to load script: Form 'DMSC' not found.\n");
        }
#endif
        return hr;
    }

    SmartRef::RiffIter ri = riForm.Descend();
    if (!ri)
        return ri.hr();

    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPT_CHUNK, DMUS_E_SCRIPT_INVALID_FILE);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_SCRIPT_INVALID_FILE)
        {
            Trace(1, "Error: Unable to load script: Chunk 'schd' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &m_iohead);
    if (FAILED(hr))
        return hr;

    hr = ri.LoadObjectInfo(&m_info.oinfo, SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPTVERSION_CHUNK);
    if (FAILED(hr))
        return hr;

    hr = SmartRef::RiffIterReadChunk(ri, &m_vDirectMusicVersion);
    if (FAILED(hr))
        return hr;

    // Read the script's embedded container
    IDirectMusicContainer *pContainer = NULL;
    hr = ri.FindAndGetEmbeddedObject(
                SmartRef::RiffIter::Riff,
                DMUS_FOURCC_CONTAINER_FORM,
                DMUS_E_SCRIPT_INVALID_FILE,
                scomLoader,
                CLSID_DirectMusicContainer,
                IID_IDirectMusicContainer,
                reinterpret_cast<void**>(&pContainer));
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_SCRIPT_INVALID_FILE)
        {
            Trace(1, "Error: Unable to load script: Form 'DMCN' no found.\n");
        }
#endif
        return hr;
    }

    // Build the container object that will represent the items in the container to the script

    m_pContainerDispatch = new CContainerDispatch(pContainer, scomLoader, m_iohead.dwFlags, &hr);
    pContainer->Release();
    if (!m_pContainerDispatch)
        return E_OUTOFMEMORY;
    if (FAILED(hr))
        return hr;

    // Create the global dispatch object

    m_pGlobalDispatch = new CGlobalDispatch(this);
    if (!m_pGlobalDispatch)
        return E_OUTOFMEMORY;

    // Get the script's language

    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK, DMUS_E_SCRIPT_INVALID_FILE);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_SCRIPT_INVALID_FILE)
        {
            Trace(1, "Error: Unable to load script: Chunk 'scla' no found.\n");
        }
#endif
        return hr;
    }

    hr = ri.ReadText(&m_wstrLanguage);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == E_FAIL)
        {
            Trace(1, "Error: Unable to load script: Problem reading 'scla' chunk.\n");
        }
#endif
        return hr == E_FAIL ? DMUS_E_SCRIPT_INVALID_FILE : hr;
    }

    // Get the script's source code

    SmartRef::WString wstrSource;
    for (++ri; ;++ri)
    {
        if (!ri)
        {
            Trace(1, "Error: Unable to load script: Expected chunk 'scsr' or list 'DMRF'.\n");
            return DMUS_E_SCRIPT_INVALID_FILE;
        }

        SmartRef::RiffIter::RiffType type = ri.type();
        FOURCC id = ri.id();

        if (type == SmartRef::RiffIter::Chunk)
        {
            if (id == DMUS_FOURCC_SCRIPTSOURCE_CHUNK)
            {
                hr = ri.ReadText(&wstrSource);
                if (FAILED(hr))
                {
#ifdef DBG
                    if (hr == E_FAIL)
                    {
                        Trace(1, "Error: Unable to load script: Problem reading 'scsr' chunk.\n");
                    }
#endif
                    return hr == E_FAIL ? DMUS_E_SCRIPT_INVALID_FILE : hr;
                }
            }
            break;
        }
        else if (type == SmartRef::RiffIter::List)
        {
            if (id == DMUS_FOURCC_REF_LIST)
            {
                DMUS_OBJECTDESC desc;
                hr = ri.ReadReference(&desc);
                if (FAILED(hr))
                    return hr;
                // The resulting desc shouldn't have a name or GUID (the plain text file can't hold name/GUID info)
                // and it should have a clsid should be GUID_NULL, which we'll replace with the clsid of our private
                // source helper object.
                if (desc.dwValidData & (DMUS_OBJ_NAME | DMUS_OBJ_OBJECT) ||
                        !(desc.dwValidData & DMUS_OBJ_CLASS) || desc.guidClass != GUID_NULL)
                {
#ifdef DBG
                    if (desc.dwValidData & (DMUS_OBJ_NAME | DMUS_OBJ_OBJECT))
                    {
                        Trace(1, "Error: Unable to load script: 'DMRF' list must have dwValidData with DMUS_OBJ_CLASS and guidClassID of GUID_NULL.\n");
                    }
                    else
                    {
                        Trace(1, "Error: Unable to load script: 'DMRF' list cannot have dwValidData with DMUS_OBJ_NAME or DMUS_OBJ_OBJECT.\n");
                    }
#endif
                    return DMUS_E_SCRIPT_INVALID_FILE;
                }
                desc.guidClass = CLSID_DirectMusicSourceText;
                IDirectMusicSourceText *pISource = NULL;
                hr = scomLoader->EnableCache(CLSID_DirectMusicSourceText, false); // This is a private object we just use temporarily. Don't want these guys hanging around in the cache.
                if (FAILED(hr))
                    return hr;
                hr = scomLoader->GetObject(&desc, IID_IDirectMusicSourceText, reinterpret_cast<void**>(&pISource));
                if (FAILED(hr))
                    return hr;
                DWORD cwchSourceBufferSize = 0;
                pISource->GetTextLength(&cwchSourceBufferSize);
                WCHAR *pwszSource = new WCHAR[cwchSourceBufferSize];
                if (!pwszSource)
                    return E_OUTOFMEMORY;
                pISource->GetText(pwszSource);
                *&wstrSource = pwszSource;
                pISource->Release();
            }
            break;
        }
    }

    m_info.fLoaded = true;

    // Now that we are loaded and initialized, we can start active scripting

    // See if we're dealing with a custom DirectMusic scripting engine.  Such engines are marked with the key DMScript.  They can be
    // called on multiple threads and they don't use oleaut32.  Ordinary active scripting engines are marked with the key OLEScript.
    SmartRef::HKey shkeyLanguage;
    SmartRef::HKey shkeyMark;
    SmartRef::AString astrLanguage = m_wstrLanguage;
    if (ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, astrLanguage, 0, KEY_QUERY_VALUE, &shkeyLanguage) || !shkeyLanguage)
    {
        Trace(1, "Error: Unable to load script: Scripting engine for language %s does not exist or is not registered.\n", astrLanguage);
        return DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
    }
    bool fCustomScriptEngine = ERROR_SUCCESS == ::RegOpenKeyEx(shkeyLanguage, "DMScript", 0, KEY_QUERY_VALUE, &shkeyMark) && shkeyMark;
    if (!fCustomScriptEngine)
    {
        if (ERROR_SUCCESS != ::RegOpenKeyEx(shkeyLanguage, "OLEScript", 0, KEY_QUERY_VALUE, &shkeyMark) || !shkeyMark)
        {
            Trace(1, "Error: Unable to load script: Language %s refers to a COM object that is not registered as a scripting engine (OLEScript key).\n", astrLanguage);
            return DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
        }
    }

    m_fUseOleAut = !fCustomScriptEngine;
    if (fCustomScriptEngine)
    {
        m_pScriptManager = new CActiveScriptManager(
                                        m_fUseOleAut,
                                        m_wstrLanguage,
                                        wstrSource,
                                        this,
                                        &hr,
                                        &m_InitErrorInfo);
    }
    else
    {
        m_pScriptManager = new CSingleThreadedScriptManager(
                                        m_fUseOleAut,
                                        m_wstrLanguage,
                                        wstrSource,
                                        this,
                                        &hr,
                                        &m_InitErrorInfo);
    }

    if (!m_pScriptManager)
        return E_OUTOFMEMORY;

    if (FAILED(hr))
    {
        SafeRelease(m_pScriptManager);
    }

    if (hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
    {
        // If we fail here, load would fail and client would never be able to get the
        // error information.  Instead, return S_OK and save the error to return from Init.
        m_fInitError = true;
        hr = S_OK;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP 
CDirectMusicScript::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CDirectMusicScript::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    
    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::GetDescriptor after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    if (wcslen(m_info.oinfo.wszName) > 0)
    {
        pDesc->dwValidData |= DMUS_OBJ_NAME;
        wcsncpy(pDesc->wszName, m_info.oinfo.wszName, DMUS_MAX_NAME);
        pDesc->wszName[DMUS_MAX_NAME-1] = L'\0';
    }

    if (GUID_NULL != m_info.oinfo.guid)
    {
        pDesc->guidObject = m_info.oinfo.guid;
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
    }

    pDesc->vVersion = m_info.oinfo.vVersion;
    pDesc->dwValidData |= DMUS_OBJ_VERSION;

    pDesc->guidClass = CLSID_DirectMusicScript;
    pDesc->dwValidData |= DMUS_OBJ_CLASS;

    if (m_info.wstrFilename)
    {
        wcsncpy(pDesc->wszFileName, m_info.wstrFilename, DMUS_MAX_FILENAME);
        pDesc->wszFileName[DMUS_MAX_FILENAME-1] = L'\0';
        pDesc->dwValidData |= DMUS_OBJ_FILENAME;
    }

    if (m_info.fLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }

    return S_OK;
}

STDMETHODIMP 
CDirectMusicScript::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CDirectMusicScript::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::SetDescriptor after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    DWORD dwTemp = pDesc->dwValidData;

    if (pDesc->dwValidData & DMUS_OBJ_OBJECT)
    {
        m_info.oinfo.guid = pDesc->guidObject;
    }

    if (pDesc->dwValidData & DMUS_OBJ_CLASS)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_CLASS;
    }

    if (pDesc->dwValidData & DMUS_OBJ_NAME)
    {
        wcsncpy(m_info.oinfo.wszName, pDesc->wszName, DMUS_MAX_NAME);
        m_info.oinfo.wszName[DMUS_MAX_NAME-1] = L'\0';
    }

    if (pDesc->dwValidData & DMUS_OBJ_CATEGORY)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_CATEGORY;
    }

    if (pDesc->dwValidData & DMUS_OBJ_FILENAME)
    {
        m_info.wstrFilename = pDesc->wszFileName;
    }

    if (pDesc->dwValidData & DMUS_OBJ_FULLPATH)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_FULLPATH;
    }

    if (pDesc->dwValidData & DMUS_OBJ_URL)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_URL;
    }

    if (pDesc->dwValidData & DMUS_OBJ_VERSION)
    {
        m_info.oinfo.vVersion = pDesc->vVersion;
    }
    
    if (pDesc->dwValidData & DMUS_OBJ_DATE)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_DATE;
    }

    if (pDesc->dwValidData & DMUS_OBJ_LOADED)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_LOADED;
    }
    
    return dwTemp == pDesc->dwValidData ? S_OK : S_FALSE;
}

STDMETHODIMP 
CDirectMusicScript::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CDirectMusicScript::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    
    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::ParseDescriptor after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    SmartRef::CritSec CS(&m_CriticalSection);

    // Read the script's header information

    SmartRef::RiffIter riForm(pStream);
    if (!riForm)
    {
#ifdef DBG
        if (SUCCEEDED(riForm.hr()))
        {
            Trace(2, "Error: ParseDescriptor on a script failed: Unexpected end of file. "
                        "(Note that this may be OK, such as when ScanDirectory is used to parse a set of unknown files, some of which are not scripts.)\n");
        }
#endif
        return SUCCEEDED(riForm.hr()) ? DMUS_E_SCRIPT_INVALID_FILE : riForm.hr();
    }
    HRESULT hr = riForm.FindRequired(SmartRef::RiffIter::Riff, DMUS_FOURCC_SCRIPT_FORM, DMUS_E_SCRIPT_INVALID_FILE);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_SCRIPT_INVALID_FILE)
        {
            Trace(1, "Error: ParseDescriptor on a script failed: Form 'DMSC' not found. "
                        "(Note that this may be OK, such as when ScanDirectory is used to parse a set of unknown files, some of which are not scripts.)\n");
        }
#endif
        return hr;
    }

    SmartRef::RiffIter ri = riForm.Descend();
    if (!ri)
        return ri.hr();

    hr = ri.LoadObjectInfo(&m_info.oinfo, SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPTVERSION_CHUNK);
    if (FAILED(hr))
        return hr;

    hr = this->GetDescriptor(pDesc);
    return hr;
}

STDMETHODIMP_(void)
CDirectMusicScript::Zombie()
{
    m_fZombie = true;
    this->ReleaseObjects();
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicScript

STDMETHODIMP
CDirectMusicScript::Init(IDirectMusicPerformance *pPerformance, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    V_INAME(CDirectMusicScript::Init);
    V_INTERFACE(pPerformance);
    V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::Init after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    SmartRef::ComPtr<IDirectMusicPerformance8> scomPerformance8;
    HRESULT hr = pPerformance->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void **>(&scomPerformance8));
    if (FAILED(hr))
        return hr;
    
    // Don't take the critical section if the script is already initialized.
    // For example, this is necessary in the following situation:
    //  - The critical section has already been taken by CallRoutine.
    //  - The routine played a segment with a script track referencing this script.
    //  - The script track calls Init (from a different thread) to make sure the script
    //    is initialized.
    if (m_pPerformance8)
    {
        // Additional calls to Init are ignored.
        // First call wins.  Return S_FALSE if performance doesn't match.
        if (m_pPerformance8 == scomPerformance8)
            return S_OK;
        else
            return S_FALSE;
    }

    SmartRef::CritSec CS(&m_CriticalSection);

    if (m_fInitError)
    {
        if (pErrorInfo)
        {
            // Syntax errors in a script occur as it is loaded, before SetDescriptor gives a script
            // its filename.  We'll have it after the load (before init is called) so can add it
            // back in here.
            if (m_InitErrorInfo.wszSourceFile[0] == L'\0' && m_info.wstrFilename)
                wcsTruncatedCopy(m_InitErrorInfo.wszSourceFile, m_info.wstrFilename, DMUS_MAX_FILENAME);

            CopySizedStruct(pErrorInfo, &m_InitErrorInfo);
        }

        return DMUS_E_SCRIPT_ERROR_IN_SCRIPT;
    }

    if (!m_info.fLoaded)
    {
        Trace(1, "Error: IDirectMusicScript::Init called before the script has been loaded.\n");
        return DMUS_E_NOT_LOADED;
    }

    // Get the dispatch interface for the performance
    SmartRef::ComPtr<IDispatch> scomDispPerformance = NULL;
    hr = pPerformance->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&scomDispPerformance));
    if (FAILED(hr))
        return hr;

    // Get a composer object
    hr = CoCreateInstance(CLSID_DirectMusicComposer, NULL, CLSCTX_INPROC_SERVER, IID_IDirectMusicComposer8, reinterpret_cast<void **>(&m_pComposer8));
    if (FAILED(hr))
        return hr;

    m_pDispPerformance = scomDispPerformance.disown();
    m_pPerformance8 = scomPerformance8.disown();

    hr = m_pScriptManager->Start(pErrorInfo);
    if (FAILED(hr))
        return hr;

    hr = m_pContainerDispatch->OnScriptInit(m_pPerformance8);
    return hr;
}

// Returns DMUS_E_SCRIPT_ROUTINE_NOT_FOUND if routine doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::CallRoutine(WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    V_INAME(CDirectMusicScript::CallRoutine);
    V_BUFPTR_READ(pwszRoutineName, 2);
    V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::CallRoutine after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    SmartRef::CritSec CS(&m_CriticalSection);

    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::CallRoutine.\n");
        return DMUS_E_NOT_INIT;
    }

    return m_pScriptManager->CallRoutine(pwszRoutineName, pErrorInfo);
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND if variable doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::SetVariableVariant(
        WCHAR *pwszVariableName,
        VARIANT varValue,
        BOOL fSetRef,
        DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    V_INAME(CDirectMusicScript::SetVariableVariant);
    V_BUFPTR_READ(pwszVariableName, 2);
    V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);

    switch (varValue.vt)
    {
    case VT_BSTR:
        V_BUFPTR_READ_OPT(varValue.bstrVal, sizeof(OLECHAR));
        // We could be more thorough and verify each character until we hit the terminator but
        // that would be inefficient.  We could also use the length preceding a BSTR pointer,
        // but that would be cheating COM's functions that encapsulate BSTRs and could lead to
        // problems in future versions of windows such as 64 bit if the BSTR format changes.
        break;
    case VT_UNKNOWN:
        V_INTERFACE_OPT(varValue.punkVal);
        break;
    case VT_DISPATCH:
        V_INTERFACE_OPT(varValue.pdispVal);
        break;
    }

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::SetVariableObject/SetVariableNumber/SetVariableVariant after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    SmartRef::CritSec CS(&m_CriticalSection);

    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::SetVariableVariant.\n");
        return DMUS_E_NOT_INIT;
    }

    HRESULT hr = m_pScriptManager->SetVariable(pwszVariableName, varValue, !!fSetRef, pErrorInfo);
    if (hr == DMUS_E_SCRIPT_VARIABLE_NOT_FOUND)
    {
        // There are also items in the script's container that the m_pScriptManager object isn't available.
        // If that's the case, we should return a more specific error message.
        IUnknown *punk = NULL;
        hr = m_pContainerDispatch->GetVariableObject(pwszVariableName, &punk);
        if (SUCCEEDED(hr))
        {
            // We don't actually need the object--it can't be set.  Just needed to find out if it's there
            // in order to return a more specific error message.
            punk->Release();
            return DMUS_E_SCRIPT_CONTENT_READONLY;
        }
    }
    return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND and empty value if variable doesn't exist in the script.
// Certain varient types such as BSTRs and interface pointers must be freed/released according to the standards for VARIANTS.
// If unsure, use VariantClear (requires oleaut32).
STDMETHODIMP
CDirectMusicScript::GetVariableVariant(WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    V_INAME(CDirectMusicScript::GetVariableVariant);
    V_BUFPTR_READ(pwszVariableName, 2);
    V_PTR_WRITE(pvarValue, VARIANT);
    V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);
    
    DMS_VariantInit(m_fUseOleAut, pvarValue);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::GetVariableObject/GetVariableNumber/GetVariableVariant after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    SmartRef::CritSec CS(&m_CriticalSection);

    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::GetVariableVariant.\n");
        return DMUS_E_NOT_INIT;
    }

    HRESULT hr = m_pScriptManager->GetVariable(pwszVariableName, pvarValue, pErrorInfo);

    if (hr == DMUS_E_SCRIPT_VARIABLE_NOT_FOUND)
    {
        // There are also items in the script's container that we need to return.
        // This is implemented by the container, which returns the IUnknown pointer directly rather than through a variant.
        IUnknown *punk = NULL;
        hr = m_pContainerDispatch->GetVariableObject(pwszVariableName, &punk);
        if (SUCCEEDED(hr))
        {
            pvarValue->vt = VT_UNKNOWN;
            pvarValue->punkVal = punk;
        }
    }

#ifdef DBG
    if (hr == DMUS_E_SCRIPT_VARIABLE_NOT_FOUND)
    {
        Trace(1, "Error: Attempt to get variable '%S' that is not defined in the script.\n", pwszVariableName);
    }
#endif

    if (!m_fUseOleAut && pvarValue->vt == VT_BSTR)
    {
        // m_fUseOleAut is false when we're using our own custom scripting engine that avoids
        // depending on oleaut32.dll.  But in this case we're returning a BSTR variant to the
        // caller.  We have to allocate this string with SysAllocString (from oleaut32)
        // because the caller is going to free it with SysFreeString--the standard thing to
        // do with a variant BSTR.
        BSTR bstrOle = DMS_SysAllocString(true, pvarValue->bstrVal); // allocate a copy with oleaut
        DMS_SysFreeString(false, pvarValue->bstrVal); // free the previous value (allocated without oleaut)
        pvarValue->bstrVal = bstrOle; // return the oleaut string to the user
        if (!bstrOle)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND if variable doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::SetVariableNumber(WCHAR *pwszVariableName, LONG lValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    VARIANT var;
    var.vt = VT_I4;
    var.lVal = lValue;
    return this->SetVariableVariant(pwszVariableName, var, false, pErrorInfo);
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND and 0 if variable doesn't exist in the script.
// Returns DISP_E_TYPEMISMATCH if variable's datatype cannot be converted to LONG.
STDMETHODIMP
CDirectMusicScript::GetVariableNumber(WCHAR *pwszVariableName, LONG *plValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    V_INAME(CDirectMusicScript::GetVariableNumber);
    V_PTR_WRITE(plValue, LONG);
    *plValue = 0;

    VARIANT var;
    HRESULT hr = this->GetVariableVariant(pwszVariableName, &var, pErrorInfo);
    if (FAILED(hr) || hr == S_FALSE || hr == DMUS_S_GARBAGE_COLLECTED)
        return hr;

    hr = DMS_VariantChangeType(m_fUseOleAut, &var, &var, 0, VT_I4);
    if (SUCCEEDED(hr))
        *plValue = var.lVal;

    // GetVariableVariant forces a BSTR to be allocated with SysAllocString;
    // so if we allocated a BSTR there, we need to free it with SysAllocString here.
    bool fUseOleAut = m_fUseOleAut;
    if (!m_fUseOleAut && var.vt == VT_BSTR)
    {
        fUseOleAut = true;
    }
    DMS_VariantClear(fUseOleAut, &var);
    return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND if variable doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::SetVariableObject(WCHAR *pwszVariableName, IUnknown *punkValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    VARIANT var;
    var.vt = VT_UNKNOWN;
    var.punkVal = punkValue;
    return this->SetVariableVariant(pwszVariableName, var, true, pErrorInfo);
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND and NULL if variable doesn't exist in the script.
// Returns DISP_E_TYPEMISMATCH if variable's datatype cannot be converted to IUnknown.
STDMETHODIMP
CDirectMusicScript::GetVariableObject(WCHAR *pwszVariableName, REFIID riid, LPVOID FAR *ppv, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    V_INAME(CDirectMusicScript::GetVariableObject);
    V_PTR_WRITE(ppv, IUnknown *);
    *ppv = NULL;

    VARIANT var;
    HRESULT hr = this->GetVariableVariant(pwszVariableName, &var, pErrorInfo);
    if (FAILED(hr) || hr == DMUS_S_GARBAGE_COLLECTED)
        return hr;

    hr = DMS_VariantChangeType(m_fUseOleAut, &var, &var, 0, VT_UNKNOWN);
    if (SUCCEEDED(hr))
        hr = var.punkVal->QueryInterface(riid, ppv);
    DMS_VariantClear(m_fUseOleAut, &var);
    return hr;
}

STDMETHODIMP
CDirectMusicScript::EnumRoutine(DWORD dwIndex, WCHAR *pwszName)
{
    V_INAME(CDirectMusicScript::EnumRoutine);
    V_BUFPTR_WRITE(pwszName, MAX_PATH);

    *pwszName = L'\0';

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::EnumRoutine after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::EnumRoutine.\n");
        return DMUS_E_NOT_INIT;
    }

    return m_pScriptManager->EnumItem(true, dwIndex, pwszName, NULL);
}

STDMETHODIMP
CDirectMusicScript::EnumVariable(DWORD dwIndex, WCHAR *pwszName)
{
    V_INAME(CDirectMusicScript::EnumRoutine);
    V_BUFPTR_WRITE(pwszName, MAX_PATH);

    *pwszName = L'\0';

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::EnumVariable after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::EnumVariable.\n");
        return DMUS_E_NOT_INIT;
    }

    int cScriptItems = 0;
    HRESULT hr = m_pScriptManager->EnumItem(false, dwIndex, pwszName, &cScriptItems);
    if (FAILED(hr))
        return hr;

    if (hr == S_FALSE)
    {
        // There are also items in the script's container that we need to report.
        assert(dwIndex >= cScriptItems);
        hr = m_pContainerDispatch->EnumItem(dwIndex - cScriptItems, pwszName);
    }

    return hr;
}

STDMETHODIMP
CDirectMusicScript::ScriptTrackCallRoutine(
        WCHAR *pwszRoutineName,
        IDirectMusicSegmentState *pSegSt,
        DWORD dwVirtualTrackID,
        bool fErrorPMsgsEnabled,
        __int64 i64IntendedStartTime,
        DWORD dwIntendedStartTimeFlags)
{
    V_INAME(CDirectMusicScript::CallRoutine);
    V_BUFPTR_READ(pwszRoutineName, 2);
    V_INTERFACE(pSegSt);

    if (m_fZombie)
    {
        Trace(1, "Error: Script track attempted to call a routine after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    SmartRef::CritSec CS(&m_CriticalSection);

    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: Unitialized Script elements in an attempt to call a Script Routine.\n");
        return DMUS_E_NOT_INIT;
    }

    return m_pScriptManager->ScriptTrackCallRoutine(
                                pwszRoutineName,
                                pSegSt,
                                dwVirtualTrackID,
                                fErrorPMsgsEnabled,
                                i64IntendedStartTime,
                                dwIntendedStartTimeFlags);
}

STDMETHODIMP
CDirectMusicScript::GetTypeInfoCount(UINT *pctinfo)
{
    V_INAME(CDirectMusicScript::GetTypeInfoCount);
    V_PTR_WRITE(pctinfo, UINT);
    *pctinfo = 0;

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicScript::GetTypeInfoCount after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return S_OK;
}

STDMETHODIMP
CDirectMusicScript::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo)
{
    *ppTInfo = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicScript::GetIDsOfNames(
        REFIID riid,
        LPOLESTR __RPC_FAR *rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID __RPC_FAR *rgDispId)
{
    if (m_fZombie)
    {
        if (rgDispId)
        {
            for (int i = 0; i < cNames; ++i)
            {
                rgDispId[i] = DISPID_UNKNOWN;
            }
        }
        Trace(1, "Error: Call of GetIDsOfNames after a script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: IDirectMusicScript::Init must be called before GetIDsOfNames.\n");
        return DMUS_E_NOT_INIT;
    }

    return m_pScriptManager->DispGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
}

STDMETHODIMP
CDirectMusicScript::Invoke(
        DISPID dispIdMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS __RPC_FAR *pDispParams,
        VARIANT __RPC_FAR *pVarResult,
        EXCEPINFO __RPC_FAR *pExcepInfo,
        UINT __RPC_FAR *puArgErr)
{
    if (m_fZombie)
    {
        if (pVarResult)
            DMS_VariantInit(m_fUseOleAut, pVarResult);
        Trace(1, "Error: Call of Invoke after the script has been garbage collected. "
                    "It is invalid to continue using a script after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    if (!m_pScriptManager || !m_pPerformance8)
    {
        Trace(1, "Error: IDirectMusicScript::Init must be called before Invoke.\n");
        return DMUS_E_NOT_INIT;
    }

    return m_pScriptManager->DispInvoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
}

//////////////////////////////////////////////////////////////////////
// Methods that allow CActiveScriptManager access to private script interfaces

IDispatch *CDirectMusicScript::GetGlobalDispatch()
{
    assert(m_pGlobalDispatch);
    return m_pGlobalDispatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engdisp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of EngineDispatch.
//

// Implements the IDispatch interface for the script that exposes its routines, variables, and type information.

#include "engcontrol.h"
#include "engexec.h"

class EngineDispatch
  : public IDispatch,
	public ITypeInfo
{
public:
	// CAudioVBScriptEngine will create EngineDispatch and pass itself as the punkParent.
	// CAudioVBScriptEngine::Close releases CAudioVBScriptEngine's ref (coming from the creation) on EngineDispatch.
	// The final call of EngineDispatch::Release in turn releases the ref (coming from holding the parent) on CAudioVBScriptEngine.
	EngineDispatch(IUnknown *punkParent, Script &script, IDispatch *pGlobalDispatch);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pDispParams,
		VARIANT *pVarResult,
		EXCEPINFO *pExcepInfo,
		UINT *puArgErr);

	// implemented ITypeInfo methods
	HRESULT STDMETHODCALLTYPE GetTypeAttr(
		/* [out] */ TYPEATTR **ppTypeAttr);
	void STDMETHODCALLTYPE ReleaseTypeAttr(
		/* [in] */ TYPEATTR *pTypeAttr);
	HRESULT STDMETHODCALLTYPE GetFuncDesc(
		/* [in] */ UINT index,
		/* [out] */ FUNCDESC **ppFuncDesc);
	void STDMETHODCALLTYPE ReleaseFuncDesc(
		/* [in] */ FUNCDESC *pFuncDesc);
	HRESULT STDMETHODCALLTYPE GetVarDesc(
		/* [in] */ UINT index,
		/* [out] */ VARDESC **ppVarDesc);
	void STDMETHODCALLTYPE ReleaseVarDesc(
		/* [in] */ VARDESC *pVarDesc);
	HRESULT STDMETHODCALLTYPE GetNames(
		/* [in] */ MEMBERID memid,
		/* [length_is][size_is][out] */ BSTR *rgBstrNames,
		/* [in] */ UINT cMaxNames,
		/* [out] */ UINT *pcNames);

	// unimplemented ITypeInfo methods
	HRESULT STDMETHODCALLTYPE GetTypeComp(
		/* [out] */ ITypeComp **ppTComp) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetRefTypeOfImplType(
		/* [in] */ UINT index,
		/* [out] */ HREFTYPE *pRefType) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetImplTypeFlags(
		/* [in] */ UINT index,
		/* [out] */ INT *pImplTypeFlags) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		/* [size_is][in] */ LPOLESTR *rgszNames,
		/* [in] */ UINT cNames,
		/* [size_is][out] */ MEMBERID *pMemId) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE Invoke(
		/* [in] */ PVOID pvInstance,
		/* [in] */ MEMBERID memid,
		/* [in] */ WORD wFlags,
		/* [out][in] */ DISPPARAMS *pDispParams,
		/* [out] */ VARIANT *pVarResult,
		/* [out] */ EXCEPINFO *pExcepInfo,
		/* [out] */ UINT *puArgErr) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetDocumentation(
		/* [in] */ MEMBERID memid,
		/* [out] */ BSTR *pBstrName,
		/* [out] */ BSTR *pBstrDocString,
		/* [out] */ DWORD *pdwHelpContext,
		/* [out] */ BSTR *pBstrHelpFile) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetDllEntry(
		/* [in] */ MEMBERID memid,
		/* [in] */ INVOKEKIND invKind,
		/* [out] */ BSTR *pBstrDllName,
		/* [out] */ BSTR *pBstrName,
		/* [out] */ WORD *pwOrdinal) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetRefTypeInfo(
		/* [in] */ HREFTYPE hRefType,
		/* [out] */ ITypeInfo **ppTInfo) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE AddressOfMember(
		/* [in] */ MEMBERID memid,
		/* [in] */ INVOKEKIND invKind,
		/* [out] */ PVOID *ppv) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE CreateInstance(
		/* [in] */ IUnknown *pUnkOuter,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ PVOID *ppvObj) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetMops(
		/* [in] */ MEMBERID memid,
		/* [out] */ BSTR *pBstrMops) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetContainingTypeLib(
		/* [out] */ ITypeLib **ppTLib,
		/* [out] */ UINT *pIndex) { assert(false); return E_NOTIMPL; }

private:
	// Data
	long m_cRef;
	SmartRef::ComPtr<IUnknown> m_scomParent;
	Script &m_script;
	Executor m_exec;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engcontrol.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of a script's control structures.
//

#include "stdinc.h"
#include "engcontrol.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engcontrol.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of a script's control structures.
//

#pragma once

#include "englookup.h"
#include "englex.h"

//////////////////////////////////////////////////////////////////////
// Statement structures

// forward decls and collections
class Routine;
typedef Slots<Routine> Routines;
class Variable;
typedef Slots<Variable> Variables;
class ReferenceName;
typedef Slots<ReferenceName> ReferenceNames;
class VariableReference;
typedef Slots<VariableReference> VariableReferences;
class Statement;
typedef Slots<Statement> Statements;
class Value;
typedef Slots<Value> Values;
class Call;
typedef Slots<Call> Calls;
class ExprBlock;
typedef Slots<ExprBlock> ExprBlocks;
class IfBlock;
typedef Slots<IfBlock> IfBlocks;
class Assignment;
typedef Slots<Assignment> Assignments;

class Variable
{
public:
	Variable(Strings::index _istrIdentifier, DISPID _dispid = DISPID_UNKNOWN) : istrIdentifier(_istrIdentifier), dispid(_dispid) {}

	Strings::index istrIdentifier;
	DISPID dispid; // this is set to a value other than DISPID_UNKNOWN if the variable is a member of the global dispatch instead of an item in the script itself

private:
	friend class SmartRef::Vector<Variable>;
	Variable() {}
};

// Names used in a sequence for dereferencing attributes or function calls.
// For example, a and b in "a.b" or x and y in "x.y(3)".
class ReferenceName
{
public:
	ReferenceName(Strings::index _istrIdentifier) : istrIdentifier(_istrIdentifier) {}

	Strings::index istrIdentifier; // -1 is used to end a sequence of names

private:
	friend class SmartRef::Vector<ReferenceName>;
	ReferenceName() {}
};

class VariableReference
{
public:
	enum kind { _global, _local };
	VariableReference(kind _k, ReferenceNames::index _irname, Variables::index _ivar)
		: k(_k), irname(_irname), ivar(_ivar) {}

	kind k;
	ReferenceNames::index irname;
	Variables::index ivar; // slot of the first name within (global/local/temporary) variables

private:
	friend class SmartRef::Vector<VariableReference>;
	VariableReference() {}
};

class Value
{
public:
	// dummy types to differentiate constructors
	enum cons_numvalue {};
	enum cons_strvalue {};
	enum cons_varref {};

	enum kind { _numvalue, _strvalue, _varref };

	Value(cons_numvalue e, int iVal) : k(_numvalue) { inumvalue = iVal; }
	Value(cons_strvalue e, Strings::index iStr) : k(_strvalue) { istrvalue = iStr; }
	Value(cons_varref e, VariableReferences::index _ivarref) : k(_varref) { ivarref = _ivarref; }

	kind k;
	union
	{
		int inumvalue;
		Strings::index istrvalue;
		VariableReferences::index ivarref;
	};

private:
	friend class SmartRef::Vector<Value>;
	Value() {}
};

class Call
{
public:
	// dummy types to differentiate constructors
	enum cons_global {};
	enum cons_dereferenced {};

	enum kind { _global, _dereferenced };

	Call() {} // all fields are set after creation

	kind k;
	union
	{
		Strings::index istrname;			// _global
		VariableReferences::index ivarref;	// _dereferenced
	};
	ExprBlocks::index iexprParams; // doubly-terminated list of lists. each parameter is terminated with an _end block and the final parameter is also terminated with a second _end block.
};

class ExprBlock
{
public:
	// dummy types to differentiate constructors
	enum cons_end {};
	enum cons_op {};
	enum cons_val {};
	enum cons_call {};
	enum cons_omitted {}; // used only in a routine call, stands for an omitted parameter

	enum kind { _end = 0, _op, _val, _call, _omitted };

	// Note: For unary - (negation), TOKEN_sub is used instead of TOKEN_op_minus.
	ExprBlock(cons_end e) : k(_end) {}
	ExprBlock(cons_op e, Token __op) : k(_op) { op = __op; assert(CheckOperatorType(op, true, true, true, false) || op == TOKEN_sub); }
	ExprBlock(cons_val e, Values::index _ival) : k(_val) { ival = _ival; }
	ExprBlock(cons_call e, Calls::index _icall) : k(_call) { icall = _icall; }
	ExprBlock(cons_omitted e) : k(_omitted) {}

	operator bool() { return k != _end; }

	kind k;

	union
	{
		Token op;
		Values::index ival;
		Calls::index icall;
	};

private:
	friend class SmartRef::Vector<ExprBlock>;
	friend class SmartRef::Stack<ExprBlock>;
	ExprBlock() {}
};

class Assignment
{
public:
	Assignment(bool _fSet, VariableReferences::index _ivarrefLHS, ExprBlocks::index _iexprRHS) : fSet(_fSet), ivarrefLHS(_ivarrefLHS), iexprRHS(_iexprRHS) {}

	bool fSet;
	VariableReferences::index ivarrefLHS;
	ExprBlocks::index iexprRHS;

private:
	friend class SmartRef::Vector<Assignment>;
	Assignment() {}
};

class IfBlock
{
public:
	// _end: end of blocks without an 'else'
	// _else: end of blocks with an 'else'
	// _cond: a conditional block, from 'if' (first one) or 'elseif' (later ones)
	enum kind { _end = 0, _else, _cond };

	IfBlock() : k(_end) {}
	IfBlock(Statements::index _istmtBlock) : k(_else), istmtBlock(_istmtBlock) {}
	IfBlock(ExprBlocks::index _iexprCondition, Statements::index _istmtBlock) : k(_cond), iexprCondition(_iexprCondition), istmtBlock(_istmtBlock) {}

	kind k;
	ExprBlocks::index iexprCondition; // only used by cond kind
	Statements::index istmtBlock; // not used by end kind
};

class Statement
{
public:
	typedef int index;

	// dummy types to differentiate constructors
	enum cons_end {};
	enum cons_asgn {};
	enum cons_if {};
	enum cons_call {};

	enum kind { _end = 0, _if, _asgn, _call }; // _end is used as a terminator for a block of statements

	Statement(cons_end e, int _iLine) : k(_end), iLine(_iLine) {}
	Statement(cons_asgn e, Assignments::index _iasgn, int _iLine) : k(_asgn), iLine(_iLine) { iasgn = _iasgn; }
	Statement(cons_if e, int _iLine) : k(_if), iLine(_iLine) { iif = 0; istmtIfTail = 0; }
	Statement(cons_call e, Calls::index _icall, int _iLine) : k(_call), iLine(_iLine) { icall = _icall; }

	operator bool() { return k != _end; }

	kind k;
	int iLine;
	union
	{
		Assignments::index iasgn;
		struct
		{
			IfBlocks::index iif;
			Statements::index istmtIfTail;
		};
		Calls::index icall;
	};

private:
	friend class SmartRef::Vector<Statement>;
	Statement() {}
};

class Routine
{
public:
	Routine(Strings::index _istrIdentifier) : istrIdentifier(_istrIdentifier), istmtBody(0), ivarNextLocal(0) {}

	Strings::index istrIdentifier;
	Statements::index istmtBody;
	Variables::index ivarNextLocal; // while parsing, this is the next local slot to use.  by runtime, this as the total number of local slots needed by the routine.

private:
	friend class SmartRef::Vector<Routine>;
	Routine() {}
};

class Script
{
public:
	Script() {}

	Routines routines;
	Variables globals;
	Strings strings;
	Statements statements;
	ReferenceNames rnames;
	VariableReferences varrefs;
	Values vals;
	Calls calls;
	ExprBlocks exprs;
	IfBlocks ifs;
	Assignments asgns;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2001 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
    if(pIStream == NULL || ppIDMStream == NULL)
    {
        return E_INVALIDARG;            
    }

    if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    ((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CDirectMusicStream::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDMStream)
    {
        *ppv = static_cast<IDMStream*>(this);
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }

    m_pStream = pStream;
    
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }
    
    return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

    FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
    {
        ckidFind = lpck->ckid;
        fccTypeFind = NULL;
    }
    else if(wFlags & MMIO_FINDRIFF)
    {
        ckidFind = FOURCC_RIFF;
        fccTypeFind = lpck->fccType;
    }
    else if(wFlags & MMIO_FINDLIST)
    {
        ckidFind = FOURCC_LIST;
        fccTypeFind = lpck->fccType;
    }
    else
    {
        ckidFind = fccTypeFind = NULL;
    }

    lpck->dwFlags = 0L;

    for(;;)
    {
        HRESULT hr;
        LARGE_INTEGER li;
        ULARGE_INTEGER uli;
        ULONG cbRead;

        // Read the chunk header
        hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // Store the offset of the data part of the chunk
        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lpck->dwDataOffset = uli.LowPart;
        }

        // See if the chunk is within the parent chunk (if given)
        if((lpckParent != NULL) &&
           (lpck->dwDataOffset - 8L >=
           lpckParent->dwDataOffset + lpckParent->cksize))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // If the chunk is a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

            if(FAILED(hr) || (cbRead != sizeof(DWORD)))
            {
                Trace(1,"Error: Unable to read file.\n");
                return DMUS_E_DESCEND_CHUNK_FAIL;
            }
        }
        else
        {
            lpck->fccType = NULL;
        }

        // If this is the chunk we're looking for, stop looking
        if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
           ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
        {
            break;
        }

        // Ascend out of the chunk and try again
        HRESULT w = Ascend(lpck, 0);
        if(FAILED(w))
        {
            return w;
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    assert(lpck);

    HRESULT hr;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;
    
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG lOffset;           // current offset in file
        LONG lActualSize;   // actual size of chunk data

        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lOffset = uli.LowPart;
        }
        
        if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }

        if(LOWORD(lActualSize) & 1)
        {
            ULONG cbWritten;

            // Chunk size is odd -- write a null pad byte
            hr = m_pStream->Write("\0", 1, &cbWritten); 
            
            if(FAILED(hr) || cbWritten != 1)
            {
                Trace(1,"Error: Unable to write file.\n");
                return DMUS_E_CANNOTWRITE;
            }
        
        }
    
        if(lpck->cksize == (DWORD)lActualSize)
        {
            return S_OK;
        }

        // Fix the chunk header
        lpck->cksize = lActualSize;

        li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
        hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }

        ULONG cbWritten;

        hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
        
        if(FAILED(hr) || cbWritten != sizeof(DWORD))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }
    }

    // Seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
    hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

    // Store the offset of the data part of the chunk
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }
    else
    {
        lOffset = uli.LowPart;
    }
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
    {
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
    else if(wFlags & MMIO_CREATELIST)
    {
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    }
    else
    {
        iBytes = 2 * sizeof(DWORD);
    }

    // Write the chunk header
    ULONG cbWritten;

    hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
        
    if(FAILED(hr) || cbWritten != iBytes)
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTWRITE;
    }

    lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
            }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engdisp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of EngineDispatch.
//

#include "stdinc.h"
#include "enginc.h"
#include "engdisp.h"
#include "limits"
#include "oleaut.h"

//////////////////////////////////////////////////////////////////////
// Global constants

const DISPID g_dispidFirstRoutine = 1;
const DISPID g_dispidFirstGlobal = 1000001;

//////////////////////////////////////////////////////////////////////
// ASCII comparison of WCHAR and char strings

bool wcsstrimatch(const WCHAR *pwsz, const char *pasz)
{
	for (;;)
	{
		if (*pwsz > std::numeric_limits<char>::max())
			return false;

		char ch1 = (char)tolower((char)*pwsz++); //  make sure tolower is the right kind of function
		char ch2 = (char)tolower((char)*pasz++);
		if (ch1 != ch2)
			return false;

		if (!ch1)
			return true;
	}
}

//////////////////////////////////////////////////////////////////////
// Creation

EngineDispatch::EngineDispatch(IUnknown *punkParent, Script &script, IDispatch *pGlobalDispatch)
  : m_cRef(1),
	m_scomParent(punkParent),
	m_script(script),
	m_exec(script, pGlobalDispatch)
{
	punkParent->AddRef();
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
EngineDispatch::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(EngineDispatch::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDispatch)
	{
		*ppv = static_cast<IDispatch*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
EngineDispatch::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
EngineDispatch::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDispatch

STDMETHODIMP
EngineDispatch::GetTypeInfoCount(UINT *pctinfo)
{
	V_INAME(EngineDispatch::GetTypeInfoCount);
	V_PTR_WRITE(pctinfo, *pctinfo);

	*pctinfo = 1;
	return S_OK;
}

STDMETHODIMP
EngineDispatch::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
	V_INAME(EngineDispatch::GetTypeInfo);
	V_PTR_WRITE(ppTInfo, *ppTInfo);

	if (iTInfo != 0)
		return DISP_E_BADINDEX;

	*ppTInfo = static_cast<ITypeInfo *>(this);
	this->AddRef();
	return S_OK;
}

STDMETHODIMP
EngineDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID *rgDispId)
{
	V_INAME(EngineDispatch::GetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	//  Possible optimization: sort the routines/globals so that we can bsearch for names.

	// See if we have a routine with the first name
	Routines::index irtnLast = m_script.routines.Next();
	for (Routines::index irtn = 0; irtn < irtnLast; ++irtn)
	{
		if (wcsstrimatch(rgszNames[0], m_script.strings[m_script.routines[irtn].istrIdentifier]))
		{
			rgDispId[0] = g_dispidFirstRoutine + irtn;
			break;
		}
	}

	if (rgDispId[0] == DISPID_UNKNOWN)
	{
		// See if we have a global variable with the first name
		Variables::index ivarLast = m_script.globals.Next();
		for (Variables::index ivar = g_cBuiltInConstants; ivar < ivarLast; ++ivar)
		{
			Variable &variable = m_script.globals[ivar];
			if (variable.dispid == DISPID_UNKNOWN &&   // variable must be in script (not member of global dispatch)
					wcsstrimatch(rgszNames[0], m_script.strings[variable.istrIdentifier]))
			{
				rgDispId[0] = g_dispidFirstGlobal + ivar;
				break;
			}
		}
	}

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

STDMETHODIMP
EngineDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pDispParams,
		VARIANT *pVarResult,
		EXCEPINFO *pExcepInfo,
		UINT *puArgErr)
{
	V_INAME(EngineDispatch::Invoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(puArgErr, UINT);

	// Additional parameter validation

	bool fReturnValueUsingOleAut = g_fUseOleAut || riid != g_guidInvokeWithoutOleaut;
	// This is true unless g_fUseOleAut is false (script engine is set to always use oleaut32.dll
	// and riid is g_guidInvokeWithoutOleaut (caller expects this not to return values allocated with
	// oleaut32.dll.  See oleaut.h for more info.

	if (fReturnValueUsingOleAut && riid != IID_NULL)
	{
		return DISP_E_UNKNOWNINTERFACE;
	}

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	HRESULT hr = S_OK;
	if (dispIdMember < g_dispidFirstGlobal)
	{
		// it's a routine
		if (!(wFlags & DISPATCH_METHOD))
			return DISP_E_MEMBERNOTFOUND;

		Routines::index irtn = dispIdMember - g_dispidFirstRoutine;
		if (irtn >= m_script.routines.Next())
			return DISP_E_MEMBERNOTFOUND;

		if (pDispParams->cArgs > 0)
			return DISP_E_BADPARAMCOUNT;
		if (pDispParams->cNamedArgs > 0)
			return DISP_E_NONAMEDARGS;

		if (pVarResult)
		{
			assert(false);
			return E_UNEXPECTED;
		}

		hr = m_exec.ExecRoutine(irtn, pExcepInfo);
	}
	else
	{
		// it's a global variable
		Variables::index ivar = dispIdMember - g_dispidFirstGlobal;
		if (ivar >= m_script.globals.Next())
			return DISP_E_MEMBERNOTFOUND;

		if (wFlags & DISPATCH_PROPERTYGET)
		{
			if (pDispParams->cArgs > 0)
				return DISP_E_BADPARAMCOUNT;
			if (pDispParams->cNamedArgs > 0)
				return DISP_E_NONAMEDARGS;

			if (pVarResult)
			{
				DMS_VariantInit(fReturnValueUsingOleAut, pVarResult);
				DMS_VariantCopy(fReturnValueUsingOleAut, pVarResult, &m_exec.GetGlobal(ivar));
			}

			return S_OK;
		}
		else
		{
			if (!(wFlags & (DISPATCH_PROPERTYPUTREF | DISPATCH_PROPERTYPUT)))
				return DISP_E_MEMBERNOTFOUND;

			bool fPutRef = !!(wFlags & DISPATCH_PROPERTYPUTREF);
			assert(fPutRef || wFlags & DISPATCH_PROPERTYPUT);

			if (pDispParams->cArgs != 1)
				return DISP_E_BADPARAMCOUNT;
			if (pDispParams->cNamedArgs != 1)
				return DISP_E_BADPARAMCOUNT;
			if (*pDispParams->rgdispidNamedArgs != DISPID_PROPERTYPUT)
				return DISP_E_PARAMNOTFOUND;

			if (pVarResult)
				return E_INVALIDARG;

			hr = m_exec.SetGlobal(ivar, pDispParams->rgvarg[0], fPutRef, pExcepInfo);
		}
	}

	// If an exception occurred, we need to convert the error strings into our own kind of BSTR.
	if (hr == DISP_E_EXCEPTION)
		ConvertOleAutExceptionBSTRs(false, fReturnValueUsingOleAut, pExcepInfo);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// ITypeInfo

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetTypeAttr(
		/* [out] */ TYPEATTR **ppTypeAttr)
{
	V_INAME(EngineDispatch::GetTypeAttr);
	V_PTR_WRITE(ppTypeAttr, *ppTypeAttr);

	*ppTypeAttr = new TYPEATTR;
	if (!*ppTypeAttr)
		return E_OUTOFMEMORY;

	Zero(*ppTypeAttr);

	(*ppTypeAttr)->cFuncs = (unsigned short)m_script.routines.Next();

	// Count the global variables  -- necessary because some are on the global dispatch
	// and we don't want to report them.
	int cVars = 0;
	Variables::index iLastGlobal = m_script.globals.Next();
	for (Variables::index  iGlobal = g_cBuiltInConstants; iGlobal < iLastGlobal; ++iGlobal)
	{
		if (m_script.globals[iGlobal].dispid == DISPID_UNKNOWN)
			++cVars;
	}
	(*ppTypeAttr)->cVars = (unsigned short)cVars;

	return S_OK;
}

void STDMETHODCALLTYPE
EngineDispatch::ReleaseTypeAttr(
		/* [in] */ TYPEATTR *pTypeAttr)
{
	assert(!IsBadReadPtr(pTypeAttr, sizeof(*pTypeAttr)));
	delete pTypeAttr;
}

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetFuncDesc(
		/* [in] */ UINT index,
		/* [out] */ FUNCDESC **ppFuncDesc)
{
	V_INAME(EngineDispatch::GetFuncDesc);
	V_PTR_WRITE(ppFuncDesc, *ppFuncDesc);
	if (index >= m_script.routines.Next())
		return E_INVALIDARG;

	*ppFuncDesc = new FUNCDESC;
	if (!*ppFuncDesc)
		return E_OUTOFMEMORY;

	Zero(*ppFuncDesc);
	(*ppFuncDesc)->funckind = FUNC_DISPATCH;
	(*ppFuncDesc)->invkind = INVOKE_FUNC;
	(*ppFuncDesc)->cParams = 0;
	(*ppFuncDesc)->memid = index + g_dispidFirstRoutine;

	return S_OK;
}

void STDMETHODCALLTYPE
EngineDispatch::ReleaseFuncDesc(
		/* [in] */ FUNCDESC *pFuncDesc)
{
	assert(!IsBadReadPtr(pFuncDesc, sizeof(*pFuncDesc)));
	delete pFuncDesc;
}

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetVarDesc(
		/* [in] */ UINT index,
		/* [out] */ VARDESC **ppVarDesc)
{
	V_INAME(EngineDispatch::GetVarDesc);
	V_PTR_WRITE(ppVarDesc, *ppVarDesc);

	// Count until we find the global (non-dispatch-based) variable at the index position.
	UINT cFuncs = 0;
	Variables::index iLastGlobal = m_script.globals.Next();
	for (Variables::index  iGlobal = g_cBuiltInConstants; iGlobal < iLastGlobal; ++iGlobal)
	{
		if (m_script.globals[iGlobal].dispid == DISPID_UNKNOWN)
		{
			if (cFuncs == index)
				break;
			else
				++cFuncs;
		}
	}

	if (cFuncs < index)
	{
		// there aren't that many variables
		return E_INVALIDARG;
	}

	*ppVarDesc = new VARDESC;
	if (!*ppVarDesc)
		return E_OUTOFMEMORY;

	Zero(*ppVarDesc);
	(*ppVarDesc)->varkind = VAR_DISPATCH;
	(*ppVarDesc)->memid = iGlobal + g_dispidFirstGlobal;

	return S_OK;
}

void STDMETHODCALLTYPE
EngineDispatch::ReleaseVarDesc(
		/* [in] */ VARDESC *pVarDesc)
{
	assert(!IsBadReadPtr(pVarDesc, sizeof(*pVarDesc)));
	delete pVarDesc;
}

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetNames(
		/* [in] */ MEMBERID memid,
		/* [length_is][size_is][out] */ BSTR *rgBstrNames,
		/* [in] */ UINT cMaxNames,
		/* [out] */ UINT *pcNames)
{
	V_INAME(EngineDispatch::GetNames);
	if (memid < g_dispidFirstRoutine)
		return E_INVALIDARG;
	V_PTR_WRITE(rgBstrNames, *rgBstrNames);
	if (cMaxNames != 1)
		return E_INVALIDARG;
	V_PTR_WRITE(pcNames, *pcNames);

	assert(g_dispidFirstRoutine < g_dispidFirstGlobal);
	Strings::index iStr = 0;
	if (memid < g_dispidFirstGlobal)
	{
		const int iSlot = memid - g_dispidFirstRoutine;
		if (iSlot >= m_script.routines.Next())
			return E_INVALIDARG;
		iStr = m_script.routines[iSlot].istrIdentifier;
	}
	else
	{
		const int iSlot = memid - g_dispidFirstGlobal;
		if (iSlot >= m_script.globals.Next())
			return E_INVALIDARG;
		iStr = m_script.globals[iSlot].istrIdentifier;
	}

	SmartRef::WString wstrName = m_script.strings[iStr];
	if (!wstrName)
		return E_OUTOFMEMORY;
	*rgBstrNames = DMS_SysAllocString(g_fUseOleAut, wstrName);
	if (!*rgBstrNames)
		return E_OUTOFMEMORY;

	*pcNames = 1;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engerror.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CActiveScriptError.
//

#include "stdinc.h"
#include "enginc.h"
#include "engerror.h"
#include "oleaut.h"

CActiveScriptError::CActiveScriptError(HRESULT hr, Lexer &lexer, const char *pszDescription)
  : m_scode(hr),
	m_wstrDescription(pszDescription),
	m_pwszSource(NULL),
	m_ulLineNumber(lexer.line() - 1), // line is reported zero-based from IActiveScriptError
	m_lCharacterPosition(lexer.column() - 1) // character position is reported zero-based from IActiveScriptError
{
	assert(pszDescription && lexer.line() > 0 && lexer.column() > 0);

	// build the near text from the lexer's current position to the end of the line
	for (const WCHAR *pwsz = lexer.m_p; *pwsz && *pwsz != '\n' && *pwsz != '\r'; ++pwsz)
	{}

	m_wstrSourceLine.Assign(lexer.m_p, pwsz - lexer.m_p);

	// fill in the source text based on hresult
	if (hr == DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR)
	{
		m_pwszSource = L"Microsoft AudioVBScript syntax error";
	}
	else if (hr == DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR)
	{
		m_pwszSource = L"Microsoft AudioVBScript runtime error";
	}
	else
	{
		assert(hr == DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE);
		m_pwszSource = L"Microsoft AudioVBScript operation failure";
	}
}

STDMETHODIMP
CActiveScriptError::GetExceptionInfo(
		/* [out] */ EXCEPINFO *pexcepinfo)
{
	V_INAME(CActiveScriptError::GetExceptionInfo);
	V_PTR_WRITE(pexcepinfo, *pexcepinfo);

	Zero(pexcepinfo);
	pexcepinfo->scode = m_scode;

	if (m_wstrDescription)
		pexcepinfo->bstrDescription = DMS_SysAllocString(g_fUseOleAut, m_wstrDescription);
	if (!pexcepinfo->bstrDescription)
		return E_OUTOFMEMORY;

	pexcepinfo->bstrSource = DMS_SysAllocString(g_fUseOleAut, m_pwszSource);
	if (!pexcepinfo->bstrSource)
		return E_OUTOFMEMORY;

	return S_OK;
}

STDMETHODIMP
CActiveScriptError::GetSourcePosition(
		/* [out] */ DWORD *pdwSourceContext,
		/* [out] */ ULONG *pulLineNumber,
		/* [out] */ LONG *plCharacterPosition)
{
	V_INAME(CActiveScriptError::GetSourcePosition);
	V_PTR_WRITE_OPT(pdwSourceContext, *pdwSourceContext);
	V_PTR_WRITE(pulLineNumber, *pulLineNumber);
	V_PTR_WRITE(plCharacterPosition, *plCharacterPosition);

	assert(!pdwSourceContext);
	*pulLineNumber = m_ulLineNumber;
	*plCharacterPosition = m_lCharacterPosition;
	return S_OK;
}

STDMETHODIMP
CActiveScriptError::GetSourceLineText(
		/* [out] */ BSTR *pbstrSourceLine)
{
	V_INAME(CActiveScriptError::GetSourceLineText);
	V_PTR_WRITE(pbstrSourceLine, *pbstrSourceLine);

	*pbstrSourceLine = NULL;
	if (m_wstrSourceLine)
		*pbstrSourceLine = DMS_SysAllocString(g_fUseOleAut, m_wstrSourceLine);
	if (!*pbstrSourceLine)
		return E_OUTOFMEMORY;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engerror.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CActiveScriptError.  Object that implements IActiveScriptError for returning error information from the script engine.
//

#pragma once

#include "englex.h"
#include "activescript.h"
#include "unkhelp.h"

class CActiveScriptError
  : public IActiveScriptError,
	public ComSingleInterface
{
public:
	ComSingleInterfaceUnknownMethods(IActiveScriptError)

	CActiveScriptError(HRESULT hr, Lexer &lexer, const char *pszDescription);

	// IActiveScriptError
	STDMETHOD(GetExceptionInfo)(
		/* [out] */ EXCEPINFO *pexcepinfo);
	STDMETHOD(GetSourcePosition)(
		/* [out] */ DWORD *pdwSourceContext,
		/* [out] */ ULONG *pulLineNumber,
		/* [out] */ LONG *plCharacterPosition);
	STDMETHOD(GetSourceLineText)(
		/* [out] */ BSTR *pbstrSourceLine);

private:
	HRESULT m_scode;
	SmartRef::WString m_wstrDescription;
	const WCHAR *m_pwszSource;

	ULONG m_ulLineNumber;
	LONG m_lCharacterPosition;
	SmartRef::WString m_wstrSourceLine;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engexec.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of Executor.
//

#include "stdinc.h"
#include "enginc.h"
#include "engexec.h"
#include "math.h"
#include "packexception.h"

//////////////////////////////////////////////////////////////////////
// CallStack

HRESULT
CallStack::Push(UINT i)
{
	UINT iInitialSize = m_vec.size();
	if (!m_vec.AccessTo(m_iNext + i - 1))
		return E_OUTOFMEMORY;
	
	UINT iNewNext = m_iNext + i;
	for (UINT iInit = std::_MAX<UINT>(m_iNext, iInitialSize); iInit < iNewNext; ++iInit)
		DMS_VariantInit(g_fUseOleAut, &m_vec[iInit]);

	m_iNext = iNewNext;
	return S_OK;
}

void
CallStack::PopTo(UINT i)
{
	for (UINT iInit = i; iInit < m_iNext; ++iInit)
		DMS_VariantClear(g_fUseOleAut, &m_vec[iInit]);

	m_iNext = std::_MIN<UINT>(m_iNext, i);
}

//////////////////////////////////////////////////////////////////////
// Executor

Executor::Executor(Script &script, IDispatch *pGlobalDispatch)
  : m_fInitialized(false),
	m_script(script),
	m_scomGlobalDispatch(pGlobalDispatch)
{
	DMS_VariantInit(g_fUseOleAut, &m_varEmpty);
}

Executor::~Executor()
{
	m_stack.PopTo(0); // clear any varients on the stack that might be holding refs
}

HRESULT
Executor::SetGlobal(Variables::index ivar, const VARIANT &varValue, bool fPutRef, EXCEPINFO *pExcepInfo)
{
	HRESULT hr = EnsureInitialized();
	if (FAILED(hr))
		return hr;

	hr = ErrorIfImproperRef(varValue, fPutRef, m_script.globals[ivar].istrIdentifier, pExcepInfo);
	if (FAILED(hr))
		return hr;

	assert(ivar <= m_script.globals.Next());
	return DMS_VariantCopy(g_fUseOleAut, &m_stack[ivar], &varValue);
}

const VARIANT &
Executor::GetGlobal(Variables::index ivar)
{
	if (!m_fInitialized)
	{
		// No variable gets or routine calls have been performed yet (or they failed).
		// But we don't want to return an error here.  Since nothing's been used yet, the correct
		// thing to do is to return an empty value.
		return m_varEmpty;
	}

	assert(ivar <= m_script.globals.Next());
	return m_stack[ivar];
}

HRESULT
Executor::ExecRoutine(Routines::index irtn, EXCEPINFO *pExcepInfo)
{
	HRESULT hr = EnsureInitialized();
	if (FAILED(hr))
		return hr;

	Routine r = m_script.routines[irtn];

	UINT iLocals = m_stack.Next();
	hr = m_stack.Push(r.ivarNextLocal);
	if (FAILED(hr))
		return hr;

	hr = ExecStatements(r.istmtBody, pExcepInfo, iLocals);
	m_stack.PopTo(iLocals);
	return hr;
}

HRESULT
Executor::EnsureInitialized()
{
	if (m_fInitialized)
		return S_OK;

	// we'll keep the global variables right at the bottom of the stack
	// this function ensures that they get pushed on before any operations that use them
	HRESULT hr = m_stack.Push(m_script.globals.Next());
	if (FAILED(hr))
		return hr;

	// Also set the first items to the build in constant values True, False, and Nothing.
	// See also engparse.cpp which creates these global variables before parsing each script.
	if (m_stack.Next() < 3)
	{
		assert(false);
		return E_UNEXPECTED;
	}
	VARIANT &vTrue = m_stack[0];
	vTrue.vt = VT_I4;
	vTrue.lVal = VARIANT_TRUE;
	VARIANT &vFalse = m_stack[1];
	vFalse.vt = VT_I4;
	vFalse.lVal = VARIANT_FALSE;
	VARIANT &vNothing = m_stack[2];
	vNothing.vt = VT_UNKNOWN;
	vNothing.punkVal = NULL;
	
	m_fInitialized = true;
	return S_OK;
}

HRESULT
Executor::Error(EXCEPINFO *pExcepInfo, bool fOperation, const WCHAR *pwszBeginning, const char *paszMiddle, const WCHAR *pwszEnd)
{
	if (!pExcepInfo)
	{
		assert(false); // our script host should always request error info
		return DISP_E_EXCEPTION;
	}

	// NULL for beginning, middle, or end treated as empty string
	if (!pwszBeginning)
		pwszBeginning = L"";
	if (!paszMiddle)
		paszMiddle = "";
	if (!pwszEnd)
		pwszEnd = L"";

	pExcepInfo->wCode = 0;
	pExcepInfo->wReserved = 0;
	pExcepInfo->bstrSource = DMS_SysAllocString(g_fUseOleAut, fOperation ? L"Microsoft AudioVBScript Operation Failed" : L"Microsoft AudioVBScript Runtime Error");

	SmartRef::WString wstrMiddle = paszMiddle;
	WCHAR *pwszDescription = NULL;
	if (wstrMiddle)
	{
		pwszDescription = new WCHAR[wcslen(pwszBeginning) + wcslen(wstrMiddle) + wcslen(pwszEnd) + 1];
	}
	if (!pwszDescription)
	{
		// Oh well.  Just return no description if we're out of memory.
		pExcepInfo->bstrDescription = NULL;
	}
	else
	{
		wcscpy(pwszDescription, pwszBeginning);
		wcscat(pwszDescription, wstrMiddle);
		wcscat(pwszDescription, pwszEnd);
		pExcepInfo->bstrDescription = DMS_SysAllocString(g_fUseOleAut, pwszDescription);
		delete[] pwszDescription;
	}
	pExcepInfo->bstrHelpFile = NULL;
	pExcepInfo->pvReserved = NULL;
	pExcepInfo->pfnDeferredFillIn = NULL;
	pExcepInfo->scode = fOperation ? DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE : DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR;

	return DISP_E_EXCEPTION;
}

HRESULT
Executor::ErrorIfImproperRef(const VARIANT &v, bool fRef, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo)
{
	bool fIsObject = v.vt == VT_DISPATCH || v.vt == VT_UNKNOWN;
	if (fRef != fIsObject)
	{
		if (fRef)
			return ErrorObjectRequired(istrIdentifier, pExcepInfo);
		else
			return Error(pExcepInfo, false, L"Type mismatch: '", m_script.strings[istrIdentifier], L"'.  Likely cause is missing Set statement.");
	}

	return S_OK;
}

// Check for the error HRESULTs returned by IDispatch::Invoke.  Those that we expect to occur in AudioVBScript need to
// be converted into exception (DISP_E_EXCEPTION) so that the user gets a nice error message.

// The first parameter lets us know the kind of Invoke call that was made (property get, property set, function/sub call)
// so that we can tailor the message.

HRESULT
Executor::ErrorIfInvokeProblem(DispatchOperationType e, HRESULT hr, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo)
{
	if (SUCCEEDED(hr) || HRESULT_FACILITY(hr) != FACILITY_DISPATCH || hr == DISP_E_EXCEPTION)
		return hr;

	const char *pszName = m_script.strings[istrIdentifier];
	if (hr == DISP_E_BADPARAMCOUNT)
	{
		// This can happen with a _call (obviously) and also with a get because property gets are also treated as function
		// calls with no arguments.  "x=GetMasterVolume" is valid but "x=Trace" would produce this error.  But I can't
		// see that this should occur with property sets.
		assert(e == _get || e == _call);

		return Error(pExcepInfo, false, L"Wrong number of parameters in call to '", pszName, L"'");
	}
	else if (hr == DISP_E_MEMBERNOTFOUND)
	{
		if (e == _call)
		{
			// Because Invoke was called, GetIDsOfNames must have succeeded, so the thing's name exists
			// but it must not be a method.
			return Error(pExcepInfo, false, L"Type mismatch: '", pszName, L"' is not a routine or method");
		}
		else if (e == _put || e == _putref)
		{
			return Error(pExcepInfo, false, L"Type mismatch: '", pszName, L"' is not a variable or is a read-only property");
		}
		else
		{
			// As mentioned above, a property get can be treated as either gets or function calls so they
			// shouldn't fail in this way.
			assert(false);
		}
	}
	else if (hr == DISP_E_TYPEMISMATCH)
	{
		// This indicates that one of the parameters was of the wrong type.
		if (e == _call)
		{
			return Error(pExcepInfo, false, L"Type mismatch: a parameter in call to '", pszName, L"' is not of the expected type");
		}
		else if (e == _put || e == _putref)
		{
			return Error(pExcepInfo, false, L"Type mismatch: value assigned to '", pszName, L"' is not of the expected type");
		}
		else
		{
			// Property gets don't have any parameters so this shouldn't happen.
			assert(false);
		}
	}
	else if (hr == DISP_E_PARAMNOTOPTIONAL)
	{
		if (e == _call)
		{
			return Error(pExcepInfo, false, L"A required parameter was omitted in call to '", pszName, L"'");
		}
		else
		{
			// Only calls should send an optional parameters.
			assert(false);
		}
	}

	// The other errors shouldn't normally occur in AudioVBScript.  They could occur if someone was
	// doing something ususual in a custom IDispatch interface, but we'll consider them exceptional cases and
	// just return the error HRESULT (meaning the user won't get a friendly text message).  Assert so we'll
	// find out if there are regular cases where this is happening in our testing.
	assert(false);

	// DISP_E_BADVARTYPE: We just use standard variant types.
	// DISP_E_NONAMEDARGS: We don't do named args.
	// DISP_E_OVERFLOW: AudioVBScript uses VT_I4 and so do our DMusic dispatch interfaces.
	// DISP_E_PARAMNOTFOUND: Only applies with named args.
	// DISP_E_UNKNOWNINTERFACE, DISP_E_UNKNOWNLCID: AudioVBScript uses calling convention and locale matching the DMusic dispatch interfaces.

	return hr;
}

HRESULT
Executor::ExecStatements(Statements::index istmt, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;

	for (Statements::index istmtCur = istmt; /* ever */; ++istmtCur)
	{
		//  Check if this generates fast retail code.  If not, walk a pointer instead of using the index.

		Statement s = m_script.statements[istmtCur];
		switch (s.k)
		{
		case Statement::_end:
			return hr;

		case Statement::_asgn:
			hr = ExecAssignment(s.iasgn, pExcepInfo, iLocals);
			break;

		case Statement::_if:
			hr = ExecIf(s.iif, pExcepInfo, iLocals);
			istmtCur = s.istmtIfTail - 1;
			break;

		case Statement::_call:
			hr = ExecCall(s.icall, false, pExcepInfo, iLocals);
			break;
		}

		if (FAILED(hr))
		{
			if (hr == DISP_E_EXCEPTION)
			{
				// Save the statement's line number in the exception info.
				// Hack: See packexception.h for more info
				ULONG ulLine = s.iLine - 1; // The IActiveScript interfaces expects zero-based line and column numbers while we have them one-based.
				PackExceptionFileAndLine(g_fUseOleAut, pExcepInfo, NULL, &ulLine);
			}

			return hr;
		}
	}
}

HRESULT
Executor::ExecAssignment(Assignments::index iasgn, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	Assignment a = m_script.asgns[iasgn];

	VARIANT var;
	DMS_VariantInit(g_fUseOleAut, &var);
	HRESULT hr = EvalExpression(var, a.iexprRHS, pExcepInfo, iLocals);
	if (FAILED(hr))
		return hr;

	hr = SetVariableReference(a.fSet, a.ivarrefLHS, var, pExcepInfo, iLocals);
	DMS_VariantClear(g_fUseOleAut, &var);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
Executor::ExecIf(IfBlocks::index iif, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	for (IfBlocks::index i = iif; /* ever */; ++i)
	{
		IfBlock &ib = m_script.ifs[i];
		if (ib.k == IfBlock::_end)
			return S_OK;

		bool fMatch = true; // default to true because an else block always matches
		if (ib.k == IfBlock::_cond)
		{
			// if the condition isn't true, set match to false
			SmartVariant svar;
			EvalExpression(svar, ib.iexprCondition, pExcepInfo, iLocals);

			VARTYPE vt = static_cast<VARIANT&>(svar).vt;
			if (vt != VT_I4)
			{
				if (vt == VT_BSTR)
					return Error(pExcepInfo, false, L"Type mismatch: the condition of an if statement evaluated as a string where a numeric True/False value was expected", NULL, NULL);
				else if (vt == VT_UNKNOWN || vt == VT_DISPATCH)
					return Error(pExcepInfo, false, L"Type mismatch: the condition of an if statement evaluated as an object where a numeric True/False value was expected", NULL, NULL);
				return Error(pExcepInfo, false, L"Type mismatch: the condition of an if statement did not evaluate to a numeric True/False value", NULL, NULL);
			}
			if (static_cast<VARIANT&>(svar).lVal != VARIANT_TRUE)
				fMatch = false;
		}

		if (fMatch)
		{
			// found the block to take -- execute its statements and we're done
			return ExecStatements(ib.istmtBlock, pExcepInfo, iLocals);
		}
	}

	return S_OK;
}

// Helper function that eats up a set amount of stack space.
const UINT g_uiExecCallCheckStackBytes = 1484 * 4;
void ExecCallCheckStack();

// Helper function that returns true if the exception code needs to be caught.
LONG ExecCallExceptionFilter(DWORD dwExceptionCode)
{
	// We need to access violations as well as stack overflows.  The first time we run out
	// of stack space we get a stack overflow.  The next time we get an access violation.
	return dwExceptionCode == EXCEPTION_STACK_OVERFLOW || dwExceptionCode == EXCEPTION_ACCESS_VIOLATION;
}

HRESULT Executor::ExecCall(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	// This is a wrapper for ExecCallInternal, which actually does the work.  Here, we just want
	// to catch a potential stack overflow and return it as an error instead of GPF-ing.
	HRESULT hr = E_FAIL;
	__try
	{
		// It is better to fail now than to actually go ahead and call the routine and fail at some point we
		// can't predict.  Routines could do lots of different things including calling into DirectMusic or the
		// OS and we can't be sure we'd get the stack overflow exception and return in a good state.  This
		// routine uses more stack space than we'd expect recursive calls to require to get back to this point
		// again.  In essence, it clears the way, checking if there's enough stack space in a way we know is safe.
		ExecCallCheckStack();

#ifdef DBG
		// The value for g_uiExecCallCheckStackBytes was determined by experiment.  Each time through ExecCall,
		// the following code prints out the address of a char on the current stack and the difference between
		// the previous call.  I found that two scripts, which each evaluated an if statement (always true) and
		// then called the other one produced a difference of 1476.  Then I multiplied that by 4 for good measure.
		char c;
		static char *s_pchPrev = &c;
		DWORD s_dwPrevThreadID = 0;
		DWORD dwGrowth = 0;
		if (s_pchPrev > &c && s_dwPrevThreadID == GetCurrentThreadId())
			dwGrowth = s_pchPrev-&c;
		TraceI(4, "Stack: 0x%08x, -%lu\n", &c, dwGrowth);

		// This assert will fire if a path is executed where a recursive path back to this function takes
		// more stack space than g_uiExecCallCheckStackBytes.  If that's the case then g_uiExecCallCheckStackBytes
		// probably needs to be increased.
		assert(dwGrowth <= g_uiExecCallCheckStackBytes);

		s_pchPrev = &c;
		s_dwPrevThreadID = GetCurrentThreadId();
#endif

		// If we fail inside this call, it means g_uiExecCallCheckStackBytes probably needs to be increased because
		// ExecCallCheckStack didn't catch the stack overflow.
		hr = ExecCallInternal(icall, fPushResult, pExcepInfo, iLocals);
	}
	__except(ExecCallExceptionFilter(GetExceptionCode()))
	{
		Trace(1, "Error: Stack overflow.\n");

		// determine routine name
		Call &c = m_script.calls[icall];
		const char *pszCall = NULL;
		if (c.k == Call::_global)
		{
			pszCall = m_script.strings[c.istrname];
		}
		else
		{
			// name to use is last of the call's reference names
			for (ReferenceNames::index irname = m_script.varrefs[c.ivarref].irname; m_script.rnames[irname].istrIdentifier != -1; ++irname)
			{}
			pszCall = m_script.strings[m_script.rnames[irname - 1].istrIdentifier];
		}
		if (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW)
		{
			hr = Error(pExcepInfo, false, L"Out of stack space: '", pszCall, L"'.  Too many nested function calls.");
		}
		else
		{
			hr = Error(pExcepInfo, false, L"Out of stack space or catastrophic error: '", pszCall, L"'.");
		}
	}
	return hr;
}

// This function doesn't actually do anything besides occupying stack space.  Turn off optimization so the
// copiler doesn't get all clever on us and skip it.
#pragma optimize("", off)
void ExecCallCheckStack()
{
	char chFiller[g_uiExecCallCheckStackBytes];
	chFiller[g_uiExecCallCheckStackBytes - 1] = '\0';
}
#pragma optimize("", on)

HRESULT Executor::ExecCallInternal(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;
	SmartVariant svar; // holds temporary variant values at various points
	SmartVariant svar2; // ditto

	Call &c = m_script.calls[icall];

	IDispatch *pDispCall = NULL;
	Strings::index istrCall = 0;
	const char *pszCall = NULL;

	if (c.k == Call::_global)
	{
		istrCall = c.istrname;
		pszCall = m_script.strings[istrCall];

		// Handle the call directly if it is a call to one of the script's own Routines.
		Routines::index irtnLast = m_script.routines.Next();
		for (Routines::index irtn = 0; irtn < irtnLast; ++irtn)
		{
			if (0 == _stricmp(pszCall, m_script.strings[m_script.routines[irtn].istrIdentifier]))
			{
				return ExecRoutine(irtn, pExcepInfo);
			}
		}

		// Must be a call to the global script API.
		pDispCall = m_scomGlobalDispatch;
	}
	else
	{
		assert(c.k == Call::_dereferenced);
		// count the reference names (needed later)
		for (ReferenceNames::index irname = m_script.varrefs[c.ivarref].irname; m_script.rnames[irname].istrIdentifier != -1; ++irname)
		{}
		assert(irname - m_script.varrefs[c.ivarref].irname > 1); // if there was only one name, this should have been a global call

		hr = VariableReferenceInternal(_call, c.ivarref, svar, pExcepInfo, iLocals);
		if (FAILED(hr))
			return hr;
		hr = ChangeToDispatch(svar, pExcepInfo, irname - 2);
		if (FAILED(hr))
			return hr;
		pDispCall = static_cast<VARIANT>(svar).pdispVal;

		// the method name is the last reference name
		istrCall = m_script.rnames[irname - 1].istrIdentifier;
		pszCall = m_script.strings[istrCall];
	}

	DISPID dispidCall = GetDispID(pDispCall, pszCall);
	if (dispidCall == DISPID_UNKNOWN)
	{
		return Error(pExcepInfo, false, L"The routine '", pszCall, L"' does not exist");
	}

	// We'll push the parameters onto the stack.  (The function we're calling doesn't actually read them directly using the stack, but
	// it is a convenient place for us to keep them temporarily.)

	// First, count the parameters.
	UINT cParams = 0;
	for (ExprBlocks::index iexpr = c.iexprParams; m_script.exprs[iexpr]; ++iexpr)
	{
		// each parameter is an expression terminated by an end block
		++cParams;
		while (m_script.exprs[++iexpr])
		{}
	}

	// Make space for them.
	UINT iParamSlots = m_stack.Next();
	hr = m_stack.Push(std::_MAX<UINT>(cParams, fPushResult ? 1 : 0)); // even if there are no params, leave one slot for the result if fPushResult is true
	if (FAILED(hr))
		return hr;

	// Fill the params in reverse order.
	iexpr = c.iexprParams;
	for (UINT iParam = iParamSlots + cParams - 1; iParam >= iParamSlots; --iParam)
	{
		if (m_script.exprs[iexpr].k == ExprBlock::_omitted)
		{
			// write the variant value IDispatch::Invoke uses for an omitted parameter
			m_stack[iParam].vt = VT_ERROR;
			m_stack[iParam].scode = DISP_E_PARAMNOTFOUND;
		}
		else
		{
			hr = EvalExpression(svar, iexpr, pExcepInfo, iLocals);
			if (FAILED(hr))
				return hr;

			hr = DMS_VariantCopy(g_fUseOleAut, &m_stack[iParam], &svar);
			if (FAILED(hr))
				return hr;
		}

		// each parameter is an expression terminated by an end block
		++iexpr;
		while (m_script.exprs[iexpr++])
		{}
	}

	DISPPARAMS dispparams;
	Zero(&dispparams);
	dispparams.rgvarg = cParams > 0 ? &m_stack[iParamSlots] : NULL;
	dispparams.rgdispidNamedArgs = NULL;
	dispparams.cArgs = cParams;
	dispparams.cNamedArgs = 0;

	// Make the call.
	// Push the result onto the stack if fPushResult is true.

	hr = InvokeAttemptingNotToUseOleAut(
			pDispCall,
			dispidCall,
			DISPATCH_METHOD,
			&dispparams,
			fPushResult ? &svar2 : NULL, // We can't save the result directly onto the stack because we could be makeing a recursive script call that could cause a stack to be reallocation, invalidating the address so we use svar2 instead.
			pExcepInfo,
			NULL);
	hr = ErrorIfInvokeProblem(_call, hr, istrCall, pExcepInfo);
	if (SUCCEEDED(hr) && fPushResult)
	{
		hr = DMS_VariantCopy(g_fUseOleAut, &m_stack[iParamSlots], &svar2);
	}

	m_stack.PopTo(iParamSlots + (fPushResult ? 1 : 0));
	if (FAILED(hr))
		return hr;

	return S_OK;
}

// possible error-message type returns: DISP_E_TYPEMISMATCH
HRESULT
Executor::EvalExpression(VARIANT &varResult, ExprBlocks::index iexpr, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;

	UINT iTempSlots = m_stack.Next();

	for (ExprBlocks::index iexprCur = iexpr; /* ever */; ++iexprCur)
	{
		ExprBlock &e = m_script.exprs[iexprCur];
		switch (e.k)
		{
		case ExprBlock::_end:
			// pop the result and return it
			if (m_stack.Next() != iTempSlots + 1)
			{
				assert(false);
				return E_FAIL;
			}

			DMS_VariantCopy(g_fUseOleAut, &varResult, &m_stack[iTempSlots]);
			m_stack.PopTo(iTempSlots);
			return hr;

		case ExprBlock::_op:
			// Pop one (unary operator) or two (binary operator) items, apply the operator, and push the result.
			// (Actually, I just assign the result into the stack instead of pushing it, but conceptually the is
			//    the same as popping and pushing the new value.)
			{
				Token t = e.op;
				bool fUnary = t == TOKEN_op_not || t == TOKEN_sub;

				UINT iNext = m_stack.Next();
				if (iNext < iTempSlots + (fUnary ? 1 : 2))
				{
					assert(false);
					return E_FAIL;
				}

				VARIANT &v1 = m_stack[iNext - 1];
				if (fUnary)
					hr = EvalUnaryOp(t, v1);
				else
				{
					VARIANT &v2 = m_stack[iNext - 2];
					hr = EvalBinaryOp(t, v1, v2, pExcepInfo);
					m_stack.PopTo(iNext - 1);
				}
			}
			break;

		case ExprBlock::_val:
			{
				// push it
				hr = m_stack.Push(1);
				VARIANT &varToPush = m_stack[m_stack.Next() - 1];
				if (SUCCEEDED(hr))
					hr = EvalValue(e.ival, varToPush, pExcepInfo, iLocals);
				if (varToPush.vt == VT_EMPTY)
				{
					// treat an empty value as zero
					varToPush.vt = VT_I4;
					varToPush.lVal = 0;
				}
			}
			break;

		case ExprBlock::_call:
			// push it
			if (SUCCEEDED(hr))
				hr = ExecCall(e.icall, true, pExcepInfo, iLocals);
			break;
		}

		if (FAILED(hr))
		{
			m_stack.PopTo(iTempSlots);
			return hr;
		}
	}

	return S_OK;
}

HRESULT
Executor::EvalValue(Values::index ival, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	Value val = m_script.vals[ival];
	switch (val.k)
	{
	case Value::_numvalue:
		v.vt = VT_I4;
		v.lVal = val.inumvalue;
		break;

	case Value::_strvalue:
		{
			v.vt = VT_BSTR;
			SmartRef::WString wstr = m_script.strings[val.istrvalue];
			if (!wstr)
				return E_OUTOFMEMORY;
			v.bstrVal = DMS_SysAllocString(g_fUseOleAut, wstr);
			if (!v.bstrVal)
				return E_OUTOFMEMORY;
			break;
		}

	case Value::_varref:
		HRESULT hr = GetVariableReference(val.ivarref, v, pExcepInfo, iLocals);
		if (FAILED(hr))
			return hr;
	}

	return S_OK;
}

HRESULT
Executor::EvalUnaryOp(Token t, VARIANT &v)
{
	if (v.vt != VT_I4)
	{
		assert(false);
		return DISP_E_TYPEMISMATCH;
	}

	if (t == TOKEN_op_not)
	{
		v.lVal = ~v.lVal;
	}
	else
	{
		assert(t == TOKEN_sub);
		v.lVal = -v.lVal;
	}

	return S_OK;
}

// Returns a proper VB boolean value (0 for false, -1 for true)
inline LONG
BoolForVB(bool f) { return f ? VARIANT_TRUE : VARIANT_FALSE; }

HRESULT
Executor::EvalBinaryOp(Token t, VARIANT &v1, VARIANT &v2, EXCEPINFO *pExcepInfo)
{
	if (v1.vt == VT_DISPATCH || v1.vt == VT_UNKNOWN)
	{
		// the only operator that accepts object values is is
		if (t != TOKEN_is || !(v2.vt == VT_DISPATCH || v2.vt == VT_UNKNOWN))
		{
			assert(false);
			return DISP_E_TYPEMISMATCH;
		}

		HRESULT hr = DMS_VariantChangeType(g_fUseOleAut, &v1, &v1, 0, VT_UNKNOWN);
		if (FAILED(hr))
			return hr;
		hr = DMS_VariantChangeType(g_fUseOleAut, &v2, &v2, 0, VT_UNKNOWN);
		if (FAILED(hr))
			return hr;

		bool fIs = v1.punkVal == v2.punkVal;

		hr = DMS_VariantClear(g_fUseOleAut, &v2);
		if (FAILED(hr))
			return hr;

		v2.vt = VT_I4;
		v2.lVal = BoolForVB(fIs);
		return S_OK;
	}

	if (v1.vt != VT_I4 || v2.vt != VT_I4)
	{
		assert(false);
		return DISP_E_TYPEMISMATCH;
	}

	switch (t)
	{
	case TOKEN_op_minus:
		v2.lVal -= v1.lVal;
		break;
	case TOKEN_op_pow:
		v2.lVal = _Pow_int(v2.lVal, v1.lVal);
		break;
	case TOKEN_op_mult:
		v2.lVal *= v1.lVal;
		break;
	case TOKEN_op_div:
		if (v1.lVal == 0)
			return Error(pExcepInfo, false, L"Division by zero", NULL, NULL);
		v2.lVal /= v1.lVal;
		break;
    case TOKEN_op_mod:
        if (v1.lVal == 0)
            return Error(pExcepInfo, false, L"Mod by zero", NULL, NULL);
        v2.lVal %= v1.lVal;
        break;
	case TOKEN_op_plus:
		v2.lVal += v1.lVal;
		break;
	case TOKEN_op_lt:
		v2.lVal = BoolForVB(v2.lVal < v1.lVal);
		break;
	case TOKEN_op_leq:
		v2.lVal = BoolForVB(v2.lVal <= v1.lVal);
		break;
	case TOKEN_op_gt:
		v2.lVal = BoolForVB(v2.lVal > v1.lVal);
		break;
	case TOKEN_op_geq:
		v2.lVal = BoolForVB(v2.lVal >= v1.lVal);
		break;
	case TOKEN_op_eq:
		v2.lVal = BoolForVB(v2.lVal == v1.lVal);
		break;
	case TOKEN_op_neq:
		v2.lVal = BoolForVB(v2.lVal != v1.lVal);
		break;
	case TOKEN_and:
		v2.lVal &= v1.lVal;
		break;
	case TOKEN_or:
		v2.lVal |= v1.lVal;
		break;
	default:
		assert(false);
		return E_UNEXPECTED;
	}

	return S_OK;
}

// O.K. This is a bit funky, but bear with me.  This function has four different behaviors determined by the first (e) parameter.
// This is some ugly code, but at least this way I get to use it for multiple purposes.

// _get:    Returns the value of the variable reference via out parameter v.
// _put:    Sets the value of the variable reference to the in parameter v.
// _putref: Same as _put, but assigns by reference ala VB's 'set' statements.
// _call:   Same as _get, but returns the second-to-last value in the chain via out parameter v.
//           For example, if the reference is 'a.b.c' this returns the value of 'a.b', which can then be used to invoke function c.
//           It is an error to call VariableReferenceInternal in this way with only a single item such as 'a'.

HRESULT
Executor::VariableReferenceInternal(DispatchOperationType e, Variables::index ivarref, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;

	VariableReference r = m_script.varrefs[ivarref];
	bool fGlobal = r.k == VariableReference::_global;

	SmartVariant svar;

	assert(m_script.rnames[r.irname].istrIdentifier != -1);
	bool fJustOnePart = m_script.rnames[r.irname + 1].istrIdentifier == -1;
	if (fJustOnePart && e == _call)
	{
		assert(false);
		return E_UNEXPECTED;
	}

	//
	// Handle the base item of the reference, which is either a script variable or an item on the global dispatch.
	// If we're doing a set and there aren't more parts to the rnames, just do the set.
	// Otherwise, get the result into 'var'.
	//
	// Example:
	// x = 1
	//     There is just one part and it is a set.  Determine whether x is in the script or part of the global dispatch, set it to 1,
	//     and we're done.
	// x.y = 1
	//     x is the base.  Determine whether x is in the script or part of the global dispatch and get its value.  (We'll worry about
	//     setting the y property later in this function.
	//

	// check if the base is part of the global dispatch
	DISPID dispid = DISPID_UNKNOWN;
	if (fGlobal)
	{
		dispid = m_script.globals[r.ivar].dispid;
	}
	if (dispid != DISPID_UNKNOWN)
	{
		// base is part of global dispatch
		if (fJustOnePart && (e == _put || e == _putref))
		{
			// set it and we're done
			hr = SetDispatchProperty(m_scomGlobalDispatch, dispid, e == _putref, v, pExcepInfo);
			hr = ErrorIfInvokeProblem(e, hr, m_script.globals[r.ivar].istrIdentifier, pExcepInfo);
			return hr;
		}
		else
		{
			hr = GetDispatchProperty(m_scomGlobalDispatch, dispid, svar, pExcepInfo);
			hr = ErrorIfInvokeProblem(e, hr, m_script.globals[r.ivar].istrIdentifier, pExcepInfo);
			if (FAILED(hr))
				return hr;
		}
	}
	else
	{
		// base is in script
		VARIANT &vVariable = m_stack[r.ivar + (fGlobal ? 0 : iLocals)];

		if (fJustOnePart && (e == _put || e == _putref))
		{
			// set it and we're done
			hr = ErrorIfImproperRef(v, e == _putref, m_script.rnames[r.irname].istrIdentifier, pExcepInfo);
			if (FAILED(hr))
				return hr;
			hr = DMS_VariantCopy(g_fUseOleAut, &vVariable, &v);
			return hr;
		}
		else
		{
			hr = DMS_VariantCopy(g_fUseOleAut, &svar, &vVariable);
			if (FAILED(hr))
				return hr;
		}
	}

	//
	// Great!  The base value is now held in svar.  Any remaining rnames are a chain of properties we need to get from that object.
	// And the last rname needs to be a set if we're in one of the put modes or the last name is ignored if we're in the _call mode.
	//

	if (m_script.rnames[r.irname + 1].istrIdentifier != -1)
	{
		// the base value must be of object type
		hr = ErrorIfImproperRef(svar, true, m_script.rnames[r.irname].istrIdentifier, pExcepInfo);
		if (FAILED(hr))
			return hr;

		for (ReferenceNames::index irname = r.irname + 1; /* ever */; ++irname)
		{
			bool fLastPart = m_script.rnames[irname + 1].istrIdentifier == -1;
			if (fLastPart && e == _call)
				break;

			// get its IDispatch interface
			hr = ChangeToDispatch(svar, pExcepInfo, irname - 1);
			if (FAILED(hr))
				return hr;
			IDispatch *pDisp = static_cast<VARIANT>(svar).pdispVal;

			// get the dispid
			ReferenceName &rname = m_script.rnames[irname];
			DISPID dispidName = GetDispID(pDisp, m_script.strings[rname.istrIdentifier]);
			if (dispidName == DISPID_UNKNOWN)
				return Error(pExcepInfo, false, L"The property '", m_script.strings[rname.istrIdentifier], L"' does not exist");

			if (fLastPart && (e == _put || e == _putref))
			{
				// set it and we're done
				hr = SetDispatchProperty(pDisp, dispidName, e == _putref, v, pExcepInfo);
				hr = ErrorIfInvokeProblem(e, hr, rname.istrIdentifier, pExcepInfo);
				return hr;
			}
			else
			{
				hr = GetDispatchProperty(pDisp, dispidName, svar, pExcepInfo);
				hr = ErrorIfInvokeProblem(e, hr, rname.istrIdentifier, pExcepInfo);
				if (FAILED(hr))
					return hr;
			}

			if (fLastPart)
			{
				// we've done all the names
				break;
			}
			else
			{
				// the new value must be of object type
				hr = ErrorIfImproperRef(svar, true, rname.istrIdentifier, pExcepInfo);
				if (FAILED(hr))
					return hr;
			}
		}
	}

	//
	// We're done.  Now we just have to return the value we calculated.  (We know that a set would have already returned.)
	//

	hr = DMS_VariantCopy(g_fUseOleAut, &v, &svar);
	return hr;
}

HRESULT
Executor::ChangeToDispatch(VARIANT &var, EXCEPINFO *pExcepInfo, ReferenceNames::index irnameIdentifier)
{
	HRESULT hr = DMS_VariantChangeType(g_fUseOleAut, &var, &var, 0, VT_DISPATCH);
	if (FAILED(hr))
		return ErrorObjectRequired(m_script.rnames[irnameIdentifier].istrIdentifier, pExcepInfo);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\enginc.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Standard included stuff for the AudioVBScript engine.
//

#pragma once

#include "oleaut.h"

const LCID lcidUSEnglish = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
const bool g_fUseOleAut = false;

// Constants built into the langauge.  These will be treated as global variables and given fixed values.
extern const char *g_rgszBuiltInConstants[];
extern const int g_cBuiltInConstants;

// Helpers for working with IDispatch
DISPID GetDispID(IDispatch *pIDispatch, const char *pszBase); // returns DISPID_UNKNOWN on failure.
HRESULT InvokeAttemptingNotToUseOleAut(
			IDispatch *pDisp,
			DISPID dispIdMember,
			WORD wFlags,
			DISPPARAMS *pDispParams,
			VARIANT *pVarResult,
			EXCEPINFO *pExcepInfo,
			UINT *puArgErr);
HRESULT SetDispatchProperty(IDispatch *pDisp, DISPID dispid, bool fSetRef, const VARIANT &v, EXCEPINFO *pExcepInfo);
HRESULT GetDispatchProperty(IDispatch *pDisp, DISPID dispid, VARIANT &v, EXCEPINFO *pExcepInfo);
void ConvertOleAutExceptionBSTRs(bool fCurrentlyUsesOleAut, bool fResultUsesOleAut, EXCEPINFO *pExcepInfo);

// Holds a variant value.  Inits it on construction and clears it on destruction.  Any failure on clearing is ignored.
class SmartVariant
{
public:
	SmartVariant() { DMS_VariantInit(g_fUseOleAut, &m_v); }
	~SmartVariant() { DMS_VariantClear(g_fUseOleAut, &m_v); }

	operator VARIANT &() { return m_v; }
	VARIANT *operator &() { return &m_v; }

private:
	VARIANT m_v;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engexpr.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of ExprBlock.
//

#include "stdinc.h"
#include "engexpr.h"

HRESULT
Expression::Generate()
{
	HRESULT hr = InfixToPostfix();
	if (FAILED(hr))
	{
		// clean up the working stack
		while (!m_stack.empty())
			m_stack.pop();

		return hr;
	}

	return S_OK;
}

int Precedence(Token t)
{
	switch(t)
	{
	case TOKEN_op_pow:		return 10;
	case TOKEN_sub:			return 9; // unary - (negation)
	case TOKEN_op_mult:		return 8;
	case TOKEN_op_div:		return 7;
	case TOKEN_op_mod:		return 6;
	case TOKEN_op_plus:
	case TOKEN_op_minus:	return 5;
	case TOKEN_op_lt:
	case TOKEN_op_leq:
	case TOKEN_op_gt:
	case TOKEN_op_geq:
	case TOKEN_op_eq:
	case TOKEN_op_neq:
	case TOKEN_is:			return 4;
	case TOKEN_op_not:		return 3;
	case TOKEN_and:			return 2;
	case TOKEN_or:			return 1;
	case TOKEN_lparen:		return 0;
	default:
		assert(false);
		return 12;
	}
}

// Infix to postfix conversion is performed by a single scan of the infix expression blocks.
// A stack is used to hold some of the blocks before they eventually are appended to the postfix expression.
//
// The algorithm follows the following rules:
// * If the current item is an value it is immediately appended.
// * If the current item is an operator, pop and append each operator on the stack until one is encountered that:
//         - has lower precedence than the current operator OR
//         - is a left paren OR
//         - is a unary operator and the current item is also unary
//   Once done with this popping, push the current item onto the stack.
// * If the current item is a left paren, push it onto the stack.
// * If the current item is a right paren, pop and append all the operators until the matching left paren is found.
//   Discard the left and right paren as parens are not needed in postfix.
// * After scanning all items of the input, pop and append any operators that remain on the stack.
//
// Before working with this code, try out a few expressions on paper to see how this works.

HRESULT
Expression::InfixToPostfix()
{
	assert(m_stack.empty());

	HRESULT hr = S_OK;

	ExprBlocks::index iLast = m_e.Next();
	assert(iLast > 0);
	for (ExprBlocks::index i = 0; i < iLast; ++i)
	{
		const ExprBlock &b = m_e[i];
		if (b.k == ExprBlock::_val || b.k == ExprBlock::_call)
		{
			// this is an operand -- send it directly to the postfix output
			hr = m_eblocks.Add(b);
			if (FAILED(hr))
				return hr;
		}
		else
		{
			if (b.op == TOKEN_rparen)
			{
				// pop whatever's left until the matching lparen
				for (;;)
				{
					if (m_stack.empty())
					{
						assert(false);
						return E_FAIL;
					}

					ExprBlock bPop = m_stack.top();
					if (bPop.op == TOKEN_lparen)
					{
						m_stack.pop();
						break;
					}
					hr = m_eblocks.Add(bPop);
					if (FAILED(hr))
						return hr;
					m_stack.pop();
				}
				continue;
			}
			else if (b.op != TOKEN_lparen)
			{
				// Pop all operators of lower precedence off the stack.  (This won't pass a left paren because its precedence is set to 0.)
				// Exception: don't pop a unary operator if the new one is also unary.
				int iNewPrecidence = Precedence(b.op);
				bool fNewUnary = b.op == TOKEN_sub || b.op == TOKEN_op_not;
				while (!m_stack.empty()) // note that there's a break inside the loop as well
				{
					ExprBlock bPop = m_stack.top();
					if (Precedence(bPop.op) < iNewPrecidence)
						break;

					if (fNewUnary && (bPop.op == TOKEN_sub || bPop.op == TOKEN_op_not))
						break;

					hr = m_eblocks.Add(bPop);
					if (FAILED(hr))
						return hr;
					m_stack.pop();
				}
			}

			// now push the new operator onto the stack
			hr = m_stack.push(b);
			if (FAILED(hr))
				return hr;
		}
	}

	while (!m_stack.empty())
	{
		ExprBlock bPop = m_stack.top();
		if (bPop.op == TOKEN_lparen)
		{
			assert(false);
			return E_FAIL;
		}
		hr = m_eblocks.Add(bPop);
		if (FAILED(hr))
			return hr;
		m_stack.pop();
	}

	// Add the teminating (_end) block
	hr = m_eblocks.Add(ExprBlock(ExprBlock::cons_end()));
	if (FAILED(hr))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engexpr.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Expression.
//

#pragma once

#include "engcontrol.h"

//    The expression class takes input of a well-formed expression in infix (the order appearing in the script source)
// notation.  The blocks are converted to postfix notation and appeanded to the given script's exprs list and followed
// with an _end block.
//    A working stack is used to perform the conversion.  The stack to use is passed by reference so that the same stack
// may be used to evaluate multiple expressions.  This allows the stack to grow as needed until it reaches the max size
// needed to process the expressions, minimizing reallocation thereafter.
class Expression
{
public:
	Expression(Script &script, SmartRef::Stack<ExprBlock> &stack, ExprBlocks *peblocks) : m_script(script), m_stack(stack), m_eblocks(peblocks ? *peblocks : m_script.exprs) {}

	// Note: For unary - (negation), use TOKEN_sub instead of TOKEN_op_minus.
	HRESULT Add(ExprBlock b) { if (b.k == ExprBlock::_end) {assert(false); return E_INVALIDARG;} return m_e.Add(b); }
	HRESULT Generate();

private:
	HRESULT InfixToPostfix();

private:
	ExprBlocks m_e;

	Script &m_script;
	SmartRef::Stack<ExprBlock> &m_stack;
	ExprBlocks &m_eblocks;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engexec.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Executor.
//

// Runs the script, interpreting its routines and managing its variables.

#include "engcontrol.h"
#include "enginc.h"
#include "oleaut.h"

// While a script is executing, a stack is used to hold routines' local parameters and temporaries for evaluating expressions.
// This stack's memory  grows as needed.  Memory allocation/deallocation is minimized because many calls to a script will grow
// the stack to its needed size.
class CallStack
{
public:
	CallStack() : m_iNext(0) {}

	UINT Next() { return m_iNext; }
	VARIANT &operator[](UINT i) { assert(i < m_iNext); return m_vec[i]; }

	// used for routines' local variables
	HRESULT Push(UINT i); // pushes i empty slots
	void PopTo(UINT i); // pops everything down to and including i (following this, i will be Next)

private:
	SmartRef::Vector<VARIANT> m_vec;
	UINT m_iNext;
};

class Executor
{
public:
	Executor(Script &script, IDispatch *pGlobalDispatch);
	~Executor();

	HRESULT SetGlobal(Variables::index ivar, const VARIANT &varValue, bool fPutRef, EXCEPINFO *pExcepInfo);
	const VARIANT &GetGlobal(Variables::index ivar);
	HRESULT ExecRoutine(Routines::index irtn, EXCEPINFO *pExcepInfo);

private:
	enum DispatchOperationType { _get, _put, _putref, _call };

	HRESULT EnsureInitialized();

	HRESULT Error(EXCEPINFO *pExcepInfo, bool fOperation, const WCHAR *pwszBeginning, const char *paszMiddle = NULL, const WCHAR *pwszEnd = NULL); // A bit hokey, but it works. Creates an error using wide strings with an ascii string (typically an identifier) in between.
	HRESULT ErrorIfImproperRef(const VARIANT &v, bool fRef, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo);
	HRESULT ErrorObjectRequired(Strings::index istrIdentifier, EXCEPINFO *pExcepInfo) { return Error(pExcepInfo, false, L"Object required: '", m_script.strings[istrIdentifier], L"'"); }
	HRESULT ErrorIfInvokeProblem(DispatchOperationType e, HRESULT hr, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo);

	HRESULT ExecStatements(Statements::index istmt, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecAssignment(Assignments::index iasgn, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecIf(IfBlocks::index iif, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecCall(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecCallInternal(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals); // helper used by ExecCall

	HRESULT EvalExpression(VARIANT &varResult, ExprBlocks::index iexpr, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT EvalValue(Values::index ival, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals); // evaluates ival, saving the result in v
	HRESULT EvalUnaryOp(Token t, VARIANT &v); // evaluates t on v -- saving the result back into v
	HRESULT EvalBinaryOp(Token t, VARIANT &v1, VARIANT &v2, EXCEPINFO *pExcepInfo); // evaluates t on v1 and v2 -- saving the result back into v2

	HRESULT GetVariableReference(Variables::index ivarref, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals) { return VariableReferenceInternal(_get, ivarref, v, pExcepInfo, iLocals); }
	HRESULT SetVariableReference(bool fSet, Variables::index ivarref, const VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals) { return VariableReferenceInternal(fSet ? _putref : _put, ivarref, const_cast<VARIANT&>(v), pExcepInfo, iLocals); }
	HRESULT VariableReferenceInternal(DispatchOperationType e, Variables::index ivarref, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals);

	HRESULT ChangeToDispatch(VARIANT &var, EXCEPINFO *pExcepInfo, ReferenceNames::index irnameIdentifier);

	// Data
	bool m_fInitialized;
	Script &m_script;
	SmartRef::ComPtr<IDispatch> m_scomGlobalDispatch;

	VARIANT m_varEmpty; //  varient we hold around so we can return a ref to a cleared variant
	CallStack m_stack;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engine.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAudioVBScriptEngine.
//

// CAudioVBScriptEngine is an ActiveX scripting engine that supports a carefully chosen subset of the VBScript language.
// It's goal in life is to be as small and fast as possible and to run on every platform that ports DirectMusic.

#pragma once

#include "activscp.h"
#include "engdisp.h"

const GUID CLSID_DirectMusicAudioVBScript = { 0x4ee17959, 0x931e, 0x49e4, { 0xa2, 0xc6, 0x97, 0x7e, 0xcf, 0x36, 0x28, 0xf3 } }; // {4EE17959-931E-49e4-A2C6-977ECF3628F3}

class CAudioVBScriptEngine
  : public IActiveScript,
	public IActiveScriptParse
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IActiveScript
	HRESULT STDMETHODCALLTYPE SetScriptSite(
		/* [in] */ IActiveScriptSite __RPC_FAR *pass);
	HRESULT STDMETHODCALLTYPE GetScriptSite(
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE SetScriptState(
		/* [in] */ SCRIPTSTATE ss) { return S_OK; }
	HRESULT STDMETHODCALLTYPE GetScriptState(
		/* [out] */ SCRIPTSTATE __RPC_FAR *pssState) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE Close(void);
	HRESULT STDMETHODCALLTYPE AddNamedItem(
		/* [in] */ LPCOLESTR pstrName,
		/* [in] */ DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE AddTypeLib(
		/* [in] */ REFGUID rguidTypeLib,
		/* [in] */ DWORD dwMajor,
		/* [in] */ DWORD dwMinor,
		/* [in] */ DWORD dwFlags) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetScriptDispatch(
		/* [in] */ LPCOLESTR pstrItemName,
		/* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
	HRESULT STDMETHODCALLTYPE GetCurrentScriptThreadID(
		/* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetScriptThreadID(
		/* [in] */ DWORD dwWin32ThreadId,
		/* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetScriptThreadState(
		/* [in] */ SCRIPTTHREADID stidThread,
		/* [out] */ SCRIPTTHREADSTATE __RPC_FAR *pstsState) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE InterruptScriptThread(
		/* [in] */ SCRIPTTHREADID stidThread,
		/* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo,
		/* [in] */ DWORD dwFlags) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE Clone(
		/* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppscript) { return E_NOTIMPL; }

	// IActiveScriptParse
    HRESULT STDMETHODCALLTYPE InitNew(void) { return S_OK; }
    HRESULT STDMETHODCALLTYPE AddScriptlet(
        /* [in] */ LPCOLESTR pstrDefaultName,
        /* [in] */ LPCOLESTR pstrCode,
        /* [in] */ LPCOLESTR pstrItemName,
        /* [in] */ LPCOLESTR pstrSubItemName,
        /* [in] */ LPCOLESTR pstrEventName,
        /* [in] */ LPCOLESTR pstrDelimiter,
        /* [in] */ DWORD_PTR dwSourceContextCookie,
        /* [in] */ ULONG ulStartingLineNumber,
        /* [in] */ DWORD dwFlags,
        /* [out] */ BSTR __RPC_FAR *pbstrName,
        /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo) { return E_NOTIMPL; }
    HRESULT STDMETHODCALLTYPE ParseScriptText(
        /* [in] */ LPCOLESTR pstrCode,
        /* [in] */ LPCOLESTR pstrItemName,
        /* [in] */ IUnknown __RPC_FAR *punkContext,
        /* [in] */ LPCOLESTR pstrDelimiter,
        /* [in] */ DWORD_PTR dwSourceContextCookie,
        /* [in] */ ULONG ulStartingLineNumber,
        /* [in] */ DWORD dwFlags,
        /* [out] */ VARIANT __RPC_FAR *pvarResult,
        /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);

private:
	// Methods
	CAudioVBScriptEngine();

	// Data
	long m_cRef;
	SmartRef::ComPtr<IActiveScriptSite> m_scomActiveScriptSite;
	SmartRef::ComPtr<EngineDispatch> m_scomEngineDispatch;

	Script m_script;
	SmartRef::ComPtr<IDispatch> m_scomGlobalDispatch;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\enginc.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Standard included stuff for the AudioVBScript engine.
//

#include "stdinc.h"
#include "enginc.h"

const char *g_rgszBuiltInConstants[] = { "true", "false", "nothing" };
const int g_cBuiltInConstants = ARRAY_SIZE(g_rgszBuiltInConstants);


DISPID
GetDispID(IDispatch *pIDispatch, const char *pszBase)
{
	SmartRef::WString wstrBase = pszBase;
	if (!wstrBase)
		return DISPID_UNKNOWN;

	DISPID dispid = DISPID_UNKNOWN;
	const WCHAR *wszBase = wstrBase;
	pIDispatch->GetIDsOfNames(IID_NULL, const_cast<WCHAR**>(&wszBase), 1, lcidUSEnglish, &dispid);
	return dispid;
}

// See oleaut.h for more info about why this is necessary.
HRESULT
InvokeAttemptingNotToUseOleAut(
		IDispatch *pDisp,
		DISPID dispIdMember,
		WORD wFlags,
		DISPPARAMS *pDispParams,
		VARIANT *pVarResult,
		EXCEPINFO *pExcepInfo,
		UINT *puArgErr)
{
	if (g_fUseOleAut)
	{
		// Engine is set to always use oleaut32.dll.
		return pDisp->Invoke(dispIdMember, IID_NULL, lcidUSEnglish, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}

	// Try not to use oleaut32.dll.
	HRESULT hr = pDisp->Invoke(dispIdMember, g_guidInvokeWithoutOleaut, lcidUSEnglish, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	if (hr != DISP_E_UNKNOWNINTERFACE)
		return hr;

	// It didn't like being called that way.  Must be some other scripting language or non-DMusic dispatch interface.
	// Use regular oleaut32.dll calling convention.
	if (pVarResult)
	{
		// We need to convert the return into our own kind of variant.
		VARIANT var;
		DMS_VariantInit(true, &var);
		hr = pDisp->Invoke(dispIdMember, IID_NULL, lcidUSEnglish, wFlags, pDispParams, &var, pExcepInfo, puArgErr);
		DMS_VariantCopy(false, pVarResult, &var);
		DMS_VariantClear(true, &var);
	}
	else
	{
		// There's no result so no conversion is necessary.
		hr = pDisp->Invoke(dispIdMember, IID_NULL, lcidUSEnglish, wFlags, pDispParams, NULL, pExcepInfo, puArgErr);
	}

	// If an exception occurred, we need to convert the error strings into our own kind of BSTR.
	if (hr == DISP_E_EXCEPTION)
		ConvertOleAutExceptionBSTRs(true, false, pExcepInfo);

	return hr;
}

HRESULT
SetDispatchProperty(IDispatch *pDisp, DISPID dispid, bool fSetRef, const VARIANT &v, EXCEPINFO *pExcepInfo)
{
	DISPID dispidPropPut = DISPID_PROPERTYPUT;
	DISPPARAMS dispparams;
	dispparams.rgvarg = const_cast<VARIANT*>(&v);
	dispparams.rgdispidNamedArgs = &dispidPropPut;
	dispparams.cArgs = 1;
	dispparams.cNamedArgs = 1;

	HRESULT hr = InvokeAttemptingNotToUseOleAut(
			pDisp,
			dispid,
			fSetRef ? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT,
			&dispparams,
			NULL,
			pExcepInfo,
			NULL);
	return hr;
}

HRESULT
GetDispatchProperty(IDispatch *pDisp, DISPID dispid, VARIANT &v, EXCEPINFO *pExcepInfo)
{
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	HRESULT hr = InvokeAttemptingNotToUseOleAut(
			pDisp,
			dispid,
			DISPATCH_PROPERTYGET | DISPATCH_METHOD,
				// DISPATCH_METHOD is also set because in VB syntax a function with no parameters
				// can be accessed like a property.  Example "x = GetMasterGrooveLevel" is a
				// shortcut for "x = GetMasterGrooveLevel()".
			&dispparamsNoArgs,
			&v,
			pExcepInfo,
			NULL);
	return hr;
}

// If needed, converts the BSTRs in an EXCEPINFO structure between formats using or not using OleAut.
void ConvertOleAutExceptionBSTRs(bool fCurrentlyUsesOleAut, bool fResultUsesOleAut, EXCEPINFO *pExcepInfo)
{
	if (pExcepInfo && fCurrentlyUsesOleAut != fResultUsesOleAut)
	{
		BSTR bstrSource = pExcepInfo->bstrSource;
		BSTR bstrDescription = pExcepInfo->bstrDescription;
		BSTR bstrHelpFile = pExcepInfo->bstrHelpFile;

		pExcepInfo->bstrSource = DMS_SysAllocString(fResultUsesOleAut, bstrSource);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fResultUsesOleAut, bstrDescription);
		pExcepInfo->bstrHelpFile = DMS_SysAllocString(fResultUsesOleAut, bstrHelpFile);

		DMS_SysFreeString(fCurrentlyUsesOleAut, bstrSource);
		DMS_SysFreeString(fCurrentlyUsesOleAut, bstrDescription);
		DMS_SysFreeString(fCurrentlyUsesOleAut, bstrHelpFile);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engine.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAudioVBScriptEngine.
//

#include "stdinc.h"
#include "dll.h"
#include "engine.h"
#include "englex.h" // 
#include "engparse.h" // 

//////////////////////////////////////////////////////////////////////
// Creation

CAudioVBScriptEngine::CAudioVBScriptEngine()
  : m_cRef(0)
{
	LockModule(true);
}

HRESULT
CAudioVBScriptEngine::CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv)
{
	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	CAudioVBScriptEngine *pInst = new CAudioVBScriptEngine;
	if (pInst == NULL)
		return E_OUTOFMEMORY;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CAudioVBScriptEngine::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CAudioVBScriptEngine::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IActiveScript)
	{
		*ppv = static_cast<IActiveScript*>(this);
	}
	else if (iid == IID_IActiveScriptParse)
	{
		*ppv = static_cast<IActiveScriptParse*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
CAudioVBScriptEngine::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CAudioVBScriptEngine::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IActiveScript

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::SetScriptSite(
		/* [in] */ IActiveScriptSite __RPC_FAR *pass)
{
	V_INAME(CAudioVBScriptEngine::SetScriptSite);
	V_INTERFACE(pass);

	m_scomActiveScriptSite = pass;
	pass->AddRef();
	return S_OK;
}

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::Close(void)
{
	m_scomActiveScriptSite.Release();
	m_scomEngineDispatch.Release();
	return S_OK;
}

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::AddNamedItem(
		/* [in] */ LPCOLESTR pstrName,
		/* [in] */ DWORD dwFlags)
{
	// We only provide limited support for named items.  We only take a single global item.  We don't even remember its name.

	if (!m_scomActiveScriptSite || !(dwFlags & SCRIPTITEM_GLOBALMEMBERS) || m_scomGlobalDispatch)
		return E_UNEXPECTED;

	IUnknown *punkGlobal = NULL;
	HRESULT hr = m_scomActiveScriptSite->GetItemInfo(pstrName, SCRIPTINFO_IUNKNOWN, &punkGlobal, NULL);
	if (FAILED(hr))
		return hr;

	hr = punkGlobal->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(&m_scomGlobalDispatch));
	punkGlobal->Release();
	return hr;
}

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::GetScriptDispatch(
		/* [in] */ LPCOLESTR pstrItemName,
		/* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp)
{
	V_INAME(CAudioVBScriptEngine::GetScriptDispatch);
	V_BUFPTR_READ_OPT(pstrItemName, 2);
	V_PTR_WRITE(ppdisp, IDispatch *);

	if (pstrItemName)
		return E_NOTIMPL;

	if (!m_scomEngineDispatch)
		m_scomEngineDispatch = new EngineDispatch(static_cast<IActiveScript*>(this), m_script, m_scomGlobalDispatch);
	if (!m_scomEngineDispatch)
		return E_OUTOFMEMORY;
	
	return m_scomEngineDispatch->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdisp));
}

//////////////////////////////////////////////////////////////////////
// IActiveScriptParse

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::ParseScriptText(
        /* [in] */ LPCOLESTR pstrCode,
        /* [in] */ LPCOLESTR pstrItemName,
        /* [in] */ IUnknown __RPC_FAR *punkContext,
        /* [in] */ LPCOLESTR pstrDelimiter,
        /* [in] */ DWORD_PTR dwSourceContextCookie,
        /* [in] */ ULONG ulStartingLineNumber,
        /* [in] */ DWORD dwFlags,
        /* [out] */ VARIANT __RPC_FAR *pvarResult,
        /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo)
{
	V_INAME(CAudioVBScriptEngine::ParseScriptText);
	V_BUFPTR_READ(pstrCode, 2);

	if (pstrItemName || pstrDelimiter || ulStartingLineNumber != 0 || dwFlags != 0 || pvarResult)
		return E_UNEXPECTED;

	Lexer lexer(pstrCode);
	Parser p(lexer, m_script, m_scomActiveScriptSite, m_scomGlobalDispatch);
	return p.hr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\englog.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper functions for logging script parsing.  Useful for debugging, but never turned on in released builds.
//

#error This file should never be used in released builds. // 

#pragma once

#include "englex.h"
#include "engcontrol.h"

void LogToken(Lexer &l);
void LogRoutine(Script &script, Routines::index irtn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\englog.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper functions for logging script parsing.  Useful for debugging, but never turned on in released builds.
//

#error This file should never be used in released builds. // 

#include "stdinc.h"
#include "englog.h"

void LogToken(Lexer &l)
{
	char msg[500] = "";
	char type[500] = "";
	char more[500] = "";

	switch (l)
	{
	case TOKEN_eof:
		if (l.error_num())
		{
			sprintf(msg, "%d(%d): error #%d - %s\n", l.line(), l.column(), l.error_num(), l.error_descr());
			OutputDebugString(msg);
			return;
		}
		strcpy(type, "end-of-file");
		break;
	case TOKEN_sub:
		strcpy(type, "sub");
		break;
	case TOKEN_dim:
		strcpy(type, "dim");
		break;
	case TOKEN_if:
		strcpy(type, "if");
		break;
	case TOKEN_then:
		strcpy(type, "then");
		break;
	case TOKEN_end:
		strcpy(type, "end");
		break;
	case TOKEN_elseif:
		strcpy(type, "elseif");
		break;
	case TOKEN_else:
		strcpy(type, "else");
		break;
	case TOKEN_set:
		strcpy(type, "set");
		break;
	case TOKEN_call:
		strcpy(type, "call");
		break;
	case TOKEN_lparen:
		strcpy(type, "(");
		break;
	case TOKEN_rparen:
		strcpy(type, ")");
		break;
	case TOKEN_comma:
		strcpy(type, ",");
		break;
	case TOKEN_op_minus:
		strcpy(type, "-");
		break;
	case TOKEN_op_not:
		strcpy(type, "not");
		break;
	case TOKEN_op_pow:
		strcpy(type, "^");
		break;
	case TOKEN_op_mult:
		strcpy(type, "*");
		break;
	case TOKEN_op_div:
		strcpy(type, "\\");
		break;
	case TOKEN_op_mod:
		strcpy(type, "mod");
		break;
	case TOKEN_op_plus:
		strcpy(type, "+");
		break;
	case TOKEN_op_lt:
		strcpy(type, "<");
		break;
	case TOKEN_op_leq:
		strcpy(type, "<=");
		break;
	case TOKEN_op_gt:
		strcpy(type, ">");
		break;
	case TOKEN_op_geq:
		strcpy(type, ">=");
		break;
	case TOKEN_op_eq:
		strcpy(type, "=");
		break;
	case TOKEN_op_neq:
		strcpy(type, "<>");
		break;
	case TOKEN_is:
		strcpy(type, "is");
		break;
	case TOKEN_and:
		strcpy(type, "and");
		break;
	case TOKEN_or:
		strcpy(type, "or");
		break;
	case TOKEN_linebreak:
		strcpy(type, "linebreak");
		break;
	case TOKEN_identifier:
		strcpy(type, "identifier");
		strcpy(more, l.identifier_name());
		break;
	case TOKEN_identifierdot:
		strcpy(type, "identifier.");
		strcpy(more, l.identifier_name());
		break;
	case TOKEN_stringliteral:
		strcpy(type, "string-literal");
		strcpy(more, l.stringliteral_text());
		break;
	case TOKEN_numericliteral:
		strcpy(type, "numeric-literal");
		_itoa(l.numericliteral_val(), more, 10);
		break;
	default:
		strcpy(type, "invalid token type!");
		break;
	}
	static const char format[] = "%d(%d): %s\n";
	static const char formatmore[] = "%d(%d): %s(%s)\n";
	sprintf(msg, *more ? formatmore : format, l.line(), l.column(), type, more);
	OutputDebugString(msg);
}

SmartRef::AString GetVarrefName(Script &script, VariableReferences::index ivarref)
{
	VariableReference r = script.varrefs[ivarref];

	const char *pszKind;
	if (r.k == VariableReference::_global)
		pszKind = "G";
	else if (r.k == VariableReference::_local)
		pszKind = "L";

	bool fFirst = true;
	char namebuf[500] = "";
	for (ReferenceNames::index irname = r.irname; script.rnames[irname].istrIdentifier != -1; ++irname)
	{
		if (fFirst)
			fFirst = false;
		else
			strcat(namebuf, ".");
		strcat(namebuf, script.strings[script.rnames[irname].istrIdentifier]);
	}

	Variables::index islot = r.ivar;

	// check if it's a dispatch item
	if (r.k == VariableReference::_global)
	{
		DISPID dispid = script.globals[islot].dispid;
		if (dispid != DISPID_UNKNOWN)
		{
			pszKind = "D";
			islot = dispid; // show the dispid instead of the slot
		}
	}

	char buf[500];
	sprintf(buf, "{%s%d}%s", pszKind, islot, namebuf);

	return buf;
}

SmartRef::AString GetValueName(Script &script, Values::index ival)
{
	const Value &v = script.vals[ival];

	char buf[500];
	if (v.k == Value::_numvalue)
	{
		sprintf(buf, "%d", v.inumvalue);
	}
	else if (v.k == Value::_strvalue)
	{
		sprintf(buf, "\"%s\"", script.strings[v.istrvalue]);
	}
	else
	{
		assert(v.k == Value::_varref);
		return GetVarrefName(script, v.ivarref);
	}

	return buf;
}

void Indent(int iNesting)
{
	for (int i = 0; i < iNesting; ++i)
		OutputDebugString(" ");
}

// forward declaration due to mutual recursion with LogExpression
void LogCall(Script &script, Calls::index icall);

ExprBlocks::index LogExpression(Script &script, ExprBlocks::index _iexpr)
{
	char msg[500] = "";

	bool fFirst = true;
	for (ExprBlocks::index iexpr = _iexpr; script.exprs[iexpr]; ++iexpr)
	{
		ExprBlock expr = script.exprs[iexpr];

		if (fFirst)
			fFirst = false;
		else
			OutputDebugString("|");

		if (expr.k == ExprBlock::_op)
		{
			bool fUnary = false;
			const char *pszOp = "";
			switch (expr.op)
			{
			case TOKEN_sub: fUnary = true; pszOp = "-"; break;
			case TOKEN_op_not: fUnary = true; pszOp = "not"; break;
			case TOKEN_op_minus: pszOp = "-"; break;
			case TOKEN_op_pow: pszOp = "^"; break;
			case TOKEN_op_mult: pszOp = "*"; break;
			case TOKEN_op_div: pszOp = "\\"; break;
			case TOKEN_op_mod: pszOp = "mod"; break;
			case TOKEN_op_plus: pszOp = "+"; break;
			case TOKEN_op_lt: pszOp = "<"; break;
			case TOKEN_op_leq: pszOp = "<="; break;
			case TOKEN_op_gt: pszOp = ">"; break;
			case TOKEN_op_geq: pszOp = ">="; break;
			case TOKEN_op_eq: pszOp = "="; break;
			case TOKEN_op_neq: pszOp = "<>"; break;
			case TOKEN_is: pszOp = "is"; break;
			case TOKEN_and: pszOp = "and"; break;
			case TOKEN_or: pszOp = "or"; break;
			default: assert(false); break;
			}

			if (fUnary)
				sprintf(msg, "%su", pszOp);
			else
				sprintf(msg, "%sb", pszOp);
			OutputDebugString(msg);
		}
		else if (expr.k == ExprBlock::_val)
		{
			SmartRef::AString astrVal = GetValueName(script, expr.ival);
			OutputDebugString(astrVal);
		}
		else
		{
			assert(expr.k == ExprBlock::_call);
			LogCall(script, expr.icall);
		}
	}
	return iexpr;
}

void LogCall(Script &script, Calls::index icall)
{
	Call c = script.calls[icall];

	if (c.k == Call::_global)
	{
		OutputDebugString(script.strings[c.istrname]);
	}
	else
	{
		assert(c.k == Call::_dereferenced);
		SmartRef::AString astrCall = GetVarrefName(script, c.ivarref);
		OutputDebugString(astrCall);
	}

	OutputDebugString("(");
	bool fFirst = true;
	for (ExprBlocks::index iexpr = c.iexprParams; script.exprs[iexpr]; ++iexpr)
	{
		if (fFirst)
			fFirst = false;
		else
			OutputDebugString(", ");
		iexpr = LogExpression(script, iexpr);
	}

	OutputDebugString(")");
}

void LogStatements(Script &script, Statements::index istmt, int iNesting)
{
	char msg[500] = "";
	for (; script.statements[istmt].k; ++istmt)
	{
		Statement s = script.statements[istmt];
		if (s.k == Statement::_asgn)
		{
			Assignment a = script.asgns[s.iasgn];

			SmartRef::AString astrLHS = GetVarrefName(script, a.ivarrefLHS);
			sprintf(msg, "%s = ", astrLHS);
			Indent(iNesting);
			OutputDebugString(msg);

			LogExpression(script, a.iexprRHS);
			OutputDebugString("\n");
		}
		else if (s.k == Statement::_if)
		{
			bool fFirst = true;
			for (IfBlocks::index iif = s.iif; script.ifs[iif].k != IfBlock::_end; ++iif)
			{
				Indent(iNesting);

				IfBlock ib = script.ifs[iif];
				if (fFirst)
				{
					assert(ib.k == IfBlock::_cond);
					OutputDebugString("if ");
					fFirst = false;
				}
				else
				{
					if (ib.k == IfBlock::_cond)
						OutputDebugString("elseif ");
					else if (ib.k == IfBlock::_else)
						OutputDebugString("else");
				}

				if (ib.k == IfBlock::_cond)
				{
					LogExpression(script, ib.iexprCondition);
				}

				OutputDebugString("\n");
				LogStatements(script, ib.istmtBlock, iNesting + 3);				
			}

			istmt = s.istmtIfTail - 1; // -1 to offset the loop, which will increment it back
		}
		else if (s.k == Statement::_call)
		{
			Indent(iNesting);
			LogCall(script, s.icall);
			OutputDebugString("\n");
		}
		else
		{
			assert(false);
			Indent(iNesting);
			OutputDebugString("   Unknown statement type!\n");
		}
	}
}

void LogRoutine(Script &script, Routines::index irtn)
{
	Routine r = script.routines[irtn];
	const char *pszName = script.strings[r.istrIdentifier];
	int cLocals = r.ivarNextLocal;

	char msg[500] = "";
	sprintf(msg, "@ Sub %s (%d locals)\n", pszName, cLocals);
	OutputDebugString(msg);
	LogStatements(script, r.istmtBody, 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\englex.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Lexer.
//

//#define LIMITEDVBSCRIPT_LOGLEXER // 

#include "stdinc.h"
#include "enginc.h"
#include "englex.h"
#include "limits"

#ifdef LIMITEDVBSCRIPT_LOGLEXER
#include "englog.h"
#endif

//////////////////////////////////////////////////////////////////////
// Unicode/ASCII character classification

inline bool iswasciialpha(WCHAR c) { return (c >= L'a' && c <= L'z') || (c >= L'A' && c <= L'Z'); }
inline bool iswasciidigit(WCHAR c) { return c >= L'0' && c <= L'9'; }
inline bool iswasciialnum(WCHAR c) { return iswasciialpha(c) || iswasciidigit(c); }
inline WCHAR towasciilower(WCHAR c) { return (c >= L'A' && c <= L'Z') ? c + (L'a' - L'A') : c; }

//////////////////////////////////////////////////////////////////////
// token tables

const TokenKeysym g_TokenKeysyms[] =
	{
		{ L'(', TOKEN_lparen },
		{ L')', TOKEN_rparen },
		{ L',', TOKEN_comma },
		{ L'-', TOKEN_op_minus },
		{ L'^', TOKEN_op_pow },
		{ L'*', TOKEN_op_mult },
		{ L'\\', TOKEN_op_div },
		{ L'+', TOKEN_op_plus },
		{ L'<', TOKEN_op_lt },
		{ L'>', TOKEN_op_gt },
		{ L'=', TOKEN_op_eq },
		{ L'\0', TOKEN_eof }
	};

const TokenKeyword g_TokenKeywords[] =
	{
		{ L"sub", TOKEN_sub },
		{ L"dim", TOKEN_dim },
		{ L"if", TOKEN_if },
		{ L"then", TOKEN_then },
		{ L"end", TOKEN_end },
		{ L"elseif", TOKEN_elseif },
		{ L"else", TOKEN_else },
		{ L"set", TOKEN_set },
		{ L"call", TOKEN_call },
		{ L"not", TOKEN_op_not },
		{ L"mod", TOKEN_op_mod },
		{ L"is", TOKEN_is },
		{ L"and", TOKEN_and },
		{ L"or", TOKEN_or },
		{ NULL, TOKEN_eof }
	};

//////////////////////////////////////////////////////////////////////
// helper functions

bool
CheckOperatorType(Token t, bool fAcceptParens, bool fAcceptUnary, bool fAcceptBinary, bool fAcceptOverloadedAssignmentTokens)
{
	switch (t)
	{
	case TOKEN_set:
	case TOKEN_sub:
		return fAcceptOverloadedAssignmentTokens;

	case TOKEN_lparen:
	case TOKEN_rparen:
		return fAcceptParens;

	case TOKEN_op_minus:
		return fAcceptUnary || fAcceptBinary;

	case TOKEN_op_not:
		return fAcceptUnary;

	case TOKEN_op_pow:
	case TOKEN_op_mult:
	case TOKEN_op_div:
	case TOKEN_op_mod:
	case TOKEN_op_plus:
	case TOKEN_op_lt:
	case TOKEN_op_leq:
	case TOKEN_op_gt:
	case TOKEN_op_geq:
	case TOKEN_op_eq:
	case TOKEN_op_neq:
	case TOKEN_is:
	case TOKEN_and:
	case TOKEN_or:
		return fAcceptBinary;
	}

	return false;
}

//////////////////////////////////////////////////////////////////////
// Lexer

Lexer::Lexer(const WCHAR *pwszSource)
  : m_p(pwszSource),
	m_pNext(NULL),
	m_iLine(1),
	m_iColumn(1),
	m_t(TOKEN_sub)
{
	this->Scan();
}

void
Lexer::Next()
{
	assert(m_t != TOKEN_eof);
	if (m_pNext)
	{
		m_iColumn += (int)(m_pNext - m_p);
		m_p = m_pNext;
		m_pNext = NULL;
	}
	else
	{
		++m_p;
		++m_iColumn;
	}
}

void
Lexer::Scan()
{
	m_szStr[0] = L'\0';
	m_iNum = 0;
	bool fLineBreak = m_t == TOKEN_linebreak;
	for (;;)
	{
		if (fLineBreak)
		{
			// line breaks tokens are reported on the line/column that they occur so this isn't isn't adjusted until the next pass
			++m_iLine;
			m_iColumn = 1;
		}

		ScanMain();
		if (!fLineBreak || m_t != TOKEN_linebreak)
			break;

		Next();
	}

#ifdef LIMITEDVBSCRIPT_LOGLEXER
	LogToken(*this);
#endif
}

void
Lexer::ScanMain()
{
	for (;; this->Next())
	{
		switch (*m_p)
		{
		case L'\0':
			// end of script
			m_t = TOKEN_eof;
			return;

		case L'\'':
			// comment till end of line
			for (; *m_p && *m_p != L'\n'; ++m_p)
			{}

			--m_p; // put one char back so the next loop can process it
			break;

		case L'\t': case L' ':
			// ignore horizontal white space
			break;

		case L'\r':
			// ignore carriage returns
			--m_iColumn; // in fact, they don't even count as characters
			break;

		case L'\n':
			// line break
			m_t = TOKEN_linebreak;
			return;

		default:
			if (*m_p == L'\"')
			{
				// string literal
				m_pNext = m_p + 1;
				char *pszDest = m_szStr;
				const char *pszMax = m_szStr + g_iMaxBuffer - 1;
				do
				{
					if (!iswascii(*m_pNext))
					{
						this->Next(); // this will update the current position to the offending character -- indicating the correct column of the error
						this->err(LEXERR_NonAsciiCharacterInStringLiteral);
						return;
					}

					if (*m_pNext == L'\n' || *m_pNext == L'\r')
					{
						this->err(LEXERR_StringLiteralUnterminated);
						return;
					}

					if (*m_pNext == L'\"')
					{
						if (*++m_pNext != L'\"')
							break; // found terminating quote

						// There were two quotes, the escape sequence for a single quote.  The first was skipped and we're all ready to append the second.
					}
					
					*pszDest++ = *m_pNext++; // we know this works because the character is ascii and those codes correspond to the same numbers in Unicode
				} while (pszDest <= pszMax);

				if (pszDest > pszMax)
				{
					this->err(LEXERR_StringLiteralTooLong);
				}
				else
				{
					*pszDest = L'\0';
					m_t = TOKEN_stringliteral;
				}
				return;
			}

			if (iswasciidigit(*m_p))
			{
				// numeric literal
				// Cant find a _wtoi like function that handles overflow so do the conversion myself.

				//  Look at runtime version to be sure these aren't constantly recomputed
				const int iMaxChop = std::numeric_limits<int>::max() / 10; // if number gets bigger than this and there's another digit then we're going to overflow
				const WCHAR wchMaxLast = std::numeric_limits<int>::max() % 10 + L'0'; // if number equals iMaxChop and the next digit is bigger than this then we're going to overflow

				m_pNext = m_p;
				m_iNum = 0;
				do
				{
					m_iNum *= 10;
					m_iNum += *m_pNext++ - L'0';
				} while (iswasciidigit(*m_pNext) && (m_iNum < iMaxChop || (m_iNum == iMaxChop && *m_pNext <= wchMaxLast)));

				if (iswasciidigit(*m_pNext))
					this->err(LEXERR_NumericLiteralTooLarge);
				else
					m_t = TOKEN_numericliteral;
				return;
			}

			if (!iswasciialpha(*m_p) && !(*m_p == L'_'))
			{
				// look for a token in the table of symbols
				for (int i = 0; g_TokenKeysyms[i].c; ++i)
				{
					if (*m_p == g_TokenKeysyms[i].c)
					{
						// we have a match
						m_t = g_TokenKeysyms[i].t;

						// check for the two-character symbols (>=, <=, <>)
						if (m_t == TOKEN_op_lt)
						{
							WCHAR wchNext = *(m_p + 1);
							if (wchNext == L'=')
							{
								m_t = TOKEN_op_leq;
								m_pNext = m_p + 2;
							}
							else if (wchNext == L'>')
							{
								m_t = TOKEN_op_neq;
								m_pNext = m_p + 2;
							}
						}
						else if (m_t == TOKEN_op_gt)
						{
							if (*(m_p + 1) == L'=')
							{
								m_t = TOKEN_op_geq;
								m_pNext = m_p + 2;
							}
						}

						return;
					}
				}

				// the symbol was not recognized
				this->err(LEXERR_InvalidCharacter);
				return;
			}

			// look for a token in the table of keywords
			for (int i = 0; g_TokenKeywords[i].s; ++i)
			{
				const WCHAR *pwchToken = g_TokenKeywords[i].s;
				const WCHAR *pwchSource = m_p;
				while (*pwchToken && *pwchSource && towasciilower(*pwchToken) == towasciilower(*pwchSource))
				{
					++pwchToken;
					++pwchSource;
				}

				if (!*pwchToken && !iswasciialnum(*pwchSource))
				{
					// made it to the end of Token and source word
					m_t = g_TokenKeywords[i].t;
					m_pNext = pwchSource;
					return;
				}
			}

			// must be an identifier
			for (m_pNext = m_p + 1; iswasciialnum(*m_pNext) || *m_pNext == L'_'; ++m_pNext)
			{}

			if (m_pNext - m_p > g_iMaxBuffer - 1)
			{
				this->err(LEXERR_IdentifierTooLong);
				return;
			}

			char *psz = m_szStr;
			for (const WCHAR *pwsz = m_p; pwsz < m_pNext; ++psz, ++pwsz)
			{
				*psz = *pwsz;
			}

			*psz = '\0';

			if (*m_pNext == L'.')
			{
				++m_pNext;
				m_t = TOKEN_identifierdot;
			}
			else
			{
				m_t = TOKEN_identifier;
			}
			return;
		}
	}
}

void Lexer::err(LexErr iErr)
{
	static const char *s_rgpszErrorText[] =
		{
		"Unexpected error!", // shouldn't ever get this error
		"Invalid character",
		"Identifier too long",
		"String too long",
		"Unterminated string constant",
		"Number too large"
 		};

	assert(ARRAY_SIZE(s_rgpszErrorText) == LEXERR_Max);
	if (iErr <= 0 || iErr >= LEXERR_Max)
	{
		assert(false);
		iErr = LEXERR_NoError;
	}

	m_t = TOKEN_eof;
	m_iNum = iErr;

	// copy error into the buffer
	const char *psz = s_rgpszErrorText[iErr];
	const char *pszMax = m_szStr + g_iMaxBuffer - 1;
	for (char *pszDest = m_szStr; pszDest < pszMax && *psz; *pszDest++ = *psz++)
	{}

	assert(!*psz); // since this function is used with hard-coded strings we shouldn't ever get one too long
	*pszDest = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\englex.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Lexer.
//

// Lexical analyzer for AudioVBScript.  Breaks down the characters of source code into a stream tokens.

#pragma once

const int g_iMaxBuffer = 256; // max length for VBScript identifiers is 255

enum LexErr
{
	LEXERR_NoError = 0,
	LEXERR_InvalidCharacter,
	LEXERR_NonAsciiCharacterInStringLiteral = LEXERR_InvalidCharacter,
	LEXERR_IdentifierTooLong,
	LEXERR_StringLiteralTooLong,
	LEXERR_StringLiteralUnterminated,
	LEXERR_NumericLiteralTooLarge,
	LEXERR_Max
};

enum Token
{
	TOKEN_eof = 0, // used for end of file or an error (nenzero error_num() indicates an error)
	TOKEN_sub,
	TOKEN_dim,
	TOKEN_if,
	TOKEN_then,
	TOKEN_end,
	TOKEN_elseif,
	TOKEN_else,
	TOKEN_set,
	TOKEN_call,
	TOKEN_lparen,
	TOKEN_rparen,
	TOKEN_comma,
	TOKEN_op_minus,
	TOKEN_op_not,
	TOKEN_op_pow,
	TOKEN_op_mult,
	TOKEN_op_div,
	TOKEN_op_mod,
	TOKEN_op_plus,
	TOKEN_op_lt,
	TOKEN_op_leq,
	TOKEN_op_gt,
	TOKEN_op_geq,
	TOKEN_op_eq,
	TOKEN_op_neq,
	TOKEN_is,
	TOKEN_and,
	TOKEN_or,
	TOKEN_linebreak,
	TOKEN_identifier,
	TOKEN_identifierdot,
	TOKEN_stringliteral,
	TOKEN_numericliteral
};

struct TokenKeysym
{
	WCHAR c;
	Token t;
};
extern const TokenKeysym g_TokenKeysyms[];

struct TokenKeyword
{
	const WCHAR *s;
	Token t;
};
extern const TokenKeyword g_TokenKeywords[];

bool CheckOperatorType(Token t, bool fAcceptParens, bool fAcceptUnary, bool fAcceptBinary, bool fAcceptOverloadedAssignmentTokens);

class Lexer
{
public:
	Lexer(const WCHAR *pwszSource);

	Lexer &operator++() { Next(); Scan(); return *this; }
	int line() { return m_iLine; }
	int column() { return m_iColumn; }
	operator Token() { return m_t; }

	// Additional token-specific info.  Only valid while on this token.

	// error
	int error_num() { assert(m_t == TOKEN_eof); return num(); } // 0 if no error
	const char *error_descr() { assert(m_t == TOKEN_eof); return str(); }

	// identifier and identifierdot
	const char *identifier_name() { assert(m_t == TOKEN_identifier || m_t == TOKEN_identifierdot); return str(); }

	// numeric literal
	int numericliteral_val() { assert(m_t == TOKEN_numericliteral); return num(); }

	// string literal
	const char *stringliteral_text() { assert(m_t == TOKEN_stringliteral); return str(); }

private:
	friend class CActiveScriptError;

	void Next();
	void Scan(); // handling for line break tokens and calls ScanMain
	void ScanMain();

	const char *str() { return m_szStr; } // Multipurpose string info set by some tokens.
	void err(LexErr iErr);
	int num() { return m_iNum; } // Multipurpose numeric info set by some tokens.

	const WCHAR *m_p;
	const WCHAR *m_pNext; // If this is set then the next Next call will advance the pointer (and the column) to this point.
	int m_iLine;
	int m_iColumn;
	Token m_t;

	char m_szStr[g_iMaxBuffer];
	int m_iNum;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\englookup.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Strings, Slots, and Hash.
//

// Strings holds a collection of strings in one big chunk of memory.
// Slots is just a collection that can be appended to and accessed
// Lookup is used during parsing and then discarded at runtime.  It maps strings to consecutive slots and positions in Strings.

#pragma once

class Strings
{
public:
#ifdef _WIN64
	typedef __int64 index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#else
	typedef int index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#endif

	Strings();
	~Strings();

	HRESULT Add(const char *psz, index &i);

    // The address of the stored string returned by operator[]
    // is guarenteed to not change over the lifetime of the Strings object.
    // (The Lookup class implementation requires this behavior.)

	const char *operator[](index i);

private:
	char *m_pszBuf;
	index m_iCur;
	index m_iSize;
    index m_iBase;
	static const index ms_iInitialSize;
};

template<class T>
class Slots
{
public:
#ifdef _WIN64
	typedef __int64 index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#else
	typedef int index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#endif

	index Next() { return m_v.size(); }
	HRESULT Add(T t) { index i = m_v.size(); if (!m_v.AccessTo(i)) return E_OUTOFMEMORY; m_v[i] = t; return S_OK; }
	T& operator[](index i) { return m_v[i]; }

private:
	SmartRef::Vector<T> m_v;
};

// hungarian: lku
class Lookup
{
public:
#ifdef _WIN64
	typedef __int64 slotindex; // don't want to have to template this on the kind of slot just for its index since it is just an int anyway
#else
	typedef int slotindex; // don't want to have to template this on the kind of slot just for its index since it is just an int anyway
#endif

	struct indices
	{
		Strings::index iString;
		slotindex iSlot;
	};

	Lookup(HRESULT *phr, Strings &strings, int iInitialSize) : m_h(phr, iInitialSize), m_strings(strings) {}
	indices &operator[](const char *psz) { StrKey k; k.psz = psz; return m_h[k]; }

	// both indices are out parameters, set only if the entry is found
	bool Find(const char *psz, slotindex &iSlot, Strings::index &iString) { return S_OK == FindOrAddInternal(false, psz, iSlot, iString); }

	// iSlot is in (next slot to add items) and out (slot if found in existing items).  iString is out only.  returns E_OUTOFMEMORY, S_OK (found), or S_FALSE (added).
	HRESULT FindOrAdd(const char *psz, slotindex &iSlot, Strings::index &iString) { return FindOrAddInternal(true, psz, iSlot, iString); }

private:
	HRESULT FindOrAddInternal(bool fAdd, const char *psz, slotindex &iSlot, Strings::index &iString);

	bool m_fInitialized;

	struct StrKey
	{
		const char *psz;
		int Hash() { int i = 0; for (const char *p = psz; *p != '\0'; i += tolower(*p++)) {} return i; };
		bool operator ==(const StrKey &o) { return 0 == _stricmp(psz, o.psz); }
	};

	typedef SmartRef::Hash<StrKey, indices> stringhash;
	stringhash m_h;
	Strings &m_strings;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engparse.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of Parser.
//

//#define LIMITEDVBSCRIPT_LOGPARSER // 

#include "stdinc.h"
#include "enginc.h"
#include "engparse.h"
#include "engerror.h"
#include "engexpr.h"

#ifdef LIMITEDVBSCRIPT_LOGPARSER
#include "englog.h"
#endif

// initial sizes for hash tables
//  tune these values?
const int g_cInitialRoutineLookup = 32;
const int g_cInitialGlobalsLookup = 32;
const int g_cInitialVarRefsLookup = 64;
const int g_cInitialAttrsLookup = 32;
const int g_cInitialLocalsLookup = 32;

// The parser will just hold weak references to the passed interfaces because we know that the parser is fully
// contained in the lifetime of its parent -- CAudioVBScriptEngine.
Parser::Parser(Lexer &lexer, Script &script, IActiveScriptSite *pActiveScriptSite, IDispatch *pGlobalDispatch)
  : m_lexer(lexer),
	m_plkuRoutines(NULL),
	m_plkuGlobals(NULL),
	m_plkuVarRefs(NULL),
	m_plkuNames(NULL),
	m_pActiveScriptSite(pActiveScriptSite),
	m_script(script),
	m_pGlobalDispatch(pGlobalDispatch)
{
	m_plkuRoutines = new Lookup(&m_hr, m_script.strings, g_cInitialRoutineLookup);
	if (!m_plkuRoutines)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	m_plkuGlobals = new Lookup(&m_hr, m_script.strings, g_cInitialGlobalsLookup);
	if (!m_plkuGlobals)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	m_plkuVarRefs = new Lookup(&m_hr, m_script.strings, g_cInitialVarRefsLookup);
	if (!m_plkuVarRefs)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	m_plkuNames = new Lookup(&m_hr, m_script.strings, g_cInitialAttrsLookup);
	if (!m_plkuNames)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	// Set up the built in constants as the first global variables.
	for (int i = 0; i < g_cBuiltInConstants; ++i)
	{
		Variables::index iSlot = m_script.globals.Next();
		Strings::index iStr;
		m_hr = m_plkuGlobals->FindOrAdd(g_rgszBuiltInConstants[i], iSlot, iStr);
		if (FAILED(m_hr))
			return;
		assert(m_hr == S_FALSE);
		Variable variable(iStr);
		m_hr = m_script.globals.Add(variable);
		if (FAILED(m_hr))
			return;
	}
	assert(m_script.globals.Next() == g_cBuiltInConstants); // they occupy the slots 0 to g_cBuiltInConstants - 1

	ParseScript();
}

Parser::~Parser()
{
	delete m_plkuRoutines;
	delete m_plkuGlobals;
	delete m_plkuVarRefs;
	delete m_plkuNames;
}

// top-level loop that parses the script
void
Parser::ParseScript()
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	// make sure the lexer has a token to start with
	if (!m_lexer)
	{
		if (m_lexer.error_num())
			Error(PARSEERR_LexerError);
		return;
	}
	if (Skip(TOKEN_linebreak) || !m_lexer)
		return;

	// parse subs and dims...
	bool fSub = false; // used to ensure that add Dim statements occur before all Sub statements
	for (;;)
	{
		if (m_lexer == TOKEN_dim)
		{
			if (fSub)
				Error(PARSEERR_DimAfterSub);
			else
				ParseDim();
		}
		else if (m_lexer == TOKEN_sub)
		{
			fSub = true;
			ParseSub();
		}
		else
		{
			Error(PARSEERR_ExpectedSubOrDim);
		}

		if (FAILED(m_hr) || !m_lexer)
			return;

		// must be followed by line break
		if (Expect(TOKEN_linebreak, PARSEERR_ExpectedLineBreak) || !m_lexer)
			return;
	}
}

// pre:  at sub
// post: beyond end sub
void
Parser::ParseSub()
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	// sub followed by identifier
	assert(m_lexer == TOKEN_sub);
	if (ExpectNext(TOKEN_identifier, PARSEERR_ExpectedIdentifier))
		return;

	const char *pszName = m_lexer.identifier_name();

	// check if there's already a variable with this name
	Variables::index iVar;
	Strings::index iStrVar;
	if (m_plkuGlobals->Find(pszName, iVar, iStrVar))
	{
		Error(PARSEERR_DuplicateVariable);
		return;
	}

	Routines::index iSlot = m_script.routines.Next();
	Strings::index iStr;
	m_hr = m_plkuRoutines->FindOrAdd(pszName, iSlot, iStr);
	if (FAILED(m_hr))
		return;
	if (m_hr == S_FALSE)
	{
		Routine routine(iStr);

		m_hr = m_script.routines.Add(routine);
		if (FAILED(m_hr))
			return;
	}
	else
	{
		Error(PARSEERR_DuplicateRoutine);
		return;
	}

	if (ExpectNext(TOKEN_linebreak, PARSEERR_ExpectedLineBreak))
		return;

	Lookup lkuLocals(&m_hr, m_script.strings, g_cInitialLocalsLookup);
	if (FAILED(m_hr))
		return;

	m_script.routines[iSlot].istmtBody = ParseStatements(iSlot, lkuLocals);
	if (FAILED(m_hr))
		return;

	if (m_lexer != TOKEN_end)
	{
		if (m_lexer == TOKEN_dim)
		{
			// AudioVBScript disallows dim statements except at the top of the script.
			// If one was found in the sub, users should receive the more specific error message.
			Error(PARSEERR_DimAfterSub);
		}
		else
		{
			Error(PARSEERR_ExpectedEndSub);
		}
		return;
	}
	if (Advance())
		return;
	if (Expect(TOKEN_sub, PARSEERR_ExpectedSub))
		return;

#ifdef LIMITEDVBSCRIPT_LOGPARSER
	LogRoutine(m_script, iSlot);
#endif
}

// pre:  at dim
// post: beyond dim <identifier>
void
Parser::ParseDim()
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	assert(m_lexer == TOKEN_dim);
	if (ExpectNext(TOKEN_identifier, PARSEERR_ExpectedIdentifier))
		return;

	Variables::index iSlot = m_script.globals.Next();
	Strings::index iStr;
	m_hr = m_plkuGlobals->FindOrAdd(m_lexer.identifier_name(), iSlot, iStr);
	if (FAILED(m_hr))
		return;
	if (m_hr == S_FALSE)
	{
		Variable variable(iStr);

		m_hr = m_script.globals.Add(variable);
		if (FAILED(m_hr))
			return;
	}
	else
	{
		Error(PARSEERR_DuplicateVariable);
		return;
	}

	if (Advance())
		return;
}

// pre:  at line break preceding the expected statements
// post: after end of line at token that isn't the start of another statement
Statements::index
Parser::ParseStatements(Routines::index irtnContext, Lookup &lkuLocals)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	assert(m_lexer == TOKEN_linebreak);
	if (Skip(TOKEN_linebreak))
		return 0;

	Statements::index istmtStart = m_script.statements.Next();
	for (;;) // ever
	{
		bool fBreakLoop = false;
		switch (m_lexer)
		{
		case TOKEN_if:
			ParseIf(irtnContext, lkuLocals);
			break;

		case TOKEN_set:
			if (Advance())
				return 0;
			ParseAssignmentOrCall(irtnContext, lkuLocals, true, false);
			break;

		case TOKEN_call:
			if (Advance())
				return 0;
			ParseAssignmentOrCall(irtnContext, lkuLocals, false, true);
			break;

		case TOKEN_identifier:
		case TOKEN_identifierdot:
			ParseAssignmentOrCall(irtnContext, lkuLocals, false, false);
			break;

		default:
			fBreakLoop = true;
			break;
		}

		if (fBreakLoop)
			break;

		if (FAILED(m_hr) || Expect(TOKEN_linebreak, PARSEERR_ExpectedLineBreak))
			return 0;
	}

	m_hr = m_script.statements.Add(Statement(Statement::cons_end(), 0));
	if (FAILED(m_hr))
		return 0;
	return istmtStart;
}

// pre:  at identifier or identifierdot (ambiguous as to whether this is going to be an assignment "x = 1" or call "x(1)")
// post: at line break beyond statement
void
Parser::ParseAssignmentOrCall(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, bool fCall)
{
	assert(!(fSet && fCall));

	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	assert(m_lexer == TOKEN_identifier || m_lexer == TOKEN_identifierdot);

	NameReference nref;
	ParseNameReference(irtnContext, lkuLocals, nref);
	if (FAILED(m_hr))
		return;

	if (fCall ? ExpectNext(TOKEN_lparen, PARSEERR_ExpectedLparen) : Advance())
		return;

	if (m_lexer == TOKEN_op_eq)
	{
		VariableReferences::index ivarrefLHS = VariableReferenceFromNameReference(irtnContext, lkuLocals, nref);
		if (FAILED(m_hr))
			return;
		Assignments::index iasgn = ParseAssignment(irtnContext, lkuLocals, fSet, ivarrefLHS);
		if (FAILED(m_hr))
			return;
		m_hr = m_script.statements.Add(Statement(Statement::cons_asgn(), iasgn, m_lexer.line()));
		if (FAILED(m_hr))
			return;
	}
	else
	{
		if (fSet)
		{
			Error(PARSEERR_ExpectedEq);
			return;
		}

		// add the call and its statement
		Calls::index icall = CallFromNameReference(irtnContext, lkuLocals, nref, fCall);
		if (FAILED(m_hr))
			return;
		m_hr = m_script.statements.Add(Statement(Statement::cons_call(), icall, m_lexer.line()));
		if (FAILED(m_hr))
			return;
	}
}

// pre:  at identifierdot
// post: at identifier
VariableReferences::index Parser::ParseDottedVariableReference(Routines::index irtnContext, Lookup &lkuLocals)
{
	return VariableReferenceInternal(irtnContext, lkuLocals, NULL);
}

// pre:  at =
// post: at line break beyond statement
Assignments::index
Parser::ParseAssignment(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, VariableReferences::index ivarrefLHS)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	// make sure they're not trying to assign to one of the built in constants
	VariableReference &vr = m_script.varrefs[ivarrefLHS];
	if (vr.k == VariableReference::_global && vr.ivar < g_cBuiltInConstants)
	{
		Error(PARSEERR_AssignedToBuiltInConstant);
		return 0;
	}

	assert(m_lexer == TOKEN_op_eq);
	if (Skip(TOKEN_op_eq))
		return 0;

	ExprBlocks::index iexprRHS = ParseExpression(irtnContext, lkuLocals, NULL, false, false);
	if (FAILED(m_hr))
		return 0;

	if (m_lexer != TOKEN_linebreak)
	{
		Error(PARSEERR_InvalidExprLineBreak);
		return 0;
	}

	Assignments::index iasgn = m_script.asgns.Next();
	m_hr = m_script.asgns.Add(Assignment(fSet, ivarrefLHS, iexprRHS));
	if (FAILED(m_hr))
		return 0;

	return iasgn;
}

// pre:  at if
// post: beyond end if
void
Parser::ParseIf(Routines::index irtnContext, Lookup &lkuLocals)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	// Temporarily place if blocks in separate slots.
	// After completing the whole if statement then we'll append them to m_script.ifs.
	// This is necessary because we could end up recursively parsing nested ifs and the parent if
	// can't have its if blocks interleaved with its children.
	IfBlocks ifsTemp;

	// add the main if statement, which needs to go on first before we add the statements from its body
	Statements::index istmtIf = m_script.statements.Next();
	m_hr = m_script.statements.Add(Statement(Statement::cons_if(), m_lexer.line()));
	if (FAILED(m_hr))
		return;

	bool fFirst = true;

	do
	{
		// determine what part of the if (if/elseif/else) we're dealing with
		bool fCondition = true;
		if (fFirst)
		{
			assert(m_lexer == TOKEN_if);
			fFirst = false;
		}
		else
		{
			assert(m_lexer == TOKEN_elseif || m_lexer == TOKEN_else);
			if (m_lexer == TOKEN_else)
				fCondition = false;
		}
		if (Advance())
			return;

		ExprBlocks::index iexprIf = 0;
		if (fCondition)
		{
			// read the condition followed by then
			iexprIf = ParseExpression(irtnContext, lkuLocals, NULL, false, false);
			if (FAILED(m_hr))
				return;
			if (Expect(TOKEN_then, PARSEERR_ExpectedThen))
				return;
		}

		// line break
		if (m_lexer != TOKEN_linebreak)
		{
			Error(!fCondition && m_lexer == TOKEN_if ? PARSEERR_IntendedElseIf : PARSEERR_ExpectedLineBreak);
			return;
		}

		// statements
		Statements::index istmtIfBody = ParseStatements(irtnContext, lkuLocals);
		if (FAILED(m_hr))
			return;

		// add the if block
		if (fCondition)
			m_hr = ifsTemp.Add(IfBlock(iexprIf, istmtIfBody));
		else
			m_hr = ifsTemp.Add(IfBlock(istmtIfBody));
		if (FAILED(m_hr))
			return;
	}
	while (m_lexer != TOKEN_end);

	if (Advance())
		return;
	if (Expect(TOKEN_if, PARSEERR_ExpectedIf))
		return;

	// copy the temp if blocks into the script's real blocks
	IfBlocks::index iifIf = m_script.ifs.Next();
	IfBlocks::index iifTempNext = ifsTemp.Next();
	for (IfBlocks::index iifTemp = 0; iifTemp < iifTempNext; ++iifTemp)
	{
		m_hr = m_script.ifs.Add(ifsTemp[iifTemp]);
		if (FAILED(m_hr))
			return;
	}

	// terminate the if blocks
	m_hr = m_script.ifs.Add(IfBlock());
	if (FAILED(m_hr))
		return;

	// now set the main if statement's if blocks and tail
	Statement &stmtIf = m_script.statements[istmtIf];
	stmtIf.iif = iifIf;
	stmtIf.istmtIfTail = m_script.statements.Next();
}

// pre:  none (at location where expression is exprected)
// post: beyond last token that is part of a legal expression
ExprBlocks::index
Parser::ParseExpression(Routines::index irtnContext, Lookup &lkuLocals, ExprBlocks *peblocks, bool fAllowRparenAtEnd, bool fDetectSpecialErrorForSubCallWithParen)
{
	// if peblocks is non-null then the expression is appended there
	// otherwise it goes onto the blocks in the script
	ExprBlocks &eblocks = peblocks ? *peblocks : m_script.exprs;

	Expression expr(m_script, m_stack, peblocks);
	
	if (m_lexer == TOKEN_stringliteral)
	{
		// a string literal is the only element of an expression
		Strings::index iStr;
		m_hr = m_script.strings.Add(m_lexer.stringliteral_text(), iStr);
		if (FAILED(m_hr))
			return 0;
		Values::index ival = m_script.vals.Next();
		m_hr = m_script.vals.Add(Value(Value::cons_strvalue(), iStr));
		if (FAILED(m_hr))
			return 0;
		m_hr = expr.Add(ExprBlock(ExprBlock::cons_val(), ival));
		if (FAILED(m_hr))
			return 0;
		if (Advance())
			return 0;
	}
	else
	{
		// The format of an expression is:
		// 1) zero or more unary operators
		// 2) a value
		// 3) either end here or have a binary operator and go back to step 1

		// Oh yeah?  What about parentheses?
		// * If a left paren is encountered in step 2, we increase a paren count and go back to stage 1.
		// * In stage three, if there is paren count then a right paren is expected instead of ending.
		//   After a matching right paren, we decrease the paren count and pop back to stage 3.

		UINT cParens = 0;

		for (;;)
		{
			// stage 1
			while (CheckOperatorType(m_lexer, false, true, false, false))
			{
				// replace minus with sub so that the expression evaluator can identify unary (negation) vs binary (subtraction)
				m_hr = expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer == TOKEN_op_minus ? TOKEN_sub : m_lexer));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;
			}

			// stage 2
			if (m_lexer == TOKEN_lparen)
			{
				m_hr = expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;

				++cParens;
				continue;
			}
			else if (m_lexer == TOKEN_identifier || m_lexer == TOKEN_identifierdot)
			{
				NameReference nref;
				ParseNameReference(irtnContext, lkuLocals, nref);
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;

				if (m_lexer == TOKEN_lparen)
				{
					// add the call and the expression block
					Calls::index icall = CallFromNameReference(irtnContext, lkuLocals, nref, true);
					m_hr = expr.Add(ExprBlock(ExprBlock::cons_call(), icall));
					if (FAILED(m_hr))
						return 0;
				}
				else
				{

					VariableReferences::index ivarref = VariableReferenceFromNameReference(irtnContext, lkuLocals, nref);
					if (FAILED(m_hr))
						return 0;
					Values::index ival = m_script.vals.Next();
					m_hr = m_script.vals.Add(Value(Value::cons_varref(), ivarref));
					if (FAILED(m_hr))
						return 0;
					m_hr = expr.Add(ExprBlock(ExprBlock::cons_val(), ival));
					if (FAILED(m_hr))
						return 0;
				}
			}
			else if (m_lexer == TOKEN_numericliteral)
			{
				Values::index ival = m_script.vals.Next();
				m_hr = m_script.vals.Add(Value(Value::cons_numvalue(), m_lexer.numericliteral_val()));
				if (FAILED(m_hr))
					return 0;
				m_hr = expr.Add(ExprBlock(ExprBlock::cons_val(), ival));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;
			}
			else
			{
				Error(m_lexer == TOKEN_stringliteral ? PARSEERR_StringInExprBlock: PARSEERR_ExpectedExprValue);
				return 0;
			}

			// stage 3
			while (m_lexer == TOKEN_rparen)
			{
				if (cParens == 0)
				{
					if (fAllowRparenAtEnd)
						break;

					Error(PARSEERR_UnexpectedRparen);
					return 0;
				}

				m_hr = expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;
				--cParens;
			}

			if (!CheckOperatorType(m_lexer, false, false, true, false))
			{
				if (cParens > 0)
				{
					if (fDetectSpecialErrorForSubCallWithParen && cParens == 1 && m_lexer == TOKEN_comma)
					{
						// This special error is needed to give a helpful error message in cases like the following:
						//    Segment1.Play(IsSecondary, AP)
						// Here the user has accidentally called a sub using parentheses when they shouldn't.
						Error(PARSEERR_ParensUsedCallingSub);
					}
					else
					{
						Error(PARSEERR_ExpectedRparen);
					}
					return 0;
				}

				// *** this is the only successful exit point from the loop ***
				break;
			}

			expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer));
			if (Advance())
				return 0;
		}
	}

	ExprBlocks::index iexprStart = eblocks.Next();
	m_hr = expr.Generate();
	if (FAILED(m_hr))
		return 0;
	return iexprStart;
}

// if fParenthesized is true
//    pre:  at lparen
//    post: beyond rparen
// if fParenthesized is false
//    pre:  none (at location where expression for first parameter is expected)
//    post: at linebreak
ExprBlocks::index Parser::ParseParameters(Routines::index irtnContext, Lookup &lkuLocals, bool fParenthesized)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	if (fParenthesized)
	{
		assert(m_lexer == TOKEN_lparen);
		if (Advance())
			return 0;
	}

	// Temporarily place expression blocks in separate slots.
	// After completing the parameters then we'll append them to m_script.exprs.
	// This is necessary because we could end up recursively parsing nested calls inside an expression and
	// the parent parameters can't have their blocks interleaved with subexpression calls.
	ExprBlocks exprsTemp;

	Token tStop = fParenthesized ? TOKEN_rparen : TOKEN_linebreak;
	ParseErr perrExpectedFinish = fParenthesized ? 	PARSEERR_InvalidExprRparen : PARSEERR_InvalidExprLineBreak;

	bool fFirstParam = true;
	while (m_lexer != tStop)
	{
		if (!fFirstParam)
		{
			if (Expect(TOKEN_comma, perrExpectedFinish) || !m_lexer)
				return 0;
		}

		if (m_lexer == TOKEN_comma)
		{
			// This parameter is omitted.  Save it as an empty expression.
			// Example:
			//		MySong.Play , , , OldPlayingSong
			// There the first three parameters are omitted.
			m_hr = exprsTemp.Add(ExprBlock(ExprBlock::cons_omitted()));
			if (FAILED(m_hr))
				return 0;
			m_hr = exprsTemp.Add(ExprBlock(ExprBlock::cons_end()));
			if (FAILED(m_hr))
				return 0;
		}
		else
		{
			// The last parameter is set to true to detect a special error when we're calling a sub (!fParenthesized) and when this is
			// the first parameter to that sub (fFirstParam).  This will detect a comma and give a better error message in cases like
			// the following:
			//    Segment1.Play(IsSecondary, AP)
			// Here the user has accidentally called a sub using parameters when they shouldn't.
			ExprBlocks::index iexpr = ParseExpression(irtnContext, lkuLocals, &exprsTemp, fParenthesized, !fParenthesized && fFirstParam);
			if (FAILED(m_hr))
				return 0;
		}

		fFirstParam = false;
	}

	if (fParenthesized)
	{
		assert(m_lexer == TOKEN_rparen);
		if (Advance())
			return 0;
	}
	else
	{
		assert(m_lexer == TOKEN_linebreak);
	}

	// terminate the parameters
	m_hr = exprsTemp.Add(ExprBlock(ExprBlock::cons_end()));
	if (FAILED(m_hr))
		return 0;

	// copy from the temporary blocks into the script
	ExprBlocks::index iexprFirstInScript = m_script.exprs.Next();
	ExprBlocks::index iexprLastInTemp = exprsTemp.Next();
	for (ExprBlocks::index iexpr = 0; iexpr < iexprLastInTemp; ++iexpr)
	{
		m_hr = m_script.exprs.Add(exprsTemp[iexpr]);
		if (FAILED(m_hr))
			return 0;
	}
	return iexprFirstInScript;
}

void Parser::ParseNameReference(Routines::index irtnContext, Lookup &lkuLocals, NameReference &nref)
{
	nref.fSingleItem = m_lexer == TOKEN_identifier;
	nref.ivarrefMultiple = 0;

	if (nref.fSingleItem)
	{
		nref.strSingle = m_lexer.identifier_name();
		if (!nref.strSingle)
		{
			m_hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		nref.ivarrefMultiple = ParseDottedVariableReference(irtnContext, lkuLocals);
	}
}

VariableReferences::index Parser::VariableReferenceFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref)
{
	VariableReferences::index ivarref =
				nref.fSingleItem
					? VariableReferenceInternal(irtnContext, lkuLocals, nref.strSingle)
					: nref.ivarrefMultiple;
	return ivarref;
}

Calls::index Parser::CallFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref, bool fParametersParenthesized)
{
	Call c;
	if (nref.fSingleItem)
	{
		// resolve the name in our temporary parsing name table
		Names_Parse::index iSlotName = m_names.Next();
		Strings::index iStrName = 0;
		m_hr = m_plkuNames->FindOrAdd(nref.strSingle, iSlotName, iStrName);
		if (FAILED(m_hr))
			return 0;
		if (m_hr == S_FALSE)
		{
			m_hr = m_names.Add(Name_Parse(iStrName));
			if (FAILED(m_hr))
				return 0;
		}

		c.k = Call::_global;
		c.istrname = iStrName;
	}
	else
	{
		c.k = Call::_dereferenced;
		c.ivarref = nref.ivarrefMultiple;
	}

	c.iexprParams = ParseParameters(irtnContext, lkuLocals, fParametersParenthesized);
	if (FAILED(m_hr))
		return 0;

	// add the call
	Calls::index icall = m_script.calls.Next();
	m_hr = m_script.calls.Add(c);
	if (FAILED(m_hr))
		return 0;

	return icall;
}

VariableReferences::index Parser::VariableReferenceInternal(Routines::index irtnContext, Lookup &lkuLocals, const char *pszName)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	assert(pszName || m_lexer == TOKEN_identifierdot);

	ReferenceNames::index irname = m_script.rnames.Next();

	// resolve the first item, which is a variable in the script

	bool fLocal = false;
	Variables::index ivarBase;
	Strings::index iStrBase;
	const char *pszBase = pszName ? pszName : m_lexer.identifier_name();

	// check if there's already a routine with this name
	Variables::index iRtn;
	Strings::index iStrRtn;
	if (m_plkuRoutines->Find(pszBase, iRtn, iStrRtn))
	{
		Error(PARSEERR_ExpectedVariableButRoutineFound);
		return 0;
	}

	// try the globals
	if (!m_plkuGlobals->Find(pszBase, ivarBase, iStrBase))
	{
		// try the locals
		if (lkuLocals.Find(pszBase, ivarBase, iStrBase))
		{
			fLocal = true;
		}
		else
		{
			// try the global dispatch
			DISPID dispid = GetDispID(m_pGlobalDispatch, pszBase);
			if (dispid != DISPID_UNKNOWN)
			{
				// add it as a global
				//  Possible performance optimization. Oops. An unintended consequence is that the script
				//    will reserve a variant slot for this as a global variable at runtime.  Could do something
				//    so save this memory if that's a problem.
				ivarBase = m_script.globals.Next();
				m_hr = m_plkuGlobals->FindOrAdd(pszBase, ivarBase, iStrBase);
				if (FAILED(m_hr))
					return 0;
				assert(m_hr == S_FALSE); // we already tried Find, above so must be added
				Variable variable(iStrBase, dispid);
				m_hr = m_script.globals.Add(variable);
				if (FAILED(m_hr))
					return 0;
			}
			else
			{
				// add to the locals
				fLocal = true;
				ivarBase = m_script.routines[irtnContext].ivarNextLocal;
				m_hr = lkuLocals.FindOrAdd(pszBase, ivarBase, iStrBase);
				if (FAILED(m_hr))
					return 0;
				assert(m_hr == S_FALSE); // we already tried Find, above so must be added
				assert(ivarBase == m_script.routines[irtnContext].ivarNextLocal);
				++m_script.routines[irtnContext].ivarNextLocal;
			}
		}
	}

	// save the name
	m_hr = m_script.rnames.Add(ReferenceName(iStrBase));
	if (FAILED(m_hr))
		return 0;

	if (!pszName)
	{
		// remaining items are scoped outside the script, so just record their names

		do
		{
			// next is identifier or identifierdot
			if (Advance())
				return 0;
			if (m_lexer != TOKEN_identifier && m_lexer != TOKEN_identifierdot)
			{
				Error(PARSEERR_ExpectedIdentifier);
				return 0;
			}

			// resolve the name in our temporary parsing name table
			Names_Parse::index iSlotName = m_names.Next();
			Strings::index iStrName = 0;
			m_hr = m_plkuNames->FindOrAdd(m_lexer.identifier_name(), iSlotName, iStrName);
			if (FAILED(m_hr))
				return 0;
			if (m_hr == S_FALSE)
			{
				m_hr = m_names.Add(Name_Parse(iStrName));
				if (FAILED(m_hr))
					return 0;
			}

			// save the name
			m_hr = m_script.rnames.Add(ReferenceName(iStrName));
			if (FAILED(m_hr))
				return 0;
		}
		while (m_lexer != TOKEN_identifier);
	}

	// terminates the rnames
	m_hr = m_script.rnames.Add(ReferenceName(-1));
	if (FAILED(m_hr))
		return 0;

	//
	// make and return the reference
	//

	VariableReferences::index ivarref = m_script.varrefs.Next();
	m_hr = m_script.varrefs.Add(VariableReference(fLocal ? VariableReference::_local : VariableReference::_global, irname, ivarBase));
	if (FAILED(m_hr))
		return 0;

	return ivarref;
}

void
Parser::Error(ParseErr iErr)
{
	static const char *s_rgpszErrorText[] =
		{
		"Unexpected error!", // shouldn't ever get this error
		"Expected Sub or Dim statement",
		"Expected identifier",
		"Expected line break",
		"Expected End Sub",
		"Expected Sub",
		"Expected statement",
		"Expected '('",
		"Expected '='",
		"All Dim statements must occur before all Sub statements",
		"Invalid expression or missing line break",
		"Invalid expression or missing Then",
		"Invalid expression or missing ')'",
		"Strings may not appear inside numerical expressions",
		"Invalid expression -- expected a number or variable",
		"A variable with this name already exists",
		"Another routine with this name already exists",
		"Invalid expression -- expected ')'",
		"Invalid expression -- encountered ')' without a preceding '('",
		"Expected Then",
		"Expected End If",
		"Expected If",
		"Expected line break or ElseIf should be a single word without space before If",
		"The values True, False, and Nothing are read-only and cannot be set",
		"Cannot use parentheses when calling a Sub",
		"Sub name used where variable was expected"
		};

	assert(ARRAY_SIZE(s_rgpszErrorText) == PARSEERR_Max);

	if (FAILED(m_hr))
	{
		// Something forgot to check m_hr. We were already in an error state previously so leave that error as is and assert.
		assert(false);
		return;
	}

	if (iErr < 0 || iErr > PARSEERR_Max)
	{
		assert(false);
		iErr = PARSEERR_LexerError;
	}

	m_hr = DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR;

	// The error number should be passed as PARSEERR_LexerError if and only if the lexer is in an error state.
	// In this case we'll get our description from the lexer itelf.  Otherwise we look it up in the table.
	assert((iErr == PARSEERR_LexerError) == (m_lexer == TOKEN_eof && m_lexer.error_num()));
	const char *pszErr = (m_lexer == TOKEN_eof && m_lexer.error_num()) ? m_lexer.error_descr() : s_rgpszErrorText[iErr];

	CActiveScriptError *perr = new CActiveScriptError(m_hr, m_lexer, pszErr);
	if (perr)
	{
		m_pActiveScriptSite->OnScriptError(perr);
		perr->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\englookup.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of Strings and Hash.
//

#include "stdinc.h"
#include "englookup.h"
#include "englex.h"

//////////////////////////////////////////////////////////////////////
// Strings

// Note: Actually this is half the initial size since the first time will realloc and double.
const Strings::index Strings::ms_iInitialSize = 256; //  Tune this.  16 chars * 32 items / 2 -> 256.

Strings::Strings() : m_pszBuf(NULL), m_iCur(0), m_iSize(ms_iInitialSize)
{
    m_iBase = 0;
}

Strings::~Strings(){
    char* p = m_pszBuf;
    while(p){
        char* p2 = *(char**) p;
        delete [] p;
        p = p2;
    }
}

union PointerIndex
{
    Strings::index i;
    char* p;
};

HRESULT
Strings::Add(const char *psz, index &i)
{
	assert(ms_iInitialSize * 2 >= g_iMaxBuffer); // the initial size (doubled) must be large enough to hold the biggest possible identifier
	int cch = strlen(psz) + 1; // including the null
	if (!m_pszBuf || m_iCur + cch > m_iSize)
	{
		// realloc
		m_iSize *= 2;
        DWORD newAlloc = m_iSize - m_iBase;
		char *pszBuf = new char[newAlloc + sizeof(char*)];
		if (!pszBuf)
			return E_OUTOFMEMORY;
        m_iBase = m_iCur;

		// thread new allocation
        *(char**) pszBuf = m_pszBuf;
		m_pszBuf = pszBuf;
	}

	// append the string
    char* pDest = m_pszBuf + m_iCur - m_iBase + sizeof(char*);
	strcpy(pDest, psz);
    PointerIndex Convert;
    Convert.i = 0;
    Convert.p = pDest;
	i = Convert.i; // Yep, i is really a pointer.
	m_iCur += cch;

	return S_OK;
}

const char *
Strings::operator[](index i)
{
	if (!m_pszBuf || ! i)
	{
		assert(false);
		return NULL;
	}

    PointerIndex Convert;
    Convert.i = i;
	return Convert.p; // Yep, i is really a pointer.
}

//////////////////////////////////////////////////////////////////////
// Lookup

HRESULT Lookup::FindOrAddInternal(bool fAdd, const char *psz, slotindex &iSlot, Strings::index &iString)
{
	StrKey k;
	k.psz = psz;

	stringhash::entry &e = m_h.Find(k);
	if (e.fFound())
	{
		assert(!fAdd || iSlot > e.v.iSlot);
		iSlot = e.v.iSlot;
		iString = e.v.iString;
		return S_OK;
	}

	if (!fAdd)
		return S_FALSE;

	indices v;
	v.iSlot = iSlot;
	HRESULT hr = m_strings.Add(psz, iString);
	if (FAILED(hr))
		return hr;
	v.iString = iString;
	k.psz = m_strings[v.iString]; // need to save key with the string from the permanent store

	hr = m_h.Add(e, k, v);
	if (FAILED(hr))
		return hr;

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\engparse.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Parser.
//

#pragma once

#include "englex.h"
#include "englookup.h"
#include "activescript.h"
#include "engcontrol.h"

// Parser for AudioVBScript.  Reads tokens from Lexer and produces program structures ready for execution.

//////////////////////////////////////////////////////////////////////
// helper structures

// saves the identifier of a dereference like x.y where y would be the name.  used to map char * into single instances in strings during parsing.
class Name_Parse
{
public:
	Name_Parse(Strings::index _istrIdentifier = 0) : istrIdentifier(_istrIdentifier) {}

	Strings::index istrIdentifier;
};
typedef Slots<Name_Parse> Names_Parse;

// Holds information about an identifier (eg "x") or identifiers (eg "x.y") until the context it will be
//    used in (variable reference or function call) becomes known.
// Returned by ParseNameReference.  Used later with VariableReferenceFromNameReference or CallFromNameReference.
struct NameReference
{
	NameReference() : fSingleItem(true), ivarrefMultiple(0) {}

	bool fSingleItem;
	SmartRef::AString strSingle; // used if fSingleItem is true: this saves the name until we know whether it's the name or a variable or a function
	VariableReferences::index ivarrefMultiple; // used if fSingleItem is false: it must reference a variable
};

//////////////////////////////////////////////////////////////////////
// error codes

enum ParseErr
{
	PARSEERR_LexerError = 0,
	PARSEERR_ExpectedSubOrDim,
	PARSEERR_ExpectedIdentifier,
	PARSEERR_ExpectedLineBreak,
	PARSEERR_ExpectedEndSub,
	PARSEERR_ExpectedSub,
	PARSEERR_ExpectedStatement,
	PARSEERR_ExpectedLparen,
	PARSEERR_ExpectedEq,
	PARSEERR_DimAfterSub,
	PARSEERR_InvalidExprLineBreak,
	PARSEERR_InvalidExprThen,
	PARSEERR_InvalidExprRparen,
	PARSEERR_StringInExprBlock,
	PARSEERR_ExpectedExprValue,
	PARSEERR_DuplicateVariable,
	PARSEERR_DuplicateRoutine,
	PARSEERR_ExpectedRparen,
	PARSEERR_UnexpectedRparen,
	PARSEERR_ExpectedThen,
	PARSEERR_ExpectedEndIf,
	PARSEERR_ExpectedIf,
	PARSEERR_IntendedElseIf,
	PARSEERR_AssignedToBuiltInConstant,
	PARSEERR_ParensUsedCallingSub,
	PARSEERR_ExpectedVariableButRoutineFound,
	PARSEERR_Max
};

//////////////////////////////////////////////////////////////////////
// Parser class

class Parser
{
public:
	Parser(Lexer &lexer, Script &script, IActiveScriptSite *pActiveScriptSite, IDispatch *pGlobalDispatch);
	~Parser();

	HRESULT hr() { return m_hr; }

private:
	// Parsing functions. Each reads a certain kind of structure. m_hr and m_pexcepinfo are set on failure.

	void ParseScript();
	void ParseSub();
	void ParseDim();
	Statements::index ParseStatements(Routines::index irtnContext, Lookup &lkuLocals);
	void ParseAssignmentOrCall(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, bool fCall);
	VariableReferences::index ParseDottedVariableReference(Routines::index irtnContext, Lookup &lkuLocals);
	Assignments::index ParseAssignment(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, VariableReferences::index ivarrefLHS);
	void ParseIf(Routines::index irtnContext, Lookup &lkuLocals);
	ExprBlocks::index ParseExpression(Routines::index irtnContext, Lookup &lkuLocals, ExprBlocks *peblocks, bool fAllowRparenAtEnd, bool fDetectSpecialErrorForSubCallWithParen);
	ExprBlocks::index ParseParameters(Routines::index irtnContext, Lookup &lkuLocals, bool fParenthesized);
	void ParseNameReference(Routines::index irtnContext, Lookup &lkuLocals, NameReference &nref);

	// Parsing helpers.

	// Advance the lexer one token. If an error token is encountered, the error is reported and true is returned.
	bool Advance() { if (!++m_lexer && m_lexer.error_num()) { Error(PARSEERR_LexerError); return true; } return false; }
	// Advances if the current token is t. If an error token is next, it is reported and true is returned.
	bool Skip(Token t) { if (m_lexer == t) { return Advance(); } return false; }
	// Same as Skip, but if t isn't next then the error iErr is reported and true is returned.
	bool Expect(Token t, ParseErr iErr) { if (m_lexer == t) { return Advance(); } Error(iErr); return true; }
	// Advance. If the next token isn't t then report iErr and return true.
	bool ExpectNext(Token t, ParseErr iErr) { if (Advance()) return true; if (m_lexer == t) return false; Error(iErr); return true; }

	// Add a variable reference using the info from a NameReference.
	VariableReferences::index VariableReferenceFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref);
	// Add a call using the info from a NameReference.  Also parses the parameters.
	Calls::index CallFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref, bool fParametersParenthesized);

	// Shared implementation for VariableReferenceFromNameReference (pszName is set) and ParseDottedVariableReference (pszName is NULL).
	VariableReferences::index VariableReferenceInternal(Routines::index irtnContext, Lookup &lkuLocals, const char *pszName);

	void Error(ParseErr iErr); // call to report a syntax error

	Lexer &m_lexer;
	Script &m_script;

	HRESULT m_hr;
	IActiveScriptSite *m_pActiveScriptSite;
	IDispatch *m_pGlobalDispatch;

	Lookup *m_plkuRoutines;
	Lookup *m_plkuGlobals;
	Lookup *m_plkuVarRefs;

	Lookup *m_plkuNames;
	Names_Parse m_names;
	SmartRef::Stack<ExprBlock> m_stack; // working stack for expression evaluation
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\guids.cpp ===
// Copyright (c) 1999 Microsoft Corporation
#include "initguid.h"
#include "dmusici.h"
#include "dmscriptautguids.h"
#include "dmstrm.h"
#include "..\shared\dmusicp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\globaldisp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implements a script's global dispatch object.
// Calls are delegated to the performance, constants, or contained content held on the parent CDirectMusicScript object.
// AddRef/Release are ignored, because it is completely contained within the lifetime of CDirectMusicScript.
//

#pragma once
#include "dmscript.h"

class CGlobalDispatch
  : public IDispatch
{
public:
	CGlobalDispatch(CDirectMusicScript *pParentScript) : m_pParentScript(pParentScript) { assert(m_pParentScript); }

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)() { return 2; }
	STDMETHOD_(ULONG, Release)() { return 2; }

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

private:
	CDirectMusicScript *m_pParentScript;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\globaldisp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implements a script's global dispatch object.
//

#include "stdinc.h"
#include "globaldisp.h"
#include "autconstants.h"
#include "autperformance.h"

// We need to shift the DISPID's of the performance, constants, and contained
// content so that they can be assembled into one range.  The performance will be first,
// followed by the others, which are shifted.
const DISPID g_dispidShiftConstants = 1000;
const DISPID g_dispidShiftContent = g_dispidShiftConstants + 1000;


//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CGlobalDispatch::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CGlobalDispatch::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDispatch)
	{
		*ppv = static_cast<IDispatch*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDispatch

STDMETHODIMP
CGlobalDispatch::GetTypeInfoCount(UINT *pctinfo)
{
	V_INAME(CGlobalDispatch::GetTypeInfoCount);
	V_PTR_WRITE(pctinfo, UINT);

	*pctinfo = 0;
	return S_OK;
}

STDMETHODIMP
CGlobalDispatch::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo)
{
	*ppTInfo = NULL;
	return E_NOTIMPL;
}

STDMETHODIMP
CGlobalDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	HRESULT hr = S_OK;

	hr = AutConstantsGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	if (hr != DISP_E_UNKNOWNNAME)
	{
		if (SUCCEEDED(hr))
			rgDispId[0] += g_dispidShiftConstants;
		return hr;
	}

	// Try the performance next.  Conceptually we're doing this:
	//    hr = m_pParentScript->m_pDispPerformance->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	// However, because AudioVBScript may try and resolve names during parsing (before a performance is set by Init),
	//    we will won't use a live perfomance object for this.  Instead we'll use the dispatch helper and the
	//    performance's table to return the ID.
	hr = AutDispatchGetIDsOfNames(CAutDirectMusicPerformance::ms_Methods, riid, rgszNames, cNames, lcid, rgDispId);
	if (hr != DISP_E_UNKNOWNNAME)
		return hr;

	hr = m_pParentScript->m_pContainerDispatch->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	if (SUCCEEDED(hr))
		rgDispId[0] += g_dispidShiftContent;

	return hr;
}

STDMETHODIMP
CGlobalDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	// If script functions are being called, it is an error if the script has not been
	// initialized with a performance.
	if (!m_pParentScript->m_pDispPerformance)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before the script can be used.\n");
		return DMUS_E_NOT_INIT;
	}

	if (dispIdMember < g_dispidShiftConstants)
	{
		// Performance method
		return m_pParentScript->m_pDispPerformance->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
	else if (dispIdMember < g_dispidShiftContent)
	{
		// Constants
		return AutConstantsInvoke(dispIdMember - g_dispidShiftConstants, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
	else
	{
		// Contained content item
		return m_pParentScript->m_pContainerDispatch->Invoke(dispIdMember - g_dispidShiftContent, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\oleaut.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper routines that wrap called to functions in oleaut32.  This enables us to
// compile free from any dependency on oleaut32.dll.  In this case, some functionality
// is lost.  For example, only certain types of VARIANT variables are handled correctly
// in the abscence of oleaut32.
//
// Defining DMS_USE_OLEAUT allows oleaut32 to be used.
//

#include "stdinc.h"
#include "oleaut.h"

#ifndef DMS_ALWAYS_USE_OLEAUT

#ifndef DMS_NEVER_USE_OLEAUT
//////////////////////////////////////////////////////////////////////
// Handling LoadLibrary of OleAut32

bool g_fCalledLoadLibrary = false;
HINSTANCE g_hinstOleAut = NULL;

#define OLEAUTAPI_FUNC_PTR STDAPICALLTYPE *
void (OLEAUTAPI_FUNC_PTR g_pfnVariantInit)(VARIANTARG *pvarg) = NULL;
HRESULT (OLEAUTAPI_FUNC_PTR g_pfnVariantClear)(VARIANTARG *pvarg) = NULL;
HRESULT (OLEAUTAPI_FUNC_PTR g_pfnVariantCopy)(VARIANTARG *pvargDest, VARIANTARG *pvargSrc) = NULL;
HRESULT (OLEAUTAPI_FUNC_PTR g_pfnVariantChangeType)(VARIANTARG *pvargDest, VARIANTARG *pvarSrc, USHORT wFlags, VARTYPE vt) = NULL;
BSTR (OLEAUTAPI_FUNC_PTR g_pfnSysAllocString)(const OLECHAR *) = NULL;
void (OLEAUTAPI_FUNC_PTR g_pfnSysFreeString)(BSTR) = NULL;

bool FEnsureOleAutLoaded()
{
	if (!g_fCalledLoadLibrary)
	{
		Trace(4, "Loading oleaut32.\n");

		g_fCalledLoadLibrary = true;
		g_hinstOleAut = LoadLibrary("oleaut32");
		assert(g_hinstOleAut);

		if (g_hinstOleAut)
		{
			*reinterpret_cast<FARPROC*>(&g_pfnVariantInit) = GetProcAddress(g_hinstOleAut, "VariantInit");
			if (!g_pfnVariantInit)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnVariantClear) = GetProcAddress(g_hinstOleAut, "VariantClear");
			if (!g_pfnVariantClear)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnVariantCopy) = GetProcAddress(g_hinstOleAut, "VariantCopy");
			if (!g_pfnVariantCopy)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnVariantChangeType) = GetProcAddress(g_hinstOleAut, "VariantChangeType");
			if (!g_pfnVariantChangeType)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnSysAllocString) = GetProcAddress(g_hinstOleAut, "SysAllocString");
			if (!g_pfnSysAllocString)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnSysFreeString) = GetProcAddress(g_hinstOleAut, "SysFreeString");
			if (!g_pfnSysFreeString)
				goto Fail;
			return true;
		}
	}

	return !!g_hinstOleAut;

Fail:
	Trace(1, "Error: Unable to load oleaut32.dll.\n");
	g_hinstOleAut = NULL;
	return false;
}
#endif

//////////////////////////////////////////////////////////////////////
// VARIANT functions

// private functions

inline bool FIsRefOrArray(VARTYPE vt)
{
	return (vt & VT_BYREF) || (vt & VT_ARRAY);
}

// public functions

void
DMS_VariantInit(bool fUseOleAut, VARIANTARG *pvarg)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
		{
			g_pfnVariantInit(pvarg);
			return;
		}
	}
#else
	assert(!fUseOleAut);
#endif
	{
		V_INAME(DMS_VariantInit);
		assert(!IsBadWritePtr(pvarg, sizeof(VARIANTARG)));

		pvarg->vt = VT_EMPTY;
	}
}

HRESULT
DMS_VariantClear(bool fUseOleAut, VARIANTARG * pvarg)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			return g_pfnVariantClear(pvarg);
		else
			return DMUS_E_SCRIPT_CANTLOAD_OLEAUT32;
	}
#else
	assert(!fUseOleAut);
#endif
	V_INAME(DMS_VariantClear);
	V_PTR_WRITE(pvarg, VARIANTARG);

	if (FIsRefOrArray(pvarg->vt))
	{
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}

	switch (pvarg->vt)
	{
	case VT_UNKNOWN:
		SafeRelease(pvarg->punkVal);
		break;
	case VT_DISPATCH:
		SafeRelease(pvarg->pdispVal);
		break;
	case VT_BSTR:
		DMS_SysFreeString(fUseOleAut, pvarg->bstrVal);
		pvarg->bstrVal = NULL;
		break;
	}

	pvarg->vt = VT_EMPTY;
	return S_OK;
}

HRESULT DMS_VariantCopy(bool fUseOleAut, VARIANTARG * pvargDest, const VARIANTARG * pvargSrc)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			return g_pfnVariantCopy(pvargDest, const_cast<VARIANT*>(pvargSrc));
		else
			return DMUS_E_SCRIPT_CANTLOAD_OLEAUT32;
	}
#else
	assert(!fUseOleAut);
#endif
	V_INAME(DMS_VariantCopy);
	V_PTR_WRITE(pvargDest, VARIANTARG);
	V_PTR_READ(pvargSrc, VARIANTARG);

	if (pvargDest == pvargSrc)
	{
		assert(false);
		return E_INVALIDARG;
	}

	if (FIsRefOrArray(pvargSrc->vt))
	{
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}

	HRESULT hr = DMS_VariantClear(fUseOleAut, pvargDest);
	if (FAILED(hr))
		return hr;

	switch (pvargSrc->vt)
	{
	case VT_UNKNOWN:
		if (pvargSrc->punkVal)
			pvargSrc->punkVal->AddRef();
		break;
	case VT_DISPATCH:
		if (pvargSrc->pdispVal)
			pvargSrc->pdispVal->AddRef();
		break;
	case VT_BSTR:
		pvargDest->vt = VT_BSTR;
		pvargDest->bstrVal = DMS_SysAllocString(fUseOleAut, pvargSrc->bstrVal);
		return S_OK;
	}

	*pvargDest = *pvargSrc;

	return S_OK;
}

HRESULT
DMS_VariantChangeType(
		bool fUseOleAut,
		VARIANTARG * pvargDest,
		VARIANTARG * pvarSrc,
		USHORT wFlags,
		VARTYPE vt)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			return g_pfnVariantChangeType(pvargDest, pvarSrc, wFlags, vt);
		else
			return DMUS_E_SCRIPT_CANTLOAD_OLEAUT32;
	}
#else
	assert(!fUseOleAut);
#endif
	V_INAME(DMS_VariantChangeType);
	V_PTR_WRITE(pvargDest, VARIANTARG);
	V_PTR_READ(pvarSrc, VARIANTARG);

	bool fConvertInPlace = pvarSrc == pvargDest;
	if (vt == pvarSrc->vt)
	{
		// No conversion necessary
		if (fConvertInPlace)
			return S_OK;
		return DMS_VariantCopy(fUseOleAut, pvargDest, pvarSrc);
	}

	if (FIsRefOrArray(vt) || FIsRefOrArray(pvarSrc->vt))
	{
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}

	switch (vt)
	{
	case VT_I4:
		{
			// Get the value
			LONG lVal = 0;
			switch (pvarSrc->vt)
			{
			case VT_I2:
				lVal = pvarSrc->iVal;
				break;
			case VT_EMPTY:
				break;
			case VT_UNKNOWN:
			case VT_DISPATCH:
			case VT_BSTR:
				return DISP_E_TYPEMISMATCH;
			default:
				Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
				return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
			}

			// Write the result
			pvargDest->vt = VT_I4;
			pvargDest->lVal = lVal;
			return S_OK;
		}

	case VT_DISPATCH:
	case VT_UNKNOWN:
		{
			// We can convert between IDispatch and IUnknown.
			bool fConvertToUnknown = vt == VT_UNKNOWN; // true if IUnknown is dest, false if IDispatch is dest

			// We'll assume that both fields (pdispVal/punkVal) are stored in the same slot in the VARIANT union.
			// This will make things simpler because we can just manipulate the same pointer now matter whether we're
			//  converting to or from Dispatch/Unknown. 
			assert(reinterpret_cast<void**>(&pvarSrc->pdispVal) == reinterpret_cast<void**>(&pvarSrc->punkVal));
			assert(reinterpret_cast<void**>(&pvargDest->pdispVal) == reinterpret_cast<void**>(&pvargDest->punkVal));

			IUnknown *punkCur = pvarSrc->punkVal; // Current value we're going to convert.
			void *pval = NULL; // New value result of conversion.

			switch (pvarSrc->vt)
			{
			case VT_DISPATCH:
			case VT_UNKNOWN:
				{
					if (!punkCur)
						return E_INVALIDARG;
					HRESULT hrDispQI = punkCur->QueryInterface(fConvertToUnknown ? IID_IUnknown : IID_IDispatch, &pval);
					if (FAILED(hrDispQI))
						return hrDispQI;
					break;
				}
			case VT_I4:
			case VT_I2:
			case VT_BSTR:
			case VT_EMPTY:
				return DISP_E_TYPEMISMATCH;
			default:
				Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
				return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
			}

			// Write the result
			if (fConvertInPlace)
				punkCur->Release();
			pvargDest->vt = fConvertToUnknown ? VT_UNKNOWN : VT_DISPATCH;
			pvargDest->punkVal = reinterpret_cast<IUnknown*>(pval);

			return S_OK;
		}

	default:
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}
}

//////////////////////////////////////////////////////////////////////
// BSTR functions

const UINT cwchCountPrefix = sizeof(DWORD) / sizeof(WCHAR);

BSTR
DMS_SysAllocString(bool fUseOleAut, const OLECHAR *pwsz)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
		{
			BSTR bstrReturn = g_pfnSysAllocString(pwsz);

			// Use this to trace memory being allocated in case you need to debug a corruption problem.
			TraceI(4, "DMS_SysAllocString: 0x%08x, \"%S\", %S\n", bstrReturn, bstrReturn ? bstrReturn : L"", L"oleaut");

			return bstrReturn;
		}
		else
		{
			return NULL;
		}
	}
#else
	assert(!fUseOleAut);
#endif
	if (!pwsz)
		return NULL;

	BSTR bstr = new WCHAR[wcslen(pwsz) + 1];
	if (!bstr)
		return NULL;
	wcscpy(bstr, pwsz);

	// Use this to trace memory being allocated in case you need to debug a corruption problem.
	TraceI(4, "DMS_SysAllocString: 0x%08x, \"%S\", %S\n", bstr, bstr ? bstr : L"", L"no oleaut");

	return bstr;
}

void
DMS_SysFreeString(bool fUseOleAut, BSTR bstr)
{
	// Use this to trace memory being deallocated in case you need to debug a corruption problem.
	// All DMS_SysAllocString with "no oleaut" should be neatly balanced by an opposing DMS_SysAllocFreeString.
	// There are some unbalanced calls with "oleaut" because we don't see the allocations and frees made by VBScript.
	TraceI(4, "DMS_SysFreeString: 0x%08x, \"%S\", %S\n", bstr, bstr ? bstr : L"", fUseOleAut ? L"oleaut" : L"no oleaut");

#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			g_pfnSysFreeString(bstr);
		return;
	}
#else
	assert(!fUseOleAut);
#endif

	delete[] bstr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\oleaut.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper routines that wrap called to functions in oleaut32.  This enables us to
// compile free from any dependency on oleaut32.dll.  Each function takes a bool as
// its first argument, which is true if the oleaut32 function is to be called.  When
// false, our own implementation of the function is used.  In this case, some
// functionality is lost.  For example, only certain types of VARIANT variables are
// handled correctly in the abscence of oleaut32.
//
// oleaut32 is demand-loaded when the first function is called with a true parameter,
// unless one of the following is defined:
//  DMS_ALWAYS_USE_OLEAUT
//     causes oleaut32 to be used in all cases and statically linked.
//  DMS_NEVER_USE_OLEAUT
//     for use on platforms where oleaut32 isn't available -- always uses the
//     internal functions and asserts if true is ever passed.
//

#pragma once

// If this GUID is passed for riid when calling Invoke, the DirectMusic automation methods will behave according to a special
// calling convention whereby the functions in this file are used (with fUseOleAut as false) instead of those from
// oleaut32.
const GUID g_guidInvokeWithoutOleaut = { 0x1fcc43db, 0xbad8, 0x4a88, { 0xbc, 0x77, 0x4e, 0x1a, 0xe0, 0x2d, 0x9c, 0x79 } };


#ifdef DMS_ALWAYS_USE_OLEAUT

// VARIANTs
inline void DMS_VariantInit(bool fUseOleAut, VARIANTARG *pvarg) { VariantInit(pvarg); }
inline HRESULT DMS_VariantClear(bool fUseOleAut, VARIANTARG *pvarg) { return VariantClear(pvarg); }
inline HRESULT DMS_VariantCopy(bool fUseOleAut, VARIANTARG *pvargDest, const VARIANTARG *pvargSrc) { return VariantCopy(pvargDest, const_cast<VARIANT*>(pvargSrc)); }
inline HRESULT DMS_VariantChangeType(bool fUseOleAut, VARIANTARG *pvargDest, VARIANTARG *pvarSrc, USHORT wFlags, VARTYPE vt) { return VariantChangeType(pvargDest, pvarSrc, wFlags, vt); }

// BSTRs
inline BSTR DMS_SysAllocString(bool fUseOleAut, const OLECHAR *pwsz) { return SysAllocString(pwsz); }
inline void DMS_SysFreeString(bool fUseOleAut, BSTR bstr) { SysFreeString(bstr); }

#else

// VARIANTs
//  Without fUseOleAut, Only handles types VT_I4, VT_I2, VT_UNKNOWN, VT_DISPATCH and
//  doesn't call dispatch pointers for their value properties.
void DMS_VariantInit(bool fUseOleAut, VARIANTARG *pvarg);
HRESULT DMS_VariantClear(bool fUseOleAut, VARIANTARG * pvarg);
HRESULT DMS_VariantCopy(bool fUseOleAut, VARIANTARG * pvargDest, const VARIANTARG * pvargSrc);
HRESULT DMS_VariantChangeType(bool fUseOleAut, VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt);

// BSTRs
//  Without fUseOleAut, doesn't include size prefix -- plain C WCHAR strings.
BSTR DMS_SysAllocString(bool fUseOleAut, const OLECHAR *pwsz);
void DMS_SysFreeString(bool fUseOleAut, BSTR bstr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\oledll.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include <iostream.h>

#include "oledll.h"

static const char g_szCLSID[]           = "CLSID";
static const char g_szCLSIDSlash[]      = "CLSID\\";
static const char g_szInProc32[]        = "InProcServer32";
static const char g_szProgIDKey[]       = "ProgID";
static const char g_szVerIndProgIDKey[] = "VersionIndependentProgID";
static const char g_szCurVer[]          = "CurVer"; 
static const char g_szThreadingModel[]	= "ThreadingModel";
static const char g_szBoth[]		= "Both";

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCSTR pstrKey, LPCSTR pstrSubkey, LPCSTR pstrValueName, LPCSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const char *szFriendlyName,
               const char *szVerIndProgID,
               const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    char szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const char *szFriendlyName,
                 const char *szVerIndProgID,
                 const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const char *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);
	strcat(szClsKey, "\\");
    if (szKey)
    {
	    strcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           char *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(char *szStr,
		   CLSID &clsid,
		   int cbStr)
{
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
}
   

static LONG
RegSetDefValue(LPCSTR pstrKey,
               LPCSTR pstrSubkey,
			   LPCSTR pstrValueName,
               LPCSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    char sz[1024];
    LPCSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        strcpy(sz, pstrKey);
        strcat(sz, "\\");
        strcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+strlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

    char szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\packexception.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Hack: There's no room in the EXCEPINFO for a filename and line number.  This is a problem when scripts
// call each other because the filename/line need to percolate with the error so that the eventual
// error message displays the filename/line of the script where the error orgiginated.
//    We'll just pack the error in with the description and then unpack it when the IDirectMusicScript
// interface returns its DMUS_SCRIPT_ERRORINFO, which does have a filename.
//

#pragma once

// Saves filname and line number into the description of the exception.  Any of the parameters may be null.
void PackExceptionFileAndLine(bool fUseOleAut, EXCEPINFO *pExcepInfo, const WCHAR *pwszFilename, const ULONG *pulLine);

// Retrieves filname and line number using a description from the exception.
// The ulLineNumber, wszSourceFile, and wszDescription fields of pErrorInfo are set if they are present in the description.
// Neither parameter may be null.
void UnpackExceptionFileAndLine(BSTR bstrDescription, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\packexception.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of PackExceptionFileAndLine and UnpackExceptionFileAndLine.
//

#include "stdinc.h"
#include "packexception.h"
#include "oleaut.h"

const WCHAR g_wszDescriptionFileSeparator[] = L""; // magic character for separating the filename, line, and description
const WCHAR g_wchDescriptionFileSeparator = g_wszDescriptionFileSeparator[0];

void SeparateDescriptionFileAndLine(BSTR bstrDescription, const WCHAR **ppwszFilename, const WCHAR **ppwszLine, const WCHAR **ppwszDescription)
{
	assert(bstrDescription && ppwszFilename && ppwszLine && ppwszDescription);

	// if there aren't any packed fields, the whole thing is the description
	*ppwszDescription = bstrDescription;

	WCHAR *pwszLine = wcsstr(bstrDescription, g_wszDescriptionFileSeparator);
	if (!pwszLine)
		return;

	WCHAR *pwszDescription = wcsstr(pwszLine + 1, g_wszDescriptionFileSeparator);
	if (!pwszDescription)
		return;

	// String looks like this:
	//                             MyScript.spt23Description of the error
	// pExcepInfo->bstrDescription-^  pwszLine-^  ^-pwszDescription

	*ppwszFilename = bstrDescription;
	assert(*pwszLine == g_wchDescriptionFileSeparator);
	*ppwszLine = pwszLine + 1;
	assert(*pwszDescription == g_wchDescriptionFileSeparator);
	*ppwszDescription = pwszDescription + 1;
}

bool wcsIsBlankTillSeparator(const WCHAR *pwsz)
{
	return !pwsz[0] || pwsz[0] == g_wchDescriptionFileSeparator;
}

void wcscpyTillSeparator(WCHAR *pwszDestination, const WCHAR *pwszSource)
{
	assert(pwszDestination && pwszSource);
	while (!wcsIsBlankTillSeparator(pwszSource))
	{
		*pwszDestination++ = *pwszSource++;
	}
	*pwszDestination = L'\0';
}

void wcscatTillSeparator(WCHAR *pwszDestination, const WCHAR *pwszSource)
{
	assert(pwszDestination && pwszSource);
	while (*pwszDestination != L'\0')
		++pwszDestination;

	wcscpyTillSeparator(pwszDestination, pwszSource);
}

void PackExceptionFileAndLine(bool fUseOleAut, EXCEPINFO *pExcepInfo, const WCHAR *pwszFilename, const ULONG *pulLine)
{
	if (!pExcepInfo || !pExcepInfo->bstrDescription)
		return;

	const WCHAR *pwszDescrFilename = L"";
	const WCHAR *pwszDescrLine = L"";
	const WCHAR *pwszDescrDescription = L"";

	SeparateDescriptionFileAndLine(pExcepInfo->bstrDescription, &pwszDescrFilename, &pwszDescrLine, &pwszDescrDescription);

	if (wcsIsBlankTillSeparator(pwszDescrFilename) && pwszFilename)
	{
		// Filename is blank.  Use the specified filename.
		pwszDescrFilename = pwszFilename;
	}

    // MSDN documentation for _ultow says max is 33 characters, but PREFIX complains if the length
    // is less than 40.
	WCHAR wszLineBuffer[40] = L""; 
	if (wcsIsBlankTillSeparator(pwszDescrLine) && pulLine)
	{
		// Line is blank.  Use the specified line.
		_ultow(*pulLine, wszLineBuffer, 10);
		pwszDescrLine = wszLineBuffer;
	}

	WCHAR *pwszNewDescription = new WCHAR[wcslen(pwszDescrFilename) + wcslen(pwszDescrLine) + wcslen(pwszDescrDescription) + (wcslen(g_wszDescriptionFileSeparator) * 2 + 1)];
	if (pwszNewDescription)
	{
		wcscpyTillSeparator(pwszNewDescription, pwszDescrFilename);
		wcscat(pwszNewDescription, g_wszDescriptionFileSeparator);
		wcscatTillSeparator(pwszNewDescription, pwszDescrLine);
		wcscat(pwszNewDescription, g_wszDescriptionFileSeparator);
		wcscat(pwszNewDescription, pwszDescrDescription);
		DMS_SysFreeString(fUseOleAut, pExcepInfo->bstrDescription);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fUseOleAut, pwszNewDescription);
		delete[] pwszNewDescription;
	}
}

void UnpackExceptionFileAndLine(BSTR bstrDescription, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	assert(pErrorInfo && bstrDescription);

    if (pErrorInfo && bstrDescription)
    {

	    const WCHAR *pwszDescrFilename = L"";
	    const WCHAR *pwszDescrLine = L"";
	    const WCHAR *pwszDescrDescription = L"";

	    SeparateDescriptionFileAndLine(bstrDescription, &pwszDescrFilename, &pwszDescrLine, &pwszDescrDescription);

	    // String looks like this:
	    //                             CoolScriptFile.spt23Description of the error
	    //           pwszDescrFilename-^    pwszDescrLine-^  ^-pwszDescrDescription
	    // Except that if these weren't found then they point to a separate empty string.

	    if (!wcsIsBlankTillSeparator(pwszDescrFilename))
	    {
		    // Filename is present.  Copy to pErrorInfo.
		    assert(*(pwszDescrLine - 1) == g_wchDescriptionFileSeparator);
		    wcsTruncatedCopy(pErrorInfo->wszSourceFile,
							    pwszDescrFilename,
							    std::_MIN<UINT>(DMUS_MAX_FILENAME, pwszDescrLine - pwszDescrFilename));
	    }

	    if (!wcsIsBlankTillSeparator(pwszDescrLine))
	    {
		    // Line is present.  Copy to pErrorInfo.
		    WCHAR *pwszLineSeparator = const_cast<WCHAR *>(pwszDescrDescription - 1);
		    assert(*pwszLineSeparator == g_wchDescriptionFileSeparator);
		    *pwszLineSeparator = L'\0'; // terminate the line for wcstoul
		    pErrorInfo->ulLineNumber = wcstoul(pwszDescrLine, NULL, 10);
		    *pwszLineSeparator = g_wchDescriptionFileSeparator; // restore the separator
	    }

	    // Always copy the description
	    wcsTruncatedCopy(pErrorInfo->wszDescription, pwszDescrDescription, DMUS_MAX_FILENAME);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\smartref.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

#include "smartref.h"
using namespace SmartRef;
#include <xutility>
#include "miscutil.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// AString

AString::AString(const char *psz, UINT cch)
{
    assert(psz);
    m_psz = new char[cch + 1];
    if (m_psz)
    {
        strncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }
}

AString &
AString::operator =(const char *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        m_psz = new char[strlen(psz) + 1];
        if (m_psz)
            strcpy(m_psz, psz);
    }

    return *this;
}

AString &AString::Assign(const char *psz, UINT cch)
{
    assert(psz);
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    m_psz = new char[cch + 1];
    if (m_psz)
    {
        strncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }

    return *this;
}

AString &
AString::AssignFromW(const WCHAR *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        int cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);
        if (cch)
        {
            m_psz = new char[cch];
            if (m_psz)
            {
                cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, m_psz, cch, NULL, NULL);
                if (!cch)
                {
                    assert(false);
                    delete[] m_psz;
                    m_psz = NULL;
                }
            }
        }
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////
// WString

WString &
WString::operator =(const WCHAR *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        m_psz = new WCHAR[wcslen(psz) + 1];
        if (m_psz)
            wcscpy(m_psz, psz);
    }

    return *this;
}

WString &WString::Assign(const WCHAR *psz, UINT cch)
{
    assert(psz);
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    m_psz = new WCHAR[cch + 1];
    if (m_psz)
    {
        wcsncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }

    return *this;
}

WString &
WString::AssignFromA(const char *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        int cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
        if (cch)
        {
            m_psz = new WCHAR[cch];
            if (m_psz)
            {
                cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, m_psz, cch);
                if (!cch)
                {
                    assert(false);
                    delete[] m_psz;
                    m_psz = NULL;
                }
            }
        }
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////
// RiffIter

RiffIter::RiffIter(IStream *pStream)
  : m_hr(S_OK),
    m_pIStream(pStream),
    m_pIDMStream(NULL),
    m_fParent(false)
{
    m_pIStream->AddRef();

    ZeroMemory(&m_ckParent, sizeof(m_ckParent));
    ZeroMemory(&m_ckChild, sizeof(m_ckChild));

    m_hr = ::AllocDirectMusicStream(m_pIStream, &m_pIDMStream);
    if (FAILED(m_hr))
        return;

    m_hr = m_pIDMStream->Descend(&m_ckChild, NULL, 0);
}

RiffIter::~RiffIter()
{
    if (!m_fParent)
    {
        SafeRelease(m_pIStream);
        SafeRelease(m_pIDMStream);
    }
}

RiffIter
&RiffIter::operator ++()
{
    if (validate())
        return *this;

    m_hr = m_pIDMStream->Ascend(&m_ckChild, 0);
    if (FAILED(m_hr))
        return *this;

    m_ckChild.ckid = 0;
    m_ckChild.fccType = 0;
    m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);
    return *this;
}

RiffIter
&RiffIter::Find(RiffType t, FOURCC idFind)
{
    if (validate())
        return *this;

    while (*this && (type() != t || id() != idFind))
        ++*this;

    return *this;
}

HRESULT
RiffIter::ReadChunk(
        void *pv,
        UINT cb)
{
    if (type() != Chunk)
    {
        assert(false);
        return DMUS_E_CANNOTREAD;
    }

    ZeroMemory(pv, cb);
    DWORD cbRead = 0;
    DWORD cbSize = std::_cpp_min<DWORD>(cb, m_ckChild.cksize);
    HRESULT hr = m_pIStream->Read(pv, cbSize, &cbRead);
    if (FAILED(hr) || cbRead != cbSize)
    {
        Trace(1, "Error: Unable to read file.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    return hr;
}

HRESULT
RiffIter::ReadArrayChunk(
    DWORD cbSize,
    void **ppv,
    int *pcRecords)
{
    // zero the out params
    *ppv = NULL;
    *pcRecords = 0;

    // get the size of the chunk and its records

    UINT cbChunk = size();
    if (cbChunk < sizeof(DWORD))
    {
        assert(false);
        return E_FAIL;
    }

    DWORD cbChunkRecord = 0;
    HRESULT hr = RiffIterReadChunk(*this, &cbChunkRecord);
    if (FAILED(hr))
        return hr;
    cbChunk -= sizeof(DWORD);

    if (cbChunk % cbChunkRecord != 0)
    {
        // array is not divisible by size of records!
        assert(false);
        return E_FAIL;
    }

    UINT cRecords = cbChunk / cbChunkRecord;

    // Get the whole rest of the chunk
    PtrArray<char> sprgChunk = new char[cbChunk];
    if (!sprgChunk)
        return E_OUTOFMEMORY;
    hr = ReadChunk(sprgChunk, cbChunk);
    if (FAILED(hr))
        return hr;

    // Return the chunk and its info.

    if (cbChunkRecord == cbSize)
    {
        // Great!  Return the chunk as is.
        *ppv = sprgChunk.disown();
    }
    else
    {
        // make an array of the requested size
        char *pArray = new char[cbSize * cRecords];
        if (!pArray)
            return E_OUTOFMEMORY;
        ZeroMemory(pArray, cbSize * cRecords);

        // copy each record
        char *pRec = sprgChunk; // iterate reading each record of the chunk
        char *pEnd = pRec + cbChunkRecord * cRecords; // stop before this (nonexistant) record
        char *pOut = pArray; // iterate writing into the array
        while (pRec < pEnd)
        {
            memcpy(pOut, pRec, std::_cpp_min<DWORD>(cbChunkRecord, cbSize));
            pRec += cbChunkRecord;
            pOut += cbSize;
        }
        *ppv = pArray;
    }

    *pcRecords = cRecords;
    return hr;
}

HRESULT RiffIter::FindAndGetEmbeddedObject(
        RiffType t,
        FOURCC idFind,
        HRESULT hrOnNotFound,
        IDirectMusicLoader *pLoader,
        REFCLSID rclsid,
        REFIID riid,
        LPVOID *ppv)
{
    if (validate() || !pLoader || !ppv)
    {
        assert(false);
        return E_FAIL;
    }

    *ppv = NULL;
    MMCKINFO ckLast;
    ZeroMemory(&ckLast, sizeof(ckLast));

    while (*this && (type() != t || id() != idFind))
    {
        ckLast = m_ckChild;
        ++*this;
    }

    if (!*this)
        return hrOnNotFound;

    // Ascend in such a way that the stream can be used to find this chunk.
    m_hr = m_pIDMStream->Ascend(&ckLast, 0);
    if (FAILED(m_hr))
        return m_hr;

    // Call GetObject using the stream
    DMUS_OBJECTDESC desc;
    ZeroAndSize(&desc);
    desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
    desc.guidClass = rclsid;
    desc.pStream = m_pIStream;
    HRESULT hrLoad = pLoader->GetObject(&desc, riid, ppv);

    // Descend again to leave the stream at the next chunk
    m_ckChild.ckid = 0;
    m_ckChild.fccType = 0;
    m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

    HRESULT hrDescend = this->hr();
    if (FAILED(hrDescend))
    {
        // Give precedence to reporting failure in the stream even though getting the
        // object succeeded before the failure.
        if (*ppv)
        {
            IUnknown *punk = static_cast<IUnknown *>(*ppv);
            if (punk)
                punk->Release();
            *ppv = NULL;
        }
        return hrDescend;
    }
    else
    {
        return hrLoad;
    }
}

HRESULT
RiffIter::ReadReference(DMUS_OBJECTDESC *pDESC)
{
    HRESULT hr = S_OK;

    assert(this->type() == List && this->id() == DMUS_FOURCC_REF_LIST);

    ZeroAndSize(pDESC);

    for (RiffIter ri = this->Descend(); ri; ++ri)
    {
        switch (ri.id())
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = SmartRef::RiffIterReadChunk(ri, &ioDMRef);
                if (SUCCEEDED(hr))
                {
                    pDESC->guidClass = ioDMRef.guidClassID;
                    pDESC->dwValidData |= ioDMRef.dwValidData;
                    pDESC->dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->guidObject);
                if (SUCCEEDED(hr))
                    pDESC->dwValidData |=  DMUS_OBJ_OBJECT;
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->ftDate);
                if (SUCCEEDED(hr))
                    pDESC->dwValidData |=  DMUS_OBJ_DATE;
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszName);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszName[DMUS_MAX_NAME - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_NAME;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszFileName);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszCategory);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = SmartRef::RiffIterReadChunk(ri, &ioDMObjVer);
                if (SUCCEEDED(hr))
                {
                    pDESC->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    pDESC->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    pDESC->dwValidData |= DMUS_OBJ_VERSION;
                }
                else
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    }
    return ri.hr();
}

HRESULT RiffIter::LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop)
{
    assert(pObjInfo);
    pObjInfo->Clear();

    HRESULT hr = S_OK;

    if (!(*this))
        return this->hr();

    for ( ; *this; ++(*this))
    {
        RiffType rtype = type();
        FOURCC fcc = id();
        if (rtype == rtypeStop && fcc == ridStop)
            return S_OK;

        if (rtype == SmartRef::RiffIter::Chunk)
        {
            if (fcc == DMUS_FOURCC_GUID_CHUNK)
                hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->guid);
            else if (fcc == DMUS_FOURCC_VERSION_CHUNK)
                hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->vVersion);
        }
        else if (rtype == SmartRef::RiffIter::List)
        {
            if (fcc == DMUS_FOURCC_UNFO_LIST)
            {
                RiffIter riUnfo = this->Descend();
                if (!riUnfo)
                    return riUnfo.hr();
                if (riUnfo.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_UNAM_CHUNK))
                {
                    hr = riUnfo.ReadTextTrunc(pObjInfo->wszName, DMUS_MAX_NAME);
                    if (FAILED(hr))
                        return hr;
                }
            }
        }

        if (FAILED(hr))
            return hr;
    }
    
    Trace(1, "Error: Unable to read file.\n");
    return E_FAIL;
}

HRESULT RiffIter::ReadText(WCHAR **ppwsz)
{
    DWORD dwSize = this->size();
    if (dwSize % 2 != 0)
    {
        assert(false);
        return E_FAIL;
    }
    *ppwsz = new WCHAR[dwSize / 2];
    if (!*ppwsz)
        return E_OUTOFMEMORY;
    HRESULT hr = this->ReadChunk(*ppwsz, dwSize);
    return hr;
}

HRESULT RiffIter::ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize)
{
    DWORD dwSize = this->size();
    if (dwSize % 2 != 0)
    {
        assert(false);
        return E_FAIL;
    }
    HRESULT hr = this->ReadChunk(pwsz, std::_MIN<DWORD>(dwSize, (cbBufSize - 1) * 2));
    pwsz[cbBufSize - 1] = L'\0';
    return hr;
}

RiffIter::RiffIter(const RiffIter &other, MMCKINFO ckParent)
  : m_hr(S_OK),
    m_pIStream(other.m_pIStream),
    m_pIDMStream(other.m_pIDMStream),
    m_fParent(true),
    m_ckParent(ckParent)
{
    other.validate();
    ZeroMemory(&m_ckChild, sizeof(m_ckChild));

    m_hr = m_pIDMStream->Descend(&m_ckChild, &m_ckParent, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\stdinc.h ===
// Copyright (c) 1999 Microsoft Corporation
#pragma once

#include <xutility>

#include "dmusici.h"
#include "Validate.h"
#include "debug.h"
#include "smartref.h"
#include "miscutil.h"

// undefine min and max from WINDEF.H
// use std::_MIN and std::_MAX instead
#undef min
#undef max

//const g_ScriptCallTraceLevel = -1; // always log
const g_ScriptCallTraceLevel = 4; // only log at level 4 and above
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\sourcetext.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSourceText.
//

#include "stdinc.h"
#include "dll.h"
#include "sourcetext.h"

const GUID CLSID_DirectMusicSourceText = { 0xc70eb77f, 0xefd4, 0x4678, { 0xa2, 0x7b, 0xbf, 0x16, 0x48, 0xf3, 0xd, 0x4 } }; // {C70EB77F-EFD4-4678-A27B-BF1648F30D04}
const GUID IID_IDirectMusicSourceText = { 0xa384ffed, 0xa708, 0x48de, { 0x85, 0x5b, 0x90, 0x63, 0x8b, 0xa5, 0xc0, 0xac } }; // {A384FFED-A708-48de-855B-90638BA5C0AC}

//////////////////////////////////////////////////////////////////////
// Creation

CSourceText::CSourceText()
  : m_cRef(0)
{
	LockModule(true);
}

HRESULT
CSourceText::CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv)
{
	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	CSourceText *pInst = new CSourceText;
	if (pInst == NULL)
		return E_OUTOFMEMORY;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CSourceText::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CSourceText::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicSourceText)
	{
		*ppv = static_cast<IDirectMusicSourceText*>(this);
	}
	else if (iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if (iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
	else if (iid == IID_IPersist)
	{
		*ppv = static_cast<IPersist*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
CSourceText::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CSourceText::Release()
{
	if (!InterlockedDecrement(&m_cRef))
	{
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP
CSourceText::Load(IStream* pStream)
{
	V_INAME(CSourceText::Load);
	V_INTERFACE(pStream);

	// Record the stream's current position
	LARGE_INTEGER li;
	ULARGE_INTEGER ulStart;
	ULARGE_INTEGER ulEnd;
	li.HighPart = 0;
	li.LowPart = 0;

	HRESULT hr = pStream->Seek(li, STREAM_SEEK_CUR, &ulStart);
	if (FAILED(hr))
		return hr;

	assert(ulStart.HighPart == 0); // We don't expect streams that big.
	DWORD dwSavedPos = ulStart.LowPart;

	// Get the stream's end and record the total size
	hr = pStream->Seek(li, STREAM_SEEK_END, &ulEnd);
	if (FAILED(hr))
		return hr;

	assert(ulEnd.HighPart == 0);
	assert(ulEnd.LowPart > dwSavedPos);
	DWORD cch = ulEnd.LowPart - dwSavedPos;

	// Go back to the start and copy the characters
	li.HighPart = 0;
	li.LowPart = dwSavedPos;
	hr = pStream->Seek(li, STREAM_SEEK_SET, &ulStart);
	if (FAILED(hr))
		return hr;
	assert(ulStart.LowPart == dwSavedPos);

	CHAR *paszSource = new CHAR[cch + 1];
	if (!paszSource)
		return E_OUTOFMEMORY;

	DWORD cbRead;
	hr = pStream->Read(paszSource, cch, &cbRead);
	if (FAILED(hr))
	{
		assert(false);
		return hr;
	}

	paszSource[cch] = '\0';

	m_wstrText.AssignFromA(paszSource);
	delete[] paszSource;
	if (!m_wstrText)
		return E_OUTOFMEMORY;

	m_cwchText = wcslen(m_wstrText);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicSourceText

STDMETHODIMP_(void)
CSourceText::GetTextLength(DWORD *pcwchRequiredBufferSize)
{
	*pcwchRequiredBufferSize = m_cwchText + 1;
}

STDMETHODIMP_(void)
CSourceText::GetText(WCHAR *pwszText)
{
	wcscpy(pwszText, m_wstrText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

	sources.

Abstract:

	This file specifies the target component being built and the list of
	sources files needed to build that component.  Also specifies optional
	compiler switches and libraries that are unique for the component being
	built.


Author:

	Jim Geist (JimGe) 29-Aug-97

NOTE:	Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmscript

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=dmscripd
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dll.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_CRTDLL=1
USE_STL=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2 -DxDMS_NEVER_USE_OLEAUT

!if defined(DMUSIC_INTERNAL)
C_DEFINES= $(C_DEFINES) -DDMUSIC_INTERNAL
!endif

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
	$(BASEDIR)\public\sdk\lib\*\kernel32.lib 	\
	$(BASEDIR)\public\sdk\lib\*\advapi32.lib 	\
	$(BASEDIR)\public\sdk\lib\*\uuid.lib 		\
	$(BASEDIR)\public\sdk\lib\*\ole32.lib
!if 0
	$(BASEDIR)\public\sdk\lib\*\winmm.lib		\
	$(BASEDIR)\public\sdk\lib\*\user32.lib
!endif


INCLUDES=$(INCLUDES);   \
	$(DXROOT)\inc;		\
	..\..\shared;		\
	..\..\includes

SOURCES=\
	..\activescript.cpp			\
	..\autaudiopath.cpp			\
	..\autaudiopathconfig.cpp	\
	..\autconstants.cpp			\
	..\authelper.cpp			\
	..\autperformance.cpp		\
	..\autsegment.cpp			\
	..\autsegmentstate.cpp		\
	..\autsong.cpp				\
	..\containerdisp.cpp		\
	..\dll.cpp					\
	..\dll.rc					\
	..\dmstrm.cpp				\
	..\debug.cpp				\
	..\dmscript.cpp				\
	..\engdisp.cpp				\
	..\engerror.cpp				\
	..\engexec.cpp				\
	..\engexpr.cpp				\
	..\enginc.cpp				\
	..\engine.cpp				\
	..\englex.cpp				\
	..\englookup.cpp			\
	..\engparse.cpp				\
	..\globaldisp.cpp			\
	..\guids.cpp				\
	..\oleaut.cpp				\
	..\oledll.cpp				\
	..\packexception.cpp		\
	..\scriptthread.cpp			\
	..\smartref.cpp				\
	..\sourcetext.cpp			\
	..\track.cpp				\
	..\trackhelp.cpp			\
	..\trackshared.cpp			\
	..\unkhelp.cpp				\
	..\workthread.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\scriptthread.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSingleThreadedScriptManager.
// Wraps CActiveScriptManager to accept calls from multiple scripts and behind the
//    scenes farms them out to a single worker thread that actually talks to the script engine.
//
// The virtual base class ScriptManager can be used to talk to either
//    CActiveScriptManager or CSingleThreadedActiveScriptManager.
//

#pragma once

#include "workthread.h"

// forward declaration
class CDirectMusicScript;

class ScriptManager
{
public:
	virtual HRESULT Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT ScriptTrackCallRoutine(
						const WCHAR *pwszRoutineName,
						IDirectMusicSegmentState *pSegSt,
						DWORD dwVirtualTrackID,
						bool fErrorPMsgsEnabled,
						__int64 i64IntendedStartTime,
						DWORD dwIntendedStartTimeFlags) = 0;
	virtual HRESULT SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems) = 0; // fRoutine true to get a routine, false to get a variable. pcItems (if supplied) is set to the total number of items
	virtual HRESULT DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId) = 0;
	virtual HRESULT DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr) = 0;
	virtual void Close() = 0;
	STDMETHOD_(ULONG, Release)() = 0;
};

// VBScript (and likely any other scripting languages besides our custom engine) fails if called from different threads.
// This class wraps such an engine, providing a ScriptManager interface that can be called from multiple threads but marshals
// all the calls to the engine onto a single worker thread.
class CSingleThreadedScriptManager : public ScriptManager
{
public:
	// The worker thread needs to be cleaned up using the static member function before the .dll is unloaded.
	static void TerminateThread() { ms_Thread.Terminate(true); }

	CSingleThreadedScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo);

	HRESULT Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT ScriptTrackCallRoutine(
				const WCHAR *pwszRoutineName,
				IDirectMusicSegmentState *pSegSt,
				DWORD dwVirtualTrackID,
				bool fErrorPMsgsEnabled,
				__int64 i64IntendedStartTime,
				DWORD dwIntendedStartTimeFlags);
	HRESULT SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems);
	HRESULT DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId);
	HRESULT DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr);
	void Close();
	STDMETHOD_(ULONG, Release)();

private:
	friend void F_Create(void *pvParams);

	static CWorkerThread ms_Thread;
	ScriptManager *m_pScriptManager;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\sourcetext.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSourceText.
//
// This is a DirectMusic object whose sole purpose is to load a plain text file and return the text.
// It is used by the CDirectMusicScript object to read its source code from a separate non-riff text file.

#pragma once

//////////////////////////////////////////////////////////////////////
// Interface for getting the text

extern const GUID CLSID_DirectMusicSourceText;
extern const GUID IID_IDirectMusicSourceText;

#undef  INTERFACE
#define INTERFACE IDirectMusicSourceText
DECLARE_INTERFACE_(IDirectMusicSourceText, IUnknown)
{
	STDMETHOD_(void, GetTextLength)(DWORD *pcwchRequiredBufferSize); // size of buffer to allocate (includes a space for the terminator)
	STDMETHOD_(void, GetText)(WCHAR *pwszText); // buffer must be of size from GetTextLength
};

//////////////////////////////////////////////////////////////////////
// The object iteself

//  Does this object need a critical section?  GetObject should serialize access and nobody but the
// script can hold onto it.

class CSourceText
  : public IDirectMusicSourceText,
	public IPersistStream,
	public IDirectMusicObject
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions (only Load is implemented)
	STDMETHOD(GetClassID)(CLSID* pClassID) {return E_NOTIMPL;}
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream);
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject
	// (This interface must exist in order for the object to be loaded, but the methods aren't actually
	//  implemented to provide/save any information.)
	STDMETHOD(GetDescriptor)(LPDMUS_OBJECTDESC pDesc) { pDesc->dwValidData = 0; return S_OK; }
	STDMETHOD(SetDescriptor)(LPDMUS_OBJECTDESC pDesc) { return S_OK; }
	STDMETHOD(ParseDescriptor)(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) { pDesc->dwValidData = 0; return S_OK; }

	// IDirectMusicSourceText
	STDMETHOD_(void, GetTextLength)(DWORD *pcwchRequiredBufferSize); // size of buffer to allocate (includes a space for the terminator)
	STDMETHOD_(void, GetText)(WCHAR *pwszText); // buffer must be of size from GetTextLength

private:
	CSourceText();

	long m_cRef;
	SmartRef::WString m_wstrText;
	DWORD m_cwchText;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\track.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CDirectMusicScriptTrack.
//

#include "stdinc.h"
#include "dll.h"
#include "track.h"
#include "dmusicf.h"
#include "dmusicp.h"

//////////////////////////////////////////////////////////////////////
// Types

CScriptTrackEvent::~CScriptTrackEvent()
{
	if (m_pSegSt) m_pSegSt->Release();
	if (m_pEvent) delete m_pEvent;
}

HRESULT CScriptTrackEvent::Init(
        const EventInfo &item,
		IDirectMusicSegmentState* pSegSt)
{
    HRESULT hr = S_OK;

	m_pEvent = new EventInfo;
	if (!m_pEvent)
	{
		return E_OUTOFMEMORY;
	}

	hr = m_pEvent->Clone(item, 0);
	if (FAILED(hr))
    {
        delete m_pEvent;
        return E_OUTOFMEMORY;
    }

	m_pSegSt = pSegSt;
	m_pSegSt->AddRef();

    return S_OK;
}

void CScriptTrackEvent::Call(DWORD dwVirtualTrackID, bool fErrorPMsgsEnabled)
{

#ifdef DBG
	//  Probably will want better logging.
	DebugTrace(g_ScriptCallTraceLevel, "Script event %S\n", m_pEvent->pwszRoutineName);
#endif

	HRESULT hrCall = m_pEvent->pIDMScriptPrivate->ScriptTrackCallRoutine(
															m_pEvent->pwszRoutineName,
															m_pSegSt,
															dwVirtualTrackID,
															fErrorPMsgsEnabled,
															m_i64IntendedStartTime,
															m_dwIntendedStartTimeFlags);

#ifdef DBG
	if (FAILED(hrCall))
	{
		DebugTrace(g_ScriptCallTraceLevel, "Call failed 0x%08X\n", hrCall);
	}
#endif

}

STDMETHODIMP CScriptTrackEvent::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    if (iid == IID_IUnknown || iid == IID_CScriptTrackEvent)
    {
        *ppv = static_cast<CScriptTrackEvent*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CScriptTrackEvent::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CScriptTrackEvent::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// Creation

// When the script track plays one of its items, sends a PMsg to itself.  When it receives the PMsg, it calls the specified
// routine.  If an invalidation occurs, the PMsg isn't retracted.  (Perhaps because it sends the PMsgs directly to itself
// without calling StampPMsg.)  Then the track is played again (with the FLUSH bit set).  This was causing it to trigger the
// routine a second time.  To fix this, the last parameter to the CSegTriggerTrackBase is false, which instructs it not to call play
// a second time when the FLUSH bit is set.
CDirectMusicScriptTrack::CDirectMusicScriptTrack(HRESULT *pHr)
  : CDirectMusicScriptTrackBase(GetModuleLockCounter(), CLSID_DirectMusicScriptTrack, true, false),
	m_fErrorPMsgsEnabled(false)
{
}

//////////////////////////////////////////////////////////////////////
// Load

HRESULT
CDirectMusicScriptTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
	struct LocalFunction
	{
		// Helper used by the LoadRiff function when we expected to find something
		// but a RiffIter becomes false.  In this case, if it has a success HR
		// indicating there were no more items then we return DMUS_E_INVALID_SCRIPTTRACK
		// because the stream didn't contain the data we expected.  If it has a
		// failure hr, it was unable to read from the stream and we return its HR.
		static HRESULT HrFailOK(const SmartRef::RiffIter &ri)
		{
			HRESULT hr = ri.hr();
			return SUCCEEDED(hr) ? DMUS_E_INVALID_SCRIPTTRACK : hr;
		}
	};

	// find <scrt>
	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SCRIPTTRACK_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load script track: List 'scrt' not found.\n");
		}
#endif
		return LocalFunction::HrFailOK(ri);
	}

	// find <scrl>
	SmartRef::RiffIter riEventsList = ri.Descend();
	if (!riEventsList)
		return riEventsList.hr();
	if (!riEventsList.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load script track: List 'scrl' not found.\n");
		}
#endif
		return LocalFunction::HrFailOK(riEventsList);
	}

	// process each event <scre>
	SmartRef::RiffIter riEvent = riEventsList.Descend();
	if (!riEvent)
		return riEvent.hr();

	for ( ; riEvent; ++riEvent)
	{
		if (riEvent.id() == DMUS_FOURCC_SCRIPTTRACKEVENT_LIST)
		{
			HRESULT hr = this->LoadEvent(riEvent.Descend(), pIDMLoader);
			if (FAILED(hr))
				return hr;
		}
	}
	return riEvent.hr();
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CDirectMusicScriptTrack::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	SmartRef::CritSec CS(&m_CriticalSection);

	HRESULT hr = CDirectMusicScriptTrackBase::InitPlay(pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
	if (FAILED(hr))
		return hr;

	// Init each script in the event list with this performance.
	for (TListItem<EventInfo> *li = m_EventList.GetHead(); li; li = li->GetNext())
	{
		EventInfo &rinfo = li->GetItemValue();
		if (!rinfo.pIDMScript)
		{
			assert(false);
			continue;
		}

		DMUS_SCRIPT_ERRORINFO ErrorInfo;
		if (m_fErrorPMsgsEnabled)
			ZeroAndSize(&ErrorInfo);

		hr = rinfo.pIDMScript->Init(pPerformance, &ErrorInfo);

		if (m_fErrorPMsgsEnabled && hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
			FireScriptTrackErrorPMsg(pPerformance, pSegmentState, dwTrackID, &ErrorInfo);
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP
CDirectMusicScriptTrack::ProcessPMsg(
		IDirectMusicPerformance* pPerf,
		DMUS_PMSG* pPMSG)
{
    if (!pPMSG || !pPMSG->punkUser) return E_POINTER;

	CScriptTrackEvent *pScriptEvent = NULL;
    if (SUCCEEDED(pPMSG->punkUser->QueryInterface(IID_CScriptTrackEvent, (void**)&pScriptEvent)))
    {
        pScriptEvent->Call(pPMSG->dwVirtualTrackID, m_fErrorPMsgsEnabled);
        pScriptEvent->Release();
    }

	return DMUS_S_FREE;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack methods

STDMETHODIMP
CDirectMusicScriptTrack::IsParamSupported(REFGUID rguid)
{
	return rguid == GUID_EnableScriptTrackError ? S_OK : DMUS_E_TYPE_UNSUPPORTED;
}

STDMETHODIMP
CDirectMusicScriptTrack::SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData)
{
	if (rguid == GUID_EnableScriptTrackError)
	{
		m_fErrorPMsgsEnabled = true;
		return S_OK;
	}
	else
	{
		return DMUS_E_SET_UNSUPPORTED;
	}
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CDirectMusicScriptTrack::LoadEvent(
		SmartRef::RiffIter ri,
		IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri)
		return ri.hr();

	// Create an event

	// TListItem<EventInfo> is the item we're going to insert into out event list.
	// SmartRef::Ptr is used instead of a regular pointer because it will automatically
	//    call delete to free the allocated list item if we bail out before the item is
	//    successfully inserted into the event list.
	// See class Ptr in smartref.h for the definition of SmartRef::Ptr.
	SmartRef::Ptr<TListItem<EventInfo> > spItem = new TListItem<EventInfo>;
	if (!spItem)
		return E_OUTOFMEMORY;
	EventInfo &rinfo = spItem->GetItemValue();

	bool fFoundEventHeader = false;

	for ( ; ri; ++ri)
	{
		switch(ri.id())
		{
			case DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK:
				// Read an event chunk
				DMUS_IO_SCRIPTTRACK_EVENTHEADER ioItem;
				hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
				if (FAILED(hr))
					return hr;

				fFoundEventHeader = true;
				rinfo.dwFlags = ioItem.dwFlags;
				rinfo.lTriggerTime = ioItem.lTimeLogical;
				rinfo.lTimePhysical = ioItem.lTimePhysical;
				break;

			case DMUS_FOURCC_REF_LIST:
				hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicScript, reinterpret_cast<void**>(&rinfo.pIDMScript));
				if (FAILED(hr))
					return hr;
				hr = rinfo.pIDMScript->QueryInterface(IID_IDirectMusicScriptPrivate, reinterpret_cast<void**>(&rinfo.pIDMScriptPrivate));
				if (FAILED(hr))
					return hr;
				break;

			case DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK:
				{
					hr = ri.ReadText(&rinfo.pwszRoutineName);
					if (FAILED(hr))
					{
#ifdef DBG
						if (hr == E_FAIL)
						{
							Trace(1, "Error: Unable to load script track: Problem reading 'scrn' chunk.\n");
						}
#endif
						return hr == E_FAIL ? DMUS_E_INVALID_SCRIPTTRACK : hr;
					}
				}
				break;

			default:
				break;
		}
	}
	hr = ri.hr();

	if (SUCCEEDED(hr) && (!fFoundEventHeader || !rinfo.pIDMScript || !rinfo.pwszRoutineName))
	{
#ifdef DBG
		if (!fFoundEventHeader)
		{
			Trace(1, "Error: Unable to load script track: Chunk 'scrh' not found.\n");
		}
		else if (!rinfo.pIDMScript)
		{
			Trace(1, "Error: Unable to load script track: List 'DMRF' not found.\n");
		}
		else
		{
			Trace(1, "Error: Unable to load script track: Chunk 'scrn' not found.\n");
		}
#endif
		hr = DMUS_E_INVALID_SCRIPTTRACK;
	}

	if (SUCCEEDED(hr))
		m_EventList.AddHead(spItem.disown()); // disown releases SmartRef::Ptr from its obligation to delete the item since that is now handled by the list

	return hr;
}

HRESULT CDirectMusicScriptTrack::PlayItem(
		const EventInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime)
{
	DWORD dwTimingFlags = 0;

	DMUS_PMSG *pMsg;
	HRESULT hr = pPerf->AllocPMsg(sizeof(DMUS_PMSG), &pMsg);
	if (FAILED(hr))
		return hr;
    ZeroAndSize(pMsg);

    CScriptTrackEvent *pScriptEvent = new CScriptTrackEvent;
	if (!pScriptEvent)
	{
		hr = E_OUTOFMEMORY;
		goto End;
	}

    hr = pScriptEvent->Init(item, pSegSt);
    if (FAILED(hr))
    {
		goto End;
    }

	if (item.dwFlags & DMUS_IO_SCRIPTTRACKF_PREPARE)
		dwTimingFlags = DMUS_PMSGF_TOOL_IMMEDIATE;
	else if (item.dwFlags & DMUS_IO_SCRIPTTRACKF_QUEUE)
		dwTimingFlags = DMUS_PMSGF_TOOL_QUEUE;
	else if (item.dwFlags & DMUS_IO_SCRIPTTRACKF_ATTIME)
		dwTimingFlags = DMUS_PMSGF_TOOL_ATTIME;
	else
		dwTimingFlags = DMUS_IO_SCRIPTTRACKF_QUEUE; // default

	if (fClockTime)
	{
		pMsg->rtTime = item.lTimePhysical * gc_RefPerMil + rtOffset;
		pMsg->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | dwTimingFlags;
		if (!(item.dwFlags & DMUS_IO_SCRIPTTRACKF_ATTIME)) // with at time, it may already be too late to play at the designated time so Play calls will just use time zero (ASAP)
		{
            pScriptEvent->SetTime(pMsg->rtTime, DMUS_SEGF_REFTIME);
		}
	}
	else
	{
		pMsg->mtTime = item.lTimePhysical + mtOffset;
		pMsg->dwFlags = DMUS_PMSGF_MUSICTIME | dwTimingFlags;
		if (!(item.dwFlags & DMUS_IO_SCRIPTTRACKF_ATTIME)) // with at time, it may already be too late to play at the designated time so Play calls will just use time zero (ASAP)
		{
            pScriptEvent->SetTime(pMsg->mtTime, 0);
		}
	}
	pMsg->dwVirtualTrackID = dwVirtualID;
    pMsg->punkUser = pScriptEvent;
	pMsg->pTool = this;
	this->AddRef(); // will be released when message is sent
	pMsg->dwType = DMUS_PMSGT_USER;

	hr = pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMsg));
	if (FAILED(hr))
	{
		this->Release(); // balance AddRef that now won't be counteracted
		goto End;
	}

	return hr;

End:
    if (pScriptEvent)
    {
        delete pScriptEvent;
    }
    pMsg->punkUser = NULL;
	pPerf->FreePMsg(pMsg);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\scriptthread.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSingleThreadedActiveScriptManager.
//

#include "stdinc.h"
#include "scriptthread.h"
#include "activescript.h"
#include "workthread.h"


#define S_STD_PARAMS ScriptManager *pmgr; HRESULT *phr;

CWorkerThread CSingleThreadedScriptManager::ms_Thread(true, true);

//////////////////////////////////////////////////////////////////////
// Construction

struct S_Create
{
	CSingleThreadedScriptManager *_this;
	bool fUseOleAut;
	const WCHAR *pwszLanguage;
	const WCHAR *pwszSource;
	CDirectMusicScript *pParentScript;
	HRESULT *phr;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_Create(void *pvParams)
{
	S_Create *pS = reinterpret_cast<S_Create*>(pvParams);
	pS->_this->m_pScriptManager = new CActiveScriptManager(pS->fUseOleAut, pS->pwszLanguage, pS->pwszSource, pS->pParentScript, pS->phr, pS->pErrorInfo);
}

CSingleThreadedScriptManager::CSingleThreadedScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
  : m_pScriptManager(NULL)
{
	S_Create S = { this, fUseOleAut, pwszLanguage, pwszSource, pParentScript, phr, pErrorInfo };
	HRESULT hr = ms_Thread.Create();
	if (SUCCEEDED(hr))
	{
		hr = ms_Thread.Call(F_Create, &S, sizeof(S), true);
	}
	if (FAILED(hr)) // Only overwrite phr if the call itself failed.  Otherwise the call itself sets phr via struct S.
		*phr = hr;
}

//////////////////////////////////////////////////////////////////////
// Start

struct S_Start
{
	S_STD_PARAMS

	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_Start(void *pvParams)
{
	S_Start *pS = reinterpret_cast<S_Start*>(pvParams);
	*pS->phr = pS->pmgr->Start(pS->pErrorInfo);
}

HRESULT
CSingleThreadedScriptManager ::Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_Start S = { m_pScriptManager, &hr, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_Start, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CallRoutine

struct S_CallRoutine
{
	S_STD_PARAMS

	const WCHAR *pwszRoutineName;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_CallRoutine(void *pvParams)
{
	S_CallRoutine *pS = reinterpret_cast<S_CallRoutine*>(pvParams);
	*pS->phr = pS->pmgr->CallRoutine(pS->pwszRoutineName, pS->pErrorInfo);
}

HRESULT CSingleThreadedScriptManager::CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_CallRoutine S = { m_pScriptManager, &hr, pwszRoutineName, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_CallRoutine, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// ScriptTrackCallRoutine

struct S_ScriptTrackCallRoutine
{
	S_STD_PARAMS

	IDirectMusicSegmentState *pSegSt;
	DWORD dwVirtualTrackID;
	bool fErrorPMsgsEnabled;
	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	WCHAR wszRoutineName[1]; // dynamically allocate extra space to hold the actual string within this structure
};

void F_ScriptTrackCallRoutine(void *pvParams)
{
	S_ScriptTrackCallRoutine *pS = reinterpret_cast<S_ScriptTrackCallRoutine*>(pvParams);
	pS->pmgr->ScriptTrackCallRoutine(
				pS->wszRoutineName,
				pS->pSegSt,
				pS->dwVirtualTrackID,
				pS->fErrorPMsgsEnabled,
				pS->i64IntendedStartTime,
				pS->dwIntendedStartTimeFlags);
	pS->pSegSt->Release(); // release the interface held in CSingleThreadedScriptManager::ScriptTrackCallRoutine
}

HRESULT CSingleThreadedScriptManager::ScriptTrackCallRoutine(
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags)
{
	// We need to allocate the structure with extra space to hold the routine name.  This is because
	// the call is asynchonous so a copy of the text will be needed because copying the pwszRoutineName
	// would fail because we can't be sure the string it points to will remain be allocated.
	int cbS = sizeof(S_ScriptTrackCallRoutine) + (sizeof(WCHAR) * wcslen(pwszRoutineName));
	S_ScriptTrackCallRoutine *pS = reinterpret_cast<S_ScriptTrackCallRoutine *>(new char[cbS]);
	if (!pS)
		return E_OUTOFMEMORY;
	pS->pmgr = m_pScriptManager;
	pS->phr = NULL;
	pS->pSegSt = pSegSt;
	pS->pSegSt->AddRef(); // hold a ref because the call is asynchronous and the interface we were passed may be released
	pS->dwVirtualTrackID = dwVirtualTrackID;
	pS->fErrorPMsgsEnabled = fErrorPMsgsEnabled;
	pS->i64IntendedStartTime = i64IntendedStartTime;
	pS->dwIntendedStartTimeFlags = dwIntendedStartTimeFlags;
	wcscpy(pS->wszRoutineName, pwszRoutineName);

	// Call asynchronously.  Needed to avoid deadlocks between the VBScript thread and
	// performance or to avoid blocking the performance if the VBScript routine goes into
	// a long loop.                                                          VVVVV
	HRESULT hrThreadCall = ms_Thread.Call(F_ScriptTrackCallRoutine, pS, cbS, false);
    delete [] reinterpret_cast<char *>(pS);
	return hrThreadCall;
}

//////////////////////////////////////////////////////////////////////
// SetVariable

struct S_SetVariable
{
	S_STD_PARAMS

	const WCHAR *pwszVariableName;
	VARIANT *pvarValue; // pass struct by reference
	bool fSetRef;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_SetVariable(void *pvParams)
{
	S_SetVariable *pS = reinterpret_cast<S_SetVariable*>(pvParams);
	*pS->phr = pS->pmgr->SetVariable(pS->pwszVariableName, *pS->pvarValue, pS->fSetRef, pS->pErrorInfo);
}

HRESULT CSingleThreadedScriptManager::SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_SetVariable S	= { m_pScriptManager, &hr, pwszVariableName, &varValue, fSetRef, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_SetVariable, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// GetVariable

struct S_GetVariable
{
	S_STD_PARAMS

	const WCHAR *pwszVariableName;
	VARIANT *pvarValue;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_GetVariable(void *pvParams)
{
	S_GetVariable *pS = reinterpret_cast<S_GetVariable*>(pvParams);
	*pS->phr = pS->pmgr->GetVariable(pS->pwszVariableName, pS->pvarValue, pS->pErrorInfo);
}


HRESULT CSingleThreadedScriptManager::GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_GetVariable S = { m_pScriptManager, &hr, pwszVariableName, pvarValue, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_GetVariable, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// EnumRoutine

struct S_EnumItem
{
	S_STD_PARAMS

	bool fRoutine;
	DWORD dwIndex;
	WCHAR *pwszName;
	int *pcItems;
};

void F_EnumItem(void *pvParams)
{
	S_EnumItem *pS = reinterpret_cast<S_EnumItem*>(pvParams);
	*pS->phr = pS->pmgr->EnumItem(pS->fRoutine, pS->dwIndex, pS->pwszName, pS->pcItems);
}

HRESULT CSingleThreadedScriptManager::EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems)
{
	HRESULT hr = E_FAIL;
	S_EnumItem S = { m_pScriptManager, &hr, fRoutine, dwIndex, pwszName, pcItems };
	HRESULT hrThreadCall = ms_Thread.Call(F_EnumItem, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// DispGetIDsOfNames

struct S_DispGetIDsOfNames
{
	S_STD_PARAMS

	const IID *piid; // use pointer instead of reference to leave struct as simple aggregate type
	LPOLESTR __RPC_FAR *rgszNames;
	UINT cNames;
	LCID lcid;
	DISPID *rgDispId;
};

void F_DispGetIDsOfNames(void *pvParams)
{
	S_DispGetIDsOfNames *pS = reinterpret_cast<S_DispGetIDsOfNames*>(pvParams);
	*pS->phr = pS->pmgr->DispGetIDsOfNames(*pS->piid, pS->rgszNames, pS->cNames, pS->lcid, pS->rgDispId);
}

HRESULT CSingleThreadedScriptManager::DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId)
{
	HRESULT hr = E_FAIL;
	S_DispGetIDsOfNames S = { m_pScriptManager, &hr, &riid, rgszNames, cNames, lcid, rgDispId };
	HRESULT hrThreadCall = ms_Thread.Call(F_DispGetIDsOfNames, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// DispInvoke

struct S_DispInvoke
{
	S_STD_PARAMS

	DISPID dispIdMember;
	const IID *piid; // use pointer instead of reference to leave struct as simple aggregate type
	LCID lcid;
	WORD wFlags;
	DISPPARAMS __RPC_FAR *pDispParams;
	VARIANT __RPC_FAR *pVarResult;
	EXCEPINFO __RPC_FAR *pExcepInfo;
	UINT __RPC_FAR *puArgErr;
};

void F_DispInvoke(void *pvParams)
{
	S_DispInvoke *pS = reinterpret_cast<S_DispInvoke*>(pvParams);
	*pS->phr = pS->pmgr->DispInvoke(pS->dispIdMember, *pS->piid, pS->lcid, pS->wFlags, pS->pDispParams, pS->pVarResult, pS->pExcepInfo, pS->puArgErr);
}

HRESULT CSingleThreadedScriptManager::DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr)
{
	HRESULT hr = E_FAIL;
	S_DispInvoke S = { m_pScriptManager, &hr, dispIdMember, &riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr };
	HRESULT hrThreadCall = ms_Thread.Call(F_DispInvoke, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Close

struct S_Close
{
	ScriptManager *pmgr;
};

void F_Close(void *pvParams)
{
	S_Close *pS = reinterpret_cast<S_Close*>(pvParams);
	pS->pmgr->Close();
}

void CSingleThreadedScriptManager::Close()
{
	S_Close S = { m_pScriptManager };
	ms_Thread.Call(F_Close, &S, sizeof(S), true);
}

//////////////////////////////////////////////////////////////////////
// Release

struct S_Release
{
	ScriptManager *pmgr;
	DWORD *pdw;
};

void F_Release(void *pvParams)
{
	S_Release *pS = reinterpret_cast<S_Release*>(pvParams);
	*pS->pdw = pS->pmgr->Release();
}

STDMETHODIMP_(ULONG)
CSingleThreadedScriptManager::Release()
{
	DWORD dw = 1;
	S_Release S = { m_pScriptManager, &dw };
	if (m_pScriptManager) // if creation failed, release will be called when m_pScriptManager hasn't been set
	{
		ms_Thread.Call(F_Release, &S, sizeof(S), true);
	}

	if (!dw)
		delete this;

	return dw;
}

/*
Template I used to stamp these things out...

//////////////////////////////////////////////////////////////////////
// XXX

struct S_XXX
{
	S_STD_PARAMS

	YYY
};

void F_XXX(void *pvParams)
{
	S_XXX *pS = reinterpret_cast<S_XXX*>(pvParams);
	*pS->phr = pS->pmgr->XXX(YYY);
}

HRESULT
CSingleThreadedScriptManager::XXX(YYY)
{
	HRESULT hr = E_FAIL;
	S_XXX S = { m_pScriptManager, &hr, YYY };
	HRESULT hrThreadCall = ms_Thread.Call(F_XXX, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\unkhelp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper classes for implementing IUnknown.
//

#include "stdinc.h"
#include "unkhelp.h"
#include "dll.h"

ComRefCount::ComRefCount()
  : m_cRef(1)
{
	LockModule(true);
}

STDMETHODIMP_(ULONG)
ComRefCount::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
ComRefCount::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

STDMETHODIMP
ComSingleInterface::QueryInterface(const IID &iid, void **ppv, const IID&iidExpected, void *pvInterface)
{
	V_INAME(ComSingleInterface::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == iidExpected)
	{
		*ppv = pvInterface;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	this->AddRef();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\trackshared.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Code that needs to be shared between the script track (CDirectMusicScriptTrack) and
// the script object (CDirectMusicScript, etc.).
//

#include "stdinc.h"
#include "trackshared.h"
#include "dmusicp.h"

HRESULT FireScriptTrackErrorPMsg(IDirectMusicPerformance *pPerf, IDirectMusicSegmentState *pSegSt, DWORD dwVirtualTrackID, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	SmartRef::ComPtr<IDirectMusicGraph> scomGraph;
	HRESULT hr = pSegSt->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&scomGraph));
	if (FAILED(hr))
		return hr;

	SmartRef::PMsg<DMUS_SCRIPT_TRACK_ERROR_PMSG> pmsgScriptTrackError(pPerf);
	hr = pmsgScriptTrackError.hr();
	if (FAILED(hr))
		return hr;

	// generic PMsg fields

	REFERENCE_TIME rtTimeNow = 0;
	hr = pPerf->GetTime(&rtTimeNow, NULL);
	if (FAILED(hr))
		return hr;

	pmsgScriptTrackError.p->rtTime = rtTimeNow;
	pmsgScriptTrackError.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
	// dwPChannel: the script doesn't have a channel so leave as 0
	pmsgScriptTrackError.p->dwVirtualTrackID = dwVirtualTrackID;
	pmsgScriptTrackError.p->dwType = DMUS_PMSGT_SCRIPTTRACKERROR;
	pmsgScriptTrackError.p->dwGroupID = -1; // the script track doesn't have a group so just say all

	// error PMsg fields

	CopyMemory(&pmsgScriptTrackError.p->ErrorInfo, pErrorInfo, sizeof(pmsgScriptTrackError.p->ErrorInfo));

	// send it
	pmsgScriptTrackError.StampAndSend(scomGraph);
	hr = pmsgScriptTrackError.hr();
	if (FAILED(hr))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\trackshared.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Code that needs to be shared between the script track (CDirectMusicScriptTrack) and
// the script object (CDirectMusicScript, etc.).
//

#pragma once

// Private script interface used by the  script track to call routines.  This is needed because
// VBScript routines must be triggered asynchronously in order to avoid deadlocks with other
// threads.  This also helps to avoid starving the performance if routines have long loops.

static const GUID IID_IDirectMusicScriptPrivate = 
	{ 0xf9a5071b, 0x6e0d, 0x498c, { 0x8f, 0xed, 0x56, 0x57, 0x1c, 0x1a, 0xb1, 0xa9 } };// {F9A5071B-6E0D-498c-8FED-56571C1AB1A9}

interface IDirectMusicScriptPrivate : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE ScriptTrackCallRoutine(
											WCHAR *pwszRoutineName,
											IDirectMusicSegmentState *pSegSt,
											DWORD dwVirtualTrackID,
											bool fErrorPMsgsEnabled,
											__int64 i64IntendedStartTime,
											DWORD dwIntendedStartTimeFlags)=0;
};

// Shared function used by the script track and by the script object for ScriptTrackCallRoutine.
// Fills out and sends a DMUS_SCRIPT_TRACK_ERROR_PMSG for the given error.
HRESULT FireScriptTrackErrorPMsg(IDirectMusicPerformance *pPerf, IDirectMusicSegmentState *pSegSt, DWORD dwVirtualTrackID, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\unkhelp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper classes for implementing IUnknown.
//

#pragma once

// Implements AddRef/Release with ref count beginning at 1. Also handles module locking.
class ComRefCount
  : public IUnknown
{
public:
	ComRefCount();
	virtual ~ComRefCount() {}

	// IUnknown
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

private:
	long m_cRef;
};

// Use this macro to declare AddRef and Release in the public section of your derived class.  This is necessary because
// the IUnknown section of any interfaces aren't linked to the methods in this base class.
#define ComRefCountAddRefRelease STDMETHOD_(ULONG, AddRef)() { return ComRefCount::AddRef(); } STDMETHOD_(ULONG, Release)() { return ComRefCount::Release(); }

// Implements QueryInterface for a single interface (in addition to IUnknown). You must pass the IID of your interface (iidExpected)
// and a pointer to that interface (pvInterface).
class ComSingleInterface
  : public ComRefCount
{
public:
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv, const IID&iidExpected, void *pvInterface);
};

// Use this macro to declare AddRef, Release, and QueryInterface function in the public section of your derived class.
#define ComSingleInterfaceUnknownMethods(IMyInterface) ComRefCountAddRefRelease STDMETHOD(QueryInterface)(const IID &iid, void **ppv) { return ComSingleInterface::QueryInterface(iid, ppv, IID_##IMyInterface, static_cast<IMyInterface*>(this)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\trackhelp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CBasicTrack.
//

#include "trackhelp.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Creation

CBasicTrack::CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid)
  : m_cRef(0),
	m_plModuleLockCounter(plModuleLockCounter),
	m_rclsid(rclsid)
{
	InitializeCriticalSection(&m_CriticalSection);
	InterlockedIncrement(plModuleLockCounter);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CBasicTrack::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CBasicTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
		*ppv = static_cast<IDirectMusicTrack8*>(this);
	else if (iid == IID_IPersistStream)
		*ppv = static_cast<IPersistStream*>(this);
	else if (iid == IID_IPersist)
		*ppv = static_cast<IPersist*>(this);
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG)
CBasicTrack::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CBasicTrack::Release()
{
	if (!InterlockedDecrement(&m_cRef))
	{
		DeleteCriticalSection(&m_CriticalSection);
		delete this;
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CBasicTrack::GetClassID(CLSID* pClassID)
{
	V_INAME(CBasicTrack::GetClassID);
	V_PTR_WRITE(pClassID, sizeof(pClassID));
	*pClassID = m_rclsid;
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CBasicTrack::Init(IDirectMusicSegment *pSegment)
{
	V_INAME(CBasicTrack::Init);
	V_INTERFACE(pSegment);
	return S_OK;
}

STDMETHODIMP
CBasicTrack::Play(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID)
{
	return this->PlayMusicOrClock(
					pStateData,
					mtStart,
					mtEnd,
					mtOffset,
					0,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					false);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8

STDMETHODIMP CBasicTrack::PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID)
{
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
	    // Convert all reference times to millisecond times and then just use them as if this were MUSIC_TIME.
	    return this->PlayMusicOrClock(
					pStateData,
					static_cast<MUSIC_TIME>(rtStart / gc_RefPerMil),
					static_cast<MUSIC_TIME>(rtEnd / gc_RefPerMil),
					static_cast<MUSIC_TIME>(rtOffset / gc_RefPerMil),
					rtOffset,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					true);
    }
    else
    {
        return this->PlayMusicOrClock(
					pStateData,
					static_cast<MUSIC_TIME>(rtStart),
					static_cast<MUSIC_TIME>(rtEnd),
					static_cast<MUSIC_TIME>(rtOffset),
					0,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					false);
    }
}

STDMETHODIMP CBasicTrack::GetParamEx(
		REFGUID rguidType,
		REFERENCE_TIME rtTime,
		REFERENCE_TIME* prtNext,
		void* pParam,
        void * pStateData,
        DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
	    hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime / gc_RefPerMil), &mtNext, pParam);
	    if (prtNext)
	    {
		    *prtNext = mtNext * gc_RefPerMil;
	    }
    }
    else
    {
	    hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CBasicTrack::SetParamEx(
		REFGUID rguidType,
		REFERENCE_TIME rtTime,
		void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= gc_RefPerMil;
    }
	return SetParam(rguidType, static_cast<MUSIC_TIME>(rtTime ), pParam);
}

STDMETHODIMP CBasicTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CBasicTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\track.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CDirectMusicScriptTrack.
//

// This track type holds events that cause script routines to be called during
// playback of a segment.

#pragma once

#include "tlist.h"
#include "trackhelp.h"
#include "trackshared.h"

//////////////////////////////////////////////////////////////////////
// Types

// List of events
struct EventInfo
{
	EventInfo() : dwFlags(0), lTriggerTime(0), lTimePhysical(0), pIDMScript(NULL), pIDMScriptPrivate(NULL), pwszRoutineName(NULL) {}
	~EventInfo() {
		SafeRelease(pIDMScript);
		SafeRelease(pIDMScriptPrivate);
		delete[] pwszRoutineName;
	}

	HRESULT Clone(const EventInfo &o, MUSIC_TIME mtStart)
	{
		pwszRoutineName = new WCHAR[wcslen(o.pwszRoutineName) + 1];
		if (!pwszRoutineName)
			return E_OUTOFMEMORY;
		wcscpy(pwszRoutineName, o.pwszRoutineName);

		dwFlags = o.dwFlags;
		lTriggerTime = o.lTriggerTime - mtStart;
		lTimePhysical = o.lTimePhysical - mtStart;

		pIDMScript = o.pIDMScript;
		pIDMScript->AddRef();
		pIDMScriptPrivate = o.pIDMScriptPrivate;
		pIDMScriptPrivate->AddRef();

		return S_OK;
	}

	// from event header chunk <scrh>
	DWORD dwFlags;
	MUSIC_TIME lTriggerTime; // logical time
	MUSIC_TIME lTimePhysical;
	// from reference <DMRF>
	IDirectMusicScript *pIDMScript;
	IDirectMusicScriptPrivate *pIDMScriptPrivate;
	WCHAR *pwszRoutineName;
};

class CScriptTrackEvent : public IUnknown
{
public:
    CScriptTrackEvent() : 
      m_pSegSt(NULL), 
      m_pEvent(NULL), 
      m_i64IntendedStartTime(0), 
      m_dwIntendedStartTimeFlags(0), 
      m_cRef(1) 
      {
      }

    ~CScriptTrackEvent();

    // IUnknown
    STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

    // CScriptTrackEvent
    HRESULT Init(const EventInfo &item, IDirectMusicSegmentState* pSegSt);

    void SetTime(REFERENCE_TIME rtTime, DWORD dwFlags)
    {
		m_i64IntendedStartTime = rtTime;
		m_dwIntendedStartTimeFlags = dwFlags;
    }

    void Call(DWORD dwdwVirtualTrackID, bool fErrorPMsgsEnabled);

private:
	IDirectMusicSegmentState *m_pSegSt;
	EventInfo *m_pEvent; // event to execute
	// scheduled time of the routine call
	__int64 m_i64IntendedStartTime;
	DWORD m_dwIntendedStartTimeFlags;

    long m_cRef;
};

//////////////////////////////////////////////////////////////////////
// CDirectMusicScriptTrack

class CDirectMusicScriptTrack;
typedef CPlayingTrack<CDirectMusicScriptTrack, EventInfo> CDirectMusicScriptTrackBase;

class CDirectMusicScriptTrack
  : public CDirectMusicScriptTrackBase,
	public IDirectMusicTool
{
public:
	CDirectMusicScriptTrack(HRESULT *pHr);
	~CDirectMusicScriptTrack()
    {
        TListItem<EventInfo>* pItem = m_EventList.GetHead();
        for ( ; pItem; pItem = pItem->GetNext() )
        {
            SafeRelease(pItem->GetItemValue().pIDMScript);
            SafeRelease(pItem->GetItemValue().pIDMScriptPrivate);
        }
    }

	// initialize each referenced script in InitPlay
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);

	// Need to implement IUnknown as part of the IDirectMusic tool interface.  (Just used to receive callbacks -- you can't actually QI to it.)
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv) { return CDirectMusicScriptTrackBase::QueryInterface(iid, ppv); }
	STDMETHOD_(ULONG, AddRef)() { return CDirectMusicScriptTrackBase::AddRef(); }
	STDMETHOD_(ULONG, Release)() { return CDirectMusicScriptTrackBase::Release(); }

	// IDirectMusicTool methods (since we aren't in a graph, only ProcessPMsg and Flush are called)
	STDMETHOD(Init)(IDirectMusicGraph* pGraph) { return E_UNEXPECTED; }
	STDMETHOD(GetMsgDeliveryType)(DWORD* pdwDeliveryType)  { return E_UNEXPECTED; }
	STDMETHOD(GetMediaTypeArraySize)(DWORD* pdwNumElements)  { return E_UNEXPECTED; }
	STDMETHOD(GetMediaTypes)(DWORD** padwMediaTypes, DWORD dwNumElements)  { return E_UNEXPECTED; }
	STDMETHOD(ProcessPMsg)(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG);
	STDMETHOD(Flush)(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime) { return DMUS_S_FREE; } // If the performance was stopped before the event actually fired, just ignore it.

	// IDirectMusicTrack methods
	STDMETHOD(IsParamSupported)(REFGUID rguid);
	STDMETHOD(SetParam)(REFGUID rguid,MUSIC_TIME mtTime,void *pData);

protected:
	HRESULT PlayItem(
		const EventInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadEvent(SmartRef::RiffIter ri, IDirectMusicLoader *pIDMLoader);

	bool m_fErrorPMsgsEnabled;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\workthread.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CWorkerThread.
// Creates worker threads, calls functions on them, and optionally waits for results.
//

#pragma once

#include "tlist.h"

class CWorkerThread
{
public:
	typedef void (*FunctionPointer)(void *pvParams);

	CWorkerThread(
		bool fUsesCOM,		// setting fUsesCOM means the thread will call CoInitialize
		bool fDeferCreation	// set to true not to automatically create thread in constructor
		);
	~CWorkerThread();

	HRESULT Call(FunctionPointer pfn, void *pvParams, UINT cbParams, bool fBlock); // if fBlock is true, the current thread will block until the called function returns

	// These can be used to dynamically create and destroy the thread.
	// Call fails (E_FAIL) when the thread isn't going.
	HRESULT Create();
	void Terminate(bool fWaitForThreadToExit);

private:
	friend unsigned int __stdcall WorkerThread(LPVOID lpThreadParameter);

	void Main();

	HANDLE m_hThread;
	unsigned int m_uiThreadId;
	HANDLE m_hEvent;

	CRITICAL_SECTION m_CriticalSection;
	struct CallInfo
	{
		FunctionPointer pfn;
		void *pvParams;
		HANDLE hEventOut; // if non-null, the main thread is waiting for a signal when the function has returned
	};
	TList<CallInfo> m_Calls;
	bool m_fUsesCOM;
	HRESULT m_hrCOM; // HRESULT from initializing COM
	bool m_fEnd; // set to true when the script thread should stop running
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmscript\workthread.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//
// Declaration of CWorkerThread.
//

#include "stdinc.h"
#include <process.h>
#include "workthread.h"

unsigned int __stdcall WorkerThread(LPVOID lpThreadParameter)
{
    reinterpret_cast<CWorkerThread*>(lpThreadParameter)->Main();
    return 0;
}

HRESULT
CWorkerThread::Create()
{
    if (m_hThread)
        return S_FALSE;

    if (!m_hEvent)
        return E_FAIL; // The constructor was unable to create the event we'll need to run the thread so we can't create it.

    m_hrCOM = E_FAIL;
    m_fEnd = false;
    m_hThread = reinterpret_cast<HANDLE>(_beginthreadex(NULL, 0, WorkerThread, this, 0, &m_uiThreadId));
    return m_hThread ? S_OK : E_FAIL;
}

void
CWorkerThread::Terminate(bool fWaitForThreadToExit)
{
    if (!m_hThread)
        return;

    EnterCriticalSection(&m_CriticalSection);
    m_fEnd = true;
    SetEvent(m_hEvent);
    LeaveCriticalSection(&m_CriticalSection);

    if (fWaitForThreadToExit)
    {
        // Wait until the other thread stops processing.
        WaitForSingleObject(m_hThread, INFINITE);
    }

    CloseHandle(m_hThread);
    m_hThread = NULL;
}

CWorkerThread::CWorkerThread(bool fUsesCOM, bool fDeferCreation)
  : m_hThread(NULL),
    m_uiThreadId(0),
    m_fUsesCOM(fUsesCOM)
{
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.

    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hEvent)
        return;

    if (!fDeferCreation)
        Create();
}

CWorkerThread::~CWorkerThread()
{
    Terminate(false);
    CloseHandle(m_hEvent);
    DeleteCriticalSection(&m_CriticalSection);
}

HRESULT CWorkerThread::Call(FunctionPointer pfn, void *pvParams, UINT cbParams, bool fBlock)
{
    if (!m_hThread)
        return E_FAIL;

    if (fBlock && GetCurrentThreadId() == m_uiThreadId)
    {
        // The call is already on this thread so just do it.
        pfn(pvParams);
        return S_OK;
    }

    TListItem<CallInfo> *pItem = new TListItem<CallInfo>;
    if (!pItem)
        return E_OUTOFMEMORY;

    CallInfo &rinfo = pItem->GetItemValue();
    rinfo.pfn = pfn;
    rinfo.hEventOut = fBlock ? CreateEvent(NULL, FALSE, FALSE, NULL) : 0;
    if (rinfo.hEventOut)
    {
        // Synchronous call -- OK to reference via pointer to params
        rinfo.pvParams = pvParams;
    }
    else
    {
        // Asynchronous call -- need to copy params
        rinfo.pvParams = new char[cbParams];
        if (!rinfo.pvParams)
        {
            delete pItem;
            return E_OUTOFMEMORY;
        }
        CopyMemory(rinfo.pvParams, pvParams, cbParams);
    }

    EnterCriticalSection(&m_CriticalSection);
    m_Calls.AddHead(pItem);
    HANDLE hEventCall = rinfo.hEventOut; // Can't refer to rinfo after we set the event because the worker will delete the event.
    SetEvent(m_hEvent);
    LeaveCriticalSection(&m_CriticalSection);

    if (hEventCall)
    {
        WaitForSingleObject(hEventCall, INFINITE);
        if (FAILED(m_hrCOM))
            return m_hrCOM;
        CloseHandle(hEventCall);
    }

    return S_OK;
}

void CWorkerThread::Main()
{
    if (m_fUsesCOM)
    {
        m_hrCOM = CoInitialize(NULL);
        if (FAILED(m_hrCOM))
        {
            Trace(1, "Error: CoInitialize failed: 0x%08x.\n", m_hrCOM);
        }
    }

    for (;;)
    {
        // block until there's something to do
        WaitForSingleObject(m_hEvent, INFINITE);

        EnterCriticalSection(&m_CriticalSection);

        // check for end
        if (m_fEnd)
        {
            LeaveCriticalSection(&m_CriticalSection);
            if (m_fUsesCOM && SUCCEEDED(m_hrCOM))
                CoUninitialize();
            _endthreadex(0);
        }

        // take all the list items
        TListItem<CallInfo> *m_pCallHead = m_Calls.GetHead();
        m_Calls.RemoveAll();

        LeaveCriticalSection(&m_CriticalSection);

        // call each function
        TListItem<CallInfo> *m_pCall = m_pCallHead;
        while (m_pCall)
        {
            CallInfo &rinfo = m_pCall->GetItemValue();
            if (SUCCEEDED(m_hrCOM))
                rinfo.pfn(rinfo.pvParams);

            if (rinfo.hEventOut)
                SetEvent(rinfo.hEventOut);
            else
                delete[] rinfo.pvParams;

            TListItem<CallInfo> *m_pNext = m_pCall->GetNext();
            delete m_pCall;
            m_pCall = m_pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\alist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       alist.cpp
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;
    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    // SetNext on pItem to NULL
    pItem->SetNext(NULL);
    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)
{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\aariff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       aariff.h
//
//--------------------------------------------------------------------------

//
// aariff.h
//

#ifndef __AARIFF__
#define __AARIFF__
#include <windows.h>
#include <mmsystem.h>
#include <objbase.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IAARIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IAARIFFStream
DECLARE_INTERFACE_(IAARIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};

struct CFileStream : IStream
{
///// object state
    ULONG           m_cRef;         // object reference count
    HANDLE          m_hfile;        // file handle

// construction and destruction
    CFileStream( HANDLE hfile ) : m_cRef( 1 ), m_hfile( hfile ) {}
#ifdef _MAC
    ~CFileStream() { FSClose( (int) m_hfile ); }
#else
    ~CFileStream() { CloseHandle( m_hfile ); }
#endif

///// IUnknown methods
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IStream ) )
        {
            *ppvObj = (IStream *) this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
       return m_cRef;
    }

    /* IStream methods */
    STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead )
    {
		DWORD dw;

		if( ReadFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbRead != NULL )
			{
				*pcbRead = dw;
			}
			return S_OK;
		}
		return E_FAIL;
    }
    STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten )
    {
		DWORD dw;

		if( WriteFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbWritten != NULL )
			{
				*pcbWritten = dw;
			}
			return S_OK;
		}
        return E_FAIL;
	}
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
    {
		DWORD dw;

		dw = SetFilePointer( m_hfile, dlibMove.LowPart, &dlibMove.HighPart, dwOrigin );
		if( dw == (DWORD)-1 )
		{
			return E_FAIL;
		}
		if( plibNewPosition != NULL )
		{
			plibNewPosition->LowPart = dw;
	        plibNewPosition->HighPart = dlibMove.HighPart;
		}
        return S_OK;
	}
    STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Revert()
    { return E_NOTIMPL; }
    STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/)
    { return E_NOTIMPL; }
    STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Clone( IStream** /*ppstm*/ )
    { return E_NOTIMPL; }
};

struct CRIFFStream : IAARIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IAARIFFStream ) )
        {
            *ppvObj = (IAARIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff );

#endif  // __AARIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\chordtrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) 1998-2001 Microsoft Corporation
//
//  File:       chordtrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// ChordTrack.cpp : Implementation of CChordTrack
//#include "stdafx.h"
//#include "Section.h"
#include "ChordTrk.h"
#include "debug.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CChordTrack

CChordTrack::CChordTrack() : m_bRequiresSave(0),
    m_bRoot(0), m_dwScalePattern(0), m_cRef(1), m_fNotifyChord(FALSE),
    m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

// This currently only supports cloning on measure boundaries
// (otherwise time sig info would be needed to get the beats right)
CChordTrack::CChordTrack(const CChordTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
    m_bRequiresSave(0),
    m_bRoot(0), m_dwScalePattern(0), m_cRef(1), 
    m_fNotifyChord(rTrack.m_fNotifyChord),
    m_fCSInitialized(FALSE)

{
    InterlockedIncrement(&g_cComponent);
    
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    TListItem<DMChord>* pScan = rTrack.m_ChordList.GetHead();
    TListItem<DMChord>* pPrevious = NULL;
    WORD wMeasure = 0;
    BOOL fStarted = FALSE;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMChord& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            if (!fStarted)
            {
                fStarted = TRUE;
                wMeasure = rScan.m_wMeasure;
            }
            TListItem<DMChord>* pNew = new TListItem<DMChord>;
            if (pNew)
            {
                DMChord& rNew = pNew->GetItemValue();
                rNew.m_strName = rScan.m_strName;
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_wMeasure = rScan.m_wMeasure - wMeasure;
                rNew.m_bBeat = rScan.m_bBeat;
                rNew.m_bKey = rScan.m_bKey;
                rNew.m_dwScale = rScan.m_dwScale;
                TListItem<DMSubChord>* pSubScan = rScan.m_SubChordList.GetHead();
                for(; pSubScan; pSubScan = pSubScan->GetNext())
                {
                    DMSubChord& rSubScan = pSubScan->GetItemValue();
                    TListItem<DMSubChord>* pSubNew = new TListItem<DMSubChord>;
                    if (pSubNew)
                    {
                        DMSubChord& rSubNew = pSubNew->GetItemValue();
                        rSubNew.m_dwChordPattern = rSubScan.m_dwChordPattern;
                        rSubNew.m_dwScalePattern = rSubScan.m_dwScalePattern;
                        rSubNew.m_dwInversionPoints = rSubScan.m_dwInversionPoints;
                        rSubNew.m_dwLevels = rSubScan.m_dwLevels;
                        rSubNew.m_bChordRoot = rSubScan.m_bChordRoot;
                        rSubNew.m_bScaleRoot = rSubScan.m_bScaleRoot;
                        rNew.m_SubChordList.AddTail(pSubNew);
                    }
                }
                m_ChordList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        DMChord& rPrevious = pPrevious->GetItemValue();
        TListItem<DMChord>* pNew = new TListItem<DMChord>;
        if (pNew)
        {
            DMChord& rNew = pNew->GetItemValue();
            rNew.m_strName = rPrevious.m_strName;
            rNew.m_mtTime = 0;
            rNew.m_wMeasure = 0;
            rNew.m_bBeat = 0;
            rNew.m_bKey = rPrevious.m_bKey;
            rNew.m_dwScale = rPrevious.m_dwScale;
            TListItem<DMSubChord>* pSubPrevious = rPrevious.m_SubChordList.GetHead();
            for(; pSubPrevious; pSubPrevious = pSubPrevious->GetNext())
            {
                DMSubChord& rSubPrevious = pSubPrevious->GetItemValue();
                TListItem<DMSubChord>* pSubNew = new TListItem<DMSubChord>;
                if (pSubNew)
                {
                    DMSubChord& rSubNew = pSubNew->GetItemValue();
                    rSubNew.m_dwChordPattern = rSubPrevious.m_dwChordPattern;
                    rSubNew.m_dwScalePattern = rSubPrevious.m_dwScalePattern;
                    rSubNew.m_dwInversionPoints = rSubPrevious.m_dwInversionPoints;
                    rSubNew.m_dwLevels = rSubPrevious.m_dwLevels;
                    rSubNew.m_bChordRoot = rSubPrevious.m_bChordRoot;
                    rSubNew.m_bScaleRoot = rSubPrevious.m_bScaleRoot;
                    rNew.m_SubChordList.AddTail(pSubNew);
                }
            }
            m_ChordList.AddHead(pNew);
        }
    }
}

CChordTrack::~CChordTrack()
{
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

void CChordTrack::Clear()
{
    m_ChordList.CleanUp();
}

STDMETHODIMP CChordTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CChordTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CChordTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CChordTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


// CChordTrack Methods
HRESULT CChordTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    V_INAME(CChordTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

// state data is not needed for now
typedef DWORD ChordStateData;

HRESULT CChordTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    ChordStateData* pStateData = new ChordStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *pStateData = 0;
    *ppStateData = pStateData;

    EnterCriticalSection( &m_CriticalSection );
    LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

HRESULT CChordTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(ChordStateData));
        ChordStateData* pSD = (ChordStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

HRESULT CChordTrack::SendNotification(REFGUID rguidType,
                                      MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (dwFlags & DMUS_TRACKF_NOTIFY_OFF)
    {
        return S_OK;
    }
    IDirectMusicSegment* pSegment = NULL;
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = DMUS_NOTIFICATION_CHORD;
        pEvent->guidNotificationType = rguidType;

        if( SUCCEEDED( pSegState->GetSegment(&pSegment)))
        {
            if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
            {
                pEvent->dwGroupID = 0xffffffff;
            }
            pSegment->Release();
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            if (rguidType == GUID_NOTIFICATION_PRIVATE_CHORD)
            {
                //stamp this with the internal Performance Tool and process immediately
                pEvent->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;
                pPerf->QueryInterface(IID_IDirectMusicTool, (void**)&pEvent->pTool);
                pEvent->pGraph = pGraph;
            }
            else
            {
                pEvent->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;
                pGraph->StampPMsg((DMUS_PMSG*) pEvent );
                pGraph->Release();
            }
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}

HRESULT CChordTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    V_INAME(CChordTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(ChordStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegState);

    bool fNotifyPastChord = false;
    TListItem<DMChord>* pLastChord = NULL;
    // if the dirty flag is set, a controlling segment either just stopped or just started.
    // send a private notification to sync with the current chord in this segment.
    if ( (dwFlags & DMUS_TRACKF_DIRTY) )
    {
        SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
    }
    // If we're seeking and not flushing, we need to notify for the chord that happens
    // before the current start time (if there is one)
    if ( (dwFlags & DMUS_TRACKF_SEEK) && !(dwFlags & DMUS_TRACKF_FLUSH) )
    {
        fNotifyPastChord = true;
    }
    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    TListItem<DMChord>* pChord = m_ChordList.GetHead();
    for(; pChord && SUCCEEDED(hr); pChord = pChord->GetNext())
    {
        MUSIC_TIME mtChordTime = pChord->GetItemValue().m_mtTime;
        if (mtChordTime < mtStart && fNotifyPastChord)
        {
            pLastChord = pChord;
        }
        else if (mtStart <= mtChordTime && mtChordTime < mtEnd)
        {
            if (pLastChord)
            {
                SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                if (m_fNotifyChord)
                {
                    hr = SendNotification(GUID_NOTIFICATION_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                }
                pLastChord = NULL;
            }
            if (SUCCEEDED(hr))
            {
                SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtChordTime + mtOffset, pPerf, pSegState, dwFlags);
                if (m_fNotifyChord)
                {
                    hr = SendNotification(GUID_NOTIFICATION_CHORD, mtChordTime + mtOffset, pPerf, pSegState, dwFlags);
                }
            }
        }
        else if (mtChordTime >= mtEnd)
        {
            if (pLastChord)
            {
                SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                if (m_fNotifyChord)
                {
                    hr = SendNotification(GUID_NOTIFICATION_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                }
            }
            break;
        }
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CChordTrack::GetChord( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_CHORD_PARAM* pChordParam)
{
    TListItem<DMChord>* pChord = m_ChordList.GetHead();
    TListItem<DMChord>* pNext = pNext = pChord->GetNext();
    for(; pNext; pNext = pNext->GetNext())
    {
        if (pNext->GetItemValue().m_mtTime <= mtTime) // may be it, but we need a next time
        {
            pChord = pNext;
        }
        else // passed it
        {
            break;
        }
    }
    *pChordParam = pChord->GetItemValue();
    if (pmtNext)
    {
        if (pNext)
        {
            *pmtNext = pNext->GetItemValue().m_mtTime - mtTime;
        }
        else
        {
            MUSIC_TIME mtLength = 0;
            *pmtNext = mtLength;
        }
    }
    TraceI(4, "Current time: %d, Time of Chord: %d\n", mtTime, pChord->GetItemValue().m_mtTime);
    return S_OK;
}

HRESULT CChordTrack::GetRhythm( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_RHYTHM_PARAM* pRhythmParam)
{
    DirectMusicTimeSig TimeSig = pRhythmParam->TimeSig;
    WORD wMeasure = (WORD)TimeSig.ClocksToMeasure(mtTime);
    TListItem<DMChord>* pChord = m_ChordList.GetHead();
    TListItem<DMChord>* pNext = NULL;
    DWORD dwPattern = 0;
    for( ; pChord; pChord = pChord->GetNext())
    {
        DMChord& rChord = pChord->GetItemValue();
        pNext = pChord->GetNext();
        if (rChord.m_wMeasure > wMeasure) // passed the target measure
        {
            break;
        }
        else if (wMeasure == rChord.m_wMeasure && !rChord.m_fSilent) // found (non-silent) part of the pattern
        {
            dwPattern |= 1 << rChord.m_bBeat;
        }
    }
//  DMChord& ChordResult =  pChord->GetItemValue();
    pRhythmParam->dwRhythmPattern = dwPattern;
    if (pmtNext)
    {
        if (pNext)
        {
            *pmtNext = pNext->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
        }
        else
        {
            MUSIC_TIME mtLength = 0;
            *pmtNext = mtLength;
        }
    }
    return S_OK;
}

// Returns either the Chord in effect at the beat containing mtTime,
// or the Rhythm pattern for the measure containing mtTime, depending
// on the value of dwCommand.
// ppData points to a struct containing an input time signature
// (used for converting mtTime to measures and beats) and either a list
// of subchords (if we're returning a chord) or a DWORD containing a rhythm
// pattern (if that's what's being returned).
HRESULT CChordTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(CChordTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rCommandGuid);

    if( NULL == pData )
    {
        return E_POINTER;
    }

    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection( &m_CriticalSection );
    if (m_ChordList.GetHead())  // Something's in the chord list
    {
        if (rCommandGuid == GUID_ChordParam)
        {
            hr = GetChord(mtTime, pmtNext, (DMUS_CHORD_PARAM*)pData);
        }
        else if (rCommandGuid == GUID_RhythmParam)
        {
            hr = GetRhythm(mtTime, pmtNext, (DMUS_RHYTHM_PARAM*)pData);
        }
        else
        {
            hr = DMUS_E_GET_UNSUPPORTED;
        }
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
} 

HRESULT CChordTrack::SetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CChordTrack::SetParam);
    V_REFGUID(rCommandGuid);

    if( NULL == pData )
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (rCommandGuid == GUID_ChordParam)
    {
        DMUS_CHORD_PARAM* pChordParam = (DMUS_CHORD_PARAM*)(pData);
        TListItem<DMChord>* pChordItem = m_ChordList.GetHead();
        TListItem<DMChord>* pPrevious = NULL;
        TListItem<DMChord>* pChord = new TListItem<DMChord>;
        if (!pChord)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            DMChord& rChord = pChord->GetItemValue();
            rChord = (DMChord) *pChordParam;
            rChord.m_mtTime = mtTime;
            rChord.m_wMeasure = 0;  // what value should this have?
            rChord.m_bBeat = 0;    // what value should this have?
            for(; pChordItem != NULL; pChordItem = pChordItem->GetNext())
            {
                if (pChordItem->GetItemValue().m_mtTime >= mtTime) break;
                pPrevious = pChordItem;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pChord);
                pChord->SetNext(pChordItem);
            }
            else // pChordItem is current head of list
            {
                m_ChordList.AddHead(pChord);
            }
            if (pChordItem && pChordItem->GetItemValue().m_mtTime == mtTime)
            {
                // remove it
                pChord->SetNext(pChordItem->GetNext());
                pChordItem->SetNext(NULL);
                delete pChordItem;
            }
        }
    }
    else
        hr = DMUS_E_SET_UNSUPPORTED;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::IsParamSupported(
                /*[in]*/ REFGUID            rGuid
            )
{
    V_INAME(CChordTrack::IsParamSupported);
    V_REFGUID(rGuid);

    return (rGuid == GUID_ChordParam || rGuid == GUID_RhythmParam) ? S_OK : DMUS_E_TYPE_UNSUPPORTED;
}

// IPersist methods
 HRESULT CChordTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CChordTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicChordTrack;
    return S_OK;
}

// IPersistStream methods
 HRESULT CChordTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CChordTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

    V_INAME(CChordTrack::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF = NULL;
    MMCKINFO    ck;
    MMCKINFO    ckHeader;
    DWORD       cb;
    HRESULT     hr;
    TListItem<DMChord>*   pChord;


    EnterCriticalSection( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF );
    if (!SUCCEEDED(hr))
    {
        goto ON_END;
    }

    ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
    hr = pRIFF->CreateChunk(&ck,MMIO_CREATELIST);
    if (SUCCEEDED(hr))
    {
        DWORD dwRoot = m_bRoot;
        DWORD dwScale = m_dwScalePattern | (dwRoot << 24);
        ckHeader.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
        hr = pRIFF->CreateChunk(&ckHeader, 0);
        if (FAILED(hr))
        {
            goto ON_END;
        }
        hr = pStream->Write( &dwScale, sizeof( dwScale ), &cb );
        if (FAILED(hr))
        {
            goto ON_END;
        }
        hr = pRIFF->Ascend( &ckHeader, 0 );
        if (hr != S_OK)
        {
            goto ON_END;
        }

        for( pChord = m_ChordList.GetHead() ; pChord != NULL ; pChord = pChord->GetNext() )
        {
            hr = pChord->GetItemValue().Save(pRIFF);
            if (FAILED(hr))
            {
                goto ON_END;
            }
        }
        if( pChord == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release( );
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

BOOL Greater(DMChord& Chord1, DMChord& Chord2)
{ 
    if (Chord1.m_wMeasure > Chord2.m_wMeasure)
        return TRUE;
    else if (Chord1.m_wMeasure < Chord2.m_wMeasure)
        return FALSE;
    else // same measure; compare beats
        return Chord1.m_bBeat > Chord2.m_bBeat;
}

BOOL Less(DMChord& Chord1, DMChord& Chord2)
{ 
    if (Chord1.m_wMeasure < Chord2.m_wMeasure)
        return TRUE;
    else if (Chord1.m_wMeasure > Chord2.m_wMeasure)
        return FALSE;
    else // same measure; compare beats
        return Chord1.m_bBeat < Chord2.m_bBeat;
}

HRESULT CChordTrack::Load(LPSTREAM pStream )
{
    V_INAME(CChordTrack::Load);
    V_INTERFACE(pStream);

    long lFileSize = 0;
    DWORD dwChunkSize;
    MMCKINFO        ckMain;
    MMCKINFO        ck;
    memset(&ck, 0, sizeof(ck));
    MMCKINFO        ckHeader;
    IAARIFFStream*  pRIFF = NULL;
//    FOURCC id = 0;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;

    EnterCriticalSection( &m_CriticalSection );
    Clear();
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0)
        {
            lFileSize = ckMain.cksize - 4; // subtract off the list type
            DWORD dwScale;
            DWORD cb;
            if (pRIFF->Descend(&ckHeader, &ckMain, 0) == 0)
            {
                if (ckHeader.ckid == DMUS_FOURCC_CHORDTRACKHEADER_CHUNK )
                {
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= ckHeader.cksize;
                    hr = pStream->Read( &dwScale, sizeof( dwScale ), &cb );
                    if (FAILED(hr) || cb != sizeof( dwScale ) ) 
                    {
                        if (SUCCEEDED(hr)) hr = DMUS_E_CHUNKNOTFOUND;
                        pRIFF->Ascend( &ckHeader, 0 );
                        goto END;
                    }
                    hr = pRIFF->Ascend( &ckHeader, 0 );
                    if (FAILED(hr))
                    {
                        goto END;
                    }
                }
                else
                {
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto END;
                }
            }
            else
            {
                hr = DMUS_E_CHUNKNOTFOUND;
                goto END;
            }
            m_bRoot = (BYTE) (dwScale >> 24);
            if (m_bRoot > 23) m_bRoot %= 24;
            m_dwScalePattern = dwScale & 0xffffff;
            while (lFileSize > 0)
            {
                if (pRIFF->Descend(&ck, &ckMain, 0) == 0)
                {
                    dwChunkSize = ck.cksize;
                    if (ck.ckid == mmioFOURCC('c','r','d','b') )
                    {
                        TListItem<DMChord>* pChord = new TListItem<DMChord>;
                        if (!pChord) break;
                        DMChord& rChord = pChord->GetItemValue();
                        if (FAILED(LoadChordChunk(pStream, rChord))) break;
                        m_ChordList.AddTail(pChord);
                    }
                    // Otherwise, ignore the chunk.
                    // In either case, ascend and subtract off the chunk size
                    if (pRIFF->Ascend( &ck, 0 ) != 0) break;
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= dwChunkSize;
                }
                else break;
            }
            if (lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0)
            {
                hr = S_OK;
                m_ChordList.MergeSort(Less);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
END:
    if (pRIFF) pRIFF->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::LoadChordChunk(LPSTREAM pStream, DMChord& rChord)//, DWORD dwChunkSize)
{
    DWORD           dwChordSize;
    DWORD           dwSubChordSize;
    DWORD           dwSubChordCount;
    DWORD           cb;
    HRESULT         hr;
    DMUS_IO_CHORD       iChord;
    DMUS_IO_SUBCHORD    iSubChord;

    memset(&iChord , 0, sizeof(iChord));
    memset(&iSubChord , 0, sizeof(iSubChord));

    hr = pStream->Read( &dwChordSize, sizeof( dwChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwChordSize ) ) 
    {
        return E_FAIL;
    }
    //dwChunkSize -= 2; // for the size word
    if( dwChordSize <= sizeof( DMUS_IO_CHORD ) )
    {
        pStream->Read( &iChord, dwChordSize, NULL );
    }
    else
    {
        pStream->Read( &iChord, sizeof( DMUS_IO_CHORD ), NULL );
        StreamSeek( pStream, dwChordSize - sizeof( DMUS_IO_CHORD ), STREAM_SEEK_CUR );
    }
    memset( &rChord, 0, sizeof( rChord) );
    rChord.m_strName = iChord.wszName;
    rChord.m_mtTime = iChord.mtTime;
    rChord.m_bBeat = iChord.bBeat;
    rChord.m_wMeasure = iChord.wMeasure;
    rChord.m_bKey = m_bRoot;
    rChord.m_dwScale = m_dwScalePattern;
    rChord.m_fSilent = (iChord.bFlags & DMUS_CHORDKEYF_SILENT) ? true : false;
    hr = pStream->Read( &dwSubChordCount, sizeof( dwSubChordCount ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordCount ) )
    {
        return E_FAIL;
    }
    //wChunkSize -= 2; // for the count word
    hr = pStream->Read( &dwSubChordSize, sizeof( dwSubChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordSize ) )
    {
        return E_FAIL;
    }
    //wChunkSize -= 2; // for the size word
    for (; dwSubChordCount > 0; dwSubChordCount--)
    {
        if( dwSubChordSize <= sizeof( DMUS_IO_SUBCHORD ) )
        {
            pStream->Read( &iSubChord, dwSubChordSize, NULL );
        }
        else
        {
            pStream->Read( &iSubChord, sizeof( DMUS_IO_SUBCHORD ), NULL );
            StreamSeek( pStream, dwSubChordSize - sizeof( DMUS_IO_SUBCHORD ), STREAM_SEEK_CUR );
        }
        TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>;
        if( pSub )
        {
            DMSubChord& rSubChord = pSub->GetItemValue();
            memset( &rSubChord, 0, sizeof( rSubChord) );
            rSubChord.m_dwChordPattern = iSubChord.dwChordPattern;
            rSubChord.m_dwScalePattern = iSubChord.dwScalePattern;
            rSubChord.m_dwInversionPoints = iSubChord.dwInversionPoints;
            rSubChord.m_dwLevels = iSubChord.dwLevels;
            rSubChord.m_bChordRoot = iSubChord.bChordRoot;
            rSubChord.m_bScaleRoot = iSubChord.bScaleRoot;
            rChord.m_SubChordList.AddTail(pSub);
        }
        else 
        {
            return E_FAIL;
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CChordTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_CHORD )
    {
        m_fNotifyChord = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CChordTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CChordTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_CHORD )
    {
        m_fNotifyChord = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CChordTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CChordTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    CChordTrack *pDM;
    
    try
    {
        pDM = new CChordTrack(*this, mtStart, mtEnd);

    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// For consistency with other track types
STDMETHODIMP CChordTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CChordTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CChordTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CChordTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CChordTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CChordTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, pContext, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, pContext, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CChordTrack::JoinInternal(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    WORD wMeasure = 0;
    HRESULT hrTimeSig = S_OK;
    MUSIC_TIME mtTimeSig = 0;
    MUSIC_TIME mtOver = 0;
    IDirectMusicSong* pSong = NULL;
    IDirectMusicSegment* pSegment = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pSegment)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hrTimeSig = E_FAIL;
        }
    }
    while (SUCCEEDED(hrTimeSig) && mtTimeSig < mtJoin)
    {
        DMUS_TIMESIGNATURE TimeSig;
        MUSIC_TIME mtNext = 0;
        if (pSegment)
        {
            hrTimeSig = pSegment->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        else
        {
            hrTimeSig = pSong->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        if (SUCCEEDED(hrTimeSig))
        {
            if (!mtNext) mtNext = mtJoin - mtTimeSig; // means no more time sigs
            DirectMusicTimeSig DMTimeSig = TimeSig;
            WORD wMeasureOffset = (WORD)DMTimeSig.ClocksToMeasure(mtNext + mtOver);
            MUSIC_TIME mtMeasureOffset = (MUSIC_TIME) wMeasureOffset;
            // The following line crashes on certain builds on certain machines.
            // mtOver = mtMeasureOffset ? (mtNext % mtMeasureOffset) : 0;
            if (mtMeasureOffset)
            {
                mtOver = mtNext % mtMeasureOffset;
            }
            else
            {
                mtOver = 0;
            }
            wMeasure += wMeasureOffset;
            mtTimeSig += mtNext;
        }
    }
    CChordTrack* pOtherTrack = (CChordTrack*)pNewTrack;
    TListItem<DMChord>* pScan = pOtherTrack->m_ChordList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        DMChord& rScan = pScan->GetItemValue();
        TListItem<DMChord>* pNew = new TListItem<DMChord>;
        if (pNew)
        {
            DMChord& rNew = pNew->GetItemValue();
            rNew.m_mtTime = rScan.m_mtTime + mtJoin;
            rNew.m_strName = rScan.m_strName;
            rNew.m_wMeasure = rScan.m_wMeasure + wMeasure;
            rNew.m_bBeat = rScan.m_bBeat;
            rNew.m_bKey = rScan.m_bKey;
            rNew.m_dwScale = rScan.m_dwScale;
            TListItem<DMSubChord>* pSubScan = rScan.m_SubChordList.GetHead();
            for(; pSubScan; pSubScan = pSubScan->GetNext())
            {
                DMSubChord& rSubScan = pSubScan->GetItemValue();
                TListItem<DMSubChord>* pSubNew = new TListItem<DMSubChord>;
                if (pSubNew)
                {
                    DMSubChord& rSubNew = pSubNew->GetItemValue();
                    rSubNew.m_dwChordPattern = rSubScan.m_dwChordPattern;
                    rSubNew.m_dwScalePattern = rSubScan.m_dwScalePattern;
                    rSubNew.m_dwInversionPoints = rSubScan.m_dwInversionPoints;
                    rSubNew.m_dwLevels = rSubScan.m_dwLevels;
                    rSubNew.m_bChordRoot = rSubScan.m_bChordRoot;
                    rSubNew.m_bScaleRoot = rSubScan.m_bScaleRoot;
                    rNew.m_SubChordList.AddTail(pSubNew);
                }
            }
            m_ChordList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (pSong) pSong->Release();
    if (pSegment) pSegment->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\chordtrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       chordtrk.h
//
//--------------------------------------------------------------------------

// ChordTrack.h : Declaration of the CChordTrack

#ifndef __CHORDTRACK_H_
#define __CHORDTRACK_H_

#include "dmsect.h"
#include "dmusici.h"

/////////////////////////////////////////////////////////////////////////////
// CChordTrack
class CChordTrack : 
	//public IChordTrack,
	public IDirectMusicTrack8,
	public IPersistStream
{
public:
	CChordTrack();
	CChordTrack(const CChordTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);	
	~CChordTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IChordTrack
public:
// IChordTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);


HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// ChordTrack members
protected:
    long m_cRef;
	TList<DMChord>				m_ChordList;
	BYTE						m_bRoot;			// root of the track's scale
	DWORD						m_dwScalePattern;	// the track's scale pattern
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;

	BYTE						m_bRequiresSave;
	BOOL						m_fNotifyChord;

// protected methods
	void Clear();
	HRESULT SendNotification(REFGUID rguidType,
								MUSIC_TIME mtTime,
								IDirectMusicPerformance*	pPerf,
								IDirectMusicSegmentState*	pSegState,
								DWORD dwFlags);

	HRESULT GetChord(MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, DMUS_CHORD_PARAM* pChordParam);
	HRESULT GetRhythm(MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, DMUS_RHYTHM_PARAM* pRhythmParam);
	HRESULT LoadChordChunk(LPSTREAM pStream, DMChord& rChord);//, DWORD dwChunkSize );
    HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup);

};

#endif //__CHORDTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\audtrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) 1998-2001 Microsoft Corporation
//
//  File:       audtrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// AudTrk.cpp : Implementation of CAuditionTrack
#include "AudTrk.h"
#include "dmusici.h"
#include "debug.h"
#include "..\shared\Validate.h"

//extern IStream* gpTempoStream;

/////////////////////////////////////////////////////////////////////////////
// AuditionTrackState

AuditionTrackState::AuditionTrackState() : 
    m_fTestVariations(TRUE), m_fByGUID(TRUE), m_bVariationLock(0), m_mtSectionOffset(0)
{
    m_pPattern = NULL;
    memset(&m_guidPart, 0, sizeof(m_guidPart));
}

AuditionTrackState::~AuditionTrackState()
{
}

BOOL AuditionTrackState::PlayAsIs()
{
    return m_fTestVariations;
}

DWORD AuditionTrackState::Variations(DirectMusicPartRef& rPartRef, int nPartIndex)
{
    if (m_bVariationLock && rPartRef.m_bVariationLockID == m_bVariationLock)
    {
        TraceI(4, "Variations for locked part\n");
        return m_dwVariation;
    }
    else if ( (m_fByGUID && 
               rPartRef.m_pDMPart && 
               rPartRef.m_dwLogicalPartID == m_dwPart &&
               rPartRef.m_pDMPart->m_guidPartID == m_guidPart) ||
              (!m_fByGUID && rPartRef.m_dwLogicalPartID == m_dwPart) )
    {
        TraceI(4, "Variations for current part\n");
//      return m_pdwVariationMask[wPart] & m_dwVariation;
        return m_dwVariation;
    }
    else
    {
        TraceI(4, "Variations for a different part\n");
        return (m_pVariations[nPartIndex] == 0xff) ? 0 : (1 << m_pVariations[nPartIndex]);
    }
}

HRESULT AuditionTrackState::InitVariationInfo(DWORD dwVariations, DWORD dwPart, REFGUID rGuidPart, BOOL fByGuid)
{
    HRESULT hr = S_OK;
    m_dwVariation = dwVariations;
    m_dwPart = dwPart;
    m_guidPart = rGuidPart;
    m_fByGUID = fByGuid;
    if (!m_pPattern)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else
    {
        if (rGuidPart == GUID_NULL)
        {
            m_bVariationLock = 0;
        }
        else
        {
            TListItem<DirectMusicPartRef>* pPartRef = m_pPattern->m_PartRefList.GetHead();
            for (short i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
                if ((m_fByGUID && rPartRef.m_pDMPart && rPartRef.m_pDMPart->m_guidPartID == m_guidPart) ||
                    (!m_fByGUID && rPartRef.m_dwLogicalPartID == m_dwPart) )
                {
                    m_bVariationLock = rPartRef.m_bVariationLockID;
                }
            }
        }
    }
    return hr;
}

HRESULT AuditionTrackState::Play(
                  MUSIC_TIME                mtStart, 
                  MUSIC_TIME                mtEnd, 
                  MUSIC_TIME                mtOffset,
                  REFERENCE_TIME rtOffset,
                  IDirectMusicPerformance* pPerformance,
                  DWORD                     dwFlags,
                  BOOL fClockTime
            )
{
    TraceI(4, "Play [%d:%d @ %d]\n", mtStart, mtEnd, mtOffset);
    m_mtPerformanceOffset = mtOffset;
    BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
    BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    if (fControl) // We need to make sure we get chords on beat boundaries
    {
        GetNextChord(mtStart, mtOffset, pPerformance, fStart);
    }
    MUSIC_TIME mtNotify = mtStart ? PatternTimeSig().CeilingBeat(mtStart) : 0;
    if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat && !fClockTime &&
        ( mtNotify < mtEnd ) )
    {
        mtNotify = NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
    }
    bool fReLoop = false;

    MUSIC_TIME mtPatternLength = PatternTimeSig().ClocksPerMeasure() * m_pPattern->m_wNumMeasures;
    if ( (fLoop || fStart) && mtPatternLength )
    {
        m_mtSectionOffset = mtStart - (mtStart % mtPatternLength);
    }
    MUSIC_TIME mtLast = m_mtSectionOffset + mtPatternLength;
    MUSIC_TIME mtPartLast = min(mtEnd, mtLast);
    DWORD dwPartFlags = PLAYPARTSF_FIRST_CALL;
    if (fStart || fLoop || fSeek) dwPartFlags |= PLAYPARTSF_START;
    if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
    if ( fLoop || (mtStart > 0 &&  (fStart || fSeek || fControl)) ) dwPartFlags |= PLAYPARTSF_FLUSH;
    PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);

    if (fReLoop)
    {
        dwPartFlags = PLAYPARTSF_RELOOP;
        if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
        PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
    }

    // If we need to reset the section offset, we do it after all the events in all the parts
    // have run. And then we need to run all events from pattern start to mtEnd.
    if (mtStart <= mtLast && mtLast < mtEnd)
    {
        m_mtSectionOffset = mtLast;
        InitPattern(m_pPattern, m_mtSectionOffset);
        dwPartFlags = 0;
        if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
        PlayParts(mtStart, mtEnd, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
    }

    if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat &&  !fClockTime &&
        ( mtNotify < mtEnd ) )
    {
        NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// AuditionTrackInfo

AuditionTrackInfo::AuditionTrackInfo() : 
    m_pPattern(NULL), m_pdwVariations(NULL), m_dwVariations(0), m_dwPart(0), m_fByGUID(TRUE)
{
    m_dwPatternTag = DMUS_PATTERN_AUDITION;
    memset(&m_guidPart, 0, sizeof(m_guidPart));
}

AuditionTrackInfo::~AuditionTrackInfo()
{
    if (m_pPattern) m_pPattern->Release();
    if (m_pdwVariations) delete [] m_pdwVariations;
}

HRESULT AuditionTrackInfo::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT AuditionTrackInfo::InitPlay(
                /*[in]*/  IDirectMusicTrack*        pParentrack,
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    if (!m_pPattern) return E_POINTER;
    IDirectMusicSegment* pSegment = NULL;
    AuditionTrackState* pStateData = new AuditionTrackState;
    if( NULL == pStateData )
    {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = S_OK;
//  hr = InitTrackVariations();
//  if (FAILED(hr)) return hr;
    pStateData->m_dwValidate = m_dwValidate;
    *ppStateData = pStateData;
    StatePair SP(pSegmentState, pStateData);
    TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
    if (!pPair) return E_OUTOFMEMORY;
    m_StateList.AddHead(pPair);
    TListItem<StylePair>* pHead = m_pISList.GetHead();
    if (!pHead || !pHead->GetItemValue().m_pStyle) return E_FAIL;
    pHead->GetItemValue().m_pStyle->GetStyleInfo((void **)&pStateData->m_pStyle);
    pStateData->m_pTrack = pParentrack;
    pStateData->m_pPatternTrack = this;
    pStateData->m_dwVirtualTrackID = dwTrackID; 
    pStateData->m_pPattern = NULL;
    pStateData->InitPattern(m_pPattern, 0);
    pStateData->InitVariationInfo(m_dwVariations, m_dwPart, m_guidPart, m_fByGUID);
    pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
    pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
    pStateData->m_mtPerformanceOffset = 0;
    pStateData->m_mtNextChordTime = 0;
    pStateData->m_mtCurrentChordTime = 0;
    hr = pStateData->ResetMappings();
    if (FAILED(hr)) return hr;
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fStateActive = m_fActive;
    }
    else
    {
        pStateData->m_fStateActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
    if (m_lRandomNumberSeed)
    {
        pStateData->InitVariationSeeds(m_lRandomNumberSeed);
    }
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        if (FAILED(pSegment->GetTrackGroup(pStateData->m_pTrack, &pStateData->m_dwGroupID)))
        {
            pStateData->m_dwGroupID = 0xffffffff;
        }
        pSegment->Release();
    }
    return S_OK;
}

HRESULT AuditionTrackInfo::InitTrackVariations()
{
    // Do the PatternTrackInfo initialization
    PatternTrackInfo::InitTrackVariations(m_pPattern);
    // init the part's variation array
    if (m_pdwVariations)
    {
        delete [] m_pdwVariations;
        m_pdwVariations = NULL;
    }
    m_pdwVariations = new DWORD[m_pPattern->m_PartRefList.GetCount()];
    if (!m_pdwVariations) return E_OUTOFMEMORY;
    TListItem<DirectMusicPartRef>* pPartRef = m_pPattern->m_PartRefList.GetHead();
    for (short i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
        DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
        m_pdwVariations[i] = 0;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CAuditionTrack

CAuditionTrack::CAuditionTrack() : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    m_pTrackInfo = new AuditionTrackInfo;
}

CAuditionTrack::CAuditionTrack(
        const CAuditionTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    m_pTrackInfo = new AuditionTrackInfo((AuditionTrackInfo*)rTrack.m_pTrackInfo, mtStart, mtEnd);
}

CAuditionTrack::~CAuditionTrack()
{
    if (m_pTrackInfo)
    {
        delete m_pTrackInfo;
    }
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CAuditionTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CAuditionTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicPatternTrack)
    {
        *ppv = static_cast<IDirectMusicPatternTrack*>(this);
    }
    else if (iid == IID_IAuditionTrack) // dx7 private interface
    {
        *ppv = static_cast<IAuditionTrack*>(this);
    }
    else if (iid == IID_IPrivatePatternTrack)
    {
        *ppv = static_cast<IPrivatePatternTrack*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CAuditionTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CAuditionTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init

HRESULT CAuditionTrack::Init( 
    /* [in] */ IDirectMusicSegment __RPC_FAR *pSegment)
{
    V_INAME(CAuditionTrack::Init);
    V_INTERFACE(pSegment);

    HRESULT hr = S_OK;
    if (m_pTrackInfo == NULL)
        return DMUS_E_NOT_INIT;

    EnterCriticalSection( &m_CriticalSection );
    hr = m_pTrackInfo->MergePChannels();
    if (SUCCEEDED(hr))
    {
        pSegment->SetPChannelsUsed(m_pTrackInfo->m_dwPChannels, m_pTrackInfo->m_pdwPChannels);
        hr = m_pTrackInfo->Init(pSegment);
    }
    LeaveCriticalSection( &m_CriticalSection );

    return hr;
}

HRESULT CAuditionTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    V_INAME(CAuditionTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    EnterCriticalSection( &m_CriticalSection );
    HRESULT hr = S_OK;
    if (m_pTrackInfo == NULL)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    hr = m_pTrackInfo->InitPlay(this, pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}


HRESULT CAuditionTrack::EndPlay(
                /*[in]*/  void*     pStateData
            )
{
    V_INAME(CAuditionTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(AuditionTrackState));

    HRESULT hr = DMUS_E_NOT_INIT;
    EnterCriticalSection( &m_CriticalSection );
    if (m_pTrackInfo)
    {
        hr = m_pTrackInfo->EndPlay((AuditionTrackState*)pStateData);
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          REFERENCE_TIME rtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID,
                          BOOL fClockTime
                )
{
    V_INAME(CAuditionTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(AuditionTrackState));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegState);

    HRESULT hr = DMUS_E_NOT_INIT;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo || m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }

    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    AuditionTrackState* pSD = (AuditionTrackState *)pStateData;

    if (pSD->m_dwValidate != m_pTrackInfo->m_dwValidate)
    {
        // new style inserted in track via Load.  Resync state data.
        MUSIC_TIME mtNext = 0;
        pSD->m_pStyle = pSD->FindStyle(mtStart, mtNext);
        if (!pSD->m_pStyle)
        {
            hr = E_POINTER;
        }
        pSD->InitPattern(pTrackInfo->m_pPattern, 0);
        pSD->m_dwValidate = m_pTrackInfo->m_dwValidate;
    }
    if (pSD && pSD->m_pMappings)
    {
        BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
        BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
        BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
        BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
        if (fStart || fSeek || fLoop || fControl)
        {
            if (pSD->m_fStateActive && !fClockTime) // if timesig events are enabled and using music time...
            {
                pSD->SendTimeSigMessage(mtStart, mtOffset, 0, pPerf);
            }
            pSD->m_fNewPattern = TRUE;
            pSD->m_mtCurrentChordTime = 0;
            pSD->m_mtNextChordTime = 0;
            pSD->m_mtLaterChordTime = 0;
//          pSD->m_CurrentChord.bSubChordCount = 0;
            for (DWORD dw = 0; dw < m_pTrackInfo->m_dwPChannels; dw++)
            {
                pSD->m_pMappings[dw].m_mtTime = 0;
                pSD->m_pMappings[dw].m_dwPChannelMap = m_pTrackInfo->m_pdwPChannels[dw];
                pSD->m_pMappings[dw].m_fMute = FALSE;
            }
        }
        hr = pSD->Play(mtStart, mtEnd, mtOffset, rtOffset, pPerf, dwFlags, fClockTime);
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}


HRESULT CAuditionTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
{
    return E_NOTIMPL;
}

HRESULT CAuditionTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void * pStateData,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(CAuditionTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData,1);
    V_PTR_WRITE_OPT(pStateData,1);
    V_REFGUID(rCommandGuid);

    EnterCriticalSection( &m_CriticalSection );
    HRESULT hr = S_OK;
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    if( GUID_Valid_Start_Time == rCommandGuid )
    {
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION) hr = DMUS_E_NOT_INIT;
        else
        {
            AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
            if (!pTrackInfo->m_pPattern) hr = E_POINTER;
            else
            {
                DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
                TListItem<MUSIC_TIME>* pScan = pTrackInfo->m_pPattern->m_StartTimeList.GetHead();
                for (; pScan; pScan = pScan->GetNext())
                {
                    if (pScan->GetItemValue() >= mtTime)
                    {
                        pValidStartData->mtTime = pScan->GetItemValue() - mtTime;
                        break;
                    }
                }
                if (!pScan) hr = DMUS_E_NOT_FOUND;
                else
                {
                    if (pmtNext)
                    {
                        if (pScan = pScan->GetNext())
                        {
                            *pmtNext = pScan->GetItemValue() - mtTime;
                        }
                        else
                        {
                            *pmtNext = 0;
                        }
                    }
                    hr = S_OK;
                }
            }
        }
    }
    else if ( GUID_Variations == rCommandGuid )
    {
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION) hr = DMUS_E_NOT_INIT;
        else
        {
            AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
            if (!pTrackInfo->m_pPattern) hr = E_POINTER;
            else
            {
                if (pStateData)
                {
                    AuditionTrackState* pSD = (AuditionTrackState*)pStateData;
                    DMUS_VARIATIONS_PARAM* pParam = (DMUS_VARIATIONS_PARAM*)pData;
                    if (!pSD->m_pPattern) hr = E_POINTER;
                    else
                    {
                        pParam->dwPChannelsUsed = pSD->m_pPattern->m_PartRefList.GetCount();
                        pParam->padwPChannels = pSD->m_pdwPChannels;
                        TListItem<DirectMusicPartRef>* pPartRef = pTrackInfo->m_pPattern->m_PartRefList.GetHead();
                        for (short i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
                        {
                            DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
                            pTrackInfo->m_pdwVariations[i] = pSD->Variations(rPartRef, i);
                        }
                        pParam->padwVariations = pTrackInfo->m_pdwVariations;
                        if (pmtNext)
                        {
                            DirectMusicTimeSig& TimeSig = pTrackInfo->m_pPattern->m_timeSig;
                            MUSIC_TIME mtToNextChord = !pSD->m_mtNextChordTime ? 0 : pSD->m_mtNextChordTime - mtTime;
                            MUSIC_TIME mtPatternClocks = pTrackInfo->m_pPattern->m_wNumMeasures * TimeSig.ClocksPerMeasure();
                            if (!mtToNextChord || mtToNextChord > mtPatternClocks)
                            {
                                *pmtNext = mtPatternClocks;
                            }
                            else
                            {
                                *pmtNext = mtToNextChord;
                            }
                        }
                    }
                }
                else
                {
                    hr = E_POINTER;
                }
            }
        }
    }
    else if (rCommandGuid == GUID_IDirectMusicPatternStyle)
    {
        if (m_pTrackInfo)
        {
            TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
            if (pScan)
            {
                IDirectMusicStyle* pDMStyle = NULL;
                IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
                if (!pStyle) 
                {
                    hr = E_POINTER;
                }
                else
                {
                    pStyle->QueryInterface(IID_IDirectMusicStyle, (void**)&pDMStyle);
                    // Note: QI with no Release has the effect of an AddRef
                    *(IDirectMusicStyle**)pData = pDMStyle;
                    if (pmtNext)
                    {
                        *pmtNext = 0;
                    }
                    hr = S_OK;
                }
            }
            else hr = DMUS_E_NOT_FOUND;
        }
        else hr = DMUS_E_NOT_INIT;
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
} 

HRESULT CAuditionTrack::SetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CAuditionTrack::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguid);

    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }

    HRESULT hr = DMUS_E_SET_UNSUPPORTED;
    if( rguid == GUID_EnableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_DisableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && !m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = FALSE;
            hr = S_OK;
        }
    }
    else if ( rguid == GUID_SeedVariations )
    {
        if (pData)
        {
            m_pTrackInfo->m_lRandomNumberSeed = *((long*) pData);
            hr = S_OK;
        }
        else hr = E_POINTER;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CAuditionTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CAuditionTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 

    *pClassID = CLSID_DirectMusicAuditionTrack;
    return S_OK;
}

HRESULT CAuditionTrack::IsParamSupported(
                /*[in]*/ REFGUID            rGuid
            )
{
    V_INAME(CAuditionTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (!m_pTrackInfo)
    {
        return DMUS_E_NOT_INIT;
    }

    if ( rGuid == GUID_SeedVariations || 
         rGuid == GUID_Valid_Start_Time ||
         rGuid == GUID_Variations ||
         rGuid == GUID_IDirectMusicPatternStyle)
    {
        return S_OK;
    }
    else if (m_pTrackInfo->m_fStateSetBySetParam)
    {
        if( m_pTrackInfo->m_fActive )
        {
            if( rGuid == GUID_DisableTimeSig ) return S_OK;
            if( rGuid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( rGuid == GUID_EnableTimeSig ) return S_OK;
            if( rGuid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
        }
    }
    else
    {
        if(( rGuid == GUID_DisableTimeSig ) ||
           ( rGuid == GUID_EnableTimeSig ) )
        {
            return S_OK;
        }
    }
    return DMUS_E_TYPE_UNSUPPORTED;

}

// IPersistStream methods
 HRESULT CAuditionTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

// Saves the track's pattern in single pattern format
HRESULT CAuditionTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

    V_INAME(CAuditionTrack::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF = NULL;
    MMCKINFO    ckRiff;
    MMCKINFO    ckPattern;
    HRESULT     hr = S_OK;
    AuditionTrackInfo* pTrackInfo = NULL;

    EnterCriticalSection( &m_CriticalSection );

    if (!m_pTrackInfo)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else
    {
        pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION ||
            !pTrackInfo->m_pPattern)
        {
            hr = DMUS_E_NOT_INIT;
        }
    }

    if ( SUCCEEDED(hr) && SUCCEEDED(hr = AllocRIFFStream( pStream, &pRIFF )) )
    {
        ckRiff.fccType = DMUS_FOURCC_PATTERN_FORM;
        hr = pRIFF->CreateChunk(&ckRiff,MMIO_CREATERIFF);
        if (SUCCEEDED(hr))
        {
            ckPattern.fccType = DMUS_FOURCC_PATTERN_LIST;
            hr = pRIFF->CreateChunk( &ckPattern, MMIO_CREATELIST );
            if (SUCCEEDED(hr))
            {
                hr =  pTrackInfo->m_pPattern->DM_SaveSinglePattern( pRIFF );
                if (SUCCEEDED(hr))
                {
                    pRIFF->Ascend(&ckPattern, 0);
                    pRIFF->Ascend(&ckRiff, 0);
                }
            }
        }
        pRIFF->Release();
    }

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CAuditionTrack::Load(LPSTREAM pIStream )
{
    DWORD dwPos;
    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT         hr = E_FAIL;
    bool fAdded = false;

    if( pIStream == NULL )
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    pTrackInfo->m_pISList.CleanUp();
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    dwPos = StreamTell( pIStream );

    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_PATTERN_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            IDMStyle* pINewStyle = NULL;
            hr = ::CoCreateInstance(
                CLSID_DirectMusicStyle,
                NULL,
                CLSCTX_INPROC, 
                IID_IDMStyle,
                (void**)&pINewStyle
            );
            if (SUCCEEDED(hr))
            {
                DMStyleStruct* pNewStyle;
                pINewStyle->GetStyleInfo((void**)&pNewStyle);
                memset(pNewStyle, 0, sizeof(DMStyleStruct));
                hr = LoadPattern(pIRiffStream, &ckMain, pNewStyle);
                if (SUCCEEDED(hr))
                {
                    pNew->GetItemValue().m_mtTime = 0;
                    pNew->GetItemValue().m_pStyle = pINewStyle;
                    pTrackInfo->m_pISList.AddTail(pNew);
                    fAdded = true;
                }
            }
        }
        pIRiffStream->Release();
        pIRiffStream = NULL;
    }
    if (!fAdded) delete pNew;

    m_pTrackInfo->m_dwValidate++;

    hr = m_pTrackInfo->MergePChannels();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::LoadPattern(IAARIFFStream* pIRiffStream,  MMCKINFO* pckMain, DMStyleStruct* pNewStyle)
{
    IStream*      pIStream;
    MMCKINFO      ck;
    MMCKINFO      ckList;
    DWORD         dwByteCount;
    DWORD         dwSize;
    DWORD         dwPos;
    HRESULT       hr = S_OK;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_STYLE_CHUNK:
            {
                DMUS_IO_STYLE iDMStyle;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLE ) );
                hr = pIStream->Read( &iDMStyle, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                pNewStyle->m_TimeSignature.m_bBeatsPerMeasure = iDMStyle.timeSig.bBeatsPerMeasure;
                pNewStyle->m_TimeSignature.m_bBeat = iDMStyle.timeSig.bBeat;
                pNewStyle->m_TimeSignature.m_wGridsPerBeat = iDMStyle.timeSig.wGridsPerBeat;
                pNewStyle->m_dblTempo = iDMStyle.dblTempo;
                break;
            }

            case FOURCC_RIFF:
            case FOURCC_LIST:
                switch( ck.fccType )
                {

                case DMUS_FOURCC_PATTERN_LIST:
                        StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
                        CDirectMusicPattern* pPattern = 
                            new CDirectMusicPattern( &pNewStyle->m_TimeSignature, FALSE );
                        if( pPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        ckList.fccType = DMUS_FOURCC_PATTERN_LIST;
                        // Allow this to succeed whether the pattern chunk is
                        // in a RIFF chunk or a LIST chunk.
                        if( (ck.ckid == FOURCC_LIST && pIRiffStream->Descend( &ckList, NULL, MMIO_FINDLIST ) != 0) ||
                            (ck.ckid == FOURCC_RIFF && pIRiffStream->Descend( &ckList, NULL, MMIO_FINDRIFF ) != 0) )
                        {
                            hr = E_FAIL;
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        hr = pPattern->DM_LoadPattern( pIRiffStream, &ckList, pNewStyle );
                        pIRiffStream->Ascend( &ckList, 0 );
                        if( FAILED( hr ) )
                        {
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
                        if (pTrackInfo->m_pPattern) pTrackInfo->m_pPattern->Release();
                        pTrackInfo->m_pPattern = pPattern;
                        pTrackInfo->InitTrackVariations();
                        break;
                }
                break;

        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

// Creates a segment containing an audition track with a style based on pStyle.
// Also creates a Tempo track, based on the pattern's tempo.  Other tracks
// (e.g. chord and band tracks) must be added to the segment separately.
// NOTE: might want to consider having a MUSIC_TIME parm here, so I can select
// a style.
HRESULT CAuditionTrack::CreateSegment(
            IDirectMusicStyle* pStyle, IDirectMusicSegment** ppSegment)
{
    V_INAME(IDirectMusicPatternTrack::CreateSegment);
    V_INTERFACE(pStyle);
    V_PTRPTR_WRITE(ppSegment);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }
    // 1. Give the track a style based on the one passed in (but with no patterns)
    IDMStyle* pIS = NULL;
    hr = pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
    if (SUCCEEDED(hr))
    {
        IDMStyle* pINewStyle = NULL;
        hr = ::CoCreateInstance(
            CLSID_DirectMusicStyle,
            NULL,
            CLSCTX_INPROC, 
            IID_IDMStyle,
            (void**)&pINewStyle
        );
        if (SUCCEEDED(hr))
        {

            DMStyleStruct* pOldStyle;
            DMStyleStruct* pNewStyle;
            pIS->GetStyleInfo((void**)&pOldStyle);
            pINewStyle->GetStyleInfo((void**)&pNewStyle);
            pNewStyle->m_guid = pOldStyle->m_guid;
            pNewStyle->m_strCategory = pOldStyle->m_strCategory;
            pNewStyle->m_strName = pOldStyle->m_strName;
            pNewStyle->m_dwVersionMS = pOldStyle->m_dwVersionMS;
            pNewStyle->m_dwVersionLS = pOldStyle->m_dwVersionLS;
            pNewStyle->m_TimeSignature = pOldStyle->m_TimeSignature;
            pNewStyle->m_dblTempo = pOldStyle->m_dblTempo;

            // Don't worry about bands and personalities...
            pNewStyle->m_pDefaultBand = NULL;
            pNewStyle->m_pDefaultPers = NULL;
            pNew->GetItemValue().m_mtTime = 0;
            pNew->GetItemValue().m_pStyle = pINewStyle;
            TListItem<DWORD>* pScan = pOldStyle->m_PChannelList.GetHead();
            for (; pScan; pScan = pScan->GetNext() )
            {
                TListItem<DWORD>* pdwItem = new TListItem<DWORD>(pScan->GetItemValue());
                if (!pdwItem) 
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pNewStyle->m_PChannelList.AddHead(pdwItem);
                }
            }
            if (SUCCEEDED(hr))
            {
                pTrackInfo->m_pISList.AddTail(pNew);
                // 2. Create a Tempo Track in which to store the tempo events
                //////////////////////////////////////////////////////////
                DMUS_TEMPO_PARAM tempo;
                tempo.mtTime = 0; 
                tempo.dblTempo = (double) pNewStyle->m_dblTempo; 
                //////////////////////////////////////////////////////////
                //IPersistStream* pIPSTrack;
                IDirectMusicTrack*  pDMTrack = NULL;
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
                    NULL, CLSCTX_INPROC, IID_IDirectMusicTrack,
                    (void**)&pDMTrack )))
                {
                    GUID Guid = GUID_TempoParam;
                    if (!SUCCEEDED(pDMTrack->SetParam(Guid, 0, &tempo)))
                    {
                        pDMTrack = NULL;
                    }
                }
                // 3. Create a segment.
                IDirectMusicSegment *pISegment;
                hr = ::CoCreateInstance(
                    CLSID_DirectMusicSegment,
                    NULL,
                    CLSCTX_INPROC, 
                    IID_IDirectMusicSegment,
                    (void**)&pISegment
                    );
                if (SUCCEEDED(hr) )
                {
                    // 4. Initialize the segment appropriately.
                    DirectMusicTimeSig& TimeSig = pNewStyle->m_TimeSignature;
                    pISegment->SetLength(TimeSig.ClocksPerMeasure()); // default to a length of 1 measure
                    pISegment->SetDefaultResolution(0);
                    pISegment->InsertTrack(this, 1);
                    if (pDMTrack)
                    {
                        pISegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    hr = S_OK;
                    *ppSegment = pISegment;
                }
            }
        }
        pIS->Release();
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// Sets the pattern for a track, given a style, the name of a pattern
// within the style, and the pattern's type (regular pattern/motif/fragment).
HRESULT CAuditionTrack::SetPatternByName(IDirectMusicSegmentState* pSegState, 
                                        WCHAR* wszName,
                                        IDirectMusicStyle* pStyle,
                                        DWORD dwPatternType,
                                        DWORD* pdwLength)
{
    V_INAME(IDirectMusicPatternTrack::SetPatternByName);
    V_INTERFACE_OPT(pSegState);
    V_PTR_READ(wszName, 1);
    V_INTERFACE(pStyle);
    V_PTR_WRITE(pdwLength, DWORD);

    HRESULT hr = S_OK;
    IDMStyle* pDMStyle = NULL;
    IStream* pStream = NULL;

    hr = pStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle);
    if (SUCCEEDED(hr))
    {
        hr = pDMStyle->GetPatternStream(wszName, dwPatternType, &pStream);
        if (S_OK == hr)
        {
            hr = SetPattern(pSegState, pStream, pdwLength);
            pStream->Release();
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
        }
        pDMStyle->Release();
    }

    return hr;
}
    
// Sets the pattern for a track.  The pattern is read from pStream.
// IMPORTANT: Calling SetPattern could change the pattern's PartRef guid, which would make 
// Variations cease to work.  therefore, it's a good idea to call SetVariation after
// caling SetPattern.
HRESULT CAuditionTrack::SetPattern(IDirectMusicSegmentState* pSegState, IStream* pStream, DWORD* pdwLength)
{
    IAARIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = DMUS_E_NOT_INIT;
    CDirectMusicPattern* pOldPattern = NULL;

    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else
    {
        DMStyleStruct* pStyle = NULL;
        IDMStyle* pIS = NULL;
        TListItem<StylePair>* pStyleItem = NULL;

        PatternTrackState* pPatternState = m_pTrackInfo->FindState(pSegState);
        AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
        {
            goto ON_END;
        }
        pStyleItem = pTrackInfo->m_pISList.GetHead();
        if (!pStyleItem)
        {
            goto ON_END;
        }
        pIS = pStyleItem->GetItemValue().m_pStyle;
        if (!pIS) goto ON_END;
        pIS->GetStyleInfo((void**)&pStyle);
        // 1. Set up the track's pattern.
        if (pTrackInfo->m_pPattern)
        {
            pOldPattern = pTrackInfo->m_pPattern;
        }
        pTrackInfo->m_pPattern = new CDirectMusicPattern( &pStyle->m_TimeSignature, FALSE );
        if( pTrackInfo->m_pPattern == NULL )
        {
            hr = E_OUTOFMEMORY ;
            goto ON_END;
        }
        // 2. Load the pattern in single Pattern format
        StreamSeek(pStream, 0, STREAM_SEEK_SET);
        if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
        {
            ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

            if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
            {
                hr = pTrackInfo->m_pPattern->DM_LoadPattern( pIRiffStream, &ckMain, pStyle );
                if (SUCCEEDED(hr))
                {
                    DirectMusicTimeSig& TimeSig = 
                        pTrackInfo->m_pPattern->m_timeSig.m_bBeat == 0 ? 
                        pStyle->m_TimeSignature : 
                        pTrackInfo->m_pPattern->m_timeSig;
                    *pdwLength = pTrackInfo->m_pPattern->m_wNumMeasures * TimeSig.ClocksPerMeasure();
                }
            }
            pIRiffStream->Release();

            hr = pTrackInfo->InitTrackVariations();
            // Set up the new pattern.
            if (pPatternState)
            {
                pPatternState->InitPattern(pTrackInfo->m_pPattern, 0, pOldPattern);
            }
            if (SUCCEEDED(hr))
            {
                // merge PChannels
                hr = m_pTrackInfo->MergePChannels();
            }
        }
    }

ON_END:
    if (pOldPattern) pOldPattern->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
HRESULT CAuditionTrack::SetVariation(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart)
{
    V_INAME(IDirectMusicPatternTrack::SetVariation);
    V_INTERFACE_OPT(pSegState);

    HRESULT hr = DMUS_E_NOT_INIT;
    PatternTrackState* pPatternState = NULL;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        goto ON_END;
    }
    pTrackInfo->m_dwVariations = dwVariationFlags;
    pTrackInfo->m_dwPart = dwPart;
    pTrackInfo->m_fByGUID = FALSE;
    pPatternState = m_pTrackInfo->FindState(pSegState);
    if (pPatternState)
    {
        AuditionTrackState* pState = (AuditionTrackState*)pPatternState;
        GUID guidPart;
        memset(&guidPart, 0, sizeof(guidPart));
        pState->InitVariationInfo(dwVariationFlags, dwPart, guidPart, FALSE);
    }
    hr = S_OK;
ON_END:
    LeaveCriticalSection( &m_CriticalSection );

    return hr;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
HRESULT CAuditionTrack::SetVariationByGUID(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, REFGUID rguidPart, DWORD dwPChannel)
{
    HRESULT hr = DMUS_E_NOT_INIT;
    PatternTrackState* pPatternState = NULL;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        goto ON_END;
    }
    pTrackInfo->m_dwVariations = dwVariationFlags;
    pTrackInfo->m_guidPart = rguidPart;
    pTrackInfo->m_dwPart = dwPChannel;
    pTrackInfo->m_fByGUID = TRUE;
    pPatternState = m_pTrackInfo->FindState(pSegState);
    if (pPatternState)
    {
        AuditionTrackState* pState = (AuditionTrackState*)pPatternState;
        pState->InitVariationInfo(dwVariationFlags, dwPChannel, rguidPart, TRUE);
    }
    hr = S_OK;
ON_END:
    LeaveCriticalSection( &m_CriticalSection );

    return hr;
}


HRESULT STDMETHODCALLTYPE CAuditionTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CAuditionTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->AddNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CAuditionTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CAuditionTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->RemoveNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CAuditionTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CAuditionTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;
    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );

    CAuditionTrack *pDM;
    
    try
    {
        pDM = new CAuditionTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    return GetParam(rCommandGuid, mtTime, NULL, pmtNext, pData);
}

STDMETHODIMP CAuditionTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext = 0;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), pStateData, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, pStateData, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CAuditionTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

STDMETHODIMP CAuditionTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CAuditionTrack::Play( 
    void *pStateData,   // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart, // @parm The start time to play.
    MUSIC_TIME mtEnd,   // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,      // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf, // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,   // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID   // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CAuditionTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CAuditionTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\cmmdtrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       cmmdtrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// CommandTrack.cpp : Implementation of CCommandTrack
#include <objbase.h>
#include "CmmdTrk.h"
#include "debug.h"
#include "debug.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CCommandTrack

CCommandTrack::CCommandTrack() : m_bRequiresSave(0),
    m_cRef(1), m_fNotifyCommand(FALSE), m_fCSInitialized(FALSE), m_pNextCommand(NULL)

{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

// it is assumed that cloning of commands will only happen on measure boundaries
CCommandTrack::CCommandTrack(const CCommandTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
    m_bRequiresSave(0),
    m_cRef(1), m_fNotifyCommand(rTrack.m_fNotifyCommand),
    m_fCSInitialized(FALSE), m_pNextCommand(NULL)

{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    WORD wMeasure = 0;
    BOOL fStarted = FALSE;
    TListItem<DMCommand>* pScan = rTrack.m_CommandList.GetHead();
    TListItem<DMCommand>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMCommand& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (!fStarted)
            {
                fStarted = TRUE;
                wMeasure = rScan.m_wMeasure;
            }
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            TListItem<DMCommand>* pNew = new TListItem<DMCommand>;
            if (pNew)
            {
                DMCommand& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_wMeasure = rScan.m_wMeasure - wMeasure;
                rNew.m_bBeat = rScan.m_bBeat;
                rNew.m_bCommand = rScan.m_bCommand;
                rNew.m_bGrooveLevel = rScan.m_bGrooveLevel;
                rNew.m_bGrooveRange = rScan.m_bGrooveRange;
                rNew.m_bRepeatMode = rScan.m_bRepeatMode;
                m_CommandList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        TListItem<DMCommand>* pNew = new TListItem<DMCommand>;
        if (pNew)
        {
            DMCommand& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_wMeasure = 0;
            rNew.m_bBeat = 0;
            // Since embellishments are only supposed to last for a bar,
            // start the new segment with a regular groove.
            rNew.m_bCommand = DMUS_COMMANDT_GROOVE;
            // Keep the groove level and range of the previous bar.
            rNew.m_bGrooveLevel = pPrevious->GetItemValue().m_bGrooveLevel;
            rNew.m_bGrooveRange = pPrevious->GetItemValue().m_bGrooveRange;
            // Default to random selection of the pattern.
            rNew.m_bRepeatMode = DMUS_PATTERNT_RANDOM;
            m_CommandList.AddHead(pNew);
        }
    }
}

CCommandTrack::~CCommandTrack()
{
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    if (m_pNextCommand)
    {
        delete m_pNextCommand;
    }
    InterlockedDecrement(&g_cComponent);
}

void CCommandTrack::Clear()
{
    m_CommandList.CleanUp();
}


STDMETHODIMP CCommandTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CCommandTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CCommandTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CCommandTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


// CCommandTrack Methods
HRESULT CCommandTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    V_INAME(CCommandTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

HRESULT CCommandTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    HRESULT hr = S_OK;
    CommandStateData* pStateData;
    EnterCriticalSection( &m_CriticalSection );
    pStateData = new CommandStateData;
    if( NULL == pStateData )
    {
        hr =  E_OUTOFMEMORY;
    }
    else
    {
        *pStateData = 0;
        *ppStateData = pStateData;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CCommandTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(CommandStateData));
        CommandStateData* pSD = (CommandStateData*)pStateData;
        delete pSD;
    }
    if (m_pNextCommand) delete m_pNextCommand;
    m_pNextCommand = NULL;
    return S_OK;
}

HRESULT CCommandTrack::SendNotification(DWORD dwCommand, 
                                        MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (dwFlags & DMUS_TRACKF_NOTIFY_OFF)
    {
        return S_OK;
    }
    IDirectMusicSegment* pSegment = NULL;
    DWORD dwOption = DMUS_NOTIFICATION_GROOVE;
    if (dwCommand != DMUS_COMMANDT_GROOVE)
    {
        dwOption = DMUS_NOTIFICATION_EMBELLISHMENT;
    }
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = dwOption;
        pEvent->guidNotificationType = GUID_NOTIFICATION_COMMAND;

        if( SUCCEEDED( pSegState->GetSegment(&pSegment)))
        {
            if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
            {
                pEvent->dwGroupID = 0xffffffff;
            }
            pSegment->Release();
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            pGraph->StampPMsg((DMUS_PMSG*) pEvent );
            pGraph->Release();
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}


HRESULT CCommandTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    bool fNotifyPastCommand = false;
    TListItem<DMCommand>* pLastCommand = NULL;
    // If we're seeking and not flushing, we need to notify for the command that happens
    // before the current start time (if there is one)
    if ( (dwFlags & DMUS_TRACKF_SEEK) && !(dwFlags & DMUS_TRACKF_FLUSH) )
    {
        fNotifyPastCommand = true;
    }
    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (m_fNotifyCommand)
    {
        TListItem<DMCommand>* pCommand = m_CommandList.GetHead();
        for(; pCommand && SUCCEEDED(hr); pCommand = pCommand->GetNext())
        {
            MUSIC_TIME mtCommandTime = pCommand->GetItemValue().m_mtTime;
            if (mtCommandTime < mtStart && fNotifyPastCommand)
            {
                pLastCommand = pCommand;
            }
            else if (mtStart <= mtCommandTime && mtCommandTime < mtEnd)
            {
                if (pLastCommand)
                {
                    hr = SendNotification(pLastCommand->GetItemValue().m_bCommand, 
                            mtStart + mtOffset, pPerf, pSegState, dwFlags);
                    pLastCommand = NULL;
                }
                if (SUCCEEDED(hr))
                {
                    hr = SendNotification(pCommand->GetItemValue().m_bCommand, 
                            mtCommandTime + mtOffset, pPerf, pSegState, dwFlags);
                }
            }
            else if (mtCommandTime >= mtEnd)
            {
                if (pLastCommand)
                {
                    hr = SendNotification(pLastCommand->GetItemValue().m_bCommand, 
                            mtStart + mtOffset, pPerf, pSegState, dwFlags);
                }
                break;
            }
        }
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CCommandTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

// Returns the Command in effect at the measure containing mtTime.
HRESULT CCommandTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(CCommandTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rCommandGuid);

    if (rCommandGuid == GUID_CommandParam2)
    {
        return GetParam2(mtTime, pmtNext, (DMUS_COMMAND_PARAM_2*) pData);
    }
    else if (rCommandGuid == GUID_CommandParamNext)
    {
        return GetParamNext(mtTime, pmtNext, (DMUS_COMMAND_PARAM_2*) pData);
    }
    else if (rCommandGuid != GUID_CommandParam)
    {
        return DMUS_E_GET_UNSUPPORTED;
    }

    HRESULT hr = S_OK;
    if (pData) // Something got passed in 
    {
        EnterCriticalSection( &m_CriticalSection );
        DMUS_COMMAND_PARAM* pCommandParam = (DMUS_COMMAND_PARAM*) pData;
        // Default to the old groove C
        BYTE bCommand = DMUS_COMMANDT_GROOVE;
        BYTE bGrooveLevel = 62;
        BYTE bGrooveRange = 0;
        BYTE bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<DMCommand>* pNext = m_CommandList.GetHead();
        const int epsilon = DMUS_PPQ / 16; // leave a 64th note on either side...
        for( ; pNext; pNext = pNext->GetNext())
        {
            if ( abs(pNext->GetItemValue().m_mtTime - mtTime) < epsilon ) //  this is it
            {
                bCommand = pNext->GetItemValue().m_bCommand;
                bGrooveLevel = pNext->GetItemValue().m_bGrooveLevel;
                bGrooveRange = pNext->GetItemValue().m_bGrooveRange;
                bRepeatMode = pNext->GetItemValue().m_bRepeatMode;
                pNext = pNext->GetNext();
                break;
            }
            else if (pNext->GetItemValue().m_mtTime < mtTime) // may be it, but we need a next time
            {
                bGrooveLevel = pNext->GetItemValue().m_bGrooveLevel;
                bGrooveRange = pNext->GetItemValue().m_bGrooveRange;
                bRepeatMode = pNext->GetItemValue().m_bRepeatMode;
            }
            else // passed it
            {
                break;
            }
        }
        hr = S_OK;
        pCommandParam->bCommand = bCommand;
        pCommandParam->bGrooveLevel = bGrooveLevel;
        pCommandParam->bGrooveRange = bGrooveRange;
        pCommandParam->bRepeatMode = bRepeatMode;
        if (pmtNext)
        {
            if (pNext)
            {
                *pmtNext = pNext->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
            }
            else
            {
                MUSIC_TIME mtLength = 0;
                *pmtNext = mtLength;
            }
        }
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
} 

HRESULT CCommandTrack::GetParam2( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_COMMAND_PARAM_2* pCommandParam)
{
    //TraceI(0, "GetParam time: %d\n", mtTime);
    HRESULT hr = S_OK;
    if (pCommandParam) // Something got passed in 
    {
        EnterCriticalSection( &m_CriticalSection );
        // Default to the old groove C
        MUSIC_TIME mtCommandTime = 0;
        BYTE bCommand = DMUS_COMMANDT_GROOVE;
        BYTE bGrooveLevel = 62;
        BYTE bGrooveRange = 0;
        BYTE bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<DMCommand>* pNext = m_CommandList.GetHead();
        for( ; pNext; pNext = pNext->GetNext())
        {
            if (pNext->GetItemValue().m_mtTime <= mtTime) // may be it, but we need a next time
            {
                mtCommandTime = pNext->GetItemValue().m_mtTime - mtTime;
                bCommand = pNext->GetItemValue().m_bCommand;
                bGrooveLevel = pNext->GetItemValue().m_bGrooveLevel;
                bGrooveRange = pNext->GetItemValue().m_bGrooveRange;
                bRepeatMode = pNext->GetItemValue().m_bRepeatMode;
            }
            else // passed it
            {
                break;
            }
        }
        hr = S_OK;
        pCommandParam->mtTime = mtCommandTime;
        pCommandParam->bCommand = bCommand;
        pCommandParam->bGrooveLevel = bGrooveLevel;
        pCommandParam->bGrooveRange = bGrooveRange;
        pCommandParam->bRepeatMode = bRepeatMode;
        if (pmtNext)
        {
            if (pNext)
            {
                *pmtNext = pNext->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
            }
            else
            {
                *pmtNext = 0;
            }
        }
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
} 

HRESULT CCommandTrack::GetParamNext( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_COMMAND_PARAM_2* pCommandParam)
{
    HRESULT hr = S_OK;
    if (pCommandParam) // Something got passed in 
    {
        EnterCriticalSection( &m_CriticalSection );
        if (m_pNextCommand)
        {
            *pCommandParam = *m_pNextCommand;
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
            /*// Default to the old groove C
            pCommandParam->bCommand = DMUS_COMMANDT_GROOVE;
            pCommandParam->bGrooveLevel = 62;
            pCommandParam->bGrooveRange = 0;*/
        }
        if (pmtNext)
        {
            *pmtNext = 0;
        }
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
} 

HRESULT CCommandTrack::SetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CCommandTrack::SetParam);
    V_REFGUID(rCommandGuid);

    if (rCommandGuid == GUID_CommandParamNext)
    {
        return SetParamNext(mtTime, (DMUS_COMMAND_PARAM_2*) pData);
    }
    else if (rCommandGuid != GUID_CommandParam)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    HRESULT hr = S_OK;
    if (pData) // Something got passed in 
    {
        EnterCriticalSection( &m_CriticalSection );
        DMUS_COMMAND_PARAM* pCommandParam = (DMUS_COMMAND_PARAM*) pData;
        //DirectMusicTimeSig TimeSig = ((CommandData *)(pData))->m_TimeSig;
        //WORD wMeasure = ClocksToMeasure(mtTime, TimeSig);
        TListItem<DMCommand>* pCommand = m_CommandList.GetHead();
        TListItem<DMCommand>* pPrevious = NULL;
        TListItem<DMCommand>* pNew = new TListItem<DMCommand>;
        if (!pNew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            DMCommand& rNew = pNew->GetItemValue();
            rNew.m_mtTime = mtTime;
            rNew.m_bBeat = 0;
            rNew.m_bCommand = pCommandParam->bCommand;
            rNew.m_bGrooveLevel = pCommandParam->bGrooveLevel;
            rNew.m_bGrooveRange = pCommandParam->bGrooveRange;
            rNew.m_bRepeatMode = pCommandParam->bRepeatMode;
            for (; pCommand != NULL; pCommand = pCommand->GetNext())
            {
                DMCommand& rCommand = pCommand->GetItemValue();
                if (rCommand.m_mtTime >= mtTime) break;
                pPrevious = pCommand;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pNew);
                pNew->SetNext(pCommand);
            }
            else // pCommand is current head of list
            {
                m_CommandList.AddHead(pNew);
            }
            if (pCommand && pCommand->GetItemValue().m_mtTime == mtTime)
            {
                // remove it
                pNew->SetNext(pCommand->GetNext());
                pCommand->SetNext(NULL);
                delete pCommand;
            }
            hr = S_OK;
        }
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
}

HRESULT CCommandTrack::SetParamNext( 
    MUSIC_TIME mtTime,
    DMUS_COMMAND_PARAM_2* pCommandParam)
{
    EnterCriticalSection( &m_CriticalSection );
    if (m_pNextCommand)
    {
        delete m_pNextCommand;
        m_pNextCommand = NULL;
    }
    if (pCommandParam)
    {
        m_pNextCommand = new DMUS_COMMAND_PARAM_2;
        if (!m_pNextCommand)
        {
            LeaveCriticalSection( &m_CriticalSection );
            return E_OUTOFMEMORY;
        }
        *m_pNextCommand = *pCommandParam;
    }
    // Otherwise, allow a null pCommandParam to act as a reset.
    LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
} 

// IPersist methods
 HRESULT CCommandTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CCommandTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicCommandTrack;
    return S_OK;
}

HRESULT CCommandTrack::IsParamSupported(
                /*[in]*/ REFGUID    rGuid
            )
{
    V_INAME(CCommandTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (rGuid == GUID_CommandParam || 
        rGuid == GUID_CommandParam2 || 
        rGuid == GUID_CommandParamNext)
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

// IPersistStream methods
 HRESULT CCommandTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CCommandTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    V_INAME(CCommandTrack::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF ;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<DMCommand>* pCommand;

    EnterCriticalSection( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF  );
    if (!SUCCEEDED(hr))
    {
        goto ON_END;
    }
    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            if (SUCCEEDED(hr)) hr = E_FAIL;
            goto ON_END;
        }
        for( pCommand = m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            DMCommand& rCommand = pCommand->GetItemValue();
            memset( &iCommand, 0, sizeof( iCommand ) );
            iCommand.mtTime = rCommand.m_mtTime;
            iCommand.wMeasure = rCommand.m_wMeasure;
            iCommand.bBeat = rCommand.m_bBeat;
            iCommand.bCommand = rCommand.m_bCommand;
            iCommand.bGrooveLevel = rCommand.m_bGrooveLevel;
            iCommand.bGrooveRange = rCommand.m_bGrooveRange;
            iCommand.bRepeatMode = rCommand.m_bRepeatMode;
            if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                cb != sizeof( iCommand ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CCommandTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

BOOL Greater(DMCommand& Command1, DMCommand& Command2)
{ return Command1.m_wMeasure > Command2.m_wMeasure; }

BOOL Less(DMCommand& Command1, DMCommand& Command2)
{ return Command1.m_wMeasure < Command2.m_wMeasure; }

HRESULT CCommandTrack::Load(LPSTREAM pStream )
{
    V_INAME(CCommandTrack::Load);
    V_INTERFACE(pStream);

    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;
    MMCKINFO        ck;
    IAARIFFStream*  pRIFF;
//    FOURCC id = 0;
    HRESULT         hr = E_FAIL;
    DMUS_IO_COMMAND     iCommand;
    DWORD dwPos;

    EnterCriticalSection( &m_CriticalSection );
    Clear();
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    ck.ckid = FOURCC_COMMAND;
    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
    {
        lFileSize = ck.cksize;
        hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<DMCommand>* pCommand;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pCommand = new TListItem<DMCommand>;
                    if( pCommand )
                    {
                        DMCommand& rCommand = pCommand->GetItemValue();
                        if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                        {
                            pStream->Read( &iCommand, dwNodeSize, NULL );
                        }
                        else
                        {
                            pStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                            StreamSeek( pStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                        }
                        memset( &rCommand, 0, sizeof( rCommand ) );
                        rCommand.m_mtTime = iCommand.mtTime;
                        rCommand.m_wMeasure = iCommand.wMeasure;
                        rCommand.m_bBeat = iCommand.bBeat;
                        rCommand.m_bCommand = iCommand.bCommand;
                        rCommand.m_bGrooveLevel = iCommand.bGrooveLevel;
                        if( iCommand.bGrooveRange > 100 )
                        {
                            Trace(0, "Warning: Illegal value %d read for Command's groove range.\n", iCommand.bGrooveRange);
                            rCommand.m_bGrooveRange = 0;
                        }
                        else
                        {
                            rCommand.m_bGrooveRange = iCommand.bGrooveRange;
                        }
                        if( iCommand.bRepeatMode > DMUS_PATTERNT_RANDOM_ROW )
                        {
                            Trace(0, "Warning: Illegal value %d read for Command's repeat mode.\n", iCommand.bRepeatMode);
                            rCommand.m_bRepeatMode = 0;
                        }
                        else
                        {
                            rCommand.m_bRepeatMode = iCommand.bRepeatMode;
                        }
                        m_CommandList.AddTail(pCommand);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
            m_CommandList.MergeSort(Less);
            BYTE bLastGrooveLevel = 62;
            TListItem<DMCommand>* pCommand = m_CommandList.GetHead();
            for(; pCommand != NULL; pCommand = pCommand->GetNext())
            {
                if (!pCommand->GetItemValue().m_bGrooveLevel)
                {
                    pCommand->GetItemValue().m_bGrooveLevel = bLastGrooveLevel;
                }
                else
                {
                    bLastGrooveLevel = pCommand->GetItemValue().m_bGrooveLevel;
                }
            }
        }
        pRIFF->Release();
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CCommandTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CCommandTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_COMMAND )
    {
        m_fNotifyCommand = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CCommandTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CCommandTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_COMMAND )
    {
        m_fNotifyCommand = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CCommandTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CCommandTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    CCommandTrack *pDM;
    try
    {
        pDM = new CCommandTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// For consistency with other track types
STDMETHODIMP CCommandTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CCommandTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CCommandTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CCommandTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CCommandTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    TList<DMCommand> ResultList;
    CCommandTrack* pResultTrack = NULL;
    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        pResultTrack = (CCommandTrack*)*ppResultTrack;
        while(!pResultTrack->m_CommandList.IsEmpty())
        {
            ResultList.AddHead(pResultTrack->m_CommandList.RemoveHead());
        }
    }
    else
    {
        pResultTrack = this;
        while(!m_CommandList.IsEmpty() && 
              m_CommandList.GetHead()->GetItemValue().m_mtTime < mtJoin)
        {
            ResultList.AddHead(m_CommandList.RemoveHead());
        }
        m_CommandList.CleanUp();
    }
    WORD wMeasure = 0;
    HRESULT hrTimeSig = S_OK;
    MUSIC_TIME mtTimeSig = 0;
    MUSIC_TIME mtOver = 0;
    IDirectMusicSong* pSong = NULL;
    IDirectMusicSegment* pSegment = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pSegment)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hrTimeSig = E_FAIL;
        }
    }
    while (SUCCEEDED(hrTimeSig) && mtTimeSig < mtJoin)
    {
        DMUS_TIMESIGNATURE TimeSig;
        MUSIC_TIME mtNext = 0;
        if (pSegment)
        {
            hrTimeSig = pSegment->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        else
        {
            hrTimeSig = pSong->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        if (SUCCEEDED(hrTimeSig))
        {
            if (!mtNext) mtNext = mtJoin - mtTimeSig; // means no more time sigs
            DirectMusicTimeSig DMTimeSig = TimeSig;
            WORD wMeasureOffset = (WORD)DMTimeSig.ClocksToMeasure(mtNext + mtOver);
            MUSIC_TIME mtMeasureOffset = (MUSIC_TIME) wMeasureOffset;
            // The following line crashes on certain builds on certain machines.
            // mtOver = mtMeasureOffset ? (mtNext % mtMeasureOffset) : 0;
            if (mtMeasureOffset)
            {
                mtOver = mtNext % mtMeasureOffset;
            }
            else
            {
                mtOver = 0;
            }
            wMeasure += wMeasureOffset;
            mtTimeSig += mtNext;
        }
    }
    CCommandTrack* pOtherTrack = (CCommandTrack*)pNewTrack;
    TListItem<DMCommand>* pScan = pOtherTrack->m_CommandList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        TListItem<DMCommand>* pNew = new TListItem<DMCommand>(pScan->GetItemValue());
        if (pNew)
        {
            pNew->GetItemValue().m_mtTime += mtJoin;
            pNew->GetItemValue().m_wMeasure += wMeasure;
            ResultList.AddHead(pNew);
        }
        else
        {
            ResultList.CleanUp();
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pResultTrack->m_CommandList.CleanUp();
        while(!ResultList.IsEmpty() )
        {
            pResultTrack->m_CommandList.AddHead(ResultList.RemoveHead());
        }
    }
    if (pSong) pSong->Release();
    if (pSegment) pSegment->Release();
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\audtrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       audtrk.h
//
//--------------------------------------------------------------------------

// AudTrk.h : Declaration of the CAuditionTrack

#ifndef __AUDITIONTRACK_H_
#define __AUDITIONTRACK_H_

#include "Ptrntrk.h"

struct AuditionTrackInfo : public PatternTrackInfo
{
	AuditionTrackInfo();
	AuditionTrackInfo(const AuditionTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) 
		: PatternTrackInfo(pInfo, mtStart, mtEnd), 
		  m_pPattern(NULL),	
		  m_pdwVariations(NULL),
		  m_dwVariations(0), 
		  m_dwPart(0),
		  m_fByGUID(TRUE)
	{
		memset(&m_guidPart, 0, sizeof(m_guidPart));
		m_dwPatternTag = DMUS_PATTERN_AUDITION;
		if (pInfo && pInfo->m_pPattern)
		{
			m_pPattern = pInfo->m_pPattern->Clone(mtStart, mtEnd, FALSE);
			PatternTrackInfo::InitTrackVariations(m_pPattern);
		}
	}
	~AuditionTrackInfo();
	virtual HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

	virtual HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);
	HRESULT InitTrackVariations();

	CDirectMusicPattern*	m_pPattern;		// The audition track's pattern
	DWORD*					m_pdwVariations;	// Variations currently in use (one DWORD per part)
	DWORD					m_dwVariations;	// The variations to use for m_wPart
	DWORD					m_dwPart;		// The part to use m_dwVariations
	GUID	m_guidPart;			// GUID of the  part to play with the selected variations
	BOOL	m_fByGUID;			// true if selecting parts by GUID, false if by PChannel
};

/////////////////////////////////////////////////////////////////////////////
// CAuditionTrack
class CAuditionTrack : 
	public IAuditionTrack,
	public IDirectMusicPatternTrack,
	public IDirectMusicTrack8,
	public IPersistStream,
	public IPrivatePatternTrack

{
public:
	CAuditionTrack();
	CAuditionTrack(const CAuditionTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
	~CAuditionTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IAuditionTrack
public:
// IDirectMusicTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;


// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IAuditionTrack methods
HRESULT STDMETHODCALLTYPE CreateSegment(
			IDirectMusicStyle* pStyle, IDirectMusicSegment** ppSegment);

HRESULT STDMETHODCALLTYPE SetPatternByName(IDirectMusicSegmentState* pSegState, 
                                          WCHAR* wszName,
                                          IDirectMusicStyle* pStyle,
										  DWORD dwPatternType,
										  DWORD* pdwLength);

HRESULT STDMETHODCALLTYPE SetVariation(
			IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart);

// IPrivatePatternTrack Methods
HRESULT STDMETHODCALLTYPE SetPattern(IDirectMusicSegmentState* pSegState, IStream* pStream, DWORD* pdwLength);

HRESULT STDMETHODCALLTYPE SetVariationByGUID(
			IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, REFGUID rguidPart, DWORD dwPChannel);

// obsolete method (dx7)
HRESULT STDMETHODCALLTYPE SetVariation(
			IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, WORD wPart)
{
    DWORD dwPart = (DWORD)wPart;
    return SetVariation(pSegState, dwVariationFlags, dwPart);
}

// other stuff
HRESULT LoadPattern(IAARIFFStream* pIRiffStream,  MMCKINFO* pckMain, DMStyleStruct* pNewStyle);
HRESULT GetParam( 
	REFGUID	rCommandGuid,
    MUSIC_TIME mtTime,
	void * pStateData,
	MUSIC_TIME* pmtNext,
    void *pData);

// IAuditionTrack data members
protected:
// new internal play method
HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID,
						  BOOL fClockTime
			);

	// attributes
    long						m_cRef;
    CRITICAL_SECTION			m_CriticalSection; // for load and playback
    BOOL                        m_fCSInitialized;
	PatternTrackInfo*			m_pTrackInfo;
	BYTE						m_bRequiresSave;
};

struct AuditionTrackState : public PatternTrackState
{
	AuditionTrackState();
	~AuditionTrackState();
	// methods
	HRESULT Play(
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  IDirectMusicPerformance* pPerformance,
						  DWORD						dwFlags,
						  BOOL fClockTime

			);

	virtual DWORD Variations(DirectMusicPartRef& rPartRef, int nPartIndex);

	virtual BOOL PlayAsIs();

	HRESULT InitVariationInfo(DWORD dwVariations, DWORD dwPart, REFGUID rGuidPart, BOOL fByGuid);

	// attributes
	DWORD	m_dwVariation;		// Which variations to play
	DWORD	m_dwPart;			// PCHannel of the part to play with the selected variations
	GUID	m_guidPart;			// GUID of the  part to play with the selected variations
	BOOL	m_fByGUID;			// true if selecting parts by GUID, false if by PChannel
	BOOL	m_fTestVariations;	// Are we testing individual variations?
	BYTE	m_bVariationLock;	// Variation Lock ID of the selected part
	MUSIC_TIME					m_mtSectionOffset;	// Elapsed time in the section (needed to calculate repeats)
};


#endif //__AUDITIONTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\cmmdtrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       cmmdtrk.h
//
//--------------------------------------------------------------------------

// CommandTrack.h : Declaration of the CCommandTrack

#ifndef __COMMANDTRACK_H_
#define __COMMANDTRACK_H_

#include "tlist.h"
#include "dmsect.h"
#include "dmusici.h"

// Don't think I currently need Command state data...
typedef DWORD CommandStateData;

/////////////////////////////////////////////////////////////////////////////
// CCommandTrack
class CCommandTrack : 
	//public ICommandTrack,
	public IDirectMusicTrack8,
	public IPersistStream
{
public:
	CCommandTrack();
	CCommandTrack(const CCommandTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CCommandTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// ICommandTrack
public:
// ICommandTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// CommandTrack members
protected:
	void Clear();
	HRESULT SendNotification(DWORD dwCommand, 
								MUSIC_TIME mtTime,
								IDirectMusicPerformance*	pPerf,
								IDirectMusicSegmentState*	pSegState,
								DWORD dwFlags);

	HRESULT GetParam2( 
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		DMUS_COMMAND_PARAM_2* pCommandParam);

	HRESULT GetParamNext( 
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		DMUS_COMMAND_PARAM_2* pCommandParam);

	HRESULT SetParamNext( 
		MUSIC_TIME mtTime,
		DMUS_COMMAND_PARAM_2* pCommandParam);

    long m_cRef;
	TList<DMCommand>			m_CommandList;
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;
	DMUS_COMMAND_PARAM_2*		m_pNextCommand;

	BYTE						m_bRequiresSave;
	BOOL						m_fNotifyCommand;
};

#endif //__COMMANDTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmfourcc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       dmfourcc.h
//
//--------------------------------------------------------------------------

#ifndef __DMFOURCC_H__
#define __DMFOURCC_H__

#define DM_FOURCC_STYLE_FORM        mmioFOURCC('S','T','Y','L')
#define DM_FOURCC_STYLE_UNDO_FORM   mmioFOURCC('s','t','u','n')
#define DM_FOURCC_STYLE_CHUNK       mmioFOURCC('s','t','y','h')
#define DM_FOURCC_STYLE_UI_CHUNK    mmioFOURCC('s','t','y','u')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define DM_FOURCC_PART_LIST	        mmioFOURCC('p','a','r','t')
#define DM_FOURCC_PART_CHUNK        mmioFOURCC('p','r','t','h')
#define DM_FOURCC_NOTE_CHUNK        mmioFOURCC('n','o','t','e')
#define DM_FOURCC_CURVE_CHUNK       mmioFOURCC('c','r','v','e')
#define DM_FOURCC_PATTERN_LIST      mmioFOURCC('p','t','t','n')
#define DM_FOURCC_PATTERN_CHUNK     mmioFOURCC('p','t','n','h')
#define DM_FOURCC_PATTERN_UI_CHUNK  mmioFOURCC('p','t','n','u')
#define DM_FOURCC_RHYTHM_CHUNK      mmioFOURCC('r','h','t','m')
#define DM_FOURCC_PARTREF_LIST      mmioFOURCC('p','r','e','f')
#define DM_FOURCC_PARTREF_CHUNK     mmioFOURCC('p','r','f','c')
#define DM_FOURCC_OLDGUID_CHUNK		mmioFOURCC('j','o','g','c')
#define DM_FOURCC_PATTERN_DESIGN	mmioFOURCC('j','p','n','d')
#define DM_FOURCC_PART_DESIGN		mmioFOURCC('j','p','t','d')
#define DM_FOURCC_PARTREF_DESIGN	mmioFOURCC('j','p','f','d')
#define DM_FOURCC_PIANOROLL_LIST	mmioFOURCC('j','p','r','l')
#define DM_FOURCC_PIANOROLL_CHUNK	mmioFOURCC('j','p','r','c')

struct ioDMStyleVersion
{
	DWORD				m_dwVersionMS;		 // Version # high-order 32 bits
	DWORD				m_dwVersionLS;		 // Version # low-order 32 bits
};

#endif // __DMFOURCC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmsect.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       dmsect.h
//
//--------------------------------------------------------------------------

// DMSection.h : Declaration of the CDMSection

#ifndef __DMSECTION_H_
#define __DMSECTION_H_

#include "dmusici.h"
#include "dmusicf.h"

#include "sjdefs.h"
#include "iostru.h"
#include "AARiff.h"
#include "str.h"
#include "tlist.h"
#include "timesig.h"
#include "dmstylep.h"

#define TRACK_COMMAND	0
#define TRACK_CHORD		1
#define TRACK_RHYTHM	2
#define TRACK_REPEATS	3
#define TRACK_START		4

#define MAJOR_PATTERN	0x91	// 10010001
#define MINOR_PATTERN	0x89	// 10001001

struct DMSubChord
{
	HRESULT Save( IAARIFFStream* pRIFF );
	DMSubChord() : m_dwChordPattern(0), m_dwScalePattern(0), m_dwInversionPoints(0),
		m_bChordRoot(0), m_bScaleRoot(0), m_dwLevels(1 << SUBCHORD_STANDARD_CHORD)
	{}
	DMSubChord(DMUS_SUBCHORD& DMSC)
	{
		m_dwChordPattern = DMSC.dwChordPattern;
		m_dwScalePattern = DMSC.dwScalePattern;
		m_dwInversionPoints = DMSC.dwInversionPoints;
		m_dwLevels = DMSC.dwLevels;
		m_bChordRoot = DMSC.bChordRoot;
		m_bScaleRoot = DMSC.bScaleRoot;
	}
	operator DMUS_SUBCHORD()
	{
		DMUS_SUBCHORD result;
		result.dwChordPattern = m_dwChordPattern;
		result.dwScalePattern = m_dwScalePattern;
		result.dwInversionPoints = m_dwInversionPoints;
		result.dwLevels = m_dwLevels;
		result.bChordRoot = m_bChordRoot;
		result.bScaleRoot = m_bScaleRoot;
		return result;
	}
	DWORD	m_dwChordPattern;		// Notes in the subchord
	DWORD	m_dwScalePattern;		// Notes in the scale
	DWORD	m_dwInversionPoints;	// Where inversions can occur
	DWORD	m_dwLevels;				// Which levels are supported by this subchord
	BYTE	m_bChordRoot;			// Root of the subchord
	BYTE	m_bScaleRoot;			// Root of the scale
};

struct DMChord
{
	HRESULT Save( IAARIFFStream* pRIFF );
	DMChord() : m_strName(""), m_mtTime(0), m_wMeasure(0), m_bBeat(0), m_fSilent(false) {}
	DMChord(DMUS_CHORD_PARAM& DMC);
	DMChord(DMChord& DMC);
	operator DMUS_CHORD_PARAM();
	DMChord& operator= (const DMChord& rDMC);
	String	m_strName;		// Name of the chord
	MUSIC_TIME	m_mtTime;		// Time, in clocks
	WORD	m_wMeasure;		// Measure this falls on
	BYTE	m_bBeat;		// Beat this falls on
	BYTE	m_bKey;			// Underlying key
	DWORD	m_dwScale;		// Underlying scale
	bool	m_fSilent;		// Is this chord silent?
	TList<DMSubChord>	m_SubChordList;	// List of sub chords
};

struct DMCommand
{
	MUSIC_TIME	m_mtTime;		// Time, in clocks
	WORD		m_wMeasure;		// Measure this falls on
	BYTE		m_bBeat;		// Beat this falls on
	BYTE		m_bCommand;		// Command type
	BYTE		m_bGrooveLevel;	// Groove level
	BYTE		m_bGrooveRange; // Groove range
	BYTE		m_bRepeatMode;	// Repeat mode
};

struct MuteMapping
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwPChannelMap;
	BOOL		m_fMute;
};


/////////////////////////////////////////////////////////////////////////////
// CDMSection
class CDMSection : 
	public IDMSection,
	public IDirectMusicObject,
	public IPersistStream
{
public:
	CDMSection();
	~CDMSection();
	void CleanUp(BOOL fStop = FALSE);
	HRESULT LoadSection(IAARIFFStream* pRIFF, MMCKINFO* pckMain);
	HRESULT LoadStyleReference( LPSTREAM pStream, MMCKINFO* pck );
	HRESULT LoadChordList(LPSTREAM pStream, MMCKINFO* pckMain, TList<DMChord>& ChordList);
	HRESULT LoadCommandList(LPSTREAM pStream, MMCKINFO* pckMain, TList<DMCommand>& CommandList);
	HRESULT SaveChordList( IAARIFFStream* pRIFF );
	HRESULT SaveCommandList( IAARIFFStream* pRIFF );
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IPersist methods */
    // Retrieves the Style's Class ID.
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

    /* IPersistStream methods */
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

protected:
    long m_cRef;
	String	m_strName;				// Name of section
	String	m_strStyleName;			// Name of associated style file
	IDirectMusicStyle* m_pStyle;	// Pointer to the style interface
	DWORD	m_dwTime;				// Time in clocks
	DWORD	m_dwFlags;				// ?
	WORD	m_wTempo;				// Tempo
	WORD	m_wRepeats;				// Repeats
	WORD	m_wMeasureLength;		// Number of measures
	DWORD	m_dwClockLength;		// Total number of clocks
	WORD	m_wClocksPerMeasure;	// Clocks per measure
	WORD	m_wClocksPerBeat;		// Clocks per beat
	WORD	m_wTempoFract;			// ?
	BYTE	m_bRoot;				// Root key of section
	TList<DMChord>		m_ChordList;	// List of chords
	TList<DMCommand>	m_CommandList;	// List of commands
	// style reference
	IDirectMusicBand*	m_pIDMBand;	// Section's band

public:

// IDMSection
public:
	STDMETHOD(CreateSegment)(IDirectMusicSegment* pSegment);
	STDMETHOD(GetStyle)(IUnknown** ppStyle);

	// IDirectMusicStyle methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;
};

#endif //__DMSECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMSTYLE"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmsect.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) 1998-2001 Microsoft Corporation
//
//  File:       dmsect.cpp
//
//--------------------------------------------------------------------------

// DMSection.cpp : Implementation of CDMSection
#include "DMSect.h"
#include "DMStyle.h"
#include <initguid.h>
#include "debug.h"
#include "..\dmloader\ima.h"
#include "..\shared\Validate.h"

HRESULT CDMSection::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    return S_OK;
}

HRESULT CDMSection::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    return S_OK;
}

HRESULT CDMSection::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    return S_OK;
}

STDMETHODIMP CDMSection::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CDMSection::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDMSection)
    {
        *ppv = static_cast<IDMSection*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMSection::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMSection::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDMSection

STDMETHODIMP CDMSection::GetStyle(IUnknown * * ppStyle)
{
    HRESULT hr;
    if (m_pStyle)
    {
        IUnknown* pIU = NULL;
        hr = m_pStyle->QueryInterface(IID_IUnknown, (void**)&pIU);
        if (SUCCEEDED(hr))
        {
            *ppStyle = pIU;
            pIU->Release();
            hr = S_OK;
        }
    }
    else
        hr = E_FAIL;
    return hr;
}

STDMETHODIMP CDMSection::CreateSegment(IDirectMusicSegment* pISegment)
{
    HRESULT                    hr                        = S_OK;
    IDirectMusicTrack*        pIStyleTrack            = NULL;
    IDirectMusicTrack*        pICommandTrack            = NULL;
    IDirectMusicTrack*        pIChordTrack            = NULL;
    IDirectMusicTrack*        pBandTrack                = NULL;
    IDirectMusicTrack*        pDMTrack                = NULL;
    IAARIFFStream*            pCommandRIFF            = NULL;
    IAARIFFStream*            pChordRIFF                = NULL;
    IStream*                pICommandStream            = NULL;
    IStream*                pIChordStream            = NULL;
    IPersistStream*            pICommandTrackStream    = NULL;
    IPersistStream*            pIChordTrackStream        = NULL;
    IStyleTrack*            pS                        = NULL;
    IUnknown*                pU                        = NULL;
    DMUS_BAND_PARAM            DMBandParam;

    // 1. Create Style, Command, and Chord Tracks.
    hr = ::CoCreateInstance(
        CLSID_DirectMusicStyleTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pIStyleTrack
        );
    if (FAILED(hr)) goto ON_END;
    hr = ::CoCreateInstance(
        CLSID_DirectMusicCommandTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pICommandTrack
        );
    if (FAILED(hr)) goto ON_END;
    hr = ::CoCreateInstance(
        CLSID_DirectMusicChordTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pIChordTrack
        );
    if (FAILED(hr)) goto ON_END;
    hr = ::CoCreateInstance(
        CLSID_DirectMusicBandTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pBandTrack
        );
    if (FAILED(hr)) goto ON_END;

    // 2/3. Use the section's style create a style track.
    hr = m_pStyle->QueryInterface(IID_IUnknown, (void**)&pU);
    if (FAILED(hr)) goto ON_END;
    hr = pIStyleTrack->QueryInterface(IID_IStyleTrack, (void**)&pS);
    if (FAILED(hr)) goto ON_END;
    pS->SetTrack(pU);
    m_pStyle->AddRef(); // Whenever I create a track from a style, I need to addref the style
    // 4. Write the section's command list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
    if (FAILED(hr)) goto ON_END;
    hr = AllocRIFFStream( pICommandStream, &pCommandRIFF);
    if (FAILED(hr)) goto ON_END;
    SaveCommandList(pCommandRIFF);
    // 5. Write the section's chord list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
    if (S_OK != hr) goto ON_END;
    hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
    if (FAILED(hr)) goto ON_END;
    SaveChordList(pChordRIFF);
    // 6. Use the command list stream as input to the Command Track's Load method.
    hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
    if (FAILED(hr)) goto ON_END;
    StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
    hr = pICommandTrackStream->Load(pICommandStream);
    if (FAILED(hr)) goto ON_END;
    // 7a. Use the chord list stream as input to the Chord Track's Load method.
    hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
    if (FAILED(hr)) goto ON_END;
    StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
    hr = pIChordTrackStream->Load(pIChordStream);
    if(FAILED(hr)) goto ON_END;
    // 7b. Load band into band track
    DMBandParam.mtTimePhysical = -64;
    DMBandParam.pBand = m_pIDMBand;
    hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
    if (FAILED(hr)) goto ON_END;

    // 8. Create a Segment has been removed it is now passed in

    // 9. Initialize the segment appropriately.
    pISegment->SetRepeats(m_wRepeats);
    pISegment->SetDefaultResolution((DWORD)m_wClocksPerBeat);
    pISegment->SetLength(m_dwClockLength); // need the length of the section!
    /////////////////////////////////////////////////////////////////
    DMUS_TEMPO_PARAM tempo;
    tempo.mtTime = 0; // ConvertTime( dwTime );
    tempo.dblTempo = (double) m_wTempo; // ((double)dw) / 64;
    /////////////////////////////////////////////////////////////////
    hr = S_OK;
    // Create a Tempo Track in which to store the tempo events
    if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
        NULL, CLSCTX_INPROC, IID_IDirectMusicTrack,
        (void**)&pDMTrack )))
    {
        GUID Guid = GUID_TempoParam;
        if ( SUCCEEDED(pDMTrack->SetParam(Guid, 0, &tempo)))
        {
            pISegment->InsertTrack( pDMTrack, 1 );
        }
    }
    // 10. Insert the three Tracks into the Segment's Track list.
    pISegment->InsertTrack(pBandTrack, 1);
    pISegment->InsertTrack(pIStyleTrack, 1);
    pISegment->InsertTrack(pICommandTrack, 1);
    pISegment->InsertTrack(pIChordTrack, 1);

    // Note: the segment must release the track objects...
ON_END:
    if (pDMTrack) pDMTrack->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pICommandStream) pICommandStream->Release();
    if (pICommandTrackStream) pICommandTrackStream->Release();
    if (pCommandRIFF) pCommandRIFF->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pS) pS->Release();
    if (pU) pU->Release();
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pICommandTrack) pICommandTrack->Release();
    if (pIChordTrack) pIChordTrack->Release();
    if (pBandTrack) pBandTrack->Release();
    return hr;
}

CDMSection::CDMSection() : m_pStyle(NULL), m_pIDMBand(NULL), m_cRef(1)
{
    InterlockedIncrement(&g_cComponent);
}

CDMSection::~CDMSection()
{
    CleanUp();
    InterlockedDecrement(&g_cComponent);
}

void CDMSection::CleanUp( BOOL fStop)
{
    if(m_pIDMBand)
    {
        m_pIDMBand->Release();
    }

    // let whoever used the section release the style.
    if (m_pStyle)
    {
        m_pStyle->Release();
    }
}

static BYTE setchordbits( long lPattern )
{
LONG    i;
short   count = 0;
BYTE bBits = 0;

    for( i=0L ;  i<32L ;  i++ )
    {
        if( lPattern & (1L << i) )
            count++;
    }
    bBits |= CHORD_INVERT;
    if( count > 3 )
        bBits |= CHORD_FOUR;
    if( lPattern & (15L << 18L) )
        bBits |= CHORD_UPPER;
    bBits &= ~CHORD_COUNT;
    bBits |= count;
    return bBits;
}

HRESULT CDMSection::LoadChordList( LPSTREAM pStream, LPMMCKINFO pck, TList<DMChord>& ChordList )
{
    HRESULT        hr = S_OK;
    DWORD        cb;
    long        lSize;
    TListItem<DMChord>*   pChord;
    ioChordSelection iChordSelection;
    WORD        wSizeChord;

    lSize = pck->cksize;
    // load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    FixBytes( FBT_SHORT, &wSizeChord );
    lSize -= cb;
    while( lSize > 0 )
    {
        pChord = new TListItem<DMChord>;
        if( pChord == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }
        if( wSizeChord > sizeof( ioChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioChordSelection ) )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
            StreamSeek( pStream, wSizeChord - sizeof( ioChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
        }
        lSize -= wSizeChord;

        // WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->name, sizeof( pChord->name ), NULL, NULL );
        DMChord& rChord = pChord->GetItemValue();
        rChord.m_bKey = m_bRoot;
        rChord.m_dwScale = DEFAULT_SCALE_PATTERN;
        rChord.m_strName = iChordSelection.wstrName;
        rChord.m_bBeat = iChordSelection.bBeat;
        rChord.m_wMeasure = iChordSelection.wMeasure;
        rChord.m_mtTime = m_wClocksPerMeasure * rChord.m_wMeasure + m_wClocksPerBeat * rChord.m_bBeat;
        // If chordpattern contains <= n notes (for an n-note chord)
        //   create a single subchord
        // Else
        //   create 2 subchords, with the 1st having the lower n notes and the
        //   2nd having the upper n notes (assumes there are <= 2n notes)
        BYTE bBits = setchordbits( iChordSelection.aChord[0].lChordPattern );
        short nChordCount = bBits & CHORD_COUNT;
        // The root of the lower chord is the input chord's root,
        // relative to the scale (section) root.
        BYTE bChordRoot = iChordSelection.aChord[0].bRoot;
        //    (bBits & CHORD_UPPER) ? (iChordSelection.aChord[0].bRoot  - 12) : iChordSelection.aChord[0].bRoot;
        bChordRoot -= m_bRoot;
        if (bChordRoot < 0) bChordRoot += 12;
        if ((bBits & CHORD_FOUR && nChordCount <= 4) ||
            (!(bBits & CHORD_FOUR) && nChordCount <= 3))
        {
            // single subchord with all info from input chord
            TListItem<DMSubChord>* pSubChord = new TListItem<DMSubChord>;
            if( pSubChord == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto ON_ERR;
            }
            DMSubChord& rSubChord = pSubChord->GetItemValue();
            if (iChordSelection.aChord[0].lChordPattern)
            {
                rSubChord.m_dwChordPattern = iChordSelection.aChord[0].lChordPattern;
            }
            else
            {
            }
            rSubChord.m_dwScalePattern = iChordSelection.aChord[0].lScalePattern;
            rSubChord.m_dwInversionPoints = 0xffffff;    // default: inversions everywhere
            rSubChord.m_dwLevels = (1 << SUBCHORD_BASS) | (1 << SUBCHORD_STANDARD_CHORD);
            rSubChord.m_bChordRoot = bChordRoot;
            rSubChord.m_bScaleRoot = m_bRoot;        // scale root is root of the section
            rChord.m_SubChordList.AddTail(pSubChord);
        }
        else
        {
            // two subchords both with scale and roots from input chord, and:
            // 1st chord: chord pattern from lower n notes of input chord
            // 2nd chord: chord pattern from upper n notes of input chord
            DWORD dwLowerSubChord = 0L;
            DWORD dwUpperSubChord = 0L;
            BYTE bUpperRoot = bChordRoot;
            DWORD dwChordPattern = iChordSelection.aChord[0].lChordPattern;
            short nIgnoreHigh = (bBits & CHORD_FOUR) ? 4 : 3;
            short nIgnoreLow = (bBits & CHORD_FOUR) ? nChordCount - 4 : nChordCount - 3;
            short nLowestUpper = 0;
            for (short nPos = 0, nCount = 0; nPos < 24; nPos++)
            {
                if (dwChordPattern & 1)
                {
                    if (nCount < nIgnoreHigh)
                    {
                        dwLowerSubChord |= 1L << nPos;
                    }
                    if (nCount >= nIgnoreLow)
                    {
                        if (!nLowestUpper)
                        {
                            nLowestUpper = nPos;
                            bUpperRoot = (bUpperRoot + (BYTE) nLowestUpper);
                        }
                        dwUpperSubChord |= 1L << (nPos - nLowestUpper);
                    }
                    nCount++;
                    if (nCount >= nChordCount)
                        break;
                }
                dwChordPattern >>= 1L;
            }
            // now, create the two subchords.
            TListItem<DMSubChord>* pLowerSubChord = new TListItem<DMSubChord>;
            if( pLowerSubChord == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto ON_ERR;
            }
            DMSubChord& rLowerSubChord = pLowerSubChord->GetItemValue();
            rLowerSubChord.m_dwChordPattern = dwLowerSubChord;
            rLowerSubChord.m_dwScalePattern = iChordSelection.aChord[0].lScalePattern;
            rLowerSubChord.m_dwInversionPoints = 0xffffff;    // default: inversions everywhere
            rLowerSubChord.m_dwLevels = (1 << SUBCHORD_BASS);
            rLowerSubChord.m_bChordRoot = bChordRoot;
            rLowerSubChord.m_bScaleRoot = m_bRoot;        // scale root is root of the section
            rChord.m_SubChordList.AddTail(pLowerSubChord);
            TListItem<DMSubChord>* pUpperSubChord = new TListItem<DMSubChord>;
            if( pUpperSubChord == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto ON_ERR;
            }
            DMSubChord& rUpperSubChord = pUpperSubChord->GetItemValue();
            rUpperSubChord.m_dwChordPattern = dwUpperSubChord;
            rUpperSubChord.m_dwScalePattern = iChordSelection.aChord[0].lScalePattern;
            rUpperSubChord.m_dwInversionPoints = 0xffffff;    // default: inversions everywhere
            rUpperSubChord.m_dwLevels = (1 << SUBCHORD_STANDARD_CHORD);
            rUpperSubChord.m_bChordRoot = bUpperRoot % 24;
            while (rUpperSubChord.m_bChordRoot < rLowerSubChord.m_bChordRoot)
                rUpperSubChord.m_bChordRoot += 12;
            rUpperSubChord.m_bScaleRoot = m_bRoot;        // scale root is root of the section
            rChord.m_SubChordList.AddTail(pUpperSubChord);
        }

        ChordList.AddTail(pChord);
    }
ON_ERR:
    return hr;
}

HRESULT CDMSection::LoadCommandList( LPSTREAM pStream, LPMMCKINFO pck, TList<DMCommand>& CommandList )
{
    HRESULT        hr = S_OK;
    DWORD        cb;
    long        lSize;
    TListItem<DMCommand>* pCommand;
    ioCommand   iCommand;
    WORD        wSizeCommand;

    lSize = pck->cksize;
    // load size of command structure
    hr = pStream->Read( &wSizeCommand, sizeof( wSizeCommand ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeCommand ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    FixBytes( FBT_SHORT, &wSizeCommand );
    lSize -= cb;
    while( lSize > 0 )
    {
        pCommand = new TListItem<DMCommand>;
        if( pCommand == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }
        if( wSizeCommand > sizeof( ioCommand ) )
        {
            hr = pStream->Read( &iCommand, sizeof( ioCommand ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioCommand ) )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCOMMAND, &iCommand );
            StreamSeek( pStream, wSizeCommand - sizeof( ioCommand ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iCommand, wSizeCommand, &cb );
            if( FAILED( hr ) || cb != wSizeCommand )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCOMMAND, &iCommand );
        }
        lSize -= wSizeCommand;

        DMCommand& rCommand = pCommand->GetItemValue();
        ////////////////////////////////////////////////////////////////////
        // Change this from absolute time to measures and beats!
        ////////////////////////////////////////////////////////////////////
         // To convert clock time to measures and beats:
         // 1. Use clocksPerMeasure to find the measure
         // 2. Use clocksPerBeat to find the beat
         // DWORD dwClocks = rCommand.m_dwTime - m_dwTime;
         rCommand.m_wMeasure = (WORD) (ConvertTime(iCommand.lTime) / m_wClocksPerMeasure); // assumes 1st measure is 0
         rCommand.m_bBeat = (BYTE) ((ConvertTime(iCommand.lTime) % m_wClocksPerMeasure) / m_wClocksPerBeat); // ditto
         rCommand.m_mtTime = ConvertTime(iCommand.lTime);
        /////////////////////////////////////////////////////////////////////
         switch (iCommand.dwCommand & PF_RIFF)
         {
         case PF_INTRO:
             rCommand.m_bCommand = DMUS_COMMANDT_INTRO;
             break;
         case PF_END:
             rCommand.m_bCommand = DMUS_COMMANDT_END;
             break;
         case PF_BREAK:
             rCommand.m_bCommand = DMUS_COMMANDT_BREAK;
             break;
         case PF_FILL:
             rCommand.m_bCommand = DMUS_COMMANDT_FILL;
             break;
         default:
             rCommand.m_bCommand = DMUS_COMMANDT_GROOVE;
         }
         switch (iCommand.dwCommand & PF_GROOVE)
         {
         case PF_A:
             rCommand.m_bGrooveLevel = 12;
             break;
         case PF_B:
             rCommand.m_bGrooveLevel = 37;
             break;
         case PF_C:
             rCommand.m_bGrooveLevel = 62;
             break;
         case PF_D:
             rCommand.m_bGrooveLevel = 87;
             break;
         default:
             rCommand.m_bGrooveLevel = 0;
         }
         rCommand.m_bGrooveRange = 0;
         rCommand.m_bRepeatMode = DMUS_PATTERNT_RANDOM;

        CommandList.AddTail(pCommand);
    }
ON_ERR:
    return hr;
}

HRESULT CDMSection::LoadStyleReference( LPSTREAM pStream, MMCKINFO* pck)
{
    HRESULT hr;
    DWORD   cb;
    DWORD    cSize;
    //char    szName[40];
    wchar_t    wstrName[40];
    //IAALoader* pLoader;

    cSize = min( pck->cksize, sizeof( wstrName ) );
    hr = pStream->Read( wstrName, cSize, &cb );
    if( FAILED( hr ) || cb != cSize )
    {
        return E_FAIL;
    }
    m_strStyleName = wstrName;
    DMUS_OBJECTDESC ObjectDescript;
    ObjectDescript.dwSize = sizeof(DMUS_OBJECTDESC);
    ObjectDescript.guidClass = CLSID_DirectMusicStyle;
    wcscpy(ObjectDescript.wszName, wstrName);
    ObjectDescript.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_NAME;
    IDirectMusicLoader* pLoader;
    IDirectMusicGetLoader *pIGetLoader;  // <==============
    hr = pStream->QueryInterface( IID_IDirectMusicGetLoader, (void **) &pIGetLoader );// <========
    if (SUCCEEDED(hr))
    {
        hr = pIGetLoader->GetLoader(&pLoader);  // <========
        if (SUCCEEDED(hr))                      // <========
        {                                       // <========
            hr = pLoader->GetObject(&ObjectDescript, IID_IDirectMusicStyle, (void**)&m_pStyle);
            pLoader->Release();
        }                                       // <========
        pIGetLoader->Release();                 // <========
    }
    return hr;
}



HRESULT CDMSection::LoadSection( IAARIFFStream* pRIFF, MMCKINFO* pckMain )
{
    HRESULT     hr = S_OK;
    HRESULT     hrBand = S_OK;
    ioSection   iSection;
    MMCKINFO    ck;
    DWORD        cb;
    DWORD        cSize;
    IStream*    pStream;
    BOOL        fLoadedSection = FALSE;

    pStream = pRIFF->GetStream();
    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
        case FOURCC_SECTION:
            cSize = min( ck.cksize, sizeof( iSection ) );
            hr = pStream->Read( &iSection, cSize, &cb );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOSECTION, &iSection );

            m_strName = iSection.wstrName;
            m_dwTime = iSection.lTime;
            m_wTempo = iSection.wTempo;
            // wRepeats refers to repeats after the first play.
            m_wRepeats = iSection.wRepeats;
            m_wMeasureLength = iSection.wMeasureLength;
            m_wClocksPerMeasure = ConvertTime(iSection.wClocksPerMeasure);
            m_wClocksPerBeat = ConvertTime(iSection.wClocksPerBeat);
            m_wTempoFract = iSection.wTempoFract;
            m_dwFlags = iSection.dwFlags;
            m_bRoot = (char)( iSection.chKey & ~KEY_FLAT );
            m_dwClockLength = (long)m_wMeasureLength * (long)m_wClocksPerMeasure;

            fLoadedSection = TRUE;
            break;
        case FOURCC_STYLEREF:
            if( fLoadedSection )
            {
                hr = LoadStyleReference( pStream, &ck );
                if (hr != S_OK)
                {
                    hrBand = hr;
                }
                if( FAILED( hr ) )
                {
                    goto ON_ERR;
                }
            }
            break;

        case FOURCC_RIFF:
            switch(ck.fccType)
            {
                case FOURCC_BAND_FORM:
                {
                    // Create a band
                    hr = CoCreateInstance(CLSID_DirectMusicBand,
                                          NULL,
                                          CLSCTX_INPROC,
                                          IID_IDirectMusicBand,
                                          (void**)&m_pIDMBand);

                    if(SUCCEEDED(hr))
                    {
                        // Seek back to begining of Riff chunk
                        // This is the amount read by Descend when descending into a FOURCC_RIFF chunk
                        // Get current position
                        LARGE_INTEGER li;
                        ULARGE_INTEGER ul;
                        li.HighPart = 0;
                        li.LowPart = 0;
                        hr = pStream->Seek(li,
                                           STREAM_SEEK_CUR,
                                           &ul);

                        if(SUCCEEDED(hr))
                        {
                            li.HighPart = 0;
                            // This is always a valid operation
                            li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
                            hr = pStream->Seek(li,
                                               STREAM_SEEK_SET,
                                               &ul);
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load band
                        IPersistStream* pIPersistStream;
                        hr = m_pIDMBand->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                        if(SUCCEEDED(hr))
                        {
                            hr = pIPersistStream->Load(pStream);
                            if (hr != S_OK)
                            {
                                hrBand = hr;
                            }
                            pIPersistStream->Release();
                        }
                    }

                    if(FAILED(hr))
                    {
                        goto ON_ERR;
                    }
                }
                break;
            }
            break;

        case FOURCC_CHORD:
            if( fLoadedSection )
            {
                hr = LoadChordList( pStream, &ck, m_ChordList );
                if( FAILED( hr ) )
                {
                    goto ON_ERR;
                }
            }
            break;
        case FOURCC_COMMAND:
            if( fLoadedSection )
            {
                hr = LoadCommandList( pStream, &ck, m_CommandList );
                if( FAILED( hr ) )
                {
                    goto ON_ERR;
                }
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }


ON_ERR:
    if( FAILED( hr ) )
    {

        if(m_pIDMBand != NULL)
        {
            if(m_pIDMBand)
            {
                m_pIDMBand->Release();
            }
            m_pIDMBand = NULL;
        }

    }
    pStream->Release( );
    if (hr == S_OK && hrBand != S_OK)
    {
        hr = hrBand;
    }
    return hr;
}

HRESULT CDMSection::Load(
                        LPSTREAM pStream )    // Pointer to a stream that contains the
                                            // Section information to load.
{
    DWORD dwPos;
    IAARIFFStream*  pRIFF;
    MMCKINFO        ckMain;
    HRESULT         hr;

    if ( pStream == NULL ) return E_INVALIDARG;
    hr = E_FAIL;
    CleanUp( FALSE );

    dwPos = StreamTell( pStream );

    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = FOURCC_SECTION_FORM;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = LoadSection( pRIFF, &ckMain );
            pRIFF->Ascend( &ckMain, 0 );
        }
        pRIFF->Release( );
    }
    return hr;
}



DMChord::DMChord(DMUS_CHORD_PARAM& DMC)
{
    m_strName = DMC.wszName;
    m_wMeasure = DMC.wMeasure;
    m_bBeat = DMC.bBeat;
    m_bKey = DMC.bKey;
    m_dwScale = DMC.dwScale;
    m_fSilent = (DMC.bFlags & DMUS_CHORDKEYF_SILENT) ? true : false;
    for (BYTE n = 0; n < DMC.bSubChordCount; n++)
    {
        TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>(DMC.SubChordList[n]);
        if (pSub)
        {
            m_SubChordList.AddTail(pSub);
        }
    }
}

DMChord::DMChord(DMChord& DMC)
{
    m_strName = DMC.m_strName;
    m_wMeasure = DMC.m_wMeasure;
    m_bBeat = DMC.m_bBeat;
    m_bKey = DMC.m_bKey;
    m_dwScale = DMC.m_dwScale;
    m_fSilent = DMC.m_fSilent;
    TListItem<DMSubChord>* pScan = DMC.m_SubChordList.GetHead();
    for (; pScan != NULL; pScan = pScan->GetNext())
    {
        TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>(pScan->GetItemValue());
        if (pSub)
        {
            m_SubChordList.AddTail(pSub);
        }
    }
}

DMChord& DMChord::operator=(const DMChord& DMC)
{
    if (this != &DMC)
    {
        m_strName = DMC.m_strName;
        m_wMeasure = DMC.m_wMeasure;
        m_bBeat = DMC.m_bBeat;
        m_bKey = DMC.m_bKey;
        m_dwScale = DMC.m_dwScale;
        m_fSilent = DMC.m_fSilent;
        m_SubChordList.CleanUp();
        TListItem<DMSubChord>* pScan = DMC.m_SubChordList.GetHead();
        for (; pScan != NULL; pScan = pScan->GetNext())
        {
            TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>(pScan->GetItemValue());
            if (pSub)
            {
                m_SubChordList.AddTail(pSub);
            }
        }
    }
    return *this;
}

DMChord::operator DMUS_CHORD_PARAM()
{
    DMUS_CHORD_PARAM result;
    wcscpy(result.wszName, m_strName);
    result.wMeasure = m_wMeasure;
    result.bBeat = m_bBeat;
    result.bKey = m_bKey;
    result.dwScale = m_dwScale;
    result.bFlags = 0;
    if (m_fSilent) result.bFlags |= DMUS_CHORDKEYF_SILENT;
    BYTE n = 0;
    TListItem<DMSubChord>* pSub = m_SubChordList.GetHead();
    for (; pSub != NULL; pSub = pSub->GetNext(), n++)
    {
        result.SubChordList[n] = pSub->GetItemValue();
    }
    result.bSubChordCount = n;
    return result;
}

HRESULT DMChord::Save( IAARIFFStream* pRIFF )
{
    IStream*    pStream;
    MMCKINFO    ck;
    DWORD       cb;
    DMUS_IO_CHORD    iChord;
    DMUS_IO_SUBCHORD    iSubChord;
    DWORD        dwSize;
    HRESULT hr = E_FAIL;

    pStream = pRIFF->GetStream();
    ck.ckid = mmioFOURCC('c', 'r', 'd', 'b');
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        memset( &iChord, 0, sizeof( iChord ) );
        m_strName = iChord.wszName;
        //MultiByteToWideChar( CP_ACP, 0, m_strName, -1, iChord.wszName, sizeof( iChord.wszName ) / sizeof( wchar_t ) );
        iChord.mtTime = m_mtTime;
        iChord.wMeasure = m_wMeasure;
        iChord.bBeat = m_bBeat;
        iChord.bFlags = 0;
        if (m_fSilent) iChord.bFlags |= DMUS_CHORDKEYF_SILENT;
        dwSize = sizeof( iChord );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( SUCCEEDED(hr) &&
            SUCCEEDED( pStream->Write( &iChord, sizeof( iChord), &cb ) ) &&
            cb == sizeof( iChord) ) // &&
            //pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            //ck.ckid = mmioFOURCC('s', 'u', 'b', 'c');
            //if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
            {
                DWORD dwCount = (WORD) m_SubChordList.GetCount();
                hr = pStream->Write( &dwCount, sizeof( dwCount ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                dwSize = sizeof( iSubChord );
                hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                for (TListItem<DMSubChord>* pSub = m_SubChordList.GetHead(); pSub != NULL; pSub = pSub->GetNext())
                {
                    DMSubChord& rSubChord = pSub->GetItemValue();
                    memset( &iSubChord, 0, sizeof( iSubChord ) );
                    iSubChord.dwChordPattern = rSubChord.m_dwChordPattern;
                    iSubChord.dwScalePattern = rSubChord.m_dwScalePattern;
                    iSubChord.dwInversionPoints = rSubChord.m_dwInversionPoints;
                    iSubChord.dwLevels = rSubChord.m_dwLevels;
                    iSubChord.bChordRoot = rSubChord.m_bChordRoot;
                    iSubChord.bScaleRoot = rSubChord.m_bScaleRoot;
                    if( FAILED( pStream->Write( &iSubChord, sizeof( iSubChord ), &cb ) ) ||
                        cb != sizeof( iSubChord ) )
                    {
                        break;
                    }
                }
                // ascend from chord body chunk
                if( pSub == NULL &&
                    pRIFF->Ascend( &ck, 0 ) != 0 )
                {
                    hr = S_OK;
                }
            }
        }
    }
    pStream->Release();
    return hr;
}


HRESULT CDMSection::SaveChordList( IAARIFFStream* pRIFF )
{
    IStream*    pStream;
    //LPSECT      pSection;
    MMCKINFO    ck;
    MMCKINFO    ckHeader;
    HRESULT     hr;
    DWORD       cb;
    //WORD        wSize;
    TListItem<DMChord>*   pChord;
    //int         i;


    pStream = pRIFF->GetStream();
    //pSection = (LPSECT)m_pSection->lpDLL1;

    ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
    hr = pRIFF->CreateChunk(&ck, MMIO_CREATELIST);
    if (SUCCEEDED(hr))
    {
       // wSize = sizeof( ioChordSelection );
        //FixBytes( FBT_SHORT, &wSize );
       // hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
       // if( FAILED( hr ) || cb != sizeof( wSize ) )
       // {
       //     RELEASE( pStream );
       //     return E_FAIL;
        //}

        DWORD dwRoot = m_bRoot;
        DWORD dwScale = DEFAULT_SCALE_PATTERN | (dwRoot << 24);

        ckHeader.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
        hr = pRIFF->CreateChunk(&ckHeader, 0);
        if (FAILED(hr))
        {
            pStream->Release();
            return hr;
        }
        hr = pStream->Write( &dwScale, sizeof( dwScale ), &cb );
        if (FAILED(hr))
        {
            pStream->Release();
            return hr;
        }
        hr = pRIFF->Ascend( &ckHeader, 0 );
        if (hr != S_OK)
        {
            pStream->Release();
            return hr;
        }

        for( pChord = m_ChordList.GetHead() ; pChord != NULL ; pChord = pChord->GetNext() )
        {
            hr = pChord->GetItemValue().Save(pRIFF);
            if (FAILED(hr))
            {
                pStream->Release();
                return hr;
            }
        }
        if( pChord == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}


HRESULT CDMSection::SaveCommandList( IAARIFFStream* pRIFF )
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD       dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<DMCommand>* pCommand;

    pStream = pRIFF->GetStream();
    if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            DMCommand& rCommand = pCommand->GetItemValue();
            memset( &iCommand, 0, sizeof( iCommand ) );
            iCommand.mtTime = rCommand.m_mtTime;
            iCommand.wMeasure = rCommand.m_wMeasure;
            iCommand.bBeat = rCommand.m_bBeat;
            iCommand.bCommand = rCommand.m_bCommand;
            iCommand.bGrooveLevel = rCommand.m_bGrooveLevel;
             iCommand.bGrooveRange = rCommand.m_bGrooveRange;
             iCommand.bRepeatMode = rCommand.m_bRepeatMode;
            if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                cb != sizeof( iCommand ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}


HRESULT CDMSection::Save(
                        LPSTREAM pStream,        // Stream to store Section.
                        BOOL /*fClearDirty*/ )    // TRUE to clear dirty flag, FALSE to leave
                                                // dirty flag unchanged.
{
    IAARIFFStream*  pRIFF;
    HRESULT         hr;
    MMCKINFO        ckMain;

    hr = E_FAIL;
    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = FOURCC_SECTION_FORM;
        if( pRIFF->CreateChunk( &ckMain, MMIO_CREATERIFF ) != 0 )
        {
            goto ON_ERR;
        }

        if( FAILED( SaveChordList( pRIFF ) ) ||
            FAILED( SaveCommandList( pRIFF ) ) )
        {
            goto ON_ERR;
        }

        if( pRIFF->Ascend( &ckMain, 0 ) != 0 )
        {
            goto ON_ERR;
        }
        hr = S_OK;
ON_ERR:
        pRIFF->Release();
    }
    return hr;
}


/* IPersist methods */
 HRESULT CDMSection::GetClassID( LPCLSID pclsid )
{
    return E_NOTIMPL;
}

 HRESULT CDMSection::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CDMSection::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmpublic.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       dmpublic.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// DMPublic: things that will eventually end up in dmusici.h or dmusicf.h

#ifndef __DMPUBLIC_H_
#define __DMPUBLIC_H_

#include "dmusicf.h"

// These should live in dmusici.h
#endif // __DMPUBLIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmstydll.cpp ===
//
// dmstydll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as Class Factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "debug.h"

#include "..\shared\oledll.h"

#include <initguid.h>
#include "dmusici.h"
#include "DMStyleP.h"
#include "dmstyle.h"
#include "dmsect.h"
#include "chordtrk.h"
#include "cmmdtrk.h"
#include "styletrk.h"
#include "motiftrk.h"
#include "audtrk.h"
#include "mutetrk.h"
#include "mgentrk.h"
#include "..\dmband\dmbndtrk.h"
#include "..\shared\Validate.h"
#include "..\shared\dmscriptautguids.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Version information
//
TCHAR g_szStyleFriendlyName[]    = TEXT("DirectMusicStyle");
TCHAR g_szStyleVerIndProgID[]    = TEXT("Microsoft.DirectMusicStyle");
TCHAR g_szStyleProgID[]          = TEXT("Microsoft.DirectMusicStyle.1");

TCHAR g_szSectionFriendlyName[]    = TEXT("DirectMusicSection");
TCHAR g_szSectionVerIndProgID[]    = TEXT("Microsoft.DirectMusicSection");
TCHAR g_szSectionProgID[]          = TEXT("Microsoft.DirectMusicSection.1");

TCHAR g_szChordTrackFriendlyName[]    = TEXT("DirectMusicChordTrack");
TCHAR g_szChordTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordTrack");
TCHAR g_szChordTrackProgID[]          = TEXT("Microsoft.DirectMusicChordTrack.1");

TCHAR g_szCommandTrackFriendlyName[]    = TEXT("DirectMusicCommandTrack");
TCHAR g_szCommandTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicCommandTrack");
TCHAR g_szCommandTrackProgID[]          = TEXT("Microsoft.DirectMusicCommandTrack.1");

TCHAR g_szStyleTrackFriendlyName[]    = TEXT("DirectMusicStyleTrack");
TCHAR g_szStyleTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicStyleTrack");
TCHAR g_szStyleTrackProgID[]          = TEXT("Microsoft.DirectMusicStyleTrack.1");

TCHAR g_szMotifTrackFriendlyName[]    = TEXT("DirectMusicMotifTrack");
TCHAR g_szMotifTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMotifTrack");
TCHAR g_szMotifTrackProgID[]          = TEXT("Microsoft.DirectMusicMotifTrack.1");

TCHAR g_szMuteTrackFriendlyName[]    = TEXT("DirectMusicMuteTrack");
TCHAR g_szMuteTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMuteTrack");
TCHAR g_szMuteTrackProgID[]          = TEXT("Microsoft.DirectMusicMuteTrack.1");

TCHAR g_szAuditionTrackFriendlyName[]    = TEXT("DirectMusicAuditionTrack");
TCHAR g_szAuditionTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicAuditionTrack");
TCHAR g_szAuditionTrackProgID[]          = TEXT("Microsoft.DirectMusicAuditionTrack.1");

TCHAR g_szMelGenTrackFriendlyName[]    = TEXT("DirectMusicMelodyFormulationTrack");
TCHAR g_szMelGenTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMelodyFormulationTrack");
TCHAR g_szMelGenTrackProgID[]          = TEXT("Microsoft.DirectMusicMelodyFormulationTrack.1");

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::QueryInterface

HRESULT __stdcall
CDirectMusicStyleFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicStyleFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::AddRef

ULONG __stdcall
CDirectMusicStyleFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::Release

ULONG __stdcall
CDirectMusicStyleFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::CreateInstance

HRESULT __stdcall
CDirectMusicStyleFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMStyle *pDM;
    
    try
    {
        pDM = new CDMStyle;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::LockServer

HRESULT __stdcall
CDirectMusicStyleFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::QueryInterface

HRESULT __stdcall
CDirectMusicSectionFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicSectionFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::AddRef

ULONG __stdcall
CDirectMusicSectionFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::Release

ULONG __stdcall
CDirectMusicSectionFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::CreateInstance

HRESULT __stdcall
CDirectMusicSectionFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMSection *pDM = new CDMSection;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::LockServer

HRESULT __stdcall
CDirectMusicSectionFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicStyleTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicStyleTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::AddRef

ULONG __stdcall
CDirectMusicStyleTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::Release

ULONG __stdcall
CDirectMusicStyleTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicStyleTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CStyleTrack *pDM;
    
    try
    {
        pDM = new CStyleTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicStyleTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicCommandTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicCommandTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::AddRef

ULONG __stdcall
CDirectMusicCommandTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::Release

ULONG __stdcall
CDirectMusicCommandTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicCommandTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CCommandTrack *pDM;
    try
    {
        pDM = new CCommandTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicCommandTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicChordTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicChordTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::AddRef

ULONG __stdcall
CDirectMusicChordTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::Release

ULONG __stdcall
CDirectMusicChordTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicChordTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CChordTrack *pDM;
    
    try
    {
        pDM = new CChordTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicChordTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicMotifTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicMotifTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::AddRef

ULONG __stdcall
CDirectMusicMotifTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::Release

ULONG __stdcall
CDirectMusicMotifTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicMotifTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CMotifTrack *pDM;
    
    try
    {
        pDM = new CMotifTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicMotifTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicMuteTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicMuteTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::AddRef

ULONG __stdcall
CDirectMusicMuteTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::Release

ULONG __stdcall
CDirectMusicMuteTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicMuteTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CMuteTrack *pDM;
    
    try
    {
        pDM = new CMuteTrack;
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicMuteTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicAuditionTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicAuditionTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::AddRef

ULONG __stdcall
CDirectMusicAuditionTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::Release

ULONG __stdcall
CDirectMusicAuditionTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicAuditionTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CAuditionTrack *pDM;
    
    try
    {
        pDM = new CAuditionTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicAuditionTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicMelodyFormulationTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicMelodyFormulationTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::AddRef

ULONG __stdcall
CDirectMusicMelodyFormulationTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::Release

ULONG __stdcall
CDirectMusicMelodyFormulationTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicMelodyFormulationTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CMelodyFormulationTrack *pDM;

    try
    {
        pDM = new CMelodyFormulationTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicMelodyFormulationTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusicStyle)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicStyleFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DMSection) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicSectionFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicChordTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicChordTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicCommandTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicCommandTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicStyleTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicStyleTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicMotifTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicMotifTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicMuteTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicMuteTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicAuditionTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicAuditionTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicMelodyFormulationTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicMelodyFormulationTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicStyle,
                     g_szStyleFriendlyName,
                     g_szStyleVerIndProgID,
                     g_szStyleProgID);

    UnregisterServer(CLSID_DMSection,
                     g_szSectionFriendlyName,
                     g_szSectionVerIndProgID,
                     g_szSectionProgID);

    UnregisterServer(CLSID_DirectMusicChordTrack,
                     g_szChordTrackFriendlyName,
                     g_szChordTrackVerIndProgID,
                     g_szChordTrackProgID);

    UnregisterServer(CLSID_DirectMusicCommandTrack,
                     g_szCommandTrackFriendlyName,
                     g_szCommandTrackVerIndProgID,
                     g_szCommandTrackProgID);

    UnregisterServer(CLSID_DirectMusicStyleTrack,
                     g_szStyleTrackFriendlyName,
                     g_szStyleTrackVerIndProgID,
                     g_szStyleTrackProgID);

    UnregisterServer(CLSID_DirectMusicMotifTrack,
                     g_szMotifTrackFriendlyName,
                     g_szMotifTrackVerIndProgID,
                     g_szMotifTrackProgID);

    UnregisterServer(CLSID_DirectMusicMuteTrack,
                     g_szMuteTrackFriendlyName,
                     g_szMuteTrackVerIndProgID,
                     g_szMuteTrackProgID);

    UnregisterServer(CLSID_DirectMusicAuditionTrack,
                     g_szAuditionTrackFriendlyName,
                     g_szAuditionTrackVerIndProgID,
                     g_szAuditionTrackProgID);

	UnregisterServer(CLSID_DirectMusicMelodyFormulationTrack,
                     g_szMelGenTrackFriendlyName,
                     g_szMelGenTrackVerIndProgID,
                     g_szMelGenTrackProgID);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicStyle,
                     g_szStyleFriendlyName,
                     g_szStyleVerIndProgID,
                     g_szStyleProgID);

    RegisterServer(g_hModule,
                   CLSID_DMSection,
                     g_szSectionFriendlyName,
                     g_szSectionVerIndProgID,
                     g_szSectionProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordTrack,
                     g_szChordTrackFriendlyName,
                     g_szChordTrackVerIndProgID,
                     g_szChordTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicCommandTrack,
                     g_szCommandTrackFriendlyName,
                     g_szCommandTrackVerIndProgID,
                     g_szCommandTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicStyleTrack,
                     g_szStyleTrackFriendlyName,
                     g_szStyleTrackVerIndProgID,
                     g_szStyleTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicMotifTrack,
                     g_szMotifTrackFriendlyName,
                     g_szMotifTrackVerIndProgID,
                     g_szMotifTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicMuteTrack,
                     g_szMuteTrackFriendlyName,
                     g_szMuteTrackVerIndProgID,
                     g_szMuteTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicAuditionTrack,
                     g_szAuditionTrackFriendlyName,
                     g_szAuditionTrackVerIndProgID,
                     g_szAuditionTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicMelodyFormulationTrack,
                     g_szMelGenTrackFriendlyName,
                     g_szMelGenTrackVerIndProgID,
                     g_szMelGenTrackProgID);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

            }
			break;


#ifdef DBG
        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
#endif
            
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\fileio.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       fileio.cpp
//
//--------------------------------------------------------------------------

// FileIO.cpp
//

#include "aariff.h"

STDAPI AllocFileStream(LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream)
{
    HANDLE          hfile;          // handle to open file
    CFileStream *   pstream;        // IStream implementation

    // in case of error...
    *ppstream = NULL;

    // open the file
    if( dwDesiredAccess == GENERIC_READ )
    {
        hfile = CreateFile( szFileName, dwDesiredAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else if( dwDesiredAccess == GENERIC_WRITE )
    {
        hfile = CreateFile( szFileName, dwDesiredAccess, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else
    {
        return E_INVALIDARG;
    }
    if( hfile == INVALID_HANDLE_VALUE )
    {
        //DisplayDebug( 5, "File open error: Can't open \"%s\", error code %d", szFileName, GetLastError() );
        return E_FAIL; // to do: real error code
    }

    // create the Windows object
    if ((pstream = new CFileStream(hfile)) == NULL)
        return E_OUTOFMEMORY;

    // return an IStream pointer
    *ppstream = (IStream *) pstream;
    return S_OK;
}

STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff )
{
    if( ( *ppRiff = (IAARIFFStream*) new CRIFFStream( pStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


/* MyRead, MyWrite, MySeek
 *
 * These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
 * except for the absence of the HMMIO parameter.
 */

long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}

long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}

long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    /* figure out what chunk id and form/list type to search for */
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        /* read the chunk header */
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;
        FixBytes( FBT_LONG, &lpck->cksize );

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by CreateChunk();
         * check that the chunk size that was written when
         * CreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            /* chunk size is odd -- write a null pad byte */
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        FixBytes( FBT_LONG, &lpck->cksize );
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))  {
        	FixBytes( FBT_LONG, &lpck->cksize );
            return MMIOERR_CANNOTWRITE;
        }
        FixBytes( FBT_LONG, &lpck->cksize );
    }

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    /* store the offset of the data part of the chunk */
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    /* write the chunk header */
	FixBytes( FBT_MMCKINFO, lpck );
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)  {
    	FixBytes( FBT_MMCKINFO, lpck );
        return MMIOERR_CANNOTWRITE;
    }
    FixBytes( FBT_MMCKINFO, lpck );

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmstyle.cpp ===
//
// DMStyle.cpp : Implementation of CDMStyle
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "DMStyle.h"
#include "score.h"

#include "..\dmband\dmbandp.h"
#include "..\shared\Validate.h"
#include <mmreg.h>
#include "dmsect.h"
#include "ptrntrk.h"
#include "StyleTrk.h"
#include "..\shared\dmscriptautguids.h"

V_INAME(DMStyle)

#define NBR_VARIATIONS 32
#define DX8_PART_SIZE 160
#define DX8_PARTREF_SIZE 28

DirectMusicTimeSig DefaultTimeSig(4, 4, 4);

static char achMappings[128] = {
         0,         //0 },
         35,        //1  },
         36,        //2  },
         38,        //3  },
         40,        //4  },
         41,        //5  },
         45,        //6  },
         48,        //7  },
         42,        //8  },
         44,        //9  },
         46,        //10 },
         39,        //11 },
         37,        //12 },
         51,        //13 },
         49,        //14 },
         54,        //15 },
         56,        //16 },
         61,        //17 },
         60,        //18 },
         64,        //19 },
         63,        //20 },
         66,        //21 },
         65,        //22 },
         69,        //23 },
         70,        //24 },
         71,        //25 },
         72,        //26 },
         73,        //27 },
         75,        //28 },
         47,        //29 },
         50,        //30 },
         53,        //31 },
         57,        //32 },
         52,        //33 },
         74,        //34 },
         35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
         55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
         75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
         95, 96, 97, 98,
         87,        //99 },
         86,        //100 },
         85,        //101 },
         84,        //102 },
         83,        //103 },
         82,        //104 },
         81,        //105 },
         80,        //106 },
         79,        //107 },
         78,        //108 },
         77,        //109 },
         76,        //110 },
         68,        //111 },
         67,        //112 },
         62,        //113 },
         59,        //114 },
         58,        //115 },
         55,        //116 },
         43,        //117 },
         34,        //118 },
         33,        //119 },
         32,        //120 },
         31,        //121 },
         30,        //122 },
         29,        //123 },
         28,        //124 },
         27,        //125 },
         26,        //126 },
         25,        //127 }
};

/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

HRESULT ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, String& pstrText )
{
    HRESULT     hr = S_OK;
    wchar_t*    wstrText = NULL;
    DWORD       dwBytesRead;
    DWORD       dwLength = dwSize / sizeof(WCHAR);
    if (dwLength * sizeof(WCHAR) != dwSize)
    {
        // Funky size that will result in a small (less than sizeof(WCHAR)) overrun 
        // So adjust the length accordingly
        dwLength++;
    }

    pstrText = "";

    wstrText = new wchar_t[dwLength + 1]; // make sure we have room for a null terminator
    if( wstrText == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERR;
    }

    hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
    wstrText[dwLength] = 0;
    if( FAILED( hr ) ||  dwBytesRead != dwSize )
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        goto ON_ERR;
    }

    pstrText = wstrText;

ON_ERR:
    if( wstrText )
    {
        delete [] wstrText;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SaveMBStoWCS

HRESULT SaveMBStoWCS( IStream* pIStream, String* pstrText )
{
    HRESULT     hr = S_OK;
    wchar_t*    wstrText = NULL;
    DWORD       dwLength;
    DWORD       dwBytesWritten;

    if( pstrText == NULL )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }

    dwLength = pstrText->GetLength() + 1;
    wstrText = new wchar_t[dwLength];
    if( wstrText == NULL )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }

     wcscpy(wstrText, *pstrText);
    dwLength *= sizeof(wchar_t);

    hr = pIStream->Write( wstrText, dwLength, &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != dwLength )
    {
        goto ON_ERR;
    }

ON_ERR:
    if( wstrText )
        delete [] wstrText;
    return hr;
}

DirectMusicPart::DirectMusicPart(DirectMusicTimeSig *pTimeSig) :
    m_cRef(1),
    m_wNumMeasures(1),
    m_bPlayModeFlags(DMUS_PLAYMODE_NORMALCHORD),
    m_bInvertLower(0),
    m_bInvertUpper(127),
    m_dwFlags(0)
{
    memset(&m_guidPartID, 0, sizeof(GUID));

    if (pTimeSig)
    {
        m_timeSig = *pTimeSig;
    }

    for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
    {
        m_dwVariationChoices[i] = 0;
    }

}

STDMETHODIMP_(ULONG) DirectMusicPart::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) DirectMusicPart::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_LoadPart

HRESULT DirectMusicPart::DM_LoadPart(
        IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwByteCount;
    long lSize;
    DWORD dwStructSize;
    WORD wExtra;

    if( pStyle == NULL ) return E_INVALIDARG;

    pIStream = pIRiffStream->GetStream();
    if( pIStream == NULL ) return E_FAIL;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_PART_CHUNK:
            {
                DMUS_IO_STYLEPART iDMStylePart;
                memset(&iDMStylePart, 0, sizeof(iDMStylePart));

                lSize = min( ck.cksize, sizeof( DMUS_IO_STYLEPART ) );
                if (ck.cksize >= DX8_PART_SIZE) pStyle->m_dwFlags |= STYLEF_USING_DX8;
                hr = pIStream->Read( &iDMStylePart, lSize, &dwByteCount );
                if( FAILED( hr ) ||  (long)dwByteCount != lSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                if( pStyle->FindPartByGUID( iDMStylePart.guidPartID ) )
                {
                    hr = S_FALSE;   // Style already contains a Part with this GUID
                    goto ON_ERROR;  // so we must bypass this Part
                }

                m_timeSig.m_bBeatsPerMeasure = iDMStylePart.timeSig.bBeatsPerMeasure;
                m_timeSig.m_bBeat = iDMStylePart.timeSig.bBeat;
                m_timeSig.m_wGridsPerBeat = iDMStylePart.timeSig.wGridsPerBeat;

                m_wNumMeasures = iDMStylePart.wNbrMeasures;
                m_bInvertUpper = iDMStylePart.bInvertUpper;
                m_bInvertLower = iDMStylePart.bInvertLower;
                m_bPlayModeFlags = iDMStylePart.bPlayModeFlags;
                m_dwFlags = iDMStylePart.dwFlags;

                memcpy( &m_guidPartID, &iDMStylePart.guidPartID, sizeof(GUID) );
                memcpy( &m_dwVariationChoices, &iDMStylePart.dwVariationChoices, sizeof(m_dwVariationChoices) );

                for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
                {
                    if( m_dwVariationChoices[i] == 0xFFFFFFFF )
                    {
                        m_dwVariationChoices[i] = 0x3FFFFFFF;
                    }
                    if (pStyle->UsingDX8() && m_dwVariationChoices[i] == 0x3FFFFFFF)
                    {
                        m_dwVariationChoices[i] = 0x7FFFFFFF;
                    }
                }
                break;
            }

            case DMUS_FOURCC_NOTE_CHUNK:
            {
                CDMStyleNote* pNote;
                DMUS_IO_STYLENOTE iDMStyleNote;
                memset(&iDMStyleNote, 0, sizeof(DMUS_IO_STYLENOTE));

                lSize = ck.cksize;

                // Read size of the note structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLENOTE ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLENOTE ) );
                    dwStructSize = sizeof( DMUS_IO_STYLENOTE );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the notes
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleNote, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Note (if note event is legal)
                    if (iDMStyleNote.mtGridStart >= 0)
                    {
                        pNote = new CDMStyleNote;
                        if( pNote )
                        {
                            pNote->m_nGridStart = (short)iDMStyleNote.mtGridStart;
                            pNote->m_dwVariation = iDMStyleNote.dwVariation;
                            pNote->m_mtDuration = iDMStyleNote.mtDuration;
                            pNote->m_nTimeOffset = iDMStyleNote.nTimeOffset;

                            pNote->m_wMusicValue = iDMStyleNote.wMusicValue;
                            pNote->m_bVelocity = iDMStyleNote.bVelocity;
                            pNote->m_bTimeRange = iDMStyleNote.bTimeRange;
                            pNote->m_bDurRange = iDMStyleNote.bDurRange;
                            pNote->m_bVelRange = iDMStyleNote.bVelRange;
                            pNote->m_bInversionId = iDMStyleNote.bInversionID;
                            pNote->m_bPlayModeFlags = iDMStyleNote.bPlayModeFlags;
                            pNote->m_bFlags = iDMStyleNote.bNoteFlags;

                            // Place note in Part's event list
                            EventList.AddHead( pNote );
                        }
                    }
                }
                break;
            }

            case DMUS_FOURCC_CURVE_CHUNK:
            {
                CDMStyleCurve* pCurve;
                DMUS_IO_STYLECURVE iDMStyleCurve;
                memset(&iDMStyleCurve, 0, sizeof(DMUS_IO_STYLECURVE));

                lSize = ck.cksize;

                // Read size of the curve structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLECURVE ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLECURVE ) );
                    dwStructSize = sizeof( DMUS_IO_STYLECURVE );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the curves
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleCurve, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Curve (if curve event is legal)
                    if (iDMStyleCurve.mtGridStart >= 0)
                    {
                        pCurve = new CDMStyleCurve;
                        if( pCurve )
                        {
                            pCurve->m_nGridStart = (short)iDMStyleCurve.mtGridStart;
                            pCurve->m_dwVariation = iDMStyleCurve.dwVariation;
                            pCurve->m_mtDuration = iDMStyleCurve.mtDuration;
                            pCurve->m_nTimeOffset = iDMStyleCurve.nTimeOffset;

                            pCurve->m_StartValue = iDMStyleCurve.nStartValue;
                            pCurve->m_EndValue = iDMStyleCurve.nEndValue;
                            pCurve->m_bEventType = iDMStyleCurve.bEventType;
                            pCurve->m_bCurveShape = iDMStyleCurve.bCurveShape;
                            pCurve->m_bCCData = iDMStyleCurve.bCCData;

                            pCurve->m_mtResetDuration = iDMStyleCurve.mtResetDuration;
                            pCurve->m_nResetValue = iDMStyleCurve.nResetValue;
                            pCurve->m_bFlags = iDMStyleCurve.bFlags;
                            // dx8 stuff
                            pCurve->m_wParamType = iDMStyleCurve.wParamType;
                            pCurve->m_wMergeIndex = iDMStyleCurve.wMergeIndex;
                            // Place curve in Part's event list
                            EventList.AddHead( pCurve );
                        }
                    }
                }
                break;
            }

            case DMUS_FOURCC_MARKER_CHUNK:
            {
                CDMStyleMarker* pMarker;
                DMUS_IO_STYLEMARKER iDMStyleMarker;
                memset(&iDMStyleMarker, 0, sizeof(DMUS_IO_STYLEMARKER));

                lSize = ck.cksize;

                // Read size of the marker structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLEMARKER ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLEMARKER ) );
                    dwStructSize = sizeof( DMUS_IO_STYLEMARKER );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the markers
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleMarker, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Marker (if marker event is legal)
                    if (iDMStyleMarker.mtGridStart >= 0)
                    {
                        pMarker = new CDMStyleMarker;
                        if( pMarker )
                        {
                            pMarker->m_nGridStart = (short)iDMStyleMarker.mtGridStart;
                            pMarker->m_dwVariation = iDMStyleMarker.dwVariation;
                            pMarker->m_nTimeOffset = 0; // ignore offsets
                            pMarker->m_wFlags = iDMStyleMarker.wMarkerFlags;
                            // Place marker in Part's event list
                            EventList.AddHead( pMarker );
                        }
                    }
                }
                break;
            }
            case DMUS_FOURCC_ANTICIPATION_CHUNK:
            {
                CDMStyleAnticipation* pAnticipation;
                DMUS_IO_STYLE_ANTICIPATION iDMStyleAnticipation;
                memset(&iDMStyleAnticipation, 0, sizeof(DMUS_IO_STYLE_ANTICIPATION));

                lSize = ck.cksize;

                // Read size of the anticipation structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLE_ANTICIPATION ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLE_ANTICIPATION ) );
                    dwStructSize = sizeof( DMUS_IO_STYLE_ANTICIPATION );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the markers
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleAnticipation, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Anticipation (if anticipation event is legal)
                    if (iDMStyleAnticipation.mtGridStart >= 0)
                    {
                        pAnticipation = new CDMStyleAnticipation;
                        if( pAnticipation )
                        {
                            pAnticipation->m_nGridStart = (short)iDMStyleAnticipation.mtGridStart;
                            pAnticipation->m_dwVariation = iDMStyleAnticipation.dwVariation;
                            pAnticipation->m_nTimeOffset = iDMStyleAnticipation.nTimeOffset;
                            pAnticipation->m_bTimeRange = iDMStyleAnticipation.bTimeRange;
                            // Place anticipation in Part's event list
                            EventList.AddHead( pAnticipation );
                        }
                    }
                }
                break;
            }
            case DMUS_FOURCC_RESOLUTION_CHUNK:
            {
                TListItem<DMUS_IO_STYLERESOLUTION>* pResolutionItem;
                DMUS_IO_STYLERESOLUTION iDMStyleResolution;
                memset(&iDMStyleResolution, 0, sizeof(DMUS_IO_STYLERESOLUTION));

                lSize = ck.cksize;

                // Read size of the resolution structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLERESOLUTION ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLERESOLUTION ) );
                    dwStructSize = sizeof( DMUS_IO_STYLERESOLUTION );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the resolutions
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleResolution, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music resolution
                    pResolutionItem = new TListItem<DMUS_IO_STYLERESOLUTION>;
                    if( pResolutionItem )
                    {
                        pResolutionItem->GetItemValue() = iDMStyleResolution;
                        // Place marker in Part's resolution list
                        m_ResolutionList.AddHead( pResolutionItem );
                    }
                }
                break;
            }
        }

        pIRiffStream->Ascend( &ck, 0 );

    }
    // Sort the Event List
    EventList.MergeSort(m_timeSig);

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDMStyle

STDMETHODIMP CDMStyle::QueryInterface(
    const IID &iid,   // Interface to query for
    void **ppv)       // The requested interface will be returned here
{
    V_INAME(CDMStyle::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicStyle)
    {
        *ppv = static_cast<IDirectMusicStyle*>(this);
    }
    else if (iid == IID_IDirectMusicStyle8)
    {
        *ppv = static_cast<IDirectMusicStyle8*>(this);
        m_StyleInfo.m_dwFlags |= STYLEF_USING_DX8;
    }
    else if (iid == IID_IDirectMusicStyle8P)
    {
        *ppv = static_cast<IDirectMusicStyle8P*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDMStyle)
    {
        *ppv = static_cast<IDMStyle*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMStyle::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMStyle::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMStyle::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMStyle::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicStyle;
    if (m_StyleInfo.m_fLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }
    if (m_StyleInfo.m_guid.Data1 || m_StyleInfo.m_guid.Data2)
    {
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
        pDesc->guidObject = m_StyleInfo.m_guid;
    }
    if (m_StyleInfo.m_strCategory)
    {
        pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
        wcsncpy(pDesc->wszCategory, m_StyleInfo.m_strCategory, DMUS_MAX_CATEGORY);
        pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = 0;
    }
    if (m_StyleInfo.m_strName)
    {
        pDesc->dwValidData |= DMUS_OBJ_NAME;
        wcsncpy(pDesc->wszName, m_StyleInfo.m_strName, DMUS_MAX_NAME);
        pDesc->wszName[DMUS_MAX_NAME - 1] = 0;
    }
    if (m_StyleInfo.m_dwVersionMS || m_StyleInfo.m_dwVersionLS)
    {
        pDesc->dwValidData |= DMUS_OBJ_VERSION;
        pDesc->vVersion.dwVersionMS = m_StyleInfo.m_dwVersionMS;
        pDesc->vVersion.dwVersionLS = m_StyleInfo.m_dwVersionLS;
    }
    return S_OK;
}

HRESULT CDMStyle::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMStyle::SetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_StyleInfo.m_guid = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            WCHAR wszTempName[DMUS_MAX_NAME];
            memcpy(wszTempName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME);
            wszTempName[DMUS_MAX_NAME - 1] = 0;
            m_StyleInfo.m_strName = wszTempName;
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            WCHAR wszTempCategory[DMUS_MAX_CATEGORY];
            memcpy(wszTempCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY);
            wszTempCategory[DMUS_MAX_CATEGORY - 1] = 0;
            m_StyleInfo.m_strCategory = wszTempCategory;
            dw |= DMUS_OBJ_CATEGORY;
        }
        if ( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_StyleInfo.m_dwVersionMS = pDesc->vVersion.dwVersionMS;
            m_StyleInfo.m_dwVersionLS = pDesc->vVersion.dwVersionLS;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & (~dw) )
        {
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CDMStyle::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMStyle::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

    IAARIFFStream*  pRIFF;
    MMCKINFO        ckMain;
    MMCKINFO        ck;
    ioStyle         iStyle;
    DWORD           cb;
    DWORD           cSize;
    HRESULT         hr = S_OK;
    DWORD           dwPos;
    BOOL fFoundFormat = FALSE;

    dwPos = StreamTell( pStream );

    // Check for Direct Music format
    hr = AllocRIFFStream( pStream, &pRIFF );
    if( SUCCEEDED( hr ) )
    {
        ckMain.fccType = DMUS_FOURCC_STYLE_FORM;

        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_ParseDescriptor( pRIFF, &ckMain, pDesc );
            fFoundFormat = TRUE;
        }
        pRIFF->Release();
        pRIFF = NULL;
    }
    else
    {
        return hr;
    }

    // Check for IMA 2.5 format
    if( fFoundFormat )
    {
        hr = S_OK;
    }
    else
    {
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

        hr = AllocRIFFStream( pStream, &pRIFF );
        if( SUCCEEDED( hr ) )
        {
            ckMain.fccType = FOURCC_STYLE_FORM;

            if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDRIFF ) != 0 )
            {
                pRIFF->Release();
                return DMUS_E_CHUNKNOTFOUND;
            }

            ck.ckid = FOURCC_STYLE;
            if( pRIFF->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) != 0 )
            {
                pRIFF->Release();
                return DMUS_E_CHUNKNOTFOUND;
            }

            cSize = min( ck.cksize, sizeof( iStyle ) );
            hr = pStream->Read( &iStyle, cSize, &cb );
            FixBytes( FBT_IOSTYLE, &iStyle );
            if( FAILED( hr ) || cb != cSize )
            {
                pRIFF->Release();
                return DMUS_E_CHUNKNOTFOUND;
            }

            pDesc->dwValidData = DMUS_OBJ_CLASS;
            pDesc->guidClass = CLSID_DirectMusicStyle;

            wcsncpy(pDesc->wszName, iStyle.wstrName, DMUS_MAX_NAME);
            if(pDesc->wszName[0])
            {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
                pDesc->wszName[16] = 0;
            }
            wcsncpy(pDesc->wszCategory, iStyle.wstrCategory, DMUS_MAX_CATEGORY);
            if(pDesc->wszCategory[0])
            {
                pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                pDesc->wszCategory[16] = 0;
            }
            if(iStyle.guid.Data1 || iStyle.guid.Data2 || iStyle.guid.Data3)
            {
                pDesc->guidObject = iStyle.guid;
                pDesc->dwValidData |= DMUS_OBJ_OBJECT;
            }
            pRIFF->Release();
        }
        else
        {
            return hr;
        }
    }

    return hr;
}

// Note: this needs to be called from inside a critical section.
HRESULT CDMStyle::CreateMotifSegment(CDirectMusicPattern* pPattern, IUnknown * * ppSegment,
                                     DWORD dwRepeats)
{
    HRESULT hr = S_OK;
    //1.  Create a Motif track.
    IDirectMusicTrack* pIMotifTrack = NULL;
    hr = ::CoCreateInstance(
        CLSID_DirectMusicMotifTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pIMotifTrack
        );
    if (SUCCEEDED(hr))
    {
        // 2. Set the Track's Motif
        DirectMusicTimeSig& TimeSig =
            pPattern->m_timeSig.m_bBeat == 0 ? m_StyleInfo.m_TimeSignature : pPattern->m_timeSig;
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->m_PartRefList.GetHead();
        for(; pPartRef != NULL; pPartRef = pPartRef->GetNext())
        {
            DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
            DirectMusicTimeSig& TS =
                pPart->m_timeSig.m_bBeat == 0 ? TimeSig : pPart->m_timeSig;
            pPart->EventList.MergeSort(TS);
        }
        IMotifTrack* pIMT;
        hr = pIMotifTrack->QueryInterface(IID_IMotifTrack, (void**)&pIMT);
        if (SUCCEEDED(hr))
        {
            IDirectMusicStyle* pIDMS = NULL;
            hr = ((IDMStyle*)this)->QueryInterface(IID_IDirectMusicStyle, (void**)&pIDMS);
            hr = pIMT->SetTrack(pIDMS, pPattern);
            pIDMS->Release();
            DWORD dwLength;
            dwLength = pPattern->m_wNumMeasures * TimeSig.ClocksPerMeasure();
            // 3. Create a secondary segment for the motif.
            IDirectMusicSegment *pISegment;
            hr = ::CoCreateInstance(
                CLSID_DirectMusicSegment,
                NULL,
                CLSCTX_INPROC,
                IID_IDirectMusicSegment,
                (void**)&pISegment
                );
            if (SUCCEEDED(hr) )
            {
                // 4. Initialize the segment appropriately.
                pISegment->SetLength(dwLength);
                if (pPattern->m_fSettings)
                {
                    pISegment->SetRepeats(pPattern->m_dwRepeats);
                    pISegment->SetDefaultResolution(pPattern->m_dwResolution);
                    pISegment->SetStartPoint(pPattern->m_mtPlayStart);
                    pISegment->SetLoopPoints(pPattern->m_mtLoopStart, pPattern->m_mtLoopEnd);
                }
                else
                {
                    pISegment->SetRepeats(dwRepeats);
                    pISegment->SetDefaultResolution(DMUS_SEGF_BEAT);
                }
                pISegment->InsertTrack(pIMotifTrack, 1);

                // create and insert a band track, if the motif references a band
                if (pPattern->m_pMotifBand)
                {
                    IDirectMusicTrack* pBandTrack = NULL;
                    hr = ::CoCreateInstance(
                        CLSID_DirectMusicBandTrack,
                        NULL,
                        CLSCTX_INPROC,
                        IID_IDirectMusicTrack,
                        (void**)&pBandTrack
                        );
                    if (SUCCEEDED(hr))
                    {
                        DMUS_BAND_PARAM DMBandParam;
                        DMBandParam.mtTimePhysical = -64;
                        DMBandParam.pBand = pPattern->m_pMotifBand;
                        hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
                        if (SUCCEEDED(hr))
                        {
                            pISegment->InsertTrack(pBandTrack, 1);
                        }
                        pBandTrack->Release(); // Release the AddRef from InsertTrack
                    }
                }

                // Note: the segment must release the track objects...
                if (SUCCEEDED(hr))
                {
                    IUnknown *pUnknown;
                    hr = pISegment->QueryInterface(IID_IUnknown, (void**)&pUnknown);
                    if (SUCCEEDED(hr))
                    {
                        *ppSegment = pUnknown;
                        pISegment->Release();
                    }
                }
            }
            pIMT->Release();
        }
        pIMotifTrack->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SaveSinglePattern

HRESULT CDirectMusicPattern::DM_SaveSinglePattern( IAARIFFStream* pIRiffStream )
{
    TList<DirectMusicPart*> PartList;
    TListItem<DirectMusicPartRef>* pPartRefItem;
    TListItem<DirectMusicPart*>* pPartItem;
    DirectMusicPart* pPart;
    HRESULT hr = S_OK;
    IStream* pIStream;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

// Save Pattern chunk
    hr = DM_SavePatternChunk( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }

// Save Pattern rhythm
    hr = DM_SavePatternRhythm( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }

/*// Save Pattern switch points
    hr = DM_SavePatternSwitchPoints( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }*/

// Save Pattern info
    hr = DM_SavePatternInfoList( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }

// Build list of Parts
    pPartRefItem = m_PartRefList.GetHead();
    for( ; pPartRefItem; pPartRefItem = pPartRefItem->GetNext() )
    {
        DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();
        if( rPartRef.m_pDMPart == NULL )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }

        for (pPartItem = PartList.GetHead(); pPartItem; pPartItem = pPartItem->GetNext())
        {
            if (pPartItem->GetItemValue() == rPartRef.m_pDMPart)
                break;
        }
        if( pPartItem == NULL )
        {
            pPartItem = new TListItem<DirectMusicPart*>(rPartRef.m_pDMPart);
            if (pPartItem)
            {
                PartList.AddTail( pPartItem );
            }
        }
    }

// Save Parts
    pPartItem = PartList.GetHead();
    for ( ; pPartItem; pPartItem = pPartItem->GetNext() )
    {
        pPart = pPartItem->GetItemValue();

        hr = pPart->DM_SavePart( pIRiffStream );
        if( FAILED ( hr ) )
        {
            goto ON_ERROR;
        }
    }

// Save Part References
    pPartRefItem = m_PartRefList.GetHead();
    for( ; pPartRefItem; pPartRefItem = pPartRefItem->GetNext() )
    {
        DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();

        hr = rPartRef.DM_SavePartRef( pIRiffStream );
        if( FAILED ( hr ) )
        {
            goto ON_ERROR;
        }
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternRhythm

HRESULT CDirectMusicPattern::DM_SavePatternRhythm( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr = S_OK;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    int i;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Rhythm chunk header
    ck.ckid = DMUS_FOURCC_RHYTHM_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save the RhythmMap for each measure
    for( i = 0 ;  i < m_wNumMeasures ;  i++ )
    {
        // Write Rhythm chunk data
        hr = pIStream->Write( &m_pRhythmMap[i], sizeof(DWORD), &dwBytesWritten);
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(DWORD) )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternSwitchPoints

/*
HRESULT CDirectMusicPattern::DM_SavePatternSwitchPoints( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    int i;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Pattern Switch Point chunk header
    ck.ckid = DMUS_FOURCC_SWITCH_POINT_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save the Switch Points for each measure
    for( i = 0 ;  i < m_wNumMeasures ;  i++ )
    {
        // Write Switch Point chunk data
        hr = pIStream->Write( &m_pSwitchPoints[i], sizeof(DWORD), &dwBytesWritten);
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(DWORD) )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternInfoList

HRESULT CDirectMusicPattern::DM_SavePatternInfoList( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

    if( m_strName.IsEmpty() )
    {
        return S_OK;
    }

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write UNFO LIST header
    ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
    if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Pattern name
    if( !m_strName.IsEmpty() )
    {
        ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
        if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }

        hr = SaveMBStoWCS( pIStream, &m_strName );
        if( FAILED( hr ) )
        {
            goto ON_ERROR;
        }

        if( pIRiffStream->Ascend(&ck, 0) != 0 )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternChunk

HRESULT CDirectMusicPattern::DM_SavePatternChunk( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    DMUS_IO_PATTERN oDMPattern;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Pattern chunk header
    ck.ckid = DMUS_FOURCC_PATTERN_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Prepare DMUS_IO_PATTERN
    memset( &oDMPattern, 0, sizeof(DMUS_IO_PATTERN) );

    oDMPattern.timeSig.bBeatsPerMeasure = m_timeSig.m_bBeatsPerMeasure;
    oDMPattern.timeSig.bBeat = m_timeSig.m_bBeat;
    oDMPattern.timeSig.wGridsPerBeat = m_timeSig.m_wGridsPerBeat;

    oDMPattern.bGrooveBottom = m_bGrooveBottom;
    oDMPattern.bGrooveTop = m_bGrooveTop;
    oDMPattern.bDestGrooveBottom = m_bDestGrooveBottom;
    oDMPattern.bDestGrooveTop = m_bDestGrooveTop;
    oDMPattern.wEmbellishment = m_wEmbellishment;
    oDMPattern.wNbrMeasures = m_wNumMeasures;
    oDMPattern.dwFlags = m_dwFlags;

    // Write Pattern chunk data
    hr = pIStream->Write( &oDMPattern, sizeof(DMUS_IO_PATTERN), &dwBytesWritten);
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(DMUS_IO_PATTERN) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


HRESULT CDirectMusicPattern::Save( IStream* pIStream )
{
    if( pIStream == NULL )
    {
        return E_INVALIDARG;
    }

   IAARIFFStream* pIRiffStream;
   MMCKINFO ckMain;
   HRESULT hr = E_FAIL;

    // Single Pattern (Direct Music format)
    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;
        if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
            &&  SUCCEEDED( DM_SaveSinglePattern( pIRiffStream ) )
            &&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
        {
            hr = S_OK;
        }
        pIRiffStream->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPartRef::DM_SavePartRef

HRESULT DirectMusicPartRef::DM_SavePartRef( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream = NULL;
    HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    DMUS_IO_PARTREF oDMPartRef;

    if ( m_pDMPart == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write PartRef list header
    ckMain.fccType = DMUS_FOURCC_PARTREF_LIST;
    if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write PartRef chunk header
    ck.ckid = DMUS_FOURCC_PARTREF_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Prepare DMUS_IO_PARTREF structure
    memset( &oDMPartRef, 0, sizeof(DMUS_IO_PARTREF) );

    oDMPartRef.dwPChannel = m_dwLogicalPartID;
    oDMPartRef.wLogicalPartID = (WORD) m_dwLogicalPartID;
    oDMPartRef.bVariationLockID = m_bVariationLockID;
    oDMPartRef.bSubChordLevel = m_bSubChordLevel;
    oDMPartRef.bPriority = m_bPriority;

    memcpy( &oDMPartRef.guidPartID, &m_pDMPart->m_guidPartID, sizeof(GUID) );

    // Write PartRef chunk data
    hr = pIStream->Write( &oDMPartRef, sizeof(DMUS_IO_PARTREF), &dwBytesWritten);
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_PARTREF) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    if (pIStream) pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SavePart

HRESULT DirectMusicPart::DM_SavePart( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    DMUS_IO_STYLEPART oDMStylePart;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Part list header
    ckMain.fccType = DMUS_FOURCC_PART_LIST;
    if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Part chunk header
    ck.ckid = DMUS_FOURCC_PART_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Prepare DMUS_IO_STYLEPART structure
    memset( &oDMStylePart, 0, sizeof(DMUS_IO_STYLEPART) );

    oDMStylePart.timeSig.bBeatsPerMeasure = m_timeSig.m_bBeatsPerMeasure;
    oDMStylePart.timeSig.bBeat = m_timeSig.m_bBeat;
    oDMStylePart.timeSig.wGridsPerBeat = m_timeSig.m_wGridsPerBeat;

    oDMStylePart.wNbrMeasures = m_wNumMeasures;
    oDMStylePart.bInvertUpper = m_bInvertUpper;
    oDMStylePart.bInvertLower = m_bInvertLower;
    oDMStylePart.bPlayModeFlags = m_bPlayModeFlags;
    oDMStylePart.dwFlags = m_dwFlags;

    memcpy( &oDMStylePart.guidPartID, &m_guidPartID, sizeof(GUID) );
    memcpy( &oDMStylePart.dwVariationChoices, &m_dwVariationChoices, sizeof(m_dwVariationChoices) );

    // Write Part chunk data
    hr = pIStream->Write( &oDMStylePart, sizeof(DMUS_IO_STYLEPART), &dwBytesWritten);
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLEPART) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    CDirectMusicEventItem* pEvent;

    // Save Part note list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_NOTE )
        {
            hr = DM_SaveNoteList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // Save Part curve list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_CURVE )
        {
            hr = DM_SaveCurveList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // Save Part marker list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_MARKER )
        {
            hr = DM_SaveMarkerList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // Save Part anticipation list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION )
        {
            hr = DM_SaveAnticipationList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // save resolution list (when applicable)
    if (m_ResolutionList.GetHead())
    {
        hr = DM_SaveResolutionList(pIRiffStream);
        if( FAILED( hr ) )
        {
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveNoteList

HRESULT DirectMusicPart::DM_SaveNoteList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleNote* pNote;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLENOTE oDMStyleNote;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Note chunk header
    ck.ckid = DMUS_FOURCC_NOTE_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLENOTE structure
    dwSize = sizeof(DMUS_IO_STYLENOTE);
    hr = pIStream->Write( &dwSize, sizeof(DWORD), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(DWORD) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the notes
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_NOTE )
        {
            pNote = (CDMStyleNote*)pEvent;

            // Prepare DMUS_IO_STYLENOTE structure
            memset( &oDMStyleNote, 0, sizeof(DMUS_IO_STYLENOTE) );

            oDMStyleNote.mtGridStart = pNote->m_nGridStart;
            oDMStyleNote.dwVariation = pNote->m_dwVariation;
            oDMStyleNote.nTimeOffset = pNote->m_nTimeOffset;

            oDMStyleNote.mtDuration = pNote->m_mtDuration;
            oDMStyleNote.wMusicValue = pNote->m_wMusicValue;
            oDMStyleNote.bVelocity = pNote->m_bVelocity;
            oDMStyleNote.bTimeRange = pNote->m_bTimeRange;
            oDMStyleNote.bDurRange = pNote->m_bDurRange;
            oDMStyleNote.bVelRange = pNote->m_bVelRange;
            oDMStyleNote.bInversionID = pNote->m_bInversionId;
            oDMStyleNote.bPlayModeFlags = pNote->m_bPlayModeFlags;
            oDMStyleNote.bNoteFlags = pNote->m_bFlags;

            // Write DMUS_IO_STYLENOTE structure
            hr = pIStream->Write( &oDMStyleNote, sizeof(DMUS_IO_STYLENOTE), &dwBytesWritten );
            if( FAILED( hr )
            ||  dwBytesWritten != sizeof(DMUS_IO_STYLENOTE) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveCurveList

HRESULT DirectMusicPart::DM_SaveCurveList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleCurve* pCurve;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLECURVE oDMStyleCurve;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_CURVE_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLECURVE structure
    dwSize = sizeof(DMUS_IO_STYLECURVE);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the curves
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_CURVE )
        {
            pCurve = (CDMStyleCurve*)pEvent;

            // Prepare DMUS_IO_STYLECURVE structure
            memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_STYLECURVE) );

            oDMStyleCurve.mtGridStart = pCurve->m_nGridStart;
            oDMStyleCurve.dwVariation = pCurve->m_dwVariation;
            oDMStyleCurve.nTimeOffset = pCurve->m_nTimeOffset;

            oDMStyleCurve.mtDuration = pCurve->m_mtDuration;
            oDMStyleCurve.nStartValue = pCurve->m_StartValue;
            oDMStyleCurve.nEndValue = pCurve->m_EndValue;
            oDMStyleCurve.bEventType = pCurve->m_bEventType;
            oDMStyleCurve.bCurveShape = pCurve->m_bCurveShape;
            oDMStyleCurve.bCCData = pCurve->m_bCCData;

            oDMStyleCurve.mtResetDuration = pCurve->m_mtResetDuration;
            oDMStyleCurve.nResetValue = pCurve->m_nResetValue;
            oDMStyleCurve.bFlags = pCurve->m_bFlags;
            // dx8 stuff
            oDMStyleCurve.wParamType = pCurve->m_wParamType;
            oDMStyleCurve.wMergeIndex = pCurve->m_wMergeIndex;

            // Write DMUS_IO_STYLECURVE structure
            hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_STYLECURVE), &dwBytesWritten );
            if( FAILED( hr )
            ||  dwBytesWritten != sizeof(DMUS_IO_STYLECURVE) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveMarkerList

HRESULT DirectMusicPart::DM_SaveMarkerList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleMarker* pMarker;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLEMARKER oDMStyleMarker;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_MARKER_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLEMARKER structure
    dwSize = sizeof(DMUS_IO_STYLEMARKER);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the markers
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_MARKER )
        {
            pMarker = (CDMStyleMarker*)pEvent;

            // Prepare DMUS_IO_STYLEMARKER structure
            memset( &oDMStyleMarker, 0, sizeof(DMUS_IO_STYLEMARKER) );

            oDMStyleMarker.mtGridStart = pMarker->m_nGridStart;
            oDMStyleMarker.dwVariation = pMarker->m_dwVariation;

            oDMStyleMarker.wMarkerFlags = pMarker->m_wFlags;

            // Write DMUS_IO_STYLEMARKER structure
            hr = pIStream->Write( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &dwBytesWritten );
            if( FAILED( hr )
            ||  dwBytesWritten != sizeof(DMUS_IO_STYLEMARKER) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveAnticipationList

HRESULT DirectMusicPart::DM_SaveAnticipationList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleAnticipation* pAnticipation;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLE_ANTICIPATION oDMStyleAnticipation;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_ANTICIPATION_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLE_ANTICIPATION structure
    dwSize = sizeof(DMUS_IO_STYLE_ANTICIPATION);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the anticipations
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION )
        {
            pAnticipation = (CDMStyleAnticipation*)pEvent;

            // Prepare DMUS_IO_STYLE_ANTICIPATION structure
            memset( &oDMStyleAnticipation, 0, sizeof(DMUS_IO_STYLE_ANTICIPATION) );

            oDMStyleAnticipation.mtGridStart = pAnticipation->m_nGridStart;
            oDMStyleAnticipation.dwVariation = pAnticipation->m_dwVariation;
            oDMStyleAnticipation.nTimeOffset = pAnticipation->m_nTimeOffset;
            oDMStyleAnticipation.bTimeRange = pAnticipation->m_bTimeRange;

            // Write DMUS_IO_STYLE_ANTICIPATION structure
            hr = pIStream->Write( &oDMStyleAnticipation, sizeof(DMUS_IO_STYLE_ANTICIPATION), &dwBytesWritten );
            if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLE_ANTICIPATION) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveResolutionList

HRESULT DirectMusicPart::DM_SaveResolutionList( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLERESOLUTION oDMStyleResolution;
    TListItem<DMUS_IO_STYLERESOLUTION>* pScan = m_ResolutionList.GetHead();

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_RESOLUTION_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLERESOLUTION structure
    dwSize = sizeof(DMUS_IO_STYLERESOLUTION);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the resolutions
    for(; pScan; pScan = pScan->GetNext() )
    {
        // Prepare DMUS_IO_STYLERESOLUTION structure
        oDMStyleResolution = pScan->GetItemValue();

        // Write DMUS_IO_STYLERESOLUTION structure
        hr = pIStream->Write( &oDMStyleResolution, sizeof(DMUS_IO_STYLERESOLUTION), &dwBytesWritten );
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLERESOLUTION) )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

HRESULT CDMStyle::GetPatternStream(WCHAR* wszName, DWORD dwPatternType, IStream** ppStream)
{
    V_PTRPTR_WRITE(ppStream);

    TListItem<CDirectMusicPattern*>* pPattern = NULL;
    switch (dwPatternType)
    {
    case DMUS_STYLET_PATTERN:
        pPattern = m_StyleInfo.m_PatternList.GetHead();
        break;
    case DMUS_STYLET_MOTIF:
        pPattern = m_StyleInfo.m_MotifList.GetHead();
        break;
        // case for melody fragments...
    }
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        if (pPattern->GetItemValue()->m_strName == wszName)
            break;
    }
    if (pPattern != NULL)
    {
        // Create a stream
        IStream *pIPatternStream;
        HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pIPatternStream);
        if (SUCCEEDED(hr))
        {
            // Persist the pattern to the stream
            pPattern->GetItemValue()->Save(pIPatternStream);
            // Return the stream
            *ppStream = pIPatternStream;
        }
        return hr;
    }
    else
    {
        return S_FALSE;
    }
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetMotif | Creates a segment containing
the named motif.

@rdesc Returns one of the following:

@flag S_OK | Success.
@flag S_FALSE | No motif with the given name.
@flag E_POINTER | <p ppSegment> is not a valid address.

@comm Searches the Style's list of motifs for one whose name matches <p wszName>. If one 
is found, a segment is created containing a Motif track.  The track references the Style as
its associated style and the motif as its pattern.
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetMotif(
            WCHAR* pwszName,                    // @parm The name of the motif to be retrieved.
            IDirectMusicSegment** ppSegment // @parm A segment containing the named motif.
        )
{
    V_PTR_READ(pwszName,1);
    V_PTRPTR_WRITE(ppSegment);

    String str = pwszName;
    EnterCriticalSection( &m_CriticalSection );
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_MotifList.GetHead();
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        if (pPattern->GetItemValue()->m_strName == str)
            break;
    }
    if (pPattern != NULL)
    {
        // AddRef the style
        ((IDirectMusicStyle*)this)->AddRef();
        // create a segment containing a motif track
        IUnknown* pIUSegment;
        // make a motif with the given number of repeats
        CreateMotifSegment(pPattern->GetItemValue(), &pIUSegment, 0);
        HRESULT hr = pIUSegment->QueryInterface(IID_IDirectMusicSegment, (void**)ppSegment);
        pIUSegment->Release();
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    else
    {
        LeaveCriticalSection( &m_CriticalSection );
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CDMStyle::EnumPartGuid(
        DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid)
{
    HRESULT hr = S_OK;
    TListItem<CDirectMusicPattern*>* pPattern = NULL;

    switch (dwPatternType)
    {
    case DMUS_STYLET_PATTERN:
        pPattern = m_StyleInfo.m_PatternList.GetHead();
        break;
    case DMUS_STYLET_MOTIF:
        pPattern = m_StyleInfo.m_MotifList.GetHead();
        break;
        // case for melody fragments...
    }
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        if (pPattern->GetItemValue()->m_strName == wszName)
            break;
    }
    if (pPattern != NULL)
    {
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->GetItemValue()->m_PartRefList.GetHead();
        for (DWORD dw = 0; dw < dwIndex; dw++)
        {
            if (pPartRef) pPartRef = pPartRef->GetNext();
        }
        if (pPartRef)
        {
            rGuid = pPartRef->GetItemValue().m_pDMPart->m_guidPartID;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}


// NOTE: assumes wszName is preallocated to MAX_PATH
HRESULT STDMETHODCALLTYPE CDMStyle::EnumPattern(
            DWORD dwIndex,
            DWORD dwPatternType,
            WCHAR *wszName
        )
{
    HRESULT hr = E_INVALIDARG;
    switch (dwPatternType)
    {
    case DMUS_STYLET_PATTERN:
        hr = EnumRegularPattern(dwIndex, wszName);
        break;
    case DMUS_STYLET_MOTIF:
        hr = EnumMotif(dwIndex, wszName);
        break;
        // case for melody fragments...
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CDMStyle::EnumRegularPattern(
            DWORD dwIndex,
            WCHAR *wszName
        )
{
    V_PTR_WRITE(wszName, 1);
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_PatternList.GetHead();
    for (DWORD dw = 0; pPattern != NULL; pPattern = pPattern->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    HRESULT hr = S_OK;
    if (pPattern != NULL)
    {
        if (pPattern->GetItemValue()->m_strName.GetLength() < MAX_PATH)
        {
            wcscpy(wszName, pPattern->GetItemValue()->m_strName);
            hr = S_OK;
        }
        else
        {
            for (int i = 0; i < (MAX_PATH - 1); i++)
            {
                wszName[i] = pPattern->GetItemValue()->m_strName[i];
            }
            wszName[MAX_PATH - 1] = L'\0';
            hr = DMUS_S_STRING_TRUNCATED;
        }
    }
    else 
    {
        hr = S_FALSE;
    }
    return hr;
}

// enum the list of start times common to all patterns referenced by the associated type, level, and range.
// (i.e. if more than one such pattern, skip start times not comon to all)
// return S_FALSE when no start times remain.
HRESULT STDMETHODCALLTYPE CDMStyle::EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime)
{
    int nRange = (int)pCommand->bGrooveRange / 2;
    int nLow = (int)pCommand->bGrooveLevel - nRange;
    if (nLow < 0) nLow = 0;
    int nHigh = (int)pCommand->bGrooveLevel + nRange;
    if (nHigh > 100) nHigh = 100;
    TList<CDirectMusicPattern*> MatchList;
    int nMatchCount = 0;
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_PatternList.GetHead();
    if (!pPattern) return S_FALSE;
    TListItem<MUSIC_TIME>** apStartTimes = NULL;
    HRESULT hr = S_OK;
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        CDirectMusicPattern*& rpPattern = pPattern->GetItemValue();
        if (rpPattern->m_bGrooveBottom <= (BYTE)nHigh &&
            rpPattern->m_bGrooveTop >= (BYTE)nLow)
        {
            if ( (pCommand->bCommand == DMUS_COMMANDT_FILL &&
                    rpPattern->m_wEmbellishment == EMB_FILL) ||
                 (pCommand->bCommand == DMUS_COMMANDT_INTRO &&
                    rpPattern->m_wEmbellishment == EMB_INTRO) ||
                 (pCommand->bCommand == DMUS_COMMANDT_BREAK &&
                    rpPattern->m_wEmbellishment == EMB_BREAK) ||
                 (pCommand->bCommand == DMUS_COMMANDT_END &&
                    rpPattern->m_wEmbellishment == EMB_END) ||
                 (pCommand->bCommand == DMUS_COMMANDT_GROOVE &&
                    rpPattern->m_wEmbellishment == EMB_NORMAL) ||
                 (rpPattern->m_wEmbellishment & EMB_USER_DEFINED &&
                    (rpPattern->m_wEmbellishment >> 8) == (WORD)pCommand->bCommand) )
            {
                if (rpPattern && rpPattern->m_StartTimeList.GetHead())
                {
                    TListItem<CDirectMusicPattern*>* pNewPattern;
                    pNewPattern = new TListItem<CDirectMusicPattern*>(rpPattern);
                    if (!pNewPattern)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    MatchList.AddHead(pNewPattern);
                    nMatchCount++;
                }
            }
        }
    }
    if (S_OK == hr)
    {
        if (nMatchCount)
        {
            apStartTimes = new TListItem<MUSIC_TIME>*[nMatchCount];
            if (!apStartTimes) hr = E_OUTOFMEMORY;
        }
        else hr = S_FALSE;
    }
    if (S_OK == hr)
    {
        MUSIC_TIME mtMin = 0, mtMax = 0;
        TListItem<CDirectMusicPattern*>* pMatch = MatchList.GetHead();
        // initialize the array of start time pointers
        for (int i = 0; pMatch; pMatch = pMatch->GetNext(), i++)
        {
            apStartTimes[i] = pMatch->GetItemValue()->m_StartTimeList.GetHead();
        }
        for (DWORD dw = 0; S_OK == hr && dw <= dwIndex; dw++)
        {
            // get the min and max times for the first item in each list
            mtMin = mtMax = apStartTimes[0]->GetItemValue();
            for (int i = 0; i < nMatchCount; i++)
            {
                if (apStartTimes[i]->GetItemValue() < mtMin)
                {
                    mtMin = apStartTimes[i]->GetItemValue();
                }
                if (apStartTimes[i]->GetItemValue() > mtMax)
                {
                    mtMax = apStartTimes[i]->GetItemValue();
                }
            }
            // sync up all the start times by making sure max == min.
            // set hr to S_FALSE if any lists run out.
            while (S_OK == hr && mtMax != mtMin)
            {
                // We'll only be changing values less than max, so the
                // new min will be not greater than that.
                MUSIC_TIME mtNewMin = mtMax;
                for (i = 0; i < nMatchCount; i++)
                {
                    if (apStartTimes[i]->GetItemValue() < mtMax)
                    {
                        apStartTimes[i] = apStartTimes[i]->GetNext();
                        if (!apStartTimes[i])
                        {
                            hr = S_FALSE;
                            break;
                        }
                        if (apStartTimes[i]->GetItemValue() < mtNewMin)
                        {
                            mtNewMin = apStartTimes[i]->GetItemValue();
                        }
                        if (apStartTimes[i]->GetItemValue() > mtMax)
                        {
                            mtMax = apStartTimes[i]->GetItemValue();
                        }
                    }
                }
                // mtTempMin is the new min, since every instance of the
                // old min was less than max and therefore changed.
                mtMin = mtNewMin;
            }
            if (S_OK != hr) break;
            // if we're going to loop again, increment all the start time pointers.
            if (dw < dwIndex)
            {
                for (i = 0;  i < nMatchCount; i++)
                {
                    apStartTimes[i] = apStartTimes[i]->GetNext();
                    // set hr to S_FALSE if any lists run out.
                    if (!apStartTimes[i])
                    {
                        hr = S_FALSE;
                        break;
                    }
                }
            }
        }
        // if hr is S_OK, max should equal min, so return one of them.
        if (S_OK == hr) *pmtStartTime = mtMax;
        delete [] apStartTimes;
    }
    return hr;
}


/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | EnumMotif | Retrieves the name of the
motif indexed by <p dwIndex>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | No motif at the given location
@flag DMUS_S_STRING_TRUNCATED | The length of the motif name is not less than MAX_PATH
@flag E_POINTER | <p pwszName> is not a valid address

@comm Searches the Style's list of motifs for the one at the location given by <p dwIndex>.
If there is such a motif, its name is returned in <p pwszName>; if it is not less than MAX_PATH,
it is truncated.  This assumes that <p pwszName>
has been pre-allocated to have a length of at least MAX_PATH.
*/
HRESULT STDMETHODCALLTYPE CDMStyle::EnumMotif(
            DWORD dwIndex, // @parm An index into the Style's motif list (0-based).
            WCHAR *pwszName  // @parm The motif name to be returned.
        )
{
    V_BUFPTR_WRITE(pwszName,MAX_PATH);
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_MotifList.GetHead();
    for (DWORD dw = 0; pPattern != NULL; pPattern = pPattern->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    HRESULT hr = S_OK;
    if (pPattern != NULL)
    {
        if (pPattern->GetItemValue()->m_strName.GetLength() < MAX_PATH)
        {
            wcscpy(pwszName, pPattern->GetItemValue()->m_strName);
            hr =  S_OK;
        }
        else
        {
            for (int i = 0; i < (MAX_PATH - 1); i++)
            {
                pwszName[i] = pPattern->GetItemValue()->m_strName[i];
            }
            pwszName[MAX_PATH - 1] = L'\0';
            hr =  DMUS_S_STRING_TRUNCATED;
        }
    }
    else 
    {
        hr =  S_FALSE;
    }
    return hr;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetChordMap | Retrieves the named ChordMap.

@rdesc Returns one of the following:

@flag S_OK | Success.
@flag S_FALSE | No ChordMap with the given name.
@flag E_POINTER | ppChordMap not a valid pointer

@comm Searches the Style's list of personalities for one whose name matches <p wszName>. If one 
is found, it is returned.
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetChordMap(
            WCHAR* pwszName,                    // @parm The name of the ChordMap to be retrieved.
            IDirectMusicChordMap** ppChordMap   // @parm The named ChordMap.
        )
{
    V_PTR_READ(pwszName,1);
    V_PTRPTR_WRITE(ppChordMap);

    String str1 = pwszName;
    TListItem<IDirectMusicChordMap*>* pPersItem = m_StyleInfo.m_PersList.GetHead();
    IDirectMusicChordMap *pPers =  NULL;
    for (; pPersItem != NULL; pPersItem = pPersItem->GetNext())
    {
        HRESULT hr = S_OK;
        String str2;
        pPers = pPersItem->GetItemValue();

        IDirectMusicObject *pIObject = NULL;
        DMUS_OBJECTDESC Desc;              // Descriptor.

        if (SUCCEEDED(hr = pPers->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject)))
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    str2 = Desc.wszName;
                    if (str1 == str2)
                    {
                        pIObject->Release();
                        break;
                    }
                }
                else hr = E_FAIL;
            }
            pIObject->Release();
        }
        if (!SUCCEEDED(hr))
        {
            return hr;
        }

    }
    if (pPersItem != NULL)
    {
        // AddRef the ChordMap
        pPers->AddRef();
        // Return it.
        *ppChordMap = pPers;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | EnumChordMap | Retrieves the name of the
ChordMap indexed by <p dwIndex>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | No ChordMap at the given location
@flag DMUS_S_STRING_TRUNCATED | The length of the ChordMap name is not less than MAX_PATH
@flag E_POINTER | <p pwszName> is not a valid address
@flag DMUS_E_TYPE_UNSUPPORTED | The ChordMap's descriptor doesn't support DMUS_OBJ_NAME

@comm Searches the Style's list of chord maps for the one at the location given by <p dwIndex>.
If there is such a ChordMap, its name is returned in <p pwszName>; if it is not less than MAX_PATH,
it is truncated.  This assumes that <p pwszName>
has been pre-allocated to have a length of at least MAX_PATH.
*/
HRESULT STDMETHODCALLTYPE CDMStyle::EnumChordMap(
            DWORD dwIndex, // @parm An index into the Style's ChordMap list (0-based).
            WCHAR *pwszName // @parm The ChordMap name to be returned.
        )
{
    V_BUFPTR_WRITE(pwszName,MAX_PATH);

    TListItem<IDirectMusicChordMap*>* pPers = m_StyleInfo.m_PersList.GetHead();
    for (DWORD dw = 0; pPers != NULL; pPers = pPers->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    if (pPers != NULL)
    {
        HRESULT hr = S_OK;
        IDirectMusicChordMap* pChordMap = pPers->GetItemValue();

        IDirectMusicObject *pIObject = NULL;
        DMUS_OBJECTDESC Desc;              // Descriptor.

        if (SUCCEEDED(hr = pChordMap->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject)))
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    if (wcslen(Desc.wszName) < MAX_PATH)
                    {
                        wcscpy(pwszName, Desc.wszName);
                    }
                    else
                    {
                        for (int i = 0; i < (MAX_PATH - 1); i++)
                        {
                            pwszName[i] = Desc.wszName[i];
                        }
                        pwszName[MAX_PATH - 1] = L'\0';
                        hr = DMUS_S_STRING_TRUNCATED;
                    }
                }
                else 
                {
                    hr = DMUS_E_TYPE_UNSUPPORTED;
                }
            }
            pIObject->Release();
        }
        return hr;
    }
    else 
    {
        return S_FALSE;
    }
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetDefaultChordMap | Gets the style's 
default ChordMap.

@rdesc Returns one of the following

@flag S_OK | Success.
@flag E_POINTER | <p ppChordMap> not a valid pointer.
@flag S_FALSE | Style does not have a default ChordMap.

@comm Returns the Style's default ChordMap in <p ppChordMap>.
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetDefaultChordMap(
            IDirectMusicChordMap **ppChordMap   // @parm The ChordMap to be returned.
        )
{
    V_PTRPTR_WRITE(ppChordMap);

    if(m_StyleInfo.m_pDefaultPers == NULL)
    {
        return S_FALSE;
    }

    *ppChordMap = m_StyleInfo.m_pDefaultPers;

    (*ppChordMap)->AddRef();

    return S_OK;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetBand | Retrieves the named band.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | ppBand not a valid pointer
@flag S_FALSE | No band with the given name

@comm Searches the Style's list of bands for one whose name matches <p pwszName>. If one 
is found, it is returned in <p ppBand>.
*/
HRESULT STDMETHODCALLTYPE CDMStyle::GetBand(
            WCHAR *pwszName,            // @parm The name of the band to be retrieved.
            IDirectMusicBand **ppBand // @parm The named band.
        )
{
    V_PTR_READ(pwszName,1);
    V_PTRPTR_WRITE(ppBand);

    String str1 = pwszName;
    TListItem<IDirectMusicBand*>* pBandItem = m_StyleInfo.m_BandList.GetHead();
    IDirectMusicBand *pBand =  NULL;
    for (; pBandItem != NULL; pBandItem = pBandItem->GetNext())
    {
        HRESULT hr = S_OK;
        String str2;
        pBand = pBandItem->GetItemValue();

        IDirectMusicObject *pIObject = NULL;
        DMUS_OBJECTDESC Desc;              // Descriptor.
        Desc.dwSize = sizeof(Desc);

        if (SUCCEEDED(hr = pBand->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject)))
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    str2 = Desc.wszName;
                    if (str1 == str2)
                    {
                        pIObject->Release();
                        break;
                    }
                }
                else hr = E_FAIL;
            }
            pIObject->Release();
        }
        if (!SUCCEEDED(hr))
        {
            return hr;
        }

    }
    if (pBandItem != NULL)
    {
        // AddRef the band
        pBand->AddRef();
        // Return it.
        *ppBand = pBand;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | EnumBand | Retrieves the name of the
band indexed by <p dwIndex>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | No band at the given location
@flag DMUS_S_STRING_TRUNCATED | The length of the band name is not less than MAX_PATH
@flag E_POINTER | <p pwszName> is not a valid address
@flag DMUS_E_TYPE_UNSUPPORTED | The band's descriptor doesn't support DMUS_OBJ_NAME

@comm Searches the Style's list of bands for the one at the location given by <p dwIndex>.
If there is such a band, its name is returned in <p pwszName>; if it is not less than MAX_PATH,
it is truncated.  This assumes that <p pwszName>
has been pre-allocated to have a length of at least MAX_PATH.
*/
HRESULT STDMETHODCALLTYPE CDMStyle::EnumBand(
            DWORD dwIndex, // @parm An index into the Style's band list (0-based).
            WCHAR *pwszName// @parm The band name to be returned.
        )
{
    V_BUFPTR_WRITE(pwszName,MAX_PATH);

    TListItem<IDirectMusicBand*>* pBandItem = m_StyleInfo.m_BandList.GetHead();
    for (DWORD dw = 0; pBandItem != NULL; pBandItem = pBandItem->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    if (pBandItem != NULL)
    {
        HRESULT hr = S_OK;
        IDirectMusicBand* pBand = pBandItem->GetItemValue();

        IDirectMusicObject *pIObject = NULL;
        DMUS_OBJECTDESC Desc;              // Descriptor.
        Desc.dwSize = sizeof(Desc);

        if (SUCCEEDED(hr = pBand->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject)))
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    if (wcslen(Desc.wszName) < MAX_PATH)
                    {
                        wcscpy(pwszName, Desc.wszName);
                    }
                    else
                    {
                        for (int i = 0; i < (MAX_PATH - 1); i++)
                        {
                            pwszName[i] = Desc.wszName[i];
                        }
                        pwszName[MAX_PATH - 1] = L'\0';
                        hr = DMUS_S_STRING_TRUNCATED;
                    }
                }
                else 
                {
                    hr = DMUS_E_TYPE_UNSUPPORTED;
                }
            }
            pIObject->Release();
        }
        return hr;
    }
    else 
    {
        return S_FALSE;
    }
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetDefaultBand | Gets the style's default band

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | ppBand not a valid pointer
@flag S_FALSE | Style does not have a default band

@comm Returns the Style's default band in <p ppBand>.
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetDefaultBand(
            IDirectMusicBand **ppBand   // @parm The band to be returned.
        )
{
    V_PTRPTR_WRITE(ppBand);

    if(m_StyleInfo.m_pDefaultBand == NULL)
    {
        return S_FALSE;
    }

    *ppBand = m_StyleInfo.m_pDefaultBand;

    (*ppBand)->AddRef();

    return S_OK;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetTimeSignature | Retrieves the Style's
time signature.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | <p pTimeSig> is not a valid address

@comm Fills in a <t DMUS_TIMESIGNATURE> structure with data from the Style's time signature.
*/
HRESULT CDMStyle::GetTimeSignature(
            DMUS_TIMESIGNATURE* pTimeSig // @parm A pre-allocated <t DMUS_TIMESIGNATURE> structure.
        )
{
    V_PTR_WRITE(pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    pTimeSig->mtTime = 0;
    pTimeSig->wGridsPerBeat = m_StyleInfo.m_TimeSignature.m_wGridsPerBeat;
    pTimeSig->bBeatsPerMeasure = m_StyleInfo.m_TimeSignature.m_bBeatsPerMeasure;
    pTimeSig->bBeat = m_StyleInfo.m_TimeSignature.m_bBeat;
    return S_OK;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetEmbellishmentLength | Finds the shortest
and longest lengths for patterns of the specified embellishment type and groove level.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | There are no patterns of the specified type and groove level
@flag E_POINTER | Either <p pdwMin> or <p pdwMax> is not a valid address

@comm Finds all patterns in the Style with embellishment type given by <p bType> and groove
range that includes <p bLevel>.  The length of the longest such pattern is returned in 
<p pdwMax>, and the length of the shortest pattern is returned in <p pdwMin>.
Note that <p bLevel> is ignored for non-groove embellishments.
*/
HRESULT CDMStyle::GetEmbellishmentLength(
            DWORD dwType,       // @parm An embellishment type.
            DWORD dwLevel,  // @parm A groove level (1 - 100).
            DWORD* pdwMin,  // @parm Length of the shortest pattern of the specified type
                            // and groove level.
            DWORD* pdwMax       // @parm Length of the longest pattern of the specified type
                            // and groove level.
        )
{
    V_PTR_WRITE(pdwMin, sizeof(DWORD) );
    V_PTR_WRITE(pdwMax, sizeof(DWORD) );
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_PatternList.GetHead();
    *pdwMin = *pdwMax = 0;
    if (!pPattern) return S_FALSE;
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        CDirectMusicPattern*& rpPattern = pPattern->GetItemValue();
        switch (dwType)
        {
        // need to use == rather than & for all of these because of user-defined embellishments
        case DMUS_COMMANDT_FILL:
            if (rpPattern->m_wEmbellishment == EMB_FILL)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_INTRO:
            if (rpPattern->m_wEmbellishment == EMB_INTRO)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_BREAK:
            if (rpPattern->m_wEmbellishment == EMB_BREAK)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_END:
            if (rpPattern->m_wEmbellishment == EMB_END)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_GROOVE: // need to use == rather than & since EMB_NORMAL == 0
            if ((rpPattern->m_wEmbellishment == EMB_NORMAL) &&
                rpPattern->m_bGrooveBottom <= (BYTE)dwLevel &&
                rpPattern->m_bGrooveTop >= (BYTE)dwLevel)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        default: // check for user-defined embellishment
            if ( (rpPattern->m_wEmbellishment & EMB_USER_DEFINED) &&
                 (rpPattern->m_wEmbellishment >> 8) == (WORD)dwType )
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
        }
    }
    if (!*pdwMin || !*pdwMax) return S_FALSE;
    return S_OK;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetTempo | Retrieves the recommended tempo
of the style.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | <p pTempo> is not a valid pointer

*/
HRESULT CDMStyle::GetTempo
    (
        double* pTempo // @parm The recommended tempo of the style.
    )
{
    V_PTR_WRITE(pTempo, sizeof(double) );
    *pTempo = m_StyleInfo.m_dblTempo;
    return S_OK;
}

CDirectMusicEventItem* CDirectMusicEventItem::MergeSort(DirectMusicTimeSig& TimeSig)
{
    if (m_pNext != NULL)
    {
        CDirectMusicEventItem *pList1, *pList2;
        Divide(pList1, pList2);
        return pList1->MergeSort(TimeSig)->Merge(pList2->MergeSort(TimeSig), TimeSig);
    }
    return this;
}

void CDirectMusicEventItem::Divide(CDirectMusicEventItem*& pHead1, CDirectMusicEventItem*& pHead2)
{
    CDirectMusicEventItem *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
    do
    {
        pHead1 = pCurrent;
        pCurrent = (CDirectMusicEventItem *)pCurrent->m_pNext;
        pHead1->m_pNext = pTail1;
        pTail1 = pHead1;
        if (pCurrent != NULL)
        {
            pHead2 = pCurrent;
            pCurrent = (CDirectMusicEventItem *)pCurrent->m_pNext;
            pHead2->m_pNext = pTail2;
            pTail2 = pHead2;
        }
    } while (pCurrent != NULL);
}

CDirectMusicEventItem* CDirectMusicEventItem::Merge(CDirectMusicEventItem* pOtherList, DirectMusicTimeSig& TimeSig)
{
    if (!pOtherList) return this;
    CDirectMusicEventItem 
        *pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
    while (pThisList && pOtherList)
    {
        if (pThisList->m_nGridStart < pOtherList->m_nGridStart ||
            // Markers need to precede other events occuring at the same time
            ((pThisList->m_dwEventTag == DMUS_EVENT_MARKER) &&
             (pThisList->m_nGridStart) == (pOtherList->m_nGridStart)) ||
            // Within a grid, sort by time offset
            ((pThisList->m_nGridStart) == (pOtherList->m_nGridStart) &&
             (pThisList->m_nTimeOffset < pOtherList->m_nTimeOffset)) )
        {
            pMergeItem = pThisList;
            pThisList = pThisList->GetNext();
        }
        else
        {
            pMergeItem = pOtherList;
            pOtherList = pOtherList->GetNext();
        }
        pMergeItem->SetNext(NULL);
        if (!pResultTail)
        {
            pResultHead = pResultTail = pMergeItem;
        }
        else
        {
            pResultTail->SetNext(pMergeItem);
            pResultTail = pMergeItem;
        }
    }
    if (pThisList) pResultTail->SetNext(pThisList);
    else pResultTail->SetNext(pOtherList);
    return pResultHead;
}

CDirectMusicEventItem* CDirectMusicEventItem::ReviseEvent(short nGrid,
                                                          short nOffset,
                                                          DWORD* pdwVariation,
                                                          DWORD* pdwID,
                                                          WORD* pwMusic,
                                                          BYTE* pbPlaymode,
                                                          BYTE* pbFlags)
{
    CDirectMusicEventItem* pEvent = NULL;
    switch (m_dwEventTag)
    {
    case DMUS_EVENT_NOTE:
        pEvent = ((CDMStyleNote*)this)->ReviseEvent(nGrid, nOffset, pdwVariation, pdwID, pwMusic, pbPlaymode, pbFlags);
        break;
    case DMUS_EVENT_CURVE:
        pEvent = ((CDMStyleCurve*)this)->ReviseEvent(nGrid, nOffset);
        break;
    case DMUS_EVENT_MARKER:
        pEvent = ((CDMStyleMarker*)this)->ReviseEvent(nGrid);
        break;
    case DMUS_EVENT_ANTICIPATION:
        pEvent = ((CDMStyleAnticipation*)this)->ReviseEvent(nGrid);
        break;
    }
    return pEvent;
}

CDirectMusicEventItem* CDMStyleNote::ReviseEvent(short nGrid,
                                                 short nOffset,
                                                 DWORD* pdwVariation,
                                                 DWORD* pdwID,
                                                 WORD* pwMusic,
                                                 BYTE* pbPlaymode,
                                                 BYTE* pbFlags)
{
    CDMStyleNote* pNoteEvent = new CDMStyleNote;
    if (pNoteEvent)
    {
        pNoteEvent->m_nGridStart = nGrid;
        pNoteEvent->m_nTimeOffset = nOffset;
        pNoteEvent->m_dwVariation = pdwVariation ? *pdwVariation : m_dwVariation;
        pNoteEvent->m_dwEventTag = m_dwEventTag;
        pNoteEvent->m_mtDuration = m_mtDuration;
        pNoteEvent->m_bVelocity = m_bVelocity;
        pNoteEvent->m_bTimeRange = m_bTimeRange;
        pNoteEvent->m_bDurRange = m_bDurRange;
        pNoteEvent->m_bVelRange = m_bVelRange;
        pNoteEvent->m_bInversionId = m_bInversionId;
        pNoteEvent->m_bPlayModeFlags = pbPlaymode ? *pbPlaymode : m_bPlayModeFlags;
        pNoteEvent->m_wMusicValue = pwMusic ? *pwMusic : m_wMusicValue;
        pNoteEvent->m_dwFragmentID = pdwID ? *pdwID : m_dwFragmentID;
        pNoteEvent->m_bFlags = pbFlags ? *pbFlags : 0;
    }
    return pNoteEvent;
}

CDirectMusicEventItem* CDMStyleCurve::ReviseEvent(short nGrid, short nOffset)
{
    CDMStyleCurve* pCurveEvent = new CDMStyleCurve;
    if (pCurveEvent)
    {
        pCurveEvent->m_nGridStart = nGrid;
        pCurveEvent->m_nTimeOffset = nOffset;
        pCurveEvent->m_dwVariation = 0xffffffff;
        pCurveEvent->m_dwEventTag = m_dwEventTag;
        pCurveEvent->m_mtDuration = m_mtDuration;
        pCurveEvent->m_mtResetDuration = m_mtResetDuration;
        pCurveEvent->m_StartValue = m_StartValue;
        pCurveEvent->m_EndValue = m_EndValue;
        pCurveEvent->m_nResetValue = m_nResetValue;
        pCurveEvent->m_bEventType = m_bEventType;
        pCurveEvent->m_bCurveShape = m_bCurveShape;
        pCurveEvent->m_bCCData = m_bCCData;
        pCurveEvent->m_bFlags = m_bFlags;
        pCurveEvent->m_wParamType = m_wParamType;
        pCurveEvent->m_wMergeIndex = m_wMergeIndex;
    }
    return pCurveEvent;
}

CDirectMusicEventItem* CDMStyleMarker::ReviseEvent(short nGrid)
{
    CDMStyleMarker* pMarkerEvent = new CDMStyleMarker;
    if (pMarkerEvent)
    {
        pMarkerEvent->m_nGridStart = nGrid;
        pMarkerEvent->m_nTimeOffset = 0;
        pMarkerEvent->m_dwVariation = 0xffffffff;
        pMarkerEvent->m_dwEventTag = m_dwEventTag;
        pMarkerEvent->m_wFlags = m_wFlags;
    }
    return pMarkerEvent;
}

CDirectMusicEventItem* CDMStyleAnticipation::ReviseEvent(short nGrid)
{
    CDMStyleAnticipation* pAnticipationEvent = new CDMStyleAnticipation;
    if (pAnticipationEvent)
    {
        pAnticipationEvent->m_nGridStart = nGrid;
        pAnticipationEvent->m_nTimeOffset = m_nTimeOffset;
        pAnticipationEvent->m_dwVariation = 0xffffffff;
        pAnticipationEvent->m_dwEventTag = m_dwEventTag;
        pAnticipationEvent->m_bTimeRange = m_bTimeRange;
    }
    return pAnticipationEvent;
}

CDirectMusicEventList::~CDirectMusicEventList()

{
    CDirectMusicEventItem *pEvent;
    while (pEvent = RemoveHead())
    {
        delete pEvent;
    }
}

void CDirectMusicEventList::MergeSort(DirectMusicTimeSig& TimeSig)
{
    if (m_pHead != NULL && m_pHead->GetNext() != NULL)
        m_pHead = ((CDirectMusicEventItem *)m_pHead)->MergeSort(TimeSig);
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern constructor

CDirectMusicPattern::CDirectMusicPattern( DirectMusicTimeSig* pTimeSig, BOOL fMotif ) :
    m_wNumMeasures(1),
    m_cRef(1),
    m_wID(0),
    m_bGrooveBottom(1),
    m_bGrooveTop(100),
    m_bDestGrooveBottom(1),
    m_bDestGrooveTop(100),
    m_pRhythmMap(NULL),
//  m_pSwitchPoints(NULL),
    m_fSettings(FALSE),
    m_dwRepeats(0),
    m_mtPlayStart(0),
    m_mtLoopStart(0),
    m_mtLoopEnd(-1),
    m_dwResolution(0),
    m_pMotifBand(NULL),
    m_dwFlags(0)
{
    if ( pTimeSig != NULL )
    {
        m_timeSig = *pTimeSig;
    }
    // Set defaults
    if( fMotif )
    {
        m_wEmbellishment = EMB_MOTIF;
    }
    else
    {
        m_wEmbellishment = EMB_NORMAL;
    }
}

CDirectMusicPattern* CDirectMusicPattern::Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, BOOL fMotif)
{
    HRESULT hr = S_OK;
    CDirectMusicPattern* pNewPattern = new CDirectMusicPattern(&m_timeSig, fMotif);
    if (pNewPattern)
    {
        WORD wMeasureStart = (WORD)m_timeSig.ClocksToMeasure(mtStart);
        WORD wMeasureEnd = (WORD)m_timeSig.ClocksToMeasure(mtEnd);
        pNewPattern->m_wNumMeasures = wMeasureEnd - wMeasureStart;
        pNewPattern->m_cRef = m_cRef;
        pNewPattern->m_wID = m_wID;
        pNewPattern->m_bGrooveBottom = m_bGrooveBottom;
        pNewPattern->m_bGrooveTop = m_bGrooveTop;
        pNewPattern->m_bDestGrooveBottom = m_bDestGrooveBottom;
        pNewPattern->m_bDestGrooveTop = m_bDestGrooveTop;
        pNewPattern->m_fSettings = m_fSettings;
        pNewPattern->m_dwRepeats = m_dwRepeats;
        pNewPattern->m_strName = m_strName;
        pNewPattern->m_dwResolution = m_dwResolution;
        pNewPattern->m_dwFlags = m_dwFlags;
        if (m_mtPlayStart <= mtStart)
        {
            pNewPattern->m_mtPlayStart = 0;
        }
        else
        {
            pNewPattern->m_mtPlayStart = m_mtPlayStart - mtStart;
        }
        if (m_mtLoopStart <= mtStart)
        {
            pNewPattern->m_mtLoopStart = 0;
        }
        else
        {
            pNewPattern->m_mtLoopStart = m_mtLoopStart - mtStart;
        }
        if (m_mtLoopEnd >= (mtEnd - mtStart))
        {
            pNewPattern->m_mtLoopEnd = mtEnd - mtStart;
        }
        else if (m_mtLoopEnd < 0)
        {
            pNewPattern->m_mtLoopEnd = -1;
        }
        else
        {
            pNewPattern->m_mtLoopEnd = m_mtLoopEnd - mtStart;
        }
        pNewPattern->m_pRhythmMap = new DWORD[pNewPattern->m_wNumMeasures];
        if (!pNewPattern->m_pRhythmMap)
        {
            hr = E_FAIL;
            goto ON_END;
        }
        for (int i = 0; i < pNewPattern->m_wNumMeasures; i++)
        {
            pNewPattern->m_pRhythmMap[i] = m_pRhythmMap[i + wMeasureStart];
        }
        if (m_pMotifBand)
        {
            pNewPattern->m_pMotifBand = m_pMotifBand;
            pNewPattern->m_pMotifBand->AddRef();
        }
        TListItem<DirectMusicPartRef>* pPartRefItem = m_PartRefList.GetHead();
        int nParts = m_PartRefList.GetCount();
        for (i = 0; pPartRefItem && i < nParts; pPartRefItem = pPartRefItem->GetNext(), i++)
        {
            DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();
            DirectMusicPart* pPart = rPartRef.m_pDMPart;
            if (!pPart)
            {
                hr = E_FAIL;
                goto ON_END;
            }
            TListItem<DirectMusicPartRef>* pNew = pNewPattern->CreatePart(rPartRef, pPart->m_bPlayModeFlags, pNewPattern->m_wNumMeasures);
            if (!pNew)
            {
                hr = E_FAIL;
                goto ON_END;
            }
            DirectMusicPartRef& rNew = pNew->GetItemValue();
            // Now that I've got the new part, I need to add events to its event list based
            // on mtStart and mtEnd
            CDirectMusicEventItem* pEvent = pPart->EventList.GetHead();
            MUSIC_TIME mtClocksInGrid = m_timeSig.ClocksPerGrid();
            for (; pEvent; pEvent = pEvent->GetNext())
            {
                MUSIC_TIME mtEvent = m_timeSig.GridToClocks(pEvent->m_nGridStart);
                if (mtEvent >= mtStart && mtEvent < mtEnd)
                {
                    short nNewGrid = (short) ((mtEvent - mtStart) / mtClocksInGrid);
                    short nNewOffset = (short) (pEvent->m_nTimeOffset + (mtEvent - mtStart) % mtClocksInGrid);
                    CDirectMusicEventItem* pNewEvent = pEvent->ReviseEvent(nNewGrid, nNewOffset);
                    if (!pNewEvent)
                    {
                        hr = E_FAIL;
                        goto ON_END;
                    }
                    rNew.m_pDMPart->EventList.AddHead(pNewEvent);
                }
            }
            rNew.m_pDMPart->EventList.MergeSort(m_timeSig);
        }
    }
ON_END:
    if (FAILED(hr))
    {
        if (pNewPattern)
        {
            delete pNewPattern;
            pNewPattern = NULL;
        }
    }
    return pNewPattern;
}

HRESULT CDirectMusicPattern::LoadCurveList( LPSTREAM pStream, LPMMCKINFO pck, short nClickTime)
{
    HRESULT     hr = S_OK;
    DWORD       cb;
    WORD        wCurveSize;
    WORD        wCurveExtra;
    WORD        wSubSize;
    WORD        wSubExtra;
    long        lSize;
    ioSubCurve  iSubCurve;
    ioCurve     iCurve;
    WORD        wCount;
    CDirectMusicEventItem*  pCurve = NULL;

    lSize = pck->cksize;
    // read size of the curve structure
    hr = pStream->Read( &wCurveSize, sizeof( wCurveSize ), &cb );
    FixBytes( FBT_SHORT, &wCurveSize );
    if( FAILED( hr ) || cb != sizeof( wCurveSize ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    lSize -= cb;
    if( wCurveSize > sizeof( ioCurve ) )
    {
        wCurveExtra = static_cast<WORD>( wCurveSize - sizeof( ioCurve ) );
        wCurveSize = sizeof( ioCurve );
    }
    else
    {
        wCurveExtra = 0;
    }
    // read size of the subcurve structure
    hr = pStream->Read( &wSubSize, sizeof( wSubSize ), &cb );
    FixBytes( FBT_SHORT, &wSubSize );
    if( FAILED( hr ) || cb != sizeof( wSubSize ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    lSize -= cb;
    if( wSubSize > sizeof( ioSubCurve ) )
    {
        wSubExtra = static_cast<WORD>( wSubSize - sizeof( ioSubCurve ) );
        wSubSize = sizeof( ioSubCurve );
    }
    else
    {
        wSubExtra = 0;
    }
    // now read in the curve
    while( lSize > 0 )
    {
        hr = pStream->Read( &iCurve, wCurveSize, &cb );
        FixBytes( FBT_IOCURVE, &iCurve );
        if( FAILED( hr ) || cb != wCurveSize )
        {
            hr = E_FAIL;
            goto ON_ERR;
        }
        lSize -= cb;
        if( wCurveExtra > 0 )
        {
            StreamSeek( pStream, wCurveExtra, STREAM_SEEK_CUR );
            lSize -= wCurveExtra;
        }
        pCurve = new CDMStyleCurve;
        if( pCurve == NULL )
        {
            hr = E_FAIL;
            goto ON_ERR;
        }

        pCurve->m_dwVariation = iCurve.wVariation;
        pCurve->m_nGridStart = nClickTime;
        ((CDMStyleCurve*)pCurve)->m_bEventType = iCurve.bEventType;
        ((CDMStyleCurve*)pCurve)->m_bCCData = iCurve.bCCData;

        DirectMusicPart* pPart = FindPart(iCurve.bVoiceID);

        // read subcurve count
        hr = pStream->Read( &wCount, sizeof( wCount ), &cb );
        FixBytes( FBT_SHORT, &wCount );
        if( FAILED( hr ) || cb != sizeof( wCount ) )
        {
            hr = E_FAIL;
            delete pCurve;
            goto ON_ERR;
        }
        lSize -= cb;
        for( ; wCount > 0 ; --wCount )
        {
            // read subcurves
            hr = pStream->Read( &iSubCurve, wSubSize, &cb );
            FixBytes( FBT_IOSUBCURVE, &iSubCurve );
            if( FAILED( hr ) || cb != wSubSize )
            {
                hr = E_FAIL;
                delete pCurve;
                goto ON_ERR;
            }
            lSize -= wSubSize;
            if( wSubExtra > 0 )
            {
                StreamSeek( pStream, wSubExtra, STREAM_SEEK_CUR );
                lSize -= wSubExtra;
            }

            ((CDMStyleCurve*)pCurve)->m_bCurveShape = iSubCurve.bCurveType; // shape
            if (iSubCurve.nMaxTime < iSubCurve.nMinTime)
            {
                short n = iSubCurve.nMaxTime;
                iSubCurve.nMaxTime = iSubCurve.nMinTime;
                iSubCurve.nMinTime = n;
            }
            if (iSubCurve.nMaxValue < iSubCurve.nMinValue)
            {
                short n = iSubCurve.nMaxValue;
                iSubCurve.nMaxValue = iSubCurve.nMinValue;
                iSubCurve.nMinValue = n;
                iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
            }
            if( iSubCurve.fFlipped & CURVE_FLIPTIME )
            {
                switch( ((CDMStyleCurve*)pCurve)->m_bCurveShape )
                {
                    case DMUS_CURVES_LINEAR:
                        if( iSubCurve.fFlipped & CURVE_FLIPVALUE )
                        {
                            iSubCurve.fFlipped = 0;
                        }
                        else
                        {
                            iSubCurve.fFlipped = CURVE_FLIPVALUE;
                        }
                        break;

                    case DMUS_CURVES_INSTANT:
                        iSubCurve.nMinTime = iSubCurve.nMaxTime;
                        iSubCurve.nMaxTime = iSubCurve.nMinTime + 1;
                        break;

                    case DMUS_CURVES_EXP:
                        ((CDMStyleCurve*)pCurve)->m_bCurveShape = DMUS_CURVES_LOG;
                        iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
                        // log is the horiz flipped version of vertical flipped exp
                        break;

                    case DMUS_CURVES_LOG:
                        ((CDMStyleCurve*)pCurve)->m_bCurveShape = DMUS_CURVES_EXP;
                        iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
                        // exp is the horiz flipped version of vertical flipped log
                        break;

                    case DMUS_CURVES_SINE:
                        iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
                        // because horiz. and vert. flip are the same for sine wave
                        break;

                    default:
                        assert( 0 );
                        break;
                }
            }

            if( iSubCurve.fFlipped & CURVE_FLIPVALUE )
            {
                ((CDMStyleCurve*)pCurve)->m_StartValue = iSubCurve.nMaxValue;
                ((CDMStyleCurve*)pCurve)->m_EndValue = iSubCurve.nMinValue;
            }
            else
            {
                ((CDMStyleCurve*)pCurve)->m_StartValue = iSubCurve.nMinValue;
                ((CDMStyleCurve*)pCurve)->m_EndValue = iSubCurve.nMaxValue;
            }

            pCurve->m_nTimeOffset = ConvertTime(iSubCurve.nMinTime);
            ((CDMStyleCurve*)pCurve)->m_mtDuration = iSubCurve.nMaxTime - iSubCurve.nMinTime;
            ((CDMStyleCurve*)pCurve)->m_mtResetDuration = 0;
            ((CDMStyleCurve*)pCurve)->m_nResetValue = 0;
            ((CDMStyleCurve*)pCurve)->m_bFlags = 0;

            if (pPart != NULL)
            {
                pPart->EventList.AddHead(pCurve);
            }
            else
            {
                delete pCurve;
            }

            pCurve = new CDMStyleCurve;
            if( pCurve == NULL )
            {
              hr = E_FAIL;
             goto ON_ERR;
            }
            pCurve->m_dwVariation = iCurve.wVariation;
            pCurve->m_nGridStart = nClickTime;
            ((CDMStyleCurve*)pCurve)->m_bEventType = iCurve.bEventType;
            ((CDMStyleCurve*)pCurve)->m_bCCData = iCurve.bCCData;

        }
        // the loop generates an extra one, and if we don't enter the loop, we never used
        // the first one we generated.
        delete pCurve; 
    }
ON_ERR:
    return hr;
}

HRESULT CDirectMusicPattern::LoadNoteList( LPSTREAM pStream, LPMMCKINFO pck, short nClickTime)
{
    HRESULT     hr = S_OK;;
    ioNote      iNote;
    DWORD       cb;
    WORD        wNoteSize;
    WORD        wExtra;
    long        lSize;
    CDirectMusicEventItem*  pNote = NULL;

    lSize = pck->cksize;
    // read size of the note structure
    hr = pStream->Read( &wNoteSize, sizeof( wNoteSize ), &cb );
    FixBytes( FBT_SHORT, &wNoteSize );
    if( FAILED( hr ) || cb != sizeof( wNoteSize ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    lSize -= cb;
    if( wNoteSize > sizeof( ioNote ) )
    {
        wExtra = static_cast<WORD>( wNoteSize - sizeof( ioNote ) );
        wNoteSize = sizeof( ioNote );
    }
    else
    {
        wExtra = 0;
    }
    // now read in the notes
    while( lSize > 0 )
    {
        iNote.bPlayMode = 0;
        hr = pStream->Read( &iNote, wNoteSize, &cb );
        FixBytes( FBT_IONOTE, &iNote );
        if( FAILED( hr ) || cb != wNoteSize )
        {
            hr = E_FAIL;
            goto ON_ERR;
        }
        lSize -= wNoteSize;
        if( wExtra > 0 )
        {
            StreamSeek( pStream, wExtra, STREAM_SEEK_CUR );
            lSize -= wExtra;
        }
        pNote = new CDMStyleNote;
        if( pNote != NULL )
        {
            pNote->m_nGridStart = nClickTime;
            pNote->m_nTimeOffset = ConvertTime(iNote.nTime);
            pNote->m_dwVariation = iNote.wVariation;
            ((CDMStyleNote*)pNote)->m_bVelocity = iNote.bVelocity;
            ((CDMStyleNote*)pNote)->m_mtDuration = ConvertTime(iNote.nDuration);
            ((CDMStyleNote*)pNote)->m_bTimeRange = iNote.bTimeRange;
            ((CDMStyleNote*)pNote)->m_bDurRange = iNote.bDurRange;
            ((CDMStyleNote*)pNote)->m_bVelRange = iNote.bVelRange;
            ((CDMStyleNote*)pNote)->m_bInversionId = 0;  // not in IMA2.5
            ((CDMStyleNote*)pNote)->m_bFlags = 0;         // not in IMA2.5

            // Make sure SuperJAM! play mode is valid
            if ( !(iNote.bPlayMode & 0x80) )
            {
                iNote.bPlayMode = CHTYPE_NONE;
            }
            // Strip 0x80 before checking SuperJAM! play mode
                switch (iNote.bPlayMode & 0x0F)
                {
                    case CHTYPE_NOTINITIALIZED:
                    case CHTYPE_NONE:
                       ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
                       break;
                    case CHTYPE_DRUM:
                    case CHTYPE_FIXED:
                       ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                       break;
                     case CHTYPE_UPPER:
                     case CHTYPE_BASS:
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
                        break;
                    case CHTYPE_SCALEONLY:
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_PEDALPOINT;
                        break;
                    case CHTYPE_BASSMELODIC:
                    case CHTYPE_UPPERMELODIC:
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT;
                        break;
                    default:
                        // should never get here...
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                }
            //}
            DirectMusicPart* pPart = FindPart(iNote.bVoiceID);
            if (pPart != NULL)
            {
                pPart->EventList.AddHead(pNote);
            }
            else
            {
                assert(0);
            }
        // Determine playmode of note
            BYTE bNotePlayModeFlags;

            if( ((CDMStyleNote*)pNote)->m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
            {
                bNotePlayModeFlags = pPart->m_bPlayModeFlags;
            }
            else
            {
                bNotePlayModeFlags = ((CDMStyleNote*)pNote)->m_bPlayModeFlags;
            }

            // if ScaleValue is non-zero and the note isn't a pedalpoint, it's purpleized.
            if( iNote.bScaleValue != 0
            &&  bNotePlayModeFlags != DMUS_PLAYMODE_PEDALPOINT )
            {
                ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_PURPLEIZED;
            }
            // if the note is a drum event, use the (mapped) MIDI value;
            if( iNote.bVoiceID == 5 ) // it's a drum part
            {
                if (iNote.bValue < 128 && achMappings[iNote.bValue] < 128)
                    ((CDMStyleNote*)pNote)->m_wMusicValue = achMappings[iNote.bValue];
                else
                {
                    ((CDMStyleNote*)pNote)->m_wMusicValue = 0;
                }
            }
            // otherwise, if it's fixed, use the unmapped Midi value
            else if( bNotePlayModeFlags == DMUS_PLAYMODE_FIXED )
            {
                ((CDMStyleNote*)pNote)->m_wMusicValue = iNote.bValue;
            }
            // otherwise, use MusicValue
            else
            {
                ((CDMStyleNote*)pNote)->m_wMusicValue = iNote.nMusicValue;
            }

        }
    }
ON_ERR:
    return hr;
}

HRESULT CDirectMusicPattern::LoadEvents( IAARIFFStream* pRIFF, MMCKINFO* pckMain )
{
    ioClick iClick;
    HRESULT hr = S_OK;
    LPSTREAM pStream;
    MMCKINFO ck;
    DWORD cSize;
    DWORD cb;
    BOOL fClickLoaded = FALSE;

    pStream = pRIFF->GetStream();
    if ( pStream == NULL ) return E_FAIL;

    short nClickTime = 0;
    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
        case FOURCC_CLICK:
            fClickLoaded = TRUE;
            cSize = min( ck.cksize, sizeof( iClick ) );
            hr = pStream->Read( &iClick, cSize, &cb );
            FixBytes( FBT_IOCLICK, &iClick );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            nClickTime = iClick.lTime;
            break;
        case FOURCC_NOTE:
            if (fClickLoaded)
                LoadNoteList( pStream, &ck, nClickTime);
            else
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            break;
        case FOURCC_CURVE:
            if (fClickLoaded)
                LoadCurveList( pStream, &ck, nClickTime);
            else
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }

ON_ERR:
    pStream->Release();
    return hr;
}

void CDirectMusicPattern::CleanUp()
{
    if (m_pRhythmMap != NULL)
    {
        delete [] m_pRhythmMap;
        m_pRhythmMap = NULL;
    }
/*  if (m_pSwitchPoints != NULL)
    {
        delete [] m_pSwitchPoints;
        m_pSwitchPoints = NULL;
    }*/

    if (m_pMotifBand)
    {
        m_pMotifBand->Release();
        m_pMotifBand = NULL;
    }

    m_PartRefList.CleanUp();
}

STDMETHODIMP_(ULONG) CDirectMusicPattern::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDirectMusicPattern::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

DirectMusicPart* CDirectMusicPattern::FindPart(BYTE bVoiceID)
{
    TListItem<DirectMusicPartRef> *li;

    for(li = m_PartRefList.GetHead(); li != NULL; li = li->GetNext())
    {
        if (VOICEID_TO_CHANNEL(bVoiceID + 1) == li->GetItemValue().m_dwLogicalPartID)
            return li->GetItemValue().m_pDMPart;
    }
    return NULL;

}

TListItem<DirectMusicPartRef>* CDirectMusicPattern::FindPartRefByPChannel(DWORD dwPChannel)
{
    TListItem<DirectMusicPartRef> *li;

    for(li = m_PartRefList.GetHead(); li != NULL; li = li->GetNext())
    {
        if (dwPChannel == li->GetItemValue().m_dwLogicalPartID)
            return li;
    }
    return NULL;
}

TListItem<DirectMusicPartRef>* CDirectMusicPattern::CreatePart( DirectMusicPartRef& rPartRef, BYTE bPlaymode, WORD wMeasures )
{
    TListItem<DirectMusicPartRef>* pNewPartRef = FindPartRefByPChannel(rPartRef.m_dwLogicalPartID);
    if (pNewPartRef)
    {
        DirectMusicPartRef& rNewPartRef = pNewPartRef->GetItemValue();
        DirectMusicPart* pFoundPart = rNewPartRef.m_pDMPart;
        DirectMusicPart* pOtherPart = rPartRef.m_pDMPart;
        if (pFoundPart && pOtherPart)
        {
            if (pOtherPart->m_bInvertUpper > pFoundPart->m_bInvertUpper)
            {
                pFoundPart->m_bInvertUpper = pOtherPart->m_bInvertUpper;
            }
            if (pOtherPart->m_bInvertLower < pFoundPart->m_bInvertLower)
            {
                pFoundPart->m_bInvertLower = pOtherPart->m_bInvertLower;
            }
            pFoundPart->m_dwFlags |= pOtherPart->m_dwFlags;
        }
    }
    else
    {
        pNewPartRef = new TListItem<DirectMusicPartRef>;
        if( pNewPartRef )
        {
            DirectMusicPart* pPart = new DirectMusicPart;
            if( !pPart )
            {
                delete pNewPartRef;
                pNewPartRef = NULL;
            }
            else
            {
                DirectMusicPartRef& rNewPartRef = pNewPartRef->GetItemValue();
                // initialize the new part...
                DirectMusicPart* pOtherPart = rPartRef.m_pDMPart;
                if (pPart && pOtherPart)
                {
                    pPart->m_guidPartID = pOtherPart->m_guidPartID;
                    pPart->m_timeSig = m_timeSig;
                    for (int i = 0; i < 32; i++) // activate all variations
                    {
                        pPart->m_dwVariationChoices[i] = 0x7fffffff;
                    }
                    pPart->m_bPlayModeFlags = bPlaymode;
                    pPart->m_bInvertUpper = pOtherPart->m_bInvertUpper;
                    pPart->m_bInvertLower = pOtherPart->m_bInvertLower;
                    pPart->m_dwFlags = pOtherPart->m_dwFlags;
                    pPart->m_wNumMeasures = wMeasures;
                }
                // initialize the new part ref...
                rNewPartRef.m_pDMPart = pPart;
                rNewPartRef.m_dwLogicalPartID = rPartRef.m_dwLogicalPartID;
                rNewPartRef.m_bVariationLockID = rPartRef.m_bVariationLockID;
                rNewPartRef.m_bSubChordLevel = rPartRef.m_bSubChordLevel;
                rNewPartRef.m_bPriority = rPartRef.m_bPriority;
                rNewPartRef.m_bRandomVariation = rPartRef.m_bRandomVariation;
                m_PartRefList.AddTail(pNewPartRef);
            }
        }
    }
    return pNewPartRef;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_LoadPattern

HRESULT CDirectMusicPattern::DM_LoadPattern(
            IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle )
{
    TListItem<DirectMusicPartRef>* pPartRefItem = NULL;
    DirectMusicPart* pPart;
    IStream*    pIStream;
    HRESULT     hr = S_OK;
    DWORD       dwByteCount;
    DWORD       dwSize;
    MMCKINFO    ck;
    MMCKINFO    ckList;
    int         i;

    if ( pStyle == NULL ) return E_INVALIDARG;
    if ( pIRiffStream == NULL ) return E_INVALIDARG;
    if ( pckMain == NULL ) return E_INVALIDARG;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    // Load the Pattern
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_PATTERN_CHUNK:
            {
                DMUS_IO_PATTERN iDMPattern;
                memset(&iDMPattern, 0, sizeof(iDMPattern));

                dwSize = min( ck.cksize, sizeof( DMUS_IO_PATTERN ) );
                hr = pIStream->Read( &iDMPattern, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_bGrooveBottom = iDMPattern.bGrooveBottom;
                m_bGrooveTop = iDMPattern.bGrooveTop;
                m_wEmbellishment = iDMPattern.wEmbellishment;
                m_bDestGrooveBottom = iDMPattern.bDestGrooveBottom;
                m_bDestGrooveTop = iDMPattern.bDestGrooveTop;
                m_dwFlags = iDMPattern.dwFlags;

                m_timeSig.m_bBeatsPerMeasure = iDMPattern.timeSig.bBeatsPerMeasure;
                m_timeSig.m_bBeat = iDMPattern.timeSig.bBeat;
                m_timeSig.m_wGridsPerBeat = iDMPattern.timeSig.wGridsPerBeat;

                m_wNumMeasures = iDMPattern.wNbrMeasures;
                break;
            }

            case DMUS_FOURCC_RHYTHM_CHUNK:
                if( m_pRhythmMap )
                {
                    delete [] m_pRhythmMap;
                    m_pRhythmMap = NULL;
                }
                m_pRhythmMap = new DWORD[m_wNumMeasures];
                if( m_pRhythmMap == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_ERROR;
                }
                for( i = 0 ;  i < m_wNumMeasures ;  i++ )
                {
                    hr = pIStream->Read( &m_pRhythmMap[i], sizeof(DWORD), &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != sizeof(DWORD) )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                }
                break;

/*          case DMUS_FOURCC_SWITCH_POINT_CHUNK:
                if( m_pSwitchPoints )
                {
                    delete [] m_pSwitchPoints;
                    m_pSwitchPoints = NULL;
                }
                m_pSwitchPoints = new DWORD[m_wNumMeasures];
                if( m_pSwitchPoints == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_ERROR;
                }
                for( i = 0 ;  i < m_wNumMeasures ;  i++ )
                {
                    hr = pIStream->Read( &m_pSwitchPoints[i], sizeof(DWORD), &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != sizeof(DWORD) )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                }
                break;
*/
            case DMUS_FOURCC_MOTIFSETTINGS_CHUNK:
            {
                DMUS_IO_MOTIFSETTINGS ioMotifSettings;
                hr = pIStream->Read( &ioMotifSettings, sizeof(DMUS_IO_MOTIFSETTINGS), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof(DMUS_IO_MOTIFSETTINGS) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                m_fSettings = TRUE;
                m_dwRepeats = ioMotifSettings.dwRepeats;
                m_mtPlayStart = ioMotifSettings.mtPlayStart;
                m_mtLoopStart = ioMotifSettings.mtLoopStart;
                m_mtLoopEnd = ioMotifSettings.mtLoopEnd;
                m_dwResolution = ioMotifSettings.dwResolution;
                break;
            }

            case FOURCC_RIFF:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_BAND_FORM:
                    {
                        // load band associated with the motif
                        if (m_pMotifBand)
                        {
                            m_pMotifBand->Release();
                            m_pMotifBand = NULL;
                        }

                        // Create a band
                        hr = CoCreateInstance(CLSID_DirectMusicBand,
                                              NULL,
                                              CLSCTX_INPROC,
                                              IID_IDirectMusicBand,
                                              (void**)&m_pMotifBand);
                        if(SUCCEEDED(hr))
                        {
                            // Seek back to begining of Riff chunk
                            // This is the amount read by Descend when descending into a FOURCC_RIFF chunk
                            // Get current position
                            LARGE_INTEGER li;
                            ULARGE_INTEGER ul;
                            li.HighPart = 0;
                            li.LowPart = 0;
                            hr = pIStream->Seek(li,
                                               STREAM_SEEK_CUR,
                                               &ul);
                            if(SUCCEEDED(hr))
                            {
                                li.HighPart = 0;
                                // This is always a valid operation
                                li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
                                hr = pIStream->Seek(li,
                                                   STREAM_SEEK_SET,
                                                   &ul);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            // Load band
                            IPersistStream* pIPersistStream;
                            hr = m_pMotifBand->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
                            if(SUCCEEDED(hr))
                            {
                                hr = pIPersistStream->Load(pIStream);
                                pIPersistStream->Release();
                            }
                        }
                        if(FAILED(hr))
                        {
                            if (m_pMotifBand)
                            {
                                m_pMotifBand->Release();
                                m_pMotifBand = NULL;
                            }
                            goto ON_ERROR;
                        }
                        break;
                    }
                }
                break;

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_UNFO_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
                        {
                            switch( ckList.ckid )
                            {
                                case RIFFINFO_INAM:
                                case DMUS_FOURCC_UNAM_CHUNK:
                                {
                                    DWORD dwLength = min(ckList.cksize, (DWORD)(sizeof(WCHAR)*(DMUS_MAX_NAME - 1)));
                                    hr = ReadMBSfromWCS( pIStream, dwLength, m_strName );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    break;
                                }
                            }
                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;

                    case DMUS_FOURCC_PART_LIST:     // only in GUID_SinglePattern format
                        pPart = pStyle->AllocPart();
                        if( pPart == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        hr = pPart->DM_LoadPart( pIRiffStream, &ck, pStyle );
                        if( FAILED( hr ) )
                        {
                            pStyle->DeletePart( pPart );
                            goto ON_ERROR;
                        }
                        if( hr == S_FALSE )
                        {
                            // Bypass this Part because Style already contains a Part
                            // whose GUID matches pPart->m_guidPartID
                            pStyle->DeletePart( pPart );
                        }
                        else // merge the part's marker events
                        {
                            pPart->MergeMarkerEvents(pStyle, this);
                        }
                        break;

                    case DMUS_FOURCC_PARTREF_LIST:
                        hr = AllocPartRef(pPartRefItem);
                        if ( FAILED(hr) )
                        {
                            goto ON_ERROR;
                        }
                        hr = pPartRefItem->GetItemValue().DM_LoadPartRef( pIRiffStream, &ck, pStyle );
                        if ( FAILED( hr ) )
                        {
                            DeletePartRef( pPartRefItem );
                            goto ON_ERROR;
                        }

                        break;
                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern additional functions

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::AllocPartRef

HRESULT CDirectMusicPattern::AllocPartRef(TListItem<DirectMusicPartRef>*& rpPartRefItem)
{
    rpPartRefItem = new TListItem<DirectMusicPartRef>;

    if (rpPartRefItem)
    {
        // Add PartRef to Pattern's list of Parts
        m_PartRefList.AddTail( rpPartRefItem );
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DeletePartRef

void CDirectMusicPattern::DeletePartRef(TListItem<DirectMusicPartRef>* pPartRefItem)
{
    // add stuff later...
}

HRESULT CDirectMusicPattern::LoadPattern(IAARIFFStream* pRIFF,
                                         MMCKINFO* pckMain,
                                         TList<DirectMusicPart*> &partList,
                                         DMStyleStruct& rStyleStruct
                                         )
{
    int         i;
    int         j;
    ioPattern   iPattern;
    LPSTREAM    pStream;
    HRESULT     hr = S_OK;
    MMCKINFO    ck;
    DWORD       cb;
    DWORD       cSize;
    WORD        wKludge;
    DWORD       dwRhythm = 1;     // make it a whole note pattern by default

    pStream = pRIFF->GetStream();
    if ( pStream == NULL ) return E_FAIL;

    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
        case FOURCC_PATTERN:
            cSize = min( ck.cksize, sizeof( iPattern ) );
            hr = pStream->Read( &iPattern, cSize, &cb );
            FixBytes( FBT_IOPATTERN, &iPattern );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            m_strName = iPattern.wstrName;
            m_timeSig.m_bBeatsPerMeasure = static_cast<BYTE>( iPattern.dwLength / static_cast<long>( iPattern.wClocksPerBeat ) / iPattern.wMeasures );
            m_timeSig.m_bBeat = static_cast<BYTE>(iPattern.wBeat);
            m_timeSig.m_wGridsPerBeat = iPattern.wClocksPerBeat / iPattern.wClocksPerClick;
            m_wNumMeasures = iPattern.wMeasures;
            // Bottom of groove range is 1 if either level A or no levels were specified;
            // 26 if level B is the lowest level specified, etc.
            if ( iPattern.fFlags & PF_A || !(iPattern.fFlags & (PF_A | PF_B | PF_C | PF_D)) )
                m_bGrooveBottom = 1;
            else if (iPattern.fFlags & PF_B) m_bGrooveBottom = 26;
            else if (iPattern.fFlags & PF_C) m_bGrooveBottom = 51;
            else m_bGrooveBottom = 76;
            // Top of groove range is 100 if either level D or no levels were specified;
            // 75 if level C is the highest level specified, etc.
            if ( iPattern.fFlags & PF_D || !(iPattern.fFlags & (PF_A | PF_B | PF_C | PF_D)) )
                m_bGrooveTop = 100;
            else if (iPattern.fFlags & PF_C) m_bGrooveTop = 75;
            else if (iPattern.fFlags & PF_B) m_bGrooveTop = 50;
            else m_bGrooveTop = 25;
            m_wEmbellishment = EMB_NORMAL;
            if (iPattern.fFlags & PF_FILL) m_wEmbellishment |= EMB_FILL;
            if (iPattern.fFlags & PF_INTRO) m_wEmbellishment |= EMB_INTRO;
            if (iPattern.fFlags & PF_END) m_wEmbellishment |= EMB_END;
            if (iPattern.fFlags & PF_BREAK) m_wEmbellishment |= EMB_BREAK;
            if (iPattern.fFlags & PF_MOTIF) m_wEmbellishment |= EMB_MOTIF;
            m_pRhythmMap = new DWORD[iPattern.wMeasures];
            if( m_pRhythmMap == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto ON_ERR;
            }
            if (iPattern.fFlags & PF_WHOLE) dwRhythm = 1;    // bit 1 set
            if (iPattern.fFlags & PF_HALF) dwRhythm = 5;     // bits 1 and 3
            if (iPattern.fFlags & PF_QUARTER) dwRhythm = 15; // bits 1-4
            for (i = 0; i < iPattern.wMeasures; ++i)
            {
                m_pRhythmMap[i] = dwRhythm;
            }
            for( i = 0 ; i < 16 ; ++i ) // loop over Parts
            {
                TListItem<DirectMusicPart*> *pPartItem = new TListItem<DirectMusicPart*>;
                if( pPartItem == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_ERR;
                }
                DirectMusicPart*& pPart = pPartItem->GetItemValue();
                pPart = new DirectMusicPart;
                if( pPart == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_ERR;
                }
                pPart->m_wNumMeasures = m_wNumMeasures;
                TListItem<DirectMusicPartRef> *pPartRefItem = new TListItem<DirectMusicPartRef>;
                if( pPartRefItem == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_ERR;
                }
                DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();
                rPartRef.m_pDMPart = pPart;
                rPartRef.m_pDMPart->AddRef();
                rPartRef.m_dwLogicalPartID = VOICEID_TO_CHANNEL(i + 1);
                AdjoinPChannel(rStyleStruct.m_PChannelList, rPartRef.m_dwLogicalPartID);
                rPartRef.m_bVariationLockID = 0;  // 0 means no locking between parts...
                rPartRef.m_bRandomVariation = DMUS_VARIATIONT_RANDOM;  // (default in 2.5)
                if( iPattern.wInvert & (1 << i) )
                {
                    pPart->m_bInvertLower = iPattern.abInvertLower[i];
                    pPart->m_bInvertUpper = iPattern.abInvertUpper[i];
                }
                else
                {
                    pPart->m_bInvertLower = 0;
                    pPart->m_bInvertUpper = 127;
                }
                if (iPattern.achChordChoice[i] == CHTYPE_UPPER ||
                    iPattern.achChordChoice[i] == CHTYPE_UPPERMELODIC)
                {
                    rPartRef.m_bSubChordLevel = SUBCHORD_STANDARD_CHORD;
                }
                else
                {
                    rPartRef.m_bSubChordLevel = SUBCHORD_BASS;
                }
                switch (iPattern.achChordChoice[i])
                {
                    case CHTYPE_DRUM:
                    case CHTYPE_FIXED:
                       pPart->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                       break;
                     case CHTYPE_UPPER:
                     case CHTYPE_BASS:
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
                        break;
                    case CHTYPE_SCALEONLY:
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_PEDALPOINT;
                        break;
                    case CHTYPE_BASSMELODIC:
                    case CHTYPE_UPPERMELODIC:
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT;
                        break;
                    default:
                        // should never get here...
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                }



// if none of the variations have the ->I or ->V flag set, set it in all variations
                wKludge = VF_TO1 | VF_TO5;
                for (j = 16; j < 32; j++) pPart->m_dwVariationChoices[j] = 0;
                for( j = 0 ; j < 16 ; ++j )
                {
                    pPart->m_dwVariationChoices[j] = iPattern.awVarFlags[i][j];
                    if( ( pPart->m_dwVariationChoices[j] & VF_TO1 ) != 0 )
                    {
                        wKludge &= ~VF_TO1;
                    }
                    if( ( pPart->m_dwVariationChoices[j] & VF_TO5 ) != 0 )
                    {
                        wKludge &= ~VF_TO5;
                    }
                }
                if( wKludge != 0 )
                {
                    for( j = 0 ; j < 16 ; ++j )
                    {
                        pPart->m_dwVariationChoices[j] |= wKludge;
                    }
                }
                partList.AddTail(pPartItem);
                m_PartRefList.AddTail(pPartRefItem);
            }
            break;
        case FOURCC_LIST:
            switch( ck.fccType )
            {
                case FOURCC_CLICK_LIST:
                    LoadEvents(pRIFF, &ck);
                    break;
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }

ON_ERR:
    pStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_LoadPartRef

HRESULT DirectMusicPartRef::DM_LoadPartRef(
                IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle )
{
    DirectMusicPart* pPart;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwByteCount;
    DWORD dwSize;

    if ( pStyle == NULL ) return E_INVALIDARG;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_PARTREF_CHUNK:
            {
                DMUS_IO_PARTREF iDMPartRef;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_PARTREF ) );
                hr = pIStream->Read( &iDMPartRef, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_bRandomVariation = iDMPartRef.bRandomVariation;
                if (dwSize < DX8_PARTREF_SIZE)
                {
                    m_dwLogicalPartID = iDMPartRef.wLogicalPartID;
                }
                else
                {
                    m_dwLogicalPartID = iDMPartRef.dwPChannel;
                }
                AdjoinPChannel(pStyle->m_PChannelList, m_dwLogicalPartID);
                m_bVariationLockID = iDMPartRef.bVariationLockID;
                m_bSubChordLevel = iDMPartRef.bSubChordLevel;
                m_bPriority = iDMPartRef.bPriority;

                pPart = pStyle->FindPartByGUID( iDMPartRef.guidPartID );
                if( pPart == NULL )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                SetPart( pPart );
                break;
            }

        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DirectMusicPartRef::SetPart

void DirectMusicPartRef::SetPart( DirectMusicPart* pPart )
{
    if( m_pDMPart == pPart )
    {
        return;
    }

    if( m_pDMPart )
    {
        m_pDMPart->Release();
    }

    if( pPart )
    {
        m_pDMPart = pPart;
        m_pDMPart->AddRef();
    }
}


CDMStyle::CDMStyle() : m_cRef(1), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    m_StyleInfo.m_fLoaded = false;
    m_StyleInfo.m_dwFlags = 0;
    m_StyleInfo.m_pDefaultBand = NULL;
    m_StyleInfo.m_pDefaultPers = NULL;
}

CDMStyle::~CDMStyle()
{
    if (m_fCSInitialized)
    {
        // Don't need to clean up if critical section failed.
        // DON'T MOVE THIS - it will fault in low memory conditions
        //
        CleanUp();

        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

HRESULT CDMStyle::GetStyleInfo(void **pData)
{
    *pData = (void *) &m_StyleInfo;
    return S_OK;
}

HRESULT CDMStyle::IsDX8()
{
    return m_StyleInfo.UsingDX8() ? S_OK : S_FALSE;
}

HRESULT CDMStyle::CritSec(bool fEnter)
{
    HRESULT hr = S_OK;
    if (m_fCSInitialized)
    {
        if (fEnter)
        {
            EnterCriticalSection(&m_CriticalSection);
        }
        else
        {
            LeaveCriticalSection(&m_CriticalSection);
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

/* IPersist methods */
 HRESULT CDMStyle::GetClassID( LPCLSID pclsid )
{
    //assert ( pclsid != NULL );
    *pclsid = CLSID_DirectMusicStyle;
    return S_OK;
}

HRESULT CDMStyle::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

HRESULT CDMStyle::Save( LPSTREAM pStream, BOOL /*fClearDirty*/ )
{

    return E_NOTIMPL;
}

HRESULT CDMStyle::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMStyle::Load( LPSTREAM pIStream )
{
    DWORD dwPos;
    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT         hr = E_FAIL;

    if( pIStream == NULL )
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    CleanUp();
    dwPos = StreamTell( pIStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_STYLE_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_LoadStyle( pIRiffStream, &ckMain );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
        pIRiffStream = NULL;
    }

    // Check for IMA 2.5 format
    if( !fFoundFormat )
    {
        StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

        if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
        {
            ckMain.fccType = FOURCC_STYLE_FORM;

            if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
            {
                hr = IMA25_LoadStyle( pIRiffStream, &ckMain );
                fFoundFormat = TRUE;
            }
            pIRiffStream->Release();
        }
    }

    if (SUCCEEDED(hr)) m_StyleInfo.m_fLoaded = true;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

void CDMStyle::CleanUp()
{
    EnterCriticalSection(&m_CriticalSection);

    m_StyleInfo.m_fLoaded = false;
    TListItem<IDirectMusicBand*>* pBandListItem = (m_StyleInfo.m_BandList).GetHead();
    for (; pBandListItem; pBandListItem = pBandListItem->GetNext())
    {
        IDirectMusicBand* pBand = pBandListItem->GetItemValue();
        if(pBand)
        {
            pBand->Release();
        }
    }
    m_StyleInfo.m_BandList.CleanUp();
    TListItem<IDirectMusicChordMap*>* pPersListItem = (m_StyleInfo.m_PersList).GetHead();
    for (; pPersListItem; pPersListItem = pPersListItem->GetNext())
    {
        IDirectMusicChordMap* pPers = pPersListItem->GetItemValue();
        if(pPers)
        {
            pPers->Release();
        }
    }
    m_StyleInfo.m_PersList.CleanUp();

    TListItem<DirectMusicPart*>* pPartListItem = (m_StyleInfo.m_PartList).GetHead();
    for (int count = 0; pPartListItem; pPartListItem = pPartListItem->GetNext(),count++)
    {
        DirectMusicPart* pPart = pPartListItem->GetItemValue();
        if(pPart)
        {
            if (pPart->Release() == 0)
            {
                pPartListItem->GetItemValue() = NULL;
            }
        }
    }
    m_StyleInfo.m_PartList.CleanUp();

    TListItem<CDirectMusicPattern*>* pPatternListItem = (m_StyleInfo.m_PatternList).GetHead();
    for (; pPatternListItem; pPatternListItem = pPatternListItem->GetNext())
    {
        CDirectMusicPattern* pPattern = pPatternListItem->GetItemValue();
        if(pPattern)
        {
            if (pPattern->Release() == 0)
            {
                pPatternListItem->GetItemValue() = NULL;
            }
        }
    }
    m_StyleInfo.m_PatternList.CleanUp();

    pPatternListItem = (m_StyleInfo.m_MotifList).GetHead();
    for (; pPatternListItem; pPatternListItem = pPatternListItem->GetNext())
    {
        CDirectMusicPattern* pPattern = pPatternListItem->GetItemValue();
        if(pPattern)
        {
            pPattern->Release();
        }
    }
    m_StyleInfo.m_MotifList.CleanUp();

    m_StyleInfo.m_PChannelList.CleanUp();

    LeaveCriticalSection(&m_CriticalSection);
}

HRESULT CDMStyle::IMA25_LoadPersonalityReference( IStream* pStream, MMCKINFO* pck )
{
    ioPersonalityRef ref;
    DWORD dwSize;
    WORD wStructSize;
    String strFileName;
    HRESULT hr = S_OK;
    HRESULT hrChordMap = E_FAIL;

    if ( pStream == NULL ) return E_POINTER;
    dwSize = pck->cksize;
    pStream->Read( &wStructSize, sizeof( wStructSize ), NULL );
    FixBytes( FBT_SHORT, &wStructSize );
    dwSize -= sizeof( wStructSize );
    if( wStructSize > sizeof(ref) )
    {
        hr = pStream->Read( &ref, sizeof(ref), NULL );
        FixBytes( FBT_IOPERSONALITYREF, &ref );
        StreamSeek( pStream, wStructSize - sizeof(ref), STREAM_SEEK_CUR );
    }
    else
    {
        hr = pStream->Read( &ref, wStructSize, NULL );
        FixBytes( FBT_IOPERSONALITYREF, &ref );
    }
    if (!SUCCEEDED(hr)) return hr;
    dwSize -= wStructSize;
    // loader stuff here...
    DMUS_OBJECTDESC ObjectDescript;
    ZeroMemory(&ObjectDescript, sizeof(DMUS_OBJECTDESC));
    ObjectDescript.dwSize = sizeof(DMUS_OBJECTDESC);
    ObjectDescript.guidClass = CLSID_DirectMusicChordMap;
    wcscpy(ObjectDescript.wszName, ref.wstrName);
    ObjectDescript.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_NAME;
    IDirectMusicLoader* pLoader;
    IDirectMusicGetLoader *pIGetLoader;
    hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (!SUCCEEDED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (!SUCCEEDED(hr)) return hr;
    IDirectMusicObject* pObject = NULL;
    // Ignore this result (except for purposes of incorporating it into the style):
    // success or failure of loading individual ChordMap references should have no 
    // bearing on the success or failure of loading the style.
    hrChordMap = pLoader->GetObject(&ObjectDescript, IID_IDirectMusicObject, (void**)&pObject);
    if (!SUCCEEDED(hrChordMap))
    {
        hr = strFileName.ReadWCS( pStream, dwSize );
        if (SUCCEEDED(hr))
        {
            strFileName += ".per";
            wcscpy(ObjectDescript.wszFileName, strFileName);
            ObjectDescript.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
            hrChordMap = pLoader->GetObject(&ObjectDescript, IID_IDirectMusicObject, (void**)&pObject);
        }
    }
    pLoader->Release();
    if (SUCCEEDED(hrChordMap))
    {
        IDirectMusicChordMap* pPers;
        hr = pObject->QueryInterface(IID_IDirectMusicChordMap, (void**)&pPers);
        pObject->Release();
        if (SUCCEEDED(hr))
        {
            hr = IncorporatePersonality(pPers, ref.wstrName, ref.fDefault);
        }
    }

    return hr;
}

HRESULT CDMStyle::IncorporatePersonality( IDirectMusicChordMap* pPers, String strName, BOOL fDefault )
{
    EnterCriticalSection( &m_CriticalSection );
    TListItem<IDirectMusicChordMap*>* pScan = m_StyleInfo.m_PersList.GetHead();
    for( ; pScan != NULL ; pScan = pScan->GetNext() )
    {
        HRESULT hr = S_OK;
        String str2;

        IDirectMusicObject *pIObject = NULL;
        DMUS_OBJECTDESC Desc;              // Descriptor.

        if (SUCCEEDED(hr = pScan->GetItemValue()->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject)))
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    str2 = Desc.wszName;
                    if (strName == str2)
                    {
                        pPers->Release();
                        break;
                    }
                }
                else hr = E_FAIL;
            }
            pIObject->Release();
        }
        if (!SUCCEEDED(hr))
        {
            LeaveCriticalSection( &m_CriticalSection );
            return hr;
        }
    }
    if( pScan == NULL )
    {
        TListItem<IDirectMusicChordMap*>* pNew = NULL;
        pNew = new TListItem<IDirectMusicChordMap*>(pPers);
        if (pNew)
        {
            m_StyleInfo.m_PersList.AddHead(pNew);
            if (fDefault)
            {
                if (m_StyleInfo.m_pDefaultPers) m_StyleInfo.m_pDefaultPers->Release();
                m_StyleInfo.m_pDefaultPers = pPers;
            }
        }
    }
    LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDMStyle::DM_ParseDescriptor

HRESULT CDMStyle::DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  )
{
    IStream*      pIStream;
    MMCKINFO      ck;
    MMCKINFO      ckList;
    DWORD         dwByteCount;
    DWORD         dwSize;
    DWORD         dwPos;
    HRESULT       hr = S_OK;
    String        str;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicStyle;
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &pDesc->guidObject, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_ERROR;
                }
                else
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
            {
                dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
                hr = pIStream->Read( &pDesc->vVersion, dwSize, &dwByteCount );
                if( FAILED( hr )||  dwByteCount != dwSize )
                {
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_ERROR;
                }
                else
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;
            }

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_UNFO_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
                        {
                            switch( ckList.ckid )
                            {
                                case RIFFINFO_INAM:
                                case DMUS_FOURCC_UNAM_CHUNK:
                                {
                                    DWORD dwLength = min(ckList.cksize, (DWORD)(sizeof(WCHAR)*(DMUS_MAX_NAME - 1)));
                                    hr = ReadMBSfromWCS( pIStream, dwLength, str );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    wcscpy(pDesc->wszName, str);
                                    if(pDesc->wszName[0])
                                    {
                                        pDesc->dwValidData |= DMUS_OBJ_NAME;
                                        pDesc->wszName[16] = 0;
                                    }
                                    break;
                                }

                                case DMUS_FOURCC_CATEGORY_CHUNK:
                                {
                                    DWORD dwLength = min(ckList.cksize, (DWORD)(sizeof(WCHAR)*(DMUS_MAX_CATEGORY - 1)));
                                    hr = ReadMBSfromWCS( pIStream, dwLength, str );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    wcscpy(pDesc->wszCategory, str);
                                    if(pDesc->wszCategory[0])
                                    {
                                        pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                                        pDesc->wszCategory[16] = 0;
                                    }
                                    break;
                                }
                            }
                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;

                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDMStyle::DM_LoadStyle

HRESULT CDMStyle::DM_LoadStyle( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain  )
{
    DirectMusicPart* pPart;
    IStream*      pIStream;
    MMCKINFO      ck;
    MMCKINFO      ckList;
    DWORD         dwByteCount;
    DWORD         dwSize;
    DWORD         dwPos;
    HRESULT       hr = S_OK;
    HRESULT       hrBand = S_OK;
    BOOL          fFoundDefault = FALSE;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_STYLE_CHUNK:
            {
                DMUS_IO_STYLE iDMStyle;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLE ) );
                hr = pIStream->Read( &iDMStyle, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_StyleInfo.m_TimeSignature.m_bBeatsPerMeasure = iDMStyle.timeSig.bBeatsPerMeasure;
                m_StyleInfo.m_TimeSignature.m_bBeat = iDMStyle.timeSig.bBeat;
                m_StyleInfo.m_TimeSignature.m_wGridsPerBeat = iDMStyle.timeSig.wGridsPerBeat;
                m_StyleInfo.m_dblTempo = iDMStyle.dblTempo;
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &m_StyleInfo.m_guid, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
            {
                DMUS_IO_VERSION iDMStyleVersion;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
                hr = pIStream->Read( &iDMStyleVersion, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_StyleInfo.m_dwVersionMS = iDMStyleVersion.dwVersionMS;
                m_StyleInfo.m_dwVersionLS = iDMStyleVersion.dwVersionLS;
                break;
            }

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_STYLE_PERS_REF_LIST:
                    {
                        hr = DM_LoadPersonalityReference( pIRiffStream, &ck );
                        if( FAILED( hr ) )
                        {
                            goto ON_ERROR;
                        }
                        break;
                    }

                    case DMUS_FOURCC_UNFO_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
                        {
                            switch( ckList.ckid )
                            {
                                case RIFFINFO_INAM:
                                case DMUS_FOURCC_UNAM_CHUNK:
                                {
                                    DWORD dwLength = min(ckList.cksize, (DWORD)(sizeof(WCHAR)*(DMUS_MAX_NAME - 1)));
                                    hr = ReadMBSfromWCS( pIStream, dwLength, m_StyleInfo.m_strName );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    break;
                                }

                                case DMUS_FOURCC_CATEGORY_CHUNK:
                                {
                                    DWORD dwLength = min(ckList.cksize, (DWORD)(sizeof(WCHAR)*(DMUS_MAX_CATEGORY - 1)));
                                    hr = ReadMBSfromWCS( pIStream, dwLength, m_StyleInfo.m_strCategory );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    break;
                                }
                            }
                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;

                    case DMUS_FOURCC_PART_LIST:
                        pPart = m_StyleInfo.AllocPart();
                        if( pPart == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        hr = pPart->DM_LoadPart( pIRiffStream, &ck, &m_StyleInfo );
                        if( FAILED( hr ) )
                        {
                            m_StyleInfo.DeletePart( pPart );
                            goto ON_ERROR;
                        }
                        if( hr == S_FALSE )
                        {
                            // This should not happen when loading a Style!
                            Trace(0, "LOAD CONFLICT: Two parts with the same Guid.\n");
                            assert( 0 );
                            // Bypass this Part because Style already contains a Part
                            // whose GUID matches pPart->m_guidPartID
                            m_StyleInfo.DeletePart( pPart );
                        }
                        break;

                case DMUS_FOURCC_PATTERN_LIST:
                        StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
                        CDirectMusicPattern* pPattern =
                            new CDirectMusicPattern( &m_StyleInfo.m_TimeSignature, FALSE );
                        if( pPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        ckList.fccType = DMUS_FOURCC_PATTERN_LIST;
                        if( pIRiffStream->Descend( &ckList, NULL, MMIO_FINDLIST ) != 0 )
                        {
                            hr = E_FAIL;
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        hr = pPattern->DM_LoadPattern( pIRiffStream, &ckList, &m_StyleInfo );
                        pIRiffStream->Ascend( &ckList, 0 );
                        if( FAILED( hr ) )
                        {
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        TListItem<CDirectMusicPattern*>* pPatternItem =
                            new TListItem<CDirectMusicPattern*>(pPattern);
                        if( pPatternItem == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        if( pPattern->m_wEmbellishment & EMB_MOTIF )
                        {
                            m_StyleInfo.m_MotifList.AddTail( pPatternItem );
                        }
                        else
                        {
                            m_StyleInfo.m_PatternList.AddTail( pPatternItem );
                        }
                        break;
                }
                break;

            case FOURCC_RIFF:
                switch( ck.fccType )
                {
                    case FOURCC_BAND_FORM:
                    case DMUS_FOURCC_BAND_FORM:
                    {
                        TListItem<IDirectMusicBand*>* pBandListItem = new TListItem<IDirectMusicBand*>;
                        if(pBandListItem)
                        {
                            pBandListItem->GetItemValue() = NULL;

                            // Create a band
                            hr = CoCreateInstance(CLSID_DirectMusicBand,
                                                  NULL,
                                                  CLSCTX_INPROC,
                                                  IID_IDirectMusicBand,
                                                  (void**)&(pBandListItem->GetItemValue()));
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        if(SUCCEEDED(hr))
                        {
                            // Seek back to begining of Riff chunk
                            // This is the amount read by Descend when descending into a FOURCC_RIFF chunk
                            // Get current position
                            LARGE_INTEGER li;
                            ULARGE_INTEGER ul;
                            li.HighPart = 0;
                            li.LowPart = 0;
                            hr = pIStream->Seek(li,
                                               STREAM_SEEK_CUR,
                                               &ul);
                            if(SUCCEEDED(hr))
                            {
                                li.HighPart = 0;
                                // This is always a valid operation
                                li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
                                hr = pIStream->Seek(li,
                                                   STREAM_SEEK_SET,
                                                   &ul);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            // Load band
                            IPersistStream* pIPersistStream;
                            hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
                            if (hr != S_OK)
                            {
                                hrBand = hr;
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = pIPersistStream->Load(pIStream);
                                pIPersistStream->Release();
                                DWORD dwFlags = 0;
                                if(SUCCEEDED(hr))
                                {
                                    IDirectMusicBandPrivate *pIDMBandP = NULL;
                                    hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pIDMBandP);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = pIDMBandP->GetFlags(&dwFlags);
                                        if(SUCCEEDED(hr))
                                        {
                                            if( (ck.fccType == FOURCC_BAND_FORM && (dwFlags & DMUSB_DEFAULT)) ||
                                                (ck.fccType == DMUS_FOURCC_BAND_FORM && !fFoundDefault) )
                                            {
                                                // We have a default band
                                                m_StyleInfo.m_pDefaultBand = pBandListItem->GetItemValue();
                                                fFoundDefault = TRUE;
                                            }
                                        }

                                        pIDMBandP->Release();
                                    }
                                }
                            }
                        }
                        if(FAILED(hr))
                        {
                            if(pBandListItem)
                            {
                                IDirectMusicBand* pBand = pBandListItem->GetItemValue();
                                if(pBand)
                                {
                                    pBand->Release();
                                }
                                delete pBandListItem;
                            }
                            goto ON_ERROR;
                        }
                        EnterCriticalSection(&m_CriticalSection);
                        (m_StyleInfo.m_BandList).AddHead(pBandListItem);
                        LeaveCriticalSection(&m_CriticalSection);
                    }
                    break;
                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    // Merge the marker event start times in each of the patterns
    TListItem<CDirectMusicPattern*>* pPattern;
    pPattern = m_StyleInfo.m_PatternList.GetHead();
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        pPattern->GetItemValue()->MergeMarkerEvents(&m_StyleInfo);
    }
    pPattern = m_StyleInfo.m_MotifList.GetHead();
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        pPattern->GetItemValue()->MergeMarkerEvents(&m_StyleInfo);
    }
    pIStream->Release();
    if (hr == S_OK && hrBand != S_OK)
    {
        hr = hrBand;
    }
    return hr;
}


HRESULT CDMStyle::DM_LoadPersonalityReference( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
    BOOL    fDefaultPers = TRUE;
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    while (pIRiffStream->Descend( &ck, pckParent, 0 ) == 0)
    {
        switch (ck.ckid)
        {
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_REF_LIST)
            {
                // Ignore this result: success or failure of loading individual
                // ChordMap references should have no bearing on the success or
                // failure of loading the style.
                //hr = LoadReference(pIStream, pIRiffStream, ck, fDefaultPers);
                LoadReference(pIStream, pIRiffStream, ck, fDefaultPers);
                fDefaultPers = FALSE;
            }
            break;
        }
        pIRiffStream->Ascend( &ck, 0 );
    }
    pIStream->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDMStyle::LoadReference

HRESULT CDMStyle::LoadReference(IStream *pStream,
                                         IAARIFFStream *pIRiffStream,
                                         MMCKINFO& ckParent,
                                         BOOL fDefault)
{
    if (!pStream || !pIRiffStream) return E_INVALIDARG;

    IDirectMusicChordMap* pChordMap;
    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    DWORD cbRead;

    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;

    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == 0 )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_REFERENCE))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(GUID))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(FILETIME))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                  desc.wszName[DMUS_MAX_NAME - 1] = L'\0';
                  desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_VERSION))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }

        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = E_FAIL;
    }

    if (!(desc.dwValidData &  DMUS_OBJ_NAME) )
    {
        hr = E_FAIL;
    }
    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc,IID_IDirectMusicChordMap, (void**)&pChordMap);
        if (SUCCEEDED(hr))
        {
            hr = IncorporatePersonality(pChordMap, desc.wszName, fDefault);
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT CDMStyle::IMA25_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain )
{
    HRESULT     hr = S_OK;
    HRESULT     hrBand = S_OK;
    MMCKINFO    ck;
    DWORD       cb;
    DWORD       cSize;
    LPSTREAM    pStream;
    ioStyle     iStyle; // in iostructs.h
    BOOL fReadStyle = FALSE;

    pStream = pRIFF->GetStream();
    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
        case FOURCC_STYLE:
            fReadStyle = TRUE;
            cSize = min( ck.cksize, sizeof( iStyle ) );
            hr = pStream->Read( &iStyle, cSize, &cb );
            FixBytes( FBT_IOSTYLE, &iStyle );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            m_StyleInfo.m_dwVersionMS = m_StyleInfo.m_dwVersionLS = 0;  // no version info in IMA 2.5
            m_StyleInfo.m_strName = iStyle.wstrName;
            m_StyleInfo.m_TimeSignature.m_bBeatsPerMeasure = (BYTE) iStyle.wBPM;
            m_StyleInfo.m_TimeSignature.m_bBeat = (BYTE) iStyle.wBeat;
            m_StyleInfo.m_TimeSignature.m_wGridsPerBeat = iStyle.wClocksPerBeat / iStyle.wClocksPerClick;
            m_StyleInfo.m_dblTempo = iStyle.wTempo;
            m_StyleInfo.m_strCategory = iStyle.wstrCategory;
            memcpy( &m_StyleInfo.m_guid, &iStyle.guid, sizeof( m_StyleInfo.m_guid ) );
            break;
        // find ChordMap reference
        case FOURCC_PERSONALITYREF:
            hr = IMA25_LoadPersonalityReference( pStream, &ck );
            if( FAILED( hr ) )
            {
                goto ON_ERR;
            }
             break;
        case FOURCC_RIFF:
            switch( ck.fccType )
            {
                case FOURCC_BAND_FORM:
                {
                    TListItem<IDirectMusicBand*>* pBandListItem = new TListItem<IDirectMusicBand*>;

                    if(pBandListItem)
                    {
                        pBandListItem->GetItemValue() = NULL;

                        // Create a band
                        hr = CoCreateInstance(CLSID_DirectMusicBand,
                                              NULL,
                                              CLSCTX_INPROC,
                                              IID_IDirectMusicBand,
                                              (void**)&(pBandListItem->GetItemValue()));
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Seek back to begining of Riff chunk
                        // This is the amount read by Descend when descending into a FOURCC_RIFF chunk
                        // Get current position
                        LARGE_INTEGER li;
                        ULARGE_INTEGER ul;
                        li.HighPart = 0;
                        li.LowPart = 0;
                        hr = pStream->Seek(li,
                                           STREAM_SEEK_CUR,
                                           &ul);

                        if(SUCCEEDED(hr))
                        {
                            li.HighPart = 0;
                            // This is always a valid operation
                            li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
                            hr = pStream->Seek(li,
                                               STREAM_SEEK_SET,
                                               &ul);
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load band
                        IPersistStream* pIPersistStream;
                        hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                        if(SUCCEEDED(hr))
                        {
                            hr = pIPersistStream->Load(pStream);
                            if (hr != S_OK)
                            {
                                hrBand = hr;
                            }
                            pIPersistStream->Release();
                            DWORD dwFlags = 0;

                            IDirectMusicBandPrivate *pIDMBandP = NULL;
                            hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pIDMBandP);
                            if(SUCCEEDED(hr))
                            {
                                hr = pIDMBandP->GetFlags(&dwFlags);
                                if(SUCCEEDED(hr))
                                {
                                    if(dwFlags & DMUSB_DEFAULT)
                                    {
                                        // We have a default band
                                        m_StyleInfo.m_pDefaultBand = pBandListItem->GetItemValue();
                                    }
                                }

                                pIDMBandP->Release();
                            }
                        }

                    }

                    if(FAILED(hr))
                    {
                        if(pBandListItem)
                        {
                            IDirectMusicBand* pBand = pBandListItem->GetItemValue();
                            if(pBand)
                            {
                                pBand->Release();
                            }

                            delete pBandListItem;
                        }

                        goto ON_ERR;
                    }

                    EnterCriticalSection(&m_CriticalSection);
                    (m_StyleInfo.m_BandList).AddHead(pBandListItem);
                    LeaveCriticalSection(&m_CriticalSection);
                }
                break;

                // find first pattern
                case FOURCC_PATTERN_FORM:
                   if( fReadStyle )
                    {
                        TListItem<CDirectMusicPattern*>* pOldPattern = new TListItem<CDirectMusicPattern*>;
                        if( pOldPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            goto ON_ERR;
                        }
                        CDirectMusicPattern*& rpOldPattern = pOldPattern->GetItemValue();
                        rpOldPattern = new CDirectMusicPattern;
                        if( rpOldPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            goto ON_ERR;
                        }

                        hr = rpOldPattern->LoadPattern( pRIFF, &ck, m_StyleInfo.m_PartList, m_StyleInfo);
                        if( FAILED( hr ) )
                        {
                            hr = E_FAIL;
                            goto ON_ERR;
                        }
                        if( ( rpOldPattern->m_wEmbellishment & EMB_MOTIF ) != 0 )
                        {
                            EnterCriticalSection( &m_CriticalSection );
                            m_StyleInfo.m_MotifList.AddTail(pOldPattern);
                            LeaveCriticalSection( &m_CriticalSection );
                        }
                        else
                        {
                            EnterCriticalSection( &m_CriticalSection );
                            m_StyleInfo.m_PatternList.AddTail(pOldPattern);
                            LeaveCriticalSection( &m_CriticalSection );
                        }
                    }
                    break;
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }
ON_ERR:


    pStream->Release();
    // sort here
    TListItem<DirectMusicPart*>* pPartItem = m_StyleInfo.m_PartList.GetHead();
    for ( ; pPartItem; pPartItem = pPartItem->GetNext() )
    {
        pPartItem->GetItemValue()->EventList.MergeSort(m_StyleInfo.m_TimeSignature);
    }
    if (hr == S_OK && hrBand != S_OK)
    {
        hr = hrBand;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DMStyleStruct::FindPartByGUID

DirectMusicPart* DMStyleStruct::FindPartByGUID( GUID guidPartID )
{
    DirectMusicPart* pThePart = NULL;
    DirectMusicPart* pPart;

    TListItem<DirectMusicPart*>* pScan = m_PartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pPart = pScan->GetItemValue();

        if( ::IsEqualGUID( pPart->m_guidPartID, guidPartID ) )
        {
            pThePart = pPart;
            break;
        }
    }

    return pThePart;
}


/////////////////////////////////////////////////////////////////////////////
// DMStyleStruct::AllocPart

DirectMusicPart* DMStyleStruct::AllocPart(  )
{
    DirectMusicPart* pPart = new DirectMusicPart(&m_TimeSignature);
    if (pPart)
    {
        TListItem<DirectMusicPart*>* pPartItem = new TListItem<DirectMusicPart*>(pPart);
        if( pPartItem)
        {
            // Add Part to Style's list of Parts
            m_PartList.AddTail( pPartItem );
        }
        else
        {
            delete pPart;
            pPart = NULL;
        }
    }

    return pPart;
}

/////////////////////////////////////////////////////////////////////////////
// DMStyleStruct::DeletePart

void DMStyleStruct::DeletePart( DirectMusicPart* pPart )
{
    TListItem<DirectMusicPart*>* pPartItem = m_PartList.GetHead();
    TListItem<DirectMusicPart*>* pPrevious = NULL;
    for ( ; pPartItem; pPartItem = pPartItem->GetNext() )
    {
        DirectMusicPart* pScan = pPartItem->GetItemValue();
        if (pPart == pScan)
        {
            pScan->Release();
            if (pPrevious)
            {
                pPrevious->SetNext(pPartItem->GetNext());
            }
            else
            {
                m_PartList.RemoveHead();
            }
            pPartItem->SetNext(NULL);
            delete pPartItem;
            break;
        }
        pPrevious = pPartItem;
    }
}

HRESULT DMStyleStruct::GetCommand(
                            MUSIC_TIME mtTime,
                            MUSIC_TIME mtOffset,
                            IDirectMusicPerformance* pPerformance,
                            IDirectMusicSegment* pSegment,
                            DWORD dwGroupID,
                            DMUS_COMMAND_PARAM_2* pCommand,
                            BYTE& rbActualCommand)
{
    HRESULT hr = S_OK;
    if (!pPerformance && !pSegment) return E_INVALIDARG;
    if (pPerformance)
    {
        hr = pPerformance->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtTime + mtOffset,
                                    NULL, ((void*) pCommand));
    }
    else
    {
        hr = pSegment->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtTime,
                                    NULL, ((void*) pCommand));
    }
    if (FAILED(hr)) return hr;
    // Look at the command's mtTime to see how far in the past it occurred.  If a measure
    // or more, keep the groove level but make the command a regular groove.
    MUSIC_TIME mtMeasureTime = (MUSIC_TIME) m_TimeSignature.ClocksPerMeasure();
    //TraceI(0, "Now: %d Offset: %d Command: %x, Groove Level: %d, Command time: %d  Measure time: %d\n",
    //  mtTime, mtOffset, pCommand->bCommand, pCommand->bGrooveLevel, pCommand->mtTime, mtMeasureTime);
    rbActualCommand = pCommand->bCommand;
    if (pCommand->mtTime + mtMeasureTime <= 0 ||
        (pCommand->mtTime + mtMeasureTime < mtMeasureTime &&
         (mtMeasureTime + pCommand->mtTime) % mtMeasureTime) )
    {
        pCommand->bCommand = DMUS_COMMANDT_GROOVE;
    }
    return hr;
}

struct TaggedCommands
{
    TaggedCommands()
    {
        m_pCommands = NULL;
        m_pRhythms = NULL;
        m_mtTag = 0;
    }
    HRESULT Init(MUSIC_TIME mtTag, int nSize, int nGlobalGroove)
    {
        HRESULT hr = S_OK;
        m_mtTag = mtTag;
        m_pCommands = new DMUS_COMMAND_PARAM_2 [nSize];
        m_pRhythms = new DWORD [nSize];
        if (!m_pCommands || !m_pRhythms)
        {
            Cleanup();
            hr = E_OUTOFMEMORY;
        }
        else
        {
            int nGroove = 62 + nGlobalGroove;
            if (nGroove > 100) nGroove = 100;
            if (nGroove < 1) nGroove = 1;
            m_pCommands[0].bGrooveLevel = (BYTE)nGroove;
            m_pCommands[0].bGrooveLevel = 62;
            m_pCommands[0].bGrooveRange = 0;
            m_pCommands[0].bCommand = DMUS_COMMANDT_GROOVE;
            m_pCommands[0].bRepeatMode = DMUS_PATTERNT_RANDOM;
            m_pRhythms[0] = 0;
        }
        return hr;
    }
    void Cleanup()
    {
        if (m_pCommands) delete [] m_pCommands;
        if (m_pRhythms) delete [] m_pRhythms;
    }
    ~TaggedCommands()
    {
        Cleanup();
    }
    MUSIC_TIME m_mtTag;
    DMUS_COMMAND_PARAM_2* m_pCommands;
    DWORD* m_pRhythms;
};

TListItem<TaggedCommands>* FindTaggedCommands(MUSIC_TIME mtTag, TList<TaggedCommands>& rCommands)
{
    TListItem<TaggedCommands>* pScan = rCommands.GetHead();
    for(; pScan; pScan = pScan->GetNext())
    {
        if (pScan->GetItemValue().m_mtTag == mtTag) return pScan;
    }
    return NULL;
}

CDirectMusicPattern* DMStyleStruct::SelectPattern(bool fNewMode,
                                   DMUS_COMMAND_PARAM_2* pCommands,
                                   StyleTrackState* StyleTrackState,
                                   PatternDispatcher& rDispatcher)
{
    if (rDispatcher.IsEmpty()) return NULL;
    if (!UsingDX8() || !StyleTrackState)
    {
        return rDispatcher.RandomSelect();
    }
    CDirectMusicPattern* pResult = NULL;
    TListItem<CDirectMusicPattern*>* pNew = NULL;
    TListItem<CDirectMusicPattern*>* pScan = NULL;
    int nIndex = 0;
    if (pCommands)
    {
        switch (pCommands[0].bRepeatMode)
        {
        case DMUS_PATTERNT_RANDOM:
            pResult = rDispatcher.RandomSelect();
            break;
        case DMUS_PATTERNT_REPEAT:
            pResult = (!fNewMode && S_OK == rDispatcher.FindPattern(StyleTrackState->m_pPattern, nIndex))
                ? StyleTrackState->m_pPattern : rDispatcher.RandomSelect();
            break;
        case DMUS_PATTERNT_SEQUENTIAL:
        case DMUS_PATTERNT_RANDOM_START:
            if (fNewMode)
            {
                if (pCommands[0].bRepeatMode == DMUS_PATTERNT_SEQUENTIAL)
                {
                    pResult = rDispatcher.GetItem(0);
                }
                else
                {
                    pResult = rDispatcher.RandomSelect();
                }
            }
            else
            {
                HRESULT hr = rDispatcher.FindPattern(StyleTrackState->m_pPattern, nIndex);
                if (hr == S_OK && rDispatcher.GetItem(nIndex + 1))
                {
                    pResult = rDispatcher.GetItem(nIndex + 1);
                }
                else
                {
                    pResult = rDispatcher.GetItem(0);
                }
            }
            break;
        case DMUS_PATTERNT_NO_REPEAT:
            if (!fNewMode)
            {
                HRESULT hr = rDispatcher.FindPattern(StyleTrackState->m_pPattern, nIndex);
                if (hr == S_OK)
                {
                    rDispatcher.SetTag(nIndex, REMOVED);
                }
            }
            pResult = rDispatcher.RandomSelect();
            break;
        case DMUS_PATTERNT_RANDOM_ROW:
            if (fNewMode)
            {
                StyleTrackState->m_PlayedPatterns.CleanUp();
            }
            pScan = StyleTrackState->m_PlayedPatterns.GetHead();
            for (; pScan; pScan = pScan->GetNext())
            {
                HRESULT hr = rDispatcher.FindPattern(pScan->GetItemValue(), nIndex);
                if (hr == S_OK)
                {
                    rDispatcher.SetTag(nIndex, RANDOM_ROW);
                }
            }
            if (rDispatcher.IsEmpty()) // start over, but avoid the one just played
            {
                rDispatcher.RestorePatterns(RANDOM_ROW);
                pScan = StyleTrackState->m_PlayedPatterns.GetHead();
                if (pScan)
                {
                    HRESULT hr = rDispatcher.FindPattern(pScan->GetItemValue(), nIndex);
                    if (hr == S_OK)
                    {
                        rDispatcher.SetTag(nIndex, RANDOM_ROW);
                    }
                }
                StyleTrackState->m_PlayedPatterns.CleanUp();
            }
            pResult = rDispatcher.RandomSelect();
            if (pResult)
            {
                pNew = new TListItem<CDirectMusicPattern*>(pResult);
                if (pNew)
                {
                    StyleTrackState->m_PlayedPatterns.AddHead(pNew);
                }
            }
            break;
        default:
            pResult = rDispatcher.RandomSelect();
            break;
        }
    }
    return pResult;
}

HRESULT DMStyleStruct::GetPattern(
            bool fNewMode,
            MUSIC_TIME mtNow,
            MUSIC_TIME mtOffset,
            StyleTrackState* pStyleTrackState,
            IDirectMusicPerformance* pPerformance,
            IDirectMusicSegment* pSegment,
            CDirectMusicPattern*& rpTargetPattern,
            MUSIC_TIME& rmtMeasureTime,
            MUSIC_TIME& rmtNextCommand)
{
    if (!pSegment && !pPerformance) return E_INVALIDARG;
    static aMatchType[5] =
        {MATCH_COMMAND_AND_RHYTHM, MATCH_COMMAND_FULL, MATCH_COMMAND_PARTIAL, MATCH_EMBELLISHMENT, MATCH_GROOVE_LEVEL};
    HRESULT hr = S_OK;
    MUSIC_TIME mtNextStyleTime = pStyleTrackState ? pStyleTrackState->m_mtNextStyleTime : 0;
    DMUS_RHYTHM_PARAM ChordRhythm;
    TList<TaggedCommands> Commands;
    int nLongestPattern = 0;
    int nPatternLength = 1;
    DWORD dwGroupID = pStyleTrackState ? pStyleTrackState->m_dwGroupID : 0xffffffff;
    TListItem<CDirectMusicPattern*> *pPatternItem = m_PatternList.GetHead();
    for (; pPatternItem != NULL; pPatternItem = pPatternItem->GetNext())
    {
        CDirectMusicPattern*& rpPattern = pPatternItem->GetItemValue();
        if (rpPattern->m_wNumMeasures > nLongestPattern)
            nLongestPattern = rpPattern->m_wNumMeasures;
    }
    if (nLongestPattern <= 0) return E_POINTER;

   char chGroove;
    if (!pPerformance ||
        !SUCCEEDED(pPerformance->GetGlobalParam((GUID)GUID_PerfMasterGrooveLevel, &chGroove, 1)))
    {
        chGroove = 0;
    }
    DMUS_COMMAND_PARAM_2 CommandParam;
    // this call to GetParam is for rmtNextCommand only (?)
    HRESULT hrCommand = E_FAIL;
    if (pPerformance)
    {
        hrCommand = pPerformance->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
                                                &rmtNextCommand, ((void*) &CommandParam));
    }
    else
    {
        hrCommand = pSegment->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtNow,
                                                &rmtNextCommand, ((void*) &CommandParam));
    }
    if (DMUS_E_TRACK_NOT_FOUND == hrCommand || rmtNextCommand <= 0) // Happens if the performance can't find a segment with a command track
    {
        if (mtNextStyleTime) rmtNextCommand = mtNextStyleTime;
        else if (pStyleTrackState && pStyleTrackState->m_pSegState)
        {
            MUSIC_TIME mtLength = 0;
            IDirectMusicSegment* pTmpSegment = NULL;
            if (SUCCEEDED(pStyleTrackState->m_pSegState->GetSegment(&pTmpSegment)))
            {
                hr = pTmpSegment->GetLength(&mtLength);
                pTmpSegment->Release();
                // GetLength may return DMUS_S_GARBAGE_COLLECTED which FAILED will not catch
                if(hr != S_OK)
                {
                    mtLength = 0x7FFFFFFF;
                }
            }
            rmtNextCommand = mtLength - mtNow;
        }
        else rmtNextCommand = 0;
    }
    MUSIC_TIME mtStyleDifference = mtNextStyleTime ? mtNextStyleTime - mtNow : 0;
    if ( mtStyleDifference > 0 && (!rmtNextCommand || mtStyleDifference < rmtNextCommand) )
    {
        rmtNextCommand = mtStyleDifference;
    }
    if (pStyleTrackState)
    {
        if (FAILED(hrCommand) || pStyleTrackState->m_CommandData.bRepeatMode != CommandParam.bRepeatMode)
        {
            fNewMode = true;
        }
        pStyleTrackState->m_CommandData = CommandParam;
        pStyleTrackState->m_CommandData.bGrooveLevel += chGroove;
    }

    TListItem<TaggedCommands>* pTaggedCommands = NULL;
    PatternDispatcher Dispatcher(m_PatternList, rmtNextCommand, mtNow, mtOffset, pStyleTrackState, pPerformance, this);
    // find a pattern matching the chord rhythm and command
    for (int nMatch = 0; nMatch < 5; nMatch++, Dispatcher.RestoreAllPatterns())
    {
        if (nMatch > 2 && !UsingDX8()) break; // only do these for dx8
        // while more pattern lengths:
        do
        {
            // divide current list into those with the longest patterns and eveything else
            Dispatcher.ResetMeasures();
            Dispatcher.Scan(FIND_LONGEST_PATTERN);
            Dispatcher.Filter(COLLECT_LONGEST_PATTERN);
            // while more time signatures:
            do
            {
                int nLength = 0;
                DirectMusicTimeSig TimeSig;
                // divide list into those with "longest" time sigs and everything else
                Dispatcher.ResetTimeSig();
                Dispatcher.Scan(FIND_LONGEST_TIMESIG);
                Dispatcher.Filter(COLLECT_LONGEST_TIMESIG);
                // fill up pCommands and pRhythms (also get mtMeasureTime, based on time sig)
                CDirectMusicPattern* pFirstPattern = Dispatcher.GetItem(0);
                MUSIC_TIME mtMeasureTime = 0;
                if (pFirstPattern)
                {
                    TimeSig = pFirstPattern->TimeSignature(this);
                    nLength = pFirstPattern->m_wNumMeasures;
                }
                else
                {
                    TimeSig = m_TimeSignature;
                }
                mtMeasureTime = TimeSig.ClocksPerMeasure();
                Dispatcher.SetMeasureTime(mtMeasureTime);

                IDirectMusicStyle* pThisStyle = NULL;
                MUSIC_TIME mtNextStyle = 0;
                if (SUCCEEDED(pPerformance->GetParam(GUID_IDirectMusicStyle, dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
                                            &mtNextStyle, (void*) &pThisStyle)))
                {
                    if (mtNextStyle && mtMeasureTime)
                    {
                        nPatternLength = (mtNextStyle / mtMeasureTime);
                        if (!nPatternLength) nPatternLength = 1;
                    }
                    if (nPatternLength > nLongestPattern) nPatternLength = nLongestPattern;
                    pThisStyle->Release();
                }
                Dispatcher.SetPatternLength(nPatternLength);

                 pTaggedCommands = FindTaggedCommands(mtMeasureTime, Commands);
                if (!pTaggedCommands)
                {
                    pTaggedCommands = new TListItem<TaggedCommands>;
                    if (!pTaggedCommands) return E_OUTOFMEMORY;
                    TaggedCommands& rCommands = pTaggedCommands->GetItemValue();
                    hr = rCommands.Init(mtMeasureTime, nPatternLength, chGroove);
                    if (FAILED(hr)) return hr;
                    Commands.AddHead(pTaggedCommands);
                    if (SUCCEEDED(hrCommand))
                    {
                        HRESULT hrChord = S_OK;
                        // get chord rhythm for next measure(s)
                        // get command for next measure(s)
                        ChordRhythm.TimeSig = TimeSig;
                        for (short i = 0; i < nPatternLength; i++)
                        {
                            BYTE bActualCommand;
                            if (S_OK != GetCommand(mtNow + (i * mtMeasureTime),
                                    mtOffset, pPerformance, pSegment, dwGroupID, &CommandParam,
                                    bActualCommand))
                            {
                                break;
                            }
                            rCommands.m_pCommands[i] = CommandParam;
                            short nGroove = CommandParam.bGrooveLevel + chGroove;
                            if (nGroove > 100) nGroove = 100;
                            if (nGroove < 1) nGroove = 1;
                            rCommands.m_pCommands[i].bGrooveLevel = (BYTE)nGroove;
                            if (pPerformance)
                            {
                                hrChord = pPerformance->GetParam(GUID_RhythmParam, dwGroupID, DMUS_SEG_ANYTRACK, (mtNow + (i * mtMeasureTime) + mtOffset),
                                                            NULL, (void*) &ChordRhythm);
                            }
                            else
                            {
                                hrChord = pSegment->GetParam(GUID_RhythmParam, dwGroupID, DMUS_SEG_ANYTRACK, (mtNow + (i * mtMeasureTime)),
                                                            NULL, (void*) &ChordRhythm);
                            }
                            if (SUCCEEDED(hrChord))
                            {
                                rCommands.m_pRhythms[i] = ChordRhythm.dwRhythmPattern;
                            }
                            else
                            {
                                rCommands.m_pRhythms[i] = 0;
                            }
                            TraceI(3, "NOW: %d, i: %d, Groove level: %d, command: %d, rhythm: %x\n",
                                mtNow + (i * mtMeasureTime), i, rCommands.m_pCommands[i].bGrooveLevel,
                                rCommands.m_pCommands[i].bCommand, rCommands.m_pRhythms[i]);
                        }
                    }
                }
                TaggedCommands& rCommands = pTaggedCommands->GetItemValue();
                Dispatcher.SetCommands(rCommands.m_pCommands, rCommands.m_pRhythms);
                // filter best matches, using aMatchType[nMatch]
                //   (MATCH_COMMAND_AND_RHYTHM also needs to filter with MATCH_RHYTHM_BITS)
                // break on match
                if (aMatchType[nMatch] == MATCH_COMMAND_AND_RHYTHM)
                {
                    Dispatcher.ResetRhythms();
                }
                Dispatcher.Filter(aMatchType[nMatch]);
                if (!Dispatcher.IsEmpty())
                {
                    if (aMatchType[nMatch] == MATCH_COMMAND_AND_RHYTHM)
                    {
                        Dispatcher.Filter(MATCH_RHYTHM_BITS);
                        if (!Dispatcher.IsEmpty()) break;
                        Dispatcher.RestorePatterns(MATCH_RHYTHM_BITS);
                    }
                    else break;
                }
                Dispatcher.ReplacePatterns(COLLECT_LONGEST_TIMESIG, REMOVED);
                TraceI(2, "Failed Match: %d (%d, %d/%d)\n",
                    nMatch, nLength, TimeSig.m_bBeatsPerMeasure, TimeSig.m_bBeat);
            } while (!Dispatcher.IsEmpty());
            if (!Dispatcher.IsEmpty()) break;
            Dispatcher.ReplacePatterns(COLLECT_LONGEST_PATTERN, REMOVED);
        } while (!Dispatcher.IsEmpty());
        if (!Dispatcher.IsEmpty()) break;
    }

    if (!Dispatcher.IsEmpty())
    {
        //TraceI(2, "Filtering Destinations...\n");
        Dispatcher.Filter(MATCH_NEXT_COMMAND);
        if (Dispatcher.IsEmpty())
        {
            Dispatcher.RestorePatterns(MATCH_NEXT_COMMAND);
        }
        rpTargetPattern = SelectPattern(fNewMode, pTaggedCommands->GetItemValue().m_pCommands, pStyleTrackState, Dispatcher);
    }
    // if all searches failed, select the first pattern
    if (!rpTargetPattern)
    {
        TraceI(1, "ALL SEARCHES FAILED\n");
        TListItem<CDirectMusicPattern*> *pPattern = m_PatternList.GetHead();
        if (pPattern) // if this is NULL, something's wrong
        {
            rpTargetPattern = pPattern->GetItemValue();
        }
    }
    if (rpTargetPattern) // if pTargetPattern is NULL, something's really wrong
    {
        rmtMeasureTime = rpTargetPattern->TimeSignature(this).ClocksPerMeasure();
        if (pStyleTrackState)
        {
            hr = pStyleTrackState->InitPattern(rpTargetPattern, mtNow);
        }
        TraceI(2, "Pattern: %S (%d, %d/%d) [%d]\n",
        //TraceI(0, "Pattern: %S (%d, %d/%d) [%d]\n",
            (const WCHAR *)rpTargetPattern->m_strName, rpTargetPattern->m_wNumMeasures,
            rpTargetPattern->TimeSignature(this).m_bBeatsPerMeasure,
            rpTargetPattern->TimeSignature(this).m_bBeat, mtNow);
    }
    else hr = E_POINTER;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// AdjoinPChannel

HRESULT AdjoinPChannel(TList<DWORD>& rPChannelList, DWORD dwPChannel)
{
    TListItem<DWORD>* pScan = rPChannelList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        DWORD rdwPChannel = pScan->GetItemValue();

        if( dwPChannel ==  rdwPChannel )
        {
            return S_OK;
        }
    }

    TListItem<DWORD>* pNew = new TListItem<DWORD>(dwPChannel);
    if (!pNew) return E_OUTOFMEMORY;
    rPChannelList.AddHead(pNew);
    return S_OK;
}

static inline BOOL InversionPoint(char chNote, DWORD dwInvertPattern)
{
    if (chNote < 0 || chNote >= 24) return FALSE;
    return (dwInvertPattern >> chNote) & 1;
}

static BYTE NotePosition(char chMidiValue, BYTE bRoot)
{
    chMidiValue -= bRoot;
    while (chMidiValue < 0) chMidiValue += 12;
    while (chMidiValue > 23) chMidiValue -= 12;
    return (BYTE)chMidiValue;
}

static char InversionAmountLow(
                BYTE bMidiValue,
                BYTE bLower,
                DWORD dwInvertPattern,
                BYTE bRoot)
{
    char chResult = 0;
    TraceI(3, "InversionAmountLow: MidiValue: %d, Lower: %d, Pattern: %X, Root: %d\n",
        bMidiValue, bLower, dwInvertPattern, bRoot);
    char chDifference = (char) (bLower - bMidiValue);
    char chPosition = NotePosition(bMidiValue, bRoot);
    while (chDifference > 23) chDifference -= 24;
    TraceI(3, "Position: %d Difference: %d\n", chPosition, chDifference);
    // Right now I'm checking both endpoints.  Is this what I want?
    for (char i = chPosition; chDifference >= 0; (i = (i < 23) ? i + 1 : 0), chDifference--)
    {
        if (InversionPoint(i, dwInvertPattern)) break;
    }
    if (chDifference >= 0)
    {
        while (bLower > bMidiValue + chResult)
        {
            chResult += 12;
        }
    }
    TraceI(3, "Result: %d\n", chResult);
    return chResult;
}

static char InversionAmountHigh(
                BYTE bMidiValue,
                BYTE bUpper,
                DWORD dwInvertPattern,
                BYTE bRoot)
{
    char chResult = 0;
    TraceI(3, "InversionAmountHigh: MidiValue: %d, Upper: %d, Pattern: %X, Root: %d\n",
        bMidiValue, bUpper, dwInvertPattern, bRoot);
    char chDifference = (char) (bMidiValue - bUpper);
    char chPosition = NotePosition(bMidiValue, bRoot);
    while (chDifference > 23) chDifference -= 24;
    TraceI(3, "Position: %d Difference: %d\n", chPosition, chDifference);
    // Right now I'm checking both endpoints.  Is this what I want?
    for (char i = chPosition; chDifference >= 0; (i = (i > 0) ? i - 1 : 23), chDifference--)
    {
        if (InversionPoint(i, dwInvertPattern)) break;
    }
    if (chDifference >= 0)
    {
        while ((char)bMidiValue + chResult > (char)bUpper)
        {
            chResult -= 12;
        }
    }
    TraceI(3, "Result: %d\n", chResult);
    return chResult;
}

static char InversionAmount(
                BYTE bMidiValue,
                BYTE bLower,
                BYTE bUpper,
                DWORD dwInvertPattern,
                BYTE bRoot)
{
    char chResult = 0;
    if (bMidiValue <= 0 || bMidiValue > 127) return 0;
    if (dwInvertPattern & 0xff000000)
    {
        while (bMidiValue + chResult < bLower) chResult += 12;
        while (bMidiValue + chResult > bUpper) chResult -= 12;
        return chResult;
    }
    TraceI(4, "InversionAmount: MidiValue: %d, Lower: %d, Upper: %d, Pattern: %X, Root: %d\n",
        bMidiValue, bLower, bUpper, dwInvertPattern, bRoot);
    if (bLower <= bMidiValue && bMidiValue <= bUpper) return 0;
    if (bMidiValue < bLower)
    {
        chResult = InversionAmountLow(bMidiValue, bLower, dwInvertPattern, bRoot);
    }
    else
    {
        chResult = InversionAmountHigh(bMidiValue, bUpper, dwInvertPattern, bRoot);
    }
    return chResult;
}

HRESULT DirectMusicPartRef::ConvertMusicValue(CDMStyleNote* pNoteEvent,
                              DMUS_CHORD_PARAM& rCurrentChord,
                              BYTE bPlayModeFlags,
                              BOOL fPlayAsIs,
                              InversionGroup aInversionGroups[],
                              IDirectMusicPerformance* pPerformance,
                              BYTE& rbMidiValue,
                              short& rnMidiOffset)
{
    bool fReleasePerformance = false;
    if (!pPerformance)
    {
        fReleasePerformance = true;
        if( FAILED( CoCreateInstance( CLSID_DirectMusicPerformance,
            NULL, CLSCTX_INPROC, IID_IDirectMusicPerformance,
            (void**)&pPerformance )))
        {
            return E_FAIL;
        }
    }
    // music value is computed using the current chord info and the playmode flags 
    // musicvalue is a MIDI note value (0-127)
    WORD wMV = pNoteEvent->m_wMusicValue;
    short nMidiOffset = 0;
    if (bPlayModeFlags != DMUS_PLAYMODE_FIXED)
    {
        DMSubChord rSubChord;
        DWORD dwLevel = 1 << m_bSubChordLevel;
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < rCurrentChord.bSubChordCount; dwIndex++)
        {
            if (dwLevel & rCurrentChord.SubChordList[dwIndex].dwLevels)
            {
                rSubChord = rCurrentChord.SubChordList[dwIndex];
                break;
            }
        }
        if (dwIndex == rCurrentChord.bSubChordCount)
        {
            rSubChord = rCurrentChord.SubChordList[0];
            dwIndex = 0;
        }
        DMUS_CHORD_KEY ChordAndKey;
        ZeroMemory(&ChordAndKey, sizeof(DMUS_CHORD_KEY));
        ChordAndKey.dwScale = rCurrentChord.dwScale;
        ChordAndKey.bSubChordCount = rCurrentChord.bSubChordCount;
        ChordAndKey.bKey = rCurrentChord.bKey;
        ChordAndKey.bFlags = 0;
        ChordAndKey.SubChordList[dwIndex].bChordRoot = rSubChord.m_bChordRoot;
        ChordAndKey.SubChordList[dwIndex].bScaleRoot = rSubChord.m_bScaleRoot;
        ChordAndKey.SubChordList[dwIndex].dwChordPattern = rSubChord.m_dwChordPattern;
        ChordAndKey.SubChordList[dwIndex].dwLevels = rSubChord.m_dwLevels;
        ChordAndKey.SubChordList[dwIndex].dwScalePattern = rSubChord.m_dwScalePattern;
        BYTE bChordRoot = 0;
        HRESULT hrChordRoot = pPerformance->MusicToMIDI(
            (pNoteEvent->m_wMusicValue & 0xf000),
            &ChordAndKey,
            bPlayModeFlags,
            m_bSubChordLevel,
            &bChordRoot);
        if (bPlayModeFlags == DMUS_PLAYMODE_CHORD_ROOT) // fixed to chord
        {
            wMV += (rSubChord.m_bChordRoot % 24);
        }
        else if (bPlayModeFlags == DMUS_PLAYMODE_SCALE_ROOT) // fixed to scale
        {
            wMV += rCurrentChord.bKey;
        }
        else
        {
            BYTE bMIDIVal;
            HRESULT hrTest = pPerformance->MusicToMIDI(
                pNoteEvent->m_wMusicValue,
                &ChordAndKey,
                bPlayModeFlags,
                m_bSubChordLevel,
                &bMIDIVal);
            if (hrTest == S_OK)
            {
                wMV = bMIDIVal;
            }
            else
            {
                wMV = 0;
            }
        }
        if (wMV && !fPlayAsIs )
        {
            if (pNoteEvent->m_bInversionId == 0)
            {
                nMidiOffset = InversionAmount((BYTE)wMV,
                m_pDMPart->m_bInvertLower,
                m_pDMPart->m_bInvertUpper,
                rSubChord.m_dwInversionPoints,
                bChordRoot);
            }
            else // handle inversion groups
            {
                short nIndex = FindGroup(aInversionGroups, pNoteEvent->m_bInversionId);
                if (nIndex >= 0) // invert according to the existing group
                {
                    nMidiOffset = aInversionGroups[nIndex].m_nOffset;
                    aInversionGroups[nIndex].m_wCount--;
                    if (aInversionGroups[nIndex].m_wCount == 0)
                        aInversionGroups[nIndex].m_wGroupID = 0;
                }
                else // create a new inversion group
                {
                    // 1. find out how many events have this group id for a count
                    WORD wCount = 1; // for this event...
                    CDirectMusicEventItem* pScan = pNoteEvent->GetNext();
                    for (; pScan; pScan = pScan->GetNext())
                    {
                        if (pScan->m_dwEventTag == DMUS_EVENT_NOTE)
                        {
                            CDMStyleNote* pScanEvent = (CDMStyleNote*)pScan;
                            if (pScanEvent->m_bInversionId == pNoteEvent->m_bInversionId)
                                wCount++;
                        }
                    }
                    // 2. call InversionAmount for an offset
                    short nOffset = InversionAmount((BYTE)wMV,
                        m_pDMPart->m_bInvertLower,
                        m_pDMPart->m_bInvertUpper,
                        rSubChord.m_dwInversionPoints,
                        bChordRoot);
                    // 3. call AddGroup with the id, count, and offset
                    short nIndex2 = AddGroup(aInversionGroups, pNoteEvent->m_bInversionId, wCount, nOffset);
                    // 4. If the add was successful, do the inversion.
                    if (nIndex2 >= 0)
                    {
                        nMidiOffset = aInversionGroups[nIndex2].m_nOffset;
                        aInversionGroups[nIndex2].m_wCount--;
                        if (aInversionGroups[nIndex2].m_wCount == 0)
                            aInversionGroups[nIndex2].m_wGroupID = 0;
                    }
                }
            }
        }
    }
    wMV += nMidiOffset;
    while (wMV < 0) wMV += 12;
    while (wMV > 127) wMV -= 12;
    // NOT IMPLEMENTED: Don't play notes with low priority when the device 
    // runs out of notes
    rbMidiValue = (BYTE) wMV;
    rnMidiOffset = nMidiOffset;
    if (fReleasePerformance) pPerformance->Release();
    return S_OK;
}

HRESULT DirectMusicPartRef::ConvertMIDIValue(BYTE bMIDI,
                              DMUS_CHORD_PARAM& rCurrentChord,
                              BYTE bPlayModeFlags,
                              IDirectMusicPerformance* pPerformance,
                              WORD& rwMusicValue)
{
    HRESULT hr = S_OK;
    bool fReleasePerformance = false;
    if (!pPerformance)
    {
        fReleasePerformance = true;
        if( FAILED( CoCreateInstance( CLSID_DirectMusicPerformance,
            NULL, CLSCTX_INPROC, IID_IDirectMusicPerformance,
            (void**)&pPerformance )))
        {
            return E_FAIL;
        }
    }
    if (bPlayModeFlags != DMUS_PLAYMODE_FIXED)
    {
        DMSubChord rSubChord;
        DWORD dwLevel = 1 << m_bSubChordLevel;
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < rCurrentChord.bSubChordCount; dwIndex++)
        {
            if (dwLevel & rCurrentChord.SubChordList[dwIndex].dwLevels)
            {
                rSubChord = rCurrentChord.SubChordList[dwIndex];
                break;
            }
        }
        if (dwIndex == rCurrentChord.bSubChordCount)
        {
            rSubChord = rCurrentChord.SubChordList[0];
            dwIndex = 0;
        }
        DMUS_CHORD_KEY ChordAndKey;
        ZeroMemory(&ChordAndKey, sizeof(DMUS_CHORD_KEY));
        ChordAndKey.dwScale = rCurrentChord.dwScale;
        ChordAndKey.bSubChordCount = rCurrentChord.bSubChordCount;
        ChordAndKey.bKey = rCurrentChord.bKey;
        ChordAndKey.bFlags = 0;
        ChordAndKey.SubChordList[dwIndex].bChordRoot = rSubChord.m_bChordRoot;
        ChordAndKey.SubChordList[dwIndex].bScaleRoot = rSubChord.m_bScaleRoot;
        ChordAndKey.SubChordList[dwIndex].dwChordPattern = rSubChord.m_dwChordPattern;
        ChordAndKey.SubChordList[dwIndex].dwLevels = rSubChord.m_dwLevels;
        ChordAndKey.SubChordList[dwIndex].dwScalePattern = rSubChord.m_dwScalePattern;
        hr = pPerformance->MIDIToMusic(
                                bMIDI,
                                &ChordAndKey,
                                bPlayModeFlags,
                                m_bSubChordLevel,
                                &rwMusicValue);
    }
    if (fReleasePerformance) pPerformance->Release();
    return hr;
}

short FindGroup(InversionGroup aGroup[], WORD wID)
{
    for (short n = 0; n < INVERSIONGROUPLIMIT; n++)
        if (wID == aGroup[n].m_wGroupID)
            return n;
    return -1;
}

short AddGroup(InversionGroup aGroup[], WORD wID, WORD wCount, short nOffset)
{
    for (short n = 0; n < INVERSIONGROUPLIMIT; n++)
    {
        if (aGroup[n].m_wGroupID == 0)
        {
            aGroup[n].m_wGroupID = wID;
            aGroup[n].m_wCount = wCount;
            aGroup[n].m_nOffset = nOffset;
            return n;
        }
    }
    return -1;

}

inline DWORD CleanupScale(DWORD dwPattern)

//  Force scale to be exactly two octaves 

{
    dwPattern &= 0x0FFF;            // Clear upper octave.
    dwPattern |= (dwPattern << 12); // Copy lower octave to top.
    return dwPattern;
}

inline BYTE RelativeRoot(char chChordRoot, char chScaleRoot)
{
    // is there any reason this should be > 12?
    while (chScaleRoot > chChordRoot) chChordRoot += 12;
    BYTE bResult = chChordRoot - chScaleRoot;
    return bResult % 12;
}

// returns 1 - 7 for scale positions I - VII and 0 if chord isn't in scale
BYTE ScalePosition(DMSubChord& rSubChord, BYTE bKey, DWORD dwScale)
{
    DWORD dwScalePattern = dwScale ? CleanupScale(dwScale) : DEFAULT_SCALE_PATTERN;
    DWORD dwRootBit = (DWORD) (1 << RelativeRoot(rSubChord.m_bChordRoot, bKey));

    if (dwRootBit & dwScalePattern)
    {
        BYTE bResult = 0;
        while (dwRootBit > 0)
        {
            if (dwRootBit & dwScalePattern)
                bResult++;
            dwRootBit >>= 1;
        }
        return bResult;
    }
    else return 0;
}

// returns 1 - 7 for scale positions #I - #VII, 0 if not a sharp position
BYTE ScalePositionSharp(DMSubChord& rSubChord, BYTE bKey, DWORD dwScale)
{
    DWORD dwScalePattern = dwScale ? CleanupScale(dwScale) : DEFAULT_SCALE_PATTERN;
    DWORD dwRootBit = (DWORD) (1 << RelativeRoot(rSubChord.m_bChordRoot, bKey));

    // now shift to see if this is sharp from the next position down
    if (dwRootBit == 1) dwRootBit <<= 11;
    else dwRootBit >>= 1;

    if (dwRootBit & dwScalePattern)
    {
        BYTE bResult = 0;
        while (dwRootBit > 0)
        {
            if (dwRootBit & dwScalePattern)
                bResult++;
            dwRootBit >>= 1;
        }
        return bResult;
    }
    else return 0;
}

// returns 1 - 7 for scale positions bI - bVII, 0 if not a flat position
BYTE ScalePositionFlat(DMSubChord& rSubChord, BYTE bKey, DWORD dwScale)
{
    DWORD dwScalePattern = dwScale ? CleanupScale(dwScale) : DEFAULT_SCALE_PATTERN;
    DWORD dwRootBit = (DWORD) (1 << RelativeRoot(rSubChord.m_bChordRoot, bKey));

    // now shift to see if this is flat from the next position up
    if (dwRootBit == (1 << 11)) dwRootBit = 1;
    else dwRootBit <<= 1;

    if (dwRootBit & dwScalePattern)
    {
        BYTE bResult = 0;
        while (dwRootBit > 0)
        {
            if (dwRootBit & dwScalePattern)
                bResult++;
            dwRootBit >>= 1;
        }
        return bResult;
    }
    else return 0;
}

bool IsSimple(DMUS_CHORD_PARAM& Chord)
{
    if (Chord.bSubChordCount <= 1)
    {
        return true;
    }
    else
    {
        bool fResult = true;
        for (int n = 1; n < Chord.bSubChordCount; n++)
        {
            if ( (Chord.SubChordList[n].dwChordPattern != Chord.SubChordList[0].dwChordPattern) ||
                 (Chord.SubChordList[n].dwScalePattern != Chord.SubChordList[0].dwScalePattern) ||
                 (Chord.SubChordList[n].bChordRoot != Chord.SubChordList[0].bChordRoot) ||
                 (Chord.SubChordList[n].bScaleRoot != Chord.SubChordList[0].bScaleRoot) )
            {
                fResult = false;
                break;
            }
        }
        return fResult;
    }
}

bool IsSimple(DMUS_CHORD_PARAM& Chord, int& rCount, int& rSixSeven)
{
    // Combine all the notes from all chord patterns into one pattern
    DWORD dwMOAPatterns = 0;
    int nBaseRoot = Chord.SubChordList[0].bChordRoot;
    for (int n = 0; n < Chord.bSubChordCount; n++)
    {
        int nShift = (int)Chord.SubChordList[n].bChordRoot - nBaseRoot;
        while (nShift < 0) nShift += 12;
        dwMOAPatterns |= (Chord.SubChordList[n].dwChordPattern << nShift);
    }
    // Fold both octaves of the pattern together
    DWORD dwHighOctave = (dwMOAPatterns & 0xfff000) >> 12;
    dwMOAPatterns = (dwMOAPatterns & 0xfff) | dwHighOctave;
    // count the total notes
    rCount = 0;
    rSixSeven = 0;
    for (n = 0; n < 12; n++)
    {
        if (dwMOAPatterns & (1 << n))
        {
            rCount++;
            if (n > 7) rSixSeven++;
        }
    }
    return rCount <= 4;
}

DWORD CDirectMusicPattern::IMA25MoawFlags(MUSIC_TIME mtTime,
                                          MUSIC_TIME mtNextChord,
                                          DMUS_CHORD_PARAM& rCurrentChord,
                                          DMUS_CHORD_PARAM& rNextChord)
{
    DWORD dwMoawFlags = 0;
    DMSubChord rSubChord = rCurrentChord.SubChordList[0];
    // set one of bits 0-7 based on chord root and scale root of current chord
    DWORD dwPosition = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    if (dwPosition)
        dwMoawFlags |= 1 << (dwPosition - 1); // bit 0 for scale position I, etc.
    else
        dwMoawFlags |= VF_ACCIDENTAL;
    // set bits based on tonality of 1st subchord of current chord
    if ((rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN)
        dwMoawFlags |= VF_MAJOR;
    else if ((rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
        dwMoawFlags |= VF_MINOR;
    else
        dwMoawFlags |= VF_ALL;
    // set bits if the root of the next chord is I or V
    MUSIC_TIME mtPatternLength = 0;
    mtPatternLength = m_timeSig.ClocksPerMeasure() * m_wNumMeasures;
    if (rNextChord.bSubChordCount > 0)
    {
        DMSubChord SC = rNextChord.SubChordList[0];
        int nNextRoot = ScalePosition(SC, rCurrentChord.bKey, rCurrentChord.dwScale);
        int nThisRoot = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
        if (mtPatternLength + mtTime < mtNextChord)
        {
            nNextRoot = nThisRoot;
        }
        switch (nNextRoot)
        {
        case 1: // Next chord is a I
            dwMoawFlags |= VF_TO1;
            break;
        case 5: // Next chord is a 5
            dwMoawFlags |= VF_TO5;
            break;
        }
    }
    // Set bits for simple and complex chords
    if ( IsSimple(rCurrentChord) )
        dwMoawFlags |= VF_SIMPLE;
    else
        dwMoawFlags |= VF_COMPLEX;
    return dwMoawFlags;
}

void CDirectMusicPattern::DMusMoawFlags(MUSIC_TIME mtTime,
                                        MUSIC_TIME mtNextChord,
                                        DMUS_CHORD_PARAM& rCurrentChord,
                                        DMUS_CHORD_PARAM& rNextChord,
                                        bool fIsDX8,
                                        DWORD& dwNaturals,
                                        DWORD& dwSharps,
                                        DWORD& dwFlats)
{
    dwNaturals = dwSharps = dwFlats = 0;
    DMSubChord rSubChord = rCurrentChord.SubChordList[0];
    // dwScalePosition holds the scale position of the chord.
    DWORD dwScalePosition = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    // dwSharpPosition holds the sharped scale position of the chord.
    DWORD dwSharpPosition = ScalePositionSharp(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    // dwFlatPosition holds the flatted scale position of the chord.
    DWORD dwFlatPosition = ScalePositionFlat(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    // set bits for scale tone, sharp, and flat
    if (dwScalePosition)
    {
        dwNaturals |= DMUS_VARIATIONF_ROOT_SCALE;
        // shift bits based on tonality of 1st subchord of current chord
        if ( (rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN )
        {
            dwNaturals |= 1 << (dwScalePosition - 1);
        }
        else if ( (rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
        {
            dwNaturals |= 1 << (dwScalePosition + 6);
        }
        else
        {
            dwNaturals |= 1 << (dwScalePosition + 13);
        }
        dwSharps = dwFlats = dwNaturals;
        dwSharpPosition = dwFlatPosition = dwScalePosition;
    }
    else
    {
        if (dwSharpPosition)
        {
            dwSharps |= DMUS_VARIATIONF_ROOT_SHARP;
            // shift bits based on tonality of 1st subchord of current chord
            if ( (rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN )
            {
                dwSharps |= 1 << (dwSharpPosition - 1);
            }
            else if ( (rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
            {
                dwSharps |= 1 << (dwSharpPosition + 6);
            }
            else
            {
                dwSharps |= 1 << (dwSharpPosition + 13);
            }
        }
        if (dwFlatPosition)
        {
            dwFlats |= DMUS_VARIATIONF_ROOT_FLAT;
            // shift bits based on tonality of 1st subchord of current chord
            if ( (rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN )
            {
                dwFlats |= 1 << (dwFlatPosition - 1);
            }
            else if ( (rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
            {
                dwFlats |= 1 << (dwFlatPosition + 6);
            }
            else
            {
                dwFlats |= 1 << (dwFlatPosition + 13);
            }
        }
    }
    // set bits if the root of the next chord is I or V (and it's different from the current chord)
    MUSIC_TIME mtPatternLength = 0;
    mtPatternLength = m_timeSig.ClocksPerMeasure() * m_wNumMeasures;
    if (rNextChord.bSubChordCount > 0)
    {
        DMSubChord SC = rNextChord.SubChordList[0];
        int nNextRoot = ScalePosition(SC, rCurrentChord.bKey, rCurrentChord.dwScale);
        int nThisRoot = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
        if (mtPatternLength + mtTime < mtNextChord)
        {
            nNextRoot = nThisRoot;
        }
        /* This is easy enough to add if it's desired --- but not having it allows a bit more control
        //Don't require anything but the ->Other flag to be set when staying on the same chord
        if (fIsDX8 && nNextRoot == nThisRoot)
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_OTHER;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_OTHER;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_OTHER;
        }
        */
        switch (nNextRoot)
        {
        case 1: // Next chord is a I
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_TO1;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_TO1;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_TO1;
            break;
        case 5: // Next chord is a V
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_TO5;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_TO5;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_TO5;
            break;
        default: // Next chord is neither I nor V
            if (fIsDX8)
            {
                if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_OTHER;
                if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_OTHER;
                if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_OTHER;
            }
            break;
        }
    }
    // Set bits for simple and complex chords
    int nCount = 0;
    int nSixSeven = 0;
    if ( IsSimple(rCurrentChord, nCount, nSixSeven) )
    {
        if (nCount <= 3)
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_TRIAD;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_TRIAD;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_TRIAD;
        }
        else if (nCount == 4)
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_6AND7;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_6AND7;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_6AND7;
        }
        else
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_COMPLEX;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_COMPLEX;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_COMPLEX;
        }
    }
    else
    {
        if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_COMPLEX;
        if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_COMPLEX;
        if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_COMPLEX;
    }
}


HRESULT CDirectMusicPattern::ComputeVariations(DWORD dwFlags,
                                               DMUS_CHORD_PARAM& rCurrentChord,
                                               DMUS_CHORD_PARAM& rNextChord,
                                               BYTE abVariationGroups[],
                                               DWORD adwVariationMask[],
                                               DWORD adwRemoveVariations[],
                                               BYTE abVariation[],
                                               MUSIC_TIME mtTime,
                                               MUSIC_TIME mtNextChord,
                                               PatternTrackState* pState)
{
    HRESULT hr = S_OK;
    // First, initialize the array of variation groups.
    for (short i = 0; i < MAX_VARIATION_LOCKS; i++)
    {
        abVariationGroups[i] = 0xFF;
    }
    // Now, compute the variations for each part.
    TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
    for (i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
        hr = ComputeVariation(
                pPartRef->GetItemValue(),
                i,
                dwFlags,
                rCurrentChord,
                rNextChord,
                abVariationGroups,
                adwVariationMask,
                adwRemoveVariations,
                abVariation,
                mtTime,
                mtNextChord,
                pState);
        if (FAILED(hr))
        {
            break;
        }
    }
    return hr;
}

HRESULT CDirectMusicPattern::ComputeVariationGroup(DirectMusicPartRef& rPartRef,
                                                   int nPartIndex,
                                                  DWORD dwFlags,
                                                  DMUS_CHORD_PARAM& rCurrentChord,
                                                  DMUS_CHORD_PARAM& rNextChord,
                                                  BYTE abVariationGroups[],
                                                  DWORD adwVariationMask[],
                                                  DWORD adwRemoveVariations[],
                                                  BYTE abVariation[],
                                                  MUSIC_TIME mtTime,
                                                  MUSIC_TIME mtNextChord,
                                                  PatternTrackState* pState)
{
    HRESULT hr = S_OK;
    BYTE bLockID = rPartRef.m_bVariationLockID;
    bool fChangedVariation = (dwFlags & COMPUTE_VARIATIONSF_CHANGED) ? true : false;
    // If this part is locked, get a new variation for all parts locked to it;
    // otherwise, just get a new variation for this part.
    if (bLockID)
    {
        if (!fChangedVariation)
        {
            // First, initialize the variation group for this variation.
            abVariationGroups[bLockID - 1] = 0xFF;
            // Now, compute the variations for each part locked to this one.
            TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                DirectMusicPartRef& rPartRefScan = pPartRef->GetItemValue();
                if ( (bLockID == rPartRefScan.m_bVariationLockID) )
                {
                    hr = ComputeVariation(
                            rPartRefScan,
                            i,
                            dwFlags,
                            rCurrentChord,
                            rNextChord,
                            abVariationGroups,
                            adwVariationMask,
                            adwRemoveVariations,
                            abVariation,
                            mtTime,
                            mtNextChord,
                            pState);
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
        }
    }
    else
    {
        hr = ComputeVariation(
                rPartRef,
                nPartIndex,
                dwFlags,
                rCurrentChord,
                rNextChord,
                abVariationGroups,
                adwVariationMask,
                adwRemoveVariations,
                abVariation,
                mtTime,
                mtNextChord,
                pState);
    }
    return hr;
}

HRESULT CDirectMusicPattern::ComputeVariation(DirectMusicPartRef& rPartRef,
                                              int nPartIndex,
                                              DWORD dwFlags,
                                              DMUS_CHORD_PARAM& rCurrentChord,
                                              DMUS_CHORD_PARAM& rNextChord,
                                              BYTE abVariationGroups[],
                                              DWORD adwVariationMask[],
                                              DWORD adwRemoveVariations[],
                                              BYTE abVariation[],
                                              MUSIC_TIME mtTime,
                                              MUSIC_TIME mtNextChord,
                                              PatternTrackState* pState)
{
    int i = nPartIndex;
    bool fUseMask = (dwFlags & COMPUTE_VARIATIONSF_USE_MASK) ? true : false;
    bool fNewPattern = (dwFlags & COMPUTE_VARIATIONSF_NEW_PATTERN) ? true : false;
    bool fChordAlign = (dwFlags & COMPUTE_VARIATIONSF_CHORD_ALIGN) ? true : false;
    bool fMarker = (dwFlags & COMPUTE_VARIATIONSF_MARKER) ? true : false;
    bool fStart = (dwFlags & COMPUTE_VARIATIONSF_START) ? true : false;
    bool fIsDX8 = (dwFlags & COMPUTE_VARIATIONSF_DX8) ? true : false;
    bool fChord = false;
    if (pState && (mtTime == pState->m_mtCurrentChordTime || mtTime == pState->m_mtNextChordTime))
    {
        fChord = true;
    }
    DWORD dwMarkerFlags = DMUS_MARKERF_START;
    DWORD dwDMusNaturals, dwDMusSharps, dwDMusFlats;
    DMusMoawFlags(mtTime, mtNextChord, rCurrentChord, rNextChord, fIsDX8, dwDMusNaturals, dwDMusSharps, dwDMusFlats);
    DWORD dwIMA25MoawFlags = IMA25MoawFlags(mtTime, mtNextChord, rCurrentChord, rNextChord);
    TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
    DWORD dwNaturalFlags, dwSharpFlags, dwFlatFlags;
    /*// First, initialize the array of variation groups
    for (short i = 0; i < MAX_VARIATION_LOCKS; i++)
    {
        abVariationGroups[i] = 0xFF;
    }*/
    //for (i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
    //  if (pguidPart &&
    //      pPartRef->GetItemValue().m_pDMPart &&
    //      *pguidPart != pPartRef->GetItemValue().m_pDMPart->m_guidPartID)
    //  {
    //      continue; // the way this was, it wiped out variation locking
    //  }
        DWORD dwVariationChoices = 0xffffffff;
        if (fUseMask)
        {
            dwVariationChoices = adwVariationMask[i];
        }
    //  DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
        BYTE bLockID = rPartRef.m_bVariationLockID;
        DirectMusicPart* pPart = rPartRef.m_pDMPart;
        MUSIC_TIME mtPartOffset = (pState) ? pState->PartOffset(i) : 0;
        MUSIC_TIME mtNowRelative = (mtTime >= mtPartOffset) ? mtTime - mtPartOffset : 0;
        MUSIC_TIME mtClosestTime = 0;
        // Find a variation whose moaw field matches dwMoawFlags.
        // Variation locking: If a part ref has a variation lock id that has already been
        // recorded, use the recorded variation.  Otherwise, find a variation and, if the
        // part ref has a variation lock id, record the variation.
        if (bLockID && abVariationGroups[bLockID - 1] != 0xFF)
        {
            abVariation[i] = abVariationGroups[bLockID - 1];
            adwVariationMask[i] = abVariationGroups[bLockID - 1];
        }
        else
        {
            // First, collect all matches.
            // Also, find the time of the matching variation closest to but not preceding mtTime.
            BYTE bMode = 0;
            DWORD dwMatches = 0;
            DWORD dwCompleteMatches = 0;
            short nMatchCount = 0;
            DWORD dwEnabled = 0;
            short nEnabledCount = 0;
            bool fGotClosest = false;
            for (short nV = 0; nV < 32; nV++)
            {
                DWORD dwVariation = 1 << nV;
                if (dwVariation & dwVariationChoices)
                {
                    if ( (pPart->m_dwVariationChoices[nV] & 0x5FFFFFFF) != 0) // enabled
                    {
                        nEnabledCount++;
                        dwEnabled |= dwVariation;
                    }
                    if (pPart->m_dwVariationChoices[nV] & DMUS_VARIATIONF_DMUS_MODE)
                    {
                        dwNaturalFlags = dwDMusNaturals;
                        dwSharpFlags = dwDMusSharps;
                        dwFlatFlags = dwDMusFlats;
                    }
                    else
                    {
                        dwNaturalFlags = dwSharpFlags = dwFlatFlags = dwIMA25MoawFlags;
                    }
                    if ( (dwNaturalFlags && (pPart->m_dwVariationChoices[nV] & dwNaturalFlags) == dwNaturalFlags) ||
                         (dwSharpFlags && (pPart->m_dwVariationChoices[nV] & dwSharpFlags) == dwSharpFlags) ||
                         (dwFlatFlags && (pPart->m_dwVariationChoices[nV] & dwFlatFlags) == dwFlatFlags) )
                    {
                        nMatchCount++;
                        dwMatches |= dwVariation;
                        if ((fStart || fMarker) && pPart && (pPart->m_dwFlags & DMUS_PARTF_USE_MARKERS))
                        {
                            MUSIC_TIME mtTemp = 0;
                            if (SUCCEEDED(pPart->GetClosestTime(nV, mtNowRelative, dwMarkerFlags, fChord, mtTemp)))
                            {
                                if (!fGotClosest || mtTemp < mtClosestTime)
                                {
                                    mtClosestTime = mtTemp;
                                    fGotClosest = true;
                                }
                            }
                        }
                    }
                }
            }
            dwCompleteMatches = dwMatches;
            DWORD dwTemp = dwMatches;
            bMode = rPartRef.m_bRandomVariation;
            if ( bMode == DMUS_VARIATIONT_RANDOM_ROW )
            {
                dwTemp &= ~adwRemoveVariations[i];
                if (!dwTemp)
                {
                    // start counting all over, but don't repeat this one
                    adwRemoveVariations[i] = 0;
                    dwTemp = dwMatches;
                    bMode = DMUS_VARIATIONT_NO_REPEAT;
                }
            }
            if ( bMode == DMUS_VARIATIONT_NO_REPEAT && abVariation[i] != 0xff )
            {
                dwTemp &= ~(1 << abVariation[i]);
            }
            if (dwTemp != dwMatches)
            {
                if (dwTemp) // otherwise, keep what we had
                {
                    for (int j = 0; j < 32; j++)
                    {
                        if ( ((1 << j) & dwMatches) && !((1 << j) & dwTemp) )
                        {
                            nMatchCount--;
                        }
                    }
                    dwMatches = dwTemp;
                }
            }
            if (nMatchCount == 0)
            {
                if (nEnabledCount)
                {
                    // if there are any enabled variations, choose from among them
                    nMatchCount = nEnabledCount;
                    dwMatches = dwEnabled;
                }
                else
                {
                    // otherwise, choose any variation from among the first 16
                    // (for compatability with SuperJam)
                    nMatchCount = 16;
                    dwMatches = 0xffffffff;
                }
            }
            adwVariationMask[i] = dwMatches;
            // If we're starting at or past a marker, or we're at a marker,
            // and the part is using markers, filter out all 
            // variations except those with start markers closest to but not preceding mtNow.
            if ( ((fStart && mtTime >= mtClosestTime) || fMarker) &&
                 pPart && (pPart->m_dwFlags & DMUS_PARTF_USE_MARKERS) )
            {
                DWORD dwMatchTemp = dwMatches;
                short nCountTemp = nMatchCount;
                for (nV = 0; nV < 32; nV++)
                {
                    if (dwMatches & (1 << nV))
                    {
                        if ( !pPart->IsMarkerAtTime(nV, mtClosestTime, dwMarkerFlags, fChord) )
                        {
                            dwMatches &= ~(1 << nV);
                            nMatchCount--;
                        }
                    }
                }
                // Fall back to the original matches
                if (!dwMatches)
                {
                    dwMatches = dwMatchTemp;
                    nMatchCount = nCountTemp;
                }
            }

            // Next, select a match.
            // Only select a match if either we're just starting a new pattern,
            // we're at a chord-aligned marker,
            // or the current variation isn't a match.
            // If this part aligns variations to chords, only get a new variation
            // if we're just starting a new pattern,
            // or we're at a chord-aligned marker AND the current variation isn't a match.
            TraceI(3, "Matches: %x\n", dwMatches);
            bool fAlignPartToChord = (pPart->m_dwFlags & DMUS_PARTF_ALIGN_CHORDS) ? true : false;
            bool fMatch = ((1 << abVariation[i]) & dwCompleteMatches) ? true : false;
            bool fFirstRandomInOrder = false;
            if ( fNewPattern ||
                 (!fAlignPartToChord && (fChordAlign || !fMatch)) ||
                 (fAlignPartToChord && fChordAlign && !fMatch) )
            {
                //TraceI(0, "Time: %d, New Pattern: %d Chord Align: %d Variation: %d Matches: %x\n",
                //  mtTime, fNewPattern, fChordAlign, abVariation[i], dwCompleteMatches);
                switch (rPartRef.m_bRandomVariation)
                {
                case DMUS_VARIATIONT_RANDOM_ROW:
                case DMUS_VARIATIONT_NO_REPEAT:
                case DMUS_VARIATIONT_RANDOM:
                    {
                        short nChoice = 0;
                        if (pState)
                        {
                            nChoice = (short)pState->RandomVariation(mtTime, nMatchCount);
                        }
                        else
                        {
                            nChoice = (short) (rand() % nMatchCount);
                        }
                        short nCount = 0;
                        for (nV = 0; nV < 32; nV++)
                        {
                            if ((1 << nV) & dwMatches)
                            {
                                if (nChoice == nCount)
                                    break;
                                nCount++;
                            }
                        }
                        abVariation[i] = (BYTE) nV;
                        if (rPartRef.m_bRandomVariation == DMUS_VARIATIONT_RANDOM_ROW)
                        {
                            adwRemoveVariations[i] |= (1 << abVariation[i]);
                        }
                        TraceI(3, "New variation: %d at time %d\n", nV, mtTime);
                        break;
                    }
                case DMUS_VARIATIONT_RANDOM_START:
                    // Choose an initial value
                    if (abVariation[i] == 0xff)
                    {
                        fFirstRandomInOrder = true;
                        int nStart = 0;
                        if (pState)
                        {
                            nStart = (BYTE)pState->RandomVariation(mtTime, nMatchCount);
                        }
                        else
                        {
                            nStart = (BYTE) (rand() % nMatchCount);
                        }
                        int nCount = 0;
                        for (nV = 0; nV < 32; nV++)
                        {
                            if ((1 << nV) & dwMatches)
                            {
                                if (nStart == nCount)
                                    break;
                                nCount++;
                            }
                        }
                        abVariation[i] = (BYTE) nV;
                    }
                    // Now, go directly to the sequential case (no break)
                case DMUS_VARIATIONT_SEQUENTIAL:
                    {
                        if (!fFirstRandomInOrder)
                        {
                            do
                            {
                                abVariation[i]++;
                            }
                            while (!((1 << ((nV + abVariation[i]) % 32)) & dwMatches));
                            abVariation[i]  %= 32;
                        }
                        TraceI(3, "New variation: %d at time %d\n", abVariation[i], mtTime);
                        break;
                    }
                }
                // If this is a locked variation, it's the first in its group, so record it.
                if (bLockID)
                {
                    abVariationGroups[bLockID - 1] = abVariation[i];
                }
            }
        }
    }
    return S_OK;
}

// Returns:
// Total number of bits in the pattern if all bits in the rhythm match the pattern.
// 0 otherwise.
void CDirectMusicPattern::MatchRhythm(DWORD pRhythms[], short nPatternLength,
                 short& nBits)
{
    nBits = 0;
    for (int i = 0; i < nPatternLength; i++)
    {
        if (i >= m_wNumMeasures)
        {
            return;
        }
        if ((pRhythms[i] & m_pRhythmMap[i]) == pRhythms[i])
        {
            for (int n = 0; n < 32; n++)
            {
                nBits += (short) (m_pRhythmMap[i] >> n) & 1;
            }
        }
        else
        {
            nBits = 0;
            return;
        }
    }
}

BOOL CDirectMusicPattern::MatchCommand(DMUS_COMMAND_PARAM_2 pCommands[], short nLength)
{
    short nPatternLength = (m_wNumMeasures < nLength) ? m_wNumMeasures : nLength;
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    for (int i = 0; i < nPatternLength; i++)
    {
        if ( (i > 0) &&
             (pCommands[i].bCommand == DMUS_COMMANDT_GROOVE) &&
             (pCommands[i].bGrooveLevel == pCommands[0].bGrooveLevel) )
        {
            continue;
        }
        if (!MatchEmbellishment(pCommands[i])) return FALSE;
        if (!MatchGrooveLevel(pCommands[i])) return FALSE;
    }
    return TRUE;
}

BOOL CDirectMusicPattern::MatchGrooveLevel(DMUS_COMMAND_PARAM_2& rCommand)
{
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    // Lower the upper range and raise the lower range by half of the total range each
    BYTE bMiddle = rCommand.bGrooveRange / 2;
    BYTE bUpper = (rCommand.bGrooveLevel < bMiddle) ? 1 : rCommand.bGrooveLevel - bMiddle;
    BYTE bLower = (rCommand.bGrooveLevel + bMiddle > 100) ? 100 : rCommand.bGrooveLevel + bMiddle;
    TraceI(3, "Range: %d Upper: %d Lower: %d\n", bMiddle, bUpper, bLower);
    return (bLower >= m_bGrooveBottom && bUpper <= m_bGrooveTop);
}

BOOL CDirectMusicPattern::MatchEmbellishment(DMUS_COMMAND_PARAM_2& rCommand)
{
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    if ((m_wEmbellishment & EMB_USER_DEFINED)) // handle user-defined embellishments
    {
        if ((BYTE)(m_wEmbellishment >> 8) != rCommand.bCommand) return FALSE;
    }
    else
    {
        switch (rCommand.bCommand)
        {
        case DMUS_COMMANDT_GROOVE:
            if ((m_wEmbellishment & EMB_NORMAL) != m_wEmbellishment) return FALSE;
            break;
        case DMUS_COMMANDT_FILL:
            if (!(m_wEmbellishment & EMB_FILL)) return FALSE;
            break;
        case DMUS_COMMANDT_INTRO:
            if (!(m_wEmbellishment & EMB_INTRO)) return FALSE;
            break;
        case DMUS_COMMANDT_BREAK:
            if (!(m_wEmbellishment & EMB_BREAK)) return FALSE;
            break;
        case DMUS_COMMANDT_END:
            if (!(m_wEmbellishment & EMB_END)) return FALSE;
            break;
        default: return FALSE;
        }
    }
    return TRUE;
}

BOOL CDirectMusicPattern::MatchNextCommand(DMUS_COMMAND_PARAM_2& rNextCommand)
{
    TraceI(3, "Next Command: %x (%d) Embellishment: %x [%d %d] <%d %d>\n", rNextCommand.bCommand, rNextCommand.bGrooveLevel,
        m_wEmbellishment, m_bGrooveBottom, m_bGrooveTop, m_bDestGrooveBottom, m_bDestGrooveTop);
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    if (!m_bDestGrooveBottom || !m_bDestGrooveTop) // handle legacy
    {
        return TRUE;
    }
    // Lower the upper range and raise the lower range by half of the total range each
    BYTE bMiddle = rNextCommand.bGrooveRange / 2;
    BYTE bUpper = (rNextCommand.bGrooveLevel < bMiddle) ? 1 : rNextCommand.bGrooveLevel - bMiddle;
    BYTE bLower = (rNextCommand.bGrooveLevel + bMiddle > 100) ? 100 : rNextCommand.bGrooveLevel + bMiddle;
    TraceI(3, "Range: %d Upper: %d Lower: %d\n", bMiddle, bUpper, bLower);
    return (bLower >= m_bDestGrooveBottom && bUpper <= m_bDestGrooveTop);
}

HRESULT CDirectMusicPattern::MergeMarkerEvents( DMStyleStruct* pStyle )
{
    TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
    for (; pPartRef; pPartRef = pPartRef->GetNext())
    {
        pPartRef->GetItemValue().m_pDMPart->MergeMarkerEvents(pStyle, this);
    }
    return S_OK;
}

bool Greater(MUSIC_TIME& mt1, MUSIC_TIME& mt2)
{
    return mt1 > mt2;
}

bool Greater(Marker& m1, Marker& m2)
{
    return m1.mtTime > m2.mtTime;
}

template <class T>
HRESULT InsertInOrder(TList<T>& List, T tValue)
{
    TListItem<T>* pNew = new TListItem<T>(tValue);
    if (!pNew) return E_OUTOFMEMORY;
    TListItem<T>* pScan = List.GetHead();
    TListItem<T>* pPrevious = NULL;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (Greater(pScan->GetItemValue(), tValue))
        {
            break;
        }
        pPrevious = pScan;
    }
    if (!pPrevious)
    {
        List.AddHead(pNew);
    }
    else
    {
        pPrevious->SetNext(pNew);
        pNew->SetNext(pScan);
    }
    return S_OK;
}

HRESULT DirectMusicPart::MergeMarkerEvents( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern )
{
    DirectMusicTimeSig& TimeSig = TimeSignature(pStyle, pPattern);
    CDirectMusicEventItem* pEvent;
    for (pEvent = EventList.GetHead(); pEvent; pEvent = pEvent->GetNext())
    {
        if (pEvent->m_dwEventTag == DMUS_EVENT_MARKER)
        {
            CDMStyleMarker* pMarker = (CDMStyleMarker*)pEvent;
            if (pMarker->m_wFlags & DMUS_MARKERF_START)
            {
                MUSIC_TIME mtTime =
                    (MUSIC_TIME)(TimeSig.GridToClocks(pMarker->m_nGridStart) + pMarker->m_nTimeOffset);
                // Put this in all the appropriate variation lists
                for (int i = 0; i < 32; i++)
                {
                    if (pMarker->m_dwVariation & (1 << i))
                    {
                        Marker M;
                        M.mtTime = mtTime;
                        M.wFlags = pMarker->m_wFlags;
                        InsertInOrder(m_StartTimes[i], M);
                    }
                }
                InsertInOrder(pPattern->m_StartTimeList, mtTime);
            }
        }
    }
    return S_OK;
}

HRESULT DirectMusicPart::GetClosestTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord, MUSIC_TIME& rmtResult)
{
    HRESULT hr = E_FAIL;
    rmtResult = 0;
    if (nVariation < 32 && nVariation >= 0)
    {
        TListItem<Marker>* pMarker = m_StartTimes[nVariation].GetHead();
        for (; pMarker; pMarker = pMarker->GetNext())
        {
            if ( pMarker->GetItemValue().mtTime >= mtTime &&
                 (pMarker->GetItemValue().wFlags & dwFlags) == dwFlags &&
                 (fChord || !(pMarker->GetItemValue().wFlags & DMUS_MARKERF_CHORD_ALIGN)) )
            {
                rmtResult = pMarker->GetItemValue().mtTime;
                hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

bool DirectMusicPart::IsMarkerAtTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord)
{
    bool fResult = false;
    if (nVariation < 32 && nVariation >= 0)
    {
        TListItem<Marker>* pMarker = m_StartTimes[nVariation].GetHead();
        for (; pMarker; pMarker = pMarker->GetNext())
        {
            if ( pMarker->GetItemValue().mtTime == mtTime &&
                 (pMarker->GetItemValue().wFlags & dwFlags) == dwFlags &&
                 (fChord || !(pMarker->GetItemValue().wFlags & DMUS_MARKERF_CHORD_ALIGN)) )
            {
                fResult = true;
                break;
            }
        }
    }

    return fResult;
}

DirectMusicTimeSig& CDirectMusicPattern::TimeSignature( DMStyleStruct* pStyle )
{
    if (m_timeSig.m_bBeat != 0)
    {
        return m_timeSig;
    }
    else if (pStyle)
    {
        return pStyle->TimeSignature();
    }
    else
    {
        return ::DefaultTimeSig;
    }
}

DirectMusicTimeSig& DirectMusicPart::TimeSignature( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern )
{
    if (m_timeSig.m_bBeat != 0)
    {
        return m_timeSig;
    }
    else if (pPattern)
    {
        return pPattern->TimeSignature(pStyle);
    }
    else
    {
        return ::DefaultTimeSig;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmstyle2.h ===
// Dx8Style.h : New for DX8
//
// Copyright (c) 1999-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DX8STYLE_H_
#define __DX8STYLE_H_

/*
@interface IDirectMusicStyle8 | 
The <i IDirectMusicStyle8> interface extends the <i IDirectMusicStyle> interface.


@base public | IUnknown

@meth HRESULT | ComposeMelodyFromTemplate | Creates a sequence segment from a 
style and a Melody template (containing a Melody Generation track, a Chord track,
and an optional Style track).  Clones the segment and adds a 
Sequence track containing melodic information.
*/

// This eventually will go in dmusici.h

/*/////////////////////////////////////////////////////////////////////*/

#endif //__DX8STYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\filter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       filter.cpp
//
//--------------------------------------------------------------------------

#include "dmstyle.h"
#include "styletrk.h"

HRESULT PatternDispatcher::Filter(DWORD dwType)
{
    HRESULT hr = S_OK;
    for (int i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag && !Test(m_aPatterns[i].pPattern, dwType))
        {
            m_aPatterns[i].dwTag = dwType;
        }
    }
    return hr;
}

HRESULT PatternDispatcher::Scan(DWORD dwType)
{
    HRESULT hr = S_OK;
    for (int i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag)
        {
             Test(m_aPatterns[i].pPattern, dwType);
        }
    }
    return hr;
}

bool PatternDispatcher::Test(CDirectMusicPattern*& rValue, DWORD dwType)
{
    bool fResult = false;
    if (!rValue) return false;
    short nBits = 0;
    switch(dwType)
    {
    case MATCH_RHYTHM_BITS:
        rValue->MatchRhythm(m_pRhythms, (short)m_nPatternLength, nBits);
        if (m_nWinBits == nBits)
        {
            fResult = true;
        }
        break;
    case MATCH_COMMAND_AND_RHYTHM:
        // the best pattern is the longest pattern with the fewest number of bits in its
        // rhythm map, where all bits match the bits in the actual rhythm.
        rValue->MatchRhythm(m_pRhythms, (short)m_nPatternLength, nBits);
        if (nBits &&
            (!m_nWinBits || nBits <= m_nWinBits) &&
            (!m_nPatternLength || (rValue->m_wNumMeasures <= m_nPatternLength)) &&
            (!m_nNextCommand || (rValue->m_wNumMeasures <= m_nNextCommand)) &&
            rValue->MatchCommand(m_pCommands, (short)m_nPatternLength))
        {
            m_nWinBits = nBits;
            fResult = true;
        }
        break;
    case MATCH_COMMAND_FULL:
        if (rValue->MatchCommand(m_pCommands, (short)m_nPatternLength) &&
            (!m_nPatternLength || (rValue->m_wNumMeasures <= m_nPatternLength)) &&
            (!m_nNextCommand || (rValue->m_wNumMeasures <= m_nNextCommand)) )
        {
            fResult = true;
        }
        break;
    case MATCH_COMMAND_PARTIAL:
        if (rValue->MatchCommand(m_pCommands, 1))
        {
            fResult = true;
        }
        break;
    case MATCH_EMBELLISHMENT:
        if (rValue->MatchEmbellishment(m_pCommands[0]))
        {
            fResult = true;
        }
        break;
    case MATCH_GROOVE_LEVEL:
        if (rValue->MatchGrooveLevel(m_pCommands[0]) && rValue->m_wEmbellishment == EMB_NORMAL)
        {
            fResult = true;
        }
        break;
    case MATCH_NEXT_COMMAND:
        if (m_pStyleTrackState)
        {
            MUSIC_TIME mtNextCommand = 0;
            HRESULT hr = S_OK;
            DMUS_COMMAND_PARAM_2 CommandParam;
            BYTE bActualCommand;
            mtNextCommand = rValue->m_wNumMeasures * m_mtMeasureTime;
            if (m_mtNextCommand && mtNextCommand > m_mtNextCommand)
            {
                mtNextCommand = m_mtNextCommand;
            }
            if (m_pStyle && m_pPerformance)
            {
                hr = m_pStyle->GetCommand(
                            m_mtNow + mtNextCommand, 
                            m_mtOffset, 
                            m_pPerformance, 
                            NULL,
                            m_pStyleTrackState->m_dwGroupID,
                            &CommandParam, 
                            bActualCommand);
            }
            if (FAILED(hr) || !m_pStyle || !m_pPerformance)
            {
                //TraceI(2, "Couldn't get a command! hr: %x Now: %d Next Command: %d Offset: %d\n", hr, m_mtNow, mtNextCommand, m_mtOffset);
                IDirectMusicSegment* pSegment = NULL;
                if (SUCCEEDED(m_pStyleTrackState->m_pSegState->GetSegment(&pSegment)))
                {
                    hr = pSegment->GetParam(
                        GUID_CommandParamNext, m_pStyleTrackState->m_dwGroupID, DMUS_SEG_ANYTRACK, 0, NULL, &CommandParam);
                    pSegment->Release();
                }
                if (FAILED(hr))
                {
                    //TraceI(2, "STILL couldn't get a command! hr: %x\n", hr);
                }
                else
                {
                    //TraceI(2, "Got a command using GUID_CommandParamNext.\n", hr);
                }
            }
            if (SUCCEEDED(hr) && rValue->MatchNextCommand(CommandParam))
            {
                //TraceI(2, "Found a match!\n");
                fResult = true;
            }
        }
        break;
    case FIND_LONGEST_PATTERN:
        if (rValue->m_wNumMeasures > m_MaxBars)
        {
            m_MaxBars = rValue->m_wNumMeasures;
        }
        break;
    case COLLECT_LONGEST_PATTERN:
        if (rValue->m_wNumMeasures == m_MaxBars)
        {
            fResult = true;
        }
        break;
    case FIND_LONGEST_TIMESIG:
        {
            DirectMusicTimeSig TimeSig = rValue->TimeSignature(m_pStyle);
            int nLHS = m_MaxNum * TimeSig.m_bBeat;
            int nRHS = m_MaxDenom * TimeSig.m_bBeatsPerMeasure;
            if ((nLHS < nRHS) ||
                (nLHS == nRHS && m_MaxNum < TimeSig.m_bBeatsPerMeasure))
            {
                m_MaxNum = TimeSig.m_bBeatsPerMeasure;
                m_MaxDenom = TimeSig.m_bBeat;
            }
        }
        break;
    case COLLECT_LONGEST_TIMESIG:
        {
            DirectMusicTimeSig TimeSig = rValue->TimeSignature(m_pStyle);
            if (TimeSig.m_bBeatsPerMeasure == m_MaxNum &&
                TimeSig.m_bBeat == m_MaxDenom)
            {
                fResult = true;
            }
        }
        break;
    }
    return fResult;
}

CDirectMusicPattern* PatternDispatcher::RandomSelect()
{
    int nCount = 0, i = 0, n = 0;
    for (i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag)
        {
            nCount++;
        }
    }
    if (!nCount) return NULL;
    nCount = rand() % nCount;
    for (i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag)
        {
            if (n == nCount) break;
            n++;
        }
    }
    if (i >= m_nPatternCount) return NULL;
    return m_aPatterns[i].pPattern;
}

HRESULT PatternDispatcher::FindPattern(CDirectMusicPattern* pSearchPattern, int& rResult)
{
    HRESULT hr = S_FALSE;
    for (int i = 0; i < m_nPatternCount; i++)
    {
        if (m_aPatterns[i].pPattern == pSearchPattern)
        {
            if (!m_aPatterns[i].dwTag)
            {
                hr = S_OK;
                rResult = i;
            }
            break;
        }
    }
    return hr;
}

void PatternDispatcher::SetMeasureTime(MUSIC_TIME mtMeasureTime)
{
    m_mtMeasureTime = mtMeasureTime;
    MUSIC_TIME mtRoundNextCommand = m_mtNextCommand;
    if (m_mtMeasureTime && m_pStyle && m_pStyle->UsingDX8()) // keeps content created under dx7 consistent
    {
        MUSIC_TIME mtMeasureOverun = mtRoundNextCommand % m_mtMeasureTime;
        if (mtMeasureOverun)
        {
            //TraceI(0, "Next command time: %d\n", mtRoundNextCommand);
            mtRoundNextCommand += m_mtMeasureTime - mtMeasureOverun;
            //TraceI(0, "Overun: %d New next command time: %d\n", mtMeasureOverun, mtRoundNextCommand);
        }
    }
    m_nNextCommand = mtMeasureTime ? (mtRoundNextCommand / mtMeasureTime) : 0;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmstyle2.cpp ===
//
// DMStyle2.cpp : Further Implementation of CDMStyle
//
// Copyright (c) 1999-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "DMStyle.h"
#include "debug.h"

#include "..\shared\Validate.h"
#include "iostru.h"
#include "mgentrk.h"

struct FirstTimePair
{
    DWORD dwPart;
    MUSIC_TIME mtTime;
};

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicStyle2

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeMelodyFromTemplate | Creates a sequence segment from a
style and a Melody template (containing a Melody Generation track, a Chord track, and an
optional Style track).  Clones the segment and adds a Sequence track containing melodic
information.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and <p ppSeqSeg> is an invalid pointer.
@flag E_INVALIDARG | <p pStyle> is NULL and there is no Style track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL,
a Style is retrieved from <p pTempSeg>'s Style track.
The length of the section segment is equal to the length of the template section
passed in.
*/

HRESULT CDMStyle::ComposeMelodyFromTemplate(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to create the sequence segment.
                    IDirectMusicSegment*        pTempSeg, // @parm The template from which to create the sequence segment.
                    IDirectMusicSegment**       ppSeqSeg // @parm Returns the created sequence segment.
            )
{
    V_INAME(ComposeMelodyFromTemplate)

    V_PTR_WRITE_OPT(pStyle, 1);
    V_PTR_WRITE(pTempSeg, 1);
    V_PTRPTR_WRITE(ppSeqSeg);

    DWORD dwTrackGroup = 0xffffffff;
    BOOL fStyleFromTrack = FALSE;
    HRESULT hr = S_OK;
    IDirectMusicTrack* pPatternTrack = NULL;
    IDirectMusicTrack* pMelGenTrack = NULL;
    MUSIC_TIME mtLength = 0;
    hr = pTempSeg->GetLength(&mtLength);
    if (FAILED(hr)) goto ON_END;

    // get the MelGen track and its track group.
    hr = pTempSeg->GetTrack(CLSID_DirectMusicMelodyFormulationTrack, 0xffffffff, 0, &pMelGenTrack);
    if (S_OK != hr) goto ON_END;
    if (FAILED(pTempSeg->GetTrackGroup(pMelGenTrack, &dwTrackGroup)))
    {
        dwTrackGroup = 0xffffffff;
    }

    // Get the style (either use the passed-in style or get one from a style track)
    if (!pStyle)
    {
        if (FAILED(hr = GetStyle(pTempSeg, 0, dwTrackGroup, pStyle)))
        {
            hr = E_INVALIDARG;
            goto ON_END;
        }
        fStyleFromTrack = TRUE;
    }

    // Using style, and melgen track, create a pattern track
    hr = GenerateTrack(pTempSeg, NULL, dwTrackGroup, pStyle, pMelGenTrack, mtLength, pPatternTrack);
    if (SUCCEEDED(hr))
    {
        if (hr == S_FALSE)
        {
            if (pPatternTrack) pPatternTrack->Release();
            pPatternTrack = NULL;
        }
        HRESULT hrCopy = CopySegment(pTempSeg, pStyle, pPatternTrack, dwTrackGroup, ppSeqSeg);
        if (FAILED(hrCopy)) hr = hrCopy;
    }

ON_END:
    // release from Addref in GetTrack
    if (pMelGenTrack) pMelGenTrack->Release();
    // release from CoCreateInstance in CreatePatternTrack
    if (pPatternTrack) pPatternTrack->Release();
    // Release from Addref in GetStyle
    if (fStyleFromTrack) pStyle->Release();

    return hr;
}

HRESULT CDMStyle::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwTrackGroup, IDirectMusicStyle*& rpStyle)
{
    HRESULT hr = S_OK;
    // Get the segment's style track.
    IDirectMusicTrack* pStyleTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicStyleTrack, dwTrackGroup, 0, &pStyleTrack);
    if (S_OK != hr) return hr;
    // Get the style from the style track
    hr = pStyleTrack->GetParam(GUID_IDirectMusicStyle, mt, NULL, (void*) &rpStyle);
    pStyleTrack->Release();
    return hr;
}

HRESULT CDMStyle::CopySegment(IDirectMusicSegment* pTempSeg,
                              IDirectMusicStyle* pStyle,
                              IDirectMusicTrack* pPatternTrack,
                              DWORD dwTrackGroup,
                              IDirectMusicSegment** ppSectionSeg)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    long                    nClocks                 = 0;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;

    DMUS_BAND_PARAM DMBandParam;
    pTempSeg->GetLength(&nClocks);
    /////////////////////////////////////////////////////////////
    // clone the template segment to get a section segment
    hr = pTempSeg->Clone(0, nClocks, ppSectionSeg);
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);

    // Remove all style tracks from the new segment.
    do
    {
        hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, dwTrackGroup, 0, &pIStyleTrack);
        if (S_OK == hr)
        {
            (*ppSectionSeg)->RemoveTrack(pIStyleTrack);
            pIStyleTrack->Release();
            pIStyleTrack = NULL;
        }
    } while (S_OK == hr);

    // hr is no longer S_OK, so reset it.
    hr = S_OK;

    // if there's no tempo track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicTempoTrack, dwTrackGroup, 0, &pDMTrack)))
    {
        // Create a Tempo Track in which to store the tempo events
        DMUS_TEMPO_PARAM tempo;
        tempo.mtTime = 0;

        pStyle->GetTempo(&tempo.dblTempo);
        if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
            NULL, CLSCTX_INPROC, IID_IDirectMusicTrack,
            (void**)&pDMTrack )))
        {
            if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
            {
                (*ppSectionSeg)->InsertTrack( pDMTrack, dwTrackGroup );
            }
        }
    }
    // if there's no band track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicBandTrack, dwTrackGroup, 0, &pBandTrack)))
    {
        // Create band track
        hr = ::CoCreateInstance(
            CLSID_DirectMusicBandTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pBandTrack
            );

        if(!SUCCEEDED(hr)) goto ON_END;

        // Load default band from style into track
        hr = pStyle->GetDefaultBand(&pBand);
        if (!SUCCEEDED(hr)) goto ON_END;
        DMBandParam.mtTimePhysical = -64;
        DMBandParam.pBand = pBand;
        hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
        if (!SUCCEEDED(hr)) goto ON_END;
        (*ppSectionSeg)->InsertTrack(pBandTrack, dwTrackGroup);
    }

    // Add the pattern track
    if (pPatternTrack)
    {
        (*ppSectionSeg)->InsertTrack(pPatternTrack, dwTrackGroup);
    }

    // Initialize the segment
    (*ppSectionSeg)->SetRepeats(0);
    TraceI(4, "Segment Length: %d\n", nClocks);
    (*ppSectionSeg)->SetLength(nClocks);

ON_END:
    if (pDMTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CoCreateInstance
        pDMTrack->Release();
    }
    if (pBandTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CoCreateInstance
        pBandTrack->Release();
    }
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

HRESULT CDMStyle::GenerateTrack(IDirectMusicSegment* pTempSeg,
                                IDirectMusicSong* pSong,
                                DWORD dwTrackGroup,
                                IDirectMusicStyle* pStyle,
                                IDirectMusicTrack* pMelGenTrack,
                                MUSIC_TIME mtLength,
                                IDirectMusicTrack*& pNewTrack)
{
    if (!pStyle || !pMelGenTrack) return E_INVALIDARG;

    HRESULT hr = S_OK;

    // CoCreate the pattern track
    hr = ::CoCreateInstance(
        CLSID_DirectMusicPatternTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pNewTrack
    );
    if (FAILED(hr)) return hr;

    // Get the Style's info struct
    IDMStyle* pDMStyle = NULL;
    hr = pStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle);
    if (FAILED(hr)) return hr;
    DMStyleStruct* pStyleStruct = NULL;
    pDMStyle->GetStyleInfo((void**)&pStyleStruct);

    MUSIC_TIME mtNewFragment = 0;
    MUSIC_TIME mtNext = 0;
    MUSIC_TIME mtRealNextChord = 0;
    MUSIC_TIME mtNextChord = 0;
    MUSIC_TIME mtLaterChord = 0;
    DMUS_MELODY_FRAGMENT DMUS_Fragment;
    memset(&DMUS_Fragment, 0, sizeof(DMUS_Fragment));
    DMUS_CHORD_PARAM CurrentChord;
    DMUS_CHORD_PARAM RealCurrentChord;
    DMUS_CHORD_PARAM NextChord;
    CDirectMusicPattern* pPattern;
    TList<CompositionFragment> listFragments;
    TListItem<CompositionFragment>* pLastFragment = NULL;
    CompositionFragment CompRepeat;
    FirstTimePair* aFirstTimes = NULL;
    BYTE bPlaymode = 0;
    pMelGenTrack->GetParam(GUID_MelodyPlaymode, 0, NULL,  (void*)&bPlaymode);
    if (bPlaymode & DMUS_PLAYMODE_NONE)
    {
        bPlaymode = DMUS_PLAYMODE_ALWAYSPLAY;
    }
    // for each melody fragment:
    do
    {
        pLastFragment = listFragments.GetHead();
        // get the fragment
        HRESULT hrFragment = pMelGenTrack->GetParam(GUID_MelodyFragment, mtNewFragment, &mtNext, (void*)&DMUS_Fragment);
        if (FAILED(hrFragment)) break;
        MelodyFragment Fragment = DMUS_Fragment;
        if (mtNext) mtNewFragment += mtNext;
        else mtNewFragment = 0;

        // get its repeat
        MelodyFragment repeatFragment = Fragment;
        hr = pMelGenTrack->GetParam(GUID_MelodyFragmentRepeat, 0, NULL, (void*)&DMUS_Fragment);
        if (SUCCEEDED(hr))
        {
            repeatFragment = DMUS_Fragment;
        }
        else // failing to get a repeat just means this fragment doesn't repeat; composition can still continue
        {
            hr = S_OK;
        }

        // If the fragment repeats an earlier fragment, get the earlier fragment.
        // Regardless, get the fragment's pattern.
        ZeroMemory( &CompRepeat, sizeof(CompRepeat));
        if (SUCCEEDED(hrFragment) && Fragment.UsesRepeat())
        {
            TListItem<CompositionFragment>* pScan = listFragments.GetHead();
            for (; pScan; pScan = pScan->GetNext())
            {
                if (pScan->GetItemValue().GetID() == repeatFragment.GetID())
                {
                    CompRepeat = pScan->GetItemValue();
                }
            }
            pPattern = CompRepeat.m_pPattern;
        }
        else
        {
            Fragment.GetPattern(pStyleStruct, pPattern, pLastFragment);
        }
        // bail if we couldn't get a pattern
        if (!pPattern)
        {
            hr = DMUS_E_NOT_FOUND;
            break;
        }

        // get the pattern's partrefs
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->m_PartRefList.GetHead();
        int nParts = pPattern->m_PartRefList.GetCount();

        // clear all inversion groups for the fragment
        Fragment.ClearInversionGroups();

        // get the starting chords for the fragment
        Fragment.GetChord(pTempSeg, pSong, dwTrackGroup, mtNextChord, CurrentChord, mtRealNextChord, RealCurrentChord);

        Fragment.GetChord(mtNextChord, pTempSeg, pSong, dwTrackGroup, mtLaterChord, NextChord);

        // initializations
        TListItem<CompositionFragment>* pFragmentItem = new TListItem<CompositionFragment>(Fragment);
        if (!pFragmentItem)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        CompositionFragment& rFragment = pFragmentItem->GetItemValue();
        hr = rFragment.Init(pPattern, pStyleStruct, nParts);
        if (FAILED(hr))
        {
            break;
        }
        if (aFirstTimes) delete [] aFirstTimes;
        aFirstTimes = new FirstTimePair[nParts];
        if (!aFirstTimes)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // If we're repeating using transposition intervals:
        // go through each part, attempting to fit the repeated part to the constraints.
        // If this process fails for any part, abort the process.
        // If it succeeds for every part, we can skip everything else that follows.
        // (ASSUMPTION 1: constraints are pattern-wide, and so must be satisfied by every part)
        // (ASSUMPTION 2: different parts are allowed to transpose by different intervals)
        HRESULT hrSkipVariations = S_OK;
        if (Fragment.RepeatsWithConstraints()) // if repeating using transposition intervals
        {
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                aFirstTimes[i].dwPart = pPartRef->GetItemValue().m_dwLogicalPartID;
                aFirstTimes[i].mtTime = 0;
                hrSkipVariations = Fragment.GetRepeatedEvents(CompRepeat,
                                                              CurrentChord,
                                                              RealCurrentChord,
                                                              bPlaymode,
                                                              i,
                                                              pPartRef->GetItemValue(),
                                                              pLastFragment,
                                                              aFirstTimes[i].mtTime,
                                                              rFragment.EventList(i));
                if (FAILED(hrSkipVariations)) break;
            }
        }
        else
        {
            hrSkipVariations = E_FAIL;
        }

        if (FAILED(hrSkipVariations))
        {
            // If we're repeating, make sure the repeat fragment actually has variations,
            // and is not itself repeating an earlier fragment.
            // (we don't need to get the pattern again; that will be the same for all repeats)
            CompositionFragment CompLast = CompRepeat;
            while (repeatFragment.UsesRepeat())
            {
                DWORD dwRepeatID = repeatFragment.GetRepeatID();
                ZeroMemory( &CompRepeat, sizeof(CompRepeat));
                TListItem<CompositionFragment>* pScan = listFragments.GetHead();
                for (; pScan; pScan = pScan->GetNext())
                {
                    if (pScan->GetItemValue().GetID() == dwRepeatID)
                    {
                        CompRepeat = pScan->GetItemValue();
                        repeatFragment = CompRepeat;
                        if (!CompLast.m_abVariations && CompRepeat.m_abVariations)
                        {
                            ZeroMemory( &CompLast, sizeof(CompLast));
                            CompLast = CompRepeat;
                        }
                    }
                }
            }

            // Get variations for the Fragment
            Fragment.GetVariations(rFragment, CompRepeat, CompLast, CurrentChord, NextChord, mtNextChord, pLastFragment);

            bool fNeedChord = false;

            // for each part in the pattern:
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                // Clean up anything that might have happened with repeats
                rFragment.CleanupEvents(i);

                if (fNeedChord)
                {
                    Fragment.GetChord(pTempSeg, pSong, dwTrackGroup, mtNextChord, CurrentChord, mtRealNextChord, RealCurrentChord);
                    Fragment.GetChord(mtNextChord, pTempSeg, pSong, dwTrackGroup, mtLaterChord, NextChord);
                    fNeedChord = false;
                }

                DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
                DirectMusicTimeSig& TimeSig = rFragment.GetTimeSig(pPart);
                aFirstTimes[i].dwPart = pPartRef->GetItemValue().m_dwLogicalPartID;
                aFirstTimes[i].mtTime = 0;
                bool fFoundFirst = false;
                // for each note in the variation:
                CDirectMusicEventItem* pEvent = pPart->EventList.GetHead();
                for (; pEvent; pEvent = pEvent->GetNext())
                {
                    if ( pEvent->m_dwVariation & (1 << rFragment.m_abVariations[i]) )
                    {
                        TListItem<EventWrapper>* pEventItem = NULL;
                        // get the time (offset from the start of the track)
                        MUSIC_TIME mtNow = Fragment.GetTime() +
                            TimeSig.GridToClocks(pEvent->m_nGridStart) + pEvent->m_nTimeOffset;
                        // Make sure this doesn't overlap with the next fragment.
                        MUSIC_TIME mtDuration = 0;
                        switch (pEvent->m_dwEventTag)
                        {
                        case DMUS_EVENT_NOTE:
                            mtDuration = ((CDMStyleNote*)pEvent)->m_mtDuration;
                            break;
                        case DMUS_EVENT_CURVE:
                            mtDuration = ((CDMStyleCurve*)pEvent)->m_mtDuration;
                            break;
                        }
                        bool fAddToOverlap = false;
                        if ( !mtNewFragment || mtNow + mtDuration <= mtNewFragment )
                        {
                            if (pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION)
                            {
                                fAddToOverlap = true;
                            }
                            else
                            {
                                // use proper chord for non-anticipated notes
                                if (mtRealNextChord != mtNextChord && mtNow >= mtRealNextChord)
                                {
                                    mtRealNextChord = mtNextChord;
                                    RealCurrentChord = CurrentChord;
                                }
                                // get a new chord if necessary
                                if (mtNextChord && mtNow >= mtNextChord)
                                {
                                    Fragment.GetChord(mtNow, pTempSeg, pSong, dwTrackGroup, mtNextChord, CurrentChord);
                                    mtRealNextChord = mtNextChord;
                                    RealCurrentChord = CurrentChord;
                                    fNeedChord = true;
                                }
                                // Convert the event to a wrapped event
                                hr = Fragment.GetEvent(pEvent, CurrentChord, RealCurrentChord, mtNow, pPartRef->GetItemValue(), pEventItem);
                                // Add the new event to a list of wrapped events.
                                if (hr == S_OK)
                                {
                                    rFragment.AddEvent(i, pEventItem);
                                }
                                if (!fFoundFirst || mtNow < aFirstTimes[i].mtTime)
                                {
                                    fFoundFirst = true;
                                    aFirstTimes[i].mtTime = mtNow;
                                }
                            }
                        }
                        // ignore anticipations that start after the next fragment
                        else if (pEvent->m_dwEventTag != DMUS_EVENT_ANTICIPATION)
                        {
                            fAddToOverlap = true;
                        }
                        if (fAddToOverlap)
                        {
                            TListItem<EventOverlap>* pOverlap = new TListItem<EventOverlap>;
                            if (pOverlap)
                            {
                                EventOverlap& rOverlap = pOverlap->GetItemValue();
                                rOverlap.m_PartRef = pPartRef->GetItemValue();
                                rOverlap.m_pEvent = pEvent;
                                rOverlap.m_mtTime = mtNow;
                                rOverlap.m_mtDuration = mtDuration;
                                rOverlap.m_Chord = CurrentChord;
                                rOverlap.m_RealChord = RealCurrentChord;
                                rFragment.AddOverlap(pOverlap);
                            }
                        }
                    }
                }
                if (!fFoundFirst) aFirstTimes[i].mtTime = mtNewFragment;
                // Sort the sequence items in reverse order, so that the last element is easy to find
                rFragment.SortEvents(i);
                        }
                // Clear this so the pointers it may reference aren't deleted twice.
                ZeroMemory( &CompLast, sizeof(CompLast));
        }
        listFragments.AddHead(pFragmentItem);
        // Go through the list of overlaps for the last fragment, adding any events that don't
        // actually overlap (and processing anticipations)
        // alg for processing anticipations:
        //   if the overlap list contains an anticipation for a part:
        //     find the first event in that part's fragment list
        //     make the start time of that event be the start time of the anticipation
        //     add to the duration of the event the difference between the event's start time
        //       and the anticipation's start time
        if (pLastFragment)
        {
            TListItem<EventWrapper>* pEventItem = NULL;
            CompositionFragment& rLastFragment = pLastFragment->GetItemValue();
            TListItem<EventOverlap>* pTupleItem;
            pTupleItem = rLastFragment.GetOverlapHead();
            for (; pTupleItem; pTupleItem = pTupleItem->GetNext() )
            {
                EventOverlap& rTuple = pTupleItem->GetItemValue();
                for (int i = 0; i < nParts; i++)
                {
                    if (rTuple.m_PartRef.m_dwLogicalPartID == aFirstTimes[i].dwPart) break;
                }
                if (i >= nParts ||
                    !aFirstTimes[i].mtTime ||
                    rTuple.m_mtTime < aFirstTimes[i].mtTime)
                {
                    if (rTuple.m_pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION)
                    {
                        if (i < nParts && aFirstTimes[i].mtTime)
                        {
                            TListItem<EventWrapper>* pFirstNote = NULL;
                            TListItem<EventWrapper>* pScan = rFragment.GetEventHead(i);
                            // since the list is sorted in reverse order, the first note in
                            // the fragment will be the last one in the list.
                            for (; pScan; pScan = pScan->GetNext())
                            {
                                if (pScan->GetItemValue().m_pEvent->m_dwEventTag == DMUS_EVENT_NOTE)
                                {
                                    pFirstNote = pScan;
                                }
                            }
                            if (pFirstNote)
                            {
                                EventWrapper& rFirstNote = pFirstNote->GetItemValue();
                                CDMStyleNote* pNoteEvent = (CDMStyleNote*)rFirstNote.m_pEvent;
                                pNoteEvent->m_mtDuration += (rFirstNote.m_mtTime - rTuple.m_mtTime);
                                rFirstNote.m_mtTime = rTuple.m_mtTime;
                            }
                        }
                    }
                    else
                    {
                        hr = rLastFragment.GetEvent(rTuple.m_pEvent, rTuple.m_Chord, rTuple.m_RealChord, rTuple.m_mtTime, rTuple.m_PartRef, pEventItem);
                        if (i < nParts &&
                            aFirstTimes[i].mtTime &&
                            rTuple.m_mtTime + rTuple.m_mtDuration >= aFirstTimes[i].mtTime)
                        {
                            int nDiff = rTuple.m_mtTime + rTuple.m_mtDuration - aFirstTimes[i].mtTime;
                            if (pEventItem && pEventItem->GetItemValue().m_pEvent)
                            {
                                switch (pEventItem->GetItemValue().m_pEvent->m_dwEventTag)
                                {
                                case DMUS_EVENT_NOTE:
                                    ((CDMStyleNote*)pEventItem->GetItemValue().m_pEvent)->m_mtDuration -= nDiff;
                                    break;
                                case DMUS_EVENT_CURVE:
                                    ((CDMStyleCurve*)pEventItem->GetItemValue().m_pEvent)->m_mtDuration -= nDiff;
                                    break;
                                }
                            }
                        }
                        rLastFragment.InsertEvent(i, pEventItem);
                    }
                }
            }
        }
        // NOTE:  Need to apply transformations (invert, reverse...) here.
        // I should also move the individual sorts out of the overlapped notes code,
        // and put it directly preceding the transformations.

    } while (mtNext != 0);

    // Clear this so the pointers it may reference aren't deleted twice.
    ZeroMemory( &CompRepeat, sizeof(CompRepeat));

    // Once pattern tracks are introduced, I need to change this to create a pattern track.
    // I should allow an option to create one or the other (?).
    if (SUCCEEDED(hr))
    {
        hr = CreatePatternTrack(listFragments,
                                pStyleStruct->m_TimeSignature,
                                pStyleStruct->m_dblTempo,
                                mtLength,
                                bPlaymode,
                                pNewTrack);
    }

    if (aFirstTimes) delete [] aFirstTimes;

    pDMStyle->Release();
    return hr;
}

TListItem<DMUS_IO_SEQ_ITEM>* ConvertToSequenceEvent(TListItem<EventWrapper>* pEventItem)
{
    TListItem<DMUS_IO_SEQ_ITEM>* pResult = new TListItem<DMUS_IO_SEQ_ITEM>;
    if (pResult)
    {
        DMUS_IO_SEQ_ITEM& rSeq = pResult->GetItemValue();
        EventWrapper& rEvent = pEventItem->GetItemValue();
        rSeq.bStatus = 0x90;  // MIDI note on (with channel nibble stripped out)
        rSeq.mtTime = rEvent.m_mtTime;
        rSeq.bByte1 = rEvent.m_bMIDI;
        rSeq.dwPChannel = rEvent.m_dwPChannel;
        rSeq.nOffset = rEvent.m_pEvent->m_nTimeOffset;
        if (rEvent.m_pEvent)
        {
            switch (rEvent.m_pEvent->m_dwEventTag)
            {
            case DMUS_EVENT_NOTE:
                rSeq.mtDuration = ((CDMStyleNote*)rEvent.m_pEvent)->m_mtDuration;
                rSeq.bByte2 = ((CDMStyleNote*)rEvent.m_pEvent)->m_bVelocity;
                break;
            case DMUS_EVENT_CURVE:
                rSeq.mtDuration = ((CDMStyleCurve*)rEvent.m_pEvent)->m_mtDuration;
                rSeq.bByte2 = 0;  // Actually, curves shouldn't end up as note events...
                break;
            }
        }
    }
    return pResult;
}

HRESULT CDMStyle::CreateSequenceTrack(TList<CompositionFragment>& rlistFragments,
                                IDirectMusicTrack*& pSequenceTrack)
{
    HRESULT hr = S_OK;

    TList<DMUS_IO_SEQ_ITEM> SeqList;

    // fold all the individual event lists into one list
    TListItem<CompositionFragment>* pFragmentItem = rlistFragments.GetHead();
    for (; pFragmentItem; pFragmentItem = pFragmentItem->GetNext())
    {
        CompositionFragment& rFragment = pFragmentItem->GetItemValue();
        int nParts = rFragment.m_pPattern->m_PartRefList.GetCount();
        for (int i = 0; i < nParts; i++)
        {
            while (!rFragment.IsEmptyEvents(i))
            {
                TListItem<EventWrapper>* pHead = rFragment.RemoveEventHead(i);
                SeqList.AddHead(ConvertToSequenceEvent(pHead));
            }
        }
    }

    // Sort the sequence items
    SeqList.MergeSort(Less);

    // Now, persist the sequence events into the Sequence track
    IPersistStream* pIPSTrack = NULL;
    if( SUCCEEDED( pSequenceTrack->QueryInterface( IID_IPersistStream, (void**)&pIPSTrack )))
    {
        // Create a stream in which to place the events so we can
        // give it to the SeqTrack.Load.
        IStream* pEventStream;
        if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
        {
            // Save the events into the stream
            TListItem<DMUS_IO_SEQ_ITEM>* pSeqItem = NULL;
            ULONG   cb, cbWritten;
            // Save the chunk id
            DWORD dwTemp = DMUS_FOURCC_SEQ_TRACK;
            pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
            // Save the overall size. Count the number of events to determine.
            DWORD dwSize = 0;
            for( pSeqItem = SeqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
            {
                dwSize++;
            }
            dwSize *= sizeof(DMUS_IO_SEQ_ITEM);
            // add 12 --- 8 for the subchunk header and overall size,
            // and 4 for the DMUS_IO_SEQ_ITEM size DWORD in the subchunk
            dwSize += 12;
            pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
            // Save the subchunk id
            dwTemp = DMUS_FOURCC_SEQ_LIST;
            pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
            // Subtract the previously added 8 (for subchunk header and overall size)
            dwSize -= 8;
            // Save the size of the subchunk (including the DMUS_IO_SEQ_ITEM size DWORD)
            pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
            // Save the structure size.
            dwTemp = sizeof(DMUS_IO_SEQ_ITEM);
            pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
            // Save the events.
            cb = sizeof(DMUS_IO_SEQ_ITEM);
            for( pSeqItem = SeqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rSeqItem = pSeqItem->GetItemValue();
                pEventStream->Write( &rSeqItem, cb, &cbWritten );
                if( cb != cbWritten ) // error!
                {
                    pEventStream->Release();
                    pEventStream = NULL;
                    hr = DMUS_E_CANNOTREAD;
                    break;
                }
            }
            if( pEventStream ) // may be NULL
            {
                StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
                pIPSTrack->Load( pEventStream );
                pEventStream->Release();
            }
        }
        pIPSTrack->Release();
    }

    return hr;
}

CDirectMusicEventItem* ConvertToPatternEvent(TListItem<EventWrapper>* pEventWrapper,
                                             DWORD dwID,
                                             BYTE bPlaymode,
                                             DirectMusicTimeSig& TimeSig)
{
    if (!pEventWrapper) return NULL;
    BYTE bEventPlaymode = pEventWrapper->GetItemValue().m_bPlaymode;
    if (bPlaymode == bEventPlaymode)
    {
        bEventPlaymode = DMUS_PLAYMODE_NONE;
    }
    CDirectMusicEventItem* pWrappedEvent = pEventWrapper->GetItemValue().m_pEvent;
    if (!pWrappedEvent) return NULL;
    MUSIC_TIME mtClocksPerGrid = TimeSig.ClocksPerGrid();
    short nGrid = 0;
    short nOffset = 0;
    if (mtClocksPerGrid)
    {
        nGrid = (short) (pEventWrapper->GetItemValue().m_mtTime / mtClocksPerGrid);
        nOffset = (short) (pWrappedEvent->m_nTimeOffset + pEventWrapper->GetItemValue().m_mtTime % mtClocksPerGrid);
    }
    DWORD dwVariations = 0xffffffff;
    BYTE bFlags = 0;
    if (pEventWrapper->GetItemValue().m_pEvent &&
        pEventWrapper->GetItemValue().m_pEvent->m_dwEventTag == DMUS_EVENT_NOTE)
    {
        bFlags = ((CDMStyleNote*)pEventWrapper->GetItemValue().m_pEvent)->m_bFlags;
    }
    return pWrappedEvent->ReviseEvent(nGrid, nOffset, &dwVariations, &dwID, &pEventWrapper->GetItemValue().m_wMusic, &bEventPlaymode, &bFlags);
}

HRESULT CDMStyle::CreatePatternTrack(TList<CompositionFragment>& rlistFragments,
                                     DirectMusicTimeSig& rTimeSig,
                                     double dblTempo,
                                     MUSIC_TIME mtLength,
                                     BYTE bPlaymode,
                                     IDirectMusicTrack*& pPatternTrack)
{
    HRESULT hr = S_OK;

    CDirectMusicPattern* pPattern = new CDirectMusicPattern(&rTimeSig);
    if (pPattern == NULL) return E_OUTOFMEMORY;

    pPattern->m_strName = "<Composed Pattern>";

    // fold all the individual event lists into corresponding parts in the pattern
    TListItem<CompositionFragment>* pFragmentItem = rlistFragments.GetHead();
    for (; pFragmentItem; pFragmentItem = pFragmentItem->GetNext())
    {
        CompositionFragment& rFragment = pFragmentItem->GetItemValue();
        TListItem<DirectMusicPartRef>* pPartRef = rFragment.m_pPattern->m_PartRefList.GetHead();
        int nParts = rFragment.m_pPattern->m_PartRefList.GetCount();
        for (int i = 0; i < nParts && pPartRef; i++, pPartRef = pPartRef->GetNext() )
        {
            DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
            TListItem<DirectMusicPartRef>* pNewPartRef = pPattern->CreatePart(rPartRef, bPlaymode);
            if (!pNewPartRef)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            DirectMusicPart* pPart = pNewPartRef->GetItemValue().m_pDMPart;
            if (!pPart)
            {
                hr = E_FAIL;
                break;
            }
            while (!rFragment.IsEmptyEvents(i))
            {
                TListItem<EventWrapper>* pHead = rFragment.RemoveEventHead(i);
                CDirectMusicEventItem* pNew = ConvertToPatternEvent(pHead, rFragment.GetID(), bPlaymode, rTimeSig);
                if (pNew)
                {
                    pPart->EventList.AddHead(pNew);
                }
                delete pHead;
            }
        }
        if (FAILED(hr)) break;
    }
    WORD wNumMeasures = 0;
    MUSIC_TIME mtClocksPerMeasure = rTimeSig.ClocksPerMeasure();
    if (mtClocksPerMeasure)
    {
        wNumMeasures = (WORD)(mtLength / mtClocksPerMeasure);
        if (mtLength % mtClocksPerMeasure)
        {
            wNumMeasures++;
        }
    }
    pPattern->m_wNumMeasures = wNumMeasures;
    pPattern->m_pRhythmMap = new DWORD[wNumMeasures];
    if (pPattern->m_pRhythmMap)
    {
        for (int i = 0; i < wNumMeasures; i++)
        {
            pPattern->m_pRhythmMap[i] = 0;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    if (SUCCEEDED(hr))
    {
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->m_PartRefList.GetHead();
        int nParts = pPattern->m_PartRefList.GetCount();
        // Sort the event lists for each part, and set the number of measures.
        for (int i = 0; i < nParts && pPartRef; i++, pPartRef = pPartRef->GetNext() )
        {
            DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
            if (pPart)
            {
                pPart->m_wNumMeasures = wNumMeasures;
                pPart->EventList.MergeSort(rTimeSig);
                // remove notes so close that they might as well be overlapping
                CDirectMusicEventItem* pThisEvent = pPart->EventList.GetHead();
                CDirectMusicEventItem* pLastEvent = NULL;
                for (; pThisEvent; pThisEvent = pThisEvent->GetNext())
                {
                    if (pThisEvent->m_dwEventTag == DMUS_EVENT_NOTE)
                    {
                        CDMStyleNote* pThisNote = (CDMStyleNote*)pThisEvent;
                        CDirectMusicEventItem* pNextEvent = pThisEvent->GetNext();
                        for (; pNextEvent; pNextEvent = pNextEvent->GetNext())
                        {
                            if (pNextEvent->m_dwEventTag == DMUS_EVENT_NOTE) break;
                        }
                        if (pNextEvent)
                        {
                            CDMStyleNote* pNextNote = (CDMStyleNote*)pNextEvent;
                            MUSIC_TIME mtThis = rTimeSig.GridToClocks(pThisNote->m_nGridStart) + pThisNote->m_nTimeOffset;
                            MUSIC_TIME mtNext = rTimeSig.GridToClocks(pNextNote->m_nGridStart) + pNextNote->m_nTimeOffset;
                            if ( (pNextNote->m_dwFragmentID != pThisNote->m_dwFragmentID) &&
                                 ((mtThis < mtNext && mtThis + OVERLAP_DELTA > mtNext) ||
                                  (mtThis > mtNext && mtThis + OVERLAP_DELTA < mtNext)) ) // could happen with negative offsets...
                            {
                                if (pLastEvent)
                                {
                                    pLastEvent->SetNext(pThisEvent->GetNext());
                                }
                                else // the note I want to remove is the first event
                                {
                                    pPart->EventList.RemoveHead();
                                }
                                pThisEvent->SetNext(NULL);
                                delete pThisEvent;
                                pThisEvent = pLastEvent;
                            }
                        }
                    }
                    pLastEvent = pThisEvent;
                }
            }
        }
        // Now, save the newly created pattern to a pattern track
        IPersistStream* pIPSTrack = NULL;
        IAARIFFStream* pIRiffStream;
        MMCKINFO ckMain;
        if( SUCCEEDED( pPatternTrack->QueryInterface( IID_IPersistStream, (void**)&pIPSTrack )))
        {
            // Create a stream in which to place the events so we can
            // give it to the PatternTrack.Load.
            IStream* pEventStream;
            if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
            {
                if( SUCCEEDED( AllocRIFFStream( pEventStream, &pIRiffStream ) ) )
                {
                    ckMain.fccType = DMUS_FOURCC_PATTERN_FORM;
                    if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0 )
                    {
                        MMCKINFO ckHeader;
                        ckHeader.ckid = DMUS_FOURCC_STYLE_CHUNK;
                        if( pIRiffStream->CreateChunk( &ckHeader, 0 ) != 0 )
                        {
                            hr = E_FAIL;
                        }
                        if (SUCCEEDED(hr))
                        {
                            // Prepare DMUS_IO_STYLE
                            DMUS_IO_STYLE oDMStyle;
                            DWORD dwBytesWritten = 0;
                            memset( &oDMStyle, 0, sizeof(DMUS_IO_STYLE) );
                            oDMStyle.timeSig.bBeatsPerMeasure = rTimeSig.m_bBeatsPerMeasure;
                            oDMStyle.timeSig.bBeat = rTimeSig.m_bBeat;
                            oDMStyle.timeSig.wGridsPerBeat = rTimeSig.m_wGridsPerBeat;
                            oDMStyle.dblTempo = dblTempo;
                            // Write chunk data
                            hr = pEventStream->Write( &oDMStyle, sizeof(DMUS_IO_STYLE), &dwBytesWritten);
                            if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLE) )
                            {
                                hr = E_FAIL;
                            }

                            if( SUCCEEDED(hr) && pIRiffStream->Ascend( &ckHeader, 0 ) != 0 )
                            {
                                hr = E_FAIL;
                            }
                        }

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pPattern->Save( pEventStream );
                            pPartRef = pPattern->m_PartRefList.GetHead();
                            for (; pPartRef; pPartRef = pPartRef->GetNext())
                            {
                                if (pPartRef->GetItemValue().m_pDMPart)
                                {
                                    delete pPartRef->GetItemValue().m_pDMPart;
                                    pPartRef->GetItemValue().m_pDMPart = NULL;
                                }
                            }
                            pPattern->CleanUp();
                            delete pPattern;
                            if ( SUCCEEDED( hr ) && pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                    pIRiffStream->Release();
                }
                if( SUCCEEDED(hr) )
                {
                    StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( pEventStream );
                }
                pEventStream->Release();
            }
            pIPSTrack->Release();
        }
    }

    if (hr == S_OK && !rlistFragments.GetHead()) hr = S_FALSE;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmstyle.h ===
// DMStyle.h : Declaration of the CDMStyle
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DMSTYLE_H_
#define __DMSTYLE_H_


#include "dmusici.h"

#include "sjdefs.h"
#include "iostru.h"
#include "AARiff.h"
#include "str.h"
#include "tlist.h"
#include "alist.h"
#include "dmstylep.h"
#include "filter.h"
#include "..\shared\dmusicp.h"

#include "timesig.h"

#include "debug.h"

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
// default chord is major 7
const DWORD DEFAULT_CHORD_PATTERN = 0x891;
const int MAX_VARIATION_LOCKS = 255;  // max number of variation lock ids

extern DirectMusicTimeSig DefaultTimeSig;

struct CompositionFragment;
struct StyleTrackState;

#define EMB_NORMAL	0
#define EMB_FILL	1
#define EMB_BREAK	2
#define EMB_INTRO	4
#define EMB_END		8
#define EMB_MOTIF	16
// User-defined embellishments live in the high byte of the embellishment word
#define EMB_USER_DEFINED	0xff00

// #defines to replace need for dynamic casts
#define DMUS_EVENT_NOTE				1
#define DMUS_EVENT_CURVE			2
#define DMUS_EVENT_MARKER			3
#define DMUS_EVENT_ANTICIPATION		4

// Curve flip flags
#define CURVE_FLIPTIME	1
#define CURVE_FLIPVALUE	2

#define STYLEF_USING_DX8 1

struct DirectMusicPart;
struct DirectMusicPartRef;
class CDMStyle;
struct DMStyleStruct;
struct CDirectMusicPattern;

struct CDirectMusicEventItem : public AListItem
{
//friend class CDirectMusicPattern;
//public:
	CDirectMusicEventItem* MergeSort(DirectMusicTimeSig& TimeSig); 
//protected:
	void Divide(CDirectMusicEventItem* &pHalf1, CDirectMusicEventItem* &pHalf2);
	CDirectMusicEventItem* Merge(CDirectMusicEventItem* pOtherList, DirectMusicTimeSig& TimeSig);
	CDirectMusicEventItem* GetNext() { return (CDirectMusicEventItem*) AListItem::GetNext(); }
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
										DWORD* pdwVariation = NULL, 
										DWORD* pdwID = NULL, 
										WORD* pwMusic = NULL, 
										BYTE* pbPlaymode = NULL,
                                        BYTE* pbFlags = NULL);

//protected:
	short		m_nGridStart;		// Grid position in track that this event belogs to.
	short		m_nTimeOffset;		// Offset, in music time, of event from designated grid position.
	DWORD		m_dwVariation;		// variation bits
	DWORD		m_dwEventTag;		// what type of event this is (note, curve, ...)
};

struct CDirectMusicEventList : public AList
{
//public:
	~CDirectMusicEventList();
    CDirectMusicEventItem *GetHead() { return (CDirectMusicEventItem *)AList::GetHead();};
    CDirectMusicEventItem *RemoveHead() { return (CDirectMusicEventItem *)AList::RemoveHead();};
	void MergeSort(DirectMusicTimeSig& TimeSig); // Destructively mergeSorts the list
};

struct CDMStyleNote : public CDirectMusicEventItem
{
//friend class CDirectMusicPattern;
//public:
	CDMStyleNote() : m_bPlayModeFlags(0), m_bFlags(0), m_dwFragmentID(0)
	{
		m_dwEventTag = DMUS_EVENT_NOTE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
									    DWORD* pdwVariation, 
										DWORD* pdwID, 
										WORD* pwMusic, 
										BYTE* pbPlaymode,
                                        BYTE* pbFlags);
//protected:
	MUSIC_TIME	m_mtDuration;		// how long this note lasts
    WORD		m_wMusicValue;		// Position in scale.
    BYTE		m_bVelocity;		// Note velocity.
    BYTE		m_bTimeRange;		// Range to randomize start time.
    BYTE		m_bDurRange;		// Range to randomize duration.
    BYTE		m_bVelRange;		// Range to randomize velocity.
	BYTE		m_bInversionId;		// Identifies inversion group to which this note belongs
	BYTE		m_bPlayModeFlags;	// can override part ref
	DWORD		m_dwFragmentID;		// for melody formulation, the fragment this note came from
	BYTE		m_bFlags;			// values from DMUS_NOTEF_FLAGS
};

struct CDMStyleCurve : public CDirectMusicEventItem
{
	CDMStyleCurve()
	{
		m_dwEventTag = DMUS_EVENT_CURVE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, short nOffset);
	MUSIC_TIME	m_mtDuration;	// how long this curve lasts
	MUSIC_TIME	m_mtResetDuration;	// how long after the end of the curve to reset it
	short		m_StartValue;	// curve's start value
	short		m_EndValue;		// curve's end value
	short		m_nResetValue;	// curve's reset value
    BYTE		m_bEventType;	// type of curve
	BYTE		m_bCurveShape;	// shape of curve
	BYTE		m_bCCData;		// CC#
	BYTE		m_bFlags;		// flags. Bit 1=TRUE means to send the reset value. Other bits reserved.
	WORD		m_wParamType;		// RPN or NRPN parameter number.
	WORD		m_wMergeIndex;		// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
};

struct CDMStyleMarker : public CDirectMusicEventItem
{
	CDMStyleMarker()
	{
		m_dwEventTag = DMUS_EVENT_MARKER;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
	WORD	m_wFlags;		// flags for how to interpret this marker.
};

struct CDMStyleAnticipation : public CDirectMusicEventItem
{
	CDMStyleAnticipation()
	{
		m_dwEventTag = DMUS_EVENT_ANTICIPATION;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
    BYTE		m_bTimeRange;		// Range to randomize start time.
};

struct Marker
{
	MUSIC_TIME	mtTime;
	WORD		wFlags;
};

struct DirectMusicPart
{
	DirectMusicPart(DirectMusicTimeSig *pTimeSig = NULL);
	~DirectMusicPart() { }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	HRESULT DM_LoadPart(  
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );
	HRESULT DM_SavePart( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveNoteList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveCurveList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveMarkerList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveAnticipationList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveResolutionList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern );
	HRESULT GetClosestTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord, MUSIC_TIME& rmtResult);
	bool IsMarkerAtTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord);
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern ); 

	long m_cRef;
	GUID							m_guidPartID;
	DirectMusicTimeSig				m_timeSig;			// can override pattern's
	WORD							m_wNumMeasures;		// length of the Part
	DWORD							m_dwVariationChoices[32];	// MOAW choices bitfield
	BYTE							m_bPlayModeFlags;	// see PLAYMODE flags (in ioDMStyle.h)
	BYTE							m_bInvertUpper;		// inversion upper limit
	BYTE							m_bInvertLower;		// inversion lower limit
	DWORD							m_dwFlags;   		// various flags
	CDirectMusicEventList			EventList;			// list of events (notes, curves, etc.)
	TList<Marker>					m_StartTimes[32];	// Array of start time lists (1 per variation)
	TList<DMUS_IO_STYLERESOLUTION>	m_ResolutionList;	// list of variation resolutions
};

struct InversionGroup 
{
	// Inversion groups are used for keeping track of groups of notes to be played
	// without inversion
	WORD		m_wGroupID;	// Group this represents.
	WORD		m_wCount;	// How many are in the group, still waiting to be played.
	short		m_nOffset;	// Number to add to all notes for offsetting.
};

const short INVERSIONGROUPLIMIT = 16;

short FindGroup(InversionGroup aGroup[], WORD wID);
short AddGroup(InversionGroup aGroup[], WORD wID, WORD wCount, short m_nOffset);

struct PatternTrackState;

struct DirectMusicPartRef
{
	DirectMusicPartRef() : 
		m_bPriority(100), 
		m_pDMPart(NULL), 
		m_bVariationLockID(0), 
		//m_wLogicalPartID(LOGICAL_PART_PIANO),
		m_bSubChordLevel(SUBCHORD_STANDARD_CHORD)
	{  }
	~DirectMusicPartRef() { if (m_pDMPart) m_pDMPart->Release(); }
	HRESULT DM_LoadPartRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle);
	HRESULT DM_SavePartRef( IAARIFFStream* pIRiffStream );
	void SetPart( DirectMusicPart* pPart );

	HRESULT ConvertMusicValue(CDMStyleNote* pNoteEvent, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlaymode,
							  BOOL fPlayAsIs,
							  InversionGroup aInversionGroups[],
							  IDirectMusicPerformance* pPerformance,
							  BYTE& rbMidiValue,
							  short& rnMidiOffset);
	HRESULT ConvertMIDIValue(BYTE bMIDI, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlayModeFlags,
							  IDirectMusicPerformance* pPerformance,
							  WORD& rwMusicValue);

	DirectMusicPart* m_pDMPart; // the Part to which this refers
	DWORD	m_dwLogicalPartID;	// corresponds to port/device/midi channel
	BYTE	m_bVariationLockID; // parts with the same ID lock variations.
								// high bit is used to identify master Part
	BYTE	m_bSubChordLevel;	// tells which sub chord level this part wants
	BYTE	m_bPriority;		// Priority levels. Parts with lower priority
								// aren't played first when a device runs out of
								// notes
	BYTE	m_bRandomVariation;		// Determines order in which variations are played.
};

#define COMPUTE_VARIATIONSF_USE_MASK	0x1
#define COMPUTE_VARIATIONSF_NEW_PATTERN	0x2
#define COMPUTE_VARIATIONSF_CHORD_ALIGN	0x4
#define COMPUTE_VARIATIONSF_MARKER		0x8
#define COMPUTE_VARIATIONSF_START		0x10
#define COMPUTE_VARIATIONSF_DX8			0x20
#define COMPUTE_VARIATIONSF_CHANGED		0x40

struct CDirectMusicPattern
{
friend class CDMStyle;
//public:
	CDirectMusicPattern( DirectMusicTimeSig* pTimeSig = NULL, BOOL fMotif = FALSE );
	~CDirectMusicPattern() { CleanUp(); }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	CDirectMusicPattern* Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, BOOL fMotif);
	void CleanUp();
	HRESULT DM_LoadPattern(
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );

	HRESULT LoadPattern(
		IAARIFFStream* pRIFF, 
		MMCKINFO* pckMain,
		TList<DirectMusicPart*> &partList,
		DMStyleStruct& rStyleStruct
	);
	HRESULT AllocPartRef(TListItem<DirectMusicPartRef>*& rpPartRefItem);
	void DeletePartRef(TListItem<DirectMusicPartRef>* pPartRefItem);
	void DMusMoawFlags(MUSIC_TIME mtTime, 
					   MUSIC_TIME mtNextChord,
					   DMUS_CHORD_PARAM& rCurrentChord, 
					   DMUS_CHORD_PARAM& rNextChord,
					   bool fIsDX8,
					   DWORD& dwNaturals,
					   DWORD& dwSharps,
					   DWORD& dwFlats);
	DWORD IMA25MoawFlags(MUSIC_TIME mtTime, 
						 MUSIC_TIME mtNextChord,
						 DMUS_CHORD_PARAM& rCurrentChord,
						 DMUS_CHORD_PARAM& rNextChord);
	HRESULT ComputeVariations(DWORD dwFlags,
							  DMUS_CHORD_PARAM& rCurrentChord, 
							  DMUS_CHORD_PARAM& rNextChord,
							  BYTE abVariationGroups[],
							  DWORD adwVariationMask[],
							  DWORD adwRemoveVariations[],
							  BYTE abVariation[],
							  MUSIC_TIME mtTime,
							  MUSIC_TIME mtNextChord,
							  PatternTrackState* pState = NULL);
	HRESULT ComputeVariationGroup(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	HRESULT ComputeVariation(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	BOOL MatchCommand(DMUS_COMMAND_PARAM_2 pCommands[], short nLength);
	void MatchRhythm(DWORD pRhythms[], short nPatternLength, short& nBits);
	BOOL MatchGrooveLevel(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchEmbellishment(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchNextCommand(DMUS_COMMAND_PARAM_2& rNextCommand);

	HRESULT LoadEvents(IAARIFFStream* pRIFF, MMCKINFO* pckMain);
	HRESULT LoadNoteList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	HRESULT LoadCurveList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	DirectMusicPart* FindPart(BYTE bChannelID);
	TListItem<DirectMusicPartRef>* FindPartRefByPChannel(DWORD dwPChannel);
	TListItem<DirectMusicPartRef>* CreatePart( DirectMusicPartRef& rPartRef, BYTE bPlaymode, WORD wMeasures = 1 );
	HRESULT Save( IStream* pIStream );
	HRESULT DM_SaveSinglePattern( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternChunk( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternRhythm( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternInfoList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle );
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle ); 

    long				m_cRef;
	String				m_strName;			// pattern name
	DirectMusicTimeSig	m_timeSig;			// Patterns can override the Style's Time sig.
	WORD				m_wID;				// ID to identify for pattern playback (instead of name)
	BYTE				m_bGrooveBottom;	// bottom of groove range
	BYTE				m_bGrooveTop;		// top of groove range
	BYTE				m_bDestGrooveBottom;	// bottom of groove range for next pattern
	BYTE				m_bDestGrooveTop;		// top of groove range for next pattern
	WORD				m_wEmbellishment;	// Fill, Break, Intro, End, Normal, Motif
	WORD				m_wNumMeasures;		// length in measures
	DWORD*				m_pRhythmMap;		// variable array of rhythms for chord matching
	TList<DirectMusicPartRef> m_PartRefList;	// list of part references
	//////// motif settings:
	BOOL		m_fSettings;	  // Have these been set?
	DWORD       m_dwRepeats;      // Number of repeats. By default, 0.
    MUSIC_TIME  m_mtPlayStart;    // Start of playback. By default, 0.
    MUSIC_TIME  m_mtLoopStart;    // Start of looping portion. By default, 0.
    MUSIC_TIME  m_mtLoopEnd;      // End of loop. Must be greater than dwPlayStart. By default equal to length of motif.
    DWORD       m_dwResolution;   // Default resolution.
	//////// motif band:
	IDirectMusicBand*	m_pMotifBand;
	TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this pattern
	DWORD		m_dwFlags;		// various flags 
};

HRESULT AdjoinPChannel(TList<DWORD>& rPChannelList, DWORD dwPChannel);

struct DMStyleStruct
{
	DirectMusicPart* AllocPart(  );
	void DeletePart( DirectMusicPart* pPart );

	HRESULT GetCommand(
		MUSIC_TIME mtTime, 
		MUSIC_TIME mtOffset, 
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		DWORD dwGroupID,
		DMUS_COMMAND_PARAM_2* pCommand,
		BYTE& rbActualCommand);

	DirectMusicPart* FindPartByGUID( GUID guidPartID );
	DirectMusicTimeSig& TimeSignature() { return m_TimeSignature; }
	bool UsingDX8() { return (m_dwFlags & STYLEF_USING_DX8) ? true : false; }

	CDirectMusicPattern* SelectPattern(bool fNewMode, 
								   DMUS_COMMAND_PARAM_2* pCommands, 
								   StyleTrackState* StyleTrackState, 
								   PatternDispatcher& rDispatcher);

	HRESULT GetPattern(
		bool fNewMode,
		MUSIC_TIME mtNow, 
		MUSIC_TIME mtOffset, 
		StyleTrackState* pStyleTrackState,
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		CDirectMusicPattern*& rpTargetPattern,
		MUSIC_TIME& rmtMeasureTime, 
		MUSIC_TIME& rmtNextCommand);


	bool				m_fLoaded;				// is the style loaded in memory?
    GUID				m_guid;					// the style's GUID
    String				m_strCategory;			// Describes musical category of style
	String				m_strName;				// style name
	DWORD				m_dwVersionMS;			// Version # high-order 32 bits
	DWORD				m_dwVersionLS;			// Version # low-order 32 bits
	DirectMusicTimeSig	m_TimeSignature;		// The style's time signature
	double				m_dblTempo;				// The style's tempo
	TList<DirectMusicPart*> m_PartList;			// Parts used by the style
	TList<CDirectMusicPattern*> m_PatternList;	// Patterns used by the style
	TList<CDirectMusicPattern*> m_MotifList;		// Motifs used by the style
	TList<IDirectMusicBand *>  m_BandList;		// Bands used by the style
	IDirectMusicBand*		   m_pDefaultBand;   // Default band for style
	TList<IDirectMusicChordMap *>  m_PersList;		// Personalities used by the style
	IDirectMusicChordMap*		  m_pDefaultPers;   // Default Personality for style
	TList<DWORD>  m_PChannelList;		// PChannels used by the style
	DWORD				m_dwFlags;			// various flags
	//TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this style
};

/*
@interface IDirectMusicStyle | 
The <i IDirectMusicStyle> interface provides access to a Style object. 
The Style provides the Interactive Music Engine with the information it needs to perform 
a style of music (hence the name.) 
The application can also access information about the style, including the name, 
time signature, and recommended tempo.
Since styles usually include sets of Personalities, Bands, and Motifs, the <i IDirectMusicStyle> interface 
also provides functions for accessing them.

It also supports the <i IPersistStream> and <i IDirectMusicObject> interfaces for loading 
its data.


@base public | IUnknown

@meth HRESULT | EnumMotif | Returns the name of a motif, by location, from a Style's list of motifs.
@meth HRESULT | GetMotif | Returns a motif, by name, from a Style's list of motifs.
@meth HRESULT | EnumBand |  Returns the name of a band, by location, from a Style's list of bands.
@meth HRESULT | GetBand | Returns a band, by name, from a Style's list of bands. 
@meth HRESULT | GetDefaultBand | Returns a Style's default band. 
@meth HRESULT | EnumChordMap | Returns the name of a ChordMap, by location, from a Style's list of personalities.
@meth HRESULT | GetChordMap | Returns a ChordMap, by name, from a Style's list of personalities. 
@meth HRESULT | GetDefaultChordMap | Returns a Style's default ChordMap.  
@meth HRESULT | GetTimeSignature | Returns the time signature of a Style.
@meth HRESULT | GetEmbellishmentLength | Determines the length of a particular embellishment
in a Style. 
@meth HRESULT | GetTempo | Returns the recommended tempo of a Style. 

*/

/////////////////////////////////////////////////////////////////////////////
// CDMStyle
class CDMStyle : 
	public IDMStyle,
	public IDirectMusicStyle8,
	public IDirectMusicStyle8P,
	public IDirectMusicObject,
	public IPersistStream
{
public:
    CDMStyle();
    ~CDMStyle();
	HRESULT CreateMotifSegment(CDirectMusicPattern* pPattern, IUnknown * * ppSegment,
		DWORD dwRepeats);

// IDMStyle
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicStyle methods
	// Returns: S_OK if the index refers to a motif; S_FALSE if it doesn't
	HRESULT STDMETHODCALLTYPE EnumMotif(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);
	HRESULT STDMETHODCALLTYPE GetMotif(
		/*in*/	WCHAR* pwszName,			// name of the motif for a secondary segment
		/*out*/	IDirectMusicSegment** ppSegment
	);
	HRESULT STDMETHODCALLTYPE GetBand(
		/*in*/	WCHAR* pwszName,
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE EnumBand(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultBand(
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE GetChordMap(
		/*in*/	WCHAR* pwszName,
		/*out*/	IDirectMusicChordMap** ppChordMap	
	);

	HRESULT STDMETHODCALLTYPE EnumChordMap(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultChordMap(
		/*out*/	IDirectMusicChordMap **ppChordMap
	);

	HRESULT STDMETHODCALLTYPE GetTimeSignature(
		/*out*/	DMUS_TIMESIGNATURE* pTimeSig			
	);

	HRESULT STDMETHODCALLTYPE GetEmbellishmentLength(
		/*in*/	DWORD dwType,			
		/*in*/	DWORD dwLevel,			
		/*out*/	DWORD* pdwMin,			
		/*out*/	DWORD* pdwMax
	);

	HRESULT STDMETHODCALLTYPE GetTempo(double* pTempo);

	// IDirectMusicStyle8 methods
	HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle*			pStyle,
		IDirectMusicSegment*		pTempSeg,
		IDirectMusicSegment**		ppSeqSeg
	);

	HRESULT STDMETHODCALLTYPE EnumPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*in*/  DWORD dwPatternType,	// type of pattern
		/*out*/	WCHAR *wszName			// name of the indexed motif
	);

	// IDirectMusicObject methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;

	/* IPersist methods */
    // Retrieves the Style's Class ID.
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

    /* IPersistStream methods */
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

	// IDMStyle
	HRESULT STDMETHODCALLTYPE GetPatternStream(WCHAR* wszName, DWORD dwPatternType, IStream** ppStream);
	HRESULT STDMETHODCALLTYPE GetStyleInfo(void **pData);
	HRESULT STDMETHODCALLTYPE IsDX8();
	HRESULT STDMETHODCALLTYPE CritSec(bool fEnter);
	HRESULT STDMETHODCALLTYPE EnumPartGuid(
		DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid);
	HRESULT STDMETHODCALLTYPE GenerateTrack(//IDirectMusicTrack* pChordTrack,
								IDirectMusicSegment* pTempSeg,
								IDirectMusicSong* pSong,
								DWORD dwTrackGroup,
								IDirectMusicStyle* pStyle,
								IDirectMusicTrack* pMelGenTrack,
								MUSIC_TIME mtLength,
								IDirectMusicTrack*& pNewTrack);


protected: /* methods */
    void CleanUp();
	HRESULT DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  );
	HRESULT IMA25_LoadPersonalityReference( IStream* pStream, MMCKINFO* pck );
    HRESULT IMA25_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT DM_LoadPersonalityReference( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent);
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  BOOL fDefault);
	HRESULT IncorporatePersonality( IDirectMusicChordMap* pPers, String strName, BOOL fDefault );
    HRESULT DM_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwTrackGroup, IDirectMusicStyle*& rpStyle);
	HRESULT CopySegment(IDirectMusicSegment* pTempSeg,
						IDirectMusicStyle* pStyle,
						IDirectMusicTrack* pSequenceTrack,
						DWORD dwTrackGroup,
						IDirectMusicSegment** ppSectionSeg);

	HRESULT CreateSequenceTrack(TList<CompositionFragment>& rlistFragments,
								IDirectMusicTrack*& pSequenceTrack);

	HRESULT CreatePatternTrack(TList<CompositionFragment>& rlistFragments,
								DirectMusicTimeSig& rTimeSig,
								double dblTempo,
								MUSIC_TIME mtLength,
								BYTE bPlaymode,
								IDirectMusicTrack*& pPatternTrack);

	HRESULT STDMETHODCALLTYPE EnumRegularPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);

	HRESULT STDMETHODCALLTYPE EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime);

protected: /* attributes */
    long m_cRef;
	BOOL				m_fDirty;				// has the style been modified?
    CRITICAL_SECTION	m_CriticalSection;		// for i/o
    BOOL                m_fCSInitialized;
	DMStyleStruct		m_StyleInfo;			// The details of the style
	InversionGroup		m_aInversionGroups[INVERSIONGROUPLIMIT]; // Inversion Groups for composing melodies
};

#endif //__DMSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\filter.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       filter.h
//
//--------------------------------------------------------------------------

//
// filter.h
//
#ifndef __FILTER_H__
#define __FILTER_H__

struct CDirectMusicPattern;
struct StyleTrackState;
struct DMStyleStruct;

enum enumPatternFilter
{
	DISPATCH_RESET				= 0,
	MATCH_COMMAND_AND_RHYTHM	= 1,
	MATCH_COMMAND_FULL			= 2,
	MATCH_COMMAND_PARTIAL		= 3,
	MATCH_EMBELLISHMENT			= 4,
	MATCH_GROOVE_LEVEL			= 5,
	MATCH_RHYTHM_BITS			= 6,
	MATCH_NEXT_COMMAND			= 7,
	FIND_LONGEST_PATTERN		= 8,
	FIND_LONGEST_TIMESIG		= 9,
	COLLECT_LONGEST_PATTERN		= 10,
	COLLECT_LONGEST_TIMESIG		= 11,
	RANDOM_ROW					= 12,
	REMOVED						= 0xffffffff
};

struct TaggedPattern
{
	CDirectMusicPattern* pPattern;
	DWORD dwTag;
};

struct PatternDispatcher
{
	PatternDispatcher() :
		m_aPatterns(NULL),
		m_fIsEmpty(false),
		m_nPatternCount(0),
		m_pRhythms(NULL),
		m_pCommands(NULL),
		m_nPatternLength(0),
		m_nNextCommand(0),
		m_mtNextCommand(0),
		m_mtNow(0),
		m_mtOffset(0),
		m_mtMeasureTime(0),
		m_pStyleTrackState(NULL),
		m_pPerformance(NULL),
		m_pStyle(NULL),
		m_nWinBits(0),
		m_MaxBars(0), m_MaxNum(0), m_MaxDenom(0)
	{}

	PatternDispatcher(
		TList<CDirectMusicPattern*>& InList,
		MUSIC_TIME mtNextCommand, 
		MUSIC_TIME mtNow, 
		MUSIC_TIME mtOffset, 
		StyleTrackState* pStyleTrackState,
		IDirectMusicPerformance* pPerformance,
		DMStyleStruct* pStyle) :
		m_aPatterns(NULL),
		m_fIsEmpty(false),
		m_nPatternCount(0),
		m_pRhythms(NULL),
		m_pCommands(NULL),
		m_nPatternLength(0),
		m_mtNextCommand(mtNextCommand),
		m_nNextCommand(0),
		m_mtNow(mtNow),
		m_mtOffset(mtOffset),
		m_mtMeasureTime(0),
		m_pStyleTrackState(pStyleTrackState),
		m_pPerformance(pPerformance),
		m_pStyle(pStyle),
		m_nWinBits(0),
		m_MaxBars(0), m_MaxNum(0), m_MaxDenom(0)
	{
		m_nPatternCount = InList.GetCount();
		if (m_nPatternCount)
		{
			m_aPatterns = new TaggedPattern [m_nPatternCount];
		}
		if (m_aPatterns)
		{
			TListItem<CDirectMusicPattern*>* pScan = InList.GetHead();
			for (int i = 0; pScan && i < m_nPatternCount; pScan = pScan->GetNext(), i++)
			{
				m_aPatterns[i].pPattern = pScan->GetItemValue();
				m_aPatterns[i].dwTag = 0;
			}
		}
		else
		{
			m_nPatternCount = 0;
		}
	}

	~PatternDispatcher()
	{
		if (m_aPatterns) delete [] m_aPatterns;
	}

	bool IsEmpty()
	{
		if (m_fIsEmpty) return true;
		bool fResult = true;
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (!m_aPatterns[i].dwTag)
			{
				fResult = false;
				break;
			}
		}
		if (fResult) m_fIsEmpty = true;
		return fResult;
	}

	HRESULT RestoreAllPatterns()
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			m_aPatterns[i].dwTag = 0;
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT RestorePatterns(DWORD dwType)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (dwType == m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = 0;
			}
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT SetTag(int nIndex, DWORD dwType)
	{
		if (nIndex < m_nPatternCount)
		{
			m_aPatterns[nIndex].dwTag = dwType;
		}
		if (!dwType) m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT ReplacePatterns(DWORD dwType, DWORD dwRemoveType)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (dwType == m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = 0;
			}
			else if (!m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = dwRemoveType;
			}
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	CDirectMusicPattern* GetItem(int n)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (!m_aPatterns[i].dwTag)
			{
				if (n == 0) break;
				n--;
			}
		}
		if (i >= m_nPatternCount || m_aPatterns[i].dwTag) return NULL;
		return m_aPatterns[i].pPattern;
	}

	HRESULT Filter(DWORD dwType);

	HRESULT Scan(DWORD dwType);

	bool Test(CDirectMusicPattern*& rValue, DWORD dwType);

	CDirectMusicPattern* RandomSelect();

	HRESULT FindPattern(CDirectMusicPattern* pSearchPattern, int& rResult);

	void ResetRhythms()
	{
		m_nWinBits = 0;
	}

	void ResetMeasures()
	{
		m_MaxBars = 0;
	}

	void ResetTimeSig()
	{
		m_MaxNum = 0;
		m_MaxDenom = 0;
	}

	void SetPatternLength(int nPatternLength)
	{
		m_nPatternLength = nPatternLength;
	}

	void SetMeasureTime(MUSIC_TIME mtMeasureTime);

	void SetCommands(DMUS_COMMAND_PARAM_2* pCommands, DWORD* pRhythms)
	{
		m_pRhythms = pRhythms;
		m_pCommands = pCommands;
	}


	TaggedPattern* m_aPatterns;
	int m_nPatternCount;
	bool m_fIsEmpty;
	DWORD* m_pRhythms;
	DMUS_COMMAND_PARAM_2* m_pCommands;
	int m_nNextCommand;
	MUSIC_TIME m_mtNextCommand;
	MUSIC_TIME m_mtNow;
	MUSIC_TIME m_mtOffset;
	MUSIC_TIME m_mtMeasureTime;
	DMStyleStruct* m_pStyle;
	StyleTrackState* m_pStyleTrackState;
	IDirectMusicPerformance* m_pPerformance;
	int m_nPatternLength;
	int m_nWinBits;
	int m_MaxBars;
	int m_MaxNum;
	int m_MaxDenom;
};

#endif // __FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\dmstylep.h ===
//
// DMStyleP.H
//
// Private include for DMStyle.DLL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//

#ifndef _DMSTYLEP_
#define _DMSTYLEP_

#include "dmusicf.h"

#define SUBCHORD_BASS				0
#define SUBCHORD_STANDARD_CHORD		1

extern long g_cComponent;

// Class factory
//
class CDirectMusicStyleFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicStyleFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicStyleFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicSectionFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicSectionFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicSectionFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicStyleTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicStyleTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicStyleTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicCommandTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicCommandTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicCommandTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicChordTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicChordTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicChordTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMotifTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMotifTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicMotifTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMuteTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMuteTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicMuteTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicAuditionTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicAuditionTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicAuditionTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMelodyFormulationTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMelodyFormulationTrackFactory() : m_cRef(1) {}

private:
    long m_cRef;
};

// private interfaces
interface IDMSection : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE GetStyle(IUnknown** ppStyle)=0;
};

interface IStyleTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle)=0;

	virtual HRESULT STDMETHODCALLTYPE GetStyle(IUnknown **ppStyle)=0;
};

interface IDMStyle : IUnknown
{
//	virtual HRESULT STDMETHODCALLTYPE GetPatternName (DWORD dwIndex, WCHAR *wszName)=0;
	virtual HRESULT STDMETHODCALLTYPE EnumPartGuid(
		DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid)=0;
	virtual HRESULT STDMETHODCALLTYPE GetPatternStream(
		WCHAR* wszName, DWORD dwPatternType, IStream** ppStream)=0;
	virtual HRESULT STDMETHODCALLTYPE GetStyleInfo(void **pData)=0;
	virtual HRESULT STDMETHODCALLTYPE IsDX8()=0;
	virtual HRESULT STDMETHODCALLTYPE CritSec(bool fEnter)=0;
	virtual HRESULT STDMETHODCALLTYPE EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime)=0;
	virtual HRESULT STDMETHODCALLTYPE GenerateTrack(
								IDirectMusicSegment* pTempSeg,
								IDirectMusicSong* pSong,
								DWORD dwTrackGroup,
								IDirectMusicStyle* pStyle,
								IDirectMusicTrack* pMelGenTrack,
								MUSIC_TIME mtLength,
								IDirectMusicTrack*& pNewTrack)=0;
	// this will go into dmusici.h when melody formulation is made public
/*	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle,
		IDirectMusicSegment* pTemplate,
		IDirectMusicSegment** ppSegment) = 0;*/
    /* Interface needs to look like this in dmusici.h
	STDMETHOD(ComposeMelodyFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   IDirectMusicSegment** ppSegment) PURE;
	*/
};

interface IMotifTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle, void* pPattern)=0;
};

interface IPrivatePatternTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetPattern(
		IDirectMusicSegmentState* pSegState,
		IStream* pStream,
		DWORD* pdwLength)=0;
    virtual HRESULT STDMETHODCALLTYPE SetVariationByGUID(
		IDirectMusicSegmentState* pSegState,
		DWORD dwVariationFlags,
		REFGUID rguidPart,
		DWORD dwPChannel)=0;
};

///////////////////////////////////////////////////////////////////////////////////////

/*
#define IAuditionTrack IDirectMusicPatternTrack

#define IID_IAuditionTrack IID_IDirectMusicPatternTrack
*/

DEFINE_GUID( IID_IAuditionTrack, 
			 0x9dc278c0, 0x9cb0, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c );

interface IAuditionTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(
		IDirectMusicStyle* pStyle, IDirectMusicSegment** ppSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE SetPattern(
		IDirectMusicSegmentState* pSegState, IStream* pStream, DWORD* pdwLength)=0;
	virtual HRESULT STDMETHODCALLTYPE SetVariation(
		IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, WORD wPart)=0;
};

#define CLSID_DirectMusicAuditionTrack CLSID_DirectMusicPatternTrack

#define DMUS_PCHANNEL_MUTE 0xffffffff

// the following constants represent time in 100 nanosecond increments

#define REF_PER_MIL		10000		// For converting from reference time to mils 
#define MARGIN_MIN		(100 * REF_PER_MIL) // 
#define MARGIN_MAX		(400 * REF_PER_MIL) // 
#define PREPARE_TIME	(m_dwPrepareTime * REF_PER_MIL)	// Time
#define NEARTIME		(100 * REF_PER_MIL)
#define NEARMARGIN      (REALTIME_RES * REF_PER_MIL)


// private CLSIDs and IIDs

DEFINE_GUID(IID_IDMSection,
	0x3F037240,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IStyleTrack,
	0x3F037246,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IDMStyle,
	0x4D7F3661,0x43D6,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IMotifTrack,
	0x7AE499C1,0x51FE,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IMuteTrack, 
	0xbc242fc1, 0xad1d, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);
DEFINE_GUID(IID_IPrivatePatternTrack, 
	0x7a8e9c33, 0x5901, 0x4f20, 0x92, 0xde, 0x3a, 0x5b, 0x3e, 0x33, 0xe2, 0x14);

DEFINE_GUID(CLSID_DMSection,
	0x3F037241,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);

// GUID and param struct for private version of GetParam (get style Time Signature,
// getting commands and chords from current segment)

struct SegmentTimeSig
{
    IDirectMusicSegment* pSegment;  // Segment passed in
    DMUS_TIMESIGNATURE  TimeSig;    // Time sig returned
};

DEFINE_GUID(GUID_SegmentTimeSig, 0x76612507, 0x4f37, 0x4b35, 0x80, 0x92, 0x50, 0x48, 0x4e, 0xd4, 0xba, 0x92);

// Private melody fragment stuff

// Used to get a repeated melody fragment
DEFINE_GUID(GUID_MelodyFragmentRepeat, 0x8cc92764, 0xf81c, 0x11d2, 0x81, 0x45, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

// This is obslolete and should not be public
#define DMUS_FOURCC_MELODYGEN_TRACK_CHUNK     mmioFOURCC( 'm', 'g', 'e', 'n' )

/*
// This is obslolete and should not be public
    // <mgen-ck>
    'mgen'
    (
        //sizeof DMUS_IO_MELODY_FRAGMENT: DWORD
        <DMUS_IO_MELODY_FRAGMENT>...
    )
*/

// GUID for private chord notifications
DEFINE_GUID(GUID_NOTIFICATION_PRIVATE_CHORD, 0xf5c19571, 0x7e1e, 0x4fff, 0xb9, 0x49, 0x7f, 0x74, 0xa6, 0x6f, 0xdf, 0xc0);

// (Private) Guid for getting a style from a pattern track
DEFINE_GUID(GUID_IDirectMusicPatternStyle, 0x689821f4, 0xb3bc, 0x44dd, 0x80, 0xd4, 0xc, 0xf3, 0x2f, 0xe4, 0xd2, 0x1b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\iostru.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       iostru.h
//
//--------------------------------------------------------------------------

// ioStructs.h
//

#ifndef __IOSTRUCTS_H__
#define __IOSTRUCTS_H__

#pragma pack(2)

#define FOURCC_BAND_FORM        mmioFOURCC('A','A','B','N')
#define FOURCC_CLICK_LIST       mmioFOURCC('A','A','C','L')
#define FOURCC_KEYBOARD_FORM    mmioFOURCC('S','J','K','B')
#define FOURCC_PATTERN_FORM     mmioFOURCC('A','A','P','T')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')
#define FOURCC_SONG_FORM        mmioFOURCC('A','A','S','O')
#define FOURCC_STYLE_FORM       mmioFOURCC('A','A','S','Y')

#define FOURCC_AUTHOR           mmioFOURCC('a','u','t','h')
#define FOURCC_BAND             mmioFOURCC('b','a','n','d')
#define FOURCC_CHORD            mmioFOURCC('c','h','r','d')
#define FOURCC_CLICK            mmioFOURCC('c','l','i','k')
#define FOURCC_COMMAND          mmioFOURCC('c','m','n','d')
#define FOURCC_COPYRIGHT        mmioFOURCC('c','p','y','r')
#define FOURCC_CURVE            mmioFOURCC('c','u','r','v')
#define FOURCC_KEYBOARD         mmioFOURCC('k','y','b','d')
#define FOURCC_LYRIC            mmioFOURCC('l','y','r','c')
#define FOURCC_MUTE             mmioFOURCC('m','u','t','e')
#define FOURCC_NOTE             mmioFOURCC('n','o','t','e')
#define FOURCC_PATTERN          mmioFOURCC('p','a','t','t')
#define FOURCC_PERSONALITYNAME  mmioFOURCC('p','r','n','m')
#define FOURCC_PERSONALITYREF   mmioFOURCC('p','r','e','f')
#define FOURCC_PHRASE           mmioFOURCC('p','h','r','s')
#define FOURCC_PPQN             mmioFOURCC('p','p','q','n')
#define FOURCC_SECTION          mmioFOURCC('s','e','c','n')
#define FOURCC_SECTIONUI        mmioFOURCC('s','c','u','i')
#define FOURCC_STYLE            mmioFOURCC('s','t','y','l')
#define FOURCC_STYLEINFO        mmioFOURCC('i','n','f','o')
#define FOURCC_STYLEREF         mmioFOURCC('s','r','e','f')
#define FOURCC_TITLE            mmioFOURCC('t','i','t','l')

typedef struct ioNoteEvent
{
    long    lTime;           // When this event occurs.
    BYTE    bStatus;         // MIDI status.
    BYTE    bNote;           // Note value.
    BYTE    bVelocity;       // Note velocity.
    BYTE    bVoiceID;        // Band member who will play note
    WORD    wDuration;       // Lead line note duration. (Song)
    BYTE    bEventType;      // Type of event
} ioNoteEvent;

typedef struct ioNote
{
    BYTE    bEventType;           // Type of event
    BYTE    bVoiceID;             // Instrument identifier.
    short   nTime;                // Time from center of beat.
    WORD    wVariation;           // 16 variation bits.
    BYTE    bScaleValue;          // Position in scale.
    BYTE    bBits;                // Various bits.
    BYTE    bValue;               // Note value.
    BYTE    bVelocity;            // Note velocity.
    WORD    nMusicValue;  // Description of note in chord and key.
    short   nDuration;            // Duration
    BYTE    bTimeRange;           // Range to randomize time.
    BYTE    bDurRange;            // Range to randomize duration.
    BYTE    bVelRange;            // Range to randomize velocity.
    BYTE    bPlayMode;
} ioNote;

typedef struct ioCurveEvent
{
    long    lTime;
    WORD    wVariation;
    BYTE    bVoiceID;
    BYTE    bVelocity;
    BYTE    bEventType;
} ioCurveEvent;

typedef struct ioCurve
{
    BYTE    bEventType;
    BYTE    bVoiceID;
    short   nTime;
    WORD    wVariation;
    BYTE    bCCData;
} ioCurve;

typedef struct ioSubCurve
{
    BYTE    bCurveType; // defines the shape of the curve
    char    fFlipped;  // flaggs defining the flipped state: not, vertical, or horizontal
    short   nMinTime;   // left lower corner of bounding box.
    short   nMinValue;  // also used by the ECT_INSTANT curve type.
    short   nMaxTime;   // right upper corner of bounding box.
    short   nMaxValue;
} ioSubCurve;

typedef struct ioMute
{
    long    lTime;           // Time in clocks.
    WORD    wMuteBits;       // Which instruments to mute.
    WORD    wLock;          // Lock flag
} ioMute;

typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;

typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;         // root note of chord
    BYTE    bReserved;     // expansion room
    WORD    wCFlags;        // bit flags
	long	lReserved;		// expansion room
} ioChord;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
};

typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;

#define KEY_FLAT 0x80
typedef struct ioSect
{
    long    lTime;           // Time this section starts.
    wchar_t wstrName[16];       // Each section has a name.
    WORD    wTempo;             // Tempo.
    WORD    wRepeats;           // Number of repeats.
    WORD    wMeasureLength;     // Length, in measures.
    WORD    wClocksPerMeasure;  // Length of each measure.
    WORD    wClocksPerBeat;     // Length of each beat.
    WORD    wTempoFract;        // Tempo fraction.  (0-65536) (Score only)
    DWORD   dwFlags;           // Currently not used in SuperJAM!
    char    chKey;          // key sig. High bit is flat bit, the rest is root.
    char    chPad[3];
    GUID    guidStyle;
    GUID    guidPersonality;
    wchar_t wstrCategory[16];
} ioSection;

typedef struct ioBand
{
    wchar_t wstrName[20]; // Band name
    BYTE    abPatch[16];
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;    // This band is the style's default band
    char    chPad;
    WORD    awDLSBank[16];
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//    wchar_t wstrCollection[16];
    char    szCollection[32];           // this only needs to be single-wide chars
} ioBand;

typedef struct ioLyric
{
    long    lTime;       // Time, in clocks
} ioLyric;

typedef struct ioPhrase
{
    long    lTime;
    BYTE    bID;    // which phrase it is. Index starting at 0.
} ioPhrase;

typedef struct ioClick
{
    short   lTime;               // Index into grid.
} ioClick;

typedef struct ioPattern
{
    long    lTime;             // Time this starts.
    DWORD   dwLength;           // Pattern length in clocks.
    DWORD   fFlags;            // Various flags.
    WORD    wClocksPerClick;   // Size of each click.
    WORD    wBeat;             // What note gets the beat.
    WORD    wClocksPerBeat;    // Size of each beat.
    WORD    wMeasures;         // Number of measures.
    wchar_t wstrName[16];         // Name of pattern.
    DWORD   dwKeyPattern;       // Key for defining in.
    DWORD   dwChordPattern;     // Defining chord.
    BYTE    abInvertUpper[16];   // Inversion upper limit.
    BYTE    abInvertLower[16];   // Inversion upper limit.
    WORD    wInvert;     // Activate inversion flags.
    WORD    awVarFlags[16][16]; // Var flags for all musicians.
    WORD    wAutoInvert;    // Automatically set inversion limits
    BYTE    bRoot;             // Root for defining.
    char    achChordChoice[16];
} ioPattern;

typedef struct ioStyle
{
    wchar_t wstrName[16];         // Each style has a name.
    WORD    wBPM;              // Beats per measure.
    WORD    wBeat;             // Beat note.
    WORD    wClocksPerClick;   // Clocks per click in patterns.
    WORD    wClocksPerBeat;    // Clocks per beat.
    WORD    wClocksPerMeasure; // Clocks per measure.
    WORD    wTempo;            // Tempo.
    WORD    wTempoFract;
    GUID    guid;
    wchar_t wstrCategory[16];
} ioStyle;

typedef struct ioPersonalityRef
{
    wchar_t wstrName[20];       // Internal name stored in personality
    char    fDefault;           // 1=Default personality
    char    achPad[3];
    GUID    guid;
} ioPersonalityRef;

#pragma pack()

#endif// __IOSTRUCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\oledll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.h
//
//--------------------------------------------------------------------------

//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\opnew.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       opnew.cpp
//
//--------------------------------------------------------------------------

// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\mgentrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       mgentrk.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// MelodyFragment

#ifndef __MELGENTRK_H_
#define __MELGENTRK_H_

#include "dmusici.h"
#include "TList.h"
//#include "dmpublic.h" // remove when this gets incorporated into dmusici.h/dmusicf.h
#include "dmstyle.h"

#define DMUS_TRANSITIONF_GHOST_FOUND 1
#define DMUS_TRANSITIONF_OVERLAP_FOUND 2
#define DMUS_TRANSITIONF_LAST_FOUND 4
#define DMUS_TRANSITIONF_GHOST_OK 8
#define DMUS_TRANSITIONF_OVERLAP_OK 0x10
#define DMUS_TRANSITIONF_LAST_OK 0x20

// overlap delta is largest value less than a 128th note triplet
#define OVERLAP_DELTA 15

HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom);

HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom);

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom);

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom);

struct CompositionFragment;
struct EventWrapper;

BOOL Less(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2);

BOOL Greater(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2);

BOOL Less(EventWrapper& SeqItem1, EventWrapper& SeqItem2);

BOOL Greater(EventWrapper& SeqItem1, EventWrapper& SeqItem2);

/////////////////////////////////////////////////////////////////////////////
// MelodyFragment
struct MelodyFragment
{
    MelodyFragment() {}

    MelodyFragment(DMUS_MELODY_FRAGMENT& rSource) :
        m_mtTime(rSource.mtTime), 
        m_dwID(rSource.dwID),
        m_dwVariationFlags(rSource.dwVariationFlags),
        m_dwRepeatFragmentID(rSource.dwRepeatFragmentID), 
        m_dwFragmentFlags(rSource.dwFragmentFlags),
        m_dwPlayModeFlags(rSource.dwPlayModeFlags),
        m_dwTransposeIntervals(rSource.dwTransposeIntervals),
        m_ConnectionArc(rSource.ConnectionArc),
        m_Command(rSource.Command)
    {
        wcscpy(m_wszVariationLabel, rSource.wszVariationLabel);
    }

    MelodyFragment(MelodyFragment& rSource) :
        m_mtTime(rSource.m_mtTime), 
        m_dwID(rSource.m_dwID),
        m_dwVariationFlags(rSource.m_dwVariationFlags),
        m_dwRepeatFragmentID(rSource.m_dwRepeatFragmentID), 
        m_dwFragmentFlags(rSource.m_dwFragmentFlags),
        m_dwPlayModeFlags(rSource.m_dwPlayModeFlags),
        m_dwTransposeIntervals(rSource.m_dwTransposeIntervals),
        m_ConnectionArc(rSource.m_ConnectionArc),
        m_Command(rSource.m_Command)
    {
        wcscpy(m_wszVariationLabel, rSource.m_wszVariationLabel);
        for (int i = 0; i < INVERSIONGROUPLIMIT; i++)
        {
            m_aInversionGroups[i] = rSource.m_aInversionGroups[i];
        }
    }

    HRESULT GetPattern(DMStyleStruct* pStyleStruct, 
                       CDirectMusicPattern*& rPattern,
                       TListItem<CompositionFragment>* pLastFragment);

    HRESULT GetVariations(CompositionFragment& rCompFragment,
                          CompositionFragment& rfragmentRepeat,
                          CompositionFragment& rfragmentLast,
                          DMUS_CHORD_PARAM& rCurrentChord, 
                          DMUS_CHORD_PARAM& rNextChord,
                          MUSIC_TIME mtNextChord,
                          TListItem<CompositionFragment>* pLastFragment);

/*  HRESULT GetVariation(DirectMusicPartRef& rPartRef,
                         DMUS_CHORD_PARAM& rCurrentChord,
                         MUSIC_TIME mtNext,
                         MUSIC_TIME mtNextChord,
                         IDirectMusicTrack* pChordTrack,
                         DWORD& rdwVariation);
*/

    HRESULT GetChord(IDirectMusicSegment* pTempSeg, 
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord,
                     MUSIC_TIME& rmtCurrent,
                     DMUS_CHORD_PARAM& rRealCurrentChord);

    HRESULT GetChord(MUSIC_TIME mtTime, 
                     IDirectMusicSegment* pTempSeg,
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord);

    HRESULT TestTransition(BYTE bMIDI,
                           MUSIC_TIME mtTime, 
                           DMUS_CHORD_PARAM& rCurrentChord,
                           int nPartIndex,
                           DirectMusicPartRef& rPartRef,
                           TListItem<CompositionFragment>* pLastFragment);

    HRESULT TestHarmonicConstraints(TListItem<EventWrapper>* pOldEventHead,
                                    TList<EventWrapper>& rNewEventList);

    HRESULT GetFirstNote(int nVariation,
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             CompositionFragment& rCompFragment,
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi,
                             MUSIC_TIME& rmtNote);

    HRESULT GetNote(CDirectMusicEventItem* pEvent, 
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi);

    HRESULT GetEvent(CDirectMusicEventItem* pEvent, 
                     DMUS_CHORD_PARAM& rCurrentChord, 
                     DMUS_CHORD_PARAM& rRealCurrentChord, 
                     MUSIC_TIME mtNow, 
                     DirectMusicPartRef& rPartRef,
                     TListItem<EventWrapper>*& rpEventItem);

    HRESULT TransposeEventList(int nInterval,
                               CompositionFragment& rfragmentRepeat,
                               DMUS_CHORD_PARAM& rCurrentChord, 
                               DMUS_CHORD_PARAM& rRealCurrentChord,
                               BYTE bPlaymode,
                               DirectMusicPartRef& rPartRef,
                               TListItem<EventWrapper>*& rpOldEventHead,
                               TList<EventWrapper>& rNewEventList,
                               BYTE& rbFirstMIDI,
                               MUSIC_TIME& rmtFirstTime);

    HRESULT GetRepeatedEvents(CompositionFragment& rfragmentRepeat,
                              DMUS_CHORD_PARAM& rCurrentChord, 
                              DMUS_CHORD_PARAM& rRealCurrentChord,
                              BYTE bPlaymode,
                              int nPartIndex,
                              DirectMusicPartRef& rPartRef,
                              TListItem<CompositionFragment>* pLastFragment,
                              MUSIC_TIME& rmtFirstNote,
                              TList<EventWrapper>& rEventList);

    bool UsesRepeat()
    {
        return (m_dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT) ? true : false;
    }

    bool UsesTransitionRules()
    {
        return (m_ConnectionArc.dwFlags & (DMUS_CONNECTIONF_GHOST | DMUS_CONNECTIONF_INTERVALS | DMUS_CONNECTIONF_OVERLAP)) ? true : false;
    }

    bool RepeatsWithConstraints()
    {
        return 
            UsesRepeat() &&
            ( (m_dwFragmentFlags & (DMUS_FRAGMENTF_SCALE | DMUS_FRAGMENTF_CHORD)) ? true : false );
    }

    DWORD GetID()
    {
        return m_dwID;
    }

    DWORD GetRepeatID()
    {
        return m_dwRepeatFragmentID;
    }

    MUSIC_TIME GetTime()
    {
        return m_mtTime;
    }

    DMUS_COMMAND_PARAM GetCommand()
    {
        return m_Command;
    }

    DMUS_CONNECTION_RULE GetConnectionArc()
    {
        return m_ConnectionArc;
    }

    DWORD GetVariationFlags()
    {
        return m_dwVariationFlags;
    }

    void ClearInversionGroups()
    {
        for (int i = 0; i < INVERSIONGROUPLIMIT; i++)
            m_aInversionGroups[i].m_wGroupID = 0;
    }

protected:

    MUSIC_TIME      m_mtTime;
    DWORD           m_dwID;  // This fragment's ID
    WCHAR           m_wszVariationLabel[DMUS_MAX_FRAGMENTLABEL]; // Each style translates this into a set of variations (held in part ref)
    DWORD           m_dwVariationFlags; // A set of variations
    DWORD           m_dwRepeatFragmentID;  // ID of a fragment to repeat 
    DWORD           m_dwFragmentFlags; // including things like: invert the fragment, transpose it...
    DWORD           m_dwPlayModeFlags; // including new playmodes (only use 8 bits of this)
    DWORD           m_dwTransposeIntervals; // Legal transposition intervals (first 24 bits; two-octave range)
    DMUS_COMMAND_PARAM      m_Command;
    DMUS_CONNECTION_RULE    m_ConnectionArc;
    InversionGroup      m_aInversionGroups[INVERSIONGROUPLIMIT]; // Inversion Groups for composing melodies
};

// TransitionConstraint (for keeping track of transition constraints)
struct TransitionConstraint
{
    TransitionConstraint() : dwFlags(0), bGhost(0), bOverlap(0), bLastPlayed(0)
    {
    }

    DWORD dwFlags;
    BYTE bGhost;
    BYTE bOverlap;
    BYTE bLastPlayed;
};

// EventOverlap (for remembering events that might overlap succeeding fragments)
struct EventOverlap
{
    ~EventOverlap()
    {
        ZeroMemory(&m_PartRef, sizeof(m_PartRef));
        m_pEvent = NULL;
    }

    DirectMusicPartRef m_PartRef;
    MUSIC_TIME m_mtTime;
    MUSIC_TIME m_mtDuration;
    CDirectMusicEventItem* m_pEvent;
    DMUS_CHORD_PARAM m_Chord;
    DMUS_CHORD_PARAM m_RealChord;
};

struct EventWrapper
{
    EventWrapper() : m_pEvent(NULL), m_mtTime(0), m_bMIDI(0), m_dwPChannel(0), m_wMusic(0), m_bPlaymode(DMUS_PLAYMODE_NONE)
    {
    }

    ~EventWrapper()
    {
        m_pEvent = NULL;
    }

    CDirectMusicEventItem*  m_pEvent;
    MUSIC_TIME              m_mtTime;
    DWORD                   m_dwPChannel;
    WORD                    m_wMusic;
    BYTE                    m_bMIDI;
    BYTE                    m_bScaleFlat;
    BYTE                    m_bScaleSharp;
    BYTE                    m_bChordFlat;
    BYTE                    m_bChordSharp;
    BYTE                    m_bPlaymode;
};

// FragmentPartRecord (for keeping track of previously generated melody fragment parts)
// (in addition to sequence events, may also want to keep track of note events)
struct FragmentPartRecord
{
    FragmentPartRecord()
    {
    }

    ~FragmentPartRecord()
    {
        m_listEvents.CleanUp();
    }

    TList<EventWrapper>     m_listEvents;

};

// CompositionFragment (melody fragment used in the composition process)
struct CompositionFragment : MelodyFragment
{
    CompositionFragment()
    {
        m_aFragmentParts = NULL;
        m_abVariations = NULL;
        m_pStyle = NULL;
        m_pPattern = NULL;
    }

    CompositionFragment(MelodyFragment& rFragment) : MelodyFragment(rFragment)
    {
        m_aFragmentParts = NULL;
        m_abVariations = NULL;
        m_pStyle = NULL;
        m_pPattern = NULL;
    }

    ~CompositionFragment()
    {
        if (m_aFragmentParts) delete [] m_aFragmentParts;
        if (m_abVariations) delete [] m_abVariations;
    }

    HRESULT Init(CDirectMusicPattern* pPattern, DMStyleStruct* pStyleStruct, int nParts)
    {
        m_pStyle = pStyleStruct;
        m_pPattern = pPattern;
        m_abVariations = new BYTE [nParts];
        if (!m_abVariations)
        {
            return E_OUTOFMEMORY;
        }
        m_aFragmentParts = new FragmentPartRecord[nParts];
        if (!m_aFragmentParts)
        {
            delete [] m_abVariations;
            m_abVariations = NULL;
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }

    void SetPattern(CDirectMusicPattern* pPattern)
    {
        m_pPattern = pPattern;
    }

    void SetStyle(DMStyleStruct* pStyle)
    {
        m_pStyle = pStyle;
    }

    TListItem<EventOverlap>* GetOverlapHead()
    {
        return m_listEventOverlaps.GetHead();
    }

    TList<EventWrapper>& EventList(int i)
    {
        return m_aFragmentParts[i].m_listEvents;
    }

    void AddOverlap(TListItem<EventOverlap>* pOverlap)
    {
        m_listEventOverlaps.AddHead(pOverlap);
    }

    TListItem<EventWrapper>* GetEventHead(int i)
    {
        return m_aFragmentParts[i].m_listEvents.GetHead();
    }

    TListItem<EventWrapper>* RemoveEventHead(int i)
    {
        return m_aFragmentParts[i].m_listEvents.RemoveHead();
    }

    void AddEvent(int i, TListItem<EventWrapper>* pEvent)
    {
        m_aFragmentParts[i].m_listEvents.AddHead(pEvent);
    }

    void InsertEvent(int i, TListItem<EventWrapper>* pEvent)
    {
        TListItem<EventWrapper>* pScan = m_aFragmentParts[i].m_listEvents.GetHead();
        TListItem<EventWrapper>* pPrevious = NULL;
        for (; pScan; pScan = pScan->GetNext() )
        {
            if ( Greater(pEvent->GetItemValue(), pScan->GetItemValue()) ) break;
            pPrevious = pScan;
        }
        if (!pPrevious)
        {
            m_aFragmentParts[i].m_listEvents.AddHead(pEvent);
        }
        else
        {
            pPrevious->SetNext(pEvent);
            pEvent->SetNext(pScan);
        }
    }

    void SortEvents(int i)
    {
        m_aFragmentParts[i].m_listEvents.MergeSort(Greater);
    }

    BOOL IsEmptyEvents(int i)
    {
        return m_aFragmentParts[i].m_listEvents.IsEmpty();
    }

    void CleanupEvents(int i)
    {
        m_aFragmentParts[i].m_listEvents.CleanUp();
    }

    DirectMusicTimeSig& GetTimeSig(DirectMusicPart* pPart)
    {
        if (pPart && pPart->m_timeSig.m_bBeat != 0)
        {
            return pPart->m_timeSig;
        }
        else if (m_pPattern && m_pPattern->m_timeSig.m_bBeat != 0)
        {
            return m_pPattern->m_timeSig;
        }
        else if (m_pStyle && m_pStyle->m_TimeSignature.m_bBeat != 0)
        {
            return m_pStyle->m_TimeSignature;
        }
        else
        {
            return m_staticTimeSig;
        }
    }

    CDirectMusicPattern*        m_pPattern;
    FragmentPartRecord*         m_aFragmentParts;
    BYTE*                       m_abVariations;
    TList<EventOverlap>         m_listEventOverlaps;
    DMStyleStruct*              m_pStyle;
    static DirectMusicTimeSig   m_staticTimeSig;
};

/////////////////////////////////////////////////////////////////////////////
// CMelodyFormulationTrack

class CMelodyFormulationTrack : 
    public IDirectMusicTrack8,
    public IPersistStream
{
public:
    CMelodyFormulationTrack();
    CMelodyFormulationTrack(const CMelodyFormulationTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
    ~CMelodyFormulationTrack();
    void Clear();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

public:
HRESULT STDMETHODCALLTYPE Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            );

HRESULT STDMETHODCALLTYPE InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            );

HRESULT STDMETHODCALLTYPE EndPlay(
                /*[in]*/  void*                     pStateData
            );

HRESULT STDMETHODCALLTYPE Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            );

    HRESULT STDMETHODCALLTYPE GetParam( 
        REFGUID pCommandGuid,
        MUSIC_TIME mtTime,
        MUSIC_TIME* pmtNext,
        void *pData);

    HRESULT STDMETHODCALLTYPE SetParam( 
        /* [in] */ REFGUID pCommandGuid,
        /* [in] */ MUSIC_TIME mtTime,
        /* [out] */ void __RPC_FAR *pData);

    HRESULT STDMETHODCALLTYPE AddNotificationType(
                /* [in] */  REFGUID pGuidNotify
            );

    HRESULT STDMETHODCALLTYPE RemoveNotificationType(
                /* [in] */  REFGUID pGuidNotify
            );

    HRESULT STDMETHODCALLTYPE Clone(
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        IDirectMusicTrack** ppTrack);

    HRESULT STDMETHODCALLTYPE IsParamSupported(
                /*[in]*/ REFGUID            pGuid
            );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
    HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
    HRESULT STDMETHODCALLTYPE IsDirty();

    HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

    HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

    HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// Methods for dealing with melody fragments
    HRESULT SendNotification(MUSIC_TIME mtTime,
                             IDirectMusicPerformance* pPerf,
                             IDirectMusicSegment* pSegment,
                             IDirectMusicSegmentState* pSegState,
                             DWORD dwFlags);
    HRESULT LoadFragments(LPSTREAM pStream, long lFileSize );
    HRESULT SetID(DWORD& rdwID);
    HRESULT GetID(DWORD& rdwID);
    HRESULT AddToSegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicTrack* pNewPatternTrack,
                           DWORD dwGroupBits);

protected:
    // attributes
    long m_cRef;
    CRITICAL_SECTION            m_CriticalSection; // for load and playback
    BYTE                        m_bRequiresSave;

    BOOL                        m_fNotifyRecompose;
    TList<DMUS_MELODY_FRAGMENT> m_FragmentList;
    DWORD                       m_dwLastId;
    BYTE                        m_bPlaymode; // playmode for events in the generated pattern track.
};

#endif // __MELGENTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\mgentrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       mgentrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// MGenTrk.cpp : Implementation of CMelodyFormulationTrack
#include "MGenTrk.h"
#include "dmstyle.h"
#include "debug.h"
#include "..\shared\Validate.h"

DirectMusicTimeSig CompositionFragment::m_staticTimeSig(4, 4, 4);

const BYTE g_bDefaultPlaymode = DMUS_PLAYMODE_ALWAYSPLAY;

// Since one of these is typedef'd to the other, we only need a single
// implementation that does a structure-wide copy (but keep the other 3 implementations
// around, in case we separate the types out later)
HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    rTo.dwPlayModeFlags = DMUS_PLAYMODE_NONE; // only flag supported for dx8
    return S_OK;
}

BOOL Less(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2)
{ return SeqItem1.mtTime + SeqItem1.nOffset < SeqItem2.mtTime + SeqItem2.nOffset; }

BOOL Greater(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2)
{ return SeqItem1.mtTime + SeqItem1.nOffset > SeqItem2.mtTime + SeqItem2.nOffset; }

BOOL Less(EventWrapper& SeqItem1, EventWrapper& SeqItem2)
{ 
    MUSIC_TIME mtOffset1 = SeqItem1.m_pEvent ? SeqItem1.m_pEvent->m_nTimeOffset : 0;
    MUSIC_TIME mtOffset2 = SeqItem2.m_pEvent ? SeqItem2.m_pEvent->m_nTimeOffset : 0;
    return SeqItem1.m_mtTime + mtOffset1 < SeqItem2.m_mtTime + mtOffset2;
}

BOOL Greater(EventWrapper& SeqItem1, EventWrapper& SeqItem2)
{ 
    MUSIC_TIME mtOffset1 = SeqItem1.m_pEvent ? SeqItem1.m_pEvent->m_nTimeOffset : 0;
    MUSIC_TIME mtOffset2 = SeqItem2.m_pEvent ? SeqItem2.m_pEvent->m_nTimeOffset : 0;
    return SeqItem1.m_mtTime + mtOffset1 > SeqItem2.m_mtTime + mtOffset2; 
}

/*
HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    return S_OK;
}

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    return S_OK;
}

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CMelodyFormulationTrack


CMelodyFormulationTrack::CMelodyFormulationTrack() : 
    m_bRequiresSave(0), m_dwLastId(0), m_bPlaymode(g_bDefaultPlaymode),
    m_cRef(1), m_fNotifyRecompose(FALSE)

{
    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    InterlockedIncrement(&g_cComponent);
}

CMelodyFormulationTrack::CMelodyFormulationTrack(const CMelodyFormulationTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0), m_dwLastId(rTrack.m_dwLastId), m_bPlaymode(rTrack.m_bPlaymode),
    m_cRef(1), m_fNotifyRecompose(FALSE)
{
    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    InterlockedIncrement(&g_cComponent);
    m_bPlaymode = rTrack.m_bPlaymode;
    BOOL fStarted = FALSE;
    TListItem<DMUS_MELODY_FRAGMENT>* pScan = rTrack.m_FragmentList.GetHead();
    TListItem<DMUS_MELODY_FRAGMENT>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMUS_MELODY_FRAGMENT& rScan = pScan->GetItemValue();
        if (rScan.mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.mtTime < mtEnd)
        {
            if (rScan.mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            if (!fStarted)
            {
                fStarted = TRUE;
            }
            TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>;
            if (pNew)
            {
                DMUS_MELODY_FRAGMENT& rNew = pNew->GetItemValue();
                CopyMelodyFragment(rNew, rScan);
                rNew.mtTime = rScan.mtTime - mtStart;
                m_FragmentList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        DMUS_MELODY_FRAGMENT& rPrevious = pPrevious->GetItemValue();
        TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>;
        if (pNew)
        {
            DMUS_MELODY_FRAGMENT& rNew = pNew->GetItemValue();
            CopyMelodyFragment(rNew, rPrevious);
            rNew.mtTime = 0;
            m_FragmentList.AddHead(pNew);
        }
    }
}

CMelodyFormulationTrack::~CMelodyFormulationTrack()
{
    ::DeleteCriticalSection( &m_CriticalSection );
    InterlockedDecrement(&g_cComponent);
}

void CMelodyFormulationTrack::Clear()
{
    m_FragmentList.CleanUp();
    m_dwLastId = 0;
}


HRESULT CMelodyFormulationTrack::SetID(DWORD& rdwID)
{
    m_dwLastId++;
    rdwID = m_dwLastId;
    return S_OK;
}

HRESULT CMelodyFormulationTrack::GetID(DWORD& rdwID)
{
    rdwID = m_dwLastId;
    return S_OK;
}

STDMETHODIMP CMelodyFormulationTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CMelodyFormulationTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMelodyFormulationTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMelodyFormulationTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CMelodyFormulationTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    return S_OK; // if I return an error, dmime gives me an assertion failure
}

HRESULT CMelodyFormulationTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    return S_OK;
}

HRESULT CMelodyFormulationTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    return S_OK;
}

HRESULT CMelodyFormulationTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    bool fStart = (dwFlags & DMUS_TRACKF_START) ? true : false;
    bool fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? true : false;
    bool fCompose = (dwFlags & DMUS_TRACKF_RECOMPOSE) ? true : false;
    bool fPlayOff = (dwFlags & DMUS_TRACKF_PLAY_OFF) ? true : false;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);
    DWORD dwTrackGroup = 1;
    if ( fStart || fLoop ) 
    {
        if ( fCompose && !fPlayOff )
        {
            IDirectMusicSegment* pSegment = NULL;
            if (SUCCEEDED(hr = pSegState->GetSegment(&pSegment)))
            {
                IDirectMusicTrack* pTrack = NULL;
                if (SUCCEEDED(hr = QueryInterface(IID_IDirectMusicTrack, (void**)&pTrack)))
                {
                    pSegment->GetTrackGroup(pTrack, &dwTrackGroup);
                    pTrack->Release();
                    // call Track::Compose on this track
                    if (SUCCEEDED(hr = Compose(pSegment, dwTrackGroup, &pTrack)))
                    {
                        if (SUCCEEDED(AddToSegment(pSegment, pTrack, dwTrackGroup)))
                        {
                            // if we recomposed, send a recompose notification
                            SendNotification(mtStart + mtOffset, pPerf, pSegment, pSegState, dwFlags);
                        }
                        pTrack->Release();
                    }
                }
            }
            pSegment->Release();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

// This will modify an existing segment by adding *only* a pattern track to it.
// Any existing pattern tracks with conflicting group bits will be modifed.
HRESULT CMelodyFormulationTrack::AddToSegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicTrack* pNewPatternTrack,
                           DWORD dwGroupBits)
{
    HRESULT                 hr                          = S_OK;
    IDirectMusicTrack*      pCurrentPatternTrack        = NULL;
    IStream*                pNewPatternStream           = NULL;
    IPersistStream*         pNewPatternTrackStream      = NULL;
    IPersistStream*         pCurrentPatternTrackStream  = NULL;

    // if there exists a pattern track with these group bits, reload this pattern into that
    // track (use the first track that's found).  Otherwise, insert this track into the segment.
    hr = pTempSeg->GetTrack(CLSID_DirectMusicPatternTrack, dwGroupBits, 0, &pCurrentPatternTrack);
    if (S_OK != hr)
    {
        // insert the passed-in track
        hr = pTempSeg->InsertTrack(pNewPatternTrack, dwGroupBits);
    }
    else
    {
        // load the new track into the one that already exists
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pNewPatternStream);
        if (S_OK != hr) goto ON_END;
        hr = pNewPatternTrack->QueryInterface( IID_IPersistStream, (void**)&pNewPatternTrackStream);
        if (S_OK != hr) goto ON_END;
        pNewPatternTrackStream->Save(pNewPatternStream, FALSE);
        hr = pCurrentPatternTrack->QueryInterface(IID_IPersistStream, (void**)&pCurrentPatternTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pNewPatternStream, 0, STREAM_SEEK_SET);
        hr = pCurrentPatternTrackStream->Load(pNewPatternStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }

ON_END:
    if (pCurrentPatternTrack) pCurrentPatternTrack->Release();
    if (pCurrentPatternTrackStream) pCurrentPatternTrackStream->Release();
    if (pNewPatternStream) pNewPatternStream->Release();
    if (pNewPatternTrackStream) pNewPatternTrackStream->Release();
    return hr;
}

HRESULT CMelodyFormulationTrack::SendNotification(MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegment* pSegment,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (!m_fNotifyRecompose || (dwFlags & DMUS_TRACKF_NOTIFY_OFF))
    {
        return S_OK;
    }
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = DMUS_NOTIFICATION_RECOMPOSE;
        pEvent->guidNotificationType = GUID_NOTIFICATION_RECOMPOSE;

        if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
        {
            pEvent->dwGroupID = 0xffffffff;
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            pGraph->StampPMsg((DMUS_PMSG*) pEvent );
            pGraph->Release();
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}

HRESULT CMelodyFormulationTrack::GetParam(
                REFGUID                     rParamGuid,
                MUSIC_TIME                  mtTime, 
                MUSIC_TIME*                 pmtNext,
                void*                       pData
            )
{
    V_INAME(CMelodyFormulationTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData, 1);
    V_REFGUID(rParamGuid);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    if (rParamGuid == GUID_MelodyFragment)
    {
        TListItem<DMUS_MELODY_FRAGMENT>* pMelGen = m_FragmentList.GetHead();
        if (pMelGen)
        {
            TListItem<DMUS_MELODY_FRAGMENT>* pNext = pMelGen->GetNext();
            for(; pNext; pNext = pNext->GetNext())
            {
                if (pNext->GetItemValue().mtTime <= mtTime) // may be it, but we need a next time
                {
                    pMelGen = pNext;
                }
                else // passed it
                {
                    break;
                }
            }
            *(DMUS_MELODY_FRAGMENT*)pData = pMelGen->GetItemValue();
            if (pmtNext)
            {
                if (pNext)
                {
                    *pmtNext = pNext->GetItemValue().mtTime - mtTime;
                }
                else
                {
                    *pmtNext = 0;
                }
            }
            hr = S_OK;
        }
        else hr = DMUS_E_NOT_FOUND;
    }
    else if (rParamGuid == GUID_MelodyFragmentRepeat)
    {
        // replace the passed-in fragment with the one its repeat field refers to
        DMUS_MELODY_FRAGMENT* pFragment = (DMUS_MELODY_FRAGMENT*)pData;
        if (!(pFragment->dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT))
        {
            hr = DMUS_E_NOT_FOUND;
        }
        else
        {
            TListItem<DMUS_MELODY_FRAGMENT>* pMelGen = m_FragmentList.GetHead();
            for(; pMelGen; pMelGen = pMelGen->GetNext())
            {
                if (pMelGen->GetItemValue().dwID == pFragment->dwRepeatFragmentID)
                {
                    break;
                }
            }
            if (pMelGen)
            {
                *(DMUS_MELODY_FRAGMENT*)pData = pMelGen->GetItemValue();
                if (pmtNext)
                {
                    TListItem<DMUS_MELODY_FRAGMENT>* pNext = pMelGen->GetNext();
                    if (pNext)
                    {
                        *pmtNext = pNext->GetItemValue().mtTime - mtTime;
                    }
                    else
                    {
                        *pmtNext = 0;
                    }
                }
                hr = S_OK;
            }
            else hr = DMUS_E_NOT_FOUND;
        }
    }
    else if (rParamGuid == GUID_MelodyPlaymode)
    {
        *(BYTE*)pData = m_bPlaymode;
        if (pmtNext)
        {
            *pmtNext = 0;
        }
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
} 

HRESULT CMelodyFormulationTrack::SetParam( 
    REFGUID                     rParamGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CMelodyFormulationTrack::SetParam);
    V_PTR_WRITE(pData, 1);
    V_REFGUID(rParamGuid);

    HRESULT hr;

    EnterCriticalSection( &m_CriticalSection );
    if (rParamGuid == GUID_Clear_All_MelodyFragments)
    {
        Clear();
        hr = S_OK;
    }
    else if (rParamGuid == GUID_MelodyFragment)
    {
        DMUS_MELODY_FRAGMENT* pFragment = (DMUS_MELODY_FRAGMENT*)pData;
        TListItem<DMUS_MELODY_FRAGMENT>* pFragmentItem = m_FragmentList.GetHead();
        TListItem<DMUS_MELODY_FRAGMENT>* pPrevious = NULL;
        TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>;
        if (!pNew)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            pNew->GetItemValue() = *pFragment;
            // overide time in struct with time passed in
            pNew->GetItemValue().mtTime = mtTime; 
            for(; pFragmentItem != NULL; pFragmentItem = pFragmentItem->GetNext())
            {
                if (pFragmentItem->GetItemValue().mtTime >= mtTime) break;
                pPrevious = pFragmentItem;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pNew);
                pNew->SetNext(pFragmentItem);
            }
            else // pFragmentItem is current head of list
            {
                m_FragmentList.AddHead(pNew);
            }
            if (pFragmentItem && pFragmentItem->GetItemValue().mtTime == mtTime)
            {
                // remove it
                pNew->GetItemValue().dwID = pFragmentItem->GetItemValue().dwID;
                pNew->SetNext(pFragmentItem->GetNext());
                pFragmentItem->SetNext(NULL);
                delete pFragmentItem;
            }
            else
            {
                // give the struct a brand new ID
                SetID(pNew->GetItemValue().dwID);
            }
            hr = S_OK;
        }
    }
    else
    {
        hr = DMUS_E_SET_UNSUPPORTED;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CMelodyFormulationTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CMelodyFormulationTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicMelodyFormulationTrack;
    return S_OK;
}

HRESULT CMelodyFormulationTrack::IsParamSupported(
                /*[in]*/ REFGUID                        rGuid
            )
{
    V_INAME(CMelodyFormulationTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (rGuid == GUID_MelodyFragment || 
        rGuid == GUID_MelodyPlaymode ||
        rGuid == GUID_Clear_All_MelodyFragments)
        return S_OK;
    else 
        return DMUS_E_TYPE_UNSUPPORTED;
}

// IPersistStream methods
 HRESULT CMelodyFormulationTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CMelodyFormulationTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    V_INAME(CMelodyFormulationTrack::Save);
    V_INTERFACE(pStream);

    HRESULT         hr = S_OK;
    IAARIFFStream* pRIFF = NULL;
    MMCKINFO        ckMain, ckHeader, ckBody;
    DWORD           cb;
    DWORD           dwSize;
    DMUS_IO_MELODY_FRAGMENT oMelGen;
    TListItem<DMUS_MELODY_FRAGMENT>* pMelGen;

    EnterCriticalSection( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF );
    if ( FAILED( hr ) )
    {
        goto ON_END;
    }

    // Create a chunk to store the MelGen data
    ckMain.fccType = DMUS_FOURCC_MELODYFORM_TRACK_LIST;
    if( pRIFF->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
    {
        hr = E_FAIL;
        goto ON_END;
    }

    // Write MelForm chunk header
    ckHeader.ckid = DMUS_FOURCC_MELODYFORM_HEADER_CHUNK;
    if( pRIFF->CreateChunk( &ckHeader, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_END;
    }

    // Prepare DMUS_IO_MELFORM
    DMUS_IO_MELFORM oMelForm;
    memset( &oMelForm, 0, sizeof(DMUS_IO_MELFORM) );

    oMelForm.dwPlaymode = m_bPlaymode;
        
    // Write MelForm chunk data
    hr = pStream->Write( &oMelForm, sizeof(DMUS_IO_MELFORM), &cb);
    if( FAILED( hr ) ||  cb != sizeof(DMUS_IO_MELFORM) )
    {
        hr = E_FAIL;
        goto ON_END;
    }
    
    if( pRIFF->Ascend( &ckHeader, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_END;
    }

    // Write MelForm chunk body
    ckBody.ckid = DMUS_FOURCC_MELODYFORM_BODY_CHUNK;
    if( pRIFF->CreateChunk( &ckBody, 0 ) == 0 )
    {
        dwSize = sizeof( oMelGen );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            if (SUCCEEDED(hr)) hr = E_FAIL;
            goto ON_END;
        }
        for( pMelGen = m_FragmentList.GetHead(); pMelGen != NULL ; pMelGen = pMelGen->GetNext() )
        {
            DMUS_MELODY_FRAGMENT& rMelGen = pMelGen->GetItemValue();
            memset( &oMelGen, 0, sizeof( oMelGen ) );
            CopyMelodyFragment(oMelGen, rMelGen);
            if( FAILED( pStream->Write( &oMelGen, sizeof( oMelGen ), &cb ) ) ||
                cb != sizeof( oMelGen ) )
            {
                break;
            }
        }
        if( pMelGen == NULL )
        {
            hr = S_OK;
        }

        // Ascend out of the MelForm Body chunk
        if( pRIFF->Ascend( &ckBody, 0 ) != 0 )
        {
            hr = E_FAIL;
            goto ON_END;
        }
    }

    // Ascend out of the MelGen chunk.
    pRIFF->Ascend( &ckMain, 0 );

ON_END:
    if (pRIFF) pRIFF->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CMelodyFormulationTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}


BOOL Less(DMUS_MELODY_FRAGMENT& MF1, DMUS_MELODY_FRAGMENT& MF2)
{ return MF1.mtTime < MF2.mtTime; }

HRESULT CMelodyFormulationTrack::Load(LPSTREAM pStream )
{
    V_INAME(CMelodyFormulationTrack::Load);
    V_INTERFACE(pStream);

    // Melody formulation temporarily turned off for DX8.
    return E_NOTIMPL;
/*
    HRESULT         hr = DMUS_E_CHUNKNOTFOUND;
    DWORD dwPos;
    IAARIFFStream*  pRIFF;

    EnterCriticalSection( &m_CriticalSection );
    Clear();
    m_dwLastId = 0;
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
    MMCKINFO        ckMain;
    MMCKINFO        ckHeader;
    bool fFoundTrack = false;

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_MELODYFORM_TRACK_LIST;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0)
        {
            // New melform track
            long lFileSize = ckMain.cksize - 4; // subtract off the list type
            DMUS_IO_MELFORM iMelform;
            DWORD cb;
            if (pRIFF->Descend(&ckHeader, &ckMain, 0) == 0)
            {
                if (ckHeader.ckid == DMUS_FOURCC_MELODYFORM_HEADER_CHUNK )
                {
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= ckHeader.cksize;
                    hr = pStream->Read( &iMelform, sizeof( iMelform ), &cb );
                    if (FAILED(hr) || cb != sizeof( iMelform ) ) 
                    {
                        if (SUCCEEDED(hr)) hr = DMUS_E_CHUNKNOTFOUND;
                    }
                    else
                    {
                        //m_bPlaymode = (BYTE) iMelform.dwPlaymode;
                        m_bPlaymode = DMUS_PLAYMODE_NONE;  // only flag supported for dx8
                    }
                }
                pRIFF->Ascend( &ckHeader, 0 );
            }
            if (SUCCEEDED(hr))
            {
                hr = DMUS_E_CHUNKNOTFOUND;
                if (pRIFF->Descend(&ck, &ckMain, 0) == 0)
                {
                    if (ck.ckid == DMUS_FOURCC_MELODYFORM_BODY_CHUNK )
                    {
                        if( SUCCEEDED(LoadFragments(pStream, (long) ck.cksize)) )
                        {
                            hr = S_OK;
                            m_FragmentList.MergeSort(Less);
                        }
                    }
                    pRIFF->Ascend( &ck, 0 );
                }
            }

            fFoundTrack = true;
        }
        pRIFF->Release();
        pRIFF = NULL;
    }

    if (!fFoundTrack)
    {
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        // old (obsolete) melform track
        if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
        {
            ck.ckid = DMUS_FOURCC_MELODYGEN_TRACK_CHUNK;
            if ( pRIFF->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
            {
                if( SUCCEEDED(LoadFragments(pStream, (long) ck.cksize)) &&
                    pRIFF->Ascend( &ck, 0 ) == 0 )
                {
                    hr = S_OK;
                    m_FragmentList.MergeSort(Less);
                }
            }
            pRIFF->Release();
        }
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;*/
}

HRESULT CMelodyFormulationTrack::LoadFragments(LPSTREAM pStream, long lFileSize )
{
    DWORD dwNodeSize;
    DWORD       cb;
    HRESULT hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
    DMUS_IO_MELODY_FRAGMENT     iMelGen;
    if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
    {
        lFileSize -= 4; // for the size dword
        TListItem<DMUS_MELODY_FRAGMENT>* pMelGen;
        if (lFileSize % dwNodeSize)
        {
            hr = E_FAIL;
        }
        else
        {
            while( lFileSize > 0 )
            {
                pMelGen = new TListItem<DMUS_MELODY_FRAGMENT>;
                if( pMelGen )
                {
                    DMUS_MELODY_FRAGMENT& rMelGen = pMelGen->GetItemValue();
                    if( dwNodeSize <= sizeof( iMelGen ) )
                    {
                        pStream->Read( &iMelGen, dwNodeSize, NULL );
                    }
                    else
                    {
                        pStream->Read( &iMelGen, sizeof( iMelGen ), NULL );
                        DWORD dw = (lFileSize >= sizeof( iMelGen ) ) ? lFileSize - sizeof( iMelGen ) : 0;
                        StreamSeek( pStream, dw, STREAM_SEEK_CUR );
                    }
                    memset( &rMelGen, 0, sizeof( rMelGen ) );
                    CopyMelodyFragment(rMelGen, iMelGen);
                    m_FragmentList.AddHead(pMelGen);
                    lFileSize -= dwNodeSize;
                }
                else break;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (lFileSize != 0)
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CMelodyFormulationTrack::AddNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CMelodyFormulationTrack::RemoveNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CMelodyFormulationTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CSPstTrk::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    
    CMelodyFormulationTrack *pDM;
    
    try
    {
        pDM = new CMelodyFormulationTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT MelodyFragment::GetChord(IDirectMusicSegment* pTempSeg,
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord,
                     MUSIC_TIME& rmtCurrent,
                     DMUS_CHORD_PARAM& rRealCurrentChord)
{
    HRESULT hr = S_OK;

    hr = GetChord(m_mtTime, pTempSeg, pSong, dwTrackGroup, rmtNext, rRealCurrentChord);

    if ( SUCCEEDED(hr) )
    {
        rmtCurrent = rmtNext;
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_ANTICIPATE)
        {
            hr = GetChord(rmtCurrent, pTempSeg, pSong, dwTrackGroup, rmtNext, rCurrentChord);
        }
        else
        {
            rCurrentChord = rRealCurrentChord;
        }
    }

    return hr;
}

HRESULT MelodyFragment::GetChord(MUSIC_TIME mtTime, 
                     IDirectMusicSegment* pTempSeg,
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord)
{
    HRESULT hr = E_FAIL;

    DMUS_CHORD_PARAM DefaultChord;
    wcscpy(DefaultChord.wszName, L"M7");
    DefaultChord.wMeasure = 0;
    DefaultChord.bBeat = 0;
    DefaultChord.bSubChordCount = 1;
    DefaultChord.dwScale = 0xab5ab5;  // default: major scale
    DefaultChord.bKey = 12;    // default: C2
    DefaultChord.SubChordList[0].dwChordPattern = 0x91;   // default: major chord
    DefaultChord.SubChordList[0].dwScalePattern = 0xab5ab5;  // default: major scale
    DefaultChord.SubChordList[0].dwInversionPoints = 0xffffff; // default: inversions everywhere
    DefaultChord.SubChordList[0].dwLevels = 0xffffff; // let this work with anything...
    DefaultChord.SubChordList[0].bChordRoot = 12;      // default: C2
    DefaultChord.SubChordList[0].bScaleRoot = 0;

    if (pTempSeg)
    {
        hr = pTempSeg->GetParam(GUID_ChordParam, dwTrackGroup, 0, mtTime, &rmtNext, (void*)&rCurrentChord);
    }
    else if (pSong)
    {
        hr = pSong->GetParam(GUID_ChordParam, dwTrackGroup, 0, mtTime, &rmtNext, (void*)&rCurrentChord);
    }
    if (SUCCEEDED(hr))
    {
        rmtNext += mtTime;
        hr = S_OK;
    }
    else
    {
        rCurrentChord = DefaultChord;
        rmtNext = 0;
        hr = S_FALSE;
    }


    return hr;
}

HRESULT MelodyFragment::GetPattern(DMStyleStruct* pStyleStruct, 
                       CDirectMusicPattern*& rpPattern,
                       TListItem<CompositionFragment>* pLastFragment)
{
    HRESULT hr = S_OK;
    DMUS_COMMAND_PARAM_2 Command[1];
    Command[0].mtTime = 0;
    if (m_Command.bGrooveLevel == 0 && pLastFragment)
    {
        m_Command = pLastFragment->GetItemValue().GetCommand();
    }
    Command[0].bCommand = m_Command.bCommand;
    Command[0].bGrooveLevel = m_Command.bGrooveLevel;
    Command[0].bGrooveRange = m_Command.bGrooveRange;

    TListItem<CDirectMusicPattern*>* pPatItem = pStyleStruct->m_PatternList.GetHead();
    if (pPatItem)
    {
        // choose the first matching pattern
        for ( ; pPatItem; pPatItem = pPatItem->GetNext())
        {
            CDirectMusicPattern* pPattern = pPatItem->GetItemValue();
            if (pPattern && pPattern->MatchCommand(Command, 1) )
            {
                rpPattern = pPattern;
                hr = S_OK;
                break;
            }
        }
        if (!pPatItem) // problem; fallback to first pattern
        {
            pPatItem = pStyleStruct->m_PatternList.GetHead();
            rpPattern = pPatItem->GetItemValue();
            hr = S_OK;
        }
    }
    else
    {
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}

// GetTransitionNotes: given the time of a note, and a fragment, return the appropriate
// transition note tuple (last and overlap; ghost tested separately)
HRESULT GetTransitionNotes(MUSIC_TIME mtTime, 
                           DWORD dwPart,
                           TListItem<CompositionFragment>* pCompFragment, 
                           TransitionConstraint& rTransition)
{
    rTransition.dwFlags &= ~DMUS_TRANSITIONF_OVERLAP_FOUND;
    rTransition.dwFlags &= ~DMUS_TRANSITIONF_LAST_FOUND;
    // Check pCompFragment overlaps for the last note to start before mtTime,
    // and the first note to start on or after mtTime.
    if (pCompFragment)
    {
        CompositionFragment& rFragment = pCompFragment->GetItemValue();
        TListItem<EventOverlap>* pOverlap = rFragment.GetOverlapHead();
        MUSIC_TIME nMinOverlap = 0;
        MUSIC_TIME nMaxPlayed = 0;
        for (; pOverlap; pOverlap = pOverlap->GetNext() )
        {
            EventOverlap& rOverlap = pOverlap->GetItemValue();
            if ( rOverlap.m_PartRef.m_dwLogicalPartID == dwPart &&
                 (rOverlap.m_pEvent->m_dwEventTag & DMUS_EVENT_NOTE) )
            {
                if (rOverlap.m_mtTime >= mtTime) // this note overlaps
                {
                    if ( !(rTransition.dwFlags & DMUS_TRANSITIONF_OVERLAP_FOUND) || 
                          rOverlap.m_mtTime < nMinOverlap )
                    {
                        HRESULT hr = rFragment.GetNote(rOverlap.m_pEvent, rOverlap.m_Chord, rOverlap.m_PartRef, rTransition.bOverlap);
                        if (SUCCEEDED(hr))
                        {
                            nMinOverlap = rOverlap.m_mtTime;
                            rTransition.dwFlags |= DMUS_TRANSITIONF_OVERLAP_FOUND;
                        }
                    }
                }
                if (rOverlap.m_mtTime < mtTime) // this note will be played
                {
                    if ( !(rTransition.dwFlags & DMUS_TRANSITIONF_LAST_FOUND) || 
                          rOverlap.m_mtTime >= nMaxPlayed )
                    {
                        HRESULT hr = rFragment.GetNote(rOverlap.m_pEvent, rOverlap.m_Chord, rOverlap.m_PartRef, rTransition.bLastPlayed);
                        if (SUCCEEDED(hr))
                        {
                            nMaxPlayed = rOverlap.m_mtTime;
                            rTransition.dwFlags |= DMUS_TRANSITIONF_LAST_FOUND;
                        }
                    }
                }
            }
        }
        // If we couldn't find a last note, use the last note in the event list of pCompFragment
        TListItem<CompositionFragment>* pfragmentScan = pCompFragment;
        while (pfragmentScan && !(rTransition.dwFlags & DMUS_TRANSITIONF_LAST_FOUND))
        {
            CompositionFragment& rfragmentScan = pfragmentScan->GetItemValue();
            TListItem<DirectMusicPartRef>* pPartRef = rfragmentScan.m_pPattern->m_PartRefList.GetHead();
            int nParts = rfragmentScan.m_pPattern->m_PartRefList.GetCount();
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                if (pPartRef->GetItemValue().m_dwLogicalPartID == dwPart) break;
            }
            if (i < nParts)
            {
                TListItem<EventWrapper>* pEventItem = rfragmentScan.GetEventHead(i);
                if (pEventItem) 
                {
                    // The list is sorted in reverse order, so the head is the last element
                    rTransition.bLastPlayed = pEventItem->GetItemValue().m_bMIDI;
                    rTransition.dwFlags |= DMUS_TRANSITIONF_LAST_FOUND;
                }
            }
            pfragmentScan = pfragmentScan->GetNext(); // goes backwards to first fragment 
        }
    }

    return S_OK;
}

HRESULT MelodyFragment::TestTransition(BYTE bMIDI,
                                       MUSIC_TIME mtNote, 
                                       DMUS_CHORD_PARAM& rCurrentChord, 
                                       int nPartIndex,
                                       DirectMusicPartRef& rPartRef,
                                       TListItem<CompositionFragment>* pLastFragment)
{ 
    bool fGhost = false;
    bool fOverlap = false;
    bool fGoodInterval = false;
    if (pLastFragment)
    {
        // if this variation doesn't meet the constraints, return S_FALSE; otherwise return S_OK
        DMUS_CONNECTION_RULE Connection = pLastFragment->GetItemValue().GetConnectionArc();

        DWORD dwPart = rPartRef.m_dwLogicalPartID;
        TransitionConstraint Transition;
        ZeroMemory(&Transition , sizeof(Transition));
        
        GetTransitionNotes(mtNote, dwPart, pLastFragment, Transition);

        // Test ghost notes
        if ( (Connection.dwFlags & DMUS_CONNECTIONF_GHOST) )
        {
            BYTE bGhost = 0;
            CDMStyleNote* pNoteEvent = new CDMStyleNote;
            if (pNoteEvent)
            {
                pNoteEvent->m_bDurRange = 0;
                pNoteEvent->m_bFlags = 0;
                pNoteEvent->m_bTimeRange = 0;
                pNoteEvent->m_bVelocity = 0;
                pNoteEvent->m_dwFragmentID = 0;
                pNoteEvent->m_mtDuration = 0;
                pNoteEvent->m_nGridStart = 0;
                pNoteEvent->m_nTimeOffset = 0;
                TListItem<DMUS_IO_STYLERESOLUTION>* pScan = rPartRef.m_pDMPart->m_ResolutionList.GetHead();
                for(; pScan; pScan = pScan->GetNext() )
                {
                    DMUS_IO_STYLERESOLUTION& rResolution = pScan->GetItemValue();
                    pNoteEvent->m_bInversionId = rResolution.bInversionID;
                    pNoteEvent->m_bPlayModeFlags = rResolution.bPlayModeFlags;
                    pNoteEvent->m_dwVariation = rResolution.dwVariation;
                    pNoteEvent->m_wMusicValue = rResolution.wMusicValue;
                    if ((1 << pLastFragment->GetItemValue().m_abVariations[nPartIndex]) & pNoteEvent->m_dwVariation &&
                        SUCCEEDED(GetNote(pNoteEvent, rCurrentChord, rPartRef, bGhost)))
                    {
                        if (bGhost == bMIDI)
                        {
                            fGhost = true;
                            break;
                        }
                    }
                }
                delete pNoteEvent;
            }
        }

        // Test overlap notes 
        if ( (Connection.dwFlags & DMUS_CONNECTIONF_OVERLAP) &&
             (Transition.dwFlags & DMUS_TRANSITIONF_OVERLAP_FOUND) )
        {
                if (Transition.bOverlap == bMIDI) fOverlap = true;
        }

        // Test last played notes
        // Assumptions:
        // 1. intervals go in either direction (up or down)
        // 2. intervals are in absolute semitones.
        if ( (Connection.dwFlags & DMUS_CONNECTIONF_INTERVALS) && 
             (Transition.dwFlags & DMUS_TRANSITIONF_LAST_FOUND) )
        {
            DWORD dwIntervals = Connection.dwIntervals;
            for (int nTranspose = 0; nTranspose <= 12; nTranspose++)
            {
                if ( dwIntervals & (1 << nTranspose) )
                {
                    if (Transition.bLastPlayed + nTranspose == bMIDI ||
                        Transition.bLastPlayed - nTranspose == bMIDI)
                    {
                        fGoodInterval = true;
                    }
                }
            }
        }
    }
    return (fGhost || fOverlap || fGoodInterval) ? S_OK : S_FALSE;
}

// Currently assuming diatonic intervals spanning an octave
#define MAX_INTERVAL 8

// Currently only transposes up...
BYTE TransposeNote(BYTE bMIDI, int nInterval, DMUS_CHORD_PARAM& rChord)
{
    if (!bMIDI) return bMIDI;
    nInterval++; // To correspond to scale intervals
    for (int nSemitone = 0; nSemitone < 24; nSemitone++)
    {
        if (rChord.dwScale & (1 << nSemitone))
        {
            nInterval--;
            if (!nInterval) break;
        }
    }
    if (nSemitone < 24)
    {
        bMIDI = (BYTE) (bMIDI + nSemitone);
    }
    return bMIDI;
}

DWORD ShiftScale(DWORD dwScale, char chRoot)
{
    while (chRoot < 0) chRoot += 12;
    while (chRoot > 11) chRoot -= 12;
    dwScale &= 0xfff;
    dwScale <<= chRoot;
    dwScale |= (dwScale >> 12);
    return dwScale & 0xfff;
}

void ScaleMisses(BYTE bTone, DWORD dwScale, BYTE& rFlats, BYTE& rSharps)
{
    // make sure the flats don't underflow the scale
    bool fUnderflow = true;
    for (int i = 0; i <= bTone; i++)
    {
        if (dwScale & (1 << i))
        {
            fUnderflow = false;
            break;
        }
    }
    if (fUnderflow)
    {
        bTone += 12;
    }
    // make sure the sharps don't overflow the scale
    bool fOverflow = true;
    for (i = bTone; i < 24; i++)
    {
        if (dwScale & (1 << i))
        {
            fOverflow = false;
            break;
        }
    }
    if (fOverflow)
    {
        dwScale |= ((dwScale << 12) & 0xfff000);
    }
    rFlats = rSharps = 0;
    // If this note is in the scale, no need to do any other processing
    if ( !(dwScale & (1 << bTone)) )
    {
        for (i = 0; i <= bTone; i++) 
        {
            if (dwScale & (1 << i))
            {
                rFlats = 0;
            }
            else
            {
                rFlats++;
            }
        }
        for (i = bTone; i < 24; i++) 
        {
            if (dwScale & (1 << i))
            {
                return;
            }
            else
            {
                rSharps++;
            }
        }
    }
}

// Transpose all events in the repeat fragment diatonically, according to the underlying scale given
// in the chord, adjusting all times relative to the the current fragment.  
// Return the time of the first note in the transposed fragment.
HRESULT MelodyFragment::TransposeEventList(int nInterval,
                                           CompositionFragment& rfragmentRepeat,
                                           DMUS_CHORD_PARAM& rCurrentChord, 
                                           DMUS_CHORD_PARAM& rRealCurrentChord,
                                           BYTE bPlaymode,
                                           DirectMusicPartRef& rPartRef,
                                           TListItem<EventWrapper>*& rpOldEventHead,
                                           TList<EventWrapper>& rNewEventList,
                                           BYTE& rbFirstMIDI,
                                           MUSIC_TIME& rmtFirstTime)
{
    DWORD dwScale = ShiftScale(rCurrentChord.dwScale, rCurrentChord.bKey);
    DWORD dwChord = ShiftScale(rCurrentChord.SubChordList[0].dwChordPattern, rCurrentChord.SubChordList[0].bChordRoot);
    rbFirstMIDI = 0;
    rmtFirstTime = 0;
    bool fFirstEvent = true;
    HRESULT hr = S_OK;
    MUSIC_TIME mtElapsed = m_mtTime - rfragmentRepeat.GetTime();
    //if (!mtElapsed) mtElapsed = 0; // clamp mtElapsed to non-negative (??)
    if (m_dwTransposeIntervals & (1 << nInterval))
    {
        rNewEventList.CleanUp();
        // Find the corresponding part in the repeat fragment
        TListItem<DirectMusicPartRef>* pPartRef = rfragmentRepeat.m_pPattern->m_PartRefList.GetHead();
        int nParts = rfragmentRepeat.m_pPattern->m_PartRefList.GetCount();
        for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
        {
            if (pPartRef->GetItemValue().m_dwLogicalPartID == rPartRef.m_dwLogicalPartID) break;
        }
        if (i < nParts)
        {
            TListItem<EventWrapper>* pScan = rfragmentRepeat.GetEventHead(i);
            rpOldEventHead = pScan;
            for (; pScan && SUCCEEDED(hr); pScan = pScan->GetNext())
            {
                EventWrapper ScanEvent = pScan->GetItemValue();
                TListItem<EventWrapper>* pEventItem = new TListItem<EventWrapper>;
                if (!pEventItem) hr = E_OUTOFMEMORY;
                else
                {
                    EventWrapper& rEvent = pEventItem->GetItemValue();
                    rEvent.m_mtTime = ScanEvent.m_mtTime + mtElapsed;
                    rEvent.m_bMIDI = TransposeNote(ScanEvent.m_bMIDI, nInterval, rCurrentChord);
                    BYTE bTone = (BYTE) (rEvent.m_bMIDI % 12);
                    ScaleMisses(bTone, dwScale, rEvent.m_bScaleFlat, rEvent.m_bScaleSharp); 
                    ScaleMisses(bTone, dwChord, rEvent.m_bChordFlat, rEvent.m_bChordSharp); 
                    hr = rPartRef.ConvertMIDIValue(rEvent.m_bMIDI, 
                                              rRealCurrentChord,
                                              bPlaymode,
                                              NULL,
                                              rEvent.m_wMusic);
                    if (FAILED(rEvent.m_wMusic))
                    {
                        rEvent.m_wMusic = 0;
                    }
                    rEvent.m_bPlaymode = bPlaymode;
                    rEvent.m_pEvent = ScanEvent.m_pEvent;
                    rEvent.m_dwPChannel = ScanEvent.m_dwPChannel;
                    rNewEventList.AddHead(pEventItem);
                    if (fFirstEvent || rEvent.m_mtTime < rmtFirstTime)
                    {
                        rmtFirstTime = rEvent.m_mtTime;
                        rbFirstMIDI = rEvent.m_bMIDI;
                        fFirstEvent = false;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                rNewEventList.MergeSort(Greater);
            }
        }
        else hr = E_FAIL;
    }
    else hr = E_FAIL;
    return hr;
}

HRESULT MelodyFragment::TestHarmonicConstraints(TListItem<EventWrapper>* pOldEventHead,
                                                TList<EventWrapper>& rNewEventList)
{
    HRESULT hr = S_OK;
    TListItem<EventWrapper>* pOldScan = pOldEventHead;
    TListItem<EventWrapper>* pNewScan = rNewEventList.GetHead();
    for (; pOldScan && pNewScan && SUCCEEDED(hr); pOldScan = pOldScan->GetNext(), pNewScan = pNewScan->GetNext())
    {
        EventWrapper& rOldEvent = pOldScan->GetItemValue();
        EventWrapper& rNewEvent = pNewScan->GetItemValue();
        BYTE bOldFlats, bOldSharps, bNewFlats, bNewSharps;
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_CHORD)
        {
            bOldFlats = rOldEvent.m_bChordFlat;
            bOldSharps = rOldEvent.m_bChordSharp;
            bNewFlats = rNewEvent.m_bChordFlat;
            bNewSharps = rNewEvent.m_bChordSharp;
        }
        else if (m_dwFragmentFlags & DMUS_FRAGMENTF_SCALE)
        {
            bOldFlats = rOldEvent.m_bScaleFlat;
            bOldSharps = rOldEvent.m_bScaleSharp;
            bNewFlats = rNewEvent.m_bScaleFlat;
            bNewSharps = rNewEvent.m_bScaleSharp;
        }
        else // something's wrong
        {
            hr = E_FAIL;
            break;
        }
        if (bOldFlats != bNewFlats && bOldSharps != bNewSharps)
        {
            hr = E_FAIL;
            break;
        }
    }
    return hr;
}

HRESULT MelodyFragment::GetRepeatedEvents(CompositionFragment& rfragmentRepeat,
                              DMUS_CHORD_PARAM& rCurrentChord, 
                              DMUS_CHORD_PARAM& rRealCurrentChord,
                              BYTE bPlaymode,
                              int nPartIndex,
                              DirectMusicPartRef& rPartRef,
                              TListItem<CompositionFragment>* pLastFragment,
                              MUSIC_TIME& rmtFirstNote,
                              TList<EventWrapper>& rEventList)
{
    HRESULT hr = E_FAIL;
    BYTE bMIDI = 0;
    TListItem<EventWrapper>* pOldEventHead;
    // For each transposition interval (unison is always the first interval tested):
    for (int i = 0; i < MAX_INTERVAL; i++)
    {
        if (SUCCEEDED(TransposeEventList(i, rfragmentRepeat, rCurrentChord, rRealCurrentChord, bPlaymode, rPartRef, pOldEventHead, rEventList, bMIDI, rmtFirstNote)))
        {
            // Test transposed notes against harmonic constraints
            if (SUCCEEDED(TestHarmonicConstraints(pOldEventHead, rEventList)))
            {
                // Test transposed notes against transition constraints (assuming there are any)
                // (note: eventually this test may be allowed to add transition notes as appropriate)

                // If there are no transition constraints, don't bother to test them.
                if (!pLastFragment || 
                    !pLastFragment->GetItemValue().UsesTransitionRules()) 
                {
                    hr = S_OK;
                    break;
                }

                if (S_OK == TestTransition(bMIDI, rmtFirstNote, rCurrentChord, nPartIndex, rPartRef, pLastFragment))
                {
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    // If no interval satisfies both constraints, fail.
    if (FAILED(hr)) rEventList.CleanUp();
    return hr;
}

// this should ensure, if possible, that the selected variations
// work for all chords from the current one to mtNext
HRESULT MelodyFragment::GetVariations(CompositionFragment& rCompFragment,
                          CompositionFragment& rfragmentRepeat,
                          CompositionFragment& rfragmentLast,
                          DMUS_CHORD_PARAM& rCurrentChord, 
                          DMUS_CHORD_PARAM& rNextChord,
                          MUSIC_TIME mtNextChord,
                          TListItem<CompositionFragment>* pLastFragment)
{
    DWORD* adwVariationMask = NULL;
    DWORD* adwRemoveVariations = NULL;
    static BYTE abVariationGroups[MAX_VARIATION_LOCKS];
    DWORD dwVariationFlags = 0;
    CDirectMusicPattern* pPattern = NULL;

    if (m_dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT)
    {
        dwVariationFlags = rfragmentRepeat.GetVariationFlags();
        pPattern = rfragmentRepeat.m_pPattern;
        int nParts = rfragmentRepeat.m_pPattern->m_PartRefList.GetCount();
        adwVariationMask = new DWORD[nParts];
        adwRemoveVariations = new DWORD[nParts];
        if (!adwVariationMask || !adwRemoveVariations)
        {
            return E_OUTOFMEMORY;
        }
        for (int i = 0; i < nParts; i++)
        {
            adwRemoveVariations[i] = 0;
        }
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_REJECT_REPEAT) 
        {
            // any variation but the one previously selected (for all parts)
            for (int i = 0; i < nParts; i++)
            {
                adwVariationMask[i] = dwVariationFlags ^ (1 << rfragmentLast.m_abVariations[i]);
            }
        }
        else
        {
            // only the variation previously selected (for all parts)
            for (int i = 0; i < nParts; i++)
            {
                adwVariationMask[i] = dwVariationFlags & (1 << rfragmentLast.m_abVariations[i]);
            }
        }
    }
    else
    {
        pPattern = rCompFragment.m_pPattern;
        int nParts = rCompFragment.m_pPattern->m_PartRefList.GetCount();
        adwVariationMask = new DWORD[nParts];
        if (!adwVariationMask)
        {
            return E_OUTOFMEMORY;
        }
        adwRemoveVariations = new DWORD[nParts];
        if (!adwRemoveVariations)
        {
            delete [] adwVariationMask;
            return E_OUTOFMEMORY;
        }
        for (int i = 0; i < nParts; i++)
        {
            adwRemoveVariations[i] = 0;
        }
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_USE_LABEL)
        {
            delete [] adwVariationMask;
            delete [] adwRemoveVariations;
            return E_NOTIMPL;
        }
        else
        {
            for (int i = 0; i < nParts; i++)
            {
                adwVariationMask[i] = rCompFragment.GetVariationFlags();
            }
        }
    }
    // filter variations according to transition constraints
    if (pLastFragment && pLastFragment->GetItemValue().UsesTransitionRules())
    {
        TListItem<DirectMusicPartRef>* pPartRef = rCompFragment.m_pPattern->m_PartRefList.GetHead();
        for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
        {
            DWORD dwOriginalMask = adwVariationMask[i];
            //int nPart = pPartRef->GetItemValue().m_wLogicalPartID;
            for (int nVar = 0; nVar < 32; nVar++)
            {
                if ( adwVariationMask[i] & (1 << nVar) )
                {
                    // get the first note of the variation
                    BYTE bMIDI = 0;
                    MUSIC_TIME mtNote = 0;
                    HRESULT hrFirst = GetFirstNote(nVar, rCurrentChord, rCompFragment, pPartRef->GetItemValue(), bMIDI, mtNote);
        
                    // if this variation doesn't meet the constraints, remove it from the mask
                    if ( SUCCEEDED(hrFirst) &&
                         S_OK != TestTransition(bMIDI, mtNote, rCurrentChord, i, pPartRef->GetItemValue(), pLastFragment) )
                    {
                        adwVariationMask[i] &= ~(1 << nVar);
                    }    
                }
            }
            // If none of the variations meet all the constraints, fall back to the original mask
            if (!adwVariationMask[i]) adwVariationMask[i] = dwOriginalMask;
        }
    }
    DWORD dwFlags = (COMPUTE_VARIATIONSF_USE_MASK | COMPUTE_VARIATIONSF_NEW_PATTERN | COMPUTE_VARIATIONSF_DX8);
    HRESULT hr = pPattern->ComputeVariations(dwFlags,
                                rCurrentChord,
                                rNextChord,
                                abVariationGroups,
                                adwVariationMask,
                                adwRemoveVariations,
                                rCompFragment.m_abVariations,
                                m_mtTime, 
                                mtNextChord);
    if (adwVariationMask) delete [] adwVariationMask;
    if (adwRemoveVariations) delete [] adwRemoveVariations;
    return hr;
}

HRESULT MelodyFragment::GetFirstNote(int nVariation,
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             CompositionFragment& rCompFragment,
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi,
                             MUSIC_TIME& rmtNote)
{
    HRESULT hr = S_OK;
    DirectMusicPart* pPart = rPartRef.m_pDMPart;
    DirectMusicTimeSig& TimeSig = rCompFragment.GetTimeSig(pPart);
    CDirectMusicEventItem* pEvent = pPart->EventList.GetHead();
    bool fFoundNote = false;
    for (; pEvent; pEvent = pEvent->GetNext())
    {
        if ( pEvent->m_dwVariation & (1 << nVariation) )
        {
            if (pEvent->m_dwEventTag == DMUS_EVENT_NOTE)
            {
                MUSIC_TIME mtNow = GetTime() +
                    TimeSig.GridToClocks(pEvent->m_nGridStart) + pEvent->m_nTimeOffset;
                if (!fFoundNote || mtNow < rmtNote)
                {
                    hr = GetNote(pEvent, rCurrentChord, rPartRef, rbMidi);
                    if (SUCCEEDED(hr))
                    {
                        fFoundNote = true;
                        rmtNote = mtNow;
                    }
                }
            }
        }
    }
    if (!fFoundNote) hr = S_FALSE;
    return hr;
}

HRESULT MelodyFragment::GetNote(CDirectMusicEventItem* pEvent, 
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi)
{
    HRESULT hr = S_OK;
    // only process note events
    CDMStyleNote* pNoteEvent = NULL;
    if (pEvent->m_dwEventTag == DMUS_EVENT_NOTE) // we have a note event
    {
        pNoteEvent = (CDMStyleNote*)pEvent;
        // get a playmode (either from the note or from the melody fragment)
        BYTE bPlaymode = (BYTE) m_dwPlayModeFlags;
        short nMidiOffset = 0;
        if (bPlaymode == DMUS_PLAYMODE_NONE)
        {
            bPlaymode =
                (pNoteEvent->m_bPlayModeFlags & DMUS_PLAYMODE_NONE) ?
                    rPartRef.m_pDMPart->m_bPlayModeFlags :
                    pNoteEvent->m_bPlayModeFlags;   
        }
        // generate a MIDI value from the melody note, fragment, chord, and playmode
        HRESULT hrTest = rPartRef.ConvertMusicValue(pNoteEvent, 
                                      rCurrentChord,
                                      bPlaymode,
                                      FALSE,
                                      m_aInversionGroups,
                                      NULL,
                                      rbMidi,
                                      nMidiOffset);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT MelodyFragment::GetEvent(CDirectMusicEventItem* pEvent, 
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             DMUS_CHORD_PARAM& rRealCurrentChord, 
                             MUSIC_TIME mtNow, 
                             DirectMusicPartRef& rPartRef,
                             TListItem<EventWrapper>*& rpEventItem)
{
    DWORD dwScale = ShiftScale(rCurrentChord.dwScale, rCurrentChord.bKey);
    DWORD dwChord = ShiftScale(rCurrentChord.SubChordList[0].dwChordPattern, rCurrentChord.SubChordList[0].bChordRoot);
    HRESULT hr = S_OK;
    // only process note events
    CDMStyleNote* pNoteEvent = NULL;
    if (pEvent->m_dwEventTag == DMUS_EVENT_NOTE) // we have a note event
    {
        pNoteEvent = (CDMStyleNote*)pEvent;
        // get a playmode (either from the note or from the melody fragment)
        BYTE bPlaymode = (BYTE) m_dwPlayModeFlags;
        BYTE bMIDI = 0;
        WORD wMusic = 0;
        short nMidiOffset = 0;
        if (bPlaymode == DMUS_PLAYMODE_NONE)
        {
            bPlaymode =
                (pNoteEvent->m_bPlayModeFlags & DMUS_PLAYMODE_NONE) ?
                    rPartRef.m_pDMPart->m_bPlayModeFlags :
                    pNoteEvent->m_bPlayModeFlags;   
        }
        // generate a MIDI value from the melody note, fragment, chord, and playmode
        HRESULT hrTest = rPartRef.ConvertMusicValue(pNoteEvent, 
                                      rCurrentChord,
                                      bPlaymode,
                                      FALSE,
                                      m_aInversionGroups,
                                      NULL,
                                      bMIDI,
                                      nMidiOffset);
        if (SUCCEEDED(hrTest))
        {
            hrTest = rPartRef.ConvertMIDIValue(bMIDI, 
                                      rRealCurrentChord,
                                      bPlaymode,
                                      NULL,
                                      wMusic);
        }
        if (FAILED(hrTest)) hr = hrTest;
        else
        {
            rpEventItem = new TListItem<EventWrapper>;
            if (!rpEventItem) hr = E_OUTOFMEMORY;
            else
            {
                EventWrapper& rEvent = rpEventItem->GetItemValue();
                rEvent.m_mtTime = mtNow - pNoteEvent->m_nTimeOffset; // remove the offset (it's in m_nTimeOffset)
                rEvent.m_bMIDI = bMIDI;
                BYTE bTone = (BYTE) (bMIDI % 12);
                ScaleMisses(bTone, dwScale, rEvent.m_bScaleFlat, rEvent.m_bScaleSharp); 
                ScaleMisses(bTone, dwChord, rEvent.m_bChordFlat, rEvent.m_bChordSharp); 
                rEvent.m_wMusic = wMusic;
                rEvent.m_pEvent = pNoteEvent;
                rEvent.m_dwPChannel = rPartRef.m_dwLogicalPartID;
                rEvent.m_bPlaymode = bPlaymode;
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CMelodyFormulationTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CMelodyFormulationTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CMelodyFormulationTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CMelodyFormulationTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(Compose)

    V_INTERFACE(pContext);
    V_PTRPTR_WRITE(ppResultTrack);

    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = S_OK;
    IDirectMusicTrack* pPatternTrack = NULL;
    IDirectMusicStyle* pStyle = NULL;
    IDMStyle* pDMStyle = NULL;
    MUSIC_TIME mtLength = 0;

    IDirectMusicSegment* pTempSeg = NULL;
    IDirectMusicSong* pSong = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pTempSeg)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hr = E_INVALIDARG;
            goto ON_END;
        }
    }

    if (pTempSeg)
    {
        if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle))) goto ON_END;
        if (FAILED(hr = pTempSeg->GetLength(&mtLength))) goto ON_END;
    }
    else if (pSong)
    {
        MUSIC_TIME mtNow = 0;
        MUSIC_TIME mtNext = 0;
        while (FAILED(hr = pSong->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, mtNow, &mtNext, (void*)&pStyle)))
        {
            if (mtNext <= 0) goto ON_END;
            mtNow = mtNext;
        }
        //if (FAILED(hr = pSong->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle))) goto ON_END;
        IDirectMusicSegment* pSeg = NULL;
        DWORD dwSeg = 0;
        while (S_OK == hr)
        {
            if (FAILED(hr = pSong->EnumSegment(dwSeg, &pSeg))) goto ON_END;
            if (hr == S_OK)
            {
                MUSIC_TIME mt = 0;
                hr = pSeg->GetLength(&mt);
                if (FAILED(hr)) goto ON_END;
                mtLength += mt;
                pSeg->Release();
                pSeg = NULL;
                dwSeg++;
            }
        }
    }

    // Using chord track, style, and melgen track, create a pattern track
    hr = pStyle->QueryInterface(IID_IDMStyle, (void**)&pDMStyle);
    if (SUCCEEDED(hr))
    {
        hr = pDMStyle->GenerateTrack(pTempSeg, pSong, dwTrackGroup, pStyle, this, mtLength, pPatternTrack);
        if (SUCCEEDED(hr))
        {
            *ppResultTrack = pPatternTrack;
        }
        pDMStyle->Release();
    }

ON_END:
    // Release from Addref in GetStyle
    if (pStyle) pStyle->Release();
    if (pSong) pSong->Release();
    if (pTempSeg) pTempSeg->Release();

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

// if ppResultTrack is NULL, add pNewTrack to the end of the current track;
// otherwise, create a copy of the current track and add pNewTrack to the end of the copy.
// The new track starts at mtJoin, so get rid of everything before that in the current
// track (or its clone).  If cloning, simply clone to mtJoin.
STDMETHODIMP CMelodyFormulationTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    TList<DMUS_MELODY_FRAGMENT> ResultList;
    CMelodyFormulationTrack* pResultTrack = NULL;
    DWORD dwMaxID = 0;
    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        pResultTrack = (CMelodyFormulationTrack*)*ppResultTrack;
        while(!pResultTrack->m_FragmentList.IsEmpty())
        {
            ResultList.AddHead(pResultTrack->m_FragmentList.RemoveHead());
            DWORD dwThis = ResultList.GetHead()->GetItemValue().dwID;
            if (dwThis > dwMaxID) dwMaxID = dwThis;
        }
    }
    else
    {
        pResultTrack = this;
        while(!m_FragmentList.IsEmpty() && 
              m_FragmentList.GetHead()->GetItemValue().mtTime < mtJoin)
        {
            ResultList.AddHead(m_FragmentList.RemoveHead());
            DWORD dwThis = ResultList.GetHead()->GetItemValue().dwID;
            if (dwThis > dwMaxID) dwMaxID = dwThis;
        }
        m_FragmentList.CleanUp();
    }
    CMelodyFormulationTrack* pOtherTrack = (CMelodyFormulationTrack*)pNewTrack;
    TListItem<DMUS_MELODY_FRAGMENT>* pScan = pOtherTrack->m_FragmentList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>(pScan->GetItemValue());
        if (pNew)
        {
            DMUS_MELODY_FRAGMENT& rNew = pNew->GetItemValue();
            rNew.mtTime += mtJoin;
            rNew.dwID += dwMaxID;
            if (rNew.dwRepeatFragmentID &&
                (rNew.dwFragmentFlags & (DMUS_FRAGMENTF_USE_REPEAT | DMUS_FRAGMENTF_REJECT_REPEAT)) )
            {
                rNew.dwRepeatFragmentID += dwMaxID;
            }

            ResultList.AddHead(pNew);
        }
        else
        {
            ResultList.CleanUp();
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pResultTrack->m_FragmentList.CleanUp();
        while(!ResultList.IsEmpty() )
        {
            pResultTrack->m_FragmentList.AddHead(ResultList.RemoveHead());
        }
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\motiftrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       motiftrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// MotifTrk.cpp : Implementation of CMotifTrack
//#include "stdafx.h"
//#include "Section.h"
#include "MotifTrk.h"
#include <stdlib.h> // for random number generator
#include <time.h>	// to seed random number generator
#include "debug.h"
#include "dmusici.h"
#include "debug.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// MotifTrackState

MotifTrackState::MotifTrackState() : 
	m_mtMotifStart(0)
{
}

MotifTrackState::~MotifTrackState()
{
}

HRESULT MotifTrackState::Play(
				  MUSIC_TIME				mtStart, 
				  MUSIC_TIME				mtEnd, 
				  MUSIC_TIME				mtOffset,
				  REFERENCE_TIME rtOffset,
				  IDirectMusicPerformance* pPerformance,
				  DWORD						dwFlags,
				  BOOL fClockTime
			)
{
	m_mtPerformanceOffset = mtOffset;
	BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
	BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
	BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
	if (fControl) // We need to make sure we get chords on beat boundaries
	{
		GetNextChord(mtStart, mtOffset, pPerformance, fStart);
	}
	MUSIC_TIME mtNotify = mtStart ? PatternTimeSig().CeilingBeat(mtStart) : 0;
	if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat &&  !fClockTime &&
		( mtNotify < mtEnd ) )
	{
		mtNotify = NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
	}

	bool fReLoop = false;
	DWORD dwPartFlags = PLAYPARTSF_FIRST_CALL;
	if (fStart || fLoop || fSeek) dwPartFlags |= PLAYPARTSF_START;
	if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
	if ( fLoop || (mtStart > 0 &&  (fStart || fSeek || fControl)) ) dwPartFlags |= PLAYPARTSF_FLUSH;
	PlayParts(mtStart, mtEnd, mtOffset, rtOffset, 0, pPerformance, dwPartFlags, dwFlags, fReLoop);

	if (fReLoop)
	{
		dwPartFlags = PLAYPARTSF_RELOOP;
		if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
		PlayParts(mtStart, mtEnd, mtOffset, rtOffset, 0, pPerformance, dwPartFlags, dwFlags, fReLoop);
	}

	if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat &&  !fClockTime &&
		( mtNotify < mtEnd ) )
	{
		NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// MotifTrackInfo

MotifTrackInfo::MotifTrackInfo() : 
	m_pPattern(NULL)
{
	m_dwPatternTag = DMUS_PATTERN_MOTIF;
}

MotifTrackInfo::~MotifTrackInfo()
{
	if (m_pPattern) m_pPattern->Release();
}

HRESULT MotifTrackInfo::Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT MotifTrackInfo::InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	IDirectMusicSegment* pSegment = NULL;
	MotifTrackState* pStateData = new MotifTrackState;
	if( NULL == pStateData )
	{
		return E_OUTOFMEMORY;
	}
	*ppStateData = pStateData;
	StatePair SP(pSegmentState, pStateData);
	TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
	if (!pPair) return E_OUTOFMEMORY;
	m_StateList.AddHead(pPair);
	TListItem<StylePair>* pHead = m_pISList.GetHead();
	if (!pHead || !pHead->GetItemValue().m_pStyle) return E_FAIL;
	pHead->GetItemValue().m_pStyle->GetStyleInfo((void **)&pStateData->m_pStyle);
	pStateData->m_pTrack = pParentrack;
	pStateData->m_pPatternTrack = this;
	pStateData->m_dwVirtualTrackID = dwTrackID;
	pStateData->m_pPattern = NULL;
	pStateData->InitPattern(m_pPattern, 0);
	pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
	pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
	pStateData->m_mtPerformanceOffset = 0;
	pStateData->m_mtCurrentChordTime = 0;
	pStateData->m_mtNextChordTime = 0;
 	pStateData->m_mtMotifStart = 0;
	HRESULT hr = pStateData->ResetMappings();
	if (FAILED(hr)) return hr;
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fStateActive = m_fActive;
    }
    else
    {
        pStateData->m_fStateActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
	if (m_lRandomNumberSeed)
	{
		pStateData->InitVariationSeeds(m_lRandomNumberSeed);
	}
	if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
	{
		if (FAILED(pSegment->GetTrackGroup(pStateData->m_pTrack, &pStateData->m_dwGroupID)))
		{
			pStateData->m_dwGroupID = 0xffffffff;
		}
		pSegment->Release();
	}
	return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
// CMotifTrack

CMotifTrack::CMotifTrack() : 
	m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
	InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	srand((unsigned int)time(NULL));
	m_pTrackInfo = new MotifTrackInfo;
}

CMotifTrack::CMotifTrack(const CMotifTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
	m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
	InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	srand((unsigned int)time(NULL));
	m_pTrackInfo = new MotifTrackInfo((MotifTrackInfo*)rTrack.m_pTrackInfo, mtStart, mtEnd);
}

CMotifTrack::~CMotifTrack()
{
	if (m_pTrackInfo)
	{
		delete m_pTrackInfo;
	}
    if (m_fCSInitialized)
    {
    	::DeleteCriticalSection( &m_CriticalSection );
    }
	InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CMotifTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
	V_INAME(CMotifTrack::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
	}
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
	}
    else if (iid == IID_IMotifTrack)
    {
        *ppv = static_cast<IMotifTrack*>(this);
    }
	else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMotifTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMotifTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init

HRESULT CMotifTrack::Init( 
    /* [in] */ IDirectMusicSegment __RPC_FAR *pSegment)
{
	V_INAME(CMotifTrack::Init);
	V_INTERFACE(pSegment);

	HRESULT hr = S_OK;
	if (!m_pTrackInfo)
		return DMUS_E_NOT_INIT;

	EnterCriticalSection( &m_CriticalSection );
	hr = m_pTrackInfo->MergePChannels();
	if (SUCCEEDED(hr))
	{
		pSegment->SetPChannelsUsed(m_pTrackInfo->m_dwPChannels, m_pTrackInfo->m_pdwPChannels);
		hr = m_pTrackInfo->Init(pSegment);
	}
    LeaveCriticalSection( &m_CriticalSection );

	return hr;
}

HRESULT CMotifTrack::InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	V_INAME(CMotifTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	EnterCriticalSection( &m_CriticalSection );
	HRESULT hr = S_OK;
	if (!m_pTrackInfo)
	{
		LeaveCriticalSection( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	hr = m_pTrackInfo->InitPlay(this, pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
    LeaveCriticalSection( &m_CriticalSection );
	return hr;

}


HRESULT CMotifTrack::EndPlay(
				/*[in]*/  void*		pStateData
			)
{
	V_INAME(CMotifTrack::EndPlay);
	V_BUFPTR_WRITE(pStateData, sizeof(MotifTrackState));

	HRESULT hr = DMUS_E_NOT_INIT;

	EnterCriticalSection( &m_CriticalSection );
	if (m_pTrackInfo)
	{
		hr = m_pTrackInfo->EndPlay((MotifTrackState*)pStateData);
	}
    LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

HRESULT CMotifTrack::Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID,
						  BOOL fClockTime
				)
{
	V_INAME(CMotifTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(MotifTrackState));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegState);

	HRESULT hr = DMUS_E_NOT_INIT;
	EnterCriticalSection( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LeaveCriticalSection( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	MotifTrackState* pSD = (MotifTrackState *)pStateData;
	if (pSD && pSD->m_pMappings)
	{
		BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
		BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
		BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
		BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
 		if (fStart || fSeek || fLoop || fControl)
		{
			pSD->m_fNewPattern = TRUE;
			pSD->m_mtCurrentChordTime = 0;
			pSD->m_mtNextChordTime = 0;
			pSD->m_mtLaterChordTime = 0;
//			pSD->m_CurrentChord.bSubChordCount = 0;
			for (DWORD dw = 0; dw < m_pTrackInfo->m_dwPChannels; dw++)
			{
				pSD->m_pMappings[dw].m_mtTime = 0;
				pSD->m_pMappings[dw].m_dwPChannelMap = m_pTrackInfo->m_pdwPChannels[dw];
				pSD->m_pMappings[dw].m_fMute = FALSE;
			}
		}
		hr = pSD->Play(mtStart, mtEnd, mtOffset, rtOffset, pPerf, dwFlags, fClockTime);
	}
	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}


HRESULT CMotifTrack::GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			)
	{
		return E_NOTIMPL;
	}

HRESULT CMotifTrack::GetParam( 
	REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMotifTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_PTR_WRITE(pData,1);
	V_REFGUID(rCommandGuid);

	EnterCriticalSection( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LeaveCriticalSection( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	HRESULT hr = S_OK;
	if( GUID_Valid_Start_Time == rCommandGuid )
	{
		if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_MOTIF) hr = E_FAIL;
		else
		{
			MotifTrackInfo* pTrackInfo = (MotifTrackInfo*)m_pTrackInfo;
			if (!pTrackInfo->m_pPattern) hr = E_POINTER;
			else
			{
				DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
				TListItem<MUSIC_TIME>* pScan = pTrackInfo->m_pPattern->m_StartTimeList.GetHead();
				for (; pScan; pScan = pScan->GetNext())
				{
					if (pScan->GetItemValue() >= mtTime)
					{
						pValidStartData->mtTime = pScan->GetItemValue() - mtTime;
						break;
					}
				}
				if (!pScan) hr = DMUS_E_NOT_FOUND;
				else
				{
					if (pmtNext)
					{
						if (pScan = pScan->GetNext())
						{
							*pmtNext = pScan->GetItemValue() - mtTime;
						}
						else
						{
							*pmtNext = 0;
						}
					}
					hr = S_OK;
				}
			}
		}
	}
	else
	{
		hr = DMUS_E_GET_UNSUPPORTED;
	}

	LeaveCriticalSection( &m_CriticalSection );
	return hr;
} 

HRESULT CMotifTrack::SetParam( 
	REFGUID	rguid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
	V_INAME(CMotifTrack::SetParam);
	V_PTR_WRITE_OPT(pData,1);
	V_REFGUID(rguid);

	EnterCriticalSection( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LeaveCriticalSection( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}

	HRESULT hr = DMUS_E_SET_UNSUPPORTED;
	if( rguid == GUID_EnableTimeSig )
	{
		if( m_pTrackInfo->m_fStateSetBySetParam && m_pTrackInfo->m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
		else
		{
			m_pTrackInfo->m_fStateSetBySetParam = TRUE;
			m_pTrackInfo->m_fActive = TRUE;
			hr = S_OK;
		}
	}
	else if( rguid == GUID_DisableTimeSig )
	{
		if( m_pTrackInfo->m_fStateSetBySetParam && !m_pTrackInfo->m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
		else
		{
			m_pTrackInfo->m_fStateSetBySetParam = TRUE;
			m_pTrackInfo->m_fActive = FALSE;
			hr = S_OK;
		}
	}
	else if ( rguid == GUID_SeedVariations )
	{
		if (pData)
		{
			m_pTrackInfo->m_lRandomNumberSeed = *((long*) pData);
			hr = S_OK;
		}
		else hr = E_POINTER;
	}
	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

// IPersist methods
 HRESULT CMotifTrack::GetClassID( LPCLSID pClassID )
{
	V_INAME(CMotifTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMotifTrack;
	return S_OK;
}

HRESULT CMotifTrack::IsParamSupported(
				/*[in]*/ REFGUID	rGuid
			)
{
	V_INAME(CMotifTrack::IsParamSupported);
	V_REFGUID(rGuid);

	if (!m_pTrackInfo)
	{
		return DMUS_E_NOT_INIT;
	}

	if ( rGuid == GUID_SeedVariations || rGuid == GUID_Valid_Start_Time )
	{
		return S_OK;
	}
    else if (m_pTrackInfo->m_fStateSetBySetParam)
    {
		if( m_pTrackInfo->m_fActive )
		{
			if( rGuid == GUID_DisableTimeSig ) return S_OK;
			if( rGuid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
		}
		else
		{
			if( rGuid == GUID_EnableTimeSig ) return S_OK;
			if( rGuid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
		}
	}
    else
    {
		if(( rGuid == GUID_DisableTimeSig ) ||
		   ( rGuid == GUID_EnableTimeSig ) )
		{
			return S_OK;
		}
    }
	return DMUS_E_TYPE_UNSUPPORTED;

}

// IPersistStream methods
 HRESULT CMotifTrack::IsDirty()
{
	 return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CMotifTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

	return E_NOTIMPL;
}

HRESULT CMotifTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CMotifTrack::Load(LPSTREAM pStream )
{
	return E_NOTIMPL;
}

HRESULT CMotifTrack::SetTrack(IUnknown* pStyle, void* pPattern)
{
	if (!pStyle) return E_POINTER;
	HRESULT hr = E_FAIL;
	EnterCriticalSection( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LeaveCriticalSection( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	MotifTrackInfo* pTrackInfo = (MotifTrackInfo*)m_pTrackInfo;
	if (m_pTrackInfo->m_dwPatternTag == DMUS_PATTERN_MOTIF)
	{
		IDMStyle* pIS = NULL;
		hr = pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
		if (SUCCEEDED(hr))
		{
			if (pTrackInfo->m_pPattern) pTrackInfo->m_pPattern->Release();
			pTrackInfo->m_pPattern = (CDirectMusicPattern*) pPattern;
			if (pTrackInfo->m_pPattern) pTrackInfo->m_pPattern->AddRef();
			pTrackInfo->InitTrackVariations(pTrackInfo->m_pPattern);
			TListItem<StylePair>* pNew = new TListItem<StylePair>;
			if (!pNew) hr = E_OUTOFMEMORY;
			else
			{
				pNew->GetItemValue().m_mtTime = 0;
				pNew->GetItemValue().m_pStyle = pIS;
				pTrackInfo->m_pISList.AddTail(pNew);
				hr = S_OK;
			}
			pIS->Release();
		}
	}
	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMotifTrack::AddNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	V_INAME(CMotifTrack::AddNotificationType);
	V_REFGUID(rGuidNotify);

	HRESULT hr = S_OK;
	EnterCriticalSection( &m_CriticalSection );
	if (m_pTrackInfo)
		hr = m_pTrackInfo->AddNotificationType(rGuidNotify);
	else
		hr = DMUS_E_NOT_INIT;
	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMotifTrack::RemoveNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	V_INAME(CMotifTrack::RemoveNotificationType);
	V_REFGUID(rGuidNotify);

	HRESULT hr = S_OK;
	EnterCriticalSection( &m_CriticalSection );
	if (m_pTrackInfo)
		hr = m_pTrackInfo->RemoveNotificationType(rGuidNotify);
	else
		hr = DMUS_E_NOT_INIT;
	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMotifTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(CMotifTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
		return E_INVALIDARG;
	}

	EnterCriticalSection( &m_CriticalSection );
    CMotifTrack *pDM;
    try
    {
        pDM = new CMotifTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
		LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

STDMETHODIMP CMotifTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CMotifTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
	return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

STDMETHODIMP CMotifTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CMotifTrack::Play( 
    void *pStateData,	// @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart,	// @parm The start time to play.
    MUSIC_TIME mtEnd,	// @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
						// <om IDirectMusicPerformance.SendPMsg>.
	DWORD dwFlags,		// @parm Flags that indicate the state of this call.
						// See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
						// normal Play call continuing playback from the previous
						// Play call.
	IDirectMusicPerformance* pPerf,	// @parm The <i IDirectMusicPerformance>, used to
						// call <om IDirectMusicPerformance.AllocPMsg>,
						// <om IDirectMusicPerformance.SendPMsg>, etc.
	IDirectMusicSegmentState* pSegSt,	// @parm The <i IDirectMusicSegmentState> this
						// track belongs to. QueryInterface() can be called on this to
						// obtain the SegmentState's <i IDirectMusicGraph> in order to
						// call <om IDirectMusicGraph.StampPMsg>, for instance.
	DWORD dwVirtualID	// @parm This track's virtual track id, which must be set
						// on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
						// will be queued to <om IDirectMusicPerformance.SendPMsg>.
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	EnterCriticalSection(&m_CriticalSection);
	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
	LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CMotifTrack::Compose(
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CMotifTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\mutetrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       mutetrk.h
//
//--------------------------------------------------------------------------

// MuteTrk.h : Declaration of the CMuteTrack

#ifndef __MUTETRACK_H_
#define __MUTETRACK_H_

#include "tlist.h"
#include "dmsect.h"
#include "dmusici.h"

// A mute track will have a list of lists of time-stamped MuteData mappings

struct MapSequence
{
	DWORD				m_dwPChannel;
	TList<MuteMapping>	m_Mappings;
};

/////////////////////////////////////////////////////////////////////////////
// CMuteTrack
class CMuteTrack : 
	public IDirectMusicTrack8,
	public IPersistStream
{
public:
	CMuteTrack();
	CMuteTrack(const CMuteTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CMuteTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

public:
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// CMuteTrack members
protected:
	void Clear();
    long m_cRef;
	TList<MapSequence>			m_MapSequenceList; // one MapSequence per PChannel
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;

	BYTE						m_bRequiresSave;
};

#endif //__MUTETRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\oledll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.cpp
//
//--------------------------------------------------------------------------

// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\motiftrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       motiftrk.h
//
//--------------------------------------------------------------------------

// MotifTrk.h : Declaration of the CMotifTrack

#ifndef __MOTIFTRACK_H_
#define __MOTIFTRACK_H_

//#include "resource.h"       // main symbols
#include "Ptrntrk.h"

struct MotifTrackInfo : public PatternTrackInfo
{
	MotifTrackInfo();
	MotifTrackInfo(const MotifTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) 
		: PatternTrackInfo(pInfo, mtStart, mtEnd), 
		  m_pPattern(NULL)	
	{
		m_dwPatternTag = DMUS_PATTERN_MOTIF;
		if (pInfo)
		{
			m_pPattern = pInfo->m_pPattern;
			InitTrackVariations(m_pPattern);
			if (m_pPattern) m_pPattern->AddRef();
		}
	}
	~MotifTrackInfo();
	virtual HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

	virtual HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

	CDirectMusicPattern*		m_pPattern; // The motif's pattern
};

/////////////////////////////////////////////////////////////////////////////
// CMotifTrack
class CMotifTrack : 
	public IMotifTrack,
	public IDirectMusicTrack8,
	public IPersistStream

{
public:
	CMotifTrack();
	CMotifTrack(const CMotifTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
	~CMotifTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IMotifTrack
public:
// IMotifTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID	rCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);


// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;


// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle, void* pPattern);


// IMotifTrack data members
protected:
// new internal play method
HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID,
						  BOOL fClockTime
			);

	// attributes
    long m_cRef;
    CRITICAL_SECTION			m_CriticalSection; // for load and playback
    BOOL                        m_fCSInitialized;
	PatternTrackInfo*			m_pTrackInfo;
	BYTE						m_bRequiresSave;
};

struct MotifTrackState : public PatternTrackState
{
	MotifTrackState();
	~MotifTrackState();
	// methods
	HRESULT Play(
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  IDirectMusicPerformance* pPerformance,
						  DWORD						dwFlags,
						  BOOL fClockTime

			);


	// attributes
	MUSIC_TIME					m_mtMotifStart;		// When the motif started relative to
													// its primary segment
};


#endif //__MOTIFTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\mutetrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       mutetrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// MuteTrk.cpp : Implementation of CMuteTrack
#include <objbase.h>
#include "MuteTrk.h"
#include "debug.h"
#include "debug.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CMuteTrack

CMuteTrack::CMuteTrack() : m_bRequiresSave(0),
	m_cRef(1), m_fCSInitialized(FALSE)

{
	InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CMuteTrack::CMuteTrack(const CMuteTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
	m_bRequiresSave(0), 
	m_cRef(1), m_fCSInitialized(FALSE)

{
	InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	TListItem<MapSequence>* pSeqScan = rTrack.m_MapSequenceList.GetHead();
	for(; pSeqScan; pSeqScan = pSeqScan->GetNext())
	{
		MapSequence& rSeqScan = pSeqScan->GetItemValue();
		TListItem<MapSequence>* pNewSeq = new TListItem<MapSequence>;
		if (!pNewSeq) break;
		MapSequence& rNewSeq = pNewSeq->GetItemValue();
		rNewSeq.m_dwPChannel = rSeqScan.m_dwPChannel;
		TListItem<MuteMapping>* pScan = rSeqScan.m_Mappings.GetHead();
		TListItem<MuteMapping>* pPrevious = NULL;
		for(; pScan; pScan = pScan->GetNext())
		{
			MuteMapping& rScan = pScan->GetItemValue();
			if (rScan.m_mtTime < mtStart)
			{
				pPrevious = pScan;
			}
			else if (rScan.m_mtTime < mtEnd)
			{
				if (rScan.m_mtTime == mtStart)
				{
					pPrevious = NULL;
				}
				TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
				if (pNew)
				{
					MuteMapping& rNew = pNew->GetItemValue();
					rNew.m_mtTime = rScan.m_mtTime - mtStart;
					rNew.m_dwPChannelMap = rScan.m_dwPChannelMap;
					rNew.m_fMute = rScan.m_fMute;
					rNewSeq.m_Mappings.AddTail(pNew);
				}
			}
			else break;
		}
		if (pPrevious)
		{
			TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
			if (pNew)
			{
				MuteMapping& rNew = pNew->GetItemValue();
				rNew.m_mtTime = 0;
				rNew.m_dwPChannelMap = pPrevious->GetItemValue().m_dwPChannelMap;
				rNew.m_fMute = pPrevious->GetItemValue().m_fMute;
				rNewSeq.m_Mappings.AddHead(pNew);
			}
		}
		if (rNewSeq.m_Mappings.GetHead())
		{
			m_MapSequenceList.AddTail(pNewSeq);
		}
		else
		{
			delete pNewSeq;
		}
	}
}

CMuteTrack::~CMuteTrack()
{
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }
	InterlockedDecrement(&g_cComponent);
}

void CMuteTrack::Clear()
{
	m_MapSequenceList.CleanUp();
}

STDMETHODIMP CMuteTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
	V_INAME(CMuteTrack::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
	}
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMuteTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMuteTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


// CMuteTrack Methods
HRESULT CMuteTrack::Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			)
{
	V_INAME(CMuteTrack::Init);
	V_INTERFACE(pSegment);

	return S_OK;
}

HRESULT CMuteTrack::InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	EnterCriticalSection( &m_CriticalSection );
	LeaveCriticalSection( &m_CriticalSection );
	return S_OK;
}

HRESULT CMuteTrack::EndPlay(
				/*[in]*/  void*						pStateData
			)
{
	return S_OK;
}

HRESULT CMuteTrack::Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			)
{
	EnterCriticalSection( &m_CriticalSection );
	// For now: do nothing.
    LeaveCriticalSection( &m_CriticalSection );
	return DMUS_S_END;
}

HRESULT CMuteTrack::GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			)
	{
		return E_NOTIMPL;
	}

HRESULT CMuteTrack::GetParam( 
	REFGUID	rCommandGuid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMuteTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_PTR_WRITE(pData,1);
	V_REFGUID(rCommandGuid);

	if (rCommandGuid != GUID_MuteParam) return DMUS_E_TYPE_UNSUPPORTED;

	HRESULT hr = S_OK;
	DMUS_MUTE_PARAM* pDMUS_MUTE_PARAM = (DMUS_MUTE_PARAM*) pData;

	MUSIC_TIME mtLength = 0;
	HRESULT hrMute = E_FAIL;
	EnterCriticalSection( &m_CriticalSection );
//	if (m_pSegment) hrMute = m_pSegment->GetLength(&mtLength);
	TListItem<MapSequence>* pSeqScan = m_MapSequenceList.GetHead();
	// Find a matching map sequence
	for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
	{
		if (pSeqScan->GetItemValue().m_dwPChannel == pDMUS_MUTE_PARAM->dwPChannel) break;
	}
	if (pSeqScan)
	{
		// Find the maps directly before (or at) and directly after mtTime
		TListItem<MuteMapping>* pScan = pSeqScan->GetItemValue().m_Mappings.GetHead();
		TListItem<MuteMapping>* pPrevious = NULL;
		for( ; pScan; pScan = pScan->GetNext())
		{
			MUSIC_TIME mt = pScan->GetItemValue().m_mtTime;
			if (mt <= mtTime)
			{
				pPrevious = pScan;
			}
			/*
			// If we're at the end of the segment...
			else if (SUCCEEDED(hrMute) && mtTime == mtLength - 1 && mt == mtLength)
			{
				pPrevious = pScan;
				pScan = NULL;
				break;
			}
			*/
			else
			{
				break;
			}
		}
		if (pPrevious)
		{
			pDMUS_MUTE_PARAM->dwPChannelMap = pPrevious->GetItemValue().m_dwPChannelMap;
			pDMUS_MUTE_PARAM->fMute = pPrevious->GetItemValue().m_fMute;
			//*pmtNext = (pScan) ? (pScan->GetItemValue().m_mtTime - mtTime) : 0; // RSW: bug 167740
		}
		else 
		// Nothing in the list is <= mtTime, so return a map that maps to itself, and the time
		// of the first mapping in the list
		{
			pDMUS_MUTE_PARAM->dwPChannelMap = pDMUS_MUTE_PARAM->dwPChannel;
			pDMUS_MUTE_PARAM->fMute = FALSE;
			//*pmtNext = (pScan) ? (pScan->GetItemValue().m_mtTime - mtTime) : 0; // RSW: bug 167740
		}
		if (pmtNext)
		{
			if (pScan)
			{
				/*
				// If we have a mute at the end of the segment...
				if (SUCCEEDED(hrMute) && pScan->GetItemValue().m_mtTime >= mtLength)
				{
					*pmtNext = (mtLength - 1) - mtTime;
				}
				else
				*/
				{
					*pmtNext = pScan->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
				}
			}
			else
			{
				/*
				if (SUCCEEDED(hrMute))
				{
					mtLength -= mtTime;
					if (mtLength < 0) mtLength = 0;
				}
				*/
				*pmtNext = mtLength;
			}
		}
	}
	else
	{
		// assume something that maps to itself, with a next time of 0
		pDMUS_MUTE_PARAM->dwPChannelMap = pDMUS_MUTE_PARAM->dwPChannel;
		pDMUS_MUTE_PARAM->fMute = FALSE;
		if (pmtNext)
		{
			*pmtNext = 0;
		}
		hr = S_OK;
	}
	LeaveCriticalSection( &m_CriticalSection );
	return hr;
} 

HRESULT CMuteTrack::SetParam( 
	REFGUID	rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
	V_INAME(CMuteTrack::SetParam);
	V_PTR_WRITE(pData,1);
	V_REFGUID(rCommandGuid);

	if (rCommandGuid != GUID_MuteParam) return DMUS_E_TYPE_UNSUPPORTED;

	HRESULT hr = S_OK;
	DMUS_MUTE_PARAM* pDMUS_MUTE_PARAM = (DMUS_MUTE_PARAM*) pData;
	EnterCriticalSection( &m_CriticalSection );
	TListItem<MapSequence>* pSeqScan = m_MapSequenceList.GetHead();
	for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
	{
		if (pSeqScan->GetItemValue().m_dwPChannel == pDMUS_MUTE_PARAM->dwPChannel) break;
	}
	// make a new mapping
	TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
	if (pNew)
	{
		MuteMapping& rNew = pNew->GetItemValue();
		rNew.m_mtTime = mtTime;
		rNew.m_dwPChannelMap = pDMUS_MUTE_PARAM->dwPChannelMap;
		rNew.m_fMute = pDMUS_MUTE_PARAM->fMute;
		if (pSeqScan)
		{
			// add the mapping to the current list
			pSeqScan->GetItemValue().m_Mappings.AddTail(pNew);
		}
		else
		{
			// make a list containing the mapping, and add it to the sequence list
			TListItem<MapSequence>* pNewSeq = new TListItem<MapSequence>;
			if (pNewSeq)
			{
				MapSequence& rNewSeq = pNewSeq->GetItemValue();
				rNewSeq.m_dwPChannel = pDMUS_MUTE_PARAM->dwPChannel;
				rNewSeq.m_Mappings.AddTail(pNew);
				m_MapSequenceList.AddTail(pNewSeq);
			}
			else
			{
				delete pNew;
				pNew = NULL;
			}
		}
	}
    if (!pNew)
	{
		hr = E_OUTOFMEMORY;
	}
	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

// IPersist methods
 HRESULT CMuteTrack::GetClassID( LPCLSID pClassID )
{
	V_INAME(CMuteTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMuteTrack;
	return S_OK;
}

HRESULT CMuteTrack::IsParamSupported(
				/*[in]*/ REFGUID	rGuid
			)
{
	V_INAME(CMuteTrack::IsParamSupported);
	V_REFGUID(rGuid);

    return rGuid == GUID_MuteParam ? S_OK : DMUS_E_TYPE_UNSUPPORTED;
}

// IPersistStream methods
 HRESULT CMuteTrack::IsDirty()
{
	 return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CMuteTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
	V_INAME(CMuteTrack::Save);
	V_INTERFACE(pStream);

	IAARIFFStream* pRIFF ;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_MUTE	oMute;
	TListItem<MapSequence>* pSeqScan = m_MapSequenceList.GetHead();

	EnterCriticalSection( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF  );
	if (!SUCCEEDED(hr))
	{
		goto ON_END;
	}
    hr = E_FAIL;
    ck.ckid = DMUS_FOURCC_MUTE_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_MUTE );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
			if (SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_END;
        }
        for( ; pSeqScan; pSeqScan = pSeqScan->GetNext() )
        {
			MapSequence& rSeqScan = pSeqScan->GetItemValue();
			DWORD dwPChannel = rSeqScan.m_dwPChannel;
			TListItem<MuteMapping>* pScan = rSeqScan.m_Mappings.GetHead();
			for( ; pScan; pScan = pScan->GetNext() )
			{
				MuteMapping& rScan = pScan->GetItemValue();
				memset( &oMute, 0, sizeof( oMute ) );
				oMute.mtTime = rScan.m_mtTime;
				oMute.dwPChannel = dwPChannel;
				oMute.dwPChannelMap = rScan.m_fMute ? DMUS_PCHANNEL_MUTE : rScan.m_dwPChannelMap;
				if( FAILED( pStream->Write( &oMute, sizeof( oMute ), &cb ) ) ||
					cb != sizeof( oMute ) )
				{
					break;
				}
			}
		}
        if( pSeqScan == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release();
	LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CMuteTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
	return E_NOTIMPL;
}

BOOL Less(MuteMapping& Mute1, MuteMapping& Mute2)
{ return Mute1.m_mtTime < Mute2.m_mtTime; }

HRESULT CMuteTrack::Load(LPSTREAM pStream )
{
	V_INAME(CMuteTrack::Load);
	V_INTERFACE(pStream);

    long lFileSize = 0;
	DWORD dwNodeSize;
	DWORD		cb;
    MMCKINFO        ck;
    IAARIFFStream*  pRIFF;
    FOURCC id = 0;
	HRESULT         hr = S_OK;
	DMUS_IO_MUTE		iMute;
    DWORD dwPos;
	TListItem<MapSequence>* pSeqScan;

	EnterCriticalSection( &m_CriticalSection );
	Clear();
	dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
	{
		if (pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
			ck.ckid == DMUS_FOURCC_MUTE_CHUNK)
		{
			lFileSize = ck.cksize;
			hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
			if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
			{
				lFileSize -= 4; // for the size dword
				while( lFileSize > 0 )
				{
					// Once DMUS_IO_MUTE changes, add code here to handle the old struct
					if( dwNodeSize <= sizeof( DMUS_IO_MUTE ) )
					{
						pStream->Read( &iMute, dwNodeSize, NULL );
					}
					else
					{
						pStream->Read( &iMute, sizeof( DMUS_IO_MUTE ), NULL );
						StreamSeek( pStream, lFileSize - sizeof( DMUS_IO_MUTE ), STREAM_SEEK_CUR );
					}
					pSeqScan = m_MapSequenceList.GetHead();
					for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
					{
						if (pSeqScan->GetItemValue().m_dwPChannel == iMute.dwPChannel) break;
					}
					// make a new mapping
					TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
					if (pNew)
					{
						MuteMapping& rNew = pNew->GetItemValue();
						memset( &rNew, 0, sizeof( rNew ) );
						rNew.m_mtTime = iMute.mtTime;
						rNew.m_dwPChannelMap = iMute.dwPChannelMap;
						rNew.m_fMute = (iMute.dwPChannelMap == DMUS_PCHANNEL_MUTE) ? TRUE : FALSE;
						if (pSeqScan)
						{
							// add the mapping to the current list
							pSeqScan->GetItemValue().m_Mappings.AddTail(pNew);
						}
						else
						{
							// make a list containing the mapping, and add it to the sequence list
							TListItem<MapSequence>* pNewSeq = new TListItem<MapSequence>;
							if (pNewSeq)
							{
								MapSequence& rNewSeq = pNewSeq->GetItemValue();
								rNewSeq.m_dwPChannel = iMute.dwPChannel;
								rNewSeq.m_Mappings.AddTail(pNew);
								m_MapSequenceList.AddTail(pNewSeq);
							}
							else
							{
								delete pNew;
								pNew = NULL;
							}
						}
					}
					if (!pNew)
					{
						hr = E_OUTOFMEMORY;
					}
					lFileSize -= dwNodeSize;
				}
			}
			if( SUCCEEDED(hr) && 
				lFileSize == 0 &&
				pRIFF->Ascend( &ck, 0 ) == 0 )
			{
				pSeqScan = m_MapSequenceList.GetHead();
				for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
				{
					pSeqScan->GetItemValue().m_Mappings.MergeSort(Less);
				}
			}
			else if (SUCCEEDED(hr)) hr = E_FAIL;
		}
		pRIFF->Release();
	}
    LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMuteTrack::AddNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CMuteTrack::RemoveNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CMuteTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(CMuteTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
		return E_INVALIDARG;
	}

	EnterCriticalSection( &m_CriticalSection );
    CMuteTrack *pDM;
    
    try
    {
        pDM = new CMuteTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
		LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	LeaveCriticalSection( &m_CriticalSection );
	return hr;
}

STDMETHODIMP CMuteTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CMuteTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
	return SetParam(rguidType, (MUSIC_TIME) rtTime, pParam);
}

STDMETHODIMP CMuteTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);


	EnterCriticalSection( &m_CriticalSection );
	// For now: do nothing.
    LeaveCriticalSection( &m_CriticalSection );
	return DMUS_S_END;
}


STDMETHODIMP CMuteTrack::Compose(
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CMuteTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\str.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       str.h
//
//--------------------------------------------------------------------------

//
// string.h
//

#include <objbase.h>

#ifndef __BRSTRING_H__
#define __BRSTRING_H__

class Archive;

class String
{
    friend String operator+( const String& str1, const String& str2 );
    friend String operator+( const String& str1, LPCSTR lpszStr );
    friend String operator+( LPCSTR lpszStr, const String& str1 );
    friend String operator+( const String& str1, char ch );
    friend String operator+( char ch, const String& str1 );

public:
    String();
    String( LPCSTR lpszStr );
    String( const String& str );
    String( LPCWSTR pszWstr );
    ~String();

    //BOOL LoadString( UINT nID, HINSTANCE hInstance );

    BOOL IsEmpty() const
    {
        return ( m_wLength == 0 );
    };
    WORD GetLength() const
    {
        return m_wLength;
    };
    int Compare( const String& str ) const
    {
		if (m_pBuf && str.m_pBuf)
		{
			return _wcsicmp( m_pBuf, str.m_pBuf );
		}
		else if (!m_pBuf && !str.m_pBuf)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    int Compare( LPCWSTR lpwzStr ) const
    {
		if (m_pBuf && lpwzStr)
		{
			return _wcsicmp( m_pBuf, lpwzStr );
		}
		else if (!m_pBuf && !lpwzStr)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    void Concat( const String& str );
    void Concat( LPCWSTR lpwzStr );
    void Concat( WCHAR wch );
    void TrimTrailingSpaces();
    WCHAR GetAt( UINT nIndex ) const
    {
        if( nIndex >= m_wLength )
        {
            return L'\0';
        }
        return m_pBuf[nIndex];
    };
    void SetAt( UINT nIndex, char ch )
    {
        if( nIndex < m_wLength )
        {
            m_pBuf[nIndex] = ch;
        }
    };
    HRESULT ReadWCS( LPSTREAM pStream, DWORD cSize );
    //HRESULT WriteWCS( LPSTREAM pStream );

// operators
    const String& operator+=( const String& str )   // concatenation
    {
        Concat( str );
        return *this;
    };
    const String& operator+=( LPCSTR lpszStr )      // concatenation
    {
        Concat( lpszStr );
        return *this;
    };
    const String& operator+=( char ch )             // concatenation
    {
        Concat( ch );
        return *this;
    };
    String& operator=( const String& str );
	String& operator=( LPCSTR pszStr );
    String& operator=( LPCWSTR pszWstr );
    operator const WCHAR*() const
    {
        return m_pBuf;
    }

private:
    WORD figureblocksize( WORD slen )
    {
        ++slen;         // for '\0'
        slen = static_cast<WORD>( slen / sm_wBlockSize );
        return static_cast<WORD>( ( slen + 1 ) * sm_wBlockSize );
    };

private:
    WORD m_wLength;
    WORD m_wAllocated;
    WCHAR* m_pBuf;

    static WORD sm_wBlockSize;  // size blocks are allocated in for strings
};

inline BOOL operator==( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator==( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) == 0 );
}

inline BOOL operator==( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator!=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator!=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) != 0 );
}

inline BOOL operator!=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator<( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator<( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) > 0 );
}

inline BOOL operator<( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator>( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator>( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) < 0 );
}

inline BOOL operator>( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator<=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator<=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) >= 0 );
}

inline BOOL operator<=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}

inline BOOL operator>=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}
#endif // __BRSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmstyle

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmstyle.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\user32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
	   $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\ole32.lib

INCLUDES=$(INCLUDES);   \
    ..\..\shared

SOURCES=..\alist.cpp           \
..\chordtrk.cpp                \
..\cmmdtrk.cpp                 \
..\debug.cpp                   \
..\dmsect.cpp                  \
..\dmstydll.cpp                \
..\dmstyle.cpp                 \
..\fileio.cpp                  \
..\motiftrk.cpp                \
..\oledll.cpp                  \
..\ptrntrk.cpp                 \
..\str.cpp                     \
..\styletrk.cpp                \
..\audtrk.cpp                  \
..\mutetrk.cpp                 \
..\dmstyle.rc                  \
..\opnew.cpp                   \
..\dmstyle2.cpp                \
..\filter.cpp                  \
..\mgentrk.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\score.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       score.h
//
//--------------------------------------------------------------------------

#ifndef __SCORE_H__
#define __SCORE_H__

/*  Defines ============================================================*/

#define INUM                16  // Number of band members
#define PPQN                192 // Pulses per quarter note
#define PPQNx4              ( PPQN << 2 )
#define PPQN_2              ( PPQN >> 1 )

#define ROOT_MIN            0   // Scale (or chord) root min and max
#define ROOT_MAX            23

// Section Flags, WPARAM of SECTION_STARTED/ENDED
#define SECF_STOPPED_EARLY  0x0001
#define SECF_IS_TRANSITION  0x0002

/*  Section Commands ===================================================*/

#define SCTSEC_PLAY_SECTION         2
#define SCTSEC_SET_ROOT             4
//#define SCTSEC_SET_STYLE            6
#define SCTSEC_SET_LENGTH           8
#define SCTSEC_SET_REPEATS          9
//#define SCTSEC_SET_PERSONALITY      15

#define BAND_MELODY   0     // Use BAND flags with RTC_SET_VOLUME,
#define BAND_STRING   1     // RTC_SET_PAN, RTC_SET_PATCH, SCTSEC_SET_VOLUME,
#define BAND_GUITAR   2     // SCTSEC_SET_PAN and SCTSEC_SET_PATCH
#define BAND_PIANO    3
#define BAND_BASS     4     // These are the default SCT band members
#define BAND_DRUM     5

#define BAND_ALL      50
#define BAND_NONE     51

#define SP_A        1       // Use SP flags for templates
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

/*  Band member mute flags =============================================*/

#define MUTE_MELODY   0x0001   // Use MUTE flags with sctSetMutes()
#define MUTE_STRING   0x0002
#define MUTE_GUITAR   0x0004
#define MUTE_PIANO    0x0008
#define MUTE_BASS     0x0010
#define MUTE_DRUM     0x0020
#define MUTE_ALL      0xFFFF

/*  SCTchord bBits flags ===============================================*/

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// Options for sctComposeTransitionEx

#define TRANS_CHANGE    1   // Chord transitions to next section instead of resolving
#define TRANS_LONG      2   // Transition lasts two measures, not one

/*  Structures maintained by SuperJAM! Technology Engine ==============*/

#pragma pack(1)

typedef struct SCTchord     FAR *LPSCTCHORD ;
typedef struct SCTchord
{
    LPSCTCHORD      pNext;         /* The next chord in the list.      */
    long            lDLL1;          /*   Reserved for use by score.dll  */
    long            lPattern;       /* Pattern that defines chord.      */
    char            achName[12];    /* Chord name.                      */
    char            chDLL2;         /*   Reserved for use by score.dll  */
    char            chRoot;         /* Root note of chord.              */
    char            chDLL3;         /*   Reserved for use by score.dll  */
    char            chFlat;         /* Indicates root is flat.          */
    short           nDLL4;          /*   Reserved for use by score.dll  */
    short           nMeasure;       /* Measure this chord occurs.       */
    char            chBeat;         /* Beat this chord falls on.        */
    BYTE            bBits;          /* Flags used when playing chord    */
    long            lScalePattern;  /* Scale Pattern for the chord.     */
    long            lMelodyPattern; /* Melody Pattern for the chord.    */
} SCTchord ;

typedef struct SCTpersonality FAR *LPSCTPERSONALITY ;
typedef struct SCTpersonality
{
    LPSCTPERSONALITY pNext ;       /* Next SCTpersonality in the list. */
    char        achName[20] ;       /* Name of composition personality. */
    char        achDescription[80];/* Description of personality.      */
    char        achUserName[20];/* Description of personality.      */
    LPVOID      lpDLL1 ;            /*   Reserved for use by score.dll  */
    long        lScalePattern ;     /* Scale pattern used by personality*/
    SCTchord    chord[24] ;         /* 24 note chord palette.           */
    char        chDefault ;         /* 0=Not default. 1=Default.        */
    char        chDLL1 ;            /*  Reserved for use by score.dll   */
} SCTpersonality ;

typedef struct SCTstyle     FAR *LPSCTSTYLE ;
typedef struct SCTstyle
{
    LPSCTSTYLE   pNext ;           /* Pointer to next SCTstyle.        */
    LPSTR        lpszFileName ;     /* File name of style.              */
    LPSTR        lpszName ;         /* Style name.                      */
    LPVOID       lpDLL1 ;           /*   Reserved for use by score.dll  */
    LPSCTPERSONALITY lpSCTpersonalityList ;  /* Available personalities.*/
    short        nBeatNote ;        /* Note receiving one beat.         */
    short        nBeatsPerMeasure ; /* Beats per measure.               */
    short        nMusicTimePerBeat ;/* Music time per beat.             */
    short        nClicksPerMeasure ;/* Clicks per measure.              */
    short        nMusicTimePerClick;/* Music time per click.            */
    short        nClicksPerBeat ;   /* Clicks per beat.                 */
    short        nDefaultTempo ;    /* Style's default tempo.           */
    void*        pIStyle;           // pointer to interface, used by AA 2.0+
} SCTstyle ;

typedef struct SCTrealtime  FAR *LPSCTREALTIME ;
typedef struct SCTrealtime
{
    short         nSizeofStruct ;   /* sizeof(struct SCTrealtime)       */
    LPSCTSTYLE    lpSCTstyle ;      /* Style played by house band       */
    LPSCTPERSONALITY lpSCTpersonality ;  /* Active personality          */
    short         nTempo ;          /* Current tempo                    */
    WORD          wTempoFract ;     /* Current tempo fraction (0-65535) */
    DWORD         dwGroove ;        /* Current groove                   */
    char          chRoot ;          /* Root note of key                 */
    char          chFlat ;          /* Indicates whether key is flat    */
    char          chAutoChord ;     /* 0=Off, 1=On                      */
    char          chAutoChordActivity ;  /* Amount of chord activity    */
} SCTrealtime ;

typedef struct SCTsectionInfo FAR *LPSCTSECTIONINFO ;
typedef struct SCTsectionInfo
{
    short         nSizeofStruct ;   /* sizeof(struct SCTsectionInfo)    */
    char          achName[16] ;     /* Section name.                    */
    LPSCTSTYLE    lpSCTstyle ;      /* Style played by the section.     */
    LPSCTPERSONALITY lpSCTpersonality ;  /* Active personality.         */
    short         nTempo ;          /* Section tempo.                   */
    WORD          wTempoFract ;     /* Section tempo fraction (0-65535) */
    short         nNbrMeasures ;    /* Nbr of measures in section.      */
    WORD          nNbrRepeats ;     /* Nbr of times section repeats.    */
    char          chRoot ;          /* Root note of section key.        */
    char          chFlat ;          /* Indicates whether key is flat.   */
} SCTsectionInfo ;

typedef struct SCTperformance FAR *LPSCTPERFORMANCE ;

typedef struct SCTsection     FAR *LPSCTSECTION ;
typedef struct SCTsection
{
    LPSCTSECTION     pNext ;          /* Pointer to next SCTsection      */
    LPSTR            lpszName ;        /* Section name.                   */
    LPVOID           lpDLL1 ;          /*   Reserved for use by score.dll */
    LPSCTPERFORMANCE lpSCTperf ;       /* Section belongs to this perf.   */
    LPSCTSTYLE       lpSCTstyle ;      /* Style played by the section.    */
    LPSCTPERSONALITY lpSCTpersonality ;/* Active personality.             */
    short            nTempo ;          /* Section tempo.                  */
    WORD             wTempoFract ;     /* Section tempo fraction (0-65535)*/
    short            nStartingMeasure ;/* Starting measure of section.    */
    short            nNbrMeasures ;    /* Nbr of measures in section.     */
    WORD             nNbrRepeats ;     /* Nbr of times section repeats.   */
    char             chRoot ;          /* Root note of section key.       */
    char             chFlat ;          /* Indicates whether key is flat   */
    long             lStartTime ;      /* Music start time of section.    */
    void*            pISection;        // pointer to interface, used by AA 2.0+
} SCTsection ;

//DM
typedef struct SCTmotif* LPSCTMOTIF;
typedef struct SCTmotif
{
    LPSCTMOTIF  pNext;
    LPVOID      lpDLL1;
    LPCSTR      lpszName;
    short       nMeasures;
    short       nBeatsPerMeasure;
    short       nClicksPerBeat;
} SCTmotif;
//DM - END

typedef struct SCTperformance
{
    LPSCTPERFORMANCE pNext ;          /* Pointer to next SCTperformance.*/
//    char             achSongName[20] ; /* Name of song.                  */
    LPSCTREALTIME    lpSCTrealtime ;   /* RealTime information.          */
    LPVOID           lpDLL1 ;          /*   Reserved for use by score.dll*/
//    short            nRelVolume ;      /* Relative volume.               */
//    short            nRelTempo ;       /* Relative tempo.                */
//    LPSTR            lpszSongTitle;
//    LPSTR            lpszSongAuthor;
//    LPSTR            lpszSongCopyright;
} SCTperformance ;

typedef struct SCTdata      FAR *LPSCTDATA ;
typedef struct SCTdata
{
    LPSCTSTYLE       lpSCTstyleList ;  /* List of opened styles.       */
    LPSCTPERFORMANCE lpSCTperformanceList ; /* List of performances.   */
//DM
    LPSCTMOTIF  lpSCTmotif;            // pointer to list of motifs
// DM - END
} SCTdata ;

typedef struct SCTcommand   FAR *LPSCTCOMMAND ;
typedef struct SCTcommand
{
    LPSCTCOMMAND  pNext ;    /* The next command in the list.    */
    long          lDLL1 ;     /*   Reserved for use by score.dll. */
    short         nMeasure ;  /* Measure this command occurs.     */
    DWORD         dwCommand ; /* Command type.                    */
    DWORD         dwChord ;   /* Signpost chord.                  */
} SCTcommand ;

typedef struct SCTtemplate  FAR *LPSCTTEMPLATE ;
typedef struct SCTtemplate
{
    LPSCTTEMPLATE pNext ;           /* The next template in the list.  */
    char          achName[20] ;      /* Template name.                  */
    char          achType[20] ;      /* Template type.                  */
    short         nMeasures ;
    LPSCTCOMMAND  lpSCTcommandList ; /* Template commands.              */
} SCTtemplate ;

#pragma pack()

/*  Function prototypes ============================================*/

LPSCTDATA WINAPI sctRegisterApplication(HWND,HWND,HINSTANCE,LPCSTR,LPDWORD,short);
void WINAPI sctUnregisterApplication(LPSCTDATA);

LPSCTSECTIONINFO WINAPI sctAllocSectionInfo(LPSCTPERFORMANCE,short);
void WINAPI sctFreeSectionInfo(LPSCTDATA,LPSCTSECTIONINFO);

DWORD WINAPI sctTimeToMeasure(LPSCTDATA,LPSCTSTYLE,DWORD);
DWORD WINAPI sctTimeToMils(LPSCTDATA,DWORD,short,unsigned short);

LPSCTCHORD WINAPI sctAllocChord(LPSCTDATA);
void WINAPI sctFreeChord(LPSCTDATA,LPSCTCHORD);
void WINAPI sctFreeChordList(LPSCTDATA,LPSCTCHORD);

LPSCTCHORD WINAPI sctGetChordListCopy(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctSetChordList(LPSCTDATA,LPSCTSECTION,LPSCTCHORD);

void WINAPI sctFreeCommandList(LPSCTDATA,LPSCTCOMMAND);

LPSCTCOMMAND WINAPI sctGetCommandListCopy(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctSetCommandList(LPSCTDATA,LPSCTSECTION,LPSCTCOMMAND);

LPSCTTEMPLATE WINAPI sctAllocTemplate(LPSCTDATA);
void WINAPI sctFreeTemplate(LPSCTDATA,LPSCTTEMPLATE);
BOOL WINAPI sctCreateTemplateSignPosts(LPSCTDATA,LPSCTTEMPLATE);
BOOL WINAPI sctCreateTemplateEmbellishments(LPSCTDATA,LPSCTTEMPLATE,short);

BOOL WINAPI sctBuildSection(LPSCTDATA,LPSCTSECTION,LPSCTPERSONALITY,short,short,short,DWORD);
BOOL WINAPI sctComposeSection(LPSCTDATA,LPSCTSECTION,LPSCTTEMPLATE,LPSCTPERSONALITY,short);
BOOL WINAPI sctComposeTransition(LPSCTDATA,LPSCTSECTION,LPSCTPERSONALITY,LPSCTCHORD,short,DWORD);
LPSCTSECTION WINAPI sctComposeTransitionEx( LPSCTDATA, LPSCTSECTION, LPSCTSECTION, short, DWORD, DWORD );

LPSCTSECTION WINAPI sctCreateSection(LPSCTPERFORMANCE,LPSCTSECTIONINFO);
void WINAPI sctDeleteSection(LPSCTDATA,LPSCTSECTION, BOOL fStop = TRUE);
LPSCTSECTION WINAPI sctDuplicateSection(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctQueueSectionEx( LPSCTDATA lpSCTdata, LPSCTSECTION lpSCTsection, DWORD dwStartTime );
BOOL WINAPI sctSectionCommand(LPSCTDATA,LPSCTSECTION,WORD,WORD,LONG,LONG);
BOOL WINAPI sctStopCurSectionASAP(LPSCTDATA);
BOOL WINAPI sctStopCurSection(LPSCTDATA,short);

LPSCTPERFORMANCE WINAPI sctCreatePerformance(LPSCTDATA,LPVOID);

//DM
BOOL WINAPI sctFreeMotif( LPSCTDATA, LPSCTMOTIF );

BOOL WINAPI sctSwitchPersonality( LPSCTDATA, LPSCTSECTION, LPSCTPERSONALITY, BOOL );

BOOL WINAPI sctSetQueuePrepareTime( WORD wPrepareTime );
//DM - END

#endif // __SCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\ptrntrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-2001 Microsoft Corporation
//
//  File:       ptrntrk.cpp
//
//--------------------------------------------------------------------------

// PtrnTrk.cpp : Implementation of the Pattern Track info and state structs

#include "PtrnTrk.h"

#include "dmusici.h"
#include "dmusicf.h"

#include "debug.h"

/////////////////////////////////////////////////////////////////////////////
// PatternTrackState

PatternTrackState::PatternTrackState() :
    m_pStyle(NULL),
    m_pSegState(NULL),
    m_pPerformance(NULL),
    m_mtPerformanceOffset(0),
    m_dwVirtualTrackID(0),
    m_pPatternTrack(NULL),
    m_pTrack(NULL),
    m_mtCurrentChordTime(0),
    m_mtNextChordTime(0),
    m_mtLaterChordTime(0),
    m_pPattern(NULL),
    m_pdwPChannels(NULL),
    m_pVariations(NULL),
    m_pdwVariationMask(NULL),
    m_pdwRemoveVariations(NULL),
    m_pmtPartOffset(NULL),
    m_nInversionGroupCount(0),
    m_fNewPattern(TRUE),
    m_fStateActive(TRUE),
//  m_fStatePlay(TRUE),
    m_pMappings(NULL),
    m_ppEventSeek(NULL),
    m_dwGroupID(0xffffffff),
    m_plVariationSeeds(NULL),
    m_nTotalGenerators(0),
    m_mtPatternStart(0),
    m_dwValidate(0),
    m_hrPlayCode(S_OK),
    m_pfChangedVariation(NULL)
{
    ZeroMemory(&m_NextChord, sizeof(DMUS_CHORD_PARAM));
    wcscpy(m_CurrentChord.wszName, L"M7");
    m_CurrentChord.wMeasure = 0;
    m_CurrentChord.bBeat = 0;
    m_CurrentChord.bSubChordCount = 1;
    m_CurrentChord.bKey = 12;
    m_CurrentChord.dwScale = DEFAULT_SCALE_PATTERN;
    m_CurrentChord.bFlags = 0;
    for (int n = 0; n < DMUS_MAXSUBCHORD; n++)
    {
        m_CurrentChord.SubChordList[n].dwChordPattern = DEFAULT_CHORD_PATTERN;
        m_CurrentChord.SubChordList[n].dwScalePattern = DEFAULT_SCALE_PATTERN;
        m_CurrentChord.SubChordList[n].dwInversionPoints = 0xffffff;
        m_CurrentChord.SubChordList[n].dwLevels = 0xffffffff;
        m_CurrentChord.SubChordList[n].bChordRoot = 12; // 2C
        m_CurrentChord.SubChordList[n].bScaleRoot = 0;
    }
    for (int i = 0; i < INVERSIONGROUPLIMIT; i++)
        m_aInversionGroups[i].m_wGroupID = 0;
}


PatternTrackState::~PatternTrackState()
{
    if (m_pmtPartOffset)
        delete [] m_pmtPartOffset;
    if (m_pdwPChannels)
        delete [] m_pdwPChannels;
    if (m_pVariations)
        delete [] m_pVariations;
    if (m_pdwVariationMask)
        delete [] m_pdwVariationMask;
    if (m_pdwRemoveVariations)
        delete [] m_pdwRemoveVariations;
    if (m_pMappings) delete [] m_pMappings;
    if (m_ppEventSeek) delete [] m_ppEventSeek;
    if (m_plVariationSeeds) delete [] m_plVariationSeeds;
    if (m_pPattern) m_pPattern->Release();
    if (m_pfChangedVariation)
    {
        delete [] m_pfChangedVariation;
    }
}


HRESULT PatternTrackState::InitPattern(CDirectMusicPattern* pTargetPattern, MUSIC_TIME mtNow, CDirectMusicPattern* pOldPattern)
{
    m_fNewPattern = TRUE;
    m_mtPatternStart = mtNow;
    short nPartCount = (short) pTargetPattern->m_PartRefList.GetCount();
    // initialize an array to keep track of variations in parts.
    // if the current pattern is the same as the previous pattern,
    // use the existing array.
    if (m_pPattern != pTargetPattern || pOldPattern)
    {
        ////////////////// create an array of variation bools //////////////////
        if (m_pfChangedVariation) delete [] m_pfChangedVariation;
        m_pfChangedVariation = new bool[nPartCount];
        if (!m_pfChangedVariation)
        {
            return E_OUTOFMEMORY;
        }
        ////////////////// create an array of part offsets //////////////////
        if (m_pmtPartOffset != NULL) delete [] m_pmtPartOffset;
        m_pmtPartOffset = new MUSIC_TIME[nPartCount];
        if (!m_pmtPartOffset)
        {
            return E_OUTOFMEMORY;
        }
        ////////////////// create an array of seek pointers //////////////////
        if (m_ppEventSeek) delete [] m_ppEventSeek;
        m_ppEventSeek = new CDirectMusicEventItem*[nPartCount];
        if (!m_ppEventSeek)
        {
            return E_OUTOFMEMORY;
        }
        ////////////////// create and initialize PChannels //////////////////
        if (m_pdwPChannels != NULL) delete [] m_pdwPChannels;
        m_pdwPChannels = new DWORD[nPartCount];
        if (!m_pdwPChannels)
        {
            return E_OUTOFMEMORY;
        }
        TListItem<DirectMusicPartRef>* pPartRef = pTargetPattern->m_PartRefList.GetHead();
        for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
        {
            m_pdwPChannels[i] = pPartRef->GetItemValue().m_dwLogicalPartID;
        }
        if (!pOldPattern ||
            pTargetPattern->m_strName != pOldPattern->m_strName ||
            nPartCount != pOldPattern->m_PartRefList.GetCount() )
        {
            ////////////////// create and initialize variations //////////////////
            if (m_pVariations != NULL) delete [] m_pVariations;
            m_pVariations = new BYTE[nPartCount];
            if (!m_pVariations)
            {
                return E_OUTOFMEMORY;
            }
            if (m_pdwVariationMask != NULL) delete [] m_pdwVariationMask;
            m_pdwVariationMask = new DWORD[nPartCount];
            if (!m_pdwVariationMask)
            {
                return E_OUTOFMEMORY;
            }
            if (m_pdwRemoveVariations != NULL) delete [] m_pdwRemoveVariations;
            m_pdwRemoveVariations = new DWORD[nPartCount];
            if (!m_pdwRemoveVariations)
            {
                return E_OUTOFMEMORY;
            }
            for (int i = 0; i < nPartCount; i++)
            {
                m_pdwVariationMask[i] = 0;
                if ( (pTargetPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) &&
                     m_pPatternTrack &&
                     m_pPatternTrack->m_pVariations &&
                     m_pPatternTrack->m_pdwRemoveVariations )
                {
                    m_pVariations[i] = m_pPatternTrack->m_pVariations[i];
                    m_pdwRemoveVariations[i] = m_pPatternTrack->m_pdwRemoveVariations[i];
                }
                else
                {
                    m_pVariations[i] = -1;
                    m_pdwRemoveVariations[i] = 0;
                }
            }
        }
    }
    // initialize the part offset array and seek pointer array.
    for (int i = 0; i < nPartCount; i++)
    {
        m_pmtPartOffset[i] = 0;
        m_ppEventSeek[i] = NULL;
    }

    // Set up the new pattern.
    if (m_pPattern != pTargetPattern)
    {
        pTargetPattern->AddRef();
        if (m_pPattern) m_pPattern->Release();
        m_pPattern = pTargetPattern;
    }
    return S_OK;
}

// This assumes the time sig remains constant for the length of the segment.
// If time sigs change, we won't necessarily have one generator per beat, but
// this will still give consistent playback behavior under most circumstances;
// the exception is a controlling segment that interupts somewhere after the
// time signature changes.
HRESULT PatternTrackState::InitVariationSeeds(long lBaseSeed)
{
    // Get the Segment length
    MUSIC_TIME mtLength = 0;
    IDirectMusicSegment* pSegment = NULL;
    if (m_pSegState)
    {
        if (SUCCEEDED(m_pSegState->GetSegment(&pSegment)))
        {
            pSegment->GetLength(&mtLength);
            pSegment->Release();
        }
    }
    else
    {
        return E_POINTER;
    }

    // Get the current time sig and use it to get the number of beats in the segment
    DirectMusicTimeSig TimeSig = PatternTimeSig();
    int nBeats = TimeSig.ClocksToBeat(mtLength);

    // Create an array with the required number of beats, and use the Base Seed to
    //   seed a random number generator at each beat
    if (m_plVariationSeeds) delete [] m_plVariationSeeds;
    m_plVariationSeeds = new CRandomNumbers[nBeats];
    if (!m_plVariationSeeds)
    {
        m_nTotalGenerators = 0;
        return E_OUTOFMEMORY;
    }
    else
    {
        m_nTotalGenerators = nBeats;
        for (int i = 0; i < nBeats; i++)
        {
            m_plVariationSeeds[i].Seed(lBaseSeed);
            lBaseSeed = m_plVariationSeeds[i].Next();
        }
        return S_OK;
    }
}

HRESULT PatternTrackState::RemoveVariationSeeds()
{
    if (m_plVariationSeeds) delete [] m_plVariationSeeds;
    m_plVariationSeeds = NULL;
    m_nTotalGenerators = 0;
    return S_OK;
}

long PatternTrackState::RandomVariation(MUSIC_TIME mtTime, long lModulus)
{
    if (m_plVariationSeeds)
    {
        DirectMusicTimeSig TimeSig = PatternTimeSig();
        int nBeat = TimeSig.ClocksToBeat(mtTime);
        // In case time sigs change somehow, make sure we get a valid generator
        if (nBeat >= m_nTotalGenerators) nBeat = m_nTotalGenerators - 1;
        return m_plVariationSeeds[nBeat].Next(lModulus);
    }
    else
    {
        // regular old rand...
        return rand() % lModulus;
    }
}

void PatternTrackState::GetNextChord(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fStart, BOOL fSkipVariations)
{
    HRESULT hr = S_OK;
    {
        hr = pPerformance->GetParam(GUID_ChordParam, m_dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
                                    &m_mtNextChordTime, (void*) &m_CurrentChord);
        if (SUCCEEDED(hr))
        {
            m_mtCurrentChordTime = mtNow;
            if (m_mtNextChordTime) m_mtNextChordTime += mtNow;
            TraceI(4, "[1] Offset: %d Next Chord: %d\n", mtOffset, m_mtNextChordTime);
#ifdef DBG
            if (!m_CurrentChord.bSubChordCount)
            {
                Trace(2, "Warning: Attempt to get a chord resulted in a chord with no subchords.\n");
            }
#endif
        }
    }
    // instead of failing here completely, I'll just give m_mtNextChordTime and m_CurrentChord
    // fallback values
    if (FAILED(hr))
    {
        m_mtCurrentChordTime = 0;
        m_mtNextChordTime = 0;
        if (!m_pStyle || !m_pStyle->UsingDX8()) // otherwise use current chord info
        {
            wcscpy(m_CurrentChord.wszName, L"M7");
            m_CurrentChord.wMeasure = 0;
            m_CurrentChord.bBeat = 0;
            m_CurrentChord.bSubChordCount = 1;
            m_CurrentChord.bKey = 12;
            m_CurrentChord.dwScale = DEFAULT_SCALE_PATTERN;
            m_CurrentChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
            m_CurrentChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
            m_CurrentChord.SubChordList[0].dwInversionPoints = 0xffffff;
            m_CurrentChord.SubChordList[0].dwLevels = 0xffffffff;
            m_CurrentChord.SubChordList[0].bChordRoot = 12; // 2C
            m_CurrentChord.SubChordList[0].bScaleRoot = 0;
        }
    }
    TraceI(3, "Current Chord: %d %s [%d] HRESULT: %x\n",
        m_CurrentChord.SubChordList[0].bChordRoot, m_CurrentChord.wszName, mtNow, hr);
    if (m_mtNextChordTime > 0)
    {
        hr = pPerformance->GetParam(GUID_ChordParam, m_dwGroupID, DMUS_SEG_ANYTRACK, m_mtNextChordTime + mtOffset,
                                    &m_mtLaterChordTime, (void*) &m_NextChord);
        if (SUCCEEDED(hr))
        {
            if (m_mtLaterChordTime) m_mtLaterChordTime += m_mtNextChordTime;
            TraceI(4, "[3] Offset: %d Later Chord: %d\n", mtOffset, m_mtLaterChordTime);
#ifdef DBG
            if (!m_NextChord.bSubChordCount)
            {
                Trace(2, "Warning: Attempt to get a chord resulted in a chord with no subchords.\n");
            }
#endif
        }
    }
    if (!fSkipVariations)
    {
        // Select a variation for each part in the pattern, based on the moaw and the
        // previous and next chords.
        DWORD dwFlags = 0;
        if (m_fNewPattern) dwFlags |= COMPUTE_VARIATIONSF_NEW_PATTERN;
        if (fStart) dwFlags |= COMPUTE_VARIATIONSF_START;
        if (m_pStyle && m_pStyle->UsingDX8()) dwFlags |= COMPUTE_VARIATIONSF_DX8;
        m_pPattern->ComputeVariations(dwFlags, m_CurrentChord, m_NextChord,
            m_abVariationGroups, m_pdwVariationMask, m_pdwRemoveVariations, m_pVariations, mtNow, m_mtNextChordTime, this);
        m_fNewPattern = FALSE;
        if ( (m_pPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) &&
              m_pPatternTrack &&
              m_pPatternTrack->m_pVariations &&
              m_pPatternTrack->m_pdwRemoveVariations)
        {
            // update track's m_pVariations and m_pdwRemoveVariations (for each part)
            for (int i = 0; i < m_pPattern->m_PartRefList.GetCount(); i++)
            {
                m_pPatternTrack->m_pVariations[i] = m_pVariations[i];
                m_pPatternTrack->m_pdwRemoveVariations[i] = m_pdwRemoveVariations[i];
            }
        }
    }
}

DMStyleStruct* PatternTrackState::FindStyle(MUSIC_TIME mtTime, MUSIC_TIME& rmtTime)
{
    IDMStyle* pStyle = NULL;
    DMStyleStruct* pResult = NULL;
    if (m_pPatternTrack && m_pPatternTrack->m_pISList.GetHead())
    {
        TListItem<StylePair>* pScan = m_pPatternTrack->m_pISList.GetHead();
        for(; pScan; pScan = pScan->GetNext())
        {
            if (pScan->GetItemValue().m_pStyle) break;
        }
        if (pScan)
        {
            pStyle = pScan->GetItemValue().m_pStyle;
            for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
            {
                StylePair& rScan = pScan->GetItemValue();
                if (rScan.m_pStyle)
                {
                    if ( mtTime < rScan.m_mtTime) break;
                    pStyle = rScan.m_pStyle;
                }
            }
            rmtTime = (pScan != NULL) ? pScan->GetItemValue().m_mtTime : 0;
            if (pStyle)
            {
                pStyle->GetStyleInfo((void**)&pResult);
            }
            else
            {
                return NULL;
            }
        }
    }
    return pResult;
}

DWORD PatternTrackState::Variations(DirectMusicPartRef&, int nPartIndex)
{
    return (m_pVariations[nPartIndex] == 0xff) ? 0 : (1 << m_pVariations[nPartIndex]);
}

BOOL PatternTrackState::PlayAsIs()
{
    return FALSE;
}

BOOL PatternTrackState::MapPChannel(DWORD dwPChannel, DWORD& dwMapPChannel)
{
    for (DWORD dw = 0; dw < m_pPatternTrack->m_dwPChannels; dw++)
    {
        if (m_pPatternTrack->m_pdwPChannels[dw] == dwPChannel)
        {
            dwMapPChannel = m_pMappings[dw].m_dwPChannelMap;
            return m_pMappings[dw].m_fMute;
        }
    }
    dwMapPChannel = 0;
    return FALSE;
}

inline int RandomExp(BYTE bRange)
{
    int nResult = 0;
    if (0 <= bRange && bRange <= 190)
    {
        nResult = bRange;
    }
    else if (191 <= bRange && bRange <= 212)
    {
        nResult = ((bRange - 190) * 5) + 190;
    }
    else if (213 <= bRange && bRange <= 232)
    {
        nResult = ((bRange - 212) * 10) + 300;
    }
    else // bRange > 232
    {
        nResult = ((bRange - 232) * 50) + 500;
    }
    return (rand() % nResult) - (nResult >> 1);
}

HRESULT PatternTrackState::PlayParts(MUSIC_TIME mtStart,
                                     MUSIC_TIME mtEnd,
                                     MUSIC_TIME mtOffset,
                                     REFERENCE_TIME rtOffset,
                                     MUSIC_TIME mtSection,
                                     IDirectMusicPerformance* pPerformance,
                                     DWORD dwPartFlags,
                                     DWORD dwPlayFlags,
                                     bool& rfReLoop)
{
    if (dwPlayFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    if (!m_pPattern) // This shouldn't happen
    {
        return DMUS_E_NOT_INIT;
    }

    HRESULT hr = S_OK;
    bool fClockTime = (dwPartFlags & PLAYPARTSF_CLOCKTIME) ? true : false;
    bool fStart = (dwPartFlags & PLAYPARTSF_START) ? true : false;
    bool fGetChordStart = fStart;
    bool fFirstCall = (dwPartFlags & PLAYPARTSF_FIRST_CALL) ? true : false;
    bool fReloop = (dwPartFlags & PLAYPARTSF_RELOOP) ? true : false;
    bool fFlush = (dwPartFlags & PLAYPARTSF_FLUSH) ? true : false;
    MUSIC_TIME mtNewChord = mtStart;

    TListItem<DirectMusicPartRef>* pPartRef = m_pPattern->m_PartRefList.GetHead();
    for (short i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
        m_pfChangedVariation[i] = false;
        MUSIC_TIME mtFinish = mtEnd;
        CurveSeek Curves;
        MUSIC_TIME mtNow = 0;
        DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
        DirectMusicTimeSig& TimeSig =
            (pPart->m_timeSig.m_bBeat != 0) ? pPart->m_timeSig : PatternTimeSig();
        MUSIC_TIME mtPartLength = TimeSig.ClocksPerMeasure() * pPart->m_wNumMeasures;
        if (fFirstCall)
        {
            if (fFlush)
            {
                GetNextMute(pPartRef->GetItemValue().m_dwLogicalPartID, 0, mtStart, mtOffset, pPerformance, fClockTime);
                m_ppEventSeek[i] = NULL;
            }
            if (fStart)
            {
                m_pmtPartOffset[i] = 0;
            }
            if (mtPartLength)
            {
                while (mtStart >= mtSection + m_pmtPartOffset[i] + mtPartLength)
                {
                    m_pmtPartOffset[i] += mtPartLength;
                }
            }
            if (mtFinish > mtSection + m_pmtPartOffset[i] + mtPartLength)
            {
                rfReLoop = TRUE;
                mtFinish = mtSection + m_pmtPartOffset[i] + mtPartLength;
            }
        }
        if (!fReloop || mtFinish > mtSection + m_pmtPartOffset[i] + mtPartLength)
        {
            if (fReloop)
            {
                m_pmtPartOffset[i] += mtPartLength;
            }
            CDirectMusicEventItem* pEvent = NULL;
            if (fFirstCall) pEvent = m_ppEventSeek[i];
            if (!pEvent) pEvent = pPart->EventList.GetHead();
            BumpTime(pEvent, TimeSig, mtSection + m_pmtPartOffset[i], mtNow);
            if (pEvent)
            {
                GetNextMute(pPartRef->GetItemValue().m_dwLogicalPartID, mtStart, mtNow, mtOffset, pPerformance, fClockTime);
            }
            while (pEvent != NULL && mtNow < mtFinish)
            {
                if (fFirstCall && fStart &&
                    mtNow < mtStart &&
                    pEvent->m_dwEventTag == DMUS_EVENT_CURVE)
                {
                    if (Variations(pPartRef->GetItemValue(), i) &
                        pEvent->m_dwVariation)
                    {
                        TraceI(4, "Found a curve\n");
                        Curves.AddCurve(pEvent, mtNow);
                    }
                }
                if (mtNow >= mtStart)
                {
                    if (mtNow < mtNewChord)
                    {
                        // Revert to the chord in effect at mtNow
                        TraceI(4, "WARNING: Reverting to chord at %d\n", mtNow);
                        GetNextChord(mtNow, mtOffset, pPerformance, (dwPartFlags & PLAYPARTSF_START) ? true : false);
                        mtNewChord = mtNow;
                    }
                    else if ((mtNow >= m_mtNextChordTime) || m_mtNextChordTime == 0)
                    {
                        TraceI(4, "Getting new chord.  Now: %d Next: %d\n", mtNow, m_mtNextChordTime);
                        GetNextChord(mtNow, mtOffset, pPerformance, fGetChordStart);
                        mtNewChord = mtNow;
                        fGetChordStart = false;
                    }
                    TraceI(4, "Play %d (%d + %d + %d)\n", mtNow, TimeSig.GridToClocks(pEvent->m_nGridStart), mtSection, m_pmtPartOffset[i]);
                    PlayPatternEvent(
                        mtNow,
                        pEvent,
                        TimeSig,
                        mtSection + m_pmtPartOffset[i],
                        mtOffset,
                        rtOffset,
                        pPerformance,
                        i,
                        pPartRef->GetItemValue(),
                        fClockTime,
                        0,
                        m_pfChangedVariation[i]);
                }
                pEvent = pEvent->GetNext();
                BumpTime(pEvent, TimeSig, mtSection + m_pmtPartOffset[i], mtNow);
                MUSIC_TIME mtMute = pEvent ? mtNow : mtFinish - 1;
                GetNextMute(pPartRef->GetItemValue().m_dwLogicalPartID, mtStart, mtMute, mtOffset, pPerformance, fClockTime);
            }
            m_ppEventSeek[i] = pEvent;
            // If we've got curve events, send them now
            if (fFirstCall && fStart)
            {
                TraceI(4, "Playing curves (after loop)\n");
                Curves.PlayCurves(this,
                        TimeSig,
                        mtSection + m_pmtPartOffset[i],
                        mtOffset,
                        rtOffset,
                        pPerformance,
                        i,
                        pPartRef->GetItemValue(),
                        fClockTime,
                        mtStart - (mtSection + m_pmtPartOffset[i]));
            }
        }
    }
    return hr;
}

// when creating a note event, both the passed in offset and the note's offset must
// be added to the note's time
void PatternTrackState::PlayPatternEvent(
        MUSIC_TIME mtNow,
        CDirectMusicEventItem* pEventItem,
        DirectMusicTimeSig& TimeSig,
        MUSIC_TIME mtPartOffset,
        MUSIC_TIME mtSegmentOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerformance,
        short nPart,
        DirectMusicPartRef& rPartRef,
        BOOL fClockTime,
        MUSIC_TIME mtPartStart,
        bool& rfChangedVariation)
{
    DMUS_NOTE_PMSG* pNote = NULL;
    DMUS_CURVE_PMSG* pCurve = NULL;
    DWORD dwMapPChannel = 0;
    BOOL fMute = MapPChannel(rPartRef.m_dwLogicalPartID, dwMapPChannel);
    if ( (!fMute) &&
         (Variations(rPartRef, nPart) & pEventItem->m_dwVariation) )
    {
        CDMStyleCurve* pCurveEvent = NULL;
        CDMStyleNote* pNoteEvent = NULL;
        CDMStyleMarker* pMarkerEvent = NULL;
        if (pEventItem->m_dwEventTag == DMUS_EVENT_MARKER) // we have a marker event
        {
            // If we're not ignoring marker events and we've hit a variation stop point that's
            // either not chord-aligned or on the chord, then get a new variation.
            pMarkerEvent = (CDMStyleMarker*)pEventItem;
            if ( (rPartRef.m_pDMPart && (rPartRef.m_pDMPart->m_dwFlags & DMUS_PARTF_USE_MARKERS)) &&
                 (pMarkerEvent->m_wFlags & DMUS_MARKERF_STOP) &&
                 (mtNow != m_mtPatternStart) &&
                 (!(pMarkerEvent->m_wFlags & DMUS_MARKERF_CHORD_ALIGN) ||
                   (mtNow == m_mtCurrentChordTime) ||
                   (mtNow == m_mtNextChordTime)) )
            {
                TraceI(3, "Computing variations at %d Pattern start: %d...\n", mtNow, m_mtPatternStart);
                DWORD dwFlags = COMPUTE_VARIATIONSF_NEW_PATTERN | COMPUTE_VARIATIONSF_MARKER;
                if ((pMarkerEvent->m_wFlags & DMUS_MARKERF_CHORD_ALIGN))
                {
                    dwFlags |= COMPUTE_VARIATIONSF_CHORD_ALIGN;
                }
                if (m_pStyle && m_pStyle->UsingDX8()) dwFlags |= COMPUTE_VARIATIONSF_DX8;
                if (rfChangedVariation) dwFlags |= COMPUTE_VARIATIONSF_CHANGED;
                m_pPattern->ComputeVariationGroup(
                    rPartRef,
                    nPart,
                    dwFlags,
                    m_CurrentChord,
                    m_NextChord,
                    m_abVariationGroups,
                    m_pdwVariationMask,
                    m_pdwRemoveVariations,
                    m_pVariations,
                    mtNow + pMarkerEvent->m_nTimeOffset,
                    m_mtNextChordTime,
                    this);
                rfChangedVariation = true;
                if ( (m_pPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) &&
                     m_pPatternTrack &&
                     m_pPatternTrack->m_pVariations &&
                     m_pPatternTrack->m_pdwRemoveVariations )
                {
                    // update track's m_pVariations and m_pdwRemoveVariations (for this part)
                    m_pPatternTrack->m_pVariations[nPart] = m_pVariations[nPart];
                    m_pPatternTrack->m_pdwRemoveVariations[nPart] = m_pdwRemoveVariations[nPart];
                }
            }
            else
            {
                TraceI(3, "NOT computing variations at %d Pattern start: %d  Chord times: %d, %d Flags: %x\n",
                    mtNow, m_mtPatternStart, m_mtCurrentChordTime, m_mtNextChordTime, pMarkerEvent->m_wFlags);
            }
        }
        else if (pEventItem->m_dwEventTag == DMUS_EVENT_CURVE) // we have a curve event
        {
            pCurveEvent = (CDMStyleCurve*)pEventItem;
            if (SUCCEEDED(pPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                    (DMUS_PMSG**) &pCurve)))
            {
                MUSIC_TIME mtSegmentTime = TimeSig.GridToClocks(pCurveEvent->m_nGridStart) +
                    pCurveEvent->m_nTimeOffset + mtPartOffset;
                if (fClockTime)
                {
                    pCurve->wMeasure = 0;
                    pCurve->bBeat = 0;
                    pCurve->bGrid = 0;
                    pCurve->nOffset = pCurveEvent->m_nTimeOffset;
                    pCurve->rtTime = (mtSegmentTime * REF_PER_MIL) + rtOffset;
                    pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    pCurve->wMeasure = (WORD)TimeSig.GridsToMeasure(pCurveEvent->m_nGridStart);
                    pCurve->bBeat = (BYTE)TimeSig.GridsToBeat(pCurveEvent->m_nGridStart);
                    pCurve->bGrid = (BYTE)TimeSig.GridOffset(pCurveEvent->m_nGridStart);
                    pCurve->nOffset = pCurveEvent->m_nTimeOffset;
                    pCurve->mtTime = mtSegmentTime + mtSegmentOffset;
                    pCurve->dwFlags = DMUS_PMSGF_MUSICTIME;
                }
                pCurve->mtResetDuration = pCurveEvent->m_mtResetDuration;
                pCurve->mtDuration = pCurveEvent->m_mtDuration;
                pCurve->nResetValue = pCurveEvent->m_nResetValue;
                pCurve->bFlags = pCurveEvent->m_bFlags;
                pCurve->dwType = DMUS_PMSGT_CURVE;
                pCurve->dwPChannel = dwMapPChannel;
                pCurve->dwVirtualTrackID = m_dwVirtualTrackID; // ??
                pCurve->nStartValue = pCurveEvent->m_StartValue;    // curve's start value
                pCurve->nEndValue = pCurveEvent->m_EndValue;    // curve's end value
                pCurve->bType = pCurveEvent->m_bEventType;  // type of curve
                pCurve->bCurveShape = pCurveEvent->m_bCurveShape;   // shape of curve
                pCurve->bCCData = pCurveEvent->m_bCCData;       // CC# if this is a control change type
                pCurve->dwGroupID = m_dwGroupID;
                pCurve->wParamType = pCurveEvent->m_wParamType;
                pCurve->wMergeIndex = pCurveEvent->m_wMergeIndex;
                // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                pCurve->dwFlags |= DMUS_PMSGF_DX8;
                if (mtPartStart) // only set on invalidation
                {
                    MUSIC_TIME mtOffset = mtPartOffset + mtSegmentOffset;
                    if (pCurve->mtTime + pCurve->mtDuration >= mtPartStart + mtOffset)
                    {
                        pCurve->mtOriginalStart = pCurve->mtTime;
                        pCurve->mtTime = mtPartStart + mtOffset;
                    }
                    else
                    {
                        pCurve->mtResetDuration -= (mtPartStart + mtOffset - pCurve->mtTime);
                        if (pCurve->mtResetDuration < 0) pCurve->mtResetDuration = 0;
                        pCurve->mtTime = mtPartStart + mtOffset;
                        pCurve->bCurveShape = DMUS_CURVES_INSTANT;
                    }
                }
                IDirectMusicGraph* pGraph;
                if( SUCCEEDED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
                    (void**)&pGraph )))
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pCurve );
                    pGraph->Release();
                }
                if(FAILED(pPerformance->SendPMsg( (DMUS_PMSG*)pCurve)))
                {
                    pPerformance->FreePMsg( (DMUS_PMSG*)pCurve);
                }
            }
        }
        else if (pEventItem->m_dwEventTag == DMUS_EVENT_NOTE) // we have a note event
        {
            pNoteEvent = (CDMStyleNote*)pEventItem;
            BYTE bPlayModeFlags =
                (pNoteEvent->m_bPlayModeFlags & DMUS_PLAYMODE_NONE) ?
                    rPartRef.m_pDMPart->m_bPlayModeFlags :
                    pNoteEvent->m_bPlayModeFlags;
            BYTE bMidiValue = 0;
            short nMidiOffset = 0;
            HRESULT hr = rPartRef.ConvertMusicValue(pNoteEvent,
                                      m_CurrentChord,
                                      bPlayModeFlags,
                                      PlayAsIs(),
                                      m_aInversionGroups,
                                      pPerformance,
                                      bMidiValue,
                                      nMidiOffset);
            if (SUCCEEDED(hr) &&
                SUCCEEDED(pPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG),
                    (DMUS_PMSG**) &pNote)))
            {
                pNote->bFlags = DMUS_NOTEF_NOTEON | pNoteEvent->m_bFlags;
                MUSIC_TIME mtSegmentTime = TimeSig.GridToClocks(pNoteEvent->m_nGridStart) +
                    pNoteEvent->m_nTimeOffset + mtPartOffset;
                if (fClockTime)
                {
                    pNote->wMeasure = 0;
                    pNote->bBeat = 0;
                    pNote->bGrid = 0;
                    pNote->nOffset = pNoteEvent->m_nTimeOffset;
                    pNote->rtTime = (mtSegmentTime * REF_PER_MIL) + rtOffset;
                    pNote->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    pNote->wMeasure = (WORD)TimeSig.GridsToMeasure(pNoteEvent->m_nGridStart);
                    pNote->bBeat = (BYTE)TimeSig.GridsToBeat(pNoteEvent->m_nGridStart);
                    pNote->bGrid = (BYTE)TimeSig.GridOffset(pNoteEvent->m_nGridStart);
                    pNote->nOffset = pNoteEvent->m_nTimeOffset;
                    pNote->mtTime = mtSegmentTime + mtSegmentOffset;
                    pNote->dwFlags = DMUS_PMSGF_MUSICTIME;
                }
                // time needs be jiggled by pNoteEvent->m_bTimeRange
                if (pNoteEvent->m_bTimeRange)
                    pNote->mtTime += RandomExp(pNoteEvent->m_bTimeRange);
                pNote->mtDuration = pNoteEvent->m_mtDuration;
                // duration needs be jiggled by pNoteEvent->m_bDurRange
                if (pNoteEvent->m_bDurRange)
                    pNote->mtDuration += RandomExp(pNoteEvent->m_bDurRange);
                    //  (rand() % pNoteEvent->m_bDurRange) - (pNoteEvent->m_bDurRange >> 1);
                pNote->bVelocity = pNoteEvent->m_bVelocity;
                // velocity needs be jiggled by pNoteEvent->m_bVelRange
                if (pNoteEvent->m_bVelRange)
                    pNote->bVelocity +=
                      (rand() % pNoteEvent->m_bVelRange) - (pNoteEvent->m_bVelRange >> 1);
                if (pNote->bVelocity < 1) pNote->bVelocity = 1;
                if (pNote->bVelocity > 127) pNote->bVelocity = 127;
                pNote->wMusicValue = pNoteEvent->m_wMusicValue;
                pNote->bMidiValue = bMidiValue;
                pNote->dwType = DMUS_PMSGT_NOTE;
                pNote->bPlayModeFlags = bPlayModeFlags;
                pNote->dwPChannel = dwMapPChannel;
                pNote->dwVirtualTrackID = m_dwVirtualTrackID; // ??
                pNote->bSubChordLevel = rPartRef.m_bSubChordLevel;
                pNote->dwGroupID = m_dwGroupID;
                pNote->bTimeRange = pNoteEvent->m_bTimeRange;
                pNote->bDurRange = pNoteEvent->m_bDurRange;
                pNote->bVelRange = pNoteEvent->m_bVelRange;
                pNote->cTranspose = (char) nMidiOffset;

                IDirectMusicGraph* pGraph;
                if( SUCCEEDED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
                    (void**)&pGraph )))
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pNote );
                    pGraph->Release();
                }

                if (pNote->dwFlags & DMUS_PMSGF_REFTIME)
                {
                    TraceI(5, "PLAY %d @%d\n", rPartRef.m_dwLogicalPartID,
                        (MUSIC_TIME)