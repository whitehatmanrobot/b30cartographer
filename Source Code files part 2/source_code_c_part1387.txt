arginFromStyle = FALSE;

    // Update the state of the line array.
    Reset(iLineStart);

    // go back to find the first line which is clear (i.e., a line
    // with default margins)
    y = yHeight;
    iAt = -1;

    First(iLineFirst);

    for (pLine = Prev(); pLine; pLine = Prev())
    {
        if (pLine->IsFrame())
        {
            // Cache the line which is aligned
            iAt = At();
        }
        else
        {
            if (pLine->HasMargins(pLine->oi()))
            {
                // current line has margins
                if(pLine->_fForceNewLine)
                    y -= pLine->_yHeight;
            }
            else
                break;
        }
    }

    // iAt now holds the last aligned frame line we saw while walking back,
    // and pLine is either NULL or points to the first clear line (i.e.,
    // no margins were specified).  The Rclclptr state (_iLine) also indexes
    // that clear line.

    // y is the y coordinate of first clear line.

    // if there were no frames there is nothing to do...
    if (iAt == -1)
        return;

    // There are aligned sites, so calculate margins.
    int             iLeftAlignedImages = 0;
    int             iRightAlignedImages = 0;
    CAlignedLine *  pALine;
    CLineCore *     pLineLeftTop = NULL;
    CLineCore *     pLineRightTop = NULL;
    
    // stacks to keep track of the number of left & right aligned sites
    // adding margins to the current line.
    _aryLeftAlignedImgs.SetSize(0);
    _aryRightAlignedImgs.SetSize(0);

    // have to adjust the height of the aligned frames.
    // iAt is the last frame line we saw, so start there and
    // walk forward until we get to iLineFirst.

    // _yBottomLeftMargin and _yBottomRightMargin are the max y values
    // for which the current left/right margin values are valid; i.e.,
    // once y increases past _yBottomLeftMargin, there's a new left margin
    // that must be used.
    
    for (pLine = First(iAt);
        pLine && At() <= iLineFirst;
        pLine = Next())
    {

        // update y to skip by 
        if(At() == iLineFirst)
            y += yBeforeSpace;
        else
        {
            // Include the text or center aligned height
            if (pLine->_fForceNewLine)
            {
                y += pLine->_yHeight;
            }
        }

        // If there are any left aligned images
        while(iLeftAlignedImages)
        {
            // check to see if we passed the left aligned image, if so pop it of the
            // stack and set its height
            pALine = & _aryLeftAlignedImgs [ iLeftAlignedImages - 1 ];

            if(y >= pALine->_pLine->_yHeight + pALine->_yLine)
            {
                _aryLeftAlignedImgs.Delete( -- iLeftAlignedImages );
            }
            else
                break;
        }
        // If there are any right aligned images
        while(iRightAlignedImages)
        {
            pALine = & _aryRightAlignedImgs [ iRightAlignedImages - 1 ];

            // check to see if we passed the right aligned image, if so pop it of the
            // stack and set its height
            if(y >= pALine->_pLine->_yHeight + pALine->_yLine)
            {
                _aryRightAlignedImgs.Delete( -- iRightAlignedImages );
            }
            else
                break;
        }

        if (pLine->IsFrame() && At() != iLineFirst)
        {
            HRESULT hr = S_OK;
            const CFancyFormat * pFF = pLine->AO_GetFancyFormat(NULL);
            CAlignedLine al;

            al._pLine = pLine;
            al._yLine = y;

            // If the current line is left aligned push it on to the left aligned images
            // stack and adjust the _yBottomLeftMargin.
            if (pLine->IsLeftAligned())
            {
                //
                // If the current aligned element needs to clear left, insert
                // the current aligned layout below all other left aligned
                // layout's since it is the last element that establishes
                // the margin.
                //
                if ((pFF && pFF->_fClearLeft)
                    || (pLine->oi()->_fHasFloatedFL && pLine->_fClearBefore))
                {
                    hr = _aryLeftAlignedImgs.InsertIndirect(0, &al);

                    if (hr)
                        return;
                }
                else
                {
                    CAlignedLine *  pAlignedLine;

                    hr = _aryLeftAlignedImgs.AppendIndirect(NULL, &pAlignedLine);

                    if (hr)
                        return;

                    *pAlignedLine = al;
                }

                iLeftAlignedImages++;

                if (y + pLine->_yHeight > _marginInfo._yBottomLeftMargin)
                {
                    _marginInfo._yBottomLeftMargin = y + pLine->_yHeight;
                }
            }
            // If the current line is right aligned push it on to the right aligned images
            // stack and adjust the _yBottomRightMargin.
            else if (pLine->IsRightAligned())
            {
                //
                // If the current aligned element needs to clear right, insert
                // the current aligned layout below all other right aligned
                // layout's since it is the last element that establishes
                // the margin.
                //
                if (pFF && pFF->_fClearRight)
                {
                    hr = _aryRightAlignedImgs.InsertIndirect(0, &al);

                    if (hr)
                        return;
                }
                else
                {
                    CAlignedLine *  pAlignedLine;

                    hr = _aryRightAlignedImgs.AppendIndirect(NULL, &pAlignedLine);

                    if (hr)
                        return;

                    *pAlignedLine = al;
                }

                iRightAlignedImages++;

                if (y + pLine->_yHeight > _marginInfo._yBottomRightMargin)
                {
                    _marginInfo._yBottomRightMargin = y + pLine->_yHeight;
                }
            }
        }
    }

    // Only use remaining floated objects.
    _fMarginFromStyle = FALSE;

    // If we have any left aligned sites left on the stack, calculate the
    // left margin.
    if(iLeftAlignedImages)
    {
        CLineOtherInfo *pLineLeftTopOI;
        const CFancyFormat *pFF;
        
        // get the topmost left aligned line and compute the current lines
        // left margin
        pALine = & _aryLeftAlignedImgs [ iLeftAlignedImages - 1 ];
        pLineLeftTop = pALine->_pLine;
        pLineLeftTopOI = pLineLeftTop->oi();
        if(!_pdp->IsRTLDisplay())
            _marginInfo._xLeftMargin = pLineLeftTopOI->_xLeftMargin + pLineLeftTop->_xLineWidth;
        else
        {
            _marginInfo._xLeftMargin = max(0L, xWidth - pLineLeftTopOI->_xRightMargin);
            // TODO RTL 112514: this is probably bogus. how to get here?
            Assert(_marginInfo._xLeftMargin == pLineLeftTopOI->_xLeftMargin + pLineLeftTop->_xLineWidth 
                   || !IsTagEnabled(tagDebugRTL));
        }
        _marginInfo._yLeftMargin = pLineLeftTop->_yHeight + pALine->_yLine;

        // Note if a "frame" margin may be needed
        _marginInfo._fAddLeftFrameMargin = pLineLeftTop->_fAddsFrameMargin;

        // Note whether margin space is due to CSS float (as opposed to ALIGN attr).
        // We need to know this because if it's CSS float, we autoclear after the line.
        pFF = pLineLeftTop->AO_GetFancyFormat(pLineLeftTopOI);
        _fMarginFromStyle |= pFF && pFF->_fCtrlAlignFromCSS;
    }
    else
    {
        // no left aligned sites for the current line, so set the margins to
        // defaults.
        _marginInfo._yBottomLeftMargin = MINLONG;
        _marginInfo._yLeftMargin = MAXLONG;
        _marginInfo._xLeftMargin = 0;
    }
    // If we have any right aligned sites left on the stack, calculate the
    // right margin.
    if(iRightAlignedImages)
    {
        CLineOtherInfo *pLineRightTopOI;
        const CFancyFormat *pFF;
        
        // get the topmost right aligned line and compute the current lines
        // right margin
        pALine = & _aryRightAlignedImgs [ iRightAlignedImages - 1 ];
        pLineRightTop = pALine->_pLine;
        pLineRightTopOI = pLineRightTop->oi();
        if(!_pdp->IsRTLDisplay())
            _marginInfo._xRightMargin = max(0L, xWidth - pLineRightTopOI->_xLeftMargin);
        else
        {
            _marginInfo._xRightMargin = pLineRightTopOI->_xRightMargin + pLineRightTop->_xLineWidth;
            // TODO RTL 112514: this is probably bogus. how to get here?
            Assert(_marginInfo._xRightMargin == max(0L, xWidth - pLineRightTopOI->_xLeftMargin)
                   || !IsTagEnabled(tagDebugRTL));
        }
        _marginInfo._yRightMargin = pLineRightTop->_yHeight + pALine->_yLine;

        // Note if a "frame" margin may be needed
        _marginInfo._fAddRightFrameMargin = pLineRightTop->_fAddsFrameMargin;

        // Note whether margin space is due to CSS float (as opposed to ALIGN attr).
        // We need to know this because if it's CSS float, we autoclear after the line.
        pFF = pLineRightTop->AO_GetFancyFormat(pLineRightTopOI);
        _fMarginFromStyle |= pFF && pFF->_fCtrlAlignFromCSS;
    }
    else
    {
        // no right aligned sites for the current line, so set the margins to
        // defaults.
        _marginInfo._yBottomRightMargin = MINLONG;
        _marginInfo._yRightMargin = MAXLONG;
        _marginInfo._xRightMargin = 0;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     AlignObjects
//
//  Synopsis:   Process all aligned objects on a line and create new
//              "frame" lines for them.
//
//  Arguments:  [pMe]              --  measurer used to recalc lines
//              [uiFlags]          --  flags
//              [iLineStart]       --  new lines start at
//              [iLineFirst]       --  line to start calculating from
//              [pyHeight]         --  y coordinate of the top of line
//
//-------------------------------------------------------------------------
int CRecalcLinePtr::AlignObjects(
    CLSMeasurer *pme,
    CLineFull   *pLineMeasured,
    LONG         cch,
    BOOL         fMeasuringSitesAtBOL,
    BOOL         fBreakAtWord,
    BOOL         fMinMaxPass,
    int          iLineStart,
    int          iLineFirst,
    LONG        *pyHeight,
    int          xWidthMax,
    LONG        *pyAlignDescent,
    LONG        *pxMaxLineWidth)
{
    CFlowLayout *       pFlowLayout = _pdp->GetFlowLayout();
    CLayout *           pLayout;
    LONG                xWidth      = pFlowLayout->GetMaxLineWidth();
    htmlControlAlign    atSite;
    CLineCore *         pLine;
    CLineCore *         pLineNew;
    CLineFull           lifNew;
    LONG                yHeight;
    LONG                yHeightCurLine = 0;
    int                 xMin = 0;
    int                 iClearLines=0;
    CTreePos           *ptp;
    CTreeNode          *pNodeLayout;
    LONG                cchInTreePos;

    CLayoutContext     *pLayoutContext = _pci->GetLayoutContext();
    BOOL                fViewChain     = (pLayoutContext && pLayoutContext->ViewChain());
    CFlowLayoutBreak   *pEndingBreak   = NULL; 

    if (fViewChain)
    {
        // 
        // Retrieve ending layout break to provide access to Site Tasks queue.
        // 
        CLayoutBreak *pLayoutBreak;

        pLayoutContext->GetEndingLayoutBreak(_pdp->GetFlowLayoutElement(), &pLayoutBreak);
        if (pLayoutBreak)
        {
            pEndingBreak = DYNCAST(CFlowLayoutBreak, pLayoutBreak);
        }
    }

    Reset(iLineStart);
    pLine = (*this)[iLineFirst];

    // Make sure the current line has aligned sites
    Assert(pLine->_fHasAligned);

    yHeight = *pyHeight;

    // If we are measuring sites at the beginning of the line,
    // measurer is positioned at the current site. So we dont
    // need to back up the measurer. Also, margins the current
    // line apply to the line being inserted before the current
    // line.
    if(!fMeasuringSitesAtBOL)
    {
        // fliForceNewLine is set for lines that have text in them.
        Assert (pLine->_fForceNewLine);

        // adjust the height and recalc the margins for the aligned
        // lines being inserted after the current line
        yHeightCurLine = pLine->_yHeight;
        yHeight += yHeightCurLine;

        if (fViewChain)
        {
            //  Adjust Y consumed if this is not BOL
            _pci->_yConsumed += yHeightCurLine;
        }

        iLineFirst++;
        if (!IsValidMargins(yHeight))
        {
            RecalcMargins(iLineStart, iLineFirst, yHeight, 0);
        }
    }

    ptp = pme->GetPtp();
    pNodeLayout = ptp->GetBranch();
    if (ptp->IsText())
        cchInTreePos = ptp->Cch() - (pme->GetCp() - ptp->GetCp());
    else
        cchInTreePos = ptp->GetCch();
    while (cch > 0)
    {
        if (ptp->IsBeginElementScope())
        {
            pNodeLayout = ptp->Branch();
            if (pNodeLayout->ShouldHaveLayout())
            {
                const CCharFormat  * pCF = pNodeLayout->GetCharFormat( LC_TO_FC(_pci->GetLayoutContext()) );
                const CParaFormat  * pPF = pNodeLayout->GetParaFormat( LC_TO_FC(_pci->GetLayoutContext()) );
                const CFancyFormat * pFF = pNodeLayout->GetFancyFormat( LC_TO_FC(_pci->GetLayoutContext()) );
                BOOL        fClearLeft      = pFF->_fClearLeft;
                BOOL        fClearRight     = pFF->_fClearRight;
                CElement *  pElementLayout  = pNodeLayout->Element();
                
                cchInTreePos = pme->GetNestedElementCch(pElementLayout, &ptp);
                
                atSite = pNodeLayout->GetSiteAlign( LC_TO_FC(_pci->GetLayoutContext()) );

                if ( !pCF->IsDisplayNone() && pFF->_fAlignedLayout)
                {
                    LONG xWidthSite, yHeightSite, yBottomMarginSite;

                    pLayout = pNodeLayout->GetUpdatedLayout( _pci->GetLayoutContext() );
 
                    // measuring sites at the Beginning of the line,
                    // insert the aligned line before the current line
                    lifNew.Init();
                    if(fMeasuringSitesAtBOL)
                    {
                        pLineNew = InsertLine(iLineFirst);
                        if (!pLineNew)
                            goto Cleanup;
                        
                        lifNew._fFrameBeforeText = TRUE;
                        lifNew._yBeforeSpace = pLineMeasured->_yBeforeSpace;
                    }
                    else
                    {
                        // insert the aligned line after the current line
                        pLineNew = AddLine();
                        if (!pLineNew)
                            goto Cleanup;

                        lifNew._fHasEOP = (*this)[iLineFirst - 1]->_fHasEOP;
                    }

                    // Update the line width and new margins caused by the aligned line
                    for(;;)
                    {
                        int     yConsumedSafe = 0;
                        BOOL    fLayoutOverflowSafe = FALSE;

                        if (fViewChain)
                        {
                            //  save consumed space
                            yConsumedSafe = _pci->_yConsumed;
                            //  save overflow flag 
                            fLayoutOverflowSafe = _pci->_fLayoutOverflow;

                            //  make adjustments to Y consumed if the align object has clear attribute(s)
                            if(atSite == htmlAlignLeft)
                            {
                                if (    fClearLeft
                                    && _marginInfo._xLeftMargin
                                    &&  lifNew._yBeforeSpace < _marginInfo._yBottomLeftMargin - yHeight)
                                {
                                    _pci->_yConsumed += (_marginInfo._yBottomLeftMargin - yHeight);
                                }
                            }
                            else if(atSite == htmlAlignRight)
                            {
                                if (    fClearRight
                                    &&  _marginInfo._xRightMargin
                                    &&  lifNew._yBeforeSpace < _marginInfo._yBottomRightMargin - yHeight)
                                {
                                    _pci->_yConsumed += (_marginInfo._yBottomRightMargin - yHeight);
                                }
                            }
                        }

                        // Measure the site
                        pme->GetSiteWidth(pNodeLayout, pLayout, _pci, fBreakAtWord,
                                          max(0l, xWidthMax - _xLayoutLeftIndent - _xLayoutRightIndent),
                                          &xWidthSite, &yHeightSite, &xMin, &yBottomMarginSite);

                        if (fViewChain)
                        {
                            // if align object didn't fit to space provided...
                            if (pEndingBreak)
                            {
                                // we want to remember element's tree node into Site Tasks queue.
                                // (if element knows how to break)
                                if (_pci->_fLayoutOverflow)
                                {
                                    CFlowLayoutBreak::CArySiteTask *pArySiteTask;

                                    pArySiteTask = pEndingBreak->GetSiteTasks();
                                    Assert(pArySiteTask);

                                    if (pArySiteTask)
                                    {
                                        CFlowLayoutBreak::CSiteTask *pSiteTask; 
                                        pSiteTask = pArySiteTask->Append();
                                        pSiteTask->_pTreeNode = pNodeLayout;

                                        if (atSite == htmlAlignLeft)
                                        {
                                            pSiteTask->_xMargin = fClearLeft ? 0 : _marginInfo._xLeftMargin;
                                        }
                                        else if (atSite == htmlAlignRight)
                                        {
                                            pSiteTask->_xMargin = fClearRight ? 0 : _marginInfo._xRightMargin;
                                        }
                                        else 
                                        {
                                            pSiteTask->_xMargin = 0;
                                        }
                                    }
                                }

                                //  (bug #111362) yHeightSite must be adjusted to available height 
                                //  to avoid unnecessary deletion of lines during CDisplay::UndoMeasure. 
                                //  It's also safe since it doesn't affect any properties of the 
                                //  aligned object. 
                                if ((_pci->_cyAvail - _pci->_yConsumed) < yHeightSite) 
                                {
                                    yHeightSite = _pci->_cyAvail - _pci->_yConsumed;
                                }
                            }

                            //  restore saved values
                            _pci->_yConsumed = yConsumedSafe;
                            //  aligned objects should not affect pagination of the main flow
                            _pci->_fLayoutOverflow = fLayoutOverflowSafe;
                        }

                        //
                        // if clear is set on the layout, we don need to auto clear.
                        //
                        if (fClearLeft || fClearRight)
                            break;

                        // If we've overflowed, and the current margin allows for auto
                        // clearing, we have to introduce a clear line.
                        if (_fMarginFromStyle &&
                            _marginInfo._xLeftMargin + _marginInfo._xRightMargin > 0 &&
                            xWidthSite > xWidthMax)
                        {
                            int iliClear;

                            _marginInfo._fAutoClear = TRUE;

                            // Find the index of the clear line that is being added.
                            if(fMeasuringSitesAtBOL)
                            {
                                iliClear = iLineFirst + iClearLines;
                            }
                            else
                            {
                                iliClear = Count() - 1;
                            }

                            // ---------------------------------------------------------
                            //
                            // BEGIN       HACK! HACK! HACK! HACK!
                            //
                            // ClearObjects will look at the line array to make some
                            // of its decisions. It will also *reuse* the line in line
                            // array -- but will assume that it has no line other info
                            // associated with it. Hence, we just transfer the lifNew
                            // over to the core line and do not bother with the other
                            // info part of lifNew since (a)ClearObjects would have to
                            // release it -- since it is reusing pliNew and (b)ClearObjects
                            // does not require to look at the other info of pliNew. 

                            Assert(lifNew._iLOI < 0);
                             *pLineNew = lifNew;
                            //
                            // END         HACK! HACK! HACK! HACK!
                            //
                            // ---------------------------------------------------------
                            
                            // add a clear line
                            ClearObjects(&lifNew, iLineStart,
                                         iliClear,
                                         &yHeight);

                            iClearLines++;

                            //
                            // Clear line takes any beforespace, so clear the
                            // beforespace for the current line
                            //
                            pme->_li._yBeforeSpace = 0;
                            ResetPosAndNegSpace();

                            // insert the new line for the alined element after the
                            // clear line.
                            lifNew.Init();
                            if(fMeasuringSitesAtBOL)
                            {
                                pLineNew = InsertLine(iLineFirst + iClearLines);

                                if (!pLineNew)
                                    goto Cleanup;

                                lifNew._fFrameBeforeText = TRUE;
                            }
                            else
                            {
                                pLineNew = AddLine();

                                if (!pLineNew)
                                    goto Cleanup;

                                lifNew._fFrameBeforeText = FALSE;
                            }

                            RecalcMargins(iLineStart,
                                          fMeasuringSitesAtBOL
                                            ? iLineFirst + iClearLines
                                            : Count() - 1,
                                          yHeight, 0);

                            xWidthMax = GetAvailableWidth();
                        }

                        // We fit just fine, but keep track of total available width.
                        else
                        {
                            xWidthMax -= xWidthSite;
                            break;
                        }
                    } // end of for loop

                    // Start out assuming that there are no style floated objects.
                    _fMarginFromStyle = FALSE;

                    // Note if the site adds "frame" margin space
                    // (e.g., tables do, images do not)
                    lifNew._fAddsFrameMargin = !(pNodeLayout->Element()->Tag() == ETAG_IMG);

                    // Top Margin is included in the line height for aligned lines,
                    // at the top of the document. Before paragraph spacing is
                    // also included in the line height.

                    long xLeftMargin, yTopMargin, xRightMargin;
                    // get the site's margins
                    pLayout->GetMarginInfo(_pci, &xLeftMargin, &yTopMargin, &xRightMargin, NULL);

                    // note: RTL display (but not RTL line) needs different calculations, because when
                    //       an RTL object doesn't fit in dislpay width, it needs to shift to the left.
                    //       Also, aligned RTL objects affect min/max calculations in combination with 
                    //       right margin (instead of left).
                    //       Therefore, calculations are done from the right margin
                    long xPos;
                    if (!_pdp->IsRTLDisplay())
                        xPos = xLeftMargin;
                    else
                        xPos = xRightMargin;

                    // Set proposed relative to the line
                    pLayout->SetXProposed(xPos);
                    pLayout->SetYProposed(yTopMargin + (fMeasuringSitesAtBOL ? (_yPadTop + _yBordTop) : 0));

                    if (pCF->HasCharGrid(FALSE))
                    {
                        long xGridWidthSite = pme->_pLS->GetClosestGridMultiple(pme->_pLS->GetCharGridSize(), xWidthSite);
                        pLayout->SetXProposed(xPos + ((xGridWidthSite - xWidthSite)/2));
                        xWidthSite = xGridWidthSite;
                    }
                    if (pCF->HasLineGrid(FALSE))
                    {
                        long yGridHeightSite = pme->_pLS->GetClosestGridMultiple(pme->_pLS->GetLineGridSize(), yHeightSite);
                        pLayout->SetYProposed(yTopMargin + ((yGridHeightSite - yHeightSite)/2));
                        yHeightSite = yGridHeightSite;
                    }

                    // _cch, _xOverhang and _xLeft are initialized to zero
                    Assert(lifNew._cch == 0 &&
                           lifNew._xLineOverhang == 0 &&
                           lifNew._xLeft == 0 &&
                           lifNew._xRight == 0);

                    // for the current line measure the left and the right indent
                    {
                        long xParentWidth = _pci->_sizeParent.cx;
                        if (   pPF->_cuvLeftIndentPercent.GetUnitValue()
                            || pPF->_cuvRightIndentPercent.GetUnitValue()
                           )
                        {
                            xParentWidth = pNodeLayout->GetParentWidth(_pci, xParentWidth);
                        }
                        long  xLeftIndent   = pPF->GetLeftIndent(_pci, FALSE, xParentWidth);
                        long  xRightIndent  = pPF->GetRightIndent(_pci, FALSE, xParentWidth);

                        if (pCF->_fHasBgColor || pCF->_fHasBgImage)
                        {
                            lifNew._fHasBackground = TRUE;
                        }

                        // (changes to the next block should be reflected in
                        //  ApplyLineIndents() too)
                        if(atSite == htmlAlignLeft)
                        {
                            _marginInfo._fAddLeftFrameMargin = lifNew._fAddsFrameMargin;
                            
                            xLeftIndent += _xMarqueeWidth + _xLayoutLeftIndent;
                            xLeftIndent += _xPadLeft + _xBordLeft;

                            // xLeftIndent is now the sum of indents.  CSS requires that when possible, this
                            // indent is shared with the space occupied by floated/ALIGN'ed elements
                            // (our code calls that space "margin").  Thus we want to apply a +ve xLeftIndent
                            // only when it's greater than the margin, and the amount applied excludes
                            // what's occupied by the margin already.  (We never want to apply a -ve xLeftIndent)

                            if (!fClearLeft)
                                lifNew._xLeft = max( 0L, xLeftIndent - _marginInfo._xLeftMargin );
                            else
                                lifNew._xLeft = xLeftIndent;

                            // If the current layout has clear left, then we need to adjust its
                            // before space so we're beneath all other left-aligned layouts.
                            // For the current layout to be clear left, its yBeforeSpace + yHeight must
                            // equal or exceed the current yBottomLeftMargin.
                            if (    fClearLeft
                                && _marginInfo._xLeftMargin
                                &&  lifNew._yBeforeSpace < _marginInfo._yBottomLeftMargin - yHeight)
                            {
                                lifNew._yBeforeSpace = _marginInfo._yBottomLeftMargin - yHeight;
                            }
                        }
                        else if(atSite == htmlAlignRight)
                        {
                            _marginInfo._fAddRightFrameMargin = lifNew._fAddsFrameMargin;
                            
                            xRightIndent += _xMarqueeWidth + _xLayoutRightIndent;
                            xRightIndent += _xPadRight + _xBordRight;

                            // xRightIndent is now the sum of indents.  CSS requires that when possible, this
                            // indent is shared with the space occupied by floated/ALIGN'ed elements
                            // (our code calls that space "margin").  Thus we want to apply a +ve xRightIndent
                            // only when it's greater than the margin, and the amount applied excludes
                            // what's occupied by the margin already.  (We never want to apply a -ve xRightIndent)

                            if (!fClearRight)
                                lifNew._xRight = max( 0L, xRightIndent - _marginInfo._xRightMargin );                            
                            else
                                lifNew._xRight = xRightIndent;

                            LONG xLeft = xLeftIndent + _xMarqueeWidth + _xLayoutLeftIndent + _xPadLeft + _xBordLeft;

                            if (!fClearLeft)
                                xLeft = max(0L, xLeft - _marginInfo._xLeftMargin);

                            xMin += xLeft + lifNew._xRight;

                            // If it's right aligned, remember the widest one in max mode.
                            _xMaxRightAlign = max(_xMaxRightAlign, long(xMin));

                            // If the current layout has clear right, then we need to adjust its
                            // before space so we're beneath all other right-aligned layouts.
                            // For the current layout to be clear right, its yBeforeSpace + yHeight must
                            // equal or exceed the current yBottomRightMargin.
                            
                            if (    fClearRight
                                &&  _marginInfo._xRightMargin
                                &&  lifNew._yBeforeSpace < _marginInfo._yBottomRightMargin - yHeight)
                            {
                                lifNew._yBeforeSpace = _marginInfo._yBottomRightMargin - yHeight;
                            }
                        }
                    }

                    // RTL line needs the adjustment at the right
                    if(!pme->_li.IsRTLLine())
                        lifNew._xLeft   += _xLeadAdjust;
                    else
                        lifNew._xRight  += _xLeadAdjust;

                    lifNew._xWidth       = xWidthSite;
                    lifNew._xLineWidth   = lifNew._xWidth;

                    if (fMeasuringSitesAtBOL)
                        lifNew._yExtent  = _yPadTop + _yBordTop;

                    lifNew._yExtent      += yHeightSite;
                    lifNew._yHeight      = lifNew._yExtent + lifNew._yBeforeSpace;

                    lifNew._pNodeForLayout = pNodeLayout;

                    _fMarginFromStyle = pFF->_fCtrlAlignFromCSS;

                    // Update the left and right margins
                    if (atSite == htmlAlignLeft)
                    {
                        lifNew.SetLeftAligned();

                        _cLeftAlignedLayouts++;

                        lifNew._xLineWidth  += lifNew._xLeft;

                        // note: for LTR display, right-aligned objects affect min/max calculations.
                        //       for RTL it is vice versa
                        if (!_pdp->IsRTLDisplay())
                        {
                            lifNew._xLeftMargin = fClearLeft ? 0 : _marginInfo._xLeftMargin;
                        }
                        else
                        {
                            if (fClearLeft)
                            {
                                lifNew._xLeftMargin = 0;
                            }
                            if (fMinMaxPass)
                            {
                                lifNew._xRightMargin = _marginInfo._xRightMargin;
                            }
                            else
                            {
                                lifNew._xRightMargin = max(_marginInfo._xRightMargin,
                                                           xWidth + 2 * _xMarqueeWidth -                                                       
                                                           (fClearLeft ? 0 : _marginInfo._xLeftMargin) -
                                                           lifNew._xLineWidth);
                                lifNew._xRightMargin = max(_xLayoutRightIndent,
                                                            lifNew._xRightMargin);
                            }
                        }

                        //
                        // if the current layout has clear then it may not
                        // establish the margin, because it needs to clear
                        // any left aligned layouts if any, in which case
                        // the left margin remains the same.
                        //
                        if (!fClearLeft || _marginInfo._xLeftMargin == 0 )
                        {
                            _marginInfo._xLeftMargin += lifNew._xLineWidth;
                            _marginInfo._yLeftMargin = yHeight + lifNew._yHeight;
                        }

                        //
                        // Update max y of all the left margin's
                        //

                        if (yHeight + lifNew._yHeight > _marginInfo._yBottomLeftMargin)
                        {
                            _marginInfo._yBottomLeftMargin = yHeight + lifNew._yHeight;
                            if (yHeight + lifNew._yHeight > *pyAlignDescent)
                            {
                                *pyAlignDescent = yHeight + lifNew._yHeight - yBottomMarginSite;
                            }
                        }
                    }
                    else
                    {
                        lifNew.SetRightAligned();

                        _cRightAlignedLayouts++;

                        lifNew._xLineWidth  += lifNew._xRight;
                        
                        if (!_pdp->IsRTLDisplay())
                        {
                            if (fMinMaxPass)
                            {
                                lifNew._xLeftMargin = _marginInfo._xLeftMargin;
                            }
                            else
                            {
                                lifNew._xLeftMargin = max(_marginInfo._xLeftMargin,
                                                         xWidth + 2 * _xMarqueeWidth -                                                     
                                                         (fClearRight ? 0 : _marginInfo._xRightMargin) -
                                                         lifNew._xLineWidth);
                                lifNew._xLeftMargin = max(_xLayoutLeftIndent,
                                                         lifNew._xLeftMargin);
                            }
                        }
                        else
                        {
                            lifNew._xRightMargin = fClearRight ? 0 : _marginInfo._xRightMargin;
                        }

                        //
                        // if the current layout has clear then it may not
                        // establish the margin, because it needs to clear
                        // any left aligned layouts if any, in which case
                        // the left margin remains the same.
                        //
                        if (!fClearRight || _marginInfo._xRightMargin == 0)
                        {
                            _marginInfo._xRightMargin += lifNew._xLineWidth;
                            _marginInfo._yRightMargin = yHeight + lifNew._yHeight;
                        }

                        //
                        // Update max y of all the right margin's
                        //

                        if (yHeight + lifNew._yHeight > _marginInfo._yBottomRightMargin)
                        {
                            _marginInfo._yBottomRightMargin = yHeight + lifNew._yHeight;
                            if (yHeight + lifNew._yHeight > *pyAlignDescent)
                            {
                                *pyAlignDescent = yHeight + lifNew._yHeight;
                            }
                        }
                    }
                    
                    if (pxMaxLineWidth)
                    {
                        if(!_pdp->IsRTLDisplay())
                        {
                            *pxMaxLineWidth = max(*pxMaxLineWidth, lifNew._xLeftMargin +
                                                                   lifNew._xLineWidth);
                        }
                        else
                        {
                            *pxMaxLineWidth = max(*pxMaxLineWidth, lifNew._xRightMargin +
                                                                   lifNew._xLineWidth);
                        }
                    }

                    if (_pci->IsNaturalMode())
                    {
                        const CFancyFormat * pFF = pNodeLayout->GetFancyFormat();
                        Assert(pFF->_bPositionType != stylePositionabsolute);

                        long dx;
                        if (!_pdp->IsRTLDisplay())
                            dx = lifNew._xLeftMargin + lifNew._xLeft;
                        else
                        {
                            dx = - lifNew._xRightMargin - lifNew._xRight;
                        }

                        long xPos; 
                        
                        // Aligned elements have their CSS margin stored in _ptProposed of
                        // their layout.  In the static case above, AddLayoutDispNode()
                        // accounts for it.  This is where we account for it in the
                        // relative case.  (Bug #65664)
                        if(!_pdp->IsRTLDisplay())
                            xPos = dx + pLayout->GetXProposed();
                        else
                        {
                            // we need to set the top left corner.
                            AssertSz(!IsTagEnabled(tagDebugRTL), "AlignObjects case 65664"); // TODO RTL 112514
                            CSize size;
                            pLayout->GetApparentSize(&size);

                            xPos = dx + _pdp->GetViewWidth() - pLayout->GetXProposed() - size.cx;
                        }


                        if (pFF->_bPositionType != stylePositionrelative)
                        {
                            pme->_pDispNodePrev =
                                _pdp->AddLayoutDispNode(
                                        _pci,
                                        pNodeLayout,
                                        xPos,
                                        yHeight + lifNew.GetYTop() + pLayout->GetYProposed(),
                                        pme->_pDispNodePrev
                                        );
                        }
                        else
                        {
                            CPoint  ptAuto(xPos, yHeight + lifNew._yBeforeSpace + pLayout->GetYProposed());
                            pNodeLayout->Element()->ZChangeElement(0, &ptAuto, _pci->GetLayoutContext());
                        }
                    }

                    // save back into the line array here
                    pLineNew->AssignLine(lifNew);
                    
                    // If we are measuring sites at the Beginning of the line. We are
                    // interested only in the current site.
                    if(fMeasuringSitesAtBOL)
                    {
                        break;
                    }
                }
            }
        }
    
        cch -= cchInTreePos;
        ptp = ptp->NextTreePos();
        Assert(ptp);
        cchInTreePos = ptp->GetCch();
    }

Cleanup:
    // Height of the current text line that contains the embedding characters for
    // the aligned sites is added at the end of CRecalcLinePtr::MeasureLine.
    // Here we are taking care of only the clear lines here.
    *pyHeight = yHeight - yHeightCurLine;

    if (fViewChain)
    {
        // restore Y consumed
        _pci->_yConsumed -= yHeightCurLine;
    }

    return iClearLines;
}


//+--------------------------------------------------------------------------
//
//  Member:     ClearObjects
//
//  Synopsis:   Insert new line for clearing objects at the left/right margin
//
//  Arguments:  [pLineMeasured]    --  Current line measured.
//              [iLineStart]       --  new lines start at
//              [iLineFirst]       --  line to start calculating from
//              [pyHeight]         --  y coordinate of the top of line
//
//
//---------------------------------------------------------------------------
BOOL CRecalcLinePtr::ClearObjects(
    CLineFull   *pLineMeasured,
    int          iLineStart,
    int &        iLineFirst,
    LONG        *pyHeight)
{
    CLineCore * pLine;
    LONG    yAt;
    CLineCore * pLineNew;

    Reset(iLineStart);
    pLine = (*this)[iLineFirst];

    Assert(_marginInfo._fClearLeft || _marginInfo._fClearRight || _marginInfo._fAutoClear);

    // Find the height to clear
    yAt = *pyHeight;

    if (_marginInfo._fClearLeft && yAt < _marginInfo._yBottomLeftMargin)
    {
        yAt = _marginInfo._yBottomLeftMargin;
    }
    if (_marginInfo._fClearRight && yAt < _marginInfo._yBottomRightMargin)
    {
        yAt = _marginInfo._yBottomRightMargin;
    }
    if (_marginInfo._fAutoClear)
    {
        yAt = max(yAt, min(_marginInfo._yRightMargin, _marginInfo._yLeftMargin));
    }

    if(pLine->_cch > 0 &&
       yAt <= (*pyHeight + pLine->_yHeight))
    {
        // nothing to clear
        pLine->_fClearBefore = pLine->_fClearAfter = FALSE;
    }

    // if the current line has any characters or is an aligned site line,
    // then add a new line, otherwise, re-use the current line.
    else if (pLine->_cch || pLine->IsFrame() && !_marginInfo._fAutoClear)
    {
        if(yAt > *pyHeight)
        {
            BOOL fIsFrame = pLine->IsFrame();
            pLineNew = AddLine();
            pLine = (*this)[iLineFirst];
            if (pLineNew)
            {
                CLineFull lif;
                CLineOtherInfo *pLineInfo = pLine->oi();
                
                lif.Init();
                lif._cch = 0;
                lif._xLeft = pLineInfo->_xLeft;
                lif._xRight = pLine->_xRight;
                lif._xLeftMargin = _marginInfo._xLeftMargin;
                lif._xRightMargin = _marginInfo._xRightMargin;
                lif._xLineWidth = max (0L, (_marginInfo._xLeftMargin ? _xMarqueeWidth : 0) +
                                                 (_marginInfo._xRightMargin ? _xMarqueeWidth : 0) +
                                                 _pdp->GetFlowLayout()->GetMaxLineWidth() -
                                                 _marginInfo._xLeftMargin -
                                                 _marginInfo._xRightMargin);
                 
                lif._xWidth = 0;

                // Make the line the right size to clear.
                if (fIsFrame)
                    lif._yHeight = pLine->_yHeight;
                else if (pLine->_fForceNewLine)
                {
                    lif._yHeight = yAt - *pyHeight - pLine->_yHeight;
                }
                else
                {
                    //
                    // if the previous line does not force new line,
                    // then we need to propagate the beforespace.
                    //
                    lif._yBeforeSpace = pLineInfo->_yBeforeSpace;
                    lif._yHeight = yAt - *pyHeight;

                    Assert(lif._yHeight >= lif._yBeforeSpace);
                }

                *pyHeight += lif._yHeight;

                lif._yExtent = lif._yHeight - lif._yBeforeSpace;
                lif._yDescent = 0;
                lif._yTxtDescent = 0;
                lif._fForceNewLine = TRUE;
                lif._fClearAfter = !pLineMeasured->_fClearBefore;
                lif._fClearBefore = pLineMeasured->_fClearBefore;
                lif._xLineOverhang = 0;
                lif._cchWhite = 0;
                lif._fHasEOP = pLine->_fHasEOP;

                if (_pci->GetLayoutContext())
                {
                    lif._fClearLeft  = _marginInfo._fClearLeft;
                    lif._fClearRight = _marginInfo._fClearRight;
                    lif._fAutoClear  = _marginInfo._fAutoClear;
                }

                pLine->_fClearBefore = pLine->_fClearAfter = FALSE;

                pLineNew->AssignLine(lif);
            }
            else
            {
                Assert(FALSE);
                return FALSE;
            }
        }
    }
    // Just replacing the existing empty line.
    else
    {
        CLineFull lif;

        Assert(pLine->_iLOI < 0);
        
        lif.Init();
        lif._xWidth = 0;

        // The clear line needs to have a margin for
        // recalc margins to work.
        lif._xLeftMargin = _marginInfo._xLeftMargin;
        lif._xRightMargin = _marginInfo._xRightMargin;

        lif._xLineWidth = max (0L, (_marginInfo._xLeftMargin ? _xMarqueeWidth : 0) +
                                                 (_marginInfo._xRightMargin ? _xMarqueeWidth : 0) +
                                                 _pdp->GetFlowLayout()->GetMaxLineWidth() -
                                                 _marginInfo._xLeftMargin - _marginInfo._xRightMargin);
        lif._xLeft = pLineMeasured->_xLeft;
        lif._xRight = pLineMeasured->_xRight;

        lif._yHeight = yAt - *pyHeight;
        lif._yExtent = lif._yHeight;
        lif._yDescent = 0;
        lif._yTxtDescent = 0;
        lif._xLineOverhang = 0;
        lif._cchWhite = 0;
        lif._fHasBulletOrNum = FALSE;
        lif._fClearAfter = !pLineMeasured->_fClearBefore;
        lif._fClearBefore = pLineMeasured->_fClearBefore;
        lif._fForceNewLine = TRUE;

        if (_pci->GetLayoutContext())
        {
            lif._fClearLeft  = _marginInfo._fClearLeft;
            lif._fClearRight = _marginInfo._fClearRight;
            lif._fAutoClear  = _marginInfo._fAutoClear;
        }

        pLine->AssignLine(lif);
        if (!_marginInfo._fAutoClear)
            iLineFirst--;

        // If we are clearing the line, then we will come around again to measure
        // the line and we will call CalcBeforeSpace all over again which will
        // add in the padding+border of block elements coming into scope again.
        // To avoid this, remove the padding+border added in this time.
        if (pLineMeasured->_fFirstInPara)
        {
            _xBordLeft  -= _xBordLeftPerLine;
            _xBordRight -= _xBordRightPerLine;
            _xPadLeft   -= _xPadLeftPerLine;
            _xPadRight  -= _xPadRightPerLine;
        }
    }
    if(pLine->_fForceNewLine)
        *pyHeight += pLine->_yHeight;

    // Prepare for the next pass of the measurer.
    _marginInfo._fClearLeft  = FALSE;
    _marginInfo._fClearRight = FALSE;
    
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::MeasureLine()
//
//  Synopsis:   Measures a new line, creates aligned and clear lines if
//              current text line has aligned objects or clear flags set on it.
//              Updates iNewLine to point to the last text line. -1 if there is
//              no text line before the current line
//
//-----------------------------------------------------------------------------

BOOL
CRecalcLinePtr::MeasureLine(CLSMeasurer &me,
                            UINT    uiFlags,
                            INT  *  piLine,
                            LONG *  pyHeight,
                            LONG *  pyAlignDescent,
                            LONG *  pxMinLineWidth,
                            LONG *  pxMaxLineWidth
                            )
{
    LONG                cchSkip = 0;
    LONG                xWidth = 0;
    CLineCore          *pliNew;
    INT                 iTLine = *piLine - 1;
    BOOL                fAdjustForCompact = FALSE;
    CFlowLayout        *pFlowLayout = _pdp->GetFlowLayout();
    BOOL                fClearMarginsRequired;
    CTreeNode          *pNodeFormatting;

    Reset(_iNewFirst);
    pliNew = (*this)[*piLine];

    _xLeadAdjust = 0;
    _ptpStartForListItem = NULL;

    me._cchAbsPosdPreChars = 0;
    me._fRelativePreChars = FALSE;
    me._fMeasureFromTheStart = FALSE;
    me._fSeenAbsolute = FALSE;
    
    _marginInfo._fClearLeft  =
    _marginInfo._fClearRight =
    _marginInfo._fAutoClear  = FALSE;

    // If the current line being measure has an offset of 0, It implies
    // the current line is the top most line.
    if (*pyHeight == 0 )
        uiFlags |= MEASURE_FIRSTLINE;

#if DBG==1
    // We should never have an index off the end of the line array.
    if (iTLine >= 0 && (*this)[iTLine] == NULL)
    {
        Assert(FALSE);
        goto err;
    }
#endif

    // If we are measuring aligned sites at the beginnning of the line,
    // we have initialized the line once.
    me.NewLine(uiFlags & MEASURE_FIRSTINPARA);

    Assert(!me._fPseudoLineEnabled);
    
    // Space between paragraphs.
    pNodeFormatting = CalcInterParaSpace(&me, iTLine, &uiFlags);

    //
    // Note: CalcBeforeSpace needs to be call ed before we call RecalcMargins
    // because before space is used to compute margins.
    //
    
    // If the current line being measured has invalid margins, a line that is
    // below an aligned line, margins have changed so recalculate margins.
    if (!IsValidMargins(*pyHeight + max(0l, me._li._yBeforeSpace)))
    {
        BOOL fClearLeft  = _marginInfo._fClearLeft;
        BOOL fClearRight = _marginInfo._fClearRight;

        RecalcMargins(_iNewFirst, *piLine, *pyHeight, me._li._yBeforeSpace);

        if (_fMarginFromStyle)
            uiFlags |= MEASURE_AUTOCLEAR;

        //
        // Restore the clear flags on _marginInfo, since RecalcMargins init's
        // the marginInfo. CalcBeforeSpace set's up clear flags on the marginInfo
        // if any elements comming into scope have clear attribute/style set.
        //
        _marginInfo._fClearLeft  = fClearLeft;
        _marginInfo._fClearRight = fClearRight;
    }

    if (   _pci->GetLayoutContext()                 // layout in context
        && _pci->GetLayoutContext()->ViewChain()    // there is a view chain 
        && _pdp->LineCount() == 1)                  // this is the first line
    {
        me._cyTopBordPad = _yBordTop + _yPadTop;
        me._li._cyTopBordPad = me._cyTopBordPad;

        // Compute the available width for the current line.
        // (Do this after determining the margins for the line)
        xWidth = GetAvailableWidth();

        ProcessAlignedSiteTasksAtBOB(&me, &me._li, uiFlags, piLine,
                                     pyHeight, &xWidth, pyAlignDescent,
                                     pxMaxLineWidth, &fClearMarginsRequired);
    }

    //
    // If we need to clear aligned elements, don't bother measuring text
    //
    if (!CheckForClear())
    {
        // Apply the line indents, _xLeft and _xRight
        ApplyLineIndents(pNodeFormatting, &me._li, uiFlags, me._fPseudoElementEnabled);
        
        if( iTLine >= 0 )
        {
            BOOL  fInner = FALSE;
            const CParaFormat* pPF;

            pPF = me.MeasureGetPF(&fInner);

            CLineCore *pli = (*this)[iTLine];

            // If we have the compact attribute set, see if we can fit the DT and the DD on the
            //  same line.
            if( pPF->HasCompactDL(fInner) && pli->_fForceNewLine )
            {
                CTreeNode * pNodeCurrBlockElem = pNodeFormatting;

                if (pNodeCurrBlockElem->Element()->IsTagAndBlock(ETAG_DD))
                {
                    CLineFull lif = *pli;
                    CTreePos  * ptp;
                    CTreePos  * ptpFirst;
                    CTreeNode * pNodePrevBlockElem;

                    //
                    // Find the DT which should have appeared before the DD
                    //
                    // Get the max we will travel backwards in search of the DT
                    pFlowLayout->GetContentTreeExtent(&ptpFirst, NULL);

                    pNodePrevBlockElem = NULL;
                    ptp = me.GetPtp();
                    for(;;)
                    {
                        ptp = ptp->PreviousTreePos();
                        Assert(ptp);
                        if (   (ptp == ptpFirst)
                            || ptp->IsText()
                           )
                            break;

                        if (   ptp->IsEndElementScope()
                            && ptp->Branch()->Element()->IsTagAndBlock(ETAG_DT)
                           )
                        {
                            pNodePrevBlockElem = ptp->Branch();
                            break;
                        }
                    }

#if DBG==1                
                    if (pNodePrevBlockElem)
                    {
                        Assert(pNodePrevBlockElem->Element()->IsTagAndBlock(ETAG_DT));
                        Assert((pFlowLayout->GetContentMarkup()->FindMyListContainer(pNodeCurrBlockElem) ==
                                pFlowLayout->GetContentMarkup()->FindMyListContainer(pNodePrevBlockElem)));
                    }
#endif
                    // Make sure that the DT is thin enough to fit the DD on the same line.
                    // TODO RTL 112514: avoid obscure formulas in offset calculations
                    if (   pNodePrevBlockElem
                        && (!pPF->_fRTL ? me._li._xLeft > lif._xWidth + lif._xLeft + lif._xLineOverhang
                                        : me._li._xRight > lif._xWidth + lif._xRight + lif._xLineOverhang
                           )
                       )
                    {
                        fAdjustForCompact = TRUE;
                        lif._fForceNewLine = FALSE;
                        if(!pPF->_fRTL)
                        {
                            lif._xRight = 0;
                            lif._xLineWidth = me._li._xLeft;
                        }
                        else
                        {
                            lif._xLeft = 0;
                            lif._xLineWidth = me._li._xRight;
                        }
                        *pyHeight -= lif._yHeight;
                        
                        if (me._li._yBeforeSpace < lif._yBeforeSpace)
                            me._li._yBeforeSpace = lif._yBeforeSpace;
                        if (lif._yBeforeSpace < me._li._yBeforeSpace)
                            lif._yBeforeSpace = me._li._yBeforeSpace;
                        
                        // If the current line being measured has an offset of 0, It implies
                        // the current line is the top most line.
                        if (*pyHeight == 0 )
                            uiFlags |= MEASURE_FIRSTLINE;

                        lif.ReleaseOtherInfo();
                        pli->AssignLine(lif);

                        // Adjust the margins
                        RecalcMargins(_iNewFirst, *piLine, *pyHeight, me._li._yBeforeSpace);
                        if (_fMarginFromStyle)
                            uiFlags |= MEASURE_AUTOCLEAR;
                    }
                }
            }
        }

        me._cyTopBordPad = _yBordTop + _yPadTop;
        me._li._cyTopBordPad = me._cyTopBordPad;

        // Compute the available width for the current line.
        // (Do this after determining the margins for the line)
        xWidth = GetAvailableWidth();

        cchSkip = CalcAlignedSitesAtBOL(&me, &me._li, uiFlags,
                                        piLine, pyHeight,
                                        &xWidth, pyAlignDescent,
                                        pxMaxLineWidth, &fClearMarginsRequired);

        pliNew = (*this)[*piLine];
        if (!fClearMarginsRequired)
        {
            me._cchPreChars = me._li._cch;
            me._li._cch = 0;

            if (me._fMeasureFromTheStart)
                me.SetCp(me.GetCp() - me._cchPreChars, NULL);
            
            if (_fMarginFromStyle)
                uiFlags |= MEASURE_AUTOCLEAR;

            me._pLS->_cchSkipAtBOL = cchSkip;
            me._yli = *pyHeight;
            if(!me.MeasureLine(xWidth, -1, uiFlags, &_marginInfo, pxMinLineWidth))
            {
                Assert(FALSE);
                goto err;
            }

            Check(cchSkip <= me._li._cch);
            
            // if it is in edit mode _fNoContent will be always FALSE
            // If it has a LI on it then too we will say that the display has contents
            _pdp->_fNoContent =    !_fIsEditable
                                && !!(uiFlags & MEASURE_FIRSTLINE && me._li._cch == 0)
                                && !me._li._fHasBulletOrNum;

            me.Resync();
            if (!me._fMeasureFromTheStart)
                me._li._cch += me._cchPreChars;

            if (   me._li._fHasBulletOrNum
                && (_yBordTop || _yPadTop)
                && !IsListItem(me.GetPtp()->GetBranch())
                && !me._pLS->HasVisualContent()
               )
            {
                _fMoveBulletToNextLine = TRUE;
                me._li._fHasBulletOrNum = FALSE;
                me._li._fHasTransmittedLI = TRUE;
                me._li._yExtent = me._li._yHeight = me._li._yDescent = me._li._yTxtDescent = 0;
                _ptpStartForListItem = NULL;
            }

            // If we couldn't fit anything on the line, clear an aligned thing and
            // we'll try again afterwards.
            if (!_marginInfo._fAutoClear || me._li._cch > 0)
            {
                // CalcAfterSpace modifies, _xBordLeft and _xBordRight
                // to account for block elements going out of scope,
                // set the flag before they are modified.
                me._li._fHasParaBorder = (_xBordLeft + _xBordRight) != 0;

                CalcAfterSpace(&me,
                               me._li._fDummyLine && (uiFlags & MEASURE_FIRSTLINE ? TRUE : FALSE),
                               LONG_MAX);

                // Monitor progress here
                Assert(me._li._cch != 0 || _pdp->GetLastCp() == me.GetCp());

                me._li._yHeight  += _yBordTop + _yBordBottom + 
                                    _yPadTop  + _yPadBottom;
                me._li._yDescent += _yBordBottom + _yPadBottom;
                me._li._yHeight  += (LONG)me._li._yBeforeSpace;
                me._li._yExtent  += _yBordTop + _yBordBottom + 
                                    _yPadTop  + _yPadBottom;
                me._li._fHasParaBorder |= (_yBordTop + _yBordBottom) != 0;

                AssertSz(!IsBadWritePtr(pliNew, sizeof(CLineCore)),
                         "Line Array has been realloc'd and now pliNew is invalid! "
                         "Memory corruption is about to occur!");

                // Remember the longest word.
                if(pxMinLineWidth && _pdp->_xMinWidth >= 0)
                {
                    _pdp->_xMinWidth = max(_pdp->_xMinWidth, *pxMinLineWidth);
                }
            }
            else
            {
                ResetPosAndNegSpace();
            }
        }
        else
        {
            me.Advance(cchSkip);
            ResetPosAndNegSpace();
            me._li._cch            += cchSkip;
            me._li._fHasEmbedOrWbr = TRUE;
            me._li._fDummyLine     = TRUE;
            me._li._fForceNewLine  = FALSE;
            me._li._fClearAfter    = TRUE;
        }
    }
    else
    {
        me.Advance(-me._li._cch);
        me._li._fClearBefore = TRUE;
        me._li._xWhite =
        me._li._xWidth = 0;
        me._li._cch =
        me._li._cchWhite = 0;
        me._li._yBeforeSpace = me._li._yBeforeSpace;
    }

    if (me._li._fForceNewLine)
        _yPadTop = _yPadBottom = _yBordTop = _yBordBottom = 0;

    // If we're autoclearing, we don't need to do anything here.
    if (!_marginInfo._fAutoClear || me._li._cch > 0)
    {
        if( fAdjustForCompact )
        {
            CLineCore *pli = (*this)[iTLine];       // since fAdjustForCompact is set, we know iTLine >= 0
            CLineFull lif = *pli;

            lif.ReleaseOtherInfo();
            
            // The DT and DL have different heights, need to make them each the height of the
            //  greater of the two.

            LONG iDTHeight = lif._yHeight - lif._yBeforeSpace - lif._yDescent;
            LONG iDDHeight = me._li._yHeight - me._li._yBeforeSpace - me._li._yDescent;

            lif._yBeforeSpace    += max( 0l, iDDHeight - iDTHeight );
            me._li._yBeforeSpace += max( 0l, iDTHeight - iDDHeight );
            lif._yDescent        += max( 0l, me._li._yDescent - lif._yDescent );
            me._li._yDescent     += max( 0l, lif._yDescent - me._li._yDescent );

            lif._yHeight = me._li._yHeight =
                lif._yBeforeSpace +  iDTHeight + lif._yDescent;

            pli->AssignLine(lif);
        }

        me._li._xLeftMargin = _marginInfo._xLeftMargin;
        me._li._xRightMargin = _marginInfo._xRightMargin;
        me._li._xLineWidth  = me._li.CalcLineWidth();

        if(me._li._fForceNewLine && xWidth > me._li._xLineWidth)
            me._li._xLineWidth = xWidth;
        
        if(me._li._fHidden)
        {
            me._li._yExtent = 0;
        }
        
        if(pxMaxLineWidth)
        {
            *pxMaxLineWidth = max(*pxMaxLineWidth, (!me._li._fRTLLn ? me._li._xLeftMargin : me._li._xRightMargin)   +
                                                   me._li._xWidth        +
                                                   me._li._xLeft         - me._li._xNegativeShiftRTL +
                                                   me._li._xLineOverhang +
                                                   me._li._xRight);
        }

        if (   me._li._cch
            || (uiFlags & MEASURE_EMPTYLASTLINE)
           )
        {
            Assert(pliNew);
            // This innocent looking line is where we transfer
            // the calculated values to the permanent line array.
            pliNew->AssignLine(me._li);
        }
        
        // Align those sites which occur somewhere in the middle or at end of the line
        // (Those occurring at the start are handled in the above loop)
        if(   me._li._fHasAligned
           && me._cAlignedSites > me._cAlignedSitesAtBeginningOfLine)
        {
            // Position the measurer so that it points to the beginning of the line
            // excluding all the whitespace characters.
            LONG cch = pliNew->_cch - me.CchSkipAtBeginningOfLine();

            CTreePos *ptpOld = me.GetPtp();
            LONG cpOld = me.GetCp();
            
            me.Advance(-cch);

            AlignObjects(&me, &me._li, cch, FALSE,
                                   (uiFlags & MEASURE_BREAKATWORD) ? TRUE : FALSE,
                                   pxMinLineWidth ? TRUE : FALSE,
                                   _iNewFirst, *piLine, pyHeight, xWidth,
                                   pyAlignDescent, pxMaxLineWidth);

            me.SetPtp(ptpOld, cpOld);
            
            Assert(me._li == *(*this)[*piLine]);
            WHEN_DBG(pliNew = NULL);
        }

        if (   me._li._fHasFirstLetter
            && me._li._fHasFloatedFL
           )
        {
            AlignFirstLetter(&me, _iNewFirst, *piLine, pyHeight, pyAlignDescent, pNodeFormatting);
        }

        // NETSCAPE: Right-aligned sites are not normally counted in the maximum line width.
        //           However, the maximum line width should not be allowed to shrink below
        //           the minimum (which does include all left/right-aligned sites guaranteed
        //           to occur on a single line).
        if (pxMaxLineWidth && pxMinLineWidth)
        {
            *pxMaxLineWidth = max(*pxMaxLineWidth, *pxMinLineWidth);
        }

        if(me._pLS->HasChunks())
        {
            FixupChunks(me, piLine);
            pliNew = (*this)[*piLine];
            me._li = *pliNew;
        }
    }
    
    if (_marginInfo._fClearLeft || _marginInfo._fClearRight || _marginInfo._fAutoClear)
    {
        ClearObjects(&me._li, _iNewFirst, *piLine, pyHeight);

        // The calling function(s) expect to point to the last text line.
        while(*piLine >= 0)
        {
            pliNew = (*this)[*piLine];
            if(pliNew->IsTextLine())
                break;
            else
                (*piLine)--;
        }
        me._li = *pliNew;
    }
    else if (me._li._fForceNewLine)
    {
        *pyHeight += me._li._yHeight;
    }
    me.PseudoLineDisable();
    me._cchPreChars = 0;
    me._fMeasureFromTheStart = 0;
    me._pLS->_cchSkipAtBOL = 0;
    return TRUE;

err:
    me.PseudoLineDisable();
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:   CRecalcLinePtr::ProcessAlignedSiteTasksAtBOB()
//
//  NOTE:     Print View specific !!! Should be called once for block 
//            (before any line is calculated) 
//
//  Synopsis: Process Site Tasks queue by measuring aligned sites.
//
//  Params:   see CRecalcLinePtr::CalcAlignedSitesAtBOL params.
//
//  Return:   nothing.
//
//-----------------------------------------------------------------------------
void 
CRecalcLinePtr::ProcessAlignedSiteTasksAtBOB(
      CLSMeasurer * pme,
      CLineFull   * pLineMeasured,
      UINT          uiFlags,
      INT         * piLine,
      LONG        * pyHeight,
      LONG        * pxWidth,
      LONG        * pyAlignDescent,
      LONG        * pxMaxLineWidth,
      BOOL        * pfClearMarginsRequired)
{
    CLayoutContext *pLayoutContext = _pci->GetLayoutContext();
    
    Assert( pLayoutContext 
        &&  pLayoutContext->ViewChain()
        &&  _pdp->LineCount() == 1);

    //  if this is print view and we are called for the first 
    //  line of a block, additional work may be needed
    CLayoutBreak *pLayoutBreak;

    pLayoutContext->GetLayoutBreak(_pdp->GetFlowLayoutElement(), &pLayoutBreak);
    if (   pLayoutBreak 
        && DYNCAST(CFlowLayoutBreak, pLayoutBreak)->HasSiteTasks())
    {
        CFlowLayoutBreak::CArySiteTask *pArySiteTask; 
        CFlowLayoutBreak               *pFlowLayoutBreak = DYNCAST(CFlowLayoutBreak, pLayoutBreak);

        pArySiteTask = pFlowLayoutBreak->GetSiteTasks();

        //  If there are Site Tasks, go ahead and process them 
        if (pArySiteTask)
        {
            int       i;
            int       cLimit = pArySiteTask->Size();
            long      cpSafe = pme->GetCp();

            for (i = 0; i < cLimit; ++i)
            {
                CFlowLayoutBreak::CSiteTask *pSiteTask;
                htmlControlAlign             atSite;

                pSiteTask = &((*pArySiteTask)[i]);
                // Adjust ls measurer
                pme->SetPtp(pSiteTask->_pTreeNode->GetBeginPos(), -1);

                Check(pme->GetCp() <= cpSafe);

                if (pme->GetCp() < cpSafe) // (olego) otherwise this site will be processed during CalcAlignedSitesAtBOL. 
                {
                    // if last time (previous block) the element was placed with offset (margin), 
                    // restore it here
                    atSite = pSiteTask->_pTreeNode->GetSiteAlign(LC_TO_FC(_pci->GetLayoutContext()));
                    if (atSite == htmlAlignLeft)
                    {
                        if (_marginInfo._xLeftMargin < pSiteTask->_xMargin)
                        {
                            _marginInfo._xLeftMargin = pSiteTask->_xMargin;
                        }
                    }
                    else if (atSite == htmlAlignRight)
                    {
                        if (_marginInfo._xRightMargin < pSiteTask->_xMargin)
                        {
                            _marginInfo._xRightMargin = pSiteTask->_xMargin;
                        }
                    }

                    //  Call CalcAlignedSitesAtBOLCore to process tasks
                    CalcAlignedSitesAtBOLCore(pme, pLineMeasured, uiFlags, piLine,
                                             pyHeight, pxWidth, pyAlignDescent,
                                             pxMaxLineWidth, pfClearMarginsRequired, 
                                             TRUE // Here we want only one element to be processed 
                                             );
                }
            }

            _marginInfo._fClearLeft  = pFlowLayoutBreak->_fClearLeft; 
            _marginInfo._fClearRight = pFlowLayoutBreak->_fClearRight; 
            _marginInfo._fAutoClear  = pFlowLayoutBreak->_fAutoClear; 

            pme->SetCp(cpSafe, NULL);
        }
    }
}                                        

//+----------------------------------------------------------------------------
//
//  Member:   CRecalcLinePtr::CalcAlignedSitesAtBOL()
//
//  Synopsis: Measures any aligned sites which are at the BOL.
//
//  Params:
//    prtp(i,o):          The position in the runs for the text
//    pLineMeasured(i,o): The line being measured
//    uiFlags(i):         The flags controlling the measurer behaviour
//    piLine(i,o):        The line before which all aligned lines are added.
//                           Incremented to reflect addition of lines.
//    pxWidth(i,o):       Contains the available width for the line. Aligned
//                           lines will decrease the available width.
//    pxMinLineWidth(o):  These two are passed directly to AlignObjects.
//    pxMaxLineWidth(o):
//
//  Return:     LONG    -   the no of character's to skip at the beginning of
//                          the line
//
//-----------------------------------------------------------------------------
LONG
CRecalcLinePtr::CalcAlignedSitesAtBOL(
      CLSMeasurer * pme,
      CLineFull   * pLineMeasured,
      UINT          uiFlags,
      INT         * piLine,
      LONG        * pyHeight,
      LONG        * pxWidth,
      LONG        * pyAlignDescent,
      LONG        * pxMaxLineWidth,
      BOOL        * pfClearMarginsRequired)
{
    CTreePos *ptp;

    ptp = pme->GetPtp();
    if (ptp->IsText() && ptp->Cch())
    {
        TCHAR ch = CTxtPtr(_pdp->GetMarkup(), pme->GetCp()).GetChar();
        CTreeNode *pNode = pme->CurrBranch();

        // Check to see whether this line begins with whitespace;
        // if it doesn't, or if it does but we're in a state where whitespace is significant
        // (e.g. inside a PRE tag), then by definition there are no aligned
        // sites at BOL (because there's something else there first).
        // Similar code is in CalcAlignedSitesAtBOLCore() for handling text
        // between aligned elements.

        if ( !IsWhite(ch) 
             || pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasInclEOLWhite( SameScope(pNode, pme->_pFlowLayout->ElementContent()) ) )
        {
            *pfClearMarginsRequired = FALSE;
            return 0;
        }
    }
    
    return CalcAlignedSitesAtBOLCore(pme, pLineMeasured, uiFlags, piLine,
                                     pyHeight, pxWidth, pyAlignDescent,
                                     pxMaxLineWidth, pfClearMarginsRequired);
}

LONG
CRecalcLinePtr::CalcAlignedSitesAtBOLCore(
        CLSMeasurer *pme,
        CLineFull   *pLineMeasured,
        UINT         uiFlags,
        INT         *piLine,
        LONG        *pyHeight,
        LONG        *pxWidth,
        LONG        *pyAlignDescent,
        LONG        *pxMaxLineWidth,
        BOOL        *pfClearMarginsRequired, 
        BOOL         fProcessOnce)  // this parameter is added for print view support. It is TRUE when 
                                    // the function is called to process Site Tasks for the block. In this 
                                    // case we want only the first site to be processed.
{
    CFlowLayout *pFlowLayout = _pdp->GetFlowLayout();
    CElement    *pElementFL  = pFlowLayout->ElementContent();
    const        CCharFormat *pCF;              // The char format
    LONG         cpSave   = pme->GetCp();       // Saves the cp the measurer is at
    CTreePos    *ptpSave  = pme->GetPtp();
    BOOL         fAnyAlignedSiteMeasured;       // Did we measure any aligned site at all?
    CTreePos    *ptpLayoutLast;
    CTreePos    *ptp;
    LONG         cp;
    CTreeNode   *pNode;
    CElement    *pElement;
    BOOL         fInner;
    
    AssertSz(!(uiFlags & MEASURE_BREAKWORDS),
             "Cannot call CalcSitesAtBOL when we are hit testing!");

    AssertSz(!fProcessOnce || (_pci->GetLayoutContext() && _pci->GetLayoutContext()->ViewChain()), 
        "Improper usage of CalcAlignedSitesAtBOLCore parameters in non print view mode !!!");

    //
    // By default, do not clear margins
    //
    *pfClearMarginsRequired = FALSE;
    fAnyAlignedSiteMeasured = FALSE;

    pFlowLayout->GetContentTreeExtent(NULL, &ptpLayoutLast);
    ptp = ptpSave;
    cp  = cpSave;
    pNode = ptp->GetBranch();
    pElement = pNode->Element();
    pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
    fInner = SameScope(pNode, pElementFL);
            
    for (;;)
    {
        pme->SetPtp(ptp, cp);

        if (ptp == ptpLayoutLast)
            break;

        if (ptp->IsPointer())
        {
            ptp = ptp->NextTreePos();
            continue;
        }

        if (ptp->IsNode())
        {
            pNode = ptp->Branch();
            pElement = pNode->Element();
            fInner = SameScope(pNode, pElementFL);
            if (ptp->IsEndNode())
                pNode = pNode->Parent();
	    if(pNode)
                pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
	    else
                break;
        }

        //
        // NOTE(SujalP):
        // pCF should never be NULL since though it starts out as NULL, it should
        // be initialized the first time around in the code above. It has happened
        // in stress once that pCF was NULL. Hence the check for pCF and the assert.
        // (Bug 18065).
        //
        AssertSz(pNode && pElement && pCF, "None of these should be NULL");
        if (!(pNode && pElement && pCF))
            break;

        if (   !_fIsEditable
            && ptp->IsBeginElementScope()
            && pCF->IsDisplayNone()
           )
        {
            cp += pme->GetNestedElementCch(pNode->Element(), &ptp);
            cp -= ptp->GetCch();
        }
        else if (   ptp->IsBeginElementScope()
                 && pNode->ShouldHaveLayout()
                )
        {
            pme->_fHasNestedLayouts = TRUE;
            pLineMeasured->_fHasNestedRunOwner |= pNode->Element()->IsRunOwner();
            
            if (!pElement->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())))
            {
                //
                // Absolutely positioned sites are measured separately
                // inside the measurer. They also count as whitespace and
                // hence we will continue looking for aligned sites after
                // them at BOL.
                //
                if (!pNode->IsAbsolute(LC_TO_FC(_pci->GetLayoutContext())))
                {
                    CLineCore *pLine;

                    //
                    // Mark the line which will contain the WCH_EMBEDDING as having
                    // an aligned site in it.
                    //
                    pLine = (*this)[*piLine];
                    pLine->_fHasAligned = TRUE;

                    //
                    // Measure the aligned site and create a line for it.
                    // AlignObjects returns the number of clear lines, so we need
                    // to add the number of clear lines + the aligned line that is
                    // inserted to *piLine to make *piLine point to the text line
                    // that contains the embedding characters for the aligned site.
                    //
                    *piLine += AlignObjects(pme, pLineMeasured, 1, TRUE,
                                            (uiFlags & MEASURE_BREAKATWORD) ? TRUE : FALSE,
                                            (uiFlags & MEASURE_MAXWIDTH)    ? TRUE : FALSE,
                                            _iNewFirst, *piLine, pyHeight, *pxWidth,
                                            pyAlignDescent, pxMaxLineWidth);

                    //
                    // This the now the next available line, because we just inserted
                    // a line for the aligned site.
                    //
                    (*piLine)++;

                    //
                    // Aligned objects change the available width for the line
                    //
                    *pxWidth = GetAvailableWidth();

                    //
                    // This is ONLY used for DD. Weird, does it need to be that special?
                    //
                    _xLeadAdjust = 0;

                    //
                    // Also update the xLeft and xRight for the next line
                    // to be inserted.
                    //
                    ApplyLineIndents(pNode, pLineMeasured, uiFlags, pme->_fPseudoElementEnabled);
                    
                    //
                    // Remember we measured an aligned site in this pass
                    //
                    fAnyAlignedSiteMeasured = TRUE;
                }

                cp += pme->GetNestedElementCch(pElement, &ptp);
                cp -= ptp->GetCch();
            }
            else
            {
                if (CheckForClear(pNode))
                {
                    *pfClearMarginsRequired = TRUE;
                }
                break;
            }
        }
        else if (ptp->IsText())
        {
            CTxtPtr tp(_pdp->GetMarkup(), cp);
            // NOTE: Cch() could return 0 here but we should be OK with that.
            LONG cch = ptp->Cch();
            BOOL fNonWhitePresent = FALSE;
            TCHAR ch;
            
            while (cch)
            {
                ch = tp.GetChar();
                //
                // These characters need to be treated like whitespace
                //
                if (!(   ch == _T(' ')
                      || (   InRange(ch, TEXT('\t'), TEXT('\r'))
                          && !pNode->GetParaFormat()->HasInclEOLWhite(
                                SameScope(pNode, pme->_pFlowLayout->ElementContent()))
                         )
                       )
                   )
                {
                    fNonWhitePresent = TRUE;
                    break;
                }
                cch--;
                tp.AdvanceCp(1);
            }
            if (fNonWhitePresent)
                break;
        }
        else if (   ptp->IsEdgeScope()
                 && pElement != pElementFL
                 && (   pFlowLayout->IsElementBlockInContext(pElement)
                     || pElement->Tag() == ETAG_BR
                    )
                )
        {
            break;
        }
        else if ( ptp->IsBeginElementScope() && CheckForClear(pNode) )
        {
            *pfClearMarginsRequired = TRUE;
            break;
        }

        if (fProcessOnce)
            break;
        
        //
        // Goto the next tree position
        //
        cp += ptp->GetCch();
        ptp = ptp->NextTreePos();
    }

    //
    // Restore the measurer to where it was when we came in
    //
    pme->SetPtp(ptpSave, cpSave);

    return fAnyAlignedSiteMeasured ? cp - cpSave : 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CheckForClear()
//
//  Synopsis:   CalcBeforeSpace set's up _fClearLeft & _fClearRight on the
//              _marginInfo, if a pNode is passed the use its clear flags,
//              check if we need to clear based on margins.
//
//  Arguments:  pNode - (optional) can be null.
//
//  Returns: A bool indicating if clear is required.
//
//-----------------------------------------------------------------------------
BOOL
CRecalcLinePtr::CheckForClear(CTreeNode * pNode)
{
    BOOL fClearLeft;
    BOOL fClearRight;

    if (pNode)
    {
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

        fClearLeft  = pFF->_fClearLeft;
        fClearRight = pFF->_fClearRight;
    }
    else
    {
        fClearLeft  = _marginInfo._fClearLeft;
        fClearRight = _marginInfo._fClearRight;
    }

    _marginInfo._fClearLeft  = _marginInfo._xLeftMargin && fClearLeft;
    _marginInfo._fClearRight = _marginInfo._xRightMargin && fClearRight;

    return _marginInfo._fClearLeft || _marginInfo._fClearRight;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::FixupChunks
//
//  Synopsis:   If the current line has multiple chunks in the line (caused by
//              relative chunks), then break the line into multiple lines that
//              form a single screen line and fix up justification.
//
//  REMINDER:   RightToLeft lines measure from the right. Therefore, the
//              chunks need to be handled accordingly.
//-----------------------------------------------------------------------------

void
CRecalcLinePtr::FixupChunks(CLSMeasurer &me, INT *piLine)
{
    CLSLineChunk * plc  = me._pLS->GetFirstChunk();
    CLineCore * pliT    = (*this)[*piLine];
    CLineFull li        = *pliT;
    LONG    cchLeft     = li._cch;
    LONG    xWidthLeft  = li._xWidth;
    LONG    xPos        = li._xLeft;    // chunk position. note: if any BiDi is involved, 
                                        // position is always taken from the chunk
    BOOL    fFirstLine  = TRUE;
    LONG    iFirstChunk = *piLine;
    
    BOOL    fBiDiLine   = FALSE;

    // if all we have is one chunk in the line, we dont need to create
    // additional lines
    if(plc->_cch >= cchLeft)
    {
        li._fRelative            = me._pLS->_pElementLastRelative != NULL;
        li._fPartOfRelChunk      = TRUE;
        _pdp->NoteMost(&li);
        return;
    }

    while(plc || cchLeft)
    {
        BOOL fLastLine = !plc || cchLeft <= plc->_cch;
        CLineFull lifNew;

        // get x position from plc (if available)
        if (plc)
        {
            if (!plc->_fRTLChunk != !li.IsRTLLine())
                fBiDiLine = TRUE;
            
            // limit xPos by line width (right-aligned lines may have hanging white space)
            LONG xPosNew = li._xLeft + min(li._xWidth, plc->_xLeft);
#if DBG==1
            // Assert that in strictly LTR case, current xPos matches the saved chunk position
            // TODO RTL 112514: make xPos calculation debug-only (when it works)
            AssertSz(li.IsRTLLine() || fBiDiLine || xPos == xPosNew
                     || !IsTagEnabled(tagDebugRTL), // TODO RTL 112514: this fires in some LTR cases
                     "chunk position doesn't match accumulated widh");
#endif

            xPos = xPosNew;
        }
        else
        {
            AssertSz(xWidthLeft <= 0 || !IsTagEnabled(tagDebugRTL), 
                     "no plc for a chunk, and it is not a trailing empty chunk"); 
        }

        lifNew = li;
        lifNew._xLeft = xPos;
            
        if(!fFirstLine)
        {
            pliT = InsertLine(++(*piLine));
            if (!pliT)
                break;

            // TODO RTL 112514: will bullets work with mixed-flow positioned lines?
            lifNew._fHasBulletOrNum  = FALSE;
            lifNew._fFirstFragInLine = FALSE;
        }
        else
        {
            li.ReleaseOtherInfo();
            lifNew._iLOI = -1;
        }

        lifNew._cch                  = min(cchLeft, long(plc ? plc->_cch : cchLeft));
        lifNew._xWidth               = plc ? min(long(plc->_xWidth), xWidthLeft) : xWidthLeft;
        lifNew._fRelative            = plc ? plc->_fRelative : me._pLS->_pElementLastRelative != NULL;
        lifNew._fSingleSite          = plc ? plc->_fSingleSite : me._pLS->_fLastChunkSingleSite;
        lifNew._fPartOfRelChunk      = TRUE;
        lifNew._fHasEmbedOrWbr       = li._fHasEmbedOrWbr;

        // TODO RTL 112514:    First/last chunks must have correct xLeft, xRight, fCleanBefore, etc.
        //                     Calculations like CalcRectsOfRangeOnLine depend on that.
        //                     It is unlcear to me if this must be true for first/last rather or
        //                     leftmost/rightmost. Both seem to be unnecessary complex. Why can't all
        //                     chunks have same flags and consistent offsets? The chunks are merely duplicates
        //                     of the container line, nothing is important there beyond offset and width.
        
        if(fLastLine) 
        {
            lifNew._cchWhite         = min(lifNew._cch, long(li._cchWhite));
            lifNew._xWhite           = min(lifNew._xWidth, long(li._xWhite));
            lifNew._xLineOverhang    = li._xLineOverhang;
            lifNew._fClearBefore     = li._fClearBefore;
            lifNew._fClearAfter      = li._fClearAfter;
            lifNew._fForceNewLine    = li._fForceNewLine;
            lifNew._fHasEOP          = li._fHasEOP;
            lifNew._fHasBreak        = li._fHasBreak;

            // TODO RTL 112514:
            //                     I would suppose that _xLineWidth should 
            //                     always equal to conainer line, but some code
            //                     elsewhere only expects that from the last fragment.
            //                     If a middle fragment has width that matches container width,
            //                     it causes line borders to ignore right margin.
            lifNew._xLineWidth       = li._xLineWidth;

            // TODO RTL 112514:
            //                     pure LTR case benefits from _xRight taken from original line
            //                     In other cases, we need to something trickier, and it is not quite working yet
            if(!li.IsRTLLine() && !fBiDiLine)
                lifNew._xRight       = li._xRight;
            else
            {
                // calculate _xRight to match line width
                // TODO RTL 112514:
                //                     this may not work in tables
                //                     (because _xLineWidth is very big during min/max pass)
                lifNew._xRight       = 0;
                lifNew._xRight       = lifNew._xLineWidth - lifNew.CalcLineWidth();
                Assert(lifNew._xRight >= 0 || !IsTagEnabled(tagDebugRTL));
            }
        }
        else
        {
            lifNew._cchWhite         = 0;
            lifNew._xWhite           = 0;
            lifNew._xLineOverhang    = 0;
            lifNew._fClearBefore     = FALSE;
            lifNew._fClearAfter      = FALSE;
            lifNew._fForceNewLine    = FALSE;
            lifNew._fHasEOP          = FALSE;
            lifNew._fHasBreak        = FALSE;

            lifNew._xRight       = 0;
            lifNew._xLineWidth   = lifNew.CalcLineWidth();
        }

        if (   !fFirstLine
            && _ptpStartForListItem
           )
        {
            LONG cpLIStart = _ptpStartForListItem->GetCp();
            LONG cpThisLine = me.GetCp() - cchLeft;
            LONG cchThisLine = lifNew._cch;

            if (   cpLIStart >= cpThisLine
                && cpLIStart < cpThisLine + cchThisLine
               )
            {
                CLineCore * pli0 = (*this)[iFirstChunk];

                lifNew._fHasBulletOrNum  = pli0->_fHasBulletOrNum;
                pli0->_fHasBulletOrNum  = FALSE;

                _ptpStartForListItem = NULL;
            }
        }
        fFirstLine  =  FALSE;
        plc         =  plc ? plc->_plcNext : NULL;
        xPos        =  lifNew._xLineWidth;  // note: unused unless all LTR
        xWidthLeft  -= lifNew._xWidth;
        cchLeft     -= lifNew._cch;
        
        _pdp->NoteMost(&lifNew);

        pliT->AssignLine(lifNew);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CalcParagraphSpacing
//
//  Synopsis:   Compute paragraph spacing for the current line
//
//-----------------------------------------------------------------------------
CTreeNode *
CRecalcLinePtr::CalcParagraphSpacing(
    CLSMeasurer *pMe,
    BOOL         fFirstLineInLayout)
{
    CTreePos *ptp = pMe->GetPtp();
    CTreeNode *pNode;
    
    Assert(   !ptp->IsBeginNode()
           || !_pdp->GetFlowLayout()->IsElementBlockInContext(ptp->Branch()->Element())
           || !ptp->Branch()->Element()->IsInlinedElement()
           || pMe->_li._fFirstInPara
           || ptp->GetBranch()->Element()->IsOverlapped()
          );
    
    // no bullet on the line
    pMe->_li._fHasBulletOrNum = FALSE;

    if (_fMoveBulletToNextLine)
    {
        pMe->_li._fHasBulletOrNum = TRUE;
        _fMoveBulletToNextLine = FALSE;
        _ptpStartForListItem = pMe->GetPtp();
    }
    
    // Reset these flags for every line that we measure.
    _fNoMarginAtBottom = FALSE;
    
    // Only interesting for the first line of a paragraph.
    if (pMe->_li._fFirstInPara || pMe->_fLastWasBreak)
    {
        ptp = CalcBeforeSpace(pMe, fFirstLineInLayout);
        pMe->_li._yBeforeSpace = _lTopPadding + _lNegSpace + _lPosSpace;

        if (_pci->_smMode == SIZEMODE_MMWIDTH)
        {
            DWORD uTextAlignLast = ptp->GetBranch()->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->_uTextAlignLast;

            if (    uTextAlignLast != styleTextAlignLastNotSet 
                &&  uTextAlignLast != styleTextAlignLastAuto    )
            {
                _pdp->SetLastLineAligned();
            }
        }

        //
        //  pre para space adjustment for print preview 
        //
        {
            CFlowLayout * pFlowLayout = _pdp->GetFlowLayout();
            Assert(pFlowLayout);

            if (pFlowLayout->ElementCanBeBroken())
            {
                CLayoutContext * pLayoutContext = pFlowLayout->LayoutContext();

                if (pLayoutContext && pLayoutContext->ViewChain())
                {
                    // adjust the Current y.
                    pMe->_pci->_yConsumed += pMe->_li._yBeforeSpace;
                }
            }
        }
    }
    // Not at the beginning of a paragraph, we have no interline spacing.
    else
    {
        pMe->_li._yBeforeSpace = 0;
    }
    if(ptp)
        pNode = ptp->GetBranch();
    else
        return NULL;
    pMe->MeasureSetPF(pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext())),
                      SameScope(pNode, _pdp->GetFlowLayout()->ElementContent()),
                      TRUE);

    return pNode; // formatting node
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::SetupMeasurerForBeforeSpace
//
//  Synopsis:   Setup the measurer so that it has all the post space info collected
//              from the previous line. This function is called only ONCE when
//              per recalclines loop. Subsequenlty we keep then spacing in sync
//              as we are measuring the lines.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
CRecalcLinePtr::SetupMeasurerForBeforeSpace(CLSMeasurer *pMe, LONG yHeight)
{
    CFlowLayout  *pFlowLayout = _pdp->GetFlowLayout();
    CElement     *pElementFL  = pFlowLayout->ElementContent();
    LONG          cpSave      = pMe->GetCp();
    CTreePos     *ptp;
    CTreeNode    *pNode;

    INSYNC(pMe);

    ResetPosAndNegSpace();
    
    _pdp->EndNodeForLine(pMe->GetCp(), pMe->GetPtp(), _pci, NULL, &ptp, &pMe->_pLS->_pNodeForAfterSpace);

    if (   ptp != pMe->GetPtp()
        || pMe->_pLS->_pNodeForAfterSpace
       )
    {
        pMe->SetPtp(ptp, -1);
    
        //
        // Having gone back to a point where there is some text or a layout(which
        // effectively means some text) we compute the "after" space. The point
        // which we go back to is effectively the point at which we would have
        // stopped measuring the previous line.
        //
        CalcAfterSpace(pMe, yHeight == 0, cpSave);
    }
    
    //
    // Be sure that calc after space gets us at the beginning of the
    // current line. If it leaves us before the current line then there is a
    // _VERY_ good chance that we will end up with more characters in the line
    // array than there are in the backing story.
    //
    Assert(pMe->GetCp() == cpSave);

    // initialize left and right padding & borderspace for parent block elements
    _xPadLeft = _xPadRight = _xBordLeft = _xBordRight = 0;
    _yPadTop = _yPadBottom = _yBordTop = _yBordBottom = 0;
    _xBordLeftPerLine = _xBordRightPerLine = _xPadLeftPerLine = _xPadRightPerLine = 0;

    pNode     = pMe->CurrBranch();

    // Measurer can be initialized for any line in the line array, so
    // compute the border and padding for all the block elements that
    // are currently in scope.
    if(DifferentScope(pNode, pElementFL))
    {
        CDoc      * pDoc = pFlowLayout->Doc();
        CTreeNode * pNodeTemp;
        CElement  * pElement;

        pNodeTemp = pMe->GetPtp()->IsBeginElementScope()
                        ? pNode->Parent()
                        : pNode;

        while(   pNodeTemp 
              && DifferentScope(pNodeTemp, pElementFL))
        {
            pElement = pNodeTemp->Element();
 
            if(     !pNodeTemp->ShouldHaveLayout()
                &&   pNodeTemp->GetCharFormat()->HasPadBord(FALSE)
                &&   pFlowLayout->IsElementBlockInContext(pElement))
            {
                const CFancyFormat * pFF = pNodeTemp->GetFancyFormat();
                const CCharFormat  * pCF = pNodeTemp->GetCharFormat();
                LONG lFontHeight = pCF->GetHeightInTwips(pDoc);
                BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
                BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

                if ( !pElement->_fDefinitelyNoBorders )
                {
                    CBorderInfo borderinfo;

                    pElement->_fDefinitelyNoBorders =
                        !GetBorderInfoHelper( pNodeTemp, _pci, &borderinfo, GBIH_NONE );
                    if ( !pElement->_fDefinitelyNoBorders )
                    {
                        _xBordLeftPerLine  += borderinfo.aiWidths[SIDE_LEFT];
                        _xBordRightPerLine += borderinfo.aiWidths[SIDE_RIGHT];
                    }
                }

                _xPadLeftPerLine  += pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                        _pci,
                                        _pci->_sizeParent.cx, 
                                        lFontHeight);
                _xPadRightPerLine += pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                        _pci,
                                        _pci->_sizeParent.cx, 
                                        lFontHeight);
            }
            pNodeTemp = pNodeTemp->Parent();
        }

        _xBordLeft  = _xBordLeftPerLine;
        _xBordRight = _xBordRightPerLine;
        _xPadLeft   = _xPadLeftPerLine;
        _xPadRight  = _xPadRightPerLine;
    }

    INSYNC(pMe);
    return;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CalcAfterSpace
//
//  Synopsis:   This function computes the after space of the line and adds
//              on the extra characters at the end of the line. Also positions
//              the measurer correctly (to the ptp at the ptp belonging to
//              the first character in the next line).
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
CRecalcLinePtr::CalcAfterSpace(CLSMeasurer *pMe, BOOL fFirstLineInLayout, LONG cpMax)
{
    CFlowLayout  *pFlowLayout = _pdp->GetFlowLayout();
    CTreeNode    *pNode;
    CElement     *pElement;
    CTreePos     *ptpStop;
    CTreePos     *ptp;
    CUnitValue    cuv;
    LONG          cpCurrent;
    BOOL          fConsumedFirstOne = pMe->_fEndSplayNotMeasured;
    BOOL          fContinueLooking = TRUE;
    BOOL          fConsumedBlockElement = FALSE;
    LONG          cchInPtp;
    
    INSYNC(pMe);
    
    if (pMe->_li._fForceNewLine)
    {
        ResetPosAndNegSpace();
    }

    if (pMe->_pLS->_pNodeForAfterSpace)
    {
        BOOL fConsumed;
        CollectSpaceInfoFromEndNode(pMe, pMe->_pLS->_pNodeForAfterSpace, fFirstLineInLayout,
                                    FALSE, &fConsumed);
    }
    
    Assert(_yPadBottom == 0);
    Assert(_yBordBottom == 0);

    ptpStop = pMe->_pLS->_treeInfo._ptpLayoutLast;
#if DBG==1
    {
        CTreePos *ptpStartDbg;
        CTreePos *ptpStopDbg;
        pFlowLayout->GetContentTreeExtent(&ptpStartDbg, &ptpStopDbg);
        Assert(ptpStop == ptpStopDbg);
    }
#endif
    
    for (cpCurrent = pMe->GetCp(), ptp = pMe->GetPtp();
         ptp && cpCurrent < cpMax && fContinueLooking;
         ptp = ptp->NextTreePos())
    {
        cchInPtp = ptp->GetCch();
        if (cchInPtp == 0)
        {
            Assert(   ptp->IsPointer()
                   || ptp->IsText()
                   || !ptp->IsEdgeScope()
                  );
            continue;
        }

        if (ptp == ptpStop)
            break;

        Assert(cpCurrent >= ptp->GetCp() && cpCurrent < ptp->GetCp() + ptp->GetCch());
        
        if (ptp->IsNode())
        {
            Assert(ptp->IsEdgeScope());
            pNode = ptp->Branch();
            pElement = pNode->Element();
            const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
            
            if (ptp->IsEndNode())
            {
                //
                // NOTE(SujalP):
                // If we had stopped because we had a line break then I cannot realistically
                // consume the end block element on this line. This would break editing when
                // the user hit shift-enter to put in a BR -- the P tag I was under has to
                // end in the next line since that is where the user wanted to see the caret.
                // IE bug 44561
                //
                if (pMe->_fLastWasBreak && _fIsEditable)
                    break;
                
                if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    const CFancyFormat * pFF = pNode->GetFancyFormat();
                    
                    pMe->_li._fHasEOP = TRUE;

                    ENI_RETVAL retVal = CollectSpaceInfoFromEndNode(pMe, pNode, fFirstLineInLayout,
                                                                    FALSE, &fConsumedBlockElement);
                    if (retVal == ENI_CONSUME_TERMINATE)
                    {
                        fContinueLooking = FALSE;
                    }
                    else if (retVal == ENI_TERMINATE)
                    {
                        fContinueLooking = FALSE;
                        break;
                    }

                    _fNoMarginAtBottom =    pElement->Tag() == ETAG_P
                                         && pElement->_fExplicitEndTag
                                         && !pFF->HasExplicitLogicalMargin(SIDE_BOTTOM, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);

                }
                // Else do nothing, just continue looking ahead

                // Just verifies that an element is block within itself.
                Assert(ptp != ptpStop);
            }
            else if (ptp->IsBeginNode())
            {
                if (pCF->IsDisplayNone())
                {
                    LONG cchHidden = pMe->GetNestedElementCch(pElement, &ptp);
                    
                    // Ptp gets updated inside GetNestedElementCch, so be sure to
                    // update cchInPtp too
                    cchInPtp = ptp->GetCch();

                    // Since we update the count below for everything, lets dec the
                    // count over here.
                    cchHidden -= cchInPtp;

                    // Add the characters to the line.
                    pMe->_li._cch += cchHidden;

                    // Also add them to the whitespace of the line
                    pMe->_li._cchWhite += (SHORT)cchHidden;

                    // Add to cpCurrent
                    cpCurrent += cchHidden;

                }
                
                // We need to stop when we see a new block element
                else if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    pMe->_li._fHasEOP = TRUE;
                    break;
                }

                // Or a new layout (including aligned ones, since these
                // will now live on lines of their own.
                else if (pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext())) || pNode->IsRelative(LC_TO_FC(_pci->GetLayoutContext())))
                    break;
                else if (pElement->Tag() == ETAG_BR)
                    break;
                else if (!pNode->Element()->IsNoScope())
                    break;
            }
            
            if (_fIsEditable )
            {
                if (fConsumedFirstOne && ptp->ShowTreePos())
                    break;
                else
                    fConsumedFirstOne = TRUE;
            }
        }
        else
        {
            Assert(ptp->IsText() && ptp->Cch() != 0);
            break;
        }

        Assert(cchInPtp == ptp->GetCch());
        
        // Add the characters to the line.
        pMe->_li._cch += cchInPtp;

        // Also add them to the whitespace of the line
        Assert((LONG)pMe->_li._cchWhite + cchInPtp < SHRT_MAX);
        pMe->_li._cchWhite += (SHORT)cchInPtp;

        // Add to cpCurrent
        cpCurrent += cchInPtp;
    }

    pMe->_fEmptyLineForPadBord = !fContinueLooking;

    // The last paragraph of a layout shouldn't have this flag set
    if( ptp == ptpStop )
        pMe->_li._fHasEOP = FALSE;
        
    if (pMe->GetPtp() != ptp)
        pMe->SetPtp(ptp, cpCurrent);

    INSYNC(pMe);
}


//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CalcBeforeSpace
//
//  Synopsis:   This function computes the before space of the line and remembers
//              the characters it has gone past in _li._cch.
//
//              Also computes border and padding (left and right too!) for
//              elements coming into scope.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CTreePos *
CRecalcLinePtr::CalcBeforeSpace(CLSMeasurer *pMe, BOOL fFirstLineInLayout)
{
    const CFancyFormat * pFF;
    const CParaFormat  * pPF;
    const CCharFormat  * pCF;
    CFlowLayout  *pFlowLayout = _pdp->GetFlowLayout();
    CDoc         *pDoc        = pFlowLayout->Doc();
    CTreeNode    *pNode       = NULL;
    CElement     *pElement;
    CTreePos     *ptpStop;
    CTreePos     *ptp;
    CTreePos     *ptpFormatting = NULL;
    BOOL          fSeenBeginBlockTag = FALSE;
    BOOL          fContinueLooking = TRUE;
    
    pMe->_fSeenAbsolute = FALSE;
    ptpStop = pMe->_pLS->_treeInfo._ptpLayoutLast;
#if DBG==1
    {
        CTreePos *ptpStartDbg;
        CTreePos *ptpStopDbg;
        pFlowLayout->GetContentTreeExtent(&ptpStartDbg, &ptpStopDbg);
        Assert(ptpStop == ptpStopDbg);
    }
#endif

    _xBordLeftPerLine = _xBordRightPerLine = _xPadLeftPerLine = _xPadRightPerLine = 0;
    pMe->_fEmptyLineForPadBord = FALSE;
    
    if (fFirstLineInLayout)
    {
        LONG lPadding[SIDE_MAX];
        _pdp->GetPadding(_pci, lPadding, _pci->_smMode == SIZEMODE_MMWIDTH);
        if (pFlowLayout->ElementContent()->TestClassFlag(CElement::ELEMENTDESC_TABLECELL))
        {
            _lTopPadding = lPadding[SIDE_TOP];
        }
        else
        {
            _lPosSpace = max(_lPosSpace, lPadding[SIDE_TOP]);
            _lNegSpace = min(_lNegSpace, lPadding[SIDE_TOP]);
            _lTopPadding = 0;
        }
    }
    else
        _lTopPadding = 0;

    for (ptp = pMe->GetPtp(); fContinueLooking; ptp = ptp->NextTreePos())
    {
	if(!ptp)
            break;

        if (ptp->IsPointer())
            continue;

        if (ptp == ptpStop)
            break;
        
        if (ptp->IsNode())
        {
            if (_fIsEditable && ptp->ShowTreePos())
                pMe->_fMeasureFromTheStart = TRUE;

            pNode = ptp->Branch();
            pElement = pNode->Element();
            BOOL fShouldHaveLayout = pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()));

            if (pNode->HasInlineMBP(LC_TO_FC(_pci->GetLayoutContext())))
                pMe->_fMeasureFromTheStart = TRUE;

            if (ptp->IsEndElementScope())
            {
                if(pNode->IsRelative() && !fShouldHaveLayout)
                    pMe->_fRelativePreChars = TRUE;

                if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    //
                    // If we encounter a break on empty block end tag, then we should
                    // give vertical space otherwise a <X*></X> where X is a block element
                    // will not produce any vertical space. (Bug 45291).
                    //
                    if (  pElement->_fBreakOnEmpty
                        && (   fSeenBeginBlockTag
                            || (   pMe->_fLastWasBreak
                                && _fIsEditable
                               )
                           )
                       )
                    {
                        break;
                    }

                    if (pMe->_fSeenAbsolute)
                        break;
                    
                    //
                    // If we are at an end LI it means that we have an
                    // empty LI for which we need to create an empty
                    // line. Hence we just break out of here. We will
                    // fall into the measurer with the ptp positioned
                    // at the end splay. The measurer will immly bail
                    // out, creating an empty line. CalcAfterSpace will
                    // go and then add the node char for the end LI to
                    // the line.
                    //
                    if (   IsGenericListItem(pNode)
                        && (   pMe->_li._fHasBulletOrNum
                            || (   pMe->_fLastWasBreak
                                && _fIsEditable
                               )
                           )
                       )
                    {
                        break;
                    }
                    
                    //
                    // Collect space info from the end node *only* if the previous
                    // line does not end in a BR. If it did, then the end block
                    // tag after does not contribute to the inter-paraspacing.
                    // (Remember, that a subsequent begin block tag will still
                    // contribute to the spacing!)
                    //
                    else if (!_fIsEditable || !pMe->_fLastWasBreak)
                    {
                        ENI_RETVAL retVal =
                               CollectSpaceInfoFromEndNode(pMe, pNode, fFirstLineInLayout, TRUE, NULL);
                        if (retVal == ENI_CONSUME_TERMINATE)
                        {
                            fContinueLooking = FALSE;
                        }
                        else if (retVal == ENI_TERMINATE)
                        {
                            pMe->_li._fIsPadBordLine = TRUE;
                            fContinueLooking = FALSE;
                            break;
                        }
                    }
                }
                // Else do nothing, just continue looking ahead

                // Just verifies that an element is block within itself.
                Assert(ptp != ptpStop);
            }
            else if (ptp->IsBeginElementScope())
            {
                pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
                pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
                pPF = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()));
                BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
                BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
                
                if (pCF->IsDisplayNone())
                {
                    // The extra one is added in the normal processing.
                    pMe->_li._cch += pMe->GetNestedElementCch(pElement, &ptp);
                    pMe->_li._cch -= ptp->GetCch();
                }
                else if (pElement->Tag() == ETAG_BR)
                {
                    break;
                }
                else
                {

                    BOOL fBlockElement = pFlowLayout->IsElementBlockInContext(pElement);

                    if(pNode->IsRelative(LC_TO_FC(_pci->GetLayoutContext())) && !fShouldHaveLayout)
                        pMe->_fRelativePreChars = TRUE;

                    if(     (pFF->_fClearLeft || pFF->_fClearRight)
                       // IE6 #32464
                       // Setting this bit will cause a cleared element to go searching for a text
                       // line anchor.  ON a new page, this won't exist, and the clear info is already
                       // implicit in the page break.                   
                       &&  !(   _pci->GetLayoutContext() 
                            &&  _pci->GetLayoutContext()->ViewChain()
                            &&  !_pci->_fHasContent )
                       )
                    {
                        _marginInfo._fClearLeft  |= pFF->_fClearLeft;
                        _marginInfo._fClearRight |= pFF->_fClearRight;
                    }

                    if (   fBlockElement
                        && pElement->IsInlinedElement())
                    {
                        fSeenBeginBlockTag = TRUE;
                        
                        if (pMe->_fSeenAbsolute)
                            break;
                        
                        LONG lFontHeight = pCF->GetHeightInTwips(pDoc);

                        if (pElement->HasFlag(TAGDESC_LIST))
                        {
                            Assert(pElement->IsBlockElement(LC_TO_FC(_pci->GetLayoutContext())));
                            if (pMe->_li._fHasBulletOrNum)
                            {
                                ptpFormatting = ptp;
                                
                                do
                                {
                                    ptpFormatting = ptpFormatting->PreviousTreePos();
                                } while (ptpFormatting->GetCch() == 0);

                                break;
                            }
                        }

                        //
                        // NOTE(SujalP): Bug 38806 points out a problem where an
                        // abs pos'd LI does not have a bullet follow it. To fix that
                        // one we decided that we will _not_ draw the bullet for LI's
                        // with layout (&& !fHasLayout). However, 61373 and its dupes
                        // indicate that this is overly restrictive. So we will change
                        // this case and not draw a bullet for only abspos'd LI's.
                        //
                        else if (   IsListItem(pNode)
                                 && !pNode->IsAbsolute()
                                )
                        {
                            Assert(pElement->IsBlockElement(LC_TO_FC(_pci->GetLayoutContext())));
                            pMe->_li._fHasBulletOrNum = TRUE;
                            _ptpStartForListItem = ptp;
                        }

                        // if a dd is comming into scope and is a
                        // naked DD, then compute the first line indent
                        if(     pElement->Tag() == ETAG_DD
                            &&  pPF->_fFirstLineIndentForDD)
                        {
                            CUnitValue cuv;
                        
                            cuv.SetPoints(LIST_INDENT_POINTS);
                            _xLeadAdjust += cuv.XGetPixelValue(_pci, 0, 1);
                        }

                        // if a block element is comming into scope, it better be
                        // the first line in the paragraph.
                        Assert(pMe->_li._fFirstInPara || pMe->_fLastWasBreak);
                        pMe->_li._fFirstInPara = TRUE;
                        
                        // compute padding and border height for the elements comming
                        // into scope
                        if(     !fShouldHaveLayout
                            &&  pCF->HasPadBord(FALSE))
                        {
                            LONG yPadTop;
                            const CUnitValue & cuvPaddingLeft  = pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed);
                            const CUnitValue & cuvPaddingRight = pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed);

                            if ( !pElement->_fDefinitelyNoBorders )
                            {
                                CBorderInfo borderinfo;

                                pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, _pci, &borderinfo, GBIH_NONE );
                                if ( !pElement->_fDefinitelyNoBorders )
                                {
                                    // If the blockelement has any border (or padding) and the
                                    // top padding is non zero then we need to
                                    // create a line to draw the border. The line
                                    // will just contain the start of the block element.
                                    // Similar thing happens at the end of the block element.
                                    if (borderinfo.aiWidths[SIDE_TOP])
                                    {
                                        fContinueLooking = FALSE;
                                        _yBordTop      += borderinfo.aiWidths[SIDE_TOP];
                                    }
                                    _xBordLeftPerLine  += borderinfo.aiWidths[SIDE_LEFT];
                                    _xBordRightPerLine += borderinfo.aiWidths[SIDE_RIGHT];
                                }
                            }

                            yPadTop = pFF->GetLogicalPadding(SIDE_TOP, fNodeVertical, fWritingModeUsed).YGetPixelValue(
                                                    _pci,
                                                    _pci->_sizeParent.cx, 
                                                    lFontHeight);
                            if (yPadTop)
                            {
                                fContinueLooking = FALSE;
                                _yPadTop += yPadTop;
                            }
                            
                            _xPadLeftPerLine  += cuvPaddingLeft.XGetPixelValue(_pci, _pci->_sizeParent.cx, lFontHeight);
                            _xPadRightPerLine += cuvPaddingRight.XGetPixelValue(_pci, _pci->_sizeParent.cx, lFontHeight);
                                                    
                            // If we have horizontal padding in percentages, flag the display
                            // so it can do a full recalc pass when necessary (e.g. parent width changes)
                            // Also see ApplyLineIndents() where we do this for horizontal indents.
                            if (cuvPaddingLeft.IsPercent() || cuvPaddingRight.IsPercent())
                            {
                                _pdp->_fContainsHorzPercentAttr = TRUE;
                            }
                        }

                        //
                        // CSS attributes page break before/after support.
                        // There are two mechanisms that add to provide full support: 
                        // 1. CRecalcLinePtr::CalcBeforeSpace() and CRecalcLinePtr::CalcAfterSpace() 
                        //    is used to set CLineCore::_fPageBreakBefore/After flags only(!) for 
                        //    nested elements which have no their own layout (i.e. paragraphs). 
                        // 2. CEmbeddedILSObj::Fmt() sets CLineCore::_fPageBreakBefore for nested 
                        //    element with their own layout that are NOT allowed to break (always) 
                        //    and for nested elements with their own layout that ARE allowed to 
                        //    break if this is the first layout in the view chain. 
                        //
                        if (   // print view 
                               _pci->GetLayoutContext() 
                            && _pci->GetLayoutContext()->ViewChain() 
                               // and element is nested element without a layout
                            && !fShouldHaveLayout    
                            )
                        {
                            // does any block elements comming into scope force a
                            // page break before this line
                            if (GET_PGBRK_BEFORE(pFF->_bPageBreaks))
                            {
                                CLayoutBreak *  pLayoutBreak;

                                pMe->_li._fPageBreakBefore = TRUE;
                                _pci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
                                _pci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 

                                _pci->GetLayoutContext()->GetEndingLayoutBreak(pFlowLayout->ElementOwner(), &pLayoutBreak);
                                if (pLayoutBreak)
                                {
                                    DYNCAST(CFlowLayoutBreak, pLayoutBreak)->_pElementPBB = pElement;
                                }
                            }
                        }

                        // If we're the first line in the scope, we only care about our
                        // pre space if it has been explicitly set.
                        if ((   !pMe->_li._fHasBulletOrNum
                             && !fFirstLineInLayout
                            )
                            || pFF->HasExplicitLogicalMargin(SIDE_TOP, fNodeVertical, fWritingModeUsed)
                           )
                        {
                            // If this is in a PRE block, then we have no
                            // interline spacing.
                            if (!(   pNode->Parent()
                                  && pNode->Parent()->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasPre(FALSE)
                                 )
                               )
                            {
                                LONG lTemp;

                                lTemp = pFF->_cuvSpaceBefore.YGetPixelValue(_pci,
                                                           _pci->_sizeParent.cx,
                                                           lFontHeight);

                                // Maintain the positives.
                                _lPosSpace = max(lTemp, _lPosSpace);

                                // Keep the negatives separately.
                                _lNegSpace =  min(lTemp, _lNegSpace);
                            }
                        }
                    }
                    else if (!fBlockElement)
                    {
                        if (pCF->_fHasInlineBg)
                        {
                            pMe->_fMeasureFromTheStart = TRUE;
                        }
                    }

                    //
                    // If we have hit a nested layout then we quit so that it can be measured.
                    // Note that we have noted the before space the site contributes in the
                    // code above.
                    //
                    // Absolute positioned nested layouts at BOL are a part of the pre-chars
                    // of the line. We also skip over them in FormattingNodeForLine.
                    //
                    if (fShouldHaveLayout)
                    {
                        pMe->_fHasNestedLayouts = TRUE;

                        //
                        // Should never be here for hidden layouts. They should be
                        // skipped over earlier in this function.
                        //
                        Assert(!pCF->IsDisplayNone());
                        if (pNode->IsAbsolute(LC_TO_FC(_pci->GetLayoutContext())))
                        {
                            LONG cchElement = pMe->GetNestedElementCch(pElement, &ptp);

                            pMe->_fSeenAbsolute = TRUE;
                            
                            // The extra one is added in the normal processing.
                            pMe->_li._cch +=  cchElement - ptp->GetCch();
                            pMe->_cchAbsPosdPreChars += cchElement; 
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            Assert(ptp->IsText());
            if (ptp->Cch())
                break;
        }

        pMe->_li._cch += ptp->GetCch();
    }

    pMe->_fEmptyLineForPadBord = !fContinueLooking;

    if (ptp != pMe->GetPtp())
        pMe->SetPtp(ptp, -1);

    _xBordLeft  += _xBordLeftPerLine;
    _xBordRight += _xBordRightPerLine;
    _xPadLeft   += _xPadLeftPerLine;
    _xPadRight  += _xPadRightPerLine;

     return ptpFormatting ? ptpFormatting : ptp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CollectSpaceInfoFromEndNode
//
//  Synopsis:   Computes the space info when we are at the end of a block element.
//
//  Returns:    A BOOL indicating if any space info was collected.
//
//-----------------------------------------------------------------------------

ENI_RETVAL
CRecalcLinePtr::CollectSpaceInfoFromEndNode(
    CLSMeasurer *pMe, 
    CTreeNode *  pNode,
    BOOL         fFirstLineInLayout,
    BOOL         fPadBordForEmptyBlock,
    BOOL *       pfConsumedBlockElement)
{
    Assert(pNode);

    ENI_RETVAL retVal = ENI_CONTINUE;
    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
    const CCharFormat *pCF  = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
    BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    
    CUnitValue cuv;
    
    Assert(   _pdp->GetFlowLayout()->IsElementBlockInContext(pNode->Element())
           || pNode->Element()->IsOwnLineElement(_pdp->GetFlowLayout())
          );
    CElement *pElement = pNode->Element();
    CDoc     *pDoc     = pElement->Doc();
    BOOL      fPadBord = pCF->HasPadBord(FALSE);
    BOOL      fShouldHaveLayout = pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()));
    
    // compute any padding or border height from elements
    // going out of scope 
    if(     !fShouldHaveLayout 
        &&   fPadBord)
    {
        LONG lFontHeight = pCF->GetHeightInTwips(pDoc);
        LONG xBordLeft, xBordRight, xPadLeft, xPadRight;

        xBordLeft = xBordRight = xPadLeft = xPadRight = 0;
        
        if ( !pElement->_fDefinitelyNoBorders )
        {
            CBorderInfo borderinfo;

            pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, _pci, &borderinfo, GBIH_NONE );
            if ( !pElement->_fDefinitelyNoBorders )
            {
                if (borderinfo.aiWidths[SIDE_BOTTOM])
                {
                    // If we are called from CalcBeforeSpace, and we run into an end node
                    // which has border, then just terminate without processing the node
                    // (ie dont collect spacing info, dont consume the character, dont
                    // modify xBordLeft/xBordRight etc). This is because this node should
                    // be consume in *CalcAfterSpace* since the width of the bottom border
                    // needs to be added into _yBordBottom -- which will eventually find
                    // its way into the descent of the line. This way we will get a line
                    // similar to others, except its natural height will be 0, but will
                    /// will eventually get a height after CalcAfterSpace is called.
                    if(fPadBordForEmptyBlock)
                    {
                        // Cause the line to be no more than just this /div character
                        retVal = ENI_TERMINATE;
                    }

                    // We got here during CalcBeforeSpace. 2 cases are worth mentioning:
                    // 1) There was text before this ptp, which was collected during
                    //    measuring the line.
                    // 2) We got here because measure line terminated right away because
                    //    it saw an end splay without seeing any characters. This would
                    //    happen if the line begins with a end splay (CalcBeforeSpace
                    //    would have terminated right away as we saw before).
                    else
                    {
                        Assert(pfConsumedBlockElement);

                        // Now, if during CalcAfterSpace, we saw an end block (block element A)
                        // ptp which did not have a bottom border (in which case
                        // *pfConsumeBlockElement will be TRUE) and then we see an end block
                        // (block element B) ptp which had a bottom border then we should
                        // terminate the line without consuming the end splay, since all the
                        // content on the line belongs to block element A and putting more
                        // content on the same line from block element B is incorrect (remember
                        // rendered border constitues content).
                        // Also note, that CalcAfterSpace always stops when it sees a beging
                        // ptp for a block  element. Hence *pfConsumedBlockElement is only
                        // telling us whether we have seen an end ptp of a block element.
                        if (*pfConsumedBlockElement)
                        {
                            retVal = ENI_TERMINATE;
                        }

                        // Finally, we have seen an end block element which has a bottom
                        // border. Consume it and stop further consumption, since we cannot
                        // add more stuff on this line now.
                        else
                        {
                            _yBordBottom += borderinfo.aiWidths[SIDE_BOTTOM];
                            retVal = ENI_CONSUME_TERMINATE;
                        }
                    }
                }

                // Remember, if we are not consuming the character, we should not
                // adjust the borders.
                if (retVal != ENI_TERMINATE)
                {
                    xBordLeft   = borderinfo.aiWidths[SIDE_LEFT];
                    xBordRight  = borderinfo.aiWidths[SIDE_RIGHT];
                }
            }
        }

        // The same argument as for borders is valid for padding too.
        LONG yPadBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed).YGetPixelValue(
            _pci,
            _pci->_sizeParent.cx, 
            lFontHeight);
        if (yPadBottom)
        {
            if(fPadBordForEmptyBlock)
            {
                retVal = ENI_TERMINATE;
            }
            else
            {
                Assert(pfConsumedBlockElement);
                if (*pfConsumedBlockElement)
                {
                    retVal = ENI_TERMINATE;
                }
                else
                {
                    _yPadBottom += yPadBottom;
                    retVal = ENI_CONSUME_TERMINATE;
                }
            }
        }
        if (retVal != ENI_TERMINATE)
        {
            xPadLeft  = pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                    _pci,
                                    _pci->_sizeParent.cx, 
                                    lFontHeight);
            xPadRight = pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                    _pci,
                                    _pci->_sizeParent.cx, 
                                    lFontHeight);
        }
        
        //
        // If fPadBordForEmptyBlock is true it means that we are called from CalcBeforeSpace.
        // During CalcBeforeSpace, the padding and border is collected in the per-line variables
        // and then accounted into _x[Pad|Bord][Left|Right] variables at the end of the call.
        // Hence when we are measuring for empty block elements, we remove their padding
        // and border from the perline varaibles, but when we are called from CalcAfterSpace
        // we remove it from the actual _x[Pad|Bord][Left|Right] variables.
        //
        if (fPadBordForEmptyBlock)
        {
            _xBordLeftPerLine  -= xBordLeft;
            _xBordRightPerLine -= xBordRight;
            _xPadLeftPerLine   -= xPadLeft;
            _xPadRightPerLine  -= xPadRight;
        }
        else
        {
            _xBordLeft  -= xBordLeft;
            _xBordRight -= xBordRight;
            _xPadLeft   -= xPadLeft;
            _xPadRight  -= xPadRight;
        }
    }

    if (   !fFirstLineInLayout
        && retVal != ENI_TERMINATE
       )
    {
        if (pfConsumedBlockElement)
            *pfConsumedBlockElement = TRUE;
        
        // Treading the fine line of Nav3, Nav4 and IE3 compat,
        // we include the bottom margin as long as we're not
        // the last line in the text site or not a P tag. This
        // is broadly Nav4 compatible.
        if (   pElement->_fExplicitEndTag
            || pFF->HasExplicitLogicalMargin(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed)
           )
        {
            // Deal with things proxied around text sites differently,
            // so we need to know when we're above the containing site.
            //if (pElement->GetLayout() == pFlowLayout)
            //break;

            // If this is in a PRE block, then we have no
            // interline spacing.
            if (!(   pNode->Parent()
                     && pNode->Parent()->GetParaFormat()->HasPre(TRUE)
                 )
               )
            {
                LONG lTemp;
                cuv = pFF->_cuvSpaceAfter;

                lTemp = cuv.YGetPixelValue(_pci,
                                           _pci->_sizeParent.cx,
                                           pNode->GetFontHeightInTwips(&cuv));

                _lPosSpace = max(lTemp, _lPosSpace);
                _lNegSpace = min(lTemp, _lNegSpace);
                if (pElement->Tag() != ETAG_P || pFF->HasExplicitLogicalMargin(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed))
                {
                    _lPosSpaceNoP = max(lTemp, _lPosSpaceNoP);
                    _lNegSpaceNoP = min(lTemp, _lNegSpaceNoP);
                }
            }
        }
    }

    //
    // CSS attributes page break before/after support.
    // There are two mechanisms that add to provide full support: 
    // 1. CRecalcLinePtr::CalcBeforeSpace() and CRecalcLinePtr::CalcAfterSpace() 
    //    is used to set CLineCore::_fPageBreakBefore/After flags only(!) for 
    //    nested elements which have no their own layout (i.e. paragraphs). 
    // 2. CEmbeddedILSObj::Fmt() sets CLineCore::_fPageBreakBefore for nested 
    //    element with their own layout that are NOT allowed to break (always) 
    //    and for nested elements with their own layout that ARE allowed to 
    //    break if this is the first layout in the view chain. 
    //
    if (   // print view 
           _pci->GetLayoutContext() 
        && _pci->GetLayoutContext()->ViewChain() 
           // and element is nested element without a layout
        && !fShouldHaveLayout 
        )
    {
        // does any blocks going out of scope force a page break
        if (fPadBordForEmptyBlock)
        {
            if (GET_PGBRK_AFTER(pFF->_bPageBreaks))
            {
                CLayoutBreak *  pLayoutBreak;

                // if this is an empty block set page break BEFORE for the line
                pMe->_li._fPageBreakBefore = TRUE; 

                _pci->GetLayoutContext()->GetEndingLayoutBreak(_pdp->GetFlowLayout()->ElementOwner(), &pLayoutBreak);
                if (pLayoutBreak)
                {
                    DYNCAST(CFlowLayoutBreak, pLayoutBreak)->_pElementPBB = pElement;
                }
            }
        }
        else 
        {
            pMe->_li._fPageBreakAfter |= !!GET_PGBRK_AFTER(pFF->_bPageBreaks);
        }

        _pci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
        _pci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 
    }

    return retVal;
}

BOOL
CRecalcLinePtr::AlignFirstLetter(CLSMeasurer *pme,
                                 int iLineStart,
                                 int iLineFirst,
                                 LONG *pyHeight,
                                 LONG *pyAlignDescent,
                                 CTreeNode *pNodeFormatting
                                )
{
    BOOL fRet = FALSE;
    LONG yHeight = *pyHeight;
    CLineFull lif;
    CLineCore *pli;
    CTreeNode *pNode;
    LONG yBS = pme->_li._yBeforeSpace;
    
    Assert(pme->_li._fHasFirstLetter);
    Assert(pme->_li._fHasFloatedFL);
    Assert(!pme->_li.IsFrame());

    pNode = _pdp->GetMarkup()->SearchBranchForBlockElement(pNodeFormatting, pme->_pFlowLayout);
    Assert(pNode);
    Assert(pNode->GetFancyFormat()->_fHasFirstLetter);

    Reset(iLineStart);
    for (LONG i = 0; i < pme->_aryFLSlab.Size(); i++)
    {
        pli = AddLine();
        if (!pli)
            goto Cleanup;

        lif = pme->_li;
        lif._iLOI = -1;
        lif._fLeftAligned = TRUE;
        lif._cchFirstLetter = lif._cch - lif._cchWhite;
        lif._cch = 0;
        lif._cchWhite = 0;
        lif._fClearBefore = i > 0;
        lif._fClearAfter = FALSE;
        lif._xLineWidth = (lif._xWidth - pme->_aryFLSlab[i]._xWidth) + lif._xLeft; 
        lif._fFrameBeforeText = FALSE;
        lif._pNodeForFirstLetter = pNode;
        lif._yBeforeSpace = yBS;
        if (pme->_aryFLSlab.Size() > 1)
            lif._yHeight = pme->_aryFLSlab[i]._yHeight + yBS;
        yBS += pme->_aryFLSlab[i]._yHeight;
        
        pli->AssignLine(lif);

        if (i == 0)
        {
            _marginInfo._xLeftMargin += lif._xLineWidth;
            _marginInfo._fAddLeftFrameMargin = FALSE;
            _marginInfo._yLeftMargin = yHeight + lif._yHeight;
        }
        if (yHeight + lif._yHeight > _marginInfo._yBottomLeftMargin)
        {
            _marginInfo._yBottomLeftMargin = yHeight + lif._yHeight;
            if (yHeight + lif._yHeight > *pyAlignDescent)
            {
                *pyAlignDescent = yHeight + lif._yHeight;
            }
        }
    }
    
    fRet = TRUE;
Cleanup:
    return fRet;
}

CSaveRLP::CSaveRLP(CRecalcLinePtr *prlp)
{
    Assert(prlp);
    _prlp = prlp;
    _marginInfo = prlp->_marginInfo;
    _xLeadAdjust = prlp->_xLeadAdjust;
    _xBordLeftPerLine = prlp->_xBordLeftPerLine;
    _xBordLeft = prlp->_xBordLeft;
    _xBordRightPerLine = prlp->_xBordRightPerLine;
    _xBordRight = prlp->_xBordRight;
    _yBordTop = prlp->_yBordTop;
    _yBordBottom = prlp->_yBordBottom;
    _xPadLeftPerLine = prlp->_xPadLeftPerLine;
    _xPadLeft = prlp->_xPadLeft;
    _xPadRightPerLine = prlp->_xPadRightPerLine;
    _xPadRight = prlp->_xPadRight;
    _yPadTop = prlp->_yPadTop;
    _yPadBottom = prlp->_yPadBottom;
    _ptpStartForListItem = prlp->_ptpStartForListItem;
    _lTopPadding = prlp->_lTopPadding;
    _lPosSpace = prlp->_lPosSpace;
    _lNegSpace = prlp->_lNegSpace;
    _lPosSpaceNoP = prlp->_lPosSpaceNoP;
    _lNegSpaceNoP = prlp->_lNegSpaceNoP;
}

CSaveRLP::~CSaveRLP()
{
    Assert(_prlp);
    _prlp->_marginInfo = _marginInfo;
    _prlp->_xLeadAdjust = _xLeadAdjust;
    _prlp->_xBordLeftPerLine = _xBordLeftPerLine;
    _prlp->_xBordLeft = _xBordLeft;
    _prlp->_xBordRightPerLine = _xBordRightPerLine;
    _prlp->_xBordRight = _xBordRight;
    _prlp->_yBordTop = _yBordTop;
    _prlp->_yBordBottom = _yBordBottom;
    _prlp->_xPadLeftPerLine = _xPadLeftPerLine;
    _prlp->_xPadLeft = _xPadLeft;
    _prlp->_xPadRightPerLine = _xPadRightPerLine;
    _prlp->_xPadRight = _xPadRight;
    _prlp->_yPadTop = _yPadTop;
    _prlp->_yPadBottom = _yPadBottom;
    _prlp->_ptpStartForListItem = _ptpStartForListItem;
    _prlp->_lTopPadding = _lTopPadding;
    _prlp->_lPosSpace = _lPosSpace;
    _prlp->_lNegSpace = _lNegSpace;
    _prlp->_lPosSpaceNoP = _lPosSpaceNoP;
    _prlp->_lNegSpaceNoP = _lNegSpaceNoP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\runptr.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module RUNPTR.C -- Text run and run pointer class |
 *  
 *  Original Authors: <nl>
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 *
 *  History: <nl>
 *      6/25/95 alexgo  Commented and Cleaned up.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

//
//  Invariant stuff
//
#define DEBUG_CLASSNAME CRunPtrBase

#include "_invar.h"

// ===========================  CRunPtrBase class  ==================================================

#if DBG==1
   
/*
 *  CRunPtrBase::Invariant()
 *
 *  @mfunc
 *      Debug-only function that validates the internal state consistency
 *      for CRunPtrBase
 *
 *  @rdesc
 *      TRUE always (failures assert)
 */
BOOL CRunPtrBase::Invariant() const
{
    CTxtRun *pRun;

    if( _prgRun == NULL )
    {
        Assert( GetIRun() == 0 );
        // we let ich zoom around a conceptual 
        // run so it can stay in sync with a text pointer
        Assert( GetIch() >= 0 );
        
        return TRUE;
    }

    pRun = _prgRun->Elem( GetIRun() );

    if( pRun == NULL )
    {
        Assert(GetIRun() == 0);
        // we let ich zoom around a conceptual 
        // run so it can stay in sync with a text pointer
        Assert( GetIch() >= 0 );
    }
    else
    {
        Assert( GetIRun() < NumRuns() );
        Assert( GetIch() <= long( pRun->_cch ) );
    }

    return TRUE;
}

/*
 *  CRunPtrBase::GetTotalCch()
 *
 *  @mfunc
 *      Calculate length of text by summing text runs accessible by this
 *      run ptr
 *
 *  @rdesc
 *      length of text so calculated, or -1 if failed
 */

long
CRunPtrBase::GetTotalCch ( ) const
{
    long iRun;
    long cchText = 0;

    AssertSz(_prgRun, "CTxtPtr::GetCch() - Invalid operation on single run CRunPtr");

    for( iRun = NumRuns() ; iRun && iRun-- ; )
        cchText += _prgRun->Elem(iRun)->_cch;

    return cchText;
}

#endif


/* 
 *  CRunPtrBase::SetRun(iRun, ich)
 *
 *  @mfunc
 *      Sets this run ptr to the given run.  If it does not
 *      exist, then we set ourselves to the closest valid run
 *
 *  @rdesc
 *      TRUE if moved to iRun
 */

BOOL
CRunPtrBase::SetRun( long iRun, long ich )
{
    BOOL      bRet = TRUE;
    long      nRuns = NumRuns();
    CTxtRun * pRun;
 
    if (!_prgRun)
        return FALSE;

    if (iRun >= nRuns)
    {
        bRet = FALSE;
        iRun = nRuns - 1;
    }
    
    if (iRun < 0)
    {
        bRet = FALSE;
        iRun = 0;
    }
    
    SetIRun( iRun );

    // Set the offset

    pRun = _prgRun->Elem( iRun );

    if (pRun)
        SetIch( min( ich, long( pRun->_cch ) ) );

    return bRet;
}
                                                
/*
 *  CRunPtrBase::NextRun()
 *
 *  @mfunc
 *      Change this RunPtr to that for the next text run
 *
 *  @rdesc
 *      TRUE if succeeds, i.e., target run exists
 */

BOOL
CRunPtrBase::NextRun()
{
    _TEST_INVARIANT_

    if (_prgRun)
    {    
        if (GetIRun() < NumRuns() - 1)
        {
            SetIRun( GetIRun() + 1 );
            SetIch( 0 );
            
            return TRUE;
        }
    }
    
    return FALSE;
}

/*
 *  CRunPtrBase::PrevRun()
 *
 *  @mfunc
 *      Change this RunPtr to that for the previous text run
 *
 *  @rdesc
 *      TRUE if succeeds, i.e., target run exists
 */

BOOL
CRunPtrBase::PrevRun()
{
    _TEST_INVARIANT_

    if (_prgRun)
    {
        SetIch( 0 );
        
        if (GetIRun() > 0)
        {
            SetIRun( GetIRun() - 1 );
            
            return TRUE;
        }
    }
    
    return FALSE;
}

/*
 *  CRunPtrBase::GetCp()
 *
 *  @mfunc
 *      Get cp of this RunPtr
 *
 *  @rdesc
 *      cp of this RunPtr
 *
 *  @devnote
 *      May be computationally expensive if there are many elements
 *      in the array (we have to run through them all to sum cch's.
 *      Used by TOM collections and Move commands, so needs to be fast.
 */

DWORD
CRunPtrBase::GetCp () const
{
    DWORD       cp   = GetIch();
    DWORD       iRun = GetIRun();
    CTxtRun *   pRun;

    _TEST_INVARIANT_

    if (_prgRun && iRun)
    {
        DWORD cb = _prgRun->Size();
        
        pRun = GetRunRel( -1 );
        
        while ( iRun-- )
        {
            Assert( pRun );
            
            cp += pRun->_cch;
            
            pRun = (CTxtRun *)((BYTE *)pRun - cb);
        }
    }
    
    return cp;
}

/*
 *  CRunPtrBase::BindToCp(cp)
 *
 *  @mfunc
 *      Set this RunPtr to correspond to a cp.
 *
 *  @rdesc
 *      the cp actually set to
 */

DWORD
CRunPtrBase::BindToCp( DWORD cp )
{
    SetIRun( 0 );
    SetIch( 0 );
    
    return DWORD( AdvanceCp( cp ) );
}

/*
 *  CRunPtrBase::AdvanceCp(cch)
 *
 *  @mfunc
 *      Advance this RunPtr by (signed) cch chars.  If it lands on the
 *      end of a run, it automatically goes to the start of the next run
 *      (if one exists). If this is violated, many bad things may happen,
 *      so change at your peril.
 *
 *  @rdesc
 *      Count of characters actually moved
 */
LONG CRunPtrBase::AdvanceCp(
    LONG cch)           //@parm signed count of chars to move this RunPtr by
{
    DWORD   cchSave = cch;
    WHEN_DBG( long lRunCount = NumRuns(); )

    AssertSz(GetIRun() == 0 || (GetIRun() > 0 && _prgRun), "Invalid CRunPtr");

    // No runs, so just update _ich as if there were a run
    if(!IsValid())
    {
        SetIch( GetIch() + cch );

        // We have to assume that caller ensures that cch isn't too large,
        // since a runless run ptr doesn't know the cch of the document.
        // But we can check for too-negative values of cch: 
        if( GetIch() < 0 )
        {
            cch = -cch + GetIch();              // Calculate actual cch moved
            SetIch( 0 );
        }
        return cch;
    }


    if(cch < 0)
    {
        while(cch < 0)
        {
            // this cast to LONG is OK, since -cch will be positive
            // (and we aren't likely to have 3 billion characters in 
            // a given run :-)
            if( -cch <= GetIch() )
            {
                SetIch( GetIch() + cch );
                cch = 0;
                break;
            }
            // otherwise, we need to go to the previous run

            cch += GetIch();                        // we moved by the number of
                                                // characters left in the 
                                                // current run.
            if (GetIRun() <= 0)                      // Already in first run
            {
                SetIRun( 0 );
                SetIch( 0 );                       // Move to run beginning
                break;
            }
            
            // move to previous run.
            
            Assert(_prgRun->Elem(GetIRun() - 1));

            SetIRun( GetIRun() - 1 );
            
            SetIch( _prgRun->Elem( GetIRun() )->_cch );
        }
    }
    else
    {
        while(cch > 0)                          // Move forward
        {
            const long cchRun = _prgRun->Elem(GetIRun())->_cch;

            SetIch( GetIch() + cch );

            if (GetIch() < cchRun)                   // Target is in this run
            {
                cch = 0;                        // Signal countdown completed
                break;                          // (if _ich = cchRun, go to
            }                                   //  next run)   

            cch = GetIch() - cchRun;                // Advance to next run

            if (GetIRun() + 1 >= NumRuns())
            {
                Assert(GetIRun() == NumRuns() - 1);
                Assert(_prgRun->Elem(GetIRun())->_cch == cchRun);
                SetIch( cchRun );
                break;
            }

            SetIRun( GetIRun() + 1 );
            
            SetIch( 0 );  // Start at beginning of new run.
        }
    }

#if DBG == 1
    // Guarantee that a) we're not changing the run count and
    //                b) We're not at the end of a non-empty run.
    // Much code depends on this behaviour of AdvanceCp().
    // - Arye
    Assert (lRunCount == NumRuns());
    Assert (GetCchRemaining() != 0 ||
            cch == 0 ||
            GetIRun() == NumRuns() - 1);
#endif


    // NB! we check the invariant at the end to handle the case where
    // we are updating the cp for a floating range (i.e., we know that
    // the cp is invalid, so we fix it up).  So we have to check for
    // validity *after* the fixup.
    _TEST_INVARIANT_

    return cchSave - cch;                       // Return TRUE if countdown
}                                               // completed

/*
 *  CRunPtrBase::AdjustBackward()
 *
 *  @mfunc
 *      If the cp for this run ptr is at the "boundary" or edge between two
 *      runs, then make sure this run ptr points to the end of the first run.
 *
 *  @comm
 *      This function does nothing unless this run ptr points to the beginning
 *      or the end of a run.  This function may be needed in those cases
 *      because a cp at the beginning of a run is identical to the cp for the
 *      end of the previous run (if it exists), i.e., such an "edge" cp is
 *      ambiguous, and you may need to be sure that this run ptr points to the
 *      end of the first run.
 *
 *      For example, consider a run that describes characters at cp's 0 to 10
 *      followed by a run that describes characters at cp's 11 through 12. For
 *      a cp of 11, it is possible for the run ptr to be either at the *end*
 *      of the first run or at the *beginning* of the second run.
 *
 *
 *  @rdesc  nothing
 */
BOOL CRunPtrBase::AdjustBackward()
{
    _TEST_INVARIANT_

    //
    // If not at beginning of run or can't go to rev run then can't
    // adjust forward
    //

    if (GetIch() || !PrevRun())
        return FALSE;

    SetIch( _prgRun->Elem(GetIRun())->_cch );
    
    return TRUE;
}

/*
 *  CRunPtrBase::AdjustForward()
 *
 *  @mfunc
 *      If the cp for this run ptr is at the "boundary" or edge between two
 *      runs, then make sure this run ptr points to the start of the second
 *      run.
 *
 *  @rdesc
 *      nothing
 *
 *  @xref
 *      <mf CRunPtrBase::AdjustBackward>
 */
BOOL CRunPtrBase::AdjustForward()
{
    _TEST_INVARIANT_

    if( !_prgRun )
        return FALSE;

    CTxtRun *pRun = _prgRun->Elem(GetIRun());

    Assert( pRun );

    Assert( GetIch() <= long( pRun->_cch ) );
        
    if (long( pRun->_cch ) == GetIch())
        return NextRun();
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\segment.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Segment.CXX
//
// Contents:    Implementation of CSegment and CElementSegment class
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SEGMENT_HXX_
#define X_SEGMENT_HXX_
#include "segment.hxx"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include "initguid.h"
#endif

PRIVATE_GUID(CLSID_CSegment, 0x3050f693, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)

MtDefine(CCaretSegment, Utilities, "CCaretSegment")
MtDefine(CSegment, Utilities, "CSegment")
MtDefine(CElementSegment, Utilities, "CElementSegment")

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

//-----------------------------------------------------------------------------
//
//  Function:   CSegment::CSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CSegment::CSegment()
{
    Assert( _pIStart == NULL );
    Assert( _pIEnd == NULL );
    Assert( _pPrev == NULL );
    Assert( _pNext == NULL );

    _ulRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegment::~CSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CSegment::~CSegment(void)
{
#if DBG == 1
    // Verify that no other elements in the list are 
    // referencing this object
    if( GetPrev() )
        Assert( GetPrev()->GetNext() != this );

    if( GetNext() )
        Assert( GetNext()->GetPrev() != this );
#endif        
    ReleaseInterface(_pIStart);
    ReleaseInterface(_pIEnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSegment::Init
//
//  Synopsis:   Initializes a segment.  Makes a copy of the markup pointers
//              passed in.
//
//  Arguments:  pIStart = Start of segment
//              pIEnd = End of segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSegment::Init( IMarkupPointer  *pIStart,
                IMarkupPointer  *pIEnd )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {
        _pIStart = pIStart;
        _pIStart->AddRef();

        _pIEnd = pIEnd;
        _pIEnd->AddRef();

        hr = S_OK;
    }        

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the beginning and end of the
//              current segment, respectively
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSegment::GetPointers(  IMarkupPointer *pIStart,
                        IMarkupPointer *pIEnd )
{
    HRESULT hr = E_INVALIDARG;
    BOOL    fResult = FALSE;
    
    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {
        //
        // Position the pointers in the correct order
        //
        IFC( _pIStart->IsLeftOfOrEqualTo( _pIEnd, &fResult ) );

        if( fResult )
        {
            IFC( pIStart->MoveToPointer( _pIStart ) );
            IFC( pIEnd->MoveToPointer( _pIEnd ) );
        }
        else
        {
            IFC( pIStart->MoveToPointer( _pIEnd ) );
            IFC( pIEnd->MoveToPointer( _pIStart ) );
        }
            
        //
        // Set the gravity up for the commands
        //
        IFC( pIStart->SetGravity( POINTER_GRAVITY_Right ) );
        IFC( pIEnd->SetGravity( POINTER_GRAVITY_Left ) );
    }        

Cleanup:

#if DBG == 1
    if( hr == S_OK )
    {
        BOOL fPositionedStart = FALSE;
        BOOL fPositionedEnd = FALSE;

        IGNORE_HR( pIStart->IsPositioned( & fPositionedStart ));
        IGNORE_HR( pIEnd->IsPositioned( & fPositionedEnd ));

        Assert( fPositionedStart && fPositionedEnd );
    }        
#endif

    RRETURN( hr );
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegment )
    {
        *ppvObj = (ISegment *)this;
    }
    else if( iid == CLSID_CSegment )
    {
        *ppvObj = this;
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

//-----------------------------------------------------------------------------
//
//  Function:   CElementSegment::CElementSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CElementSegment::CElementSegment() : CSegment()
{
    Assert( _pIElement == NULL );
    _ulRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::~CElementSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CElementSegment::~CElementSegment(void)
{
    ReleaseInterface(_pIElement);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::Init
//
//  Synopsis:   Initializes a segment around an IHTMLElement.
//
//  Arguments:  pIElement = IHTMLElement to initialize segment around
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CElementSegment::Init( IHTMLElement *pIElement )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIElement );

    if( pIElement )
    {
        _pIElement = pIElement;
        _pIElement->AddRef();
        hr = S_OK;
    }        

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the beginning and end of the
//              IHTMLElement for the element segment
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CElementSegment::GetPointers(   IMarkupPointer *pIStart,
                                IMarkupPointer *pIEnd )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {
        // Position the pointers
        IFC( ( pIStart->MoveAdjacentToElement(_pIElement, ELEM_ADJ_BeforeBegin) ) );
        IFC( ( pIEnd->MoveAdjacentToElement(_pIElement, ELEM_ADJ_AfterEnd) ) );

        // Setup the gravity
        IFC( pIStart->SetGravity( POINTER_GRAVITY_Right ) );
        IFC( pIEnd->SetGravity( POINTER_GRAVITY_Left ) );        

        hr = S_OK;
    }        

Cleanup:    
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::GetElement
//
//  Synopsis:   Returns the element represented by this segment
//
//  Arguments:  ppIElement = Output pointer to IHTMLElement
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CElementSegment::GetElement(IHTMLElement **ppIElement)
{
    HRESULT hr = E_INVALIDARG;

    Assert( ppIElement );

    if( ppIElement )
    {
        hr = _pIElement->QueryInterface(IID_IHTMLElement, (void **)ppIElement );
    }

    RRETURN( hr );
}

HRESULT
CElementSegment::SetPrimary( BOOL fPrimary )
{
    _fPrimary = fPrimary;
    return S_OK;
}

HRESULT
CElementSegment::IsPrimary( BOOL* pfIsPrimary)
{
    Assert( pfIsPrimary );
    if ( pfIsPrimary)
    {
        *pfIsPrimary = _fPrimary;
        return S_OK;
    }
    else
        return E_INVALIDARG;
}
        
//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CElementSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ISegment)
    {
        *ppvObj = (ISegment *)((IElementSegment *)this);
    }
    else if (iid == IID_IElementSegment)
    {
        *ppvObj = (IElementSegment *)this;
    }
    else if( iid == CLSID_CSegment )
    {
        *ppvObj = this;
        return S_OK;
    }   
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

//-----------------------------------------------------------------------------
//
//  Function:   CCaretSegment::CCaretSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CCaretSegment::CCaretSegment() : CSegment()
{
    _ulRefs = 1;
    _pICaret = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaretSegment::~CCaretSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CCaretSegment::~CCaretSegment(void)
{
    ReleaseInterface(_pICaret);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaretSegment::Init
//
//  Synopsis:   Initializes a caret segment.
//
//  Arguments:  pICaret = Pointer to caret interface
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CCaretSegment::Init( IHTMLCaret *pICaret )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pICaret );

    if( pICaret )
    {
        _pICaret = pICaret;
        _pICaret->AddRef();

        hr = S_OK;
    }        

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaretSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the caret position.
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CCaretSegment::GetPointers( IMarkupPointer *pIStart,
                            IMarkupPointer *pIEnd )
{
    HRESULT     hr = S_OK;

    Assert( pIStart && pIEnd );
    
    // Position our pointers at the caret
    IFC( _pICaret->MoveMarkupPointerToCaret( pIStart ) );
    IFC( _pICaret->MoveMarkupPointerToCaret( pIEnd ) );

    // Set up the gravity
    IFC( pIStart->SetGravity( POINTER_GRAVITY_Right ) );
    IFC( pIEnd->SetGravity( POINTER_GRAVITY_Left ) );         

Cleanup:
    RRETURN( hr );
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCaretSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ISegment)
    {
        *ppvObj = (ISegment *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\rel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       rel.cxx
//
//  Contents:   Implementation of some code for relatively positioned lines.
//
//  Classes:    CDisplay
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

DeclareTag(tagRelPositioning, "Relative Positioning", "Relative Positioning");

MtDefine(CDisplayDrawRelElemBgAndBorder_aryNodesWithBgOrBorder_pv, Locals, "CDisplay::DrawRelElemBgAndBorder aryNodesWithBgOrBorder::_pv")
MtDefine(CDisplayDrawRelElemBgAndBorder_aryRects_pv, Locals, "CDisplay::DrawRelElemBgAndBorder aryRects::_pv")
MtDefine(CDisplayAddRelDispNodes_aryRelDispNodeCtxs_pv, Locals, "CDisplay::AddRelDispNodes aryRelDispNodeCtxs::_pv")
MtDefine(CDisplayUpdateRelDispNodeCache_rdnc_pv, Locals, "CDisplay::UpdateRelDispNodeCache rdnc::_pv")

MtExtern(CDisplay)
MtDefine(MtStoredRFE, CDisplay, "CStoredRFE")
MtDefine(MtStoredRFE_aryRect_pv, CDisplay, "MtStoredRFE_aryRect_pv")


extern CDispNode * EnsureContentNode(CDispNode * pDispNode);

void CDisplay::RcFromLine(RECT *prc, LONG top, LONG ili, CLineCore *pli, CLineOtherInfo *ploi)
{
    Assert(pli == Elem(ili));
    Assert(pli->oi() == ploi);

    // If it is the first fragment in a line with relative chunks use only
    // the margin space otherwise use the text left or right.
    if (!pli->IsRTLLine())
    {
        /* LTR */
        prc->left   = ((IsLogicalFirstFrag(ili) || pli->_fHasBulletOrNum)
                    ? ploi->_xLeftMargin
                    : ploi->GetTextLeft());

        prc->right  = ploi->_xLeftMargin + pli->_xLineWidth
                    + (pli->_fForceNewLine ? ploi->_xWhite : 0);
    }
    else
    {
        /* RTL */
        // TODO RTL 112514: this should be using same code as RegionFromElement()
        prc->right  = GetViewWidth()
                    - ((IsLogicalFirstFrag(ili) || pli->_fHasBulletOrNum)
                                ? ploi->_xRightMargin
                                : pli->GetRTLTextRight(ploi));

        prc->left   = GetViewWidth()
                    - (ploi->_xRightMargin + pli->_xLineWidth
                        + (pli->_fForceNewLine ? ploi->_xWhite : 0));
    }

    // If the line has negative margin, we need to use the larger
    // rect because text goes into the negative margin space.
    prc->top    = top + pli->GetYTop(ploi);
    prc->bottom = top + max(pli->GetYHeight(), pli->GetYBottom(ploi));
}

void
CDisplay::VoidRelDispNodeCache()
{
    if(HasRelDispNodeCache())
    {
        CRelDispNodeCache * prdnc = GetRelDispNodeCache();

        prdnc->DestroyDispNodes();

        delete DelRelDispNodeCache();
    }
}

CRelDispNodeCache *
CDisplay::GetRelDispNodeCache() const
{
    CDoc * pDoc = GetFlowLayout()->Doc();
#if DBG == 1
    if(HasRelDispNodeCache())
    {
        void * pLookasidePtr =  pDoc->GetLookasidePtr((DWORD *)this);

        Assert(pLookasidePtr == _pRelDispNodeCache);

        return (CRelDispNodeCache *)pLookasidePtr;
    }
    else
        return NULL;
#else
    return (CRelDispNodeCache *)(HasRelDispNodeCache() ? pDoc->GetLookasidePtr((DWORD *)this) : NULL);
#endif
}

HRESULT
CDisplay::SetRelDispNodeCache(void * pvVal)
{
    HRESULT hr = THR(GetFlowLayout()->Doc()->SetLookasidePtr((DWORD *)this, pvVal));

    if (hr == S_OK)
    {
        _fHasRelDispNodeCache = 1;
#if DBG == 1
        Assert(!_pRelDispNodeCache);

        _pRelDispNodeCache = (CRelDispNodeCache *)pvVal;
#endif
    }

    RRETURN(hr);
}

CRelDispNodeCache *
CDisplay::DelRelDispNodeCache()
{
    if (HasRelDispNodeCache())
    {
        void * pvVal = GetFlowLayout()->Doc()->DelLookasidePtr((DWORD *)this);
        _fHasRelDispNodeCache = 0;
#if DBG == 1
        Assert(_pRelDispNodeCache == pvVal);

        _pRelDispNodeCache = NULL;

        TraceTag((tagRelPositioning, "Deleting RelDispNodeCache - Element(Tag: %ls, SN:%ld)",
                                        GetFlowLayoutElement()->TagName(),
                                        GetFlowLayoutElement()->SN()));
#endif
        return(CRelDispNodeCache *)pvVal;
    }

    return(NULL);
}


CRelDispNodeCache *
CDisplay::EnsureRelDispNodeCache()
{
    Assert(!HasRelDispNodeCache());

    CRelDispNodeCache * prdnc = new CRelDispNodeCache(this);

    if(prdnc)
    {
        TraceTag((tagRelPositioning, "Creating RelDispNodeCache - %x", prdnc));
        SetRelDispNodeCache(prdnc);
    }

    return prdnc;
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::UpdateDispNodeCache
//
// Synopsis:    Update the relative line cache smartly using the line edit
//              descriptor
//
//-----------------------------------------------------------------------------

void
CDisplay::UpdateRelDispNodeCache(CLed * pled)
{
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    CStackDataAry<CRelDispNode, 4>  rdnc(Mt(CDisplayUpdateRelDispNodeCache_rdnc_pv));
    CLed                led;
    long                iliMatchNew;
    long                dy;
    long                dili;

    TraceTag((tagRelPositioning, "Entering: CDisplay::UpdateRelDispNodeCache - Element(Tag: %ls, SN:%ld)",
                                    GetFlowLayoutElement()->TagName(),
                                    GetFlowLayoutElement()->SN()));

    if(!pled)
    {
        pled = &led;
        pled->_yFirst = pled->_iliFirst = 0;
        pled->_cpFirst = GetFlowLayout()->GetContentFirstCpForBrokenLayout();
        pled->SetNoMatch();
    }

    dy   = pled->_yMatchNew - pled->_yMatchOld;
    dili = pled->_iliMatchNew - pled->_iliMatchOld;

    iliMatchNew = pled->_iliMatchNew == MAXLONG ? LineCount() : pled->_iliMatchNew;

    {
        CRelDispNode      * prdn = NULL;
        long                lSize;
        long                iEntry, iEntryStart, iEntryFinish;
        long                iliFirst   = pled->_iliFirst;
        long                yFirst     = pled->_yFirst;
        long                cpFirst    = pled->_cpFirst;
        long                cNewEntries;

        lSize = prdnc ? prdnc->Size() : 0;

        if(prdnc)
        {
            // find the node that corresponds to iliFirst
            for ( iEntryStart = 0, prdn = (*prdnc)[0];
                  iEntryStart < lSize && prdn->_ili + prdn->_cLines <= iliFirst;
                  iEntryStart++, prdn++);
        }
        else
        {
            iEntryStart = 0;
        }

        iEntryFinish = -1;

        // find the last entry affected by the lines changed
        if ( iEntryStart < lSize)
        {
            // if the region affected starts in the middle of the
            // disp node, then update the affected range to include
            // the entire dispnode.
            if(prdn->_ili < iliFirst)
            {
                iliFirst = prdn->_ili;
                yFirst  = prdn->_yli;
                cpFirst = prdn->GetElement()->GetFirstCp() - 1;
            }

            if (iliMatchNew != LineCount())
            {
                for(iEntryFinish = iEntryStart;
                    iEntryFinish < lSize && prdn->_ili < pled->_iliMatchOld;
                    iEntryFinish++, prdn++);
            }
            else
            {
                iEntryFinish = lSize;
            }

        }

        //
        // Add the new entries to temporary stack
        //
        AddRelNodesToCache(cpFirst, yFirst, iliFirst, iliMatchNew, &rdnc);
        cNewEntries = rdnc.Size();


        //
        // Destroy the display nodes that correspond to the entries
        // in the dirty range
        //
        if(iEntryStart < lSize)
        {
            long i, iNewEntry = 0;
            long diEntries;

            prdn = (*prdnc)[iEntryStart];
            // now remove all the entries that are affected
            for ( iEntry = iEntryStart; iEntry < iEntryFinish; iEntry++, prdn++)
            {
                i = iNewEntry;

                if(cNewEntries && prdn->_pDispNode->IsContainer())
                {
                    //
                    // Replace old disp containers with the new ones, to ensure that all
                    // children are properly parented to the new container.
                    //
                    for( ; i < cNewEntries; i++)
                    {
                        CRelDispNode * prdnNewEntry = &rdnc.Item(i);

                        //
                        // Do not dereference, prdn->_pElement, it might have been destroyed.
                        //
                        if(     prdn->GetElement()
                            &&  prdnNewEntry->GetElement() == prdn->GetElement()
                            &&  prdnNewEntry->_pDispNode->IsContainer())
                        {
                            CSize       size;

                            // start at the next entry, so that we can start
                            // the search for the next container after the
                            // current entry. Both the caches are in source order
                            iNewEntry = i + 1;

                            GetFlowLayout()->GetView()->ExtractDispNode(prdn->_pDispNode);

                            TraceTag((tagRelPositioning, "\tReplacing dispnode for element(Tag: %ls, SN:%ld) from %ld",
                                        prdnNewEntry->GetElement()->TagName(),
                                        prdnNewEntry->GetElement()->SN(),
                                        iEntry));

                            size = prdnNewEntry->_pDispNode->GetSize();
                            prdnNewEntry->_pDispNode->ReplaceNode(prdn->_pDispNode);
                            prdnNewEntry->_pDispNode->SetSize(size, NULL, FALSE);

                            if (IsRTLDisplay())
                                SetRelDispNodeContentOrigin(prdnNewEntry->_pDispNode);

                            for (CDispNode* pDispNode = prdnNewEntry->_pDispNode->GetFirstFlowChildNode();
                                            pDispNode;
                                            pDispNode = pDispNode->GetNextFlowNode())
                            {
                                if (pDispNode->IsOwned())
                                {
                                    CElement *  pElement;

                                    pDispNode->GetDispClient()->GetOwner(pDispNode, (void **)&pElement);

                                    if (    pElement
                                        &&  pElement->ShouldHaveLayout())
                                    {
                                        pElement->ZChangeElement();
                                    }
                                }
                            }
                            break;
                        }
                    }

                    if( i == cNewEntries)
                    {
                        prdn->ClearContents();
                    }
                }
                else
                {
                    prdn->ClearContents();
                }
            }

            diEntries = cNewEntries - iEntryFinish + iEntryStart;

            // move all the disp nodes that follow the
            // affected entries
            if( iEntryFinish != lSize && (dy || dili || diEntries))
            {
                TraceTag((tagRelPositioning, "\tMoving Entries %ld - %ld by %ld",
                    iEntryFinish,
                    lSize,
                    diEntries));

                long iLastLine = -1;

                for (iEntry = iEntryFinish, prdn = (*prdnc)[iEntryFinish];
                     iEntry < lSize;
                     iEntry++, prdn++)
                {
                    prdn->_ili += dili;
                    prdn->_yli += dy;

                    if (iLastLine <= prdn->_ili)
                    {
                        prdn->_pDispNode->SetPosition(prdn->_pDispNode->GetPosition() + CSize(0, dy));
                        iLastLine = prdn->_ili + prdn->_cLines;
                    }

                    prdn->_pDispNode->SetExtraCookie((void *)(LONG_PTR)(iEntry + diEntries));
                }
            }

            if(iEntryStart < iEntryFinish)
            {
                // delete all the old entries in the dirty range
                prdnc->Delete(iEntryStart, iEntryFinish - 1);
            }
        }

        //
        // Insert the new entries in the dirty range, back to the cache
        //
        if(cNewEntries)
        {
            long iEntryInsert = iEntryStart;
            prdnc = GetRelDispNodeCache();

            Assert(prdnc);

            prdn = &rdnc.Item(0);
            for(iEntry = 0; iEntry < cNewEntries; iEntry++, prdn++, iEntryInsert++)
            {
                long xPos = prdn->_ptOffset.x;
                CPoint ptAuto(xPos, prdn->_ptOffset.y + prdn->_yli);

                prdnc->InsertAt(iEntryInsert, *prdn);

                prdn->_pDispNode->SetExtraCookie((void *)(LONG_PTR)(iEntryInsert));

                //
                // Ensure flow node for each of the newly created containers
                //
                if(prdn->_pDispNode->IsContainer())
                {
                    CDispNode * pDispContent = EnsureContentNode(prdn->_pDispNode);

                    if(pDispContent)
                    {
                        pDispContent->SetSize(prdn->_pDispNode->GetSize(), NULL, FALSE);

                        // note: content origin and position are initialized in EnsureContentNode
                    }
                }

                TraceTag((tagRelPositioning, "\tAdding Element(Tag: %ls, SN:%ld) at %ld",
                                prdn->GetElement()->TagName(),
                                prdn->GetElement()->SN(),
                                iEntryInsert));
                //
                // Fire off a ZChange notification to insert it in the appropriate
                // ZLayer and ZParent.
                //
                prdn->GetElement()->ZChangeElement(NULL, &ptAuto, GetFlowLayout()->LayoutContext());

                Assert(prdnc->Size() > (iEntryInsert));
            }
        }
    }

    prdnc = GetRelDispNodeCache();

    if(prdnc && !prdnc->Size())
        delete DelRelDispNodeCache();

    GetFlowLayout()->_fContainsRelative = HasRelDispNodeCache();
    TraceTag((tagRelPositioning, "\tContainsRelative: %ls", HasRelDispNodeCache() ? "TRUE" : "FALSE"));
    TraceTag((tagRelPositioning, "Leaving: CDisplay::UpdateRelDispNodeCache"));
}

struct CRelDispNodeCtx
{
    CElement *  _pElement;
    CRect       _rc;
    long        _cpEnd;
    long        _cLines;
    long        _ili;
    long        _yli;
    long        _iEntry;
    BOOL        _fHasChildren;
    LONG        _xAnchor;  // descending's anchor point x-coordinate
};

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::AddDispNodesToCache
//
// Synopsis:    Add new display nodes to the cache in the range of lines changed
//
//-----------------------------------------------------------------------------
void
CDisplay::AddRelNodesToCache(
    long cpFirst,
    long yli,
    long iliStart,
    long iliMatchNew,
    CDataAry<CRelDispNode> * prdnc)
{
    CStackDataAry<CRelDispNodeCtx, 4> aryRelDispNodeCtx(Mt(CDisplayAddRelDispNodes_aryRelDispNodeCtxs_pv));
    CRelDispNodeCtx   * prdnCtx = NULL;
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CMarkup     * pMarkup = pFlowLayout->GetContentMarkup();
    CLineCore   * pli;
    long          ili;
    long          ich;
    long          iTop = -1;
    long          cpTopEnd = MINLONG;
    long          cpLayoutMax = pFlowLayout->GetContentLastCp();
    long          iEntryInsert = 0;
    long          lCount = LineCount();
    BOOL          fDesignMode = pFlowLayout->IsEditable(TRUE);

    CLayoutContext *pLayoutContext = pFlowLayout->LayoutContext();
    BOOL            fViewChain = pLayoutContext && pLayoutContext->ViewChain();

    if (fViewChain)
    {
        CTreePos *  ptp = pMarkup->TreePosAtCp(cpFirst, &ich);
        CTreeNode * pNode = ptp->GetBranch();
        CElement *  pElementRel = pNode->Element();

        //  If elment just begins we will insert later;
        if (ptp->IsBeginElementScope())
        {
            pNode = pNode->Parent();
            pElementRel = pNode->Element();
        }

        while (pElementRel != pFlowLayout->ElementOwner())
        {
            if (pElementRel->IsRelative() && !pElementRel->ShouldHaveLayout())
            {
                CRelDispNode rdn;
                CRelDispNodeCtx rdnCtx;

                if(!GetRelDispNodeCache())
                {
                    if(!EnsureRelDispNodeCache())
                        return;
                }

                prdnc->InsertIndirect(0, &rdn);
                aryRelDispNodeCtx.InsertIndirect(0, &rdnCtx);
                prdnCtx = &aryRelDispNodeCtx.Item(0);

                if(!prdnCtx)
                    return;

                prdnCtx->_pElement = pElementRel;
                prdnCtx->_ili      = iliStart;
                prdnCtx->_yli      = yli;
                prdnCtx->_cpEnd    = min(pElementRel->GetLastCp(), cpLayoutMax);
                prdnCtx->_rc       = g_Zero.rc;
                prdnCtx->_cLines   = 0;
                prdnCtx->_fHasChildren = FALSE;

                iTop++;

                Assert(aryRelDispNodeCtx.Size() == iTop + 1);
            }

            pNode = pNode->Parent();
            pElementRel = pNode->Element();
        }

        {
            int i;

            for (i = 0; i <= iTop; ++i)
            {
                prdnCtx = &aryRelDispNodeCtx.Item(i);

                prdnCtx->_iEntry = i;
                cpTopEnd = prdnCtx->_cpEnd;
            }

            iEntryInsert = iTop + 1;    //  (bug #12997)
        }
    }

    //
    // Note: here we are trying to walk lines beyond iliMatchNew to update the
    // rc of the elements that came into scope in the dirty region
    //

    for (ili = iliStart;
         ili < lCount && (ili < iliMatchNew || cpFirst <= cpTopEnd);
         ili++)
    {
        pli = Elem(ili);

        // create a new entry only for elements in the dirty range
        // (ili < iliMatchNew)
        if (pli->_fRelative && pli->_cch && ili < iliMatchNew)
        {
            CTreePos *ptp = pMarkup->TreePosAtCp(cpFirst, &ich);
            CElement *pElementRel = ptp->GetBranch()->Element();

            // if the current line is relative and a new element
            // is comming into scope, then push a new reldispnode
            // context on to the stack.
            if(     ptp->IsBeginElementScope()
                &&  pElementRel->IsRelative()
                &&  !pElementRel->ShouldHaveLayout())
            {
                CRelDispNode rdn;

                if(!GetRelDispNodeCache())
                {
                    if(!EnsureRelDispNodeCache())
                        return;
                }

                prdnc->InsertIndirect(iEntryInsert, &rdn);

                prdnCtx = aryRelDispNodeCtx.Append();

                if(!prdnCtx)
                    return;

                cpTopEnd           = min(pElementRel->GetLastCp(), cpLayoutMax);
                prdnCtx->_pElement = pElementRel;
                prdnCtx->_ili      = ili;
                prdnCtx->_yli      = yli;
                prdnCtx->_cpEnd    = cpTopEnd;
                prdnCtx->_rc       = g_Zero.rc;
                prdnCtx->_xAnchor  = 0;
                prdnCtx->_iEntry   = iEntryInsert++;

                iTop++;

                Assert(aryRelDispNodeCtx.Size() == iTop + 1);
            }

        }

        // if we have a relative element in context, add the
        // current line to it
        if(iTop >= 0)
        {
            CRect rcLine;

            Assert(prdnCtx);

            prdnCtx->_cLines++;

            // TODO RTL 112514:    This doesn't work in bidi scenarios. It occasionally returns
            //                     correct rectangle. The way it is currently implementede, it
            //                     is really hard to fix. The whole relative positioning should
            //                     be re-implemented using a cleaner desing; when that happens,
            //                     RTL won't be a problem.
            // note: this is the only caller of RcFromLine
            RcFromLine(&rcLine, yli, ili, pli, pli->oi());

            // Relative elements define a positioning origin whose x-coord
            // is where its text on its first line begins.
            if (prdnCtx->_cLines == 1)
                prdnCtx->_xAnchor = pli->oi()->GetTextLeft();

            // Add non-empty lines to the rect
            if(!IsRectEmpty(&rcLine))
            {
                UnionRect((RECT *)&prdnCtx->_rc, (RECT *)&prdnCtx->_rc, (RECT *)&rcLine);
            }
            // If we're dealing with the 1st line, even an empty rect is important,
            // because it contains offset information (i.e. top = bottom = 5)
            else if ( prdnCtx->_cLines == 1)
            {
                prdnCtx->_rc = rcLine;
            }

            if(pli->IsFrame() || pli->_fHasEmbedOrWbr || pli->_fRelative)
                prdnCtx->_fHasChildren = TRUE;

        }

        cpFirst  += pli->_cch;

        if(pli->_fForceNewLine)
            yli += pli->_yHeight;


        // if the current relative element is going out of scope,
        // then create a disp node for the element and send a zchange
        // notification.
        while(((cpFirst > cpTopEnd) || (ili == lCount - 1)) && iTop >= 0)
        {
            VISIBILITYMODE vis = VISIBILITYMODE_INHERIT;

            CRelDispNode * prdn = &prdnc->Item(prdnCtx->_iEntry);

            // pop the top rel disp node context and create a disp item for it
            // and update the parent disp node context
            prdn->SetElement( prdnCtx->_pElement);
            prdn->_ili        = prdnCtx->_ili;
            prdn->_yli        = prdnCtx->_yli;
            prdn->_cLines     = prdnCtx->_cLines;
            prdn->_ptOffset.x = prdnCtx->_rc.left;
            prdn->_ptOffset.y = prdnCtx->_rc.top - prdnCtx->_yli;
            prdn->_xAnchor    = prdnCtx->_xAnchor;

            // TODO RTL 112514: This is not always correct in RTL
            prdn->_xAnchor -= prdn->_ptOffset.x;

            // guess what extras the display node will need
            DWORD dwDispExtras = DISPEX_EXTRACOOKIE;
            if (IsRTLDisplay())
                dwDispExtras |= DISPEX_CONTENTORIGIN;

            // create the display node
            if(prdnCtx->_fHasChildren)
            {
                prdn->_pDispNode = CDispContainer::New(
                                                GetRelDispNodeCache(),
                                                dwDispExtras);

                if (prdn->_pDispNode != NULL)
                {
                    // Some of the children may be -ve'ly positioned, so we need to set
                    // the background bit on the dispnode to get called with a DrawClientBackground
                    // before we draw any -ve'ly positioned children
                    prdn->_pDispNode->SetBackground(TRUE);

                }
            }
            else
            {
                prdn->_pDispNode = (CDispNode *)CDispLeafNode::New(
                                                GetRelDispNodeCache(),
                                                dwDispExtras);
            }

            if(!prdn->_pDispNode)
                goto Error;

            prdn->_pDispNode->SetSize(prdnCtx->_rc.Size() , NULL, FALSE);
            prdn->_pDispNode->SetOwned(TRUE);
            prdn->_pDispNode->SetAffectsScrollBounds(fDesignMode);

            if (IsRTLDisplay())
                SetRelDispNodeContentOrigin(prdn->_pDispNode);

            switch (prdn->GetElement()->GetFirstBranch()->GetCascadedvisibility())
            {
            case styleVisibilityVisible:
                vis = VISIBILITYMODE_VISIBLE;
                break;

            case styleVisibilityHidden:
                vis = VISIBILITYMODE_INVISIBLE;
                break;

            case styleVisibilityInherit:
            default:
                vis = prdn->GetElement()->GetFirstBranch()->GetCharFormat()->_fVisibilityHidden
                                        ? VISIBILITYMODE_INVISIBLE
                                        : VISIBILITYMODE_VISIBLE;
            }

            Assert(vis == VISIBILITYMODE_VISIBLE || vis == VISIBILITYMODE_INVISIBLE);
            prdn->_pDispNode->SetVisible(vis == VISIBILITYMODE_VISIBLE);

            //
            // Append the current cLines & rc to the parent's
            // cache entry, if the current element is nested.
            //
            if(iTop > 0)
            {
                CRelDispNodeCtx * prdnCtxT = prdnCtx;

                prdnCtx = &aryRelDispNodeCtx.Item(iTop - 1);
                prdnCtx->_fHasChildren = TRUE;
                prdnCtx->_cLines += prdnCtxT->_cLines;
                cpTopEnd = prdnCtx->_cpEnd;

                // update the parent's context
                UnionRect( (RECT *)&prdnCtx->_rc,
                           (RECT *)&prdnCtx->_rc,
                           (RECT *)&prdnCtxT->_rc);

            }
            else
            {
                prdnCtx  = NULL;
                cpTopEnd = MINLONG;
            }

            aryRelDispNodeCtx.Delete(iTop--);
        }
    }
Cleanup:

#if DBG==1
    {
        CRelDispNode *  prdn        = &prdnc->Item(0);
        int             cNewEntries = prdnc->Size();

        while (--cNewEntries >= 0)
        {
            Assert(     prdn->_pDispNode
                    &&  prdn->GetElement()
                    &&  "CDisplay::AddRelNodesToCache() is about to return inconsistent RelDispNode array!!!");
            prdn++;
        }
    }
#endif

    return;
Error:
    goto Cleanup;
}

// note: DestroyDispNode is here and not an inline to prevent a dependency from
// _disp.h on dispnode.hxx, which makes Display Tree development difficult due
// to the large number of files that must be compiled when dispnode.hxx changes.
void
CRelDispNode::DestroyDispNode()
{
    Assert(_pDispNode != NULL);
    _pDispNode->Destroy();
    _pDispNode = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:    CRelDispNodeCache::GetOwner
//
// Synopsis:    Get the owning element of the given disp node.
//
//-----------------------------------------------------------------------------
void
CRelDispNodeCache::GetOwner(
    CDispNode const* pDispNode,
    void ** ppv)
{
    CRelDispNode *  prdn;
    long            lEntry;

    Assert(pDispNode);
    Assert(pDispNode->GetDispClient() == this);
    Assert(ppv);
    Assert(Size());

    // we could be passed in a dispNode corresponding to the
    // content node of a container, in which case return the
    // element owner of the container.
    if(!pDispNode->IsOwned())
    {
        CDispNode * pDispNodeParent = pDispNode->GetParentNode();

        Assert(pDispNodeParent); // Relative disp nodes must have a parent.
        Assert(pDispNodeParent->GetDispClient() == this);

        lEntry = (LONG)(LONG_PTR)pDispNodeParent->GetExtraCookie();
    }
    else
    {
        lEntry = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
    }

    Assert(lEntry >= 0 && lEntry < Size());

    prdn = (*this)[lEntry];

    Assert (prdn->_pDispNode == pDispNode ||
            prdn->_pDispNode == pDispNode->GetParentNode());

    *ppv = prdn->GetElement();
}


long GetRelCacheEntry(CDispNode * pDispNode)
{
    long    lEntry;

    //
    // Find the index of the the cache entry that corresponds to the given node.
    // Extra cookie on the disp node stores the index into the cache.
    //
    // For container nodes, their flow node is passed in as a display node
    // to be rendered, so we need to get the parent's cookie instead.
    //
    if(!pDispNode->IsOwned())
    {
        CDispNode * pDispNodeParent = pDispNode->GetParentNode();

        Assert(pDispNodeParent); // Relative disp nodes must have a parent.

        lEntry = (LONG)(LONG_PTR)pDispNodeParent->GetExtraCookie();
    }
    else
    {
        lEntry = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
    }

    return lEntry;
}

BOOL
CRelDispNodeCache::GetAnchorPoint(CDispNode* pDispNode, CPoint* pPoint)
{
    long index = GetRelCacheEntry(pDispNode);
    if (unsigned(index) >= unsigned(Size()))
        return FALSE;
    CRelDispNode * pdn = &_aryRelDispNodes[index];
    pPoint->x = pdn->_xAnchor;
    pPoint->y = 0;
    return TRUE;
}


BOOL
CRelDispNodeCache::HitTestContent(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData,
    BOOL  fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CFlowLayout   * pFL = _pdp->GetFlowLayout();
    CElement      * pElementDispNode;
    CRelDispNode *  prdn;
    CHitTestInfo *  phti        = (CHitTestInfo *)pClientData;
    BOOL            fBrowseMode = !pFL->ElementContent()->IsEditable(/*fCheckContainerOnly*/FALSE);
    long            lEntry      = GetRelCacheEntry(pDispNode);
    long            lSize       = Size();
    long            ili;
    long            iliLast;
    long            yli;
    long            cp;
    CPoint          pt;

    Assert(lSize && lEntry >= 0 && lEntry < lSize);

    prdn    = (*this)[lEntry];
    cp      = prdn->GetElement()->GetFirstCp() - 1;
    ili     = prdn->_ili;
    iliLast = ili + prdn->_cLines;
    yli     = prdn->_yli;

    //
    // convert the point relative to the layout parent
    //

    pt.x = pptHit->x + prdn->_ptOffset.x;
    pt.y = pptHit->y + prdn->_ptOffset.y + prdn->_yli;

    pElementDispNode = prdn->GetElement();

    //
    // HitTest lines that are owned by the given relative node.
    //
    while(ili < iliLast)
    {
        CLineCore * pli = _pdp->Elem(ili);

         // Hit test the current line here.
        if (    !pli->_fHidden
            && (!pli->_fDummyLine || fBrowseMode) )
        {
            CLineOtherInfo *ploi = pli->oi();

            // if the point is in the vertical bounds of the line
            if ( pt.y >= yli + pli->GetYTop(ploi) &&
                 pt.y <  yli + pli->GetYLineBottom(ploi))
            {
                // check if the point lies in the horzontal bounds of the
                // line
                if (pt.x >= ploi->_xLeftMargin &&
                    pt.x < (pli->_fForceNewLine
                                    ? ploi->_xLeftMargin + pli->_xLineWidth
                                    : pli->GetTextRight(ploi, ili == _pdp->LineCount() - 1)))
                {
                    break;
                }
            }

        }

        if(pli->_fForceNewLine)
            yli += pli->_yHeight;

        cp += pli->_cch;
        ili++;
    }

    //
    // If a line is hit, find the branch hit.
    //
    if ( ili < iliLast)
    {
        HITTESTRESULTS * presultsHitTest = phti->_phtr;
        HTC              htc = HTC_YES;
        BOOL             fPseudoHit;
        CTreeNode      * pNodeHit = NULL;

        //
        // If the line hit belongs to a nested relative line then it is
        // a pseudo hit.
        //
        fPseudoHit = FALSE;

        for (++lEntry; lEntry < lSize; lEntry++)
        {
            prdn++;

            if(ili >= prdn->_ili && ili < prdn->_ili + prdn->_cLines)
            {
                fPseudoHit = TRUE;
                break;
            }
        }

        if(!fPseudoHit)
        {
            CLinePtr    rp(_pdp);
            CTreePos *  ptp = NULL;
            DWORD       dwFlags = 0;

            dwFlags |= !!(phti->_grfFlags & HT_ALLOWEOL)
                            ? CDisplay::CFP_ALLOWEOL : 0;
            dwFlags |=  !(phti->_grfFlags & HT_DONTIGNOREBEFOREAFTER)
                            ? CDisplay::CFP_IGNOREBEFOREAFTERSPACE : 0;
            dwFlags |=  !(phti->_grfFlags & HT_NOEXACTFIT)
                            ? CDisplay::CFP_EXACTFIT : 0;

            cp = _pdp->CpFromPointEx(
                            ili, yli,
                            cp, pt,
                            &rp, &ptp, NULL, dwFlags,
                            &phti->_phtr->_fRightOfCp,
                            &fPseudoHit, &presultsHitTest->_cchPreChars,
                            &presultsHitTest->_fGlyphHit,
                            &presultsHitTest->_fBulletHit, NULL);

            if (   cp < pElementDispNode->GetFirstCp() - 1
                || cp > pElementDispNode->GetLastCp() + 1
               )
            {
                return FALSE;
            }

            presultsHitTest->_iliHit = rp;
            presultsHitTest->_ichHit = rp.RpGetIch();


            if (!fBrowseMode && ptp->IsNode() && ptp->ShowTreePos()
                             && (cp + 1 == ptp->GetBranch()->Element()->GetFirstCp()))
            {
                htc        = HTC_YES;
                pNodeHit   = ptp->GetBranch();
                presultsHitTest->_fWantArrow = TRUE;
            }
            else
            {
                htc = pFL->BranchFromPointEx(pt, rp, ptp,
                                    pElementDispNode->GetFirstBranch(),
                                    &pNodeHit,
                                    fPseudoHit,
                                    &presultsHitTest->_fWantArrow,
                                    dwFlags & CDisplay::CFP_IGNOREBEFOREAFTERSPACE);
            }
        }
        else
        {
            pNodeHit                 = pElementDispNode->GetFirstBranch();
            presultsHitTest->_iliHit = ili;
            presultsHitTest->_ichHit = 0;
        }

        presultsHitTest->_cpHit  = cp;

        if (htc != HTC_YES)
        {
            presultsHitTest->_fWantArrow = TRUE;
        }
        else
        {
            // pNodeHit is the child of the Flowlayout owner of this cache.
            // if it should NOT have layout, or is the owner themself, then
            //     register this information in the HTI and return success.
            // If, on the other hand, this child should have layout then we are in
            //    one of 2 cases:
            //      1> the child is higher in the z-order and previously declined the hit.
            //         in this case, we should only touch the HTI if there is NOTHING there
            //         already, and that should only be to add ourselves to it. i.e. the
            //          child said NO, and no one else is registered for the hit.
            //      2> the child is below our content in the z-order, and so hasn't been
            //          hit test yet by the display tree. in this case, don't touch the
            //          HTI (unles it is empty) since if the child is hit, they will override anyhow
            htc = (   pNodeHit
                   && (   pNodeHit == pElementDispNode->GetFirstBranch()
                       || !pNodeHit->ShouldHaveLayout()
                  )   ) ? HTC_YES : HTC_NO;

            if (htc == HTC_YES
                && !(fPseudoHit && phti->_pDispNode)
                )
            {
                phti->_ptContent    = *pptHit;
                phti->_pDispNode    = pDispNode;
                phti->_pNodeElement = pNodeHit;
            }
            else if (phti->_pNodeElement == NULL)
            {
                Assert(pNodeHit != pElementDispNode->GetFirstBranch());

                // register ourselves as the soft hit, since no one previous has.
                phti->_pNodeElement = pElementDispNode->GetFirstBranch();
            }
        }

        phti->_htc = htc;

        // If this is not a pseudo hit then just return the current settings.
        // If this IS a pseudo hit, we are hit on nested relative lines and so, return FALSE to
        // allow the hit testing process to continue, but leave the data in the HitTestInfo so
        // that if nothing else is a hit, then this data is returned.
        return (fPseudoHit) ? FALSE : htc == HTC_YES;
    }
    else
        return FALSE;
}

BOOL
CRelDispNodeCache::HitTestFuzzy(
    const POINT *pptHitInBoxCoords,
    CDispNode *pDispNode,
    void *pClientData)
{
    // no fuzzy hit test
    return FALSE;
}

LONG
CRelDispNodeCache::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    CElement *  pElement1 = ::GetDispNodeElement(pDispNode1);
    CElement *  pElement2 = ::GetDispNodeElement(pDispNode2);

    return pElement1 != pElement2
                ? pElement1->CompareZOrder(pElement2)
                : 0;
}

LONG
CRelDispNodeCache::GetZOrderForSelf(CDispNode const* pDispNode)
{
    CElement *  pElement = ::GetDispNodeElement(pDispNode);
    if( pElement && pElement->GetFirstBranch())
        return pElement->GetFirstBranch()->GetCascadedzIndex();
    else
        return -1;
}


//+----------------------------------------------------------------------------
//
// Function:    CRelDispNodeCache::DrawClient
//
// Synopsis:    Draw the background of the given disp node
//
//-----------------------------------------------------------------------------
void
CRelDispNodeCache::DrawClientBackground(
    const RECT* prcBounds,
    const RECT* prcRedraw,
    CDispSurface *pSurface,
    CDispNode *pDispNode,
    void *pClientData,
    DWORD dwFlags)
{
    long            lEntry = GetRelCacheEntry(pDispNode);

    Assert(Size() && lEntry >= 0 && lEntry < Size());

    if (lEntry >= 0)
    {
        Assert(pClientData);

        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pSurface);
        CRelDispNode *  prdn;

        prdn = (*this)[lEntry];

        Assert(!prdn->GetElement()->ShouldHaveLayout());

        CTreePos *  ptp;
        CDisplay *  pdp = GetDisplay();
        long        cp;

        prdn = (*this)[lEntry];

        ((CRect &)(pDI->_rcClip)).IntersectRect(*prcBounds);

        prdn->GetElement()->GetTreeExtent(&ptp, NULL);

        cp = ptp->GetCp();

        // Draw background and border of the current relative
        // element or any of it's descendents.
        pdp->DrawRelElemBgAndBorder(cp, ptp, prdn, prcBounds, prcRedraw, pDI);
    }
}

//+----------------------------------------------------------------------------
//
// Function:    CRelDispNodeCache::DrawClient
//
// Synopsis:    Draw the given disp node
//
//-----------------------------------------------------------------------------
void
CRelDispNodeCache::DrawClient(
    const RECT* prcBounds,
    const RECT* prcRedraw,
    CDispSurface *pSurface,
    CDispNode *pDispNode,
    void *cookie,
    void *pClientData,
    DWORD dwFlags)
{
    CRelDispNode *  prdn;
    long            lEntry = GetRelCacheEntry(pDispNode);

    Assert(Size() && lEntry >= 0 && lEntry < Size());

    if (lEntry >= 0)
    {
        Assert(pClientData);

        // draw the lines here
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pSurface);

        prdn = (*this)[lEntry];

        Assert(!prdn->GetElement()->ShouldHaveLayout());

        //
        // Draw the lines that correspond to the given disp node
        //
        XHDC        hdc = pDI->GetDC();
        long        ili;
        CTreePos *  ptp;
        CDisplay *  pdp = GetDisplay();
        CElement *  pElementFL = pdp->GetFlowLayoutElement();
        CLineCore * pli;
        CLSRenderer lsre(pdp, pDI);
        long        cp;

        CLayoutContext *pLayoutContext  = pdp->GetFlowLayout()->LayoutContext();
        BOOL            fViewChain      = pLayoutContext && pLayoutContext->ViewChain();

        if (!lsre.GetLS())
            return;

        prdn = (*this)[lEntry];

        ((CRect &)(pDI->_rcClip)).IntersectRect(*prcBounds);

        lsre.StartRender(*prcBounds, pDI->_rcClip, -1, -1);

        prdn->GetElement()->GetTreeExtent(&ptp, NULL);

        cp = ptp->GetCp();

        if (fViewChain)
        {
            //
            //  In print view probably correction should be made (cp and lsre)
            //

            Assert(pLayoutContext);

            CLayoutBreak *  pLayoutBreak;
            long            cpStart;
            pLayoutContext->GetLayoutBreak(pElementFL, &pLayoutBreak);

            if (pLayoutBreak)
            {
                cpStart = DYNCAST(CFlowLayoutBreak, pLayoutBreak)->GetMarkupPointer()->GetCp();

                //  This means that relatively positioned element (span) is broken and we need to
                //  advance cp and lsre to the beginning of the element on the curent line.
                if (cp < cpStart)
                {
                    cp = cpStart;
                }
            }
        }

        if ( !prdn->_pDispNode->IsContainer())
        {
            // If the current relative element is not a container,
            // draw its background and border (or those of its
            // descendents).  Containers have their background
            // drawn via DrawClientBackground().
            pdp->DrawRelElemBgAndBorder(cp, ptp, prdn, prcBounds, prcRedraw, pDI);
        }

        lsre.SetCurPoint(CPoint(0, prcBounds->top - prdn->_ptOffset.y));

        if (fViewChain)
        {
            //  In print view ptp probably should be updated
            lsre.SetCp(cp, NULL);
            ptp = lsre.GetPtp();
        }
        else
        {
            lsre.SetCp(cp, ptp);
        }

        for (ili = prdn->_ili; ili < prdn->_ili + prdn->_cLines; ili++)
        {
            //
            // Find the current relative node that owns the current line
            //
            CTreeNode * pNodeRelative =
                            ptp->GetBranch()->GetCurrentRelativeNode(pElementFL);

            pli = pdp->Elem(ili);

            //
            // Skip the current line if the owner is not the same element
            // that owns the current display node.
            //
            if( pNodeRelative && pNodeRelative->Element() != prdn->GetElement())
            {
                lsre.SkipCurLine(pli);
            }
            else
            {
                CLineFull lif = *pli;
                lsre.RenderLine(lif, prcBounds->left - prdn->_ptOffset.x);
            }

            Assert(pli == pdp->Elem(ili));

            ptp = lsre.GetPtp();
            // It's possible for the renderer to return a pointer treepos; this is no good
            // to us, since we need the next content related node.  Keep walking till we
            // find one. (Bug #72264).
            while ( ptp->Type() == CTreePos::EType::Pointer )
            {
                ptp = ptp->NextTreePos();
            }
        }

        //
        // restore the original text align, the renderer might have modified the
        // text align. This caused some pretty bad rendering problems(specially with
        // radio buttons).
        //
        if (lsre._lastTextOutBy != CLSRenderer::DB_LINESERV)
        {
            lsre._lastTextOutBy = CLSRenderer::DB_NONE;
            SetTextAlign(hdc, TA_TOP | TA_LEFT);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::DrawRelElemBgAndBorder
//
// Synopsis:    CDisplay::DrawRelElemBgAndBorder draws the backround or borders
//              on itself and any child elements that are not relative.
//
//-----------------------------------------------------------------------------
void
CDisplay::DrawRelElemBgAndBorder(
    long            cp,
    CTreePos      * ptp,
    CRelDispNode  * prdn,
    const RECT    * prcView,
    const RECT    * prcClip,
    CFormDrawInfo * pDI)
{
    CDataAry <RECT> aryRects(Mt(CDisplayDrawRelElemBgAndBorder_aryRects_pv));
    CLineCore   *   pli;
    CFlowLayout *   pFlowLayout     = GetFlowLayout();
    CMarkup     *   pMarkup         = pFlowLayout->GetContentMarkup();
    BOOL            fPaintBackground= pMarkup->PaintBackground();
    long            iliStop = min(LineCount(), prdn->_ili + prdn->_cLines);
    long            yli     = - prdn->_ptOffset.y;
    long            cpLine;
    long            cpNextLine;
    long            cpPtp;
    long            ili, ich;
    CPoint          ptOffset = prdn->_ptOffset;

    // If the disp node has a content origin, incorporate that into the offset
    if (prdn->_pDispNode->HasContentOrigin())
        ptOffset += prdn->_pDispNode->GetContentOrigin();

    ptOffset.x = -ptOffset.x;
    ptOffset.y = -ptOffset.y - prdn->_yli;

    cpPtp = cpLine = cpNextLine = cp;
    for (ili = prdn->_ili; ili < iliStop && yli < prcClip->bottom; ili++)
    {
        pli = Elem(ili);

        cpNextLine += pli->_cch;

        if (pli->_fForceNewLine)
            yli += pli->_yHeight;

        if (pli->_cch)
        {
            if (    (fPaintBackground && pli->_fHasBackground)
                ||  pli->_fHasParaBorder)
            {
                if(cpPtp < cpLine)
                {
                    ptp = pMarkup->TreePosAtCp(cpLine, &ich);

                    cpPtp = cpLine;
                    if(ich)
                    {
                        cpPtp += ptp->Cch() - ich; // (olego) fix for 26845
                        ptp = ptp->NextTreePos();
                        Assert(cpPtp == ptp->GetCp());
                    }
                }

                while(cpNextLine > cpPtp)
                {
                    if(ptp->IsBeginElementScope())
                    {
                        CTreeNode * pNode = ptp->GetBranch();
                        CElement  * pElement = pNode->Element();
                        const CCharFormat * pCF = pNode->GetCharFormat();
                        const CFancyFormat* pFF = pNode->GetFancyFormat();

                        if(     pCF->IsVisibilityHidden() || pCF->IsDisplayNone()
                            ||  (cp != cpPtp && (pFF->_fRelative || pNode->ShouldHaveLayout())))
                        {
                            pElement->GetTreeExtent(NULL, &ptp);
                            ptp = ptp->NextTreePos();
                            cpPtp = ptp->GetCp();
                            continue;
                        }
                        else
                        {
                            BOOL fDrawBackground = fPaintBackground &&
                                                     pFF->_fBlockNess &&
                                                    (pFF->_lImgCtxCookie ||
                                                     pFF->_ccvBackColor.IsDefined());
                            BOOL fDrawBorder     = pCF->_fPadBord &&
                                                   pFF->_fBlockNess;

                            // Draw the background if the element comming into scope
                            // has background or border.
                            if ( fDrawBackground || fDrawBorder)
                            {
                                DrawElemBgAndBorder(
                                    pElement, &aryRects,
                                    prcView, prcClip,
                                    pDI, &ptOffset,
                                    fDrawBackground, fDrawBorder, -1, -1, !pCF->_cuvLineHeight.IsNull(), TRUE);
                            }
                        }

                    }
                    cpPtp += ptp->GetCch();
                    ptp    = ptp->NextTreePos();
                }
            }
        }

        cpLine = cpNextLine;
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::ClearStoredRFEs
//
// Synopsis:    Clears CDisplay's cache of precalculated RFE results for 
//              block elements. Used in drawing their backgrounds and borders.
//
//-----------------------------------------------------------------------------

//This struct will hold result of RFE - aryRect and rcBound
class CStoredRFE
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(MtStoredRFE))

    RECT _rcBound;

    DECLARE_CDataAry(CRectAry, RECT, Mt(Mem), Mt(MtStoredRFE_aryRect_pv))
    CRectAry _aryRects;
};

//Clears cache of stored RFEs - called when we reclac or die.
void 
CDisplay::ClearStoredRFEs()
{
    UINT index;
    
    CStoredRFE *pRFE = (CStoredRFE *) _htStoredRFEs.GetFirstEntry(&index);

    while(pRFE)
    {
        delete pRFE;
        pRFE = (CStoredRFE *) _htStoredRFEs.GetNextEntry(&index);
    }

    _htStoredRFEs.ReInit();
}



//+----------------------------------------------------------------------------
//
// Member:      CDisplay::DrawElemBgAndBorder
//
// Synopsis:    Draw the border and background on an element if any. cpStart
//              and cpFinish define the clip region. iRunStart and iRunFinish
//              are for performance reasons so that we dont have run around in
//              the tree for the element.
//
//-----------------------------------------------------------------------------

void
CDisplay::DrawElemBgAndBorder(
                     CElement        *  pElement,
                     CDataAry <RECT> *  paryRects,
                     const RECT      *  prcView,
                     const RECT      *  prcClip,
                     CFormDrawInfo   *  pDI,
                     const CPoint    *  pptOffset,
                     BOOL               fDrawBackground,
                     BOOL               fDrawBorder,
                     LONG               cpStart,
                     LONG               cpFinish,
                     BOOL               fClipToCPs,
                     BOOL               fNonRelative,
                     BOOL               fPseudo)
{
    Assert (pElement && pDI && prcView && prcClip && paryRects);
    Assert (!pElement->ShouldHaveLayout());

    // If a clip range has been specified (e.g. either cpStart or cpFinish
    // is not -1), then we want a bounding rect.
    RECT        rcBound;
    RECT *      prcBound = ((pElement->IsBlockElement() || cpStart != -1 || cpFinish != -1)
                                    ? &rcBound
                                    : NULL);

    Assert ( fDrawBorder || fDrawBackground );

    CPoint  ptOffset(((CRect *)prcView)->TopLeft());

    // TODO RTL 112514: this won't work with relative positioning
    if (IsRTLDisplay())
        ptOffset.x = 0;

    if (pptOffset)
    {
        ptOffset += (SIZE &)*pptOffset;
    }

    DWORD dwRFEFlags = RFE_BACKGROUND;

    if ( fNonRelative )
        dwRFEFlags |= RFE_IGNORE_RELATIVE;

#if 0
    // If we're not drawing borders, we don't need to compute the
    // region for the whole element, only for what's visible.
    // fDrawBorder is sometimes true even when we don't have a border,
    // because some callers pass in the PF's _fPadBord, which is true
    // if either padding or borders exist -- hence we also look at
    // _fDefinitelyNoBorders.
    // (clipping to visible in the border drawing case would cause
    // them to appear around the visible part of the element,
    // instead of the entire element).

    // Sujalp and KTam: Temp fix for bug 82208 -- need better fix
    if ( !fDrawBorder || pElement->_fDefinitelyNoBorders )
        dwRFEFlags |= RFE_CLIP_TO_VISIBLE;
#endif

    if (!fDrawBorder || pElement->_fDefinitelyNoBorders)
        dwRFEFlags |= RFE_ONLY_BACKGROUND;

    //Call RFE for the element to calc where to draw background/border
    //Use cache to avoid unneccessary calls to RFE.
    {
        CStoredRFE *pStoredRFE = (CStoredRFE *) _htStoredRFEs.Lookup(pElement);

        if (pStoredRFE && !fClipToCPs)  
        {
            // We have cached result of RFE - use it
            paryRects->Copy(pStoredRFE->_aryRects, FALSE);
            *prcBound = pStoredRFE->_rcBound;
        }
        else
        {
            //(dmitryt) changed to -1 because since we don't pass RFE_CLIP_TO_VISIBLE flag,
            // RFE will go through entire range of pElement anyway, it only will not append
            // the rects lying outside of the cp range to the output aryRect.
            // Ideally this "optimization" in RFE should be fixed away since it doesn't 
            // really save much. Also it breaks our caching here because we can cache 
            // incomplete region. So for now (IE6 RC) I remove cpStart/cpFinish from here.

            // (gschneid) In case of pseudo we have to take care about cpStart and cpEnd because
            // we only want to render the first-line or first-element.

            // (grzegorz) fClipToCPs is set to true in case of:
            // * pseudo elements (see comment above)
            // * explicit line height, in this case we may have overlapping lines
            //   and this may cause drawing background for a line which is visible,
            //   but hasn't been drawn because the previous line goes beyond clipping
            //   rect
            if (fClipToCPs)
            {
                RegionFromElement(pElement, paryRects, &ptOffset, pDI,
                    dwRFEFlags, cpStart, cpFinish, prcBound);
            }
            else
            {
                RegionFromElement(pElement, paryRects, &ptOffset, pDI,
                    dwRFEFlags, -1, -1, prcBound);
            }
            
            if (!fClipToCPs)
            {
                //Cache result of RFE for later use (painting, 
                // scrolling and banding benefit from it)
                pStoredRFE = new CStoredRFE();
                pStoredRFE->_aryRects.Copy(*paryRects, FALSE);
                pStoredRFE->_rcBound = *prcBound;
                _htStoredRFEs.Insert(pElement, pStoredRFE);
            }
        }
    }

    if(paryRects->Size())
    {

        // now that we have its region render its background or border
        if(fDrawBackground)    // if we have background color
        {
            // draw element background

            DrawElementBackground(pElement->GetFirstBranch(), paryRects, prcBound,
                                    prcView, prcClip,
                                    pDI, fPseudo);
                                    
        }

        if (fDrawBorder)
        {

            // Draw a border if necessary
            DrawElementBorder(pElement->GetFirstBranch(), paryRects, prcBound,
                                prcView, prcClip,
                                pDI);
                                
        }
    }
}

CDispNode *
CRelDispNodeCache::FindElementDispNode(CElement * pElement)
{
    int lSize = _aryRelDispNodes.Size();

    if (lSize)
    {
        CRelDispNode * prdn = _aryRelDispNodes;
        for (; lSize ; lSize--, prdn++)
        {
            if(prdn->GetElement() == pElement)
            {
                return prdn->_pDispNode;
            }
        }
    }
    return NULL;
}

void
CRelDispNodeCache::Delete(long iPosFrom, long iPosTo)
{
    // we need to clearContents on each item
    if (iPosTo >= iPosFrom)
    {
        int            i = iPosFrom;
        CRelDispNode * prdn = (*this)[i];

        for (; i<=iPosTo; i++, prdn++)
        {
            prdn->SetElement( NULL );
        }
    }

    _aryRelDispNodes.DeleteMultiple(iPosFrom, iPosTo);
}

void
CRelDispNodeCache::SetElementDispNode(
    CElement *  pElement,
    CDispNode * pDispNode)
{
    Assert(pElement);
    Assert(pDispNode);

    int lSize = _aryRelDispNodes.Size();

    if (lSize)
    {
        CRelDispNode * prdn = _aryRelDispNodes;
        for (; lSize ; lSize--, prdn++)
        {
            if(prdn->GetElement() == pElement)
            {
                prdn->_pDispNode = pDispNode;
            }
        }
    }
}

void
CRelDispNodeCache::EnsureDispNodeVisibility(
    CElement * pElement)
{
    CLayout *       pLayout = _pdp->GetFlowLayout();
    CRelDispNode *  prdn    = _aryRelDispNodes;
    long            cSize   = _aryRelDispNodes.Size();

    for (; cSize; prdn++, cSize--)
    {
        if (    !pElement
            ||  prdn->GetElement() == pElement)
        {
            pLayout->EnsureDispNodeVisibility(prdn->GetElement(), prdn->_pDispNode);
        }
    }
}

void
CRelDispNodeCache::HandleDisplayChange()
{
    CRelDispNode *  prdn    = _aryRelDispNodes;
    long            cSize   = _aryRelDispNodes.Size();
    BOOL            fDisplayNone = _pdp->GetFlowLayoutElement()->IsDisplayNone();

    for (; cSize; prdn++, cSize--)
    {
        if (fDisplayNone || prdn->GetElement()->IsDisplayNone())
        {
            _pdp->GetFlowLayout()->GetView()->ExtractDispNode(prdn->_pDispNode);
        }
        else
        {
            CPoint ptAuto(prdn->_ptOffset.x, prdn->_ptOffset.y + prdn->_yli);

            prdn->GetElement()->ZChangeElement(NULL, &ptAuto);
        }
    }
}

void
CRelDispNodeCache::DestroyDispNodes()
{
    long lSize = _aryRelDispNodes.Size();

    if (lSize)
    {
        CRelDispNode *  prdn;
        for (prdn = (*this)[0]; lSize; lSize--, prdn++)
        {
            prdn->ClearContents();
        }
    }
}

void
CRelDispNodeCache::Invalidate(
    CElement *pElement,         // Relative element to invalidate
    const RECT * prc /*=NULL*/, // array of rects describing region to inval
    int nRects /*=1*/ )         // count of rects in array
{
    // The element must itself actually be relative; it is insufficient for
    // it to have "inherited" relativeness (see element.hxx discussion of
    // IsRelative vs. IsInheritingRelativeness), since the RDNC tracks only
    // only relative elements and not their children.
    // We could use GetCurrentRelativeNode() instead of relying on the caller
    // to do that, but it would require an additional param (pElementFL)
    // that might obfuscate.
    Assert( pElement->IsRelative() );

    CDispNode *pDispNode = FindElementDispNode( pElement );

    // If callers pass a relative element that we aren't responsible for, then
    // bail!  This shouldn't happen.
    if ( !pDispNode )
    {
        // NOTE: this assert is valid.  See CFlowLayout::Notify() comments
        // on handling of invalidation.
        //Assert( FALSE && "Caller passed a relative element that doesn't belong to this RDNC!" );
        return;
    }

    if ( _pdp->GetFlowLayout()->Doc()->_state >= OS_INPLACE )
    {
        if ( _pdp->GetFlowLayout()->OpenView())
        {
            // Incoming rects are in the coordinate system of the
            // flow layout.  We need to convert them into the system
            // of the dispnode, so we need the flow offset of the
            // dispnode..
            CPoint pt;
            _pdp->GetRelNodeFlowOffset( pDispNode, &pt );

            // Conversion involves subtracting flow offset of dispnode
            // from each rect:
            pt.x = -pt.x;
            pt.y = -pt.y;

            Assert( prc );
            for (int i=0; i < nRects; i++, prc++)
            {
                ::OffsetRect( (RECT *)prc, pt.x, pt.y );
                pDispNode->Invalidate((CRect &)*prc, COORDSYS_FLOWCONTENT);
            }
        }
    }
}


void
CDisplay::GetRelNodeFlowOffset(CDispNode * pDispNode, CPoint *ppt)
{
    CRelDispNode      * prdn;
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    long                lEntry = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();

    Assert(prdnc);
    Assert(prdnc == pDispNode->GetDispClient());
    Assert(lEntry >= 0 && lEntry < prdnc->Size());


    prdn = (*prdnc)[lEntry];

    Assert(prdn->_pDispNode == pDispNode);

    ppt->x = prdn->_ptOffset.x;
    ppt->y = prdn->_ptOffset.y + prdn->_yli;
}

void
CDisplay::GetRelElementFlowOffset(CElement * pElement, CPoint *ppt)
{
    CRelDispNode      * prdn;
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    long                lEntry, lSize;

    *ppt = g_Zero.pt;

    if(prdnc)
    {
        lSize = prdnc->Size();
        prdn  = (*prdnc)[0];

        for(lEntry = 0; lEntry < lSize; lEntry++, prdn++)
        {
            if (prdn->GetElement() == pElement)
            {
                ppt->x = prdn->_ptOffset.x;
                ppt->y = prdn->_ptOffset.y + prdn->_yli;
            }
        }
    }
}


void
CDisplay::TranslateRelDispNodes(const CSize & size, long lStart)
{
    CDispNode         * pDispNode;
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    CRelDispNode      * prdn;
    long                lSize = prdnc->Size();
    long                lEntry;
    long                iLastLine = -1;

    Assert(lSize && lStart < lSize);

    prdn = (*prdnc)[lStart];

    for(lEntry = lStart; lEntry < lSize; lEntry++, prdn++)
    {
        if (iLastLine <= prdn->_ili)
        {
            pDispNode = prdn->_pDispNode;
            pDispNode->SetPosition(pDispNode->GetPosition() + size);
            iLastLine = prdn->_ili + prdn->_cLines;
        }
    }
}


void
CDisplay::ZChangeRelDispNodes()
{
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    CRelDispNode      * prdn;
    long                cEntries = prdnc->Size();
    long                iEntry   = 0;
    long                iLastLine = -1;

    Assert( cEntries
        &&  iEntry < cEntries);

    prdn = (*prdnc)[iEntry];

    for(; iEntry < cEntries; iEntry++, prdn++)
    {
        if (iLastLine < prdn->_ili)
        {
            prdn->GetElement()->ZChangeElement();
            iLastLine = prdn->_ili + prdn->_cLines;
        }
    }
}

//
// Calculate content origin for relative disp node
// This is slightly different from SizeRTLDispNode because the relative disp nodes
// have random sizes and offsets, so their content origins can't be calculated from
// CDisplay data.
//
void
CDisplay::SetRelDispNodeContentOrigin(CDispNode *pDispNode)
{
    if(pDispNode && pDispNode->HasContentOrigin())
    {
        // This is an RTL case. If not, we need to check for something else, as this is RTL-specific
        Assert(IsRTLDisplay());

        // We only care about containers, because other nodes get positioned relatively to them.
        int cxOrigin = GetRTLOverflow();

        // When this is called, the relative position has not been set yet.
        // Any offset from left that the node has, is due to its calculated bounds.
        // We need to adjust content origin so that any nested content gets positioned correctly.
        cxOrigin -= pDispNode->GetPosition().x;

        // TODO RTL 112514: figure out where to get offset from right (and do we need to?)
        pDispNode->SetContentOrigin(CSize(cxOrigin, 0), -1);
    }
    else
    {
        // If we have a disp node, it must have content origin allocated.
        // If it doesn't, it means that GetDispNodeInfo() is buggy
        AssertSz(!pDispNode, "No content origin on an RTL flow node ???");
    }

}

BOOL CDisplay::IsLogicalFirstFrag(const LONG ili)
{
    BOOL fFirstLogicalFrag;
    CLineCore *pli = Elem(ili);

    fFirstLogicalFrag = pli->_fFirstFragInLine;

    if (pli->_fRelative && !pli->_fFirstFragInLine && !pli->IsFrame() && !pli->IsClear() && !pli->_fDummyLine)
    {
        Assert(pli->_fPartOfRelChunk);

        CLineCore *pliCore;
        for(LONG i = ili - 1; i >= 0; i--)
        {
            pliCore = Elem(i);
            Assert(pliCore->_fPartOfRelChunk);

            // There exists a line before which has width and hence
            // this line (ili) is truly not the first frag
            if (pliCore->_xWidth != 0)
                break;

            // If we reached the first frag without running into a frag
            // which has width, then this line is the logical first line
            if (pliCore->_fFirstFragInLine)
            {
                fFirstLogicalFrag = TRUE;
                break;
            }

            AssertSz(i != 0, "We should never since we should find a firstfragline.");
        }
    }

    return fFirstLogicalFrag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\seldrag.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif


extern const int CFETC;                   // global in dataxfrobj

extern FORMATETC g_rgFETC[];

MtDefine(CDropTargetInfo, Utilities, "CDropTargetInfo ")
MtDefine(CSelDragDropSrcInfo, Utilities, "CSelDragDropSrcInfo")

//
// Constants for comparison of results of IMarkupPointer::Compare method.
//
const int LEFT = 1;   
const int RIGHT = -1 ;
const int SAME = 0;

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

HRESULT
OldCompare(IDisplayPointer* pDisp1, IDisplayPointer* pDisp2, int * pi )
{
    HRESULT hr;
    BOOL    fResult;

    Assert(pi);

    IFC( pDisp1->IsEqualTo(pDisp2, &fResult) );
    if (fResult)
    {
        *pi = 0;
        goto Cleanup;
    }
    
    IFC( pDisp1->IsLeftOf(pDisp2, &fResult)  );

    *pi = fResult ? -1 : 1;

Cleanup:
    RRETURN(hr);
}


CDropTargetInfo::CDropTargetInfo(CLayout * pLayout, CDoc* pDoc , POINT pt)
{
    _pDoc = pDoc;

    //  Bug 93494, 101542: If we are dragging within our own instance, we want to check if
    //  we are in the same spot as the initial hit.

    if (pDoc->_pDragDropSrcInfo)
    {
        _ptInitial = pt;
    }
    else
    {
        _ptInitial.x = -1;
        _ptInitial.y = -1;
    }

    Init(  );

    UpdateDragFeedback( pLayout, pt, NULL, TRUE );
}

CDropTargetInfo::~CDropTargetInfo()
{
    ReleaseInterface( _pCaret );
    ReleaseInterface( _pDispPointer );
    ReleaseInterface( _pDispTestPointer );
}

void 
CDropTargetInfo::Init()
{ 
    HRESULT hr;

    IFC( _pDoc->CreateDisplayPointer( & _pDispPointer ));
    IFC( _pDoc->CreateDisplayPointer( & _pDispTestPointer ));
    IFC( _pDoc->GetCaret( & _pCaret ));

Cleanup:
    _fFurtherInStory = FALSE;
    _fPointerPositioned = FALSE;
}
    
void 
CDropTargetInfo::UpdateDragFeedback(CLayout*                pLayout, 
                                    POINT                   pt,
                                    CSelDragDropSrcInfo *   pInfo,
                                    BOOL                    fPositionLastToTest )
{
    HRESULT hr = S_OK;
    BOOL fInside = FALSE;
    BOOL fSamePointer = FALSE;
    int iWherePointer = SAME;
    CPoint ptContent(pt);
    IHTMLElement *pElement = NULL;

    Assert(pLayout && pLayout->ElementContent());
    
    pLayout->TransformPoint( &ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT, NULL );

    hr = THR( pLayout->ElementContent()->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElement) );
    if (hr)
        goto Cleanup;

    g_uiDisplay.DocPixelsFromDevice(&ptContent);    
    hr = THR( _pDispTestPointer->MoveToPoint(ptContent, COORD_SYSTEM_CONTENT, pElement, 0, NULL) );

    if ( hr )
        goto Cleanup;

    if ( _fPointerPositioned )
    {
        hr = THR( OldCompare( _pDispPointer, _pDispTestPointer, & iWherePointer ));
        if ( hr )
            goto Cleanup;
        _fFurtherInStory = ( iWherePointer == RIGHT );            
    }
    
    if ( fPositionLastToTest )
    {
        hr = THR( _pDispPointer->MoveToPointer( _pDispTestPointer ));        
        if ( hr )
           goto Cleanup;
        _fPointerPositioned = TRUE;           
    }
    
    if ( pInfo )
    {
        CMarkupPointer mp(_pDoc);

        hr = THR( _pDispTestPointer->PositionMarkupPointer(&mp) );
        if (hr)
            goto Cleanup;
            
        fInside = pInfo->IsInsideSelection(&mp);
    }
        
    if ( fInside )
    {
        if (!_pDoc->_fSlowClick)
        {
            // Hide caret
            DrawDragFeedback(FALSE);
        }

        _pDoc->_fSlowClick = TRUE;
    }
    else
    {
        // If feedback is currently displayed and the feedback location
        // is changing, then erase the current feedback.

        if ( ! fPositionLastToTest )
        {
            hr = THR ( _pDispPointer->IsEqualTo( _pDispTestPointer, & fSamePointer ));
            if ( hr )
                goto Cleanup;
        }
        else 
            fSamePointer = TRUE;

        if ( ! fSamePointer  )
        {
            //  Hide caret
            DrawDragFeedback(FALSE);
            hr = THR ( _pDispPointer->MoveToPointer( _pDispTestPointer ));
            if ( hr )
                goto Cleanup;
            _fPointerPositioned = TRUE;                
        }

        // Draw new feedback.
        if (_pDoc->_fSlowClick || ! _pDoc->_fDragFeedbackVis)
        {
            //  Show caret
            DrawDragFeedback(TRUE);
        }

        _pDoc->_fSlowClick = FALSE;
    }
Cleanup:
    ReleaseInterface(pElement);
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     DrawDragFeedback
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CDropTargetInfo::DrawDragFeedback(BOOL fCaretVisible)
{
    if (fCaretVisible)
    {
        _pCaret->MoveCaretToPointerEx( _pDispPointer, TRUE, FALSE, CARET_DIRECTION_INDETERMINATE );
        _pDoc->_fDragFeedbackVis = 1;
    }
    else
    {
        _pCaret->Hide();
        _pDoc->_fDragFeedbackVis = 0;
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     PasteDataObject
//
//  Synopsis: Paste a Data Object at a MarkupPointer
//
//----------------------------------------------------------------------------


HRESULT
CDropTargetInfo::PasteDataObject( 
                    IDataObject * pdo,
                    IMarkupPointer* pInsertionPoint,
                    IMarkupPointer* pStart,
                    IMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* pHTMLEditor = _pDoc->GetHTMLEditor();
    IHTMLEditingServices * pEditingServices = NULL;

    Assert( pHTMLEditor );
    if ( ! pHTMLEditor )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = THR( pHTMLEditor->QueryInterface( IID_IHTMLEditingServices, ( void** ) & pEditingServices ));
    if ( hr )
        goto Cleanup;

    //
    // We'll use Markup Services "magic" to move the pointers around where we insert
    //

    hr = THR( pStart->MoveToPointer( pInsertionPoint ));
    if ( hr )
        goto Cleanup;
    hr = THR( pStart->SetGravity ( POINTER_GRAVITY_Left ));
    if ( hr )   
        goto Cleanup;
    hr = THR( pEnd->MoveToPointer( pInsertionPoint ));
    if ( hr )
        goto Cleanup;
    hr = THR( pEnd->SetGravity ( POINTER_GRAVITY_Right ));
    if ( hr )   
        goto Cleanup;    

    hr = THR( pEditingServices->PasteFromClipboard( pInsertionPoint, NULL, pdo ));
    if ( hr )
       goto Cleanup;

Cleanup:

    ReleaseInterface( pEditingServices );
    RRETURN ( hr );    
}
            
//+====================================================================================
//
// Method: EquivalentElements
//
// Synopsis: Test elements for 'equivalency' - ie if they are the same element type,
//           and have the same class, id , and style.
//
//------------------------------------------------------------------------------------

BOOL 
CDropTargetInfo::EquivalentElements( IHTMLElement* pIElement1, IHTMLElement* pIElement2 )
{
    CElement* pElement1 = NULL;
    CElement* pElement2 = NULL;
    BOOL fEquivalent = FALSE;
    HRESULT hr = S_OK;
    IHTMLStyle * pIStyle1 = NULL;
    IHTMLStyle * pIStyle2 = NULL;
    BSTR id1 = NULL;
    BSTR id2 = NULL;
    BSTR class1 = NULL;
    BSTR class2 = NULL;
    BSTR style1 = NULL;
    BSTR style2 = NULL;
    
    hr = THR( pIElement1->QueryInterface( CLSID_CElement, (void**) & pElement1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->QueryInterface( CLSID_CElement, (void**) & pElement2 ));
    if ( hr )
        goto Cleanup;

    //
    // Compare Tag Id's
    //
    if ( pElement1->_etag != pElement2->_etag )
        goto Cleanup;

    //
    // Compare Id's
    //
    hr = THR( pIElement1->get_id( & id1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->get_id( & id2 ));
    if ( hr )   
        goto Cleanup;  
    if ((( id1 != NULL ) || ( id2 != NULL )) && 
        ( StrCmpIW( id1, id2) != 0))
        goto Cleanup;

    //
    // Compare Class
    //
    hr = THR( pIElement1->get_className( & class1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->get_className( & class2 ));
    if ( hr )   
        goto Cleanup;   
        
    if ((( class1 != NULL ) || ( class2 != NULL )) &&
        ( StrCmpIW( class1, class2) != 0 ) )
        goto Cleanup;

    //
    // Compare Style's
    //        
    hr = THR( pIElement1->get_style( & pIStyle1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->get_style( & pIStyle2 ));
    if ( hr )   
        goto Cleanup;                
    hr = THR( pIStyle1->toString( & style1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIStyle2->toString( & style2 ));
    if ( hr )
        goto Cleanup;        
    if ((( style1 != NULL ) || ( style2 != NULL )) &&
        ( StrCmpIW( style1, style2) != 0 ))
        goto Cleanup;

    fEquivalent = TRUE;        
Cleanup:
    SysFreeString( id1 );
    SysFreeString( id2 );
    SysFreeString( class1 );
    SysFreeString( class2 );
    SysFreeString( style1 );
    SysFreeString( style2 );
    ReleaseInterface( pIStyle1 );
    ReleaseInterface( pIStyle2 );
    
    AssertSz(!FAILED(hr), "Unexpected failure in Equivalent Elements");

    return ( fEquivalent );
}


//+---------------------------------------------------------------------------
//
//  Member:     Drop
//
//  Synopsis: Do everything you need to do as a result of a drop operation
//
//----------------------------------------------------------------------------

HRESULT 
CDropTargetInfo::Drop (  
                    CLayout* pLayout, 
                    IDataObject *   pDataObj,
                    DWORD           grfKeyState,
                    POINT          ptScreen,
                    DWORD *         pdwEffect)
{

    HRESULT hr = S_OK;


    IMarkupPointer* pStart = NULL;
    IMarkupPointer* pEnd = NULL;
    IHTMLEditingServices * pEdServices = NULL;
    IMarkupPointer* pBoundaryStart = NULL;
    IMarkupPointer* pBoundaryEnd = NULL;
    IMarkupPointer2* pBoundaryStart2 = NULL;
    IMarkupPointer2* pBoundaryEnd2 = NULL;
    CElement* pDropElement = NULL;
    CSelDragDropSrcInfo* pSelDragSrc = NULL;    
    HRESULT hrDrop = S_OK;
    CMarkupPointer mpPointer(_pDoc);
    BOOL fAtBOL;
    IHTMLElement* pIElementDrop = NULL;
    DOCHOSTUIINFO           info;
    BOOL                    fIgnoreHR = FALSE;

    IFC( _pDispTestPointer->PositionMarkupPointer(&mpPointer) );
        
    pSelDragSrc = _pDoc->GetSelectionDragDropSource();
    if ( pSelDragSrc )
    {
        hrDrop = THR( pSelDragSrc->IsValidDrop(&mpPointer, (grfKeyState & MK_CONTROL)) );
    }
    
    if ( hrDrop == S_OK && 
        (  *pdwEffect == DROPEFFECT_COPY 
        || *pdwEffect == DROPEFFECT_MOVE 
        || *pdwEffect == DROPEFFECT_NONE ))
    {
        IFC( _pDoc->GetEditingServices(& pEdServices ));
        IFC( _pDoc->CreateMarkupPointer( & pBoundaryStart));            
        IFC( _pDoc->CreateMarkupPointer( & pBoundaryEnd));

        pDropElement = pLayout->ElementOwner();
        Assert( pDropElement);
        if ( ! pDropElement )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        IFC( pDropElement->QueryInterface( IID_IHTMLElement, (void**) & pIElementDrop ));

        if( pDropElement->HasSlavePtr())
        {
            IFC( pEdServices->PositionPointersInMaster( pIElementDrop , pBoundaryStart, pBoundaryEnd ));
        }
        else
        {
            IFC( pBoundaryStart->QueryInterface( IID_IMarkupPointer2, (void**) & pBoundaryStart2 ));
            IFC( pBoundaryEnd->QueryInterface( IID_IMarkupPointer2, (void**) & pBoundaryEnd2 ));
       
            IFC( pBoundaryStart2->MoveToContent( pIElementDrop, TRUE ));
            IFC( pBoundaryEnd2->MoveToContent( pIElementDrop, FALSE ));
        }
        
        IFC( _pDispPointer->IsAtBOL(&fAtBOL) );
        IFC( pEdServices->AdjustPointerForInsert( _pDispPointer, fAtBOL /* fFurtherInDoc */, pBoundaryStart, pBoundaryEnd ) );
        IFC( _pDispPointer->PositionMarkupPointer(&mpPointer) );
        
        pSelDragSrc = _pDoc->GetSelectionDragDropSource();
        if ( pSelDragSrc )
        {
            //
            // Test if the point after we do the adjust is ok.
            //
            hrDrop = THR( pSelDragSrc->IsValidDrop( &mpPointer, (grfKeyState & MK_CONTROL) ));
        }           

        if ( hrDrop == S_OK )
        {
            if ( *pdwEffect == DROPEFFECT_COPY || *pdwEffect == DROPEFFECT_MOVE )
            {
                IFC( _pDoc->CreateMarkupPointer( & pStart ));
                IFC( _pDoc->CreateMarkupPointer( & pEnd ));
                            
                hr = THR( PasteDataObject( pDataObj, &mpPointer, pStart, pEnd )) ;
                if ( hr )
                {
                    AssertSz(0, "Paste Failed !");
                    goto Cleanup;            
                }
                   
                

                if ( _pDoc->_pHostUIHandler)
                {
                    memset(reinterpret_cast<VOID **>(&info), 0, sizeof(DOCHOSTUIINFO));
                    info.cbSize = sizeof(DOCHOSTUIINFO);
                    
                    if ( SUCCEEDED( _pDoc->_pHostUIHandler->GetHostInfo(&info) )
                         && (info.dwFlags & DOCHOSTUIFLAG_DISABLE_EDIT_NS_FIXUP) )
                    {
                        fIgnoreHR = TRUE;
                    }

                }

                hr = THR( SelectAfterDrop( pDataObj, pStart, pEnd ) );
                if ( FAILED(hr) )
                {
                    if ( fIgnoreHR )
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        goto Cleanup;
                    }
                }
            }
            else
            {
                *pdwEffect = DROPEFFECT_NONE;
                //
                // For None we put the caret here 
                //
                hr = THR( _pDoc->Select(&mpPointer, &mpPointer, SELECTION_TYPE_Caret ));
                _pDoc->_fDragFeedbackVis = FALSE;

            }
        }
        else
        {
            if ( hrDrop == S_FALSE &&  pSelDragSrc &&       
                (  *pdwEffect == DROPEFFECT_COPY 
                || *pdwEffect == DROPEFFECT_MOVE ))
            {
                hr = S_FALSE;
            }
        
            //
            // NOTE - what should we do ?
            //
            *pdwEffect = DROPEFFECT_NONE ;
        }
    }
    else
    {    
        if ( hrDrop == S_FALSE &&  pSelDragSrc &&       
            (  *pdwEffect == DROPEFFECT_COPY 
            || *pdwEffect == DROPEFFECT_MOVE ))
        {
            hr = S_FALSE;
        }
    
        //
        // NOTE - what should we do ?
        //
        *pdwEffect = DROPEFFECT_NONE ;
    }


Cleanup:
    AssertSz( ! FAILED(hr), "Drag & Drop failed");
    ReleaseInterface( pBoundaryStart );
    ReleaseInterface( pBoundaryEnd );
    ReleaseInterface( pBoundaryStart2 );
    ReleaseInterface( pBoundaryEnd2 );    
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pEdServices );
    ReleaseInterface( pIElementDrop );
    
    RRETURN1 ( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     SelectAfterDrag
//
//  Synopsis:   Make a selection after you just did a drag/drop operation.
//
//----------------------------------------------------------------------------


HRESULT
CDropTargetInfo::SelectAfterDrop(
                                        IDataObject* pDataObj, 
                                        IMarkupPointer* pStart,
                                        IMarkupPointer* pEnd)
{
    HRESULT                 hr;
    ISegmentList            *pSegmentList = NULL;
    ISegmentList            *pSelectList = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    IElementSegment         *pISegmentAdded = NULL;
    IHTMLEditingServices    *pEdServices = NULL;
    IHTMLEditor             *pIEditor = NULL;
    SELECTION_TYPE          eType;
    BOOL                    fSelected = FALSE;
    IMarkupPointer          *pTempStart = NULL;
    IMarkupPointer          *pElemStart = NULL;
    IMarkupPointer          *pElemEnd = NULL;
    IHTMLElement            *pIDragElement = NULL;
    BOOL                    fHasSelection = FALSE;
    

    pIEditor = _pDoc->GetHTMLEditor();
    if( pIEditor == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    IFC( _pDoc->GetEditingServices(& pEdServices ));

    //
    // We QI the IDataObj for ISegmentList - true for IE 5 & IE 6. If we have
    // one - we use the segment list based select. If not - we do it the IE 4 way
    // and "look" for something site selectable.
    //
    hr = THR ( pDataObj->QueryInterface( IID_ISegmentList, (void**) & pSegmentList ));
    if ( !hr && pSegmentList )
    {
        IFC( pSegmentList->GetType( &eType ));

        if ( eType == SELECTION_TYPE_Control )
        {
            //
            // if we have multiple controls site selected - 
            // we need to create a CSegmentList - and call select on it
            //
            Assert( hr == S_OK );                

            CSegmentList segmentList;
            segmentList.SetSelectionType( eType );

            // Create an iterator, and a pointer to keep track of the
            // current start position.
            IFC( pSegmentList->CreateIterator( &pIter ) );
            IFC( _pDoc->CreateMarkupPointer( & pTempStart ));
            IFC( pTempStart->MoveToPointer( pStart ) );

            // Create and position our pointers
            IFC( _pDoc->CreateMarkupPointer( &pElemStart ));
            IFC( _pDoc->CreateMarkupPointer( &pElemEnd ));

            while( pIter->IsDone() == S_FALSE )
            {
                IFC( pIter->Current(&pISegment) );

                IFC( pElemStart->MoveToPointer( pTempStart ) );
                IFC( pElemEnd->MoveToPointer( pEnd ));

                ClearInterface(&pIDragElement);
                IFC( pEdServices->FindSiteSelectableElement( pElemStart, pElemEnd, & pIDragElement));
                
                if ( pIDragElement )
                {
                    IFC( segmentList.AddElementSegment( pIDragElement, &pISegmentAdded ));

                    // Reposition our temporary starting position
                    IFC( pTempStart->MoveAdjacentToElement( pIDragElement, ELEM_ADJ_AfterEnd ) );
                }
                else
                {
                    IFC( pISegment->GetPointers( pElemStart, pTempStart ) );
                }

                // Advance to next segment
                IFC( pIter->Advance() );

                // Clear interfaces
                ClearInterface(&pISegmentAdded);
                ClearInterface(&pISegment);
            }

            IFC( segmentList.QueryInterface( IID_ISegmentList, (void **)&pSelectList) );

            IFC( pSelectList->IsEmpty(&fHasSelection) );
            if (!fHasSelection )
            {
                IFC( _pDoc->Select(pSelectList));
            }

            fSelected = TRUE;                
        }
    }

    if ( ! fSelected )
    {
        ClearInterface(&pIDragElement);
        hr = THR( pEdServices->FindSiteSelectableElement( pStart, pEnd, & pIDragElement));
        if ( hr == S_OK )                
        {
            eType = SELECTION_TYPE_Control ;
            
            IFC( pStart->MoveAdjacentToElement( pIDragElement, ELEM_ADJ_BeforeBegin ));
            IFC( pEnd->MoveAdjacentToElement( pIDragElement, ELEM_ADJ_AfterEnd ));
        }
        else
            eType = SELECTION_TYPE_Text;
       
        IFC( _pDoc->Select( pStart, pEnd, eType ));

        if ( eType != SELECTION_TYPE_Control )
        {
            IFC( _pDoc->ScrollPointersIntoView( pStart, pEnd ));
        }

    }

Cleanup:

    ReleaseInterface( pIter );
    ReleaseInterface( pISegment );
    ReleaseInterface( pISegmentAdded );
    ReleaseInterface( pTempStart );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pSelectList );
    ReleaseInterface( pEdServices );
    ReleaseInterface( pElemStart );
    ReleaseInterface( pElemEnd );
    ReleaseInterface( pIDragElement );
    
    RRETURN( hr );
}

BOOL
CDropTargetInfo::IsAtInitialHitPoint(POINTL pt)
{
    CPoint  ptCurrent;

    //  See if we're still where we started
    ptCurrent.x = pt.x;
    ptCurrent.y = pt.y;

    ScreenToClient( _pDoc->_pInPlace->_hwnd, & ptCurrent );

    return (_ptInitial.x == ptCurrent.x && _ptInitial.y == ptCurrent.y);
}

CSelDragDropSrcInfo::CSelDragDropSrcInfo( CDoc* pDoc ) : 
    CDragDropSrcInfo() ,
    _selSaver( pDoc )
{
    _ulRefs = 1;
    _srcType = DRAGDROPSRCTYPE_SELECTION;
    _pDoc = pDoc;
    Assert( ! _pBag );
}

CSelDragDropSrcInfo::~CSelDragDropSrcInfo()
{
    ReleaseInterface(_pStart);
    ReleaseInterface(_pEnd);
    
    delete _pBag;   // To break circularity
}


//+====================================================================================
//
// Method:GetSegmentList
//
// Synopsis: Hide the getting of the segment list on the doc - so we can easily be moved
//
//------------------------------------------------------------------------------------

HRESULT
CSelDragDropSrcInfo::GetSegmentList( ISegmentList** ppSegmentList )
{
    return ( _pDoc->GetCurrentSelectionSegmentList( ppSegmentList ) ) ; 
}

HRESULT
CSelDragDropSrcInfo::GetMarkup( IMarkupServices** ppMarkup)
{
    return ( _pDoc->PrimaryMarkup()->QueryInterface( IID_IMarkupServices, (void**) ppMarkup )) ; 
}

//+====================================================================================
//
// Method: Init
//
// Synopsis: Inits the SelDragDrop Info. Basically positions two TreePointers around 
// the selection, creates a range, and invokes the saver on that to create a Bag.
// 
//
//------------------------------------------------------------------------------------

HRESULT 
CSelDragDropSrcInfo::Init(CElement* pElement)
{
    HRESULT         hr = S_OK;
    ISegmentList    *pSegmentList = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    IMarkupServices *pMarkup = NULL;
    CBaseBag        *pBag = NULL;;
    CMarkup         *pMarkupInternal;
    DWORD            dwFlags = 0;
    SELECTION_TYPE  eType;

    Assert( pElement );
    
    //
    // Position the Pointers
    //
    IFC( _pDoc->CreateMarkupPointer( &_pStart ) );
    IFC( _pDoc->CreateMarkupPointer( &_pEnd ) );
  
    IFC( GetSegmentList( & pSegmentList ));
    IFC( pSegmentList->GetType(&eType) );

    IFC( _selSaver.SetSelectionType(eType) );
    IFC( _selSaver.SaveSelection());

    pMarkupInternal = pElement->GetMarkup();

    if( pElement->GetFirstBranch()->SupportsHtml() )
    {
        dwFlags |= CREATE_FLAGS_SupportsHtml;
    }
    if (eType == SELECTION_TYPE_Control &&
        !_selSaver.HasMultipleSegments())
    {
        //  Bug 18795, 13330: The saver includes <FORM> elements if the <FORM> contains one
        //  control, and the user is dragging the control.  In this case we don't want to 
        //  adjust out so we set the CREATE_FLAGS_NoIE4SelCompat flag.

        IFC( _selSaver.CreateIterator( &pIter ) );

        if( pIter->IsDone() == S_FALSE )
        {
            CMarkupPointer      *pTest;

            IFC( pIter->Current(&pISegment) );

            IFC( pISegment->GetPointers( _pStart, _pEnd ) );
            IFC( _pStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pTest) );

            CTreeNode   *pNode = pTest->CurrentScope();

            //  Since pTest is positioned outside of the control, the scope will be the parent
            //  element.  We're interested in seeing whether the parent is a <form> element.

            if (pNode && pNode->Tag() == ETAG_FORM)
            {
                dwFlags |= CREATE_FLAGS_NoIE4SelCompat;
            }

            //  Since we checked that HasMultipleSegments() was FALSE, we
            //  should not have any more segments here.
            IFC( pIter->Advance() );
            Assert(pIter->IsDone() == S_OK);
        }
        else
        {
            AssertSz(FALSE, "We're dragging a control but we have no segments!");
        }
    }

    IFC(CTextXBag::Create( pMarkupInternal, 
                                dwFlags, 
                                pSegmentList, 
                                TRUE, 
                                (CTextXBag **)&pBag, 
                                this ));

    _pBag = pBag;

    hr = THR( SetInSameFlow());

Cleanup:
    ReleaseInterface( pMarkup );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pISegment );

    RRETURN(hr);    
}

HRESULT
CSelDragDropSrcInfo::SetInSameFlow()
{
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;
    BOOL                    fSameFlow = FALSE;    

    _fInSameFlow = TRUE;

    IFC( _selSaver.CreateIterator( &pIter ) );

    while( pIter->IsDone() == S_FALSE )
    {
        IFC( pIter->Current(&pISegment) );

        IFC( GetInSameFlowSegment( pISegment, & fSameFlow ));
        if ( ! fSameFlow )
        {
            _fInSameFlow = FALSE;
            break;
        }
       
        IFC( pIter->Advance() );

        ClearInterface(&pISegment);
    }

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);
    
    RRETURN( hr );
}

//+====================================================================================
//
// Method:SetInSameFlowSegment
//
// Synopsis: Set the _pfInSameFlow Bit per Selection Segment.
//
//------------------------------------------------------------------------------------

HRESULT
CSelDragDropSrcInfo::GetInSameFlowSegment( ISegment *pISegment, BOOL *pfSameFlow )
{
    HRESULT hr = S_OK;
    
    CElement* pElement1 = NULL;
    CElement* pElement2 = NULL;
    CFlowLayout* pFlow1 = NULL;
    CFlowLayout* pFlow2 = NULL;
    IHTMLElement* pIHTMLElement1 = NULL;
    IHTMLElement* pIHTMLElement2 = NULL;

    Assert( pfSameFlow );
    Assert( pISegment );

    IFC( pISegment->GetPointers( _pStart, _pEnd ) );
    
    IFC( _pDoc->CurrentScopeOrSlave( _pStart, & pIHTMLElement1));

    if ( ! pIHTMLElement1 )
    {
        AssertSz(0, "Didn't get an element");
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pIHTMLElement1->QueryInterface( CLSID_CElement, (void**) & pElement1 ));

    IFC( _pDoc->CurrentScopeOrSlave( _pEnd, & pIHTMLElement2));

    if ( ! pIHTMLElement2 )
    {
        AssertSz(0, "Didn't get an element");
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pIHTMLElement2->QueryInterface( CLSID_CElement, (void**) & pElement2 ));

    pFlow1 = pElement1->GetFirstBranch()->GetFlowLayout();

    pFlow2 = pElement2->GetFirstBranch()->GetFlowLayout();

    if ( pfSameFlow )
        *pfSameFlow =  ( pFlow1 == pFlow2 );
    
Cleanup:
    ReleaseInterface( pIHTMLElement1 );
    ReleaseInterface( pIHTMLElement2 );

    RRETURN ( hr );
    
}

//+---------------------------------------------------------------------------
//
//  Member:     IsInsideSelection
//
//  Synopsis:   Is the given pointer inside the saved selection ?
//
//----------------------------------------------------------------------------

BOOL
CSelDragDropSrcInfo::IsInsideSelection(IMarkupPointer* pTestPointer)
{
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;
    BOOL                    fInside = FALSE;

    IFC( _selSaver.CreateIterator( &pIter ) );

    while( pIter->IsDone() == S_FALSE )
    {
        IFC( pIter->Current(&pISegment) );

        fInside = IsInsideSavedSelectionSegment( pISegment, pTestPointer );
        if ( fInside )
            break;
       
        IFC( pIter->Advance() );

        ClearInterface(&pISegment);
    }

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);

    return fInside;
}

//+---------------------------------------------------------------------------
//
//  Member:     IsInsideSavedSelectionSegment
//
//  Synopsis:   Is the given pointer inside a given saved selection segment ? 
//
//----------------------------------------------------------------------------


BOOL
CSelDragDropSrcInfo::IsInsideSavedSelectionSegment( ISegment *pISegment, IMarkupPointer* pTestPointer)
{
    BOOL                fInsideSelection    = FALSE;
    CMarkupPointer *    pTest               = NULL;
    CMarkupPointer *    pStart              = NULL;
    CMarkupPointer *    pEnd                = NULL;
    CElement *          pElement            = NULL;
    CMarkup *           pMarkupSel;
    CMarkup *           pMarkupTest;
#ifdef NEVER
    CElement *          pElemMaster;
#endif
    BOOL                fRefOnTest          = FALSE;
    SELECTION_TYPE      eType;
    HRESULT             hr = S_OK;
    BOOL                fDifferentMarkups   = FALSE;
    
    Assert( pISegment );

    IFC( pISegment->GetPointers( _pStart, _pEnd ) );

    // Handle the case where pTestPointer is not in the same markup as
    // _pStart and _pEnd.
    Verify(
        S_OK == pTestPointer->QueryInterface(CLSID_CMarkupPointer, (void**)&pTest)
     && S_OK == _pStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pStart)
     && S_OK == _pEnd->QueryInterface(CLSID_CMarkupPointer, (void**)&pEnd));

    pMarkupSel = pStart->Markup();
    Assert(pMarkupSel && pMarkupSel == pEnd->Markup());

    pMarkupTest = pTest->Markup();
    Assert(pMarkupTest);

    if (pMarkupTest != pMarkupSel)
    {
        CTreeNode * pNodeTest = pTest->CurrentScope(MPTR_SHOWSLAVE);

        while (pNodeTest && pNodeTest->GetMarkup() != pMarkupSel)
        {
            while (pNodeTest && !pNodeTest->Element()->HasMasterPtr())
            {
                pNodeTest = pNodeTest->Parent();
            }
            if (pNodeTest)
            {
                pNodeTest = pNodeTest->Element()->GetMasterPtr()->GetFirstBranch();
            }
        }
        if (pNodeTest)
        {
            if (S_OK != _pDoc->CreateMarkupPointer(&pTest))
                goto Cleanup;
            fRefOnTest = TRUE;
            pElement = pNodeTest->Element();
            if (S_OK != pTest->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin))
                goto Cleanup;
            fDifferentMarkups = TRUE;
        }
    }

    //
    // Why are the rules for AreWeInside A selection different ? 
    // We want to not compare on equality for character selection
    // otherwise we can't drag characters adjacent to each other ( bug 11490 ).
    // BUT we want to not allow controls to be dragged onto each other - for example dragging a Text box
    // onto iteself with nothing else in the tree ( bug 54338 )
    //
    _selSaver.GetType( &eType );

    //
    // This seems ok now - we don't need to copare isEqualTo on control elemnets
    // and it fixes bugs like 102011.
    //
    if (pTest->Markup() == pStart->Markup())
    {
        if ( eType == SELECTION_TYPE_Control )
        {
            // Bug 104536: If we're in different markups, we need to test equality on the start
            // and test pointer since we've positioned the test pointer at the start of the nested
            // markup.

            BOOL    fRightOfStart = FALSE;
            fRightOfStart = (fDifferentMarkups) ? pTest->IsRightOfOrEqualTo(pStart ) :
                                                  pTest->IsRightOf(pStart );
            if ( fRightOfStart )
            {        
                if ( pTest->IsLeftOf( pEnd ) )
                {
                    fInsideSelection = TRUE;
                }
            }
        }
        else 
        {
            BOOL    fTestLeft = FALSE;

            if ( pTest->IsRightOf(pStart ) )
            {
                fTestLeft = TRUE;
            }
            else if (fDifferentMarkups)
            {
                //  We may have positioned the test pointer to the same position as the start markup pointer.
                //  If this is the case, we'll check to see if the end of the nested markup is between the
                //  start and end markup pointers.  If so, we are inside the selection.

                if (pTest->IsEqualTo(pStart))
                {
                    if (S_OK != pTest->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd))
                        goto Cleanup;
                    fTestLeft = TRUE;
                }
            }

            if (fTestLeft && pTest->IsLeftOf(pEnd))
            {
                fInsideSelection = TRUE;
            }
        }
    }

Cleanup:
    if (fRefOnTest)
        ReleaseInterface(pTest);
    return ( fInsideSelection );
}

//+====================================================================================
//
// Method: IsValidPaste
//
// Synopsis: Ask if the drop is valid. If the pointer is within the selection it isn't valid
//
//------------------------------------------------------------------------------------


HRESULT
CSelDragDropSrcInfo::IsValidDrop(IMarkupPointer* pTestPointer, BOOL fDuringCopy /*=FALSE*/)
{
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;
    BOOL                    fInsideSelection = FALSE;
    CMarkupPointer          *pTest = NULL;
    CMarkupPointer          *pStart = NULL;
    CMarkupPointer          *pEnd = NULL;
    BOOL                    fSelectionHasMultipleSegments = FALSE;

    IFC( pTestPointer->QueryInterface(CLSID_CMarkupPointer, (void**)&pTest));

    IFC( _selSaver.CreateIterator( &pIter ) );
    fSelectionHasMultipleSegments = _selSaver.HasMultipleSegments();

    //  If we have multiple selection segments, we are interested in seeing whether we are
    //  dropping at a point that is in or next to any segment in the selection.

    while( pIter->IsDone() == S_FALSE )
    {
        IFC( pIter->Current(&pISegment) );

        IFC( pISegment->GetPointers( _pStart, _pEnd ) );
        
        IFC( _pStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pStart));        
        IFC( _pEnd->QueryInterface(CLSID_CMarkupPointer, (void**)&pEnd));

        if ( pTest->Markup() != pStart->Markup() ||
             pTest->Markup() != pEnd->Markup() )
        {
            goto Cleanup;
        }

        //  If we are doing a copy, we should allow the user to drop next to
        //  our selection.
        
        if ( fDuringCopy || fSelectionHasMultipleSegments )
        {
            if ( pTest->IsRightOf(pStart ) )
            {        
                if ( pTest->IsLeftOf( pEnd ) )
                {
                    fInsideSelection = TRUE;
                    break;
                }
            }
        }
        else
        {
            if ( pTest->IsRightOfOrEqualTo(pStart ) )
            {        
                if ( pTest->IsLeftOfOrEqualTo( pEnd ) )
                {
                    fInsideSelection = TRUE;
                    break;
                }
            }
        }
            
        IFC( pIter->Advance() );

        ClearInterface(&pISegment);
    }

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);

    if ( fInsideSelection )
        hr = S_FALSE;
    else if ( ! hr )
        hr = S_OK;
    
    RRETURN1( hr, S_FALSE );        
}

    
HRESULT 
CSelDragDropSrcInfo::GetDataObjectAndDropSource(    IDataObject **  ppDO,
                                                    IDropSource **  ppDS )
{
    HRESULT hr = S_OK;

    hr = THR( QueryInterface(IID_IDataObject, (void **)ppDO));
    if (hr)
        goto Cleanup;

    hr = THR( QueryInterface(IID_IDropSource, (void **)ppDS));
    if (hr)
    {
        (*ppDO)->Release();
        goto Cleanup;
    }
    
Cleanup:
    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     PostDragDelete
//
//  Synopsis: The drag is over and has successfully finished ( on a move)
//            We want to now delete the contents of the selection
//
//----------------------------------------------------------------------------

 
HRESULT 
CSelDragDropSrcInfo::PostDragDelete()
{
    IHTMLEditingServices    *pEdServices = NULL;
    IHTMLEditor             *pEditor = NULL ;
    BOOL                    fInSameFlow;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;

    pEditor = _pDoc->GetHTMLEditor();

    if ( pEditor )
    {
        IFC( pEditor->QueryInterface( IID_IHTMLEditingServices, ( void**) & pEdServices ));

        IFC( _selSaver.CreateIterator( &pIter ) );

        while( pIter->IsDone() == S_FALSE )
        {
            IFC( pIter->Current(&pISegment) );

            // Delete the segment
            IFC( GetInSameFlowSegment( pISegment, & fInSameFlow ));

            IFC( pISegment->GetPointers(_pStart, _pEnd) );
            
            if ( fInSameFlow )
            {
                IFC( pEdServices->Delete( _pStart, _pEnd, TRUE ));
            }                    
           
            IFC( pIter->Advance() );

            ClearInterface(&pISegment);
        }
    }
    else
        hr = E_FAIL;

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);
    ReleaseInterface(pEdServices );

    RRETURN ( hr );
}

HRESULT 
CSelDragDropSrcInfo::PostDragSelect()
{
    ISegmentList    *pSegmentList = NULL;
    HRESULT         hr = E_FAIL;

    IFC( _selSaver.QueryInterface(IID_ISegmentList, (void **)&pSegmentList ) );
    
    IFC( _pDoc->Select( pSegmentList ) );

Cleanup:
    ReleaseInterface(pSegmentList);
    RRETURN(hr);
}

// ISegmentList methods
HRESULT
CSelDragDropSrcInfo::GetType(SELECTION_TYPE *peType)
{
    return _selSaver.GetType(peType);
}

HRESULT
CSelDragDropSrcInfo::CreateIterator(ISegmentListIterator **ppIIter)
{
    return _selSaver.CreateIterator(ppIIter);
}

HRESULT
CSelDragDropSrcInfo::IsEmpty(BOOL *pfEmpty)
{
    return _selSaver.IsEmpty(pfEmpty);
}

STDMETHODIMP
CSelDragDropSrcInfo::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( this, IDataObject )
        QI_INHERITS( this, IDropSource )
        QI_INHERITS2( this, IUnknown, IDropSource  )
        
    case Data1_ISegmentList:    
        if ( iid == IID_ISegmentList )
        {                                   
            return _selSaver.QueryInterface( iid, ppv );
        }                                   
        break;

    default:
        if (_pBag)
            return _pBag->QueryInterface(iid, ppv);
        break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

//
// Methods that we delegate to our _pBag
//

HRESULT CSelDragDropSrcInfo::DAdvise( FORMATETC FAR* pFormatetc,
        DWORD advf,
        LPADVISESINK pAdvSink,
        DWORD FAR* pdwConnection) 
{
    if ( _pBag )
    {
        RRETURN ( _pBag->DAdvise( pFormatetc, advf, pAdvSink, pdwConnection ) ); 
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::DUnadvise( DWORD dwConnection)
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->DUnadvise( dwConnection ) );
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::EnumDAdvise( LPENUMSTATDATA FAR* ppenumAdvise)
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->EnumDAdvise( ppenumAdvise ));
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::EnumFormatEtc(
            DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc)
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->EnumFormatEtc( dwDirection, ppenumFormatEtc ) );
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::GetCanonicalFormatEtc(
            LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut)
{ 
    if ( _pBag )
    {
        RRETURN( _pBag->GetCanonicalFormatEtc( pformatetc, pformatetcOut) );
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->GetData( pformatetcIn, pmedium ));
    }
    else
        return E_FAIL;
}

HRESULT 
CSelDragDropSrcInfo::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{ 
    if ( _pBag )
    {
        RRETURN( _pBag->GetDataHere( pformatetc, pmedium ));
    }
    else
        return E_FAIL;
}


HRESULT 
CSelDragDropSrcInfo::QueryGetData(LPFORMATETC pformatetc )
{ 
    if ( _pBag )
    {
        RRETURN( _pBag->QueryGetData( pformatetc ));
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease)
{
    if ( _pBag )
    {
        RRETURN( _pBag->SetData( pformatetc, pmedium , fRelease));  
    }
    else
        return E_FAIL;
}


HRESULT
CSelDragDropSrcInfo::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    if ( _pBag )
    {
        return( _pBag->QueryContinueDrag( fEscapePressed, grfKeyState ));
    }
    else
        return E_FAIL;
}

HRESULT 
CSelDragDropSrcInfo::GiveFeedback (DWORD dwEffect)
{
    if ( _pBag )
    {
        return( _pBag->GiveFeedback (dwEffect));
    }
    else
        return E_FAIL;
}




CDragDropTargetInfo::CDragDropTargetInfo(CDoc* pDoc )
{
    _pDoc = pDoc;
    _pSaver = NULL;
    _fSelectionSaved = FALSE;
    if( _pDoc->_pElemCurrent && _pDoc->_pElemCurrent->IsEditable(/*fCheckContainerOnly*/FALSE) )
    {
        StoreSelection();
        //
        // Tell the Selection to tear itself down for the duration of the drag    
        //
        _pDoc->DestroySelection();
    }
}

CDragDropTargetInfo::~CDragDropTargetInfo()
{
    ReleaseInterface( _pSaver );        
}


HRESULT 
CDragDropTargetInfo::StoreSelection()
{
    HRESULT hr = S_OK ;

    Assert( ! _pSaver );

    _pElemCurrentAtStoreSel = _pDoc->_pElemCurrent ;

    _pSaver = new CSelectionSaver( _pDoc );
    if ( ! _pSaver )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    IFC( _pSaver->SaveSelection());
    _fSelectionSaved = TRUE;
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CDragDropTargetInfo::RestoreSelection()
{
    ISegmentList    *pSegmentList = NULL;
    HRESULT         hr = E_FAIL;
    //
    // Ensure that the current element we began a drag & drop with is the same
    // as the currency now. This makes us not whack selection back - if our host
    // has changed currency on us in some way ( as access does over ole controls)
    //
    if ( _pDoc->_pElemCurrent == _pElemCurrentAtStoreSel &&
         _pSaver->HasSegmentsToRestore() )
    {
        IFC( _pSaver->QueryInterface(IID_ISegmentList, (void **)&pSegmentList ) );
        
        IFC( _pDoc->Select( pSegmentList ) );
    }

    _pElemCurrentAtStoreSel = NULL;

Cleanup:
    ReleaseInterface( pSegmentList );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\slist.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "slist.hxx"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "segment.hxx"
#endif

MtDefine(CSegmentList, Utilities, "CSegmentList")
MtDefine(CSegmentListIterator, Utilities, "CSegmentListIterator")

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::CSegmentList
//
//  Synopsis:   Constructor
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentList::CSegmentList() 
{
    _eType = SELECTION_TYPE_None;
    _ulRefs = 1;

    //
    // May be used on the stack Not Memcleared.
    //
    _pFirst = NULL;
    _pLast = NULL;
    _nSize = 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::~CSegmentList
//
//  Synopsis:   Destructor
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentList::~CSegmentList()
{
    RemoveAll();
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CSegmentList::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentList )
    {
        *ppvObj = (ISegmentList *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

//
//  ISegmentList methods
//

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::GetType
//
//  Synopsis:   Retrieves the type of selection this segment list contains
//
//  Arguments:  peType = OUT pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::GetType( SELECTION_TYPE *peType )
{
    HRESULT hr = E_FAIL;
    
    Assert( peType );

    if( peType )
    {
        *peType = _eType; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::IsEmpty
//
//  Synopsis:   Determines whether the segment list is empty or not
//
//  Arguments:  pfEmpty = Empty pointer to BOOL
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::IsEmpty( BOOL *pfEmpty )
{
    HRESULT hr = E_FAIL;
    
    Assert( pfEmpty );

    if( pfEmpty )
    {
        *pfEmpty = (_pFirst == NULL) ? TRUE :FALSE; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::CreateIterator
//
//  Synopsis:   Creates an iterator that can be used to iterate over the 
//              segments in our list.
//
//  Arguments:  pIIter = Iterator to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::CreateIterator( ISegmentListIterator **pIIter )
{
    HRESULT hr = S_OK;

    CSegmentListIterator *pListIter = new CSegmentListIterator();

    if( pListIter == NULL )
        goto Error;

    // Initialize the iterator, and retrieve the ISegmentListIterator interface
    IFC( pListIter->Init( _pFirst ) );
    IFC( pListIter->QueryInterface(IID_ISegmentListIterator, (void **)pIIter) );
  
Cleanup:
    ReleaseInterface( pListIter );
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::SetSelectionType
//
//  Synopsis:   Sets the type of selection this segment list contains
//
//  Arguments:  eType = selection type
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::SetSelectionType( SELECTION_TYPE eType )
{
    while( !IsEmpty() )
    {
        PrivateRemove( _pFirst );
    }

    _eType = eType;
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::AddSegment
//
//  Synopsis:   Adds a segment to our list.
//
//  Arguments:  pStart = Start position
//              pEnd = End position
//              pISegmentAdded = OUTPUT ISegment pointer to added segment
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::AddSegment( IMarkupPointer    *pIStart,
                          IMarkupPointer    *pIEnd,
                          ISegment          **pISegmentAdded)
{
    HRESULT     hr = E_INVALIDARG;
    CSegment    *pSegment = NULL;
    
    Assert( pIStart && pIEnd && pISegmentAdded );
//        Assert( (GetSelectionType() == SELECTION_TYPE_Caret) || 
//                (GetSelectionType() == SELECTION_TYPE_Text ) );

    if( pIStart && pIEnd && pISegmentAdded )
    {
        pSegment = new CSegment();
        if ( pSegment == NULL )
            goto Error;

        // Add this to our linked list, and retrieve the ISegment interface
        IFC( pSegment->Init( pIStart, pIEnd ) );
        IFC( PrivateAdd( pSegment ) );

        IFC( pSegment->QueryInterface( IID_ISegment, (void **)pISegmentAdded) );
    }        
             
Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::AddElementSegment
//
//  Synopsis:   Adds an element segment. The element segment is used to 
//              keep track of control selections.
//
//  Arguments:  pIElement = Element to bound selection to
//              ppISegmentAdded = ISegment pointer to added segment
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::AddElementSegment( IHTMLElement       *pIElement,
                                 IElementSegment    **pISegmentAdded )
{
    HRESULT         hr = E_INVALIDARG;
    CElementSegment *pSegment = NULL;
    
    Assert( pIElement && pISegmentAdded );
//    Assert( GetSelectionType() == SELECTION_TYPE_Control );

    if( pIElement && pISegmentAdded)
    {
        pSegment = new CElementSegment();
        if ( pSegment == NULL )
            goto Error;
  
        // Initialize and add our new segment
        IFC( pSegment->Init( pIElement ) );
        IFC( PrivateAdd( pSegment ) );

        IFC( pSegment->QueryInterface( IID_IElementSegment, (void **)pISegmentAdded) );
    }        
             
Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::AddCaretSegment
//
//  Synopsis:   Adds a caret segment. The caret segment is used to keep track
//              of the caret.
//
//  Arguments:  pICaret = Caret pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::AddCaretSegment(IHTMLCaret *pICaret, ISegment **pISegmentAdded)
{
    HRESULT         hr = E_INVALIDARG;
    CCaretSegment   *pSegment = NULL;
    
    Assert( pICaret );
    Assert( GetSelectionType() == SELECTION_TYPE_Caret );

    if( pICaret )
    {
        pSegment = new CCaretSegment();
        if ( pSegment == NULL )
            goto Error;
  
        // Initialize and add our new segment
        IFC( pSegment->Init( pICaret ) );
        IFC( PrivateAdd( pSegment ) );

        // Retrieve the ISegment pointer
        if( pISegmentAdded )
        {
            IFC( pSegment->QueryInterface( IID_ISegment, (void **)pISegmentAdded) );
        }            
    }        
             
Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::RemoveSegment
//
//  Synopsis:   Removes a segment.
//
//  Arguments:  pISegment = Segment to remove
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::RemoveSegment( ISegment *pISegment )
{
    HRESULT     hr = E_INVALIDARG;
    CSegment    *pSegment = NULL;
    
    Assert( pISegment );

    if( pISegment )
    {
        // Lookup our element
        IFC( PrivateLookup(pISegment, &pSegment) );
        
        // Remove it
        IFC( PrivateRemove( pSegment ) );
    }        
            
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::PrivateAdd
//
//  Synopsis:   Adds a segment to the linked list
//
//  Arguments:  pSegment = Segment to add
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::PrivateAdd( CSegment *pSegment )
{
    Assert( pSegment );

    if( IsEmpty() )
    {
        // Handle the case when this is the
        // first element
        _pFirst = pSegment;
        _pLast = pSegment;
        _pFirst->SetNext(NULL);
        _pFirst->SetPrev(NULL);
    }
    else
    {
        // Append this element
        pSegment->SetNext(NULL);
        pSegment->SetPrev(_pLast);
        _pLast->SetNext(pSegment);
        _pLast = pSegment;   
    }

    _nSize++;
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::PrivateLookup
//
//  Synopsis:   Given an ISegment, this function will find the underlying
//              CSegment.
//
//  Arguments:  pISegment = ISegment to retreive CSegment for
//              ppSegment = Returned CSegment pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::PrivateLookup( ISegment *pISegment, CSegment **ppSegment )
{  
    HRESULT hr = S_OK;
    
    Assert( pISegment && ppSegment );

    // Query for the CSegment
    IFC( pISegment->QueryInterface(CLSID_CSegment, (void **)ppSegment));

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::RemoveAll
//
//  Synopsis:   Removes all of the segments from the linked list.
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::RemoveAll(void)
{  
    HRESULT hr = S_OK;
    
    while( !IsEmpty() )
    {
        IFC( PrivateRemove( _pFirst ) );
    }

Cleanup:
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::PrivateRemove
//
//  Synopsis:   Removes a CSegment from the list
//
//  Arguments:  pSegment = CSegment to remove
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::PrivateRemove( CSegment *pSegment )
{  
    CSegment    *pNext = NULL;
    CSegment    *pPrev = NULL;

    pPrev = pSegment->GetPrev();
    pNext = pSegment->GetNext();

    Assert( pSegment );

    // Item certainly isn't in our list, and it looks like it
    // should be in our list, tell our client
    if( ( (_pFirst == _pLast) && (pSegment != _pFirst) ) || 
        ( (_pFirst != _pLast) && (pPrev == NULL) && (pNext == NULL) ) )
    {
        return S_FALSE;
    }

    if( _pFirst == _pLast )
    {
        _pFirst = NULL;
        _pLast = NULL;
    }
    else if( pSegment == _pFirst )
    {
        // Removing first element
        _pFirst = pSegment->GetNext();
        _pFirst->SetPrev(NULL);
    }
    else if( pSegment == _pLast )
    {
        // Removing last element
        _pLast = pSegment->GetPrev();
        _pLast->SetNext(NULL);
    }
    else
    {
        // Should be somewhere in the middle of the list
        Assert( pSegment->GetNext() );
        Assert( pSegment->GetPrev() );

        pPrev->SetNext(pNext);
        pNext->SetPrev(pPrev);
    }

    pSegment->SetNext(NULL);
    pSegment->SetPrev(NULL);
    
    ReleaseInterface(pSegment);

    _nSize--;
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::CSegmentListIterator
//
//  Synopsis:   Constructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentListIterator::CSegmentListIterator()
{
    Assert( _pCurrent == NULL );
    Assert( _pFirst == NULL );
    _ulRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::~CSegmentListIterator
//
//  Synopsis:   Destructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentListIterator::~CSegmentListIterator()
{
    
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::Init
//
//  Synopsis:   Initializes our segment list iterator
//
//  Arguments:  pFirst = Pointer to first segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSegmentListIterator::Init(CSegment *pFirst)
{   
    _pFirst = pFirst;
    _pCurrent = pFirst;
        
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::First
//
//  Synopsis:   Resets the iterator
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentListIterator::First()
{
    return Init(_pFirst);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::Current
//
//  Synopsis:   Returns the current ISegment position of the iterator.
//
//  Arguments:  ppISegment = OUTPUT pointer to an ISegment which will contain
//                the current segment for this iterator.
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentListIterator::Current(ISegment **pISegment)
{
    HRESULT hr = E_FAIL;

    Assert( pISegment != NULL );
    
    if( (_pCurrent != NULL) && (pISegment != NULL ) )
    {
        hr = _pCurrent->QueryInterface(IID_ISegment, (void **)pISegment);
    }

    RRETURN(hr);        
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::IsDone
//
//  Synopsis:   Returns whether or not we have iterated past the end of our
//              list.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = There are no more elements
//              S_FALSE = There are more elements
//
//--------------------------------------------------------------------------
HRESULT
CSegmentListIterator::IsDone(void)
{
    return (_pCurrent == NULL) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::Advance
//
//  Synopsis:   Advances the iterator by one element.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = The iterator was advanced successfully
//              S_FALSE = The advance operation failed
//
//--------------------------------------------------------------------------
HRESULT
CSegmentListIterator::Advance(void)
{
    HRESULT hr = S_FALSE;

    if( IsDone() == S_FALSE )
    {
        _pCurrent = _pCurrent->GetNext();
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CSegmentListIterator::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentListIterator )
    {
        *ppvObj = (ISegmentListIterator *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\selrensv.cxx ===
//+---------------------------------------------------------------------
//
//   File:      Selrensv.cpp
//
//  Contents:   Implementation of ISelectionRenderServices on CTxtEdit.
//
//  Classes:    CTxtEdit
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SELRENSV_HXX_
#define X_SELRENSV_HXX_
#include "selrensv.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_SEGMENT_HXX_
#define X_SEGMENT_HXX_
#include "segment.hxx"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include "initguid.h"
#endif

const int LEFT = 1;   
const int RIGHT = -1 ;
const int SAME = 0;
const int INVALIDATE_VERSION = - 1000000;

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

MtDefine(CSelectionRenderingServiceProvider, Tree , "CSelectionRenderingServiceProvider" )    
MtDefine(CHighlightSegment, Utilities, "CHighlightSegment")

DeclareTag(tagValidateSelRenSv, "Selection", "Validate Selection Rendering Changes")

#if DBG == 1
static const LPCTSTR strSelectionStartName = _T(" Start Selection Segment");
static const LPCTSTR strSelectionEndName = _T(" End Selection Segment");
#endif

CSelectionRenderingServiceProvider::CSelectionRenderingServiceProvider(CDoc* pDoc, CMarkup* pMarkup )
{
    _lContentsVersion = INVALIDATE_VERSION;
    _pDoc = pDoc;
    _pMarkup = pMarkup ;
    _nSize = 0;
}

CSelectionRenderingServiceProvider::~CSelectionRenderingServiceProvider()
{
    ClearSegments(FALSE);
}

//+============================================================================================
//
//  Method:     InvalidateSegment
//
//  Arguments:  pStart = Starting pointer which needs to be invalidated
//              pEnd = End pointer which needs to be invalidated
//              pNewStart = This is where the new selection begins
//              pNewEnd = This is where the new selection ends
//              fSelected = Turn on or off selection

//  Synopsis:   The Area from pStart to pEnd's "selectioness" has changed. 
//              Tell the renderer about it.
//
//---------------------------------------------------------------------------------------------

DeclareTag(tagDisplayShowInvalSegment, "Selection", "Selection show InvalidateSegment")

HRESULT 
CSelectionRenderingServiceProvider::InvalidateSegment(  CMarkupPointer  *pStart, 
                                                        CMarkupPointer  *pEnd,
                                                        CMarkupPointer  *pNewStart,
                                                        CMarkupPointer  *pNewEnd ,
                                                        BOOL            fSelected )
{
    CTreePos    *pCurPos;                   // Current tree position in invalidation walk
    CTreePos    *pEndPos;                   // End position of range that needs to be inval'd
    CTreeNode   *pNode;                     // The node at pCurPos
    CLayout     *pCurLayout = NULL;         // The layout for the node at pCurPos
    CTreePos    *pPrevPos = NULL;           // The last position we looked at
    CTreeNode   *pFirstNode;                // Node corresponding to start
    CLayout     *pPrevLayout = NULL;        // Previous layout we examined
    CTreePos    *pLayoutStart = NULL;       // Start position of current layout that is being examined
    BOOL        fLayoutEnclosed = FALSE;    // Is the layout enclosed completely by our inval segment
    BOOL        fLayoutChange = FALSE;      // Have we had a layout change?
    HRESULT     hr = S_OK;

    Assert(pStart && pEnd);
    if ( pNewStart && pNewEnd )
    {
        Assert(pNewStart->Markup() == pNewEnd->Markup());
        if (pNewStart->Markup() != pNewEnd->Markup())
        {
            return E_FAIL;
        }
    }

    IGNORE_HR( pStart->Markup()->EmbedPointers() );
  
    //
    // Setup the ending position, the initial layout, and the starting TREEPOS
    // for this layout
    //
    pEndPos = pEnd->GetEmbeddedTreePos();
    pFirstNode = pStart->Branch();
    pPrevLayout = pFirstNode->GetUpdatedNearestLayout();
    pLayoutStart =  pStart->GetEmbeddedTreePos() ;

    // If the selection is in a slave markup, GetNearestLayout() will return NULL
    // on the top-level nodes. In such a case, we use the layout of the markup's
    // master element.
    if (!pPrevLayout && pFirstNode->Element()->HasMasterPtr())
    {
        pPrevLayout = pFirstNode->Element()->GetMasterPtr()->GetUpdatedLayout();
    }

#if DBG == 1
    //
    // marka - we shouldn't be invalidating if End < Start or End == SAME 
    //
    int layoutStartCp , layoutEndCp;

    layoutEndCp = pEndPos->GetCp();
    layoutStartCp = pLayoutStart->GetCp( FALSE );

    Assert( pStart->IsLeftOf( pEnd ) );
    Assert( layoutStartCp <= layoutEndCp );
#endif

    //
    // Loop from the starting point which needs to be inval'd and 
    // go to the end pointer
    // 
    for ( pCurPos = pStart->GetEmbeddedTreePos() ; 
          (pCurPos ) &&  (pCurPos != pEndPos); 
          pCurPos = pCurPos->NextTreePos() )
    {
        //
        // Code to handle rendering glyphs in between the two pos's
        //
        if ( pCurPos->IsNode() && pCurPos->ShowTreePos(NULL) )
        {
            CTreeNode* pGlyphNode = pCurPos->Branch();
            CLayout* pParentLayout = pGlyphNode->GetUpdatedParentLayout();

            pParentLayout->ShowSelected( pGlyphNode->GetBeginPos() ,
                                         pGlyphNode->GetEndPos(), 
                                         fSelected, 
                                         fLayoutEnclosed );
        }            

        //
        // If we have a begin or end scope, we need to check if we 
        // crossed a layout boundary
        //
        if (  ( pCurPos && pCurPos->IsBeginElementScope() )
           || ( pPrevPos && pPrevPos->IsEndElementScope()) )
               
        {            
            pNode = pCurPos->GetBranch();
            pCurLayout = pNode->GetUpdatedNearestLayout();

            //
            // If we have a new layout - then we draw the previous layout.
            //
            if ( pPrevLayout != pCurLayout )
            {
                //
                // If this is the first time we are looping, then
                // pLayoutRunOwner will be NULL, so we need to check
                // that it is not
                //
                if ( pPrevLayout )
                {
                    TraceTag((tagDisplayShowInvalSegment, "InvalidteSegment: Inval prevLayout from tp:%d to %d:",pLayoutStart->_nSerialNumber, pCurPos->_nSerialNumber ));
#if DBG == 1
                    layoutEndCp = pCurPos->GetCp( FALSE );
                    layoutStartCp = pLayoutStart->GetCp( FALSE );
                    Assert( layoutStartCp <= layoutEndCp );
#endif  

                    fLayoutEnclosed = IsLayoutCompletelyEnclosed( pPrevLayout, pNewStart, pNewEnd);

                    pPrevLayout->ShowSelected( pLayoutStart, pCurPos, fSelected, fLayoutEnclosed );

                    //
                    // If this layout has a slave pointer, invalidate all of the layouts
                    // in the slave markup.
                    //
                    if( pPrevLayout->ElementOwner()->HasSlavePtr() )
                    {
                        InvalidateLayout( pPrevLayout, pStart->Markup(), fSelected );
                    }
                        
                    IGNORE_HR( InvalidateParentLayout( pPrevLayout, pStart->Markup(), fSelected ) );
                }

                pPrevLayout = pCurLayout;
                pLayoutStart = pCurPos;
                fLayoutChange = TRUE;
            }
        }
        pPrevPos = pCurPos;
    }

    //
    // Add final layout
    //
    if ( pPrevLayout )
    {
        TraceTag((tagDisplayShowInvalSegment, "InvalidateSegment: Inval Final Layout from tp:%d to %d:",pLayoutStart->_nSerialNumber, pEndPos->_nSerialNumber ));

#if DBG == 1
        layoutEndCp = pEndPos->GetCp();
        layoutStartCp = pLayoutStart->GetCp( FALSE );
        Assert( layoutStartCp <= layoutEndCp );
#endif

        //
        // Invalidate our layout
        //
        fLayoutEnclosed = IsLayoutCompletelyEnclosed( pPrevLayout, pNewStart, pNewEnd);

        pPrevLayout->ShowSelected( pLayoutStart, pEndPos, fSelected, fLayoutEnclosed );

        if( pPrevLayout->ElementOwner()->HasSlavePtr() )
        {
            InvalidateLayout( pPrevLayout, pStart->Markup(), fSelected );
        }

        //
        // We only need to inval our parent layout if we crossed a layout boundary.  This
        // only happens if pCurLayout != pPrevLayout
        // 
        if( fLayoutChange )
        {
            IGNORE_HR( InvalidateParentLayout( pPrevLayout, pStart->Markup(), fSelected ) );
        }
    }     

    return hr;
}


//+============================================================================================
//
// Method:      CHighlightRenderingServices::InvalidateLayout
//
// Synopsis:    We need to invalidate the flow layout.  We must call ShowSelected() on the
//              layout, and potentially invalidate any of the children layout as well.
//
// Arguments:   pLayout = Base layout 
//              fSelected = Is the layout being selected?
//---------------------------------------------------------------------------------------------
void CSelectionRenderingServiceProvider::InvalidateLayout(  CLayout     *pLayout,
                                                            CMarkup     *pMarkup,
                                                            BOOL        fSelected )
{
    DWORD_PTR   dwIterator;
    CLayout *pSubLayout = NULL;

    Assert( pMarkup && pLayout );
    
    //
    // Check to see if this flow layout has additional flow layouts
    //
    if( pLayout->ContainsChildLayout() )
    {
        pSubLayout = pLayout->GetFirstLayout(&dwIterator);
        Assert( pSubLayout );

        //
        // Loop thru each of our children layout, invalidating
        // them recursively (all of our children flow layout need to
        // have the text selected bit turned on our off )
        // 
        while( pSubLayout )
        {
            InvalidateLayout( pSubLayout, pMarkup, fSelected );
            
            pSubLayout->SetSelected( fSelected, TRUE );

            pSubLayout = pLayout->GetNextLayout(&dwIterator);
        }

        pLayout->ClearLayoutIterator( dwIterator );
    }
}

//+============================================================================================
//
// Method:      CHighlightRenderingServices::InvalidateParentLayout
//
// Synopsis:    We need to invalidate the parent flow layout.  This is because the new selection
//              code has the parent flow layout paint the site as selected, and then the 
//              flow layout of the site paints on top of the selection.  When the site becomes
//              unselected partially, we need to notify the parent.
//
// Arguments:   pLayout = Base layout from which parent's should be updated
//              pStart = Start pos of base layout
//              pEnd = End pos of base layout
//              pMarkup = Base markup in which selection is being invalidated
//              fSelected = Is the layout being selected?
//              fEnclosed = Is the layout fully enclosed?
//
// Returns:     HRESULT indicating success
//---------------------------------------------------------------------------------------------
HRESULT CSelectionRenderingServiceProvider::InvalidateParentLayout( CLayout    *pLayout,
                                                                    CMarkup    *pMarkup,
                                                                    BOOL       fSelected )
{
    CLayout         *pParentLayout;
    CElement        *pLayoutOwner;
    CTreePos        *pStartPos;             // Starting treepos
    CTreePos        *pEndPos;               // Ending treepos
    HRESULT         hr=S_OK;
    
    Assert( pLayout && pMarkup);

    //
    // Get the parent layout, and the tree pos's for the layout
    // which needs to be invalidated
    //
    pParentLayout = pLayout->GetUpdatedParentLayout();
    pLayoutOwner = pLayout->ElementOwner();
    Assert( pLayoutOwner );

    if( !pLayoutOwner )
        goto Cleanup;

    pLayoutOwner->GetTreeExtent( &pStartPos, &pEndPos );
       
    Assert( pStartPos && pEndPos );
    
    if( !pStartPos || !pEndPos)
        goto Cleanup;
          
    //
    // Walk up the parent chain until we hit a flowlayout
    //
    while(  pParentLayout                                   && 
            !pParentLayout->IsFlowLayout()                  &&
            pParentLayout->GetContentMarkup() == pMarkup )
    {
        pParentLayout = pParentLayout->GetUpdatedParentLayout();            
    }


    //
    // If we found a flow layout, then we need to invalidate it
    //
    if( pParentLayout                   && 
        pParentLayout->IsFlowLayout()   && 
        pParentLayout->GetContentMarkup() == pMarkup )
    {
        //
        // Adjust the end to be in the parent's flow layout, so that 
        // ShowSelected is able to call RegionFromElement successfull.
        //

        pEndPos = pEndPos->NextTreePos();

        pParentLayout->ShowSelected(pStartPos, pEndPos, fSelected, FALSE /* fEnclosed */ );
    }

Cleanup:
    RRETURN(hr);
}


//+============================================================================================
//
// Method: UpdateSegment
//
// Synopsis: The Given Segment is about to be changed. Work out what needs to be invalidated
//           and tell the renderer about it.
//
//  Passing pIStart, and pIEnd == NULL, makes the given segment hilite ( used on AddSegment )
//
//---------------------------------------------------------------------------------------------

DeclareTag(tagDisplaySelectedSegment , "Selection", "Selection Show Update Segement")


//+====================================================================================
//
// Method: IsLayoutCompletelySelected
//
// Synopsis: Check to see if a layout is completely enclosed by a pair of treepos's
//
//------------------------------------------------------------------------------------


BOOL 
CSelectionRenderingServiceProvider::IsLayoutCompletelyEnclosed( 
                                                                CLayout* pLayout, 
                                                                CMarkupPointer* pStart, 
                                                                CMarkupPointer* pEnd )
{
    BOOL fCompletelyEnclosed = FALSE;
    int iWhereStart = 0;
    int iWhereEnd = 0;
    CMarkupPointer* pLayoutStart = NULL;
    CMarkupPointer* pLayoutEnd = NULL;
    HRESULT hr = S_OK;

    if ( !pStart || ! pEnd )
        return FALSE;

    if ( ! pLayout->ElementOwner()->GetFirstBranch() )
        return FALSE;

    Assert(pStart->Markup() == pEnd->Markup());
    if (pStart->Markup() != pEnd->Markup())
        return FALSE;
        
    //
    // Create two markup pointers, and move them before and after
    // our element in question
    //
    IFC( pStart->Doc()->CreateMarkupPointer( &pLayoutStart ) );        
    IFC( pEnd->Doc()->CreateMarkupPointer( & pLayoutEnd ) );
        
    IFC( pLayoutStart->MoveAdjacentToElement( pLayout->ElementOwner(), ELEM_ADJ_BeforeBegin) );
    IFC( pLayoutEnd->MoveAdjacentToElement( pLayout->ElementOwner(), ELEM_ADJ_AfterEnd ) );

    if ( pLayoutStart->Markup() != pStart->Markup() )
        goto Cleanup;
        
    iWhereStart = OldCompare( pStart, pLayoutStart );

    if ( pLayoutEnd->Markup() != pEnd->Markup() )
        goto Cleanup;
        
    iWhereEnd = OldCompare( pEnd, pLayoutStart );

    fCompletelyEnclosed = ( ( iWhereStart != LEFT ) && ( iWhereEnd != RIGHT ) ) ;
    if ( fCompletelyEnclosed )
    {
        iWhereStart = OldCompare( pStart, pLayoutEnd);
        iWhereEnd = OldCompare( pEnd, pLayoutEnd );
        fCompletelyEnclosed = ( ( iWhereStart != LEFT ) && ( iWhereEnd != RIGHT ) ) ;        
    }

Cleanup:
    ReleaseInterface( pLayoutStart );
    ReleaseInterface( pLayoutEnd );
    return fCompletelyEnclosed ;
}


HRESULT
CSelectionRenderingServiceProvider::UpdateSegment( CMarkupPointer* pOldStart, CMarkupPointer* pOldEnd, CMarkupPointer* pNewStart, CMarkupPointer* pNewEnd )
{
    int ssStart;
    int ssStop;
    BOOL fSame = FALSE;
    int compareStartEnd = SAME;
    HRESULT hr = S_OK;
    
    Assert(pNewStart && pNewEnd);
    Assert(pNewStart->Markup() == pNewEnd->Markup());
    if (pOldStart && pOldEnd)
    {
        Assert(pOldStart->Markup() == pOldEnd->Markup());
    }
    if (pNewStart->Markup() != pNewEnd->Markup())
    {
        return E_FAIL;
    }

    _fInUpdateSegment = TRUE;
    
    compareStartEnd = OldCompare( pNewStart, pNewEnd ) ;
    switch( compareStartEnd )
    {
        case LEFT:
        {
            CMarkupPointer* pTemp = pNewStart;
            pNewStart = pNewEnd;
            pNewEnd = pTemp;
        }
        break;

        case SAME:
        fSame = TRUE;
        break;
    }

    
    if ( !fSame && ( pOldStart != NULL ) && ( pOldEnd != NULL ) )
    {
        //
        // Initialize pOldStart, pOldEnd, pNewStart, pNewEnd, handling Start > End.
        //
        if ( OldCompare( pOldStart, pOldEnd ) == LEFT )
        {
            CMarkupPointer* pTemp2 = pOldStart;
            pOldStart = pOldEnd;
            pOldEnd = pTemp2;
        }

        
        if ( ( OldCompare( pOldStart, pNewEnd ) == LEFT ) ||  // New End is to the left
             ( OldCompare( pOldEnd, pNewStart) == RIGHT ) )   // New Start is to right
        {
            //
            // Segments do not overlap
            //   
            TraceTag( ( tagDisplaySelectedSegment, "Non Overlap") );
            if (OldCompare( pOldStart, pOldEnd ) != SAME)
            {
                IFC( InvalidateSegment( pOldStart, pOldEnd, pNewStart, pNewEnd , FALSE )); // hide old selection
            }
            if (OldCompare( pNewStart, pNewEnd ) != SAME)
            {
                IFC( InvalidateSegment( pNewStart, pNewEnd,  pNewStart, pNewEnd , TRUE ));
            }
        }
        else
        {
            ssStart = OldCompare( pOldStart, pNewStart) ;
            ssStop  = OldCompare( pOldEnd, pNewEnd );

            //
            // Note that what we invalidate is the Selection 'delta', ie that portion of the selection
            //  whose "highlightness" is now different. We don't turn on/off parts that havent' changed
            //
            switch( ssStart )
            {
                case RIGHT:
                    switch( ssStop )
                    {
                        //
                        //      S    NS     NE   E
                        //
                        case LEFT:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 1. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pOldStart, pNewStart,  pNewStart, pNewEnd ,FALSE )); // hide old selection
                            IFC( InvalidateSegment( pNewEnd, pOldEnd, pNewStart, pNewEnd , FALSE ));
                        }
                        break;
                        //
                        //      S    NS      E    NE
                        //
                        case RIGHT: 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 2. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pOldStart, pNewStart,pNewStart, pNewEnd ,FALSE ));
                            IFC( InvalidateSegment( pOldEnd, pNewEnd, pNewStart, pNewEnd, TRUE ));
                        }
                        break;
                        //
                        //      S    NS      E   
                        //                   NE
                        case SAME:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 3. ssStart:%d, ssEnd:%d", ssStart, ssStop ));                        
                            IFC( InvalidateSegment( pOldStart, pNewStart, pNewStart, pNewEnd , FALSE  ));
                        }
                        break;
                    }
                    break;
                    
                case LEFT : 
                    switch( ssStop )
                    {
                        //
                        //      NS  S   NE E
                        //
                        case LEFT:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 4. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pNewEnd , pOldEnd ,  pNewStart, pNewEnd , FALSE )); // hide old selection
                            IFC( InvalidateSegment( pNewStart, pOldStart, pNewStart, pNewEnd, TRUE  ));
                        }
                        break;
                        //
                        //     NS    S      E    NE
                        //
                        case RIGHT : 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 5. ssStart:%d, ssEnd:%d", ssStart, ssStop ));                            
                            IFC( InvalidateSegment( pNewStart, pOldStart, pNewStart, pNewEnd  , TRUE ));
                            IFC( InvalidateSegment( pOldEnd, pNewEnd, pNewStart, pNewEnd , TRUE  ));                                 
                        }
                        break;
                        
                       //
                       //      NS    S      E
                       //                   NE
                        case SAME:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 6. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pNewStart, pOldStart, pNewStart, pNewEnd , TRUE ));
                        }
                        break;
                    }
                    break;
                    
                default: // or same - which gives us less invalidation
                    switch( ssStop )
                    {
                        //
                        //      NS     NE E
                        //      S    
                        case LEFT:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 7. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pNewEnd , pOldEnd , pNewStart, pNewEnd , FALSE )); // hide old selection
                        }
                        break;
                        //
                        //      S         E    NE
                        //      NS
                        case RIGHT : 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 8. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pOldEnd, pNewEnd,  pNewStart, pNewEnd, TRUE  ));
                        }
                        break;

                        //
                        // For SAME case - we do nothing.
                        //
                        case SAME : 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 9. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                        }
                        break;
                    }
                    break;                    
            } 
        }
    }
    else
    {
        TraceTag(( tagDisplaySelectedSegment, "New Segment Invalidation"));

        if ( !fSame )
        {
            IFC( InvalidateSegment( pNewStart , pNewEnd ,  pNewStart, pNewEnd , TRUE ));        
        }            
        else if ( ( pOldStart != NULL ) && ( pOldEnd != NULL ) )
        {
            int iCompareOld = OldCompare( pOldStart, pOldEnd );
            if ( iCompareOld == LEFT )
            {
                CMarkupPointer* pTemp2 = pOldStart;
                pOldStart = pOldEnd;
                pOldEnd = pTemp2;
            }        
            if ( iCompareOld != SAME )
            {
                IFC( InvalidateSegment( pOldStart , pOldEnd ,  pNewStart, pNewEnd , FALSE ));   
            }                
        }
    }

    _fInUpdateSegment = FALSE;
    
Cleanup:
    RRETURN( hr );
}

//+==================================================================================
//
// Method: AddSegment
//
// Synopsis: Add a Selection Segment, at the position given by two MarkupPointers.
//           Expected that Segment Type is either SELECTION_RENDER_Selected or None
//
//-----------------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::AddSegment( 
    IDisplayPointer      *pDispStart, 
    IDisplayPointer      *pDispEnd,
    IHTMLRenderStyle    *pIRenderStyle,
    IHighlightSegment   **ppISegment )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      *pInternalStart = NULL;
    CMarkupPointer      *pInternalEnd = NULL;
    CHighlightSegment   *pSegment = NULL;
    POINTER_GRAVITY     eGravity = POINTER_GRAVITY_Left;    // need to initialize

    Assert( pDispStart && pDispEnd && pIRenderStyle );
    if ( ! _fSelectionVisible )
        _fSelectionVisible = TRUE;

    pInternalStart = new CMarkupPointer( _pDoc );
    if ( ! pInternalStart ) goto Error;
    pInternalStart->SetAlwaysEmbed( TRUE );
    
    pInternalEnd = new CMarkupPointer( _pDoc );
    if ( ! pInternalEnd ) goto Error;
    pInternalEnd->SetAlwaysEmbed( TRUE);


    // Copy the pointers for our internal data structure.
    // Copy over the position, and the gravity
    hr = pDispStart->PositionMarkupPointer(pInternalStart);
    if ( !hr ) hr = pDispStart->GetPointerGravity( &eGravity );
    if ( !hr ) hr = pInternalStart->SetGravity( eGravity );

    if ( !hr ) hr = pDispEnd ->PositionMarkupPointer(pInternalEnd);
    if ( !hr ) hr = pDispEnd->GetPointerGravity( &eGravity );
    if ( !hr ) hr = pInternalEnd->SetGravity( eGravity );

    if( FAILED(hr) )
        goto Cleanup;    

    Assert(pInternalStart->Markup() == pInternalEnd->Markup());
    if (pInternalStart->Markup() != pInternalEnd->Markup())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pSegment = new CHighlightSegment();
    if( !pSegment )
        goto Error;

    hr = pSegment->Init( pInternalStart, pInternalEnd, pIRenderStyle );
    if( FAILED(hr) )
        goto Cleanup;

    //
    // Check that we are in the same tree.
    //
#if DBG == 1
    Assert( pInternalStart->Markup() == _pMarkup );
    Assert( pInternalEnd->Markup() == _pMarkup );
    pInternalStart->SetDebugName( strSelectionStartName );
    pInternalEnd->SetDebugName( strSelectionEndName );
#endif

    // Add this segment, and get the IHighlightSegment for the caller
    IFC( PrivateAdd( pSegment ) );
    IFC( pSegment->QueryInterface( IID_IHighlightSegment, (void **)ppISegment) );
    
    // Invalidate CP cache.
    _lContentsVersion = INVALIDATE_VERSION;
    
    hr = THR( UpdateSegment( NULL, NULL, pInternalStart, pInternalEnd ));    
    
Cleanup:
    TraceTag( (tagValidateSelRenSv, "SelRen::Added Segment"));

    //
    // Release our ref's
    //
    ReleaseInterface( pInternalStart );
    ReleaseInterface( pInternalEnd );

    RRETURN( hr );

Error:
    return E_OUTOFMEMORY;
}

HRESULT 
CSelectionRenderingServiceProvider::MoveSegmentToPointers( 
    IHighlightSegment *pISegment,
    IDisplayPointer* pDispStart, 
    IDisplayPointer* pDispEnd)  
{
    HRESULT             hr = S_OK;
    CMarkupPointer      mpNewStart(_pDoc);
    CMarkupPointer      mpNewEnd(_pDoc);
    CMarkupPointer      *pOldStart = NULL;
    CMarkupPointer      *pOldEnd = NULL;
    CHighlightSegment   *pSegment = NULL;
    POINTER_GRAVITY     eGravity = POINTER_GRAVITY_Left;

    Assert( pISegment && pDispStart && pDispEnd);
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispStart->IsPositioned( & fPositioned ));
    Assert ( fPositioned );
    IGNORE_HR( pDispEnd->IsPositioned( & fPositioned ));
    Assert ( fPositioned );
    int cpStartNew =0;
    int cpEndNew = 0;
    int cchNewSel = 0;
    int cpStart = 0;
    int cpEnd = 0;
    int cchSel = 0;
#endif
  
    if ( ! _fSelectionVisible )
        _fSelectionVisible = TRUE;

    if ( !pISegment )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( PrivateLookup( pISegment, &pSegment ) );
  
#if DBG == 1
    IGNORE_HR( pDispStart->PositionMarkupPointer(&mpNewStart) );
    IGNORE_HR( pDispEnd->PositionMarkupPointer(&mpNewEnd) );

    Assert(mpNewStart.Markup() == mpNewEnd.Markup());
    if (mpNewStart.Markup() != mpNewEnd.Markup())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if ( IsTagEnabled( tagValidateSelRenSv))
    {
        cpStartNew = mpNewStart.GetCp();
        cpEndNew= mpNewEnd.GetCp();
        cchNewSel = abs( cpStartNew - cpEndNew );
        cpStart = pSegment->GetStart()->GetCp();
        cpEnd = pSegment->GetEnd()->GetCp();
        cchSel = abs( cpStart - cpEnd );
        TraceTag(( tagValidateSelRenSv, "Selection - Old Start:%d End:%d Size:%d New Start:%d End:%d Size:%d\n", 
                cpStart, cpEnd, cchSel, cpStartNew, cpEndNew, cchNewSel ));
        _cchLast = cchSel;
    }
#endif

    //
    // Move Old Pointers to start and end.
    //
    IFC( _pDoc->CreateMarkupPointer( & pOldStart ));
    IFC( _pDoc->CreateMarkupPointer( & pOldEnd ));
    IFC( pOldStart->MoveToPointer( pSegment->GetStart() ));
    IFC( pOldEnd->MoveToPointer( pSegment->GetEnd() ));

    Assert(pOldStart->Markup() == pOldEnd->Markup());
    
    IFC( pDispStart->PositionMarkupPointer(pSegment->GetStart()) );
    IFC( pDispEnd->PositionMarkupPointer(pSegment->GetEnd()) );

    // Set the new markup
    pSegment->SetMarkup( pSegment->GetStart()->Markup() );
    
    //
    // Copy Gravity on pointers.
    //
    IFC( pDispStart->GetPointerGravity ( & eGravity));
    IFC( pSegment->GetStart()->SetGravity( eGravity ));
    IFC( pDispEnd->GetPointerGravity ( & eGravity));
    IFC( pSegment->GetEnd()->SetGravity( eGravity ));

    //
    // TODO (track bug 4354) - rewrite Update Segment sometime - so it doesn't need to take
    // CMarkupPointers as parameters for the old selection boundarys (perf).
    //
    IFC( UpdateSegment( pOldStart, pOldEnd,  pSegment->GetStart(), pSegment->GetEnd() ) );
   
    _lContentsVersion = INVALIDATE_VERSION; // Invalidate CP cache.

    //
    // While processing this - we got an Invalidate call, which is invalid (as we had'nt 
    // updated our selection as yet.
    //
    if ( _fPendingInvalidate )
    {
        InvalidateSelection( TRUE );
        _fPendingInvalidate = FALSE;
    }

Cleanup:
    if ( pOldStart ) pOldStart->Release();
    if ( pOldEnd ) pOldEnd->Release();
  
    RRETURN( hr );
}    
    
//+===================================================================================
//
// Method: ClearSegments
//
// Synopsis: Empty ( remove all ) selection segments. ( ie nothing is selected )
//
//-----------------------------------------------------------------------------------

HRESULT
CSelectionRenderingServiceProvider::ClearSegments(BOOL fInvalidate /* = FALSE */)
{
    TraceTag( (tagValidateSelRenSv, "SelRen::ClearSegs" ));

    while( !IsEmpty() )
    {
        PrivateClearSegment( _pFirst, fInvalidate );
    }
    
    return S_OK;
}

HRESULT
CSelectionRenderingServiceProvider::RemoveSegment(IHighlightSegment *pISegment)
{
    return PrivateClearSegment(pISegment, TRUE);
}    

HRESULT
CSelectionRenderingServiceProvider::PrivateClearSegment(IHighlightSegment *pISegment, 
                                                        BOOL fInvalidate)
{
    CHighlightSegment   *pSegment = NULL;
    HRESULT             hr = E_INVALIDARG;

    Assert( pISegment );

    if( pISegment )
    {

        IFC( PrivateLookup( pISegment, &pSegment ) );
   
        if ( fInvalidate && _pDoc->_pInPlace )
        {
            CMarkupPointer *pStart = pSegment->GetStart();
            CMarkupPointer *pEnd = pSegment->GetEnd();

            Assert(pStart->Markup() == pEnd->Markup());
            
            if (pStart && pEnd &&
                pStart->Markup() == pEnd->Markup())
            {
                int wherePointer = OldCompare( pStart, pEnd );

                switch( wherePointer )
                {
                    case RIGHT:
                        InvalidateSegment( pStart, pEnd, NULL, NULL , FALSE);
                        break;

                    case LEFT:
                        InvalidateSegment( pEnd, pStart, NULL, NULL, FALSE);
                        break;
                }
            }
        }

        IFC( PrivateRemove( pSegment ) );
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}
   
//+===============================================================================
//
// Method: ConstructSelectionRenderCache
//
// Synopsis: This method is called by the renderer at the start of a paint,
//
//             As it is expected that the work involved in "chunkifying" the selection
//             will be expensive. So this work is done once per render.
//
//             As each flow layout is rendered, the Renderer calls GetSelectionChunksForLayout,
//             which essentially returns part of the array built on this call.
// 
// Build an array of FlowLayoutChunks. A "chunk" is a FlowLayout, and pair of 
// cps within that FlowLayout that are selected. Hence Selections that span multiple
// layouts are broken up by this routine into separate chunks for the renderer.
// 
//--------------------------------------------------------------------------------

VOID 
CSelectionRenderingServiceProvider::ConstructSelectionRenderCache()
{
    CHighlightSegment *pSegment = NULL;
    int start, end;

    //
    // We only need to recompute CP's if our version nos' are different.
    //
    Assert(_pMarkup && _pMarkup->GetMarkupContentsVersion() != _lContentsVersion);

    pSegment = _pFirst;

    while( pSegment != NULL )
    {       
        start = pSegment->GetStart()->GetCp();
        end = pSegment->GetEnd()->GetCp(); 

        //
        // Make sure we are embedded.
        //
        Assert( pSegment->GetStart()->GetEmbeddedTreePos() != NULL );
        Assert( pSegment->GetEnd()->GetEmbeddedTreePos() != NULL );

        if ( start > end )
        {
            pSegment->SetStartCP(end); 
            pSegment->SetEndCP(start);
        }
        else
        {
            pSegment->SetStartCP(start);
            pSegment->SetEndCP(end);
        }

        pSegment = pSegment->GetNext();
    }

    //
    // marka - take this call out for now - we will try to use _lContentsVersion
    // to figure out when we need to reconstruct the cache.
    //
#ifdef NEVER
    WHEN_DBG( _fInPaint = TRUE; )    
#endif    
}
//+====================================================================================
//
// Method: HideSelection
//
// Synopsis: Selection is to be hidden. Anticipated use is switching focus to another window
//
//------------------------------------------------------------------------------------

VOID
CSelectionRenderingServiceProvider::HideSelection()
{
    _fSelectionVisible = FALSE; 
    if ( _pDoc->GetView()->IsActive() )
    {
        InvalidateSelection( FALSE );
    }        
}

//+====================================================================================
//
// Method: ShowSelection
//
// Synopsis: Selection is to be shown. Anticipated use is gaining focus from another window
//
//------------------------------------------------------------------------------------
VOID
CSelectionRenderingServiceProvider::ShowSelection()
{
    _fSelectionVisible = TRUE;

    InvalidateSelection( TRUE );            
}

VOID
CSelectionRenderingServiceProvider::OnRenderStyleChange( CNotification * pnf )
{
    const int LEFT = 1;   
    const int RIGHT = -1;
    const int SAME = 0;
    IHTMLRenderStyle *pIRenderStyle=NULL;
    CHighlightSegment *pSegment = GetFirst();
    int wherePointer;
    IUnknown* pUnkRenderStyle = NULL;
    IUnknown* pUnk = NULL;
    HRESULT hr;

    IFC( ((IHTMLRenderStyle*) pnf->DataAsPtr())->QueryInterface( IID_IUnknown, ( void**) & pUnkRenderStyle ));
    
    for( ; pSegment; pSegment = pSegment->GetNext() )
    {
        wherePointer = SAME;
        pSegment->GetType(&pIRenderStyle);
        IFC( pIRenderStyle->QueryInterface( IID_IUnknown, ( void**) & pUnk ));
        
        if( pUnk == pUnkRenderStyle )
        {
            wherePointer = OldCompare( pSegment->GetStart(), pSegment->GetEnd() );
            switch( wherePointer )
            {
            case RIGHT:
                InvalidateSegment( 
                                   pSegment->GetStart(), pSegment->GetEnd(),
                                   pSegment->GetStart(), pSegment->GetEnd(), TRUE );
                break;

            case LEFT:
                InvalidateSegment( 
                                   pSegment->GetEnd(), pSegment->GetStart(),
                                   pSegment->GetEnd(), pSegment->GetStart(), TRUE );
                break;
            }

        }
        ClearInterface(&pUnk );
        ClearInterface(&pIRenderStyle);
    }
Cleanup:    
    ReleaseInterface( pUnkRenderStyle );
    ReleaseInterface( pUnk );
    ReleaseInterface( pIRenderStyle );    
}

//+====================================================================================
//
// Method: InvalidateSelection
//
// Synopsis: Invalidate the Selection
//
//------------------------------------------------------------------------------------

VOID
CSelectionRenderingServiceProvider::InvalidateSelection( BOOL fSelectionOn )
{
    CHighlightSegment *pSegment = NULL;
    int wherePointer = SAME;

    if ( _fInUpdateSegment )
    {
        _fPendingInvalidate = TRUE;
        return;
    }        

    pSegment = _pFirst;
    
    while( pSegment != NULL )
    {
        Assert(pSegment->GetStart()->Markup() == pSegment->GetEnd()->Markup());
        wherePointer = OldCompare( pSegment->GetStart(), pSegment->GetEnd() );

        switch( wherePointer )
        {
            case RIGHT:
                //
                // We really want to emulate PrivateClearSegment() here.  When we 
                // are clearing seleciton, the arguements to InvalidateSegment
                // are pretty important.  We need to set pNewStart and pNewEnd to NULL
                //
                InvalidateSegment(  pSegment->GetStart(), pSegment->GetEnd(),
                                    fSelectionOn ? pSegment->GetStart() : NULL,
                                    fSelectionOn ? pSegment->GetEnd() : NULL,
                                    fSelectionOn );
                break;

            case LEFT:
                InvalidateSegment(  pSegment->GetEnd(), pSegment->GetStart(),
                                    fSelectionOn ? pSegment->GetEnd() : NULL,
                                    fSelectionOn ? pSegment->GetStart() : NULL,               
                                    fSelectionOn );
                break;
        }

        pSegment = pSegment->GetNext();
    } 
}          


//+==============================================================================
// 
// Method: GetSelectionChunksForLayout
//
// Synopsis: Get the 'chunks" for a given Flow Layout, as well as the Max and Min Cp's of the chunks
//              
//            A 'chunk' is a part of a SelectionSegment, broken by FlowLayout
//
//-------------------------------------------------------------------------------
VOID
CSelectionRenderingServiceProvider::GetSelectionChunksForLayout( 
    CFlowLayout* pFlowLayout, 
    CRenderInfo *pRI,
    CDataAry<HighlightSegment> *paryHighlight, 
    int* piCpMin, 
    int * piCpMax )
{
    int cpMin = LONG_MAX;  // using min() macro on this will always give a smaller number.
    int cpMax = - 1;
    int segmentStart, segmentEnd ;    
    long cpFlowStart = pFlowLayout->GetContentFirstCp();
    long cpFlowEnd = pFlowLayout->GetContentLastCp();
    long cp;
    int chunkStart = -1;
    int chunkEnd = -1;
    int ili;
    HighlightSegment *pNewSegment;
    const int iInitSizeMax = 2000;
    RECT rcView;
    enum SELEDGE
    {
        SE_INSIDE, SE_OUTSIDE
    };
    SELEDGE ssSelStart;
    SELEDGE ssSelEnd;   
    const INT iIntersectWithViewThreshold = 30; // TODO: tune this number
    const CDisplay *pdp = pRI->_pdp;
    int iliViewStart = pRI->_iliStart;
    long cpViewStart = pRI->_cpStart;
    
    Assert( paryHighlight->Size() == 0 );

    CHighlightSegment *pSegment = NULL;

    if( !IsEmpty() && _fSelectionVisible && !pFlowLayout->_fTextSelected )
    {
        Assert(_pMarkup);
        if ( _pMarkup->GetMarkupContentsVersion() != _lContentsVersion  )
        {
            ConstructSelectionRenderCache();
            _lContentsVersion = _pMarkup->GetMarkupContentsVersion();
        }
        
        paryHighlight->EnsureSize(min(iInitSizeMax, _nSize));

        // Only intersect with the view if there are enough segments to make the call to 
        // LineFromPos worthwhile
        //
        
        if( _nSize  > iIntersectWithViewThreshold )
        {
            //
            // Intersect cpFlowStart view start
            //

            rcView = pRI->_pDI->_rcClip;

            if (cpViewStart < 0 || iliViewStart < 0)
            {
                iliViewStart = pdp->LineFromPos(rcView, NULL, &cpViewStart, 0, -1, -1);
            }

            cpFlowStart = max(cpViewStart, cpFlowStart);

            //
            // Intersect cpFlowEnd view end
            //
            
            // Because rcView.top might be positioned in the middle of the line
            // we need to add the offset from the begining of the line to the rcView.top.
            Assert(iliViewStart >= 0);
            CLineCore * pliViewStart = pdp->Elem(iliViewStart);
            CLineOtherInfo * ploiViewStart = pliViewStart->oi();

            rcView.bottom -= pliViewStart->GetYTop(ploiViewStart);
            rcView.top = 0;

            ili = pdp->LineFromPos(rcView, NULL, &cp, CDisplay::LFP_INTERSECTBOTTOM, iliViewStart, -1);

            cp += pdp->Elem(ili)->_cch;
        
            cpFlowEnd = min(cp, cpFlowEnd);        
        }
        else if (cpViewStart >= 0)
        {
            // If we have cpViewStart passed, we should intersect with cpFlowStart
            cpFlowStart = max(cpViewStart, cpFlowStart);
        }

        //
        // Create segments
        //
        pSegment = _pFirst;

        while( pSegment != NULL )
        {
            segmentStart = pSegment->GetStartCP();
            segmentEnd = pSegment->GetEndCP(); 

            if( !( (segmentEnd <= cpFlowStart) || (cpFlowEnd <= segmentStart)) )
            {                
                ssSelStart = segmentStart  <= cpFlowStart  ? SE_OUTSIDE : SE_INSIDE;
                ssSelEnd  = segmentEnd >= cpFlowEnd ? SE_OUTSIDE : SE_INSIDE;

                switch (ssSelStart)
                {
                case SE_OUTSIDE:
                {
                    switch (ssSelEnd)
                    {
                    case SE_OUTSIDE:
                        //
                        // Selection completely encloses layout
                        //
                        chunkStart = cpFlowStart;
                        chunkEnd = cpFlowEnd;
                        break;
                    
                    case SE_INSIDE:
                        //
                        // Overlap with selection ending inside
                        //
                        chunkStart = cpFlowStart;
                        chunkEnd = segmentEnd ;                 
                        break;
                    }
                    break;
                }
                case SE_INSIDE:
                {
                    switch( ssSelEnd )
                    {
                    case SE_OUTSIDE:
                        //
                        // Overlap with selection ending outside
                        //
                        chunkStart = segmentStart;
                        chunkEnd = cpFlowEnd;
                        break;
                    
                    case SE_INSIDE:
                        //
                        // Layout completely encloses selection
                        //
                        chunkStart = segmentStart;
                        chunkEnd = segmentEnd  ;                 
                        break;
                    }
                    break;
                }
                }
                if (( chunkStart != -1 ) && ( chunkEnd != -1))
                {
                    //
                    // Insertion Sort on The Array we've been given.
                    //
                    pNewSegment = paryHighlight->Append();

                    pNewSegment->_cpStart = chunkStart;
                    pNewSegment->_cpEnd = chunkEnd;
                    pNewSegment->_pRenderStyle = pSegment->GetType();
                                        
                    cpMin = min ( chunkStart, cpMin );
                    cpMax = max ( chunkEnd, cpMax );
                    
                    chunkStart = -1;
                    chunkEnd = -1;
                }
            }

            pSegment = pSegment->GetNext();
        }
    }
    if ( piCpMin )
        *piCpMin = cpMin;
    if ( piCpMax )
        *piCpMax = cpMax;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionRenderingServiceProvider::PrivateAdd
//
//  Synopsis:   Adds a segment to the linked list
//
//  Arguments:  pSegment = Segment to add
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::PrivateAdd( CHighlightSegment *pSegment )
{
    Assert( pSegment );
    Assert( pSegment->GetStart() && pSegment->GetEnd() );
    Assert( pSegment->GetStart()->Markup() == pSegment->GetEnd()->Markup() );

    if( IsEmpty() )
    {
        // Handle the case when this is the
        // first element
        _pFirst = pSegment;
        _pLast = pSegment;
        _pFirst->SetNext(NULL);
        _pFirst->SetPrev(NULL);
    }
    else
    {
        // Append this element
        pSegment->SetNext(NULL);
        pSegment->SetPrev(_pLast);
        _pLast->SetNext(pSegment);
        _pLast = pSegment;   
    }

    _nSize++;

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionRenderingServiceProvider::PrivateLookup
//
//  Synopsis:   Given an ISegment, this function will find the underlying
//              CSegment.
//
//  Arguments:  pISegment = ISegment to retreive CHighlightSegment for
//              ppSegment = Returned CHighlightSegment pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::PrivateLookup( IHighlightSegment *pISegment, CHighlightSegment **ppSegment )
{  
    HRESULT hr = S_OK;
    
    Assert( pISegment && ppSegment );

    // Query for the CSegment
    IFC( pISegment->QueryInterface(CLSID_CHighlightSegment, (void **)ppSegment));

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionRenderingServiceProvider::PrivateRemove
//
//  Synopsis:   Removes a CHighlightSegment from the list
//
//  Arguments:  pSegment = CHighlightSegment to remove
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::PrivateRemove( CHighlightSegment *pSegment )
{  
    CHighlightSegment    *pNext = NULL;
    CHighlightSegment    *pPrev = NULL;

    pPrev = pSegment->GetPrev();
    pNext = pSegment->GetNext();

    Assert( pSegment );
    Assert( pSegment->GetStart()->Markup() == pSegment->GetEnd()->Markup() );

    // Item certainly isn't in our list, and it looks like it
    // should be in our list, tell our client
    if( ( (_pFirst == _pLast) && (pSegment != _pFirst) ) || 
        ( (_pFirst != _pLast) && (pPrev == NULL) && (pNext == NULL) ) )
    {
        return S_FALSE;
    }

    if( _pFirst == _pLast )
    {
        _pFirst = NULL;
        _pLast = NULL;
    }
    else if( pSegment == _pFirst )
    {
        // Removing first element
        _pFirst = pSegment->GetNext();
        _pFirst->SetPrev(NULL);
    }
    else if( pSegment == _pLast )
    {
        // Removing last element
        _pLast = pSegment->GetPrev();
        _pLast->SetNext(NULL);
    }
    else
    {
        // Should be somewhere in the middle of the list
        Assert( pSegment->GetNext() );
        Assert( pSegment->GetPrev() );

        pPrev->SetNext(pNext);
        pNext->SetPrev(pPrev);
    }

    pSegment->SetNext(NULL);
    pSegment->SetPrev(NULL);
    
    // Clean up the CHighlightSegment object
    ReleaseInterface(pSegment);

    _nSize--;
    
    RRETURN(S_OK);
}

//-----------------------------------------------------------------------------
//
//  Function:   CHighlightSegment::CHighlightSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CHighlightSegment::CHighlightSegment()
{
    _pIRenderStyle = NULL;
    _ulRefs = 1;
    _fInitialized = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::~CHighlightSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CHighlightSegment::~CHighlightSegment(void)
{
    ReleaseInterface(_pIRenderStyle );

    _pMarkup->Release();
    
    //
    // Unposition the pointers
    //
    _pStart->Unposition();
    _pEnd->Unposition();

    //
    // Release our ref
    //
    ReleaseInterface( _pStart );
    ReleaseInterface( _pEnd );
      
#if DBG == 1
    // Verify that no other elements in the list are 
    // referencing this object
    if( GetPrev() )
        Assert( GetPrev()->GetNext() != this );

    if( GetNext() )
        Assert( GetNext()->GetPrev() != this );
#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::Init
//
//  Synopsis:   Initializes a highlight segment
//
//  Arguments:  pStart = Starting position of segment
//              pEnd = Ending position of segment
//              pRenderStyle = Style highlight segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::Init(CMarkupPointer *pStart, 
                        CMarkupPointer *pEnd,
                        IHTMLRenderStyle *pIRenderStyle )
{
    Assert( pStart && pEnd );
    Assert( pStart->Markup() == pEnd->Markup() );

    _pStart = pStart;
    _pStart->AddRef();

    _pEnd = pEnd;
    _pEnd->AddRef();

    ReplaceInterface( &_pIRenderStyle, pIRenderStyle );

    //
    // Add-ref the markup (we need to guarantee it will be around to destroy us)
    //
    _pMarkup = _pStart->Markup();
    _pMarkup->AddRef();
    
    _fInitialized = TRUE;
    
    RRETURN(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::SetType
//
//  Synopsis:   Sets the highlight type of selection, without adjusting 
//              the pointers
//
//  Arguments:  eType = New highlight type
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::SetType( IHTMLRenderStyle *pIRenderStyle )
{
    ReplaceInterface( & _pIRenderStyle , pIRenderStyle );
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::GetType
//
//  Synopsis:   Retrieves the type of highlight
//              
//  Arguments:  peType = Output pointer to receive type
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::GetType( IHTMLRenderStyle **ppIRenderStyle )
{
    Assert( ppIRenderStyle );

    *ppIRenderStyle = _pIRenderStyle;
    _pIRenderStyle->AddRef();

    return S_OK;
}

CRenderStyle *
CHighlightSegment::GetType(void)
{ 
    CRenderStyle *pRenderStyle = NULL;
    _pIRenderStyle->QueryInterface( CLSID_HTMLRenderStyle, (void **)&pRenderStyle);
    return pRenderStyle; 
}

void
CHighlightSegment::SetMarkup(CMarkup *pMarkup)
{
    Assert( pMarkup );

    _pMarkup->Release();

    _pMarkup = pMarkup;
    _pMarkup->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the beginning and end of the
//              current segment, respectively
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::GetPointers( IMarkupPointer *pIStart,
                                IMarkupPointer*pIEnd )
{
    HRESULT hr = E_INVALIDARG;
    BOOL    fResult = FALSE;
    
    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {       
        hr = THR( _pStart->IsLeftOfOrEqualTo( _pEnd, &fResult ) );
        if( hr )
            goto Cleanup;

        //
        // Swap pointers if they're out of order.
        //
        if( fResult == TRUE )
        {
            hr = pIStart->MoveToPointer( _pStart );
            if (!hr) hr = pIEnd->MoveToPointer( _pEnd );
        }
        else
        {
            hr = pIStart->MoveToPointer( _pEnd );
            if (!hr) hr = pIEnd->MoveToPointer( _pStart );
        }
        
        //
        // copy gravity - important for commands
        //
        if ( !hr ) hr = pIStart->SetGravity( POINTER_GRAVITY_Right );
        if ( !hr ) hr = pIEnd->SetGravity( POINTER_GRAVITY_Left );
    }        

Cleanup:
#if DBG == 1
    if( hr == S_OK )
    {
        BOOL fPositionedStart = FALSE;
        BOOL fPositionedEnd = FALSE;

        IGNORE_HR( pIStart->IsPositioned( & fPositionedStart ));
        IGNORE_HR( pIEnd->IsPositioned( & fPositionedEnd ));

        Assert( fPositionedStart && fPositionedEnd );
    }        
#endif

    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CHighlightSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegment )
    {
        *ppvObj = (ISegment *)((IHighlightSegment *)this);
    }
    else if( iid == IID_IHighlightSegment )
    {
        *ppvObj = (IHighlightSegment *)this;
    }
    else if( iid == CLSID_CHighlightSegment )
    {
        *ppvObj = this;
        return S_OK;
    }   
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

#if DBG == 1 

MtDefine(CTxtEdit_aryChunkTest_pv, Utilities , "TestSelectionRenderServices::_aryChunkTest::_pv")

void TestSelectionRenderServices( CMarkup* pMarkup , CElement* pTestElement)
{
    // NOTE - t-mbodel - Sept 10, 1999
    // We need to eventually make the notify call here a default property
    // of all of the put_ functions.  Unfortuately they are all currently
    // generated by pdl magic.
    // When this is fixed should take out the changes in formkrnl.cxx, 
    // formkrnl.hxx that make reference to TestSelectionRenderServices.

    CDocument *pDoc = pMarkup->Document();
    IHTMLRenderStyle    *pIRenderStyle = NULL;
    VARIANT             vtColorValue;
    CNotification       nf;

    VariantInit(& vtColorValue );
    V_VT( & vtColorValue ) = VT_I4;
    V_I4( & vtColorValue ) = 0x00ff00;

    pDoc->createRenderStyle( NULL, &pIRenderStyle );
    pIRenderStyle->put_textBackgroundColor(vtColorValue);
    VariantClear(& vtColorValue );
    
    pIRenderStyle->put_defaultTextSelection(SysAllocString(_T("false")));
    nf.MarkupRenderStyle( 0, 0, pIRenderStyle, 0);
    pMarkup->Notify(&nf);

    pMarkup->DumpTree();

    ReleaseInterface( pIRenderStyle );
   //
    // NOTE - this is just a test. Note that this WILL LEAK MEMORY.
    //
#ifdef NEVER
    CDoc* pDoc = ped->Doc();
    CMarkupPointer* pStart = new CMarkupPointer( pDoc );
    CMarkupPointer* pEnd = new CMarkupPointer( pDoc );
    int firstSelCp, lastSelCp, firstCp, firstFlow, lastFlow;
    IMarkupPointer* pIStart = NULL ;
    IMarkupPointer* pIEnd = NULL ;
    IHTMLElement* pElement = NULL;
    IHTMLElement* pNewElement = NULL;
    IHTMLElement* pNewElement2 = NULL;
    IMarkupServices* pTreeServices = NULL;
    LONG pch = 0;
    
    IHighlightRenderingServices* pIHighlightRenderSvcs = NULL;
    int iSelectionIndex = -1;

    THR(pTestElement->QueryInterface( IID_IHTMLElement, ( void**) & pElement ));
    THR(pStart->QueryInterface( IID_IMarkupPointer, (void * *) & pIStart ) );
    THR( pIStart->SetGravity( POINTER_GRAVITY_Left ));
    THR(pEnd->QueryInterface( IID_IMarkupPointer, (void * *) & pIEnd ) );
//
// Test Select All
//
    /*THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ));
    THR( pMarkup->QueryInterface( IID_IHighlightRenderingServices, ( void**) & pIHighlightRenderSvcs ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));
    */

    //
    // Test Multiple selection.
    //
    //
    // Segment 1 from 0 to 30.

    THR( pMarkup->QueryInterface( IID_IHighlightRenderingServices, ( void**) & pIHighlightRenderSvcs ));

    //
    // Test Case 1 Non-Overlapped Segments.
    //
    THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    pch = 9;
    firstCp = pStart->TreePos()->GetCp(FALSE);
    BSTR testString = SysAllocString(_T("                "));
    THR( pIStart->Right(TRUE, NULL, NULL, &pch, testString ));
   
    firstSelCp = pStart->TreePos()->GetCp(FALSE);
    
    pch = 19;
    THR( pIEnd->Right(TRUE, NULL, NULL, &pch, testString ));
    lastSelCp = pEnd->TreePos()->GetCp( FALSE);
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));

    CFlowLayout *pFLayout = pTestElement->GetFlowLayout();
    firstFlow = pFLayout->GetFirstCp();
    lastFlow = pFLayout->GetLastCp();
/*
    THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    pch = 32;
    THR( pIStart->Right(TRUE, NULL, NULL, &pch, NULL ));
    pch = 41;
    THR( pIEnd->Right(TRUE, NULL, NULL, &pch, NULL ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));
*/
    //
    // TestCaseII Overlapped Segments.
    //
  /*  THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    pch = 29;
    THR( pIStart->Right(TRUE, NULL, NULL, &pch, NULL ));
    pch = 31;
    THR( pIEnd->Right(TRUE, NULL, NULL, &pch, NULL ));
    THR( pMarkup->QueryInterface( IID_IHighlightRenderingServices, ( void**) & pIHighlightRenderSvcs ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));*/

    //Segment 2 10 to 20
/*     pch = 10;
    THR( pIStart->Right( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIEnd->Left( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));

    // Segment 3 110 to 120
    pch = 100;
    THR( pIStart->Right( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIEnd->Right( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex )); */
/*    THR( pDoc->QueryInterface( IID_IHTMLTreeServices, ( void**) & pTreeServices ));
    THR( pTreeServices->CreateElement( TAGID_INPUT, NULL, & pNewElement ));
    THR( pTreeServices->InsertElement( pNewElement, pIStart, pIStart ));
    THR( pTreeServices->CreateElement( TAGID_INPUT, NULL, &pNewElement2 ));
    THR( pTreeServices->InsertElement( pNewElement2, pIEnd, pIEnd ));*/


    //THR( pIHighlightRenderSvcs->AddElementSegment( pElement, &iSelectionIndex  ));

 /*   pMarkup->ConstructSelectionRenderCache();
    CStackDataAry<int, 10> aryChunkCp(Mt( CTxtEdit_aryChunkTest_pv ) );
    CStackDataAry<int, 10> aryChunkCCh(Mt( CTxtEdit_aryChunkTest_pv ) );
    int cpMax = 0;
    int cpMin = 0;

    pMarkup->GetSelectionChunksForLayout( pMarkup->Root()->GetFlowLayout(), &aryChunkCp, &aryChunkCCh, &cpMin, &cpMax );
    aryChunkCp.DeleteAll();
    aryChunkCCh.DeleteAll();
    CElement* pNewElementClass = NULL;
    THR( pNewElement->QueryInterface( CLSID_CElement,  ( void**) & pNewElementClass ));

    CFlowLayout* pNewLayout = pNewElementClass->GetFlowLayout();
    pMarkup->GetSelectionChunksForLayout( pNewLayout, &aryChunkCp, &aryChunkCCh, &cpMin,  &cpMax );
    pMarkup->InvalidateSelectionRenderCache();

    pMarkup->InvalidateSelectionRenderCache();*/

    ReleaseInterface( pIStart );
    ReleaseInterface( pIEnd );
    ReleaseInterface( pElement );
    ReleaseInterface( pNewElement );
    ReleaseInterface( pNewElement2 );
    ReleaseInterface( pIHighlightRenderSvcs );

    pStart->Release();
    pEnd->Release();

#endif // NEVER
}

void
CSelectionRenderingServiceProvider::DumpSegments()
{
    CHighlightSegment *pSegment = NULL;
    int i = 0;
    
    if( !IsEmpty() )
    {
        pSegment = _pFirst;

        while( pSegment != NULL )
        {
            char buf[256];

            wsprintfA(buf, "%3d : cp=(%d,%d) sn=(%d,%d) type=%d\r\n",
                      i++,
                      pSegment->GetStartCP(),
                      pSegment->GetEndCP(),
                      pSegment->GetStart()->SN(),
                      pSegment->GetEnd()->SN(),
                      pSegment->GetType() );

            OutputDebugStringA( buf );
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\tpointer.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TOMCONST_H_
#define X_TOMCONST_H_
#include "tomconst.h"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

DeclareTagOther(tagMarkupPointerAlwaysEmbed, "MarkupPointer", "Force embedding of all markup pointers");

MtDefine(CMarkupPointer, Tree, "CMarkupPointer");

#if DBG == 1 || defined(DUMPTREE)
int CMarkupPointer::s_NextSerialNumber = 1;
#endif

#if DBG == 1

void
SetDebugName ( IMarkupPointer * pIPointer, LPCTSTR strDbgName )
{
    CMarkupPointer * pPointer;

    IGNORE_HR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointer ) );

    pPointer->SetDebugName( strDbgName );
}

#endif


inline BOOL
IsValidGravity ( POINTER_GRAVITY eGravity )
{
    return eGravity == POINTER_GRAVITY_Left || eGravity == POINTER_GRAVITY_Right;
}

inline BOOL
IsValidAdjacency ( ELEMENT_ADJACENCY eAdj )
{
    return
        eAdj == ELEM_ADJ_BeforeBegin || eAdj == ELEM_ADJ_AfterBegin ||
        eAdj == ELEM_ADJ_BeforeEnd   || eAdj == ELEM_ADJ_AfterEnd;
}

void
EnsureLogicalOrder ( CMarkupPointer * & pStart, CMarkupPointer * & pFinish )
{
    Assert( pStart && pFinish );
    Assert( pStart->IsPositioned() && pFinish->IsPositioned() );
    Assert( pStart->Markup() == pFinish->Markup() );

    if (pStart->IsRightOf( pFinish ) )
    {
        CMarkupPointer * pTemp = pStart;
        pStart = pFinish;
        pFinish = pTemp;
    }
}

void
EnsureTotalOrder ( CTreePosGap * & ptpgStart, CTreePosGap * & ptpgFinish )
{
    CTreePos * ptpStart = ptpgStart->AdjacentTreePos( TPG_RIGHT );
    CTreePos * ptpFinish = ptpgFinish->AdjacentTreePos( TPG_RIGHT );
    
    Assert( ptpStart->GetCp() <= ptpFinish->GetCp() );

    if (ptpStart == ptpFinish)
        return;

    //
    // Move the finish as far to the right as possible without going over any content,
    // looking for the start.  If we find the start, then they are not ordered properly.
    //

    while ( ptpFinish->IsPointer() || ptpFinish->IsText() && ptpFinish->Cch() == 0 )
    {
        ptpFinish = ptpFinish->NextTreePos();

        if (ptpFinish == ptpStart)
        {
            CTreePosGap * ptpgTemp = ptpgStart;
            ptpgStart = ptpgFinish;
            ptpgFinish = ptpgTemp;

            return;
        }
    }
}

#if DBG == 1

CMarkupPointer::CMarkupPointer ( CDoc * pDoc )
  : _pDoc( pDoc ), _pMarkup( NULL ),
    _pmpNext( NULL ), _pmpPrev( NULL ),
    _fRightGravity( FALSE ), _fCling( FALSE ),
    _fEmbedded( FALSE ),
    _fKeepMarkupAlive( FALSE ), _fAlwaysEmbed( FALSE ),
    _ptpRef( NULL ), _ichRef( 0 ),
    _verCp( 0 ), _cpCache( -1 ),
    _nSerialNumber( s_NextSerialNumber++ )
{
}

void
CMarkupPointer::Validate ( ) const
{
    static BOOL fValidating = FALSE;

    if (fValidating)
        return;
            
    if (!IsPositioned())
    {
        Assert( _pmpNext == NULL );
        Assert( _pmpPrev == NULL );
        Assert( ! _fEmbedded );
        Assert( _cpCache == -1 );
        Assert( _verCp == 0 );
        Assert( _ptp == NULL );
        Assert( _ichRef == 0 );

        return;
    }

    Assert( ! _fAlwaysEmbed || _fEmbedded );

    static BOOL fValidatingAll = FALSE;
        
    if (IsPositioned() && !fValidatingAll)
    {
        fValidatingAll = TRUE;
        
        for ( CMarkupPointer * pmp = Markup()->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            if (pmp != this)
                pmp->Validate();
        }
        
        fValidatingAll = FALSE;
    }

    AssertSz(
        ! _fEmbedded || _ptpEmbeddedPointer->IsPointer(),
        "Embedded pointer does not point to pointer pos" );

    if (!_fEmbedded)
    {
        AssertSz( _ptpRef && ! _ptpRef->IsPointer(), "Bad position reference" );

        Assert( ! _ptpRef->IsText() || (_ichRef >= 0 && _ichRef <= _ptpRef->Cch()) );

        //
        // The only time it is ok for the ich to be 0 when on a zero length text
        // pos is when that text pos has a non zero text id.  This is so because
        // being after a zero sized id'ed chunk of text is accomplished by pointing
        // at the text pos and setting cch to zero.  Otherwise, if you want to be
        // before the text pos, point to the previous text pos.
        //

        if (_ptpRef->IsText() && _ichRef == 0 && _ptpRef->Cch() == 0)
            AssertSz( _ptpRef->TextID() != 0, "Ambiguous unembedded pointer position" );
    }
    else
    {
        Assert( _ptpEmbeddedPointer->IsPointer() );
        
        Assert( _ptpRef->MarkupPointer() == this );
        Assert( _ptpRef->Gravity() == Gravity() );
        Assert( _ptpRef->Cling() == Cling() );
        
        Assert( ! _pmpNext && ! _pmpNext );

        //
        // Make sure this pointer is NOT in it's markups list
        //

        for ( CMarkupPointer * p = Markup()->_pmpFirst ; p ; p = p->_pmpNext )
            AssertSz( p != this, "Embedded pointer is in unembedded list" );
    }

    //
    // Make sure the pointer is not in an inclusion
    //

    {
        CTreePos * ptp;
        long       ich;

        fValidating = TRUE;

        ptp = GetNormalizedReference( ich );

        fValidating = FALSE;
        
        if (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsEndNode())
            AssertSz( 0, "Pointer in the middle of an inclusion" );

        ptp = ptp->NextTreePos();
        
        if (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsBeginNode())
            AssertSz( 0, "Pointer in the middle of an inclusion" );
    }

    //
    // If we are caching a cp, compute it manually and make sure it is ok
    //
    
    AssertSz( ! CpIsCached() || GetCpSlow() == _cpCache, "Cached cp is not valid" );
}

#endif

inline void
CMarkupPointer::AddMeToList ( )
{
    Assert( Markup() );
    Assert( ! _pmpNext && ! _pmpPrev );
    
    CMarkupPointer * & pmpFirst = Markup()->_pmpFirst;

    _pmpNext = pmpFirst;
    
    if (pmpFirst)
        pmpFirst->_pmpPrev = this;
    
    pmpFirst = this;
}

inline void
CMarkupPointer::RemoveMeFromList ( )
{
    Assert( Markup() );

#if DBG == 1
    
    for ( CMarkupPointer * pmp = Markup()->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
    {
        if (pmp == this)
            break;
    }

    Assert( pmp );
    
#endif

    CMarkupPointer * & pmpFirst = Markup()->_pmpFirst;
    
    if (pmpFirst == this)
        pmpFirst = _pmpNext;

    if (_pmpPrev)
        _pmpPrev->_pmpNext = _pmpNext;

    if (_pmpNext)
        _pmpNext->_pmpPrev = _pmpPrev;

    _pmpNext = _pmpPrev = NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     GetNormalizedReference
//
//  Synopsis:   Returns a ptp/ich pair as far left as possible.  Basically,
//              skips past pointers and empty 0-textid text pos/
//
//-----------------------------------------------------------------------------

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreePos *
CMarkupPointer::GetNormalizedReference ( long & ichOut ) const
{
    Assert( IsPositioned() );

    Validate();

    //
    // Unembedded pointers are already normalized!
    //

    if (!_fEmbedded)
    {
        ichOut = _ichRef;
        return _ptpRef;
    }
    
    for ( CTreePos * ptp = _ptpEmbeddedPointer ; ; )
    {
        ptp = ptp->PreviousTreePos();

        if (ptp->IsPointer())
            continue;

        if (ptp->IsText())
        {
            long cch = ptp->Cch();

            if (cch > 0)
            {
                ichOut = cch;
                return ptp;
            }

            //
            // Special case for text id, can have ich == 0 and cch = 0
            // when text has non zero ID.
            //
            
            if (ptp->TextID() != 0)
            {
                ichOut = 0;
                return ptp;
            }

            //
            // Skip past empty non-text id text pos
            //

            continue;
        }

        ichOut = 0;
        return ptp;
    }
}

HRESULT
CMarkupPointer::UnEmbed ( CTreePos * * pptpUpdate, long * pichUpdate )
{
    HRESULT    hr = S_OK;
    CTreePos * ptpSave;

    //
    // If we are already not embedded, then do nothing.
    //
    
    if (!IsPositioned() || !_fEmbedded)
        goto Cleanup;
    
    ptpSave = _ptpEmbeddedPointer;

    _ptpRef = GetNormalizedReference( _ichRef );
    
    
    AddMeToList();

    _fEmbedded = FALSE;

    //
    // Clear the CMarkupPointer pointer in the pos so that OnPositionReleased
    // isn't called, so we don't assume that the pointer is still embedded
    // and someone is taking it out of the tree (other than here).
    //
    
    ptpSave->SetMarkupPointer( NULL );
    
    hr = THR( Markup()->RemovePointerPos( ptpSave, pptpUpdate, pichUpdate ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif

///////////////////////////////////////////
//  CBase methods

const CMarkupPointer::CLASSDESC CMarkupPointer::s_classdesc =
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
};

const CBase::CLASSDESC *
CMarkupPointer::GetClassDesc () const
{
    return &s_classdesc;
}

HRESULT
CMarkupPointer::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IMarkupPointer)
        QI_INHERITS(this, IMarkupPointer2)

    default:
        if (iid == CLSID_CMarkupPointer)
        {
            *ppv = this;
            return S_OK;
        }
        break;
    }

    if (!*ppv)
        RRETURN( E_NOINTERFACE );

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


///////////////////////////////////////////
//  IMarkupPointer methods

STDMETHODIMP
CMarkupPointer::OwningDoc ( IHTMLDocument2 ** ppDoc )
{
    HRESULT hr;
    CMarkup * pMarkup = Markup();

    if (!pMarkup)
        pMarkup = _pDoc->PrimaryMarkup();

    //
    // Ensure we have the primary markup or frame
    //
    pMarkup = pMarkup->GetFrameOrPrimaryMarkup();
    Assert( pMarkup );
       
    hr = pMarkup->EnsureDocument();
    if (hr)
        goto Cleanup;

    hr = pMarkup->Document()->QueryInterface(IID_IHTMLDocument2, (void **) ppDoc);

Cleanup:
    RRETURN(hr);
}


STDMETHODIMP
CMarkupPointer::Gravity ( POINTER_GRAVITY *peGravity )
{
    HRESULT hr = S_OK;

    if (!peGravity)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *peGravity = Gravity() ? POINTER_GRAVITY_Right : POINTER_GRAVITY_Left;

Cleanup:

    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::SetGravity ( POINTER_GRAVITY eGravity )
{
    HRESULT hr = S_OK;

    Assert( IsValidGravity( eGravity ) );

    if (!IsValidGravity( eGravity ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    _fRightGravity = eGravity == POINTER_GRAVITY_Right;

    //
    // Push the gravity to the pos if we are embedded
    //

    if (_fEmbedded)
        GetEmbeddedTreePos()->SetGravity( _fRightGravity );
    
Cleanup:

    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::Cling ( BOOL * pfCling )
{
    HRESULT hr = S_OK;

    if (!pfCling)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfCling = Cling();

Cleanup:

    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::SetCling ( BOOL fCling )
{
    HRESULT hr = S_OK;

    _fCling = fCling;
    
    //
    // Push the cling to the pos if we are embedded
    //

    if (_fEmbedded)
        GetEmbeddedTreePos()->SetCling( _fCling );
    
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::MoveAdjacentToElement ( IHTMLElement *pIElement, ELEMENT_ADJACENCY eAdj )
{
    HRESULT hr;
    CElement * pElement;

    if (!IsValidAdjacency( eAdj ) || !pIElement || !_pDoc->IsOwnerOf( pIElement ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pElement->IsInMarkup())
    {
        hr = CTL_E_UNPOSITIONEDELEMENT;
        goto Cleanup;
    }

    //
    // TODO (JHarding): can't get the root, we should assert here
    //
    if( pElement->Tag() == ETAG_ROOT && 
        ( eAdj == ELEM_ADJ_BeforeBegin || eAdj == ELEM_ADJ_AfterEnd ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( MoveAdjacentToElement( pElement, eAdj ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::MoveToPointer ( IMarkupPointer * pIPointer )
{
    HRESULT hr = S_OK;
    CMarkupPointer *pPointer;

    if (!pIPointer || !_pDoc->IsOwnerOf( pIPointer ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pPointer->IsPositioned())
    {
        hr = THR( Unposition() );
        if( hr )
            goto Cleanup;
    }
    else
    {
        hr = THR( MoveToPointer( pPointer ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::MoveToContainer ( IMarkupContainer * pContainer, BOOL fAtStart )
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    if (!pContainer || !_pDoc->IsOwnerOf( pContainer ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pContainer->QueryInterface( CLSID_CMarkup, (void **) & pMarkup ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( MoveToContainer( pMarkup, fAtStart ) );

Cleanup:
    
    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::IsPositioned ( BOOL * pfPositioned )
{
    HRESULT hr = S_OK;

    if (!pfPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfPositioned = IsPositioned();

Cleanup:

    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::GetContainer ( IMarkupContainer * * ppContainer )
{
    HRESULT   hr = S_OK;
    CMarkup * pMarkup;

    if (!ppContainer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppContainer = NULL;

    pMarkup = Markup();

    if (pMarkup)
    {
        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **) ppContainer ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

STDMETHODIMP
CMarkupPointer::Unposition ( )
{
    HRESULT hr = S_OK;
    
    if (!IsPositioned())
        goto Cleanup;

    hr = THR( UnEmbed( NULL, NULL ) );

    if (hr)
        goto Cleanup;

    //
    // Remove from the unembeded list.  Remember, it can be
    // anywhere in the list.
    //

    RemoveMeFromList();

    //
    // Now, setting the markup to NULL will finally unposition it
    //
    
    SetMarkup(NULL);
    _ptpRef = NULL;
    _ichRef = 0;
    
    //
    // We have changed the position of the pointer, invalidate the
    // cp cache
    //
    
    _verCp = 0;
    _cpCache = -1;

    Validate();
    
Cleanup:
    
    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif


STDMETHODIMP
CMarkupPointer::Left (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchtext )
{
    return THR( There( TRUE, fMove, pContext, ppElement, pcch, pchtext, 0 ) );
}

STDMETHODIMP
CMarkupPointer::Right (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchText )
{
    return THR( There( FALSE, fMove, pContext, ppElement, pcch, pchText, 0 ) );
}

HRESULT
CMarkupPointer::There (
    BOOL                  fLeft,
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchText,
    DWORD *               pdwFlags)
{
    HRESULT     hr;
    CTreeNode * pNode;

    pNode = NULL;

    hr = THR(
        There(
            fLeft, fMove, pContext,
            ppElement ? & pNode : NULL,
            pcch, pchText, NULL, pdwFlags ) );

    if (hr)
        goto Cleanup;

    if (ppElement)
    {
        *ppElement = NULL;

        if (pNode)
        {
            hr = THR( pNode->GetElementInterface( IID_IHTMLElement, (void * *) ppElement ) );
    
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

HRESULT
CMarkupPointer::There (
    BOOL                  fLeft,
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    CTreeNode * *         ppNode,
    long *                pcch,
    OLECHAR *             pchText,
    long *                plTextID,
    DWORD *               pdwFlags )
{
    HRESULT    hr = S_OK;
    long       cchIn = 0;
    CTreePos * ptp;
    long       ich;
    long       dcch;
    BOOL       fHitNode;

    Validate();
    
    //
    // We must assign something to all output params, even if they are
    // meaningless in the current context.
    //

    if (ppNode)
        *ppNode = NULL;

    if (pcch)
    {
        cchIn = *pcch;
        *pcch = 0;
    }

    if (plTextID)
        *plTextID = 0;

    if (pContext)
        *pContext = CONTEXT_TYPE_None;
    
    //
    // If we are unpositioned, then we have done all we have to do.
    //

    if (!IsPositioned())
        goto Cleanup;

    //
    // Get the current reference
    //

    if (_fEmbedded)
    {
        ptp = _ptpEmbeddedPointer;
        ich = 0;
    }
    else
    {
        ptp = _ptpRef;
        ich = _ichRef;
    }

    //
    // Compute the delta of characters moved, useful for updating cached cp.
    //

    dcch = 0;

    //
    // If the content we are adjacent to is a node, then set this var.
    //

    fHitNode = FALSE;

    //
    // The following will set ptp to either point to the edge we are to cross,
    // or set the ptp/ich pair to a significant text node.
    //

    if (fLeft)
    {
        for ( ; ; )
        {
            if (!ptp->IsPointer())
            {
                if (ptp->IsNode())
                {
                    fHitNode = TRUE;
                    break;
                }

                Assert( ptp->IsText() );

                if (ich > 0)
                    break;

                //
                // Check for an empty text pos with ID.  This is a empty
                // DOM text node.
                //

                Assert( ptp->Cch() == 0 );

                if (plTextID && ptp->TextID() != 0)
                    break;
            }

            ptp = ptp->PreviousTreePos();
            ich = ptp->IsText() ? ptp->Cch() : 0;
        }
    }
    else
    {
        for ( ; ; )
        {
            if (ptp->IsText() && ich < ptp->Cch())
                break;
            
            CTreePos * ptpNext = ptp->NextTreePos();

            if (!ptpNext->IsPointer())
            {
                if (ptpNext->IsNode())
                {
                    fHitNode = TRUE;
                    break;
                }

                Assert( ptpNext->IsText() );

                if (ptpNext->Cch())
                    break;

                if (plTextID && ptpNext->TextID() != 0)
                    break;
            }

            //
            // We should never attempt to cross over an empty dom text node.  We
            // should have broken out of hte loop by now in this case.
            //

            ptp = ptpNext;
            
            Assert( !plTextID || !ptp->IsText() || ptp->Cch() != 0 || ptp->TextID() != 0 );
            
            ich = 0;
        }
    }

    //
    // See if we stopped on a node
    //

    if (fHitNode)
    {
        long nIncl = 0;
        
        ptp = fLeft ? ptp : (dcch++, ptp->NextTreePos());

        Assert( ptp->IsNode() );
        
        //
        // Find the kernel of the inclusion
        //

        for ( nIncl = 0 ; ! ptp->IsEdgeScope() ; nIncl++ )
        {
            if (fLeft)
            {
                ptp = ptp->PreviousTreePos();
            }
            else
            {
                ptp = ptp->NextTreePos();
            }
        }

        //
        // Have we butted up against the edge of the container?
        //

        if (ptp->Branch()->Tag() == ETAG_ROOT)
            goto Cleanup;

        //
        // Return the node crossed
        //

        if (ppNode)
            *ppNode = ptp->Branch();

        //
        // If we are traveling left and encounter a begin node, or we are
        // traveling right and encounter an end node, then we have left the
        // scope of an element.  Otherwise we have entered the scope of an
        // element (the else clause)
        //

        if (fLeft && ptp->IsBeginNode() || !fLeft && ptp->IsEndNode())
        {
            //
            // We better not have left the scope of a no scope element, for
            // we never must ever get into one.
            //

            Assert( ! ptp->Branch()->Element()->IsNoScope() );

            //
            // When moving out of a slave, behave as if we're moving off
            // the edge of the tree (dbau): report no context, don't move the
            // pointer, and report no element.
            //
            
            if ((!pdwFlags || !(*pdwFlags & MPTR_SHOWSLAVE)) && ptp->Branch()->Element()->HasMasterPtr())
	    {
		if (ppNode)
		    *ppNode = NULL;

                goto Cleanup;
	    }

            if (pContext)
                *pContext = CONTEXT_TYPE_ExitScope;
        }
        else
        {
            //
            // If we have moved into the scope of a no scope element, then break
            // out to the other side.
            //

            if (ptp->Branch()->Element()->IsNoScope())
            {
                if (pContext)
                    *pContext = CONTEXT_TYPE_NoScope;

                Assert( nIncl == 0 );

                Assert(
                    ptp->Branch() ==
                        ptp->Branch()->Element()->GetFirstBranch() );

                if (fMove)
                {
                    //
                    // Skip over to the other side of the no scope element
                    //

                    if (fLeft)
                    {
                        dcch -= 1;
                        ptp->Branch()->Element()->GetTreeExtent( & ptp, NULL );
                    }
                    else
                    {
                        dcch += 1;
                        ptp->Branch()->Element()->GetTreeExtent( NULL, & ptp );
                    }
                }
            }
            else
            {
                if (pContext)
                    *pContext = CONTEXT_TYPE_EnterScope;
            }
        }

        //
        // Get out of the inclusion and position properly.
        //

        if (fLeft)
        {
            while ( nIncl-- )
                ptp = ptp->PreviousTreePos();

            Assert( ptp->IsNode() );
            
            ptp = ptp->PreviousTreePos();
            dcch--;

            ich = ptp->IsText() ? ptp->Cch() : 0;
        }
        else
        {
            while ( nIncl-- )
                ptp = ptp->NextTreePos();
            
            ich = 0;
        }
    }
    else
    {
        if (pContext)
            *pContext = CONTEXT_TYPE_Text;
        
#if DBG == 1
        if (fLeft)
            Assert( ptp->IsText() );
        else
            Assert( ptp->IsText() && ich < ptp->Cch() || ptp->NextTreePos()->IsText() );
#endif
        
        if (plTextID)
        {
            if (fLeft)
                *plTextID = ptp->TextID();
            else
            {
                if (ptp->IsText() && ich < ptp->Cch())
                    *plTextID = ptp->TextID();
                else
                    *plTextID = ptp->NextTreePos()->TextID();
            }
        }
            
        long cchWant = (pcch && cchIn >= 0) ? cchIn : INT_MAX;
        long cchLook = cchWant;

        //
        // Here we move accross up to cchLook text or until we hit a node or
        // text with a different ID.
        //

        if (fLeft)
        {
            for ( ; ; )
            {
                if (ich > 0)
                {
                    if (plTextID && ptp->TextID() != * plTextID)
                        break;

                    long dcch2 = min( cchLook, ich );
                    cchLook -= dcch2;
                    ich -= dcch2;
                    dcch -= dcch2;

                    if (ich == 0)
                    {
                        ptp = ptp->PreviousTreePos();
                        ich = ptp->IsText() ? ptp->Cch() : 0;
                    }

                    if (cchLook == 0)
                        break;
                }
                else
                {
                    if (ptp->IsText())
                    {
                        if (plTextID)
                        {
                            long textID = ptp->TextID();

                            if (textID != 0 && textID != * plTextID)
                                break;
                        }
                    }
                    else if (!ptp->IsPointer())
                    {
                        Assert( ptp->IsNode() );
                        break;
                    }

                    ptp = ptp->PreviousTreePos();
                    ich = ptp->IsText() ? ptp->Cch() : 0;
                }
            }
        }
        else
        {
            for ( ; ; )
            {
                long cch;
                
                if (ptp->IsText() && ich < (cch = ptp->Cch()))
                {
                    if (plTextID && ptp->TextID() != * plTextID)
                        break;

                    long dcch2 = min( cchLook, cch - ich );
#if 0
                    //
                    // Special flag to stop at CR or LF in text.  Only works
                    // when going to the right.
                    //
                    
                    if (pdwFlags && (*pdwFlags & MPTR_STOPATCRLF))
                    {
                        long cp = GetCp() + dcch;
                        CTxtPtr txtPtr( Markup(), cp );
                        
                        if (txtPtr.FindCrOrLf( dcch2 ) )
                        {
                            *pdwFlags |= MPTR_FOUNDCRLF;
                            
                            Assert( long( txtPtr.GetCp() ) >= cp );
                            
                            dcch2 = txtPtr.GetCp() - cp + 1;
                            
                            cchLook -= dcch2;
                            ich += dcch2;
                            dcch += dcch2;

                            break;
                        }
                    }
#endif

                    cchLook -= dcch2;
                    ich += dcch2;
                    dcch += dcch2;

                    if (cchLook == 0)
                        break;
                }
                else
                {
                    CTreePos * ptpNext = ptp->NextTreePos();

                    if (ptpNext->IsText())
                    {
                        if (plTextID)
                        {
                            long textID = ptpNext->TextID();

                            if (textID != 0 && *plTextID != textID)
                                break;
                        }
                    }
                    else if (!ptpNext->IsPointer())
                    {
                        Assert( ptpNext->IsNode() );
                        break;
                    }

                    ptp = ptpNext;
                    ich = 0;
                }
            }

            //
            // Might be on a text node with ich == 0 which is only allowed if it is
            // an empty text id'ed node.
            //

            if (ich == 0 && ptp->IsText() && ptp->Cch())
            {
                ptp = ptp->PreviousTreePos();
                ich = ptp->IsText() ? ptp->Cch() : 0;
            }
        }

        long cchFound = cchWant - cchLook;

        //
        // Return the number of chars found
        //
        
        if (pcch)
            *pcch = cchFound;

        //
        // Return the text moved over
        //

        if (pchText && cchFound > 0 && pcch && cchIn > 0)
        {
            long cp = GetCp();

            if (fLeft)
                cp -= cchFound;

            Verify( CTxtPtr( Markup(), cp ).GetRawText( cchFound, pchText ) );
        }
    }

    //
    // The ptp/ich pair should now indicate where we should move
    //

    if (fMove)
    {
        hr = THR(
            MoveToReference(
                ptp, ich, Markup(), CpIsCached() ? _cpCache + dcch : -1 ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif

STDMETHODIMP
CMarkupPointer::MoveUnit( MOVEUNIT_ACTION muAction )
{
    RRETURN1( MoveUnitInternal( muAction, -1 ), S_FALSE );
}

STDMETHODIMP
CMarkupPointer::MoveUnitBounded( MOVEUNIT_ACTION muAction, IMarkupPointer * pmpBound )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pmpBoundary;

    if( !pmpBound || 
        !_pDoc->IsOwnerOf( pmpBound ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pmpBound->QueryInterface( CLSID_CMarkupPointer, (void **)&pmpBoundary ) );
    if( hr || !pmpBoundary->IsPositioned() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( MoveUnitInternal( muAction, pmpBoundary->GetCp() ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CMarkupPointer::MoveUnitInternal ( MOVEUNIT_ACTION muAction, long cpBoundary )
{
    HRESULT   hr = S_OK;
    long      cp;
    long      newcp;
    CTxtPtr   tp;
    long      action;
    BOOL      fForward = TRUE;

    Validate();
            
    if (!IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }

    cp = GetCp();
    
    tp.Reinit( Markup(), cp );
    
    action = 0;
    
    switch( muAction )
    {
    case MOVEUNIT_PREVCHAR:
    case MOVEUNIT_NEXTCHAR:
        fForward = ( muAction == MOVEUNIT_NEXTCHAR );
        tp.MoveChar( fForward );
        break;
        
    case MOVEUNIT_PREVCLUSTERBEGIN:
    case MOVEUNIT_NEXTCLUSTERBEGIN:
        fForward = ( muAction == MOVEUNIT_NEXTCLUSTERBEGIN );
        tp.MoveCluster( fForward );
        break;
        
    case MOVEUNIT_PREVCLUSTEREND:
    case MOVEUNIT_NEXTCLUSTEREND:
        fForward = ( muAction == MOVEUNIT_NEXTCLUSTEREND );
        tp.MoveClusterEnd( fForward );
        break;
        
    case MOVEUNIT_PREVWORDBEGIN:
    case MOVEUNIT_NEXTWORDBEGIN:
    case MOVEUNIT_PREVWORDEND:
    case MOVEUNIT_NEXTWORDEND:
    case MOVEUNIT_PREVPROOFWORD:
    case MOVEUNIT_NEXTPROOFWORD:
        switch( muAction )
        {
            case MOVEUNIT_PREVWORDBEGIN:
                action = WB_MOVEWORDLEFT;
                break;
            case MOVEUNIT_NEXTWORDBEGIN:
                action = WB_MOVEWORDRIGHT;
                break;
            case MOVEUNIT_PREVWORDEND:
                action = WB_LEFTBREAK;
                break;
            case MOVEUNIT_NEXTWORDEND:
                action = WB_RIGHTBREAK;
                break;
            case MOVEUNIT_PREVPROOFWORD:
                action = WB_LEFT;
                break;
            case MOVEUNIT_NEXTPROOFWORD:
                action = WB_RIGHT;
                break;
        }
        // All of the forward word actions are defined as odd numbers,
        // so we can do this a little easier
        fForward = muAction & 1;
        tp.FindWordBreak( action );
        break;
        
    case MOVEUNIT_PREVURLBEGIN:
        fForward = FALSE;
        if( !tp.FindUrl( FALSE, TRUE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_NEXTURLBEGIN:
        fForward = TRUE;
        if( !tp.FindUrl( TRUE, TRUE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_PREVURLEND:
        fForward = FALSE;
        if( !tp.FindUrl( FALSE, FALSE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_NEXTURLEND:
        fForward = TRUE;
        if( !tp.FindUrl( TRUE, FALSE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_PREVSENTENCE:
    case MOVEUNIT_NEXTSENTENCE:
        fForward = ( muAction == MOVEUNIT_NEXTSENTENCE );
        tp.FindBOSentence( fForward );
        break;
        
    case MOVEUNIT_PREVBLOCK:
    case MOVEUNIT_NEXTBLOCK:
        fForward = ( muAction == MOVEUNIT_NEXTBLOCK );
        tp.FindBlockBreak( fForward );
        break;
        
#if DBG==1
    default:
        AssertSz( FALSE, "Invalid action" );
#endif
    }

    // If the tp moved somewhere, position us wherever it went
    newcp = tp.GetCp();

    // NOTE (johnbed) Due to a problem with moveunit, it is possible that
    // we will be compute a cp that is outside the document here. Fix it up
    // instead of asserting for now. This is raided bug assigned to TomFakes.
    // When it is fixed, this should be removed

    if( newcp < 1 )
        newcp = 1;
    
    if( newcp >= Markup()->Cch() )
        newcp = Markup()->Cch() -1;

    // Only move if we're within the boundary, or no boundary was given
    if( newcp != cp && ( cpBoundary == -1 || 
                       ( fForward && newcp <= cpBoundary ) ||
                       (!fForward && newcp >= cpBoundary ) ) )
        hr = THR( MoveToCp( newcp, Markup() ) );
    else
        hr = S_FALSE;

Cleanup:

    RRETURN1( hr, S_FALSE );
}


STDMETHODIMP
CMarkupPointer::CurrentScope ( IHTMLElement ** ppElemCurrent )
{
    HRESULT hr = S_OK;
    CTreeNode * pNode;

    if (!ppElemCurrent)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElemCurrent = NULL;
    
    pNode = CurrentScope();
    
    if (pNode)
    {
        hr = THR(
            pNode->GetElementInterface(
                IID_IHTMLElement, (void **) ppElemCurrent ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::FindText (
    OLECHAR *        pchFindText, 
    DWORD            dwFlags,
    IMarkupPointer * pIEndMatch, /* =NULL */
    IMarkupPointer * pIEndSearch /* =NULL */)
{
    HRESULT hr;
    CMarkupPointer *pEndMatch  = NULL;
    CMarkupPointer *pEndSearch = NULL;

    if (!IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }
    
    //
    // Convert arguments, if necessary.
    //

    // Move this pointer to the end of the match
    
    if (pIEndMatch)
    {
        Assert( _pDoc->IsOwnerOf( pIEndMatch ) );

        hr = THR( pIEndMatch->QueryInterface( CLSID_CMarkupPointer, (void **) & pEndMatch) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // Limit our search to this pointer.
    
    if (pIEndSearch)
    {
        hr = THR( pIEndSearch->QueryInterface( CLSID_CMarkupPointer, (void **) & pEndSearch ) );
        
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    hr = FindText( pchFindText, dwFlags, pEndMatch, pEndSearch ) ? S_OK : S_FALSE;

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}

HRESULT
CMarkupPointer::SetTextIdentity ( CMarkupPointer * pPointerFinish, long * plTextID )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pPointerStart = this;
    CTreePosGap      tpgBegin, tpgEnd;

    Assert(
        IsPositioned() && pPointerFinish->IsPositioned() &&
        Markup() == pPointerFinish->Markup() );

#if DBG == 1
    Validate();
    if (pPointerFinish)
        pPointerFinish->Validate();
#endif

    hr = THR( Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    EnsureLogicalOrder( pPointerStart, pPointerFinish );

    Verify( ! tpgBegin.MoveTo( pPointerStart->GetEmbeddedTreePos(), TPG_LEFT ) );
    Verify( ! tpgEnd.MoveTo( pPointerFinish->GetEmbeddedTreePos(), TPG_LEFT ) );

    hr = THR( Markup()->SetTextID( & tpgBegin, & tpgEnd, plTextID ) );
    
    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::FindTextIdentity ( long textID, CMarkupPointer * pPointerOtherEnd )
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgBegin ( TPG_RIGHT );
    CTreePosGap tpgEnd ( TPG_LEFT );

#if DBG == 1
    Validate();
    if (pPointerOtherEnd)
        pPointerOtherEnd->Validate();
#endif

    if (!IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // TODO (EricVas): This needs to be rewritten to not assume pointer pos's
    //

    hr = THR( Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    Verify( ! tpgBegin.MoveTo( GetEmbeddedTreePos(), TPG_LEFT ) );

    hr = THR( Markup()->FindTextID( textID, & tpgBegin, & tpgEnd ) );
    
    if (hr == S_FALSE)
        goto Cleanup;
    
    if (hr)
        goto Cleanup;

    hr = THR( MoveToGap( & tpgBegin, Markup() ) );

    if (hr)
        goto Cleanup;

    if (pPointerOtherEnd)
    {
        hr = THR( pPointerOtherEnd->MoveToGap( & tpgEnd, Markup() ) );
        
        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}


STDMETHODIMP
CMarkupPointer::IsInsideURL( IMarkupPointer * pIRight, BOOL * pfResult )
{
    HRESULT          hr = S_OK;
    CTxtPtr          tpThis, tpRight;
    BOOL             fFound  = FALSE;
    long             cpStart;
    long             cpEnd;

    if (!IsPositioned() || !pfResult || !pIRight || !_pDoc->IsOwnerOf( pIRight ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    tpThis.Reinit( Markup(), GetCp() );
    tpRight.Reinit( Markup(), GetCp() );
    
    if (tpThis.IsInsideUrl( & cpStart, & cpEnd ))
    {
        long cchOffset;
        CMarkupPointer * pRight;
        CTreePos * ptp;
        
        hr = THR( pIRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pRight ) );

        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

#if DBG==1
        SetDebugName(_T("Start Url"));
        pRight->SetDebugName(_T("End Url"));
#endif
        ptp = Markup()->TreePosAtCp( cpEnd, & cchOffset );

        hr = THR( MoveToCp( cpStart, Markup() ) );

        if (hr)
            goto Cleanup;

        if (ptp->IsNode())
        {
            CTreePosGap tpg ( ptp, TPG_LEFT );
        
            tpg.Move( TPG_LEFT, TPG_VALIDGAP | TPG_OKNOTTOMOVE );
        
            pRight->MoveToGap( & tpg, Markup() );
        }
        else
        {  
            pRight->MoveToCp( cpEnd, Markup() );
        }
        
        fFound = TRUE;
    }

Cleanup:
    
    *pfResult = fFound;
    
    RRETURN( hr );
}

long
CMarkupPointer::GetCpSlow ( ) const
{
    if (!IsPositioned())
        return -1;
    
    if (_fEmbedded)
        return _ptpEmbeddedPointer->GetCp();
    
    if (_ptpRef->IsText())
    {
        Assert( _ichRef >= 0 && _ichRef <= _ptpRef->Cch() );
        return _ptpRef->GetCp() + _ichRef;
    }
    
    Assert( _ichRef == 0 );
    
    return _ptpRef->GetCp() + _ptpRef->GetCch();
}

#define COMPARE(TYPE)                                                                      \
HRESULT                                                                                    \
CMarkupPointer::TYPE ( IMarkupPointer * pIPointerThat, BOOL * pfResult )                   \
{                                                                                          \
    HRESULT          hr;                                                                   \
    CMarkupPointer * pPointerThat;                                                         \
                                                                                           \
    if (!pIPointerThat || !pfResult)                                                       \
    {                                                                                      \
        hr = E_INVALIDARG;                                                                 \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    hr = pIPointerThat->QueryInterface( CLSID_CMarkupPointer, (void * *) & pPointerThat ); \
                                                                                           \
    if (hr)                                                                                \
    {                                                                                      \
        hr = E_INVALIDARG;                                                                 \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    if (!IsPositioned() || !pPointerThat->IsPositioned())                                  \
    {                                                                                      \
        hr = CTL_E_UNPOSITIONEDPOINTER;                                                    \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    if (Markup() != pPointerThat->Markup())                                                \
    {                                                                                      \
        hr = CTL_E_INCOMPATIBLEPOINTERS;                                                   \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    *pfResult = TYPE( pPointerThat );                                                      \
                                                                                           \
Cleanup:                                                                                   \
                                                                                           \
    RRETURN( hr );                                                                         \
}

COMPARE( IsLeftOf )
COMPARE( IsLeftOfOrEqualTo )
COMPARE( IsRightOf )
COMPARE( IsRightOfOrEqualTo )

#undef COMPARE

//
// IsEqualTo is different from the others because it is capable of
// dealing with unpositioned or incompatible markup pointers.
//

HRESULT
CMarkupPointer::IsEqualTo ( IMarkupPointer * pIPointerThat, BOOL * pfResult )
{
    HRESULT          hr;
    CMarkupPointer * pPointerThat;

    if (!pIPointerThat || !pfResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pIPointerThat->QueryInterface( CLSID_CMarkupPointer, (void * *) & pPointerThat );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsPositioned() || !pPointerThat->IsPositioned() || Markup() != pPointerThat->Markup())
    {
        *pfResult = FALSE;
        goto Cleanup;
    }
    
    *pfResult = IsEqualTo( pPointerThat );

Cleanup:

    RRETURN( hr );
}

HRESULT
OldCompare ( IMarkupPointer * p1, IMarkupPointer * p2, int * piResult )
{
    HRESULT hr = S_OK;
    BOOL    fResult;

    Assert( piResult );

    hr = THR( p1->IsEqualTo( p2, & fResult ) );

    if (hr)
        goto Cleanup;

    if (fResult)
    {
        *piResult = 0;
        goto Cleanup;
    }

    hr = THR( p1->IsLeftOf( p2, & fResult ) );

    if (hr)
        goto Cleanup;

    *piResult = fResult ? -1 : 1;

Cleanup:

    RRETURN( hr );
}

int
OldCompare ( CMarkupPointer * p1, CMarkupPointer * p2 )
{
    if (p1->IsEqualTo( p2))
        return 0;

    return p1->IsLeftOf( p2 ) ? -1 : 1;
}

void
CMarkupPointer::SetKeepMarkupAlive ( BOOL fKeepAlive )
{
    if (!!fKeepAlive == !!_fKeepMarkupAlive)
        return;

    _fKeepMarkupAlive = !!fKeepAlive;

    if (Markup())
    {
        if (_fKeepMarkupAlive)
            Markup()->PrivateAddRef();
        else
            Markup()->PrivateRelease();
    }
}

void
CMarkupPointer::SetAlwaysEmbed ( BOOL fAlwaysEmbed )
{
    if (!!fAlwaysEmbed == !!_fAlwaysEmbed)
        return;

    _fAlwaysEmbed = !!fAlwaysEmbed;

    if (IsPositioned() && !_fEmbedded && _fAlwaysEmbed)
        IGNORE_HR( Embed( Markup(), _ptpRef, _ichRef, CpIsCached() ? _cpCache : -1 ) );
}

HRESULT
CMarkupPointer::MoveAdjacentToElement ( CElement * pElement, ELEMENT_ADJACENCY adj )
{
    HRESULT hr = S_OK;
    CTreePos * ptp = NULL;
    BOOL fBefore = adj == ELEM_ADJ_BeforeBegin || adj == ELEM_ADJ_BeforeEnd;
    BOOL fBegin  = adj == ELEM_ADJ_BeforeBegin || adj == ELEM_ADJ_AfterBegin;
    TPG_DIRECTION eDir = fBefore ? TPG_LEFT : TPG_RIGHT;
    CTreePosGap tpg;

    Assert( pElement && IsValidAdjacency( adj ) );
    Assert( pElement->IsInMarkup() );
    Assert( ! ( pElement->Tag() == ETAG_ROOT &&
                ( adj == ELEM_ADJ_BeforeBegin || adj == ELEM_ADJ_AfterEnd ) ) );
    
    if (pElement->IsNoScope() &&
        (adj == ELEM_ADJ_AfterBegin || adj == ELEM_ADJ_BeforeEnd))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // find the TreePos where we're supposed to start looking
    
    pElement->GetTreeExtent(
        fBegin ? & ptp : NULL, fBegin ? NULL : & ptp );

    Assert( ptp );
    
    // move to the nearest legal position
    
    tpg.SetMoveDirection( eDir );
    
    hr = THR( tpg.MoveTo( ptp, eDir ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( tpg.Move( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( MoveToGap( & tpg, pElement->GetMarkup() ) );

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkupPointer::MoveToContainer ( CMarkup * pMarkup, BOOL fBegin, DWORD dwFlags )
{
    HRESULT     hr;
    CTreePos *  ptp = NULL;
    CTreePosGap tpg;
    CTreeNode * pNode;
    MARKUP_CONTEXT_TYPE context;

    Assert( pMarkup );
    Assert( pMarkup->Root() && pMarkup->Root()->Tag() == ETAG_ROOT );

    pMarkup->Root()->GetTreeExtent( fBegin ? & ptp : NULL, fBegin ? NULL : & ptp );

    Assert( ptp );

    hr = THR( tpg.MoveTo( ptp, fBegin ? TPG_RIGHT : TPG_LEFT ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( MoveToGap( & tpg, pMarkup ) );

    {
        //
        // move inside TEXTSLAVE if present (as if the TEXTSLAVE element were not present - dbau)
        //
        
        hr = THR( There( ! fBegin, FALSE, &context, &pNode, NULL, NULL, NULL, 0 ) );
        
        if (hr)
            goto Cleanup;

        if (context == CONTEXT_TYPE_EnterScope && pNode && pNode->Element()->HasMasterPtr())
        {
            hr = THR( There( ! fBegin, TRUE, NULL, NULL, NULL, NULL, NULL, 0 ) );
            
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );
}


HRESULT
CMarkupPointer::MoveToPointer ( CMarkupPointer * pPointerThat )
{
    HRESULT    hr;
    CTreePos * ptp;
    long       ich;

    Validate();
            
    Assert( pPointerThat );
    Assert( pPointerThat->IsPositioned() );

    ptp = pPointerThat->GetNormalizedReference( ich );

    hr = THR(
        MoveToReference(
            ptp, ich, pPointerThat->Markup(),
            pPointerThat->CpIsCached() ? pPointerThat->_cpCache : -1 ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

void
CMarkupPointer::OnPositionReleased ( )
{
    Assert( _fEmbedded );
    Assert( ! _pmpNext && ! _pmpPrev );
    Assert( Markup() );
    Assert( _ptpEmbeddedPointer );
    Assert( _ichRef == 0 );

    _ptpEmbeddedPointer = NULL;
    _ichRef = 0;
    _fEmbedded = FALSE;
    SetMarkup(NULL);
    WHEN_DBG( _verCp = 0; )
    WHEN_DBG( _cpCache = -1; )
}

void 
CMarkupPointer::SetMarkup( CMarkup * pMarkup )
{
    if (_fKeepMarkupAlive)
    {
        CMarkup * pMarkupOld = _pMarkup;

        _pMarkup = pMarkup;

        if (_pMarkup)
            _pMarkup->PrivateAddRef();

        if (pMarkupOld)
            pMarkupOld->PrivateRelease();
    }
    else
    {
        _pMarkup = pMarkup;
    }
}

CTreeNode *
CMarkupPointer::CurrentScope ( DWORD dwFlags )
{
    CTreeNode * pNode;

    Validate();
    
    if (!IsPositioned())
        return NULL;

    pNode = Branch();

    if (pNode)
    {
        if (   pNode->Tag() == ETAG_ROOT
            && !pNode->_pElement->GetMasterPtr())
            return NULL;

        if (!(dwFlags & MPTR_SHOWSLAVE) && pNode->Element()->HasMasterPtr())
            return NULL;
    }

    return pNode;
}


BOOL
CMarkupPointer::FindText(
    TCHAR *          pchFindText, 
    DWORD            dwFlags, 
    CMarkupPointer * pEndMatch,
    CMarkupPointer * pEndSearch )
{
    long       cp;
    long       cpLimit = -1;
    CTxtPtr    tp;
    HRESULT    hr;

    Validate();
            
    Assert( IsPositioned() );
    
    cp = GetCp();
    
    tp.Reinit( Markup(), cp );

    if (pEndSearch)
    {
        Assert( pEndSearch->Markup() == Markup() );

        cpLimit = pEndSearch->GetCp();

        // Set direction based on the pointer, overriding flags
        // passed in, if necessary.
        
        if(cpLimit < cp)
            dwFlags |= FINDTEXT_BACKWARDS;
        else
            dwFlags &= ~FINDTEXT_BACKWARDS;
    }

    // ask the TP to find the text
    
    cp = tp.FindText( cpLimit, dwFlags, pchFindText, _tcslen( pchFindText ) );

    // if it succeeded, move myself accordingly

    if (cp < 0)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( MoveToCp( tp._cp, Markup() ) );

    if (hr)
        goto Cleanup;

    // Set end pointer, if requested

    if (pEndMatch)
    {
        hr = THR( pEndMatch->MoveToCp( cp, Markup() ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    return hr == S_OK;
}

HRESULT 
CMarkupPointer::QueryBreaks ( DWORD * pdwBreaks )
{
    HRESULT          hr = S_OK;
    CTreePos *       ptp;
    long             ich;
    CTreePosGap      tpg;
    CLineBreakCompat breaker;

    Validate();
            
    Assert( pdwBreaks );

    *pdwBreaks = BREAK_NONE;

    if (!IsPositioned())
        goto Cleanup;

    ptp = GetNormalizedReference( ich );

    //
    // No breaks inside a text pos.  Also, we can't
    // position a gap inside a text pos.
    //

    if (ich > 0 && ich < ptp->Cch())
        goto Cleanup;
    
    hr = THR(
        tpg.MoveTo(
            ptp,
            ptp->IsText()
                ? (ich == 0 ? TPG_LEFT : TPG_RIGHT)
                : TPG_RIGHT ) );

    if (hr)
        goto Cleanup;

    hr = THR( breaker.QueryBreaks( & tpg, pdwBreaks ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkupPointer::MoveToOrphan ( CTreePos * ptp )
{
    HRESULT hr;
    
    Assert( ptp && ptp->IsPointer() && !ptp->MarkupPointer() );

    // if the pointer was already active, delete its old position

    hr = THR( Unposition() );

    if (hr)
        goto Cleanup;

    //
    // remember the new position
    //

    ptp->SetMarkupPointer( this );

    SetMarkup( ptp->GetMarkup() );
    _ptpEmbeddedPointer = ptp;
    _fEmbedded = TRUE;

    _cpCache = -1;
    _verCp = 0;
    
    _fRightGravity = ptp->Gravity();
    _fCling = ptp->Cling();

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

HRESULT
CMarkupPointer::MoveToReference (
    CTreePos * ptp, long ich, CMarkup * pMarkup, long cpNew )
{
    HRESULT hr;

    Assert( ptp && (ich == 0 || ich <= ptp->Cch()) );
    Assert( pMarkup && pMarkup == ptp->GetMarkup() );

    //
    // Make sure the ptp/ich are properly adjusted
    //

    while ( ptp->IsPointer() || (ich == 0 && ptp->IsText() && ptp->TextID() == 0) )
    {
        ptp = ptp->PreviousTreePos();
        ich = ptp->IsText() ? ptp->Cch() : 0;
    }

    Assert( !ptp->IsText() || ich != 0 || ptp->Cch() == 0 );

    hr = THR( UnEmbed( & ptp, & ich ) );

    if (hr)
        goto Cleanup;

    Assert( ! _fEmbedded );

    if (Markup() && Markup() != pMarkup)
    {
        RemoveMeFromList();
        SetMarkup( NULL );
    }

#if DBG == 1
    if (_fAlwaysEmbed || IsTagEnabled( tagMarkupPointerAlwaysEmbed ))
#else
    if (_fAlwaysEmbed)
#endif
    {
        if (Markup())
        {
            RemoveMeFromList();
            SetMarkup( NULL );
        }
        
        hr = THR( Embed( pMarkup, ptp, ich, cpNew ) );

        if (hr)
            goto Cleanup;
    }
    else
    {
        if (!Markup())
        {
            SetMarkup( pMarkup );
            AddMeToList();
        }

        _ptpRef = ptp;
        _ichRef = ich;

        if (cpNew == -1)
        {
            _verCp = 0;
            _cpCache = -1;
        }
        else
        {
            _cpCache = cpNew;
            _verCp = Markup()->GetMarkupContentsVersion();
            Assert( _cpCache == GetCpSlow() );
        }

        Assert( !_fEmbedded );
    }

    Validate();

Cleanup:

    RRETURN( hr );
}


HRESULT
CMarkupPointer::MoveToGap (
    CTreePosGap * ptpg, CMarkup * pMarkup, BOOL fForceEmbedding )
{
    HRESULT    hr = S_OK;
    CTreePos * ptp;
    long       ich;

    Validate();
            
    Assert( ptpg && pMarkup );
    Assert( ptpg->GetAttachedMarkup() );
    Assert( ptpg->GetAttachedMarkup() == pMarkup );

    //
    // pull the position out of the gap, then unposition the gap
    // because an embedding may be removed, one inserted or both.
    // All uses of MoveToGap must expect the gap to be unpositioned
    // upon return.
    //

    ptp = ptpg->AdjacentTreePos( TPG_LEFT );
    ich = ptp->IsText() ? ptp->Cch() : 0;

    ptpg->UnPosition();

    //
    // Make sure the ptp/ich are properly adjusted.  Only do this
    // if not forcing an embedding.  Forcing an embedding is used
    // to place an embedded pointer exactly at the place requested.
    //

    if (!fForceEmbedding && !_fAlwaysEmbed)
    {
        while ( ptp->IsPointer() || (ich == 0 && ptp->IsText() && ptp->TextID() == 0) )
        {
            ptp = ptp->PreviousTreePos();
            ich = ptp->IsText() ? ptp->Cch() : 0;
        }
        
        Assert( ! ptp->IsText() || ich != 0 || 0 == ptp->Cch() );

        hr = THR( MoveToReference( ptp, ich, pMarkup, -1 ) );

        if (hr)
            goto Cleanup;

        goto Cleanup;
    }

    if (IsPositioned())
    {
        if (_fEmbedded)
        {
            //
            // If this pointer is already embedded at the correct
            // location, then there is nothing to do!
            //
            
            if (ptp == _ptpEmbeddedPointer)
                goto Cleanup;
            
            //
            // Remove any existing embedding, making sure to update the
            // target ptp/ich.
            //

            hr = THR( UnEmbed( & ptp, & ich ) );

            if (hr)
                goto Cleanup;
        }

        RemoveMeFromList();
        SetMarkup(NULL);
    }

    hr = THR( Embed( pMarkup, ptp, ich, -1 ) );

    if (hr)
        goto Cleanup;
    
Cleanup:

    Validate();
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::Embed ( CMarkup * pMarkup, CTreePos * ptp, long ich, long cpNew )
{
    HRESULT hr = S_OK;
    CTreePos * ptpNew;
    
    Assert( ! IsPositioned() );
    Assert( ! _fEmbedded );

    Assert( pMarkup && ptp->GetMarkup() == pMarkup );

    //
    // See if we need to split a text pos
    //

    if (ich > 0 && ich < ptp->Cch())
    {
        CMarkupPointer * pmp;

        hr = THR( pMarkup->Split( ptp, ich ) );

        if (hr)
            goto Cleanup;

        //
        // See if other unembedded pointers were pointing at this text pos
        // after where we split it.  Update those where were.
        //

        for ( pmp = pMarkup->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            if (pmp->_ptpRef == ptp && pmp->_ichRef > ich)
            {
                pmp->_ichRef -= ich;
                pmp->_ptpRef = ptp->NextTreePos();
            }
        }

#if DBG == 1
        for ( pmp = pMarkup->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
            pmp->Validate();
#endif
    }

    //
    // Make a pointer pos and put it in the right place
    //

    ptpNew = pMarkup->NewPointerPos( this, Gravity(), Cling() );

    if (!ptpNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pMarkup->Insert( ptpNew, ptp, FALSE ) );

    if (hr)
        goto Cleanup;

    SetMarkup( pMarkup );
    _ptpEmbeddedPointer = ptpNew;
    _ichRef = 0;
    _fEmbedded = TRUE;

    _cpCache = 0;
    _verCp = -1;

    Validate();

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif


HRESULT
CMarkupPointer::MoveToCp ( long cp, CMarkup * pMarkup )
{
    HRESULT    hr = S_OK;
    CTreePos * ptp;
    long       ich;

    Validate();
            
    ptp = pMarkup->TreePosAtCp( cp, & ich );

    if(!ptp)
        return E_FAIL;

    //
    // TreePosAtCp gives a ptp before the given cp.  Markup pointers refer to
    // a ptp as to pointing after.
    //

    if (!ptp->IsText() || ich == 0)
    {
        ptp = ptp->PreviousTreePos();

        while ( ptp->IsPointer() )
            ptp = ptp->PreviousTreePos();

        ich = ptp->IsText() ? ptp->Cch() : 0;
    }
    
    //
    // make sure the ptp is not in an inclusion
    //

    if (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsEndNode())
    {
        while (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsEndNode())
            ptp = ptp->PreviousTreePos();

        if (ptp->IsText())
            ich = ptp->Cch();
    }
    else if (ptp->IsNode())
    {
        CTreePos * ptpNext = ptp->NextTreePos();
        
        if (ptpNext->IsNode() && !ptpNext->IsEdgeScope() && ptpNext->IsBeginNode())
        {
            while (ptpNext->IsNode() && !ptpNext->IsEdgeScope() && ptpNext->IsBeginNode())
            {
                ptp = ptpNext;
                ptpNext = ptp->NextTreePos();
            }
        }
    }

    //
    // Make sure we're not positioned after a pointer
    //

    if (ptp->IsPointer())
    {
        while ( ptp->IsPointer() )
            ptp = ptp->PreviousTreePos();

        ich = ptp->IsText() ? ptp->Cch() : 0;
    }
    
    //
    // Make sure were no in the middle of a noscope
    //

    if (ptp->IsNode() && ptp->IsBeginElementScope() &&
        ptp->Branch()->Element()->IsNoScope())
    {
        ptp = ptp->Branch()->GetEndPos();
    }

    //
    //
    //
    
    Assert( ptp->IsNode() || ptp->IsText() );
    Assert( ich >= 0 && ich <= ptp->GetCch() );
    Assert( pMarkup == ptp->GetMarkup() );

    hr = THR( MoveToReference( ptp, ich, pMarkup, -1 ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

//
// GetBookmark/MoveToBookmark stuff - these are mainly pass-thrus to 
//  functions on CTxtPtr.
//

HRESULT
CMarkupPointer::MoveToBookmark ( BSTR bstrBookmark, CMarkupPointer * pEnd )
{
    HRESULT   hr = S_OK;
    CMarkup * pMarkup;

    Validate();
            
    Assert( pEnd );
    Assert( IsPositioned() );

    pMarkup = Markup();

    {
        CTxtPtr tpLeft ( pMarkup );
        CTxtPtr tpRight ( tpLeft );
        
        hr = THR( tpLeft.MoveToBookmark( bstrBookmark, & tpRight ) );

        if (hr)
            goto Cleanup;

        hr = THR( MoveToCp( tpLeft._cp, pMarkup ) );

        if (hr)
            goto Cleanup;
    
        hr = THR( pEnd->MoveToCp( tpRight._cp, pMarkup ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}


HRESULT
CMarkupPointer::GetBookmark ( BSTR * pbstrBookmark, CMarkupPointer * pEnd )
{
    HRESULT   hr      = S_OK;
    CMarkup * pMarkup = Markup();
    long      cp      = GetCp();

    Validate();
            
    Assert( pEnd );
    Assert( IsPositioned() && pEnd->IsPositioned() );
    Assert( Markup() == pEnd->Markup() );
    Assert( pbstrBookmark );

    {
        CTxtPtr tpThis ( pMarkup, cp );
        CTxtPtr tpEnd ( tpThis );
        
        tpEnd.SetCp( pEnd->GetCp() );

        hr = THR( tpThis.GetBookmark( pbstrBookmark, & tpEnd ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::IsAtWordBreak( BOOL * pfAtBreak )
{
    HRESULT     hr       = S_OK;

    Assert( pfAtBreak );
    Assert( IsPositioned() );

    if( !pfAtBreak || !IsPositioned() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    {
        CTxtPtr tp( Markup(), GetCp() );

        *pfAtBreak = tp.IsAtWordBreak();
    }

Cleanup:
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::GetMarkupPosition( long * plMP )
{
    HRESULT hr  = S_OK;

    Assert( plMP );

    if( !plMP )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( !IsPositioned() )
    {
        *plMP = -1;
    }
    else
    {
        *plMP = GetCp();
    }

Cleanup:
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::MoveToMarkupPosition( IMarkupContainer * pContainer, long lMP )
{
    HRESULT     hr;
    CMarkup *   pMarkup = NULL;

    // If they didn't give us a container, we need to be positioned.
    // Otherwise, the container had better be valid.
    if( ( !pContainer && !IsPositioned() ) || ( pContainer && !_pDoc->IsOwnerOf( pContainer ) ) )
    {
        AssertSz( FALSE, "Bogus arguments for MoveToMarkupPosition" );

        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( pContainer )
    {
        hr = THR( pContainer->QueryInterface( CLSID_CMarkup, (void **)&pMarkup ) );
        if( hr )
        {
            AssertSz( FALSE, "Non-Markup passed to MoveToMarkupPosition" );

            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else
    {
        pMarkup = Markup();
    }

    // If they gave us -1, unposition the pointer
    if( lMP == -1 )
    {
        hr = THR( Unposition() );
        if( hr )
            goto Cleanup;
    }
    else
    {
        if( lMP < 1 || lMP >= pMarkup->Cch() )
        {
            AssertSz( FALSE, "Bogus MP for MoveToMarkupPosition" );

            hr = E_INVALIDARG;
            goto Cleanup;
        }


        hr = THR( MoveToCp( lMP, pMarkup ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::MoveToContent( IHTMLElement* pIElement, BOOL fAtStart )
{
    HRESULT hr ;
    CElement* pContentElement = NULL;
    
    Assert( pIElement );

    if ( ! pIElement )
    {   
        hr = E_INVALIDARG;
        goto Cleanup;
    }   
    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void**) & pContentElement ));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pContentElement->IsInMarkup())
    {
        hr = CTL_E_UNPOSITIONEDELEMENT;
        goto Cleanup;
    }
    

    if ( pContentElement->HasSlavePtr())
    {
        pContentElement = pContentElement->GetSlavePtr();
    }
    
    Assert( pContentElement );

    hr = THR( MoveAdjacentToElement( pContentElement, 
                                     fAtStart ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ));

    
Cleanup:
    RRETURN( hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\treepos.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_NOTIFY_HXX_
#define X_NOTIFY_HXX_
#include "notify.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

DeclareTag(tagTreePosOps,"TreePos","TreePos operations");
DeclareTag(tagTreePosAccess, "TreePos", "TreePos access");
DeclareTag(tagTreePosSplay, "TreePos", "Rebalancing");
DeclareTag(tagTreePosValidate, "TreePos", "Aggressive validation");
DeclareTag(tagTreePosNoCount, "TreePos", "Don't validate counts");
DeclareTag(tagDontSplay, "TreePos", "Don't splay tree");

DeclareTag(tagNotify,     "Notify",     "Trace notifications");
DeclareTag(tagNotifyPath, "NotifyPath", "Trace notification send");

MtDefine(CTreePos, Tree, "CTreePos");
MtDefine(CTreeDataPos, Tree, "CTreeDataPos");
MtDefine(CMarkup_pvPool, CMarkup, "CMarkup::_pvPool")
MtDefine(CChildIterator, Tree, "CChildIterator");

#pragma warning(disable:4706) /* assignment within conditional expression */

MtDefine(CDocExtra, Mem, "CDocExtra")
MtDefine(CAryNotify_aryANotification_pv, CDocExtra, "CDocExtra::_aryANotification::_pv")

// allocate this many CTreePos objects at a time
static const size_t s_cTreePosPoolSize = 64;

// splay when accessing something deeper than this
static const long s_cSplayDepth = 10;

// The tree pos SN pool
#if DBG == 1 || defined(DUMPTREE)
int CTreePos::s_NextSerialNumber = 0;
#endif

inline BOOL
CMarkup::ShouldSplay(long cDepth) const
{
    WHEN_DBG( if( IsTagEnabled( tagDontSplay ) ) return FALSE; );
    return cDepth > 4 && (cDepth > 30 || (0x1<<cDepth) > NumElems());
}

/////////////////////////////////////////////////////////////////////////
//          CTreePos
/////////////////////////////////////////////////////////////////////////

inline void
CTreePos::ClearCounts()
{
    SetElemLeft( 0 );
    _cchLeft = 0;
}

inline void
CTreePos::IncreaseCounts(const CTreePos *ptp, unsigned fFlags)
{
    if (fFlags & TP_LEFT)
    {
        AdjElemLeft(ptp->GetElemLeft());
        _cchLeft += ptp->_cchLeft;
    }
    if (fFlags & TP_DIRECT)
    {
        if (ptp->IsNode())
        {
            if( ptp->IsEdgeScope() )
            {
                _cchLeft += 1;
                if( ptp->IsBeginNode() )
                {
                    AdjElemLeft(1);
                }
            }
        }
        else if (ptp->IsText())
        {
            _cchLeft += ptp->Cch();
        }
    }
}

inline void
CTreePos::IncreaseCounts(const SCounts *pCounts )
{
    AdjElemLeft( pCounts->_cElem );
    _cchLeft += pCounts->_cch;
}

inline void
CTreePos::DecreaseCounts(const CTreePos *ptp, unsigned fFlags)
{
    if (fFlags & TP_LEFT)
    {
        AdjElemLeft(-ptp->GetElemLeft());
        _cchLeft -= ptp->_cchLeft;
    }
    if (fFlags & TP_DIRECT)
    {
        if (ptp->IsNode())
        {
            if( ptp->IsEdgeScope() )
            {
                _cchLeft -= 1;
                if( ptp->IsBeginNode() )
                {
                    AdjElemLeft( -1 );
                }
            }
        }
        else if (ptp->IsText())
        {
            _cchLeft -= ptp->Cch();
        }
    }
}


// functions for CTreePos::SCounts
inline void
CTreePos::SCounts::Clear()
{
    _cch = 0;
    _cElem = 0;
}


inline void
CTreePos::SCounts::Increase( const CTreePos * ptp )
{
    if (ptp->IsNode())
    {
        if( ptp->IsEdgeScope() )
        {
            _cch++;
            if( ptp->IsBeginNode() )
            {
                _cElem++;
            }
        }
    }
    else if (ptp->IsText())
    {
        _cch += ptp->Cch();
    }
}

inline BOOL
CTreePos::SCounts::IsNonzero()
{
    return _cElem  || _cch;
}


void
CTreePos::InitSublist()
{
    SetFirstChild(NULL);
    SetNext(NULL);
    MarkLast();
    MarkRight();        // this distinguishes a sublist from a splay tree root
    ClearCounts();
#if defined(MAINTAIN_SPLAYTREE_THREADS)
    SetLeftThread(NULL);
    SetRightThread(NULL);
#endif
}


inline void
CTreePos::ReplaceOrRemoveChild(CTreePos *pOld, CTreePos *pNew)
{
    if (pNew)
        ReplaceChild(pOld, pNew);
    else
        RemoveChild(pOld);
}


BOOL
CTreePos::HasNonzeroCounts(unsigned fFlags)
{
    BOOL result = FALSE;

    if (fFlags & TP_DIRECT)
    {
        Assert( !IsUninit() );
        result = result || !IsPointer();
    }

    if (fFlags & TP_LEFT)
    {
        result = result || GetElemLeft() > 0 || _cchLeft > 0;
    }

    return result;
}


#if DBG==1

inline BOOL
CTreePos::EqualCounts(const CTreePos *ptp) const
{
    return  GetElemLeft() == ptp->GetElemLeft() &&
            _cchLeft == ptp->_cchLeft;
}


BOOL
CTreePos::IsSplayValid(CTreePos *ptpTotal) const
{
    BOOL fIsValid = TRUE;
    CTreePos *ptpLeft, *ptpRight;
    const CTreePos *ptpFail = NULL;   // marks where we ran out of stack or memory
    const CTreePos *ptpCurr = this;
    enum { VISIT_FIRST, VISIT_MIDDLE, VISIT_LAST} state = VISIT_FIRST;
    CStackPtrAry<CTreePos*, 32> aryTreePosStack(Mt(Mem));
#define PUSH(stack, item)   stack.Append(item)
#define POP(stack)          stack[stack.Size()-1]; stack.Delete(stack.Size()-1)

    if( !IsTagEnabled( tagTreePosNoCount ) )
        ptpTotal->ClearCounts();

    while (fIsValid && ptpCurr)
    {
        switch (state)
        {
        case VISIT_FIRST:
            ptpCurr->GetChildren(&ptpLeft, &ptpRight);

            // verify structure
            if (ptpLeft)
            {
                
                fIsValid = fIsValid && ptpLeft->IsLeftChild() &&
                                    ptpLeft->Parent() == ptpCurr;
                Assert(fIsValid);
            }
            if (ptpRight)
            {
                fIsValid = fIsValid && !ptpRight->IsLeftChild() &&
                                    ptpRight->IsLastChild() &&
                                    ptpRight->Parent() == ptpCurr;
                Assert(fIsValid);
            }

            if( !IsTagEnabled( tagTreePosNoCount ) )
            {
                // push accumulated total onto the stack
                if (ptpFail == NULL)
                {
                    if (S_OK == PUSH(aryTreePosStack, ptpTotal))
                    {
                        ptpTotal = new CTreePos(TRUE);
                        if (ptpTotal == NULL)
                        {
                            ptpTotal = POP(aryTreePosStack);
                            ptpFail = ptpCurr;
                        }
                    }
                    else
                    {
                        ptpFail = ptpCurr;
                    }
                }
            }

            // advance into left subtree
            if (ptpLeft)
                ptpCurr = ptpLeft;
            else
                state = VISIT_MIDDLE;
            break;

        case VISIT_MIDDLE:

            if( !IsTagEnabled( tagTreePosNoCount ) )
            {
                // compare true count from left subtree with count in current node,
                // then pop the stack
                if (ptpFail == NULL)
                {
                    fIsValid = fIsValid && ptpCurr->EqualCounts(ptpTotal);
                    Assert(fIsValid);
                    delete ptpTotal;
                    ptpTotal = POP(aryTreePosStack);
                }

                // accumulate counts
                ptpTotal->IncreaseCounts(ptpCurr, ptpFail ? TP_DIRECT : TP_BOTH);
            }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
            // check the threads
            fIsValid = fIsValid &&
                        (ptpCurr->LeftThread() == NULL ||
                         ptpCurr->LeftThread()->RightThread() == ptpCurr);
            fIsValid = fIsValid &&
                        (ptpCurr->RightThread() == NULL ||
                         ptpCurr->RightThread()->LeftThread() == ptpCurr);
            Assert(fIsValid);
#endif

            // advance into right subtree
            ptpRight = ptpCurr->RightChild();
            if (ptpRight)
                ptpCurr = ptpRight, state = VISIT_FIRST;
            else
                state = VISIT_LAST;
            break;

        case VISIT_LAST:
            // advance to parent
            if (ptpCurr == ptpFail)
            {
                ptpFail = NULL;
            }
            state = ptpCurr->IsLeftChild() ? VISIT_MIDDLE : VISIT_LAST;
            ptpCurr = (ptpCurr == this) ? NULL : ptpCurr->Parent();
            break;
        }
    }

    Assert(!fIsValid || aryTreePosStack.Size() == 0);
    fIsValid = fIsValid && aryTreePosStack.Size() == 0;

    aryTreePosStack.DeleteAll();

    return fIsValid;
}

#endif


#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

void
CTreePos::GetChildren(CTreePos **ppLeft, CTreePos **ppRight) const
{
    if (FirstChild())
    {
        if (FirstChild()->IsLeftChild())
        {
            Assert(     (   FirstChild()->IsLastChild()     // Either just a left child, 
                         && FirstChild()->Next() == this )  // who's parent is me, or
                    ||  (   FirstChild()->Next()->IsLastChild()         // His next is the last child
                         &&!FirstChild()->Next()->IsLeftChild()         // NOT a left child
                         && FirstChild()->Next()->Next() == this ) );   // and his parent is me.
            *ppLeft = FirstChild();
            *ppRight = (FirstChild()->IsLastChild()) ? NULL : FirstChild()->Next();
        }
        else
        {
            Assert(     FirstChild()->IsLastChild() 
                    &&  FirstChild()->Next() == this );

            *ppLeft = NULL;
            *ppRight = FirstChild();
        }
    }
    else
    {
        *ppLeft = *ppRight = NULL;
    }
}


HRESULT
CTreePos::Remove()
{
    Assert(!HasNonzeroCounts(TP_DIRECT));    // otherwise we need to adjust counts to the root
    CTreePos *pLeft, *pRight, *pParent=Parent();

    GetChildren(&pLeft, &pRight);

    if (pLeft == NULL)
    {
        pParent->ReplaceOrRemoveChild(this, pRight);
    }
    else
    {
        while (pRight)
        {
            Assert( pParent == Parent() );

            pRight->RotateUp(this, pParent);
            pParent = pRight;       // Old right child is now parent
            pRight = RightChild();
        }
        Assert( pParent == Parent() );
        pParent->ReplaceChild(this, pLeft);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    if (LeftThread())
        LeftThread()->SetRightThread(RightThread());
    if (RightThread())
        RightThread()->SetLeftThread(LeftThread());
    SetLeftThread(NULL);
    SetRightThread(NULL);
#endif

    return S_OK;
}


CTreePos *
CTreePos::LeftmostDescendant() const
{
    const CTreePos *ptp = this;
    const CTreePos *ptpLeft = FirstChild();

    while (ptpLeft && ptpLeft->IsLeftChild())
    {
        ptp = ptpLeft;
        ptpLeft = ptp->FirstChild();
    }

    return const_cast<CTreePos *>(ptp);
}


CTreePos *
CTreePos::RightmostDescendant() const
{
    CTreePos *ptp = const_cast<CTreePos*>(this);
    CTreePos *ptpRight = RightChild();

    while (ptpRight)
    {
        ptp = ptpRight;
        ptpRight = ptp->RightChild();
    }

    return ptp;
}


#if DBG==1
long
CTreePos::Depth() const
{
    long cDepth=0;
    const CTreePos *ptp;

    for (ptp=this; ptp; ptp=ptp->Parent())
    {
        ++ cDepth;
    }

    return cDepth-2;
}
#endif


CMarkup *
CTreePos::GetMarkup()
{
    CTreePos *ptp=this, *ptpParent=Parent();

    while (ptpParent)
    {
        ptp = ptpParent;
        ptpParent = ptp->Parent();
    }

    AssertSz(!ptp->IsLeftChild(), "GetList called when not in a CMarkup");
    return ptp->IsLeftChild() ? NULL
                              : CONTAINING_RECORD(ptp, CMarkup, _tpRoot);
}

CTreePos *
CTreePos::PreviousTreePos()
{
    CTreePos *ptp = this;
    
    // Do we have a left child?
    if (ptp->FirstChild() && ptp->FirstChild()->IsLeftChild())
    {
        // Rightmost descendent for ptp->LeftChild()
    Loop:
        ptp = ptp->FirstChild();
        
        while (ptp->FirstChild())
        {
            if (!ptp->FirstChild()->IsLeftChild())
                goto Loop;
            
            if (ptp->FirstChild()->IsLastChild())
            {
                Assert(ptp == _ptpThreadLeft); // MAINTAIN_SPLAYTREE_THREADS
                return ptp;
            }
                
            ptp = ptp->FirstChild()->Next();
        }

        Assert(ptp == _ptpThreadLeft); // MAINTAIN_SPLAYTREE_THREADS
        return ptp;
    }
    
    // No left child
    while (ptp->IsLeftChild())
    {
        // ptp = ptp->Parent() -- inlined here
        if (ptp->IsLastChild())
            ptp = ptp->Next();
        else
            ptp = ptp->Next()->Next();

        // Root pos (marked as right child) protects us from NULL
    }
            
    // ptp = ptp->Parent() (we know ptp is a right (and last) child)
    ptp = ptp->Next();

    Assert(ptp == _ptpThreadLeft); // MAINTAIN_SPLAYTREE_THREADS
    return ptp;
}

CTreePos *
CTreePos::NextTreePos()
{
    CTreePos *ptp;
    
    if (!FirstChild())
        goto Up;

    if (!FirstChild()->IsLeftChild())
    {
        ptp = FirstChild();
        goto Right;
    }

    if (FirstChild()->IsLastChild())
        goto Up;
    
    ptp = FirstChild()->Next();

Right:

    // Leftmost descendent

    while (ptp->FirstChild() && ptp->FirstChild()->IsLeftChild())
        ptp = ptp->FirstChild();

    Assert(ptp == _ptpThreadRight); // MAINTAIN_SPLAYTREE_THREADS
    return ptp;
    
Up:

    for (ptp = this; !ptp->IsLeftChild(); ptp = ptp->Next());

    ptp = ptp->Parent();
    
    if (ptp->Next() == NULL)
    {
        Assert(NULL == _ptpThreadRight); // MAINTAIN_SPLAYTREE_THREADS
        return NULL;
    }

    Assert(ptp == _ptpThreadRight); // MAINTAIN_SPLAYTREE_THREADS
    return ptp;
}
        

CTreePos *
CTreePos::NextValidNonPtrInterLPos()
{
    CTreePos *ptp = this;

    do
    {
        ptp = ptp->NextValidInterLPos();
    }
    while (ptp && ptp->IsPointer());

    return ptp;
}

CTreePos *
CTreePos::PreviousValidNonPtrInterLPos()
{
    CTreePos *ptp = this;

    do
    {
        ptp = ptp->PreviousValidInterLPos();
    }
    while (ptp && ptp->IsPointer());

    return ptp;
}

CTreePos *
CTreePos::NextNonPtrTreePos()
{
    CTreePos * ptp = this;

    do
    {
        ptp = ptp->NextTreePos();
    }
    while ( ptp && ptp->IsPointer() );

    return ptp;
}

CTreePos *
CTreePos::PreviousNonPtrTreePos()
{
    CTreePos * ptp = this;

    do
    {
        ptp = ptp->PreviousTreePos();
    }
    while ( ptp && ptp->IsPointer() );

    return ptp;
}

// NOTE (SamBent): deprecated.  use CTreePosGap::IsValid()
BOOL
CTreePos::IsLegalPosition(CTreePos *ptpLeft, CTreePos *ptpRight)
{
    // use the marks to determine if content is allowed between the inputs
    return (!ptpLeft->IsNode() || !ptpRight->IsNode() ||
             !( (ptpLeft->IsEndNode() && !ptpLeft->IsEdgeScope()) ||
                (ptpRight->IsBeginNode() && !ptpRight->IsEdgeScope()) ) );
}

CTreePos *
CTreePos::FindLegalPosition(BOOL fBefore)
{
    CTreePos *ptpCur, *ptpAdvance;
    CTreePos * (CTreePos::*pAdvanceFn)(void);

    // select the member function we use to advance
    pAdvanceFn = fBefore ? &CTreePos::PreviousTreePos : &CTreePos::NextTreePos;

    // advance to a legal position, or the end of the list
    ptpAdvance = this;
    do
    {
        ptpCur = ptpAdvance;
        ptpAdvance = (ptpAdvance->*pAdvanceFn)();
    }
    while (ptpAdvance &&
            ( fBefore ? !IsLegalPosition(ptpAdvance, ptpCur)
                      : !IsLegalPosition(ptpCur, ptpAdvance) ));

    return ptpAdvance ? ptpCur : NULL;
}

BOOL
CTreePos::ShowTreePos(CGlyphRenderInfoType *pRenderInfo)
{
    BOOL fRet;

    // 1) We can only show edge scopes
    // 2) We can only show explicit end tags
    if (   IsEdgeScope()
        &&  (  !IsEndNode()
             || Branch()->Element()->_fExplicitEndTag
            )
       )
    {
        CGlyphRenderInfoType renderInfo;
        if (pRenderInfo == NULL)
            pRenderInfo = &renderInfo;
        pRenderInfo->pImageContext = NULL;
        fRet = Branch()->GetMarkup()->GetTagInfo(this, GAT_COMPUTE, GPT_COMPUTE, GOT_COMPUTE, NULL, pRenderInfo) == S_OK;
        fRet = fRet && pRenderInfo->HasInfo();
    }
    else
        fRet = FALSE;
    return fRet;
}

CTreeNode *
CTreePos::SearchBranchForElement(CElement *pElement, BOOL fLeft)
{
    Assert(pElement);
    CTreePos *ptpLeft, *ptpRight;
    CTreeNode *pNode;

    // start at the requested gap
    if (fLeft)
    {
        ptpLeft = PreviousTreePos(),  ptpRight = this;
    }
    else
    {
        ptpLeft = this,  ptpRight = NextTreePos();
    }

    // move right to a valid gap (invalid gaps may give too high a scope)
    while (!IsLegalPosition(ptpLeft, ptpRight))
    {
        // but stop if we stumble across the element we're looking for
        if (ptpRight->IsNode() && ptpRight->Branch()->Element() == pElement)
        {
            return ptpRight->Branch();
        }

        ptpLeft = ptpRight;
        ptpRight = ptpLeft->NextTreePos();
    }

    // now search for a nearby node
    if (ptpLeft->IsNode())
    {
        pNode = ptpLeft->IsBeginNode() ? ptpLeft->Branch()
                                       : ptpLeft->Branch()->Parent();
    }
    else
    {
        while (!ptpRight->IsNode())
        {
            ptpRight = ptpRight->NextTreePos();
        }
        pNode = ptpRight->IsBeginNode() ? ptpRight->Branch()->Parent()
                                        : ptpRight->Branch();
    }

    // finally, look for the element along this node's branch
    for ( ; pNode; pNode = pNode->Parent())
    {
        if (pNode->Element() == pElement)
        {
            return pNode;
        }
    }

    return NULL;
}


long
CTreePos::SourceIndex()
{
    CTreePos *ptp;
    long cSourceIndex = GetElemLeft();
    BOOL fLeftChild = IsLeftChild();
    long cDepth = -1;
    CMarkup *pMarkup;
    CTreePos *pRoot = NULL;

    for (ptp = Parent();  ptp;  ptp = ptp->Parent())
    {
        if (!fLeftChild)
        {
            cSourceIndex += ptp->GetElemLeft() + (ptp->IsBeginElementScope()? 1: 0);
        }
        fLeftChild = ptp->IsLeftChild();

        ++cDepth;
        pRoot = ptp;
    }

    pMarkup = CONTAINING_RECORD(pRoot, CMarkup, _tpRoot);

    TraceTag((tagTreePosAccess, "%p: SourceIndex %ld  depth %ld",
            pMarkup, cSourceIndex, cDepth));

    if (pMarkup->ShouldSplay(cDepth))
    {
        Splay();
    }

    return cSourceIndex;
}

//
// Retunrs TRUE if this and ptpRight are separated only by
// pointers or empty text positions.  ptpRight must already
// be to the right of this.
//

BOOL
CTreePos::LogicallyEqual ( CTreePos * ptpRight )
{
    Assert( InternalCompare( ptpRight ) <= 0 );

    for ( CTreePos * ptp = this ;
          ptp->IsPointer() || (ptp->IsText() && ptp->Cch() == 0) ;
          ptp = ptp->NextTreePos() )
    {
        if (ptp == ptpRight)
            return TRUE;
    }

    return FALSE;
}
            
//
// Returns (not logically)
//
//   -1: this <  that
//    0: this == that
//   +1: this >  that
//

int
CTreePos::InternalCompare ( CTreePos * ptpThat )
{
    Assert( GetMarkup() && ptpThat->GetMarkup() == GetMarkup() );

    if (this == ptpThat)
        return 0;

    static long cSplayThis = 0;
    
    if (cSplayThis++ & 1)
    {
        CTreePos * ptpThis = this;

        ptpThis->Splay();

        for ( ; ; )
        {
            CTreePos * ptpChild = ptpThat;

            ptpThat = ptpThat->Parent();

            if (ptpThat == ptpThis)
                return ptpChild->IsLeftChild() ? +1 : -1;
        }
    }
    else
    {
        CTreePos * ptpThis = this;

        ptpThat->Splay();

        for ( ; ; )
        {
            CTreePos * ptpChild = ptpThis;

            ptpThis = ptpThis->Parent();

            if (ptpThis == ptpThat)
                return ptpChild->IsLeftChild() ? -1 : +1;
        }
    }
}

CTreeNode *
CTreePos::GetBranch ( ) const
{
    CTreePos * ptp = const_cast < CTreePos * > ( this );

    if (ptp->IsNode())
        return ptp->Branch();

    while ( ! ptp->IsNode() )
    {
        if (ptp->IsPointer() && ptp->GetWhitespaceParent())
        {
#if DBG==1
            CTreeNode *pWhitespaceParent = ptp->GetWhitespaceParent();

            while (!ptp->IsNode())
                ptp = ptp->PreviousTreePos();

            if (ptp->IsBeginNode())
            {
                Assert(ptp->Branch() == pWhitespaceParent );
            }
            else
            {
                Assert(ptp->Branch()->Parent() == pWhitespaceParent );
            }
            return pWhitespaceParent;
#else
            return ptp->GetWhitespaceParent();
#endif
        }
        ptp = ptp->PreviousTreePos();
    }

    Assert( ptp && (ptp->IsBeginNode() || ptp->IsEndNode()) );

    return ptp->IsBeginNode() ? ptp->Branch() : ptp->Branch()->Parent();
}

CTreeNode *
CTreePos::GetInterNode ( ) const
{
    CTreePos * ptp = const_cast < CTreePos * > ( this );

    while ( ! ptp->IsNode() )
        ptp = ptp->PreviousTreePos();

    Assert( ptp && (ptp->IsBeginNode() || ptp->IsEndNode()) );

    return ptp->IsBeginNode() ? ptp->Branch() : ptp->Branch()->Parent();
}

long
CTreePos::GetCp( WHEN_DBG(BOOL fNoTrace) )
{
    CTreePos *ptp;
    long cch = _cchLeft;
    BOOL fLeftChild = IsLeftChild();
    long cDepth = -1;
    CMarkup *pMarkup;
    CTreePos *pRoot = NULL;

    for (ptp = Parent();  ptp;  ptp = ptp->Parent())
    {
        if (!fLeftChild)
            cch += ptp->_cchLeft + ptp->GetCch();
        
        fLeftChild = ptp->IsLeftChild();

        ++cDepth;
        pRoot = ptp;
    }

    pMarkup = CONTAINING_RECORD(pRoot, CMarkup, _tpRoot);
    
#if DBG==1
    if (!fNoTrace)
    {
        TraceTag((tagTreePosAccess, "%p: GetCp cp %ld  depth %ld",
                pMarkup, cch, cDepth));
    }
#endif

    if ( WHEN_DBG( !fNoTrace && ) pMarkup->ShouldSplay(cDepth))
        Splay();

    return cch;
}

int
CTreePos::Gravity() const
{
    Assert( IsPointer() );
    return DataThis()->p._dwPointerAndGravityAndCling & 0x1;
}

void
CTreePos::SetGravity ( BOOL fRight )
{
    Assert( IsPointer() );

    DataThis()->p._dwPointerAndGravityAndCling =
        (DataThis()->p._dwPointerAndGravityAndCling & ~1) | (!!fRight);
}

int
CTreePos::Cling() const
{
    Assert( IsPointer() );
    return !!(DataThis()->p._dwPointerAndGravityAndCling & 0x2);
}

void
CTreePos::SetCling ( BOOL fStick )
{
    Assert( IsPointer() );

    DataThis()->p._dwPointerAndGravityAndCling =
        (DataThis()->p._dwPointerAndGravityAndCling & ~2) | (fStick ? 2 : 0);
}

void
CTreePos::SetScopeFlags(BOOL fEdge)
{
    long cElemDelta = IsBeginElementScope()? -1 : 0;
    long cchDelta = IsEdgeScope()? -1 : 0;

    SetFlags((GetFlags() & ~TPF_EDGE) | BOOLFLAG(fEdge, TPF_EDGE));

    if (IsBeginElementScope())
    {
        cElemDelta += 1;
    }

    if (IsEdgeScope())
    {
        cchDelta += 1;
    }

    if (cElemDelta != 0 || cchDelta != 0)
    {
        CTreePos *ptp;
        BOOL fLeftChild = IsLeftChild();

        for (ptp=Parent(); ptp; ptp = ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->AdjElemLeft(cElemDelta);
                ptp->_cchLeft += cchDelta;
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }
}


void
CTreePos::ChangeCch(long cchDelta)
{
    BOOL fLeftChild = IsLeftChild();
    CTreePos *ptp;
#if DBG==1
    CTreePos *pRoot = NULL;
    CMarkup *pMarkup;
    long cDepth = -1;
#endif

    Assert( IsText() );

    DataThis()->t._cch += cchDelta;

    for (ptp=Parent(); ptp; ptp = ptp->Parent())
    {
        if (fLeftChild)
            ptp->_cchLeft += cchDelta;
        
        fLeftChild = ptp->IsLeftChild();

        WHEN_DBG( ++cDepth; )
        WHEN_DBG( pRoot = ptp; )
    }

    WHEN_DBG( pMarkup = CONTAINING_RECORD(pRoot, CMarkup, _tpRoot); )
    TraceTag((tagTreePosOps, "%p: ChangeCch by %ld to %ld", pMarkup, cchDelta, Cch()));
    TraceTag((tagTreePosAccess, "%p: ChangeCch depth %ld", pMarkup, cDepth));
}

//+----------------------------------------------------------------+
//
//  Method: MakeNonEdge
//
//  Synopsis: Turns an end node pos into a non-edge end node
//      pos, while updating all the statistics in the splay tree.
//      Can be called on a non-edge node pos, in which case it's a
//      no-op
//
//+----------------------------------------------------------------+

void
CTreePos::MakeNonEdge()
{
    Assert( IsEndNode() );

    // Already non-edge, so we're done.
    if( !IsEdgeScope() )
        return;

    SetScopeFlags( FALSE );
}


void
CTreePos::Splay()
{
    CTreePos *p=Parent(), *g=p->Parent(), *gg;   // parent, grandparent, great-grandparent
#if DBG==1
    long nZigZig=0, nZigZag=0, nZig=0;
    CMarkup *pMarkup;
#endif

    for (; g; p=Parent(), g=p->Parent())
    {
        gg = g->Parent();

        if (gg)
        {
            if (IsLeftChild() == p->IsLeftChild())      // zig-zig
            {
                p->RotateUp(g, gg);
                RotateUp(p, gg);
                WHEN_DBG( ++ nZigZig; )
            }
            else                                    // zig-zag
            {
                RotateUp(p, g);
                RotateUp(g, gg);
                WHEN_DBG( ++ nZigZag; )
            }
        }
        else                                        // zig
        {
            RotateUp(p, g);
            WHEN_DBG( ++ nZig; )
        }
    }

    WHEN_DBG( pMarkup = CONTAINING_RECORD(p, CMarkup, _tpRoot); )
    TraceTag((tagTreePosSplay, "%p: Splay  depth=%ld (%ld, %ld, %ld)",
                pMarkup, 2*(nZigZig+nZigZag) + nZig, nZigZig, nZigZag, nZig));

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
    {
        CTreePos tpValid(TRUE);
        Assert(IsSplayValid(&tpValid));
    }
#endif
}


void
CTreePos::RotateUp(CTreePos *p, CTreePos *g)
{
    CTreePos *ptp1, *ptp2, *ptp3;

    Assert( Parent() == p && Parent()->Parent() == g );

    if (IsLeftChild())                    // rotate right
    {
        GetChildren(&ptp1, &ptp2);
        ptp3 = p->RightChild();
        g->ReplaceChild(p, this);

        // recreate my family
        if (ptp1)
        {
            ptp1->MarkFirst();
            ptp1->SetNext(p);
        }
        else
        {
            SetFirstChild(p);
        }

        // recreate p's family
        if (ptp2)
        {
            p->SetFirstChild(ptp2);
            ptp2->MarkLeft();
            if (ptp3)
            {
                ptp2->MarkFirst();
                ptp2->SetNext(ptp3);
            }
            else
            {
                ptp2->MarkLast();
                ptp2->SetNext(p);
            }
        }
        else
        {
            p->SetFirstChild(ptp3);
        }
        p->MarkRight();
        p->MarkLast();
        p->SetNext(this);

        // adjust cumulative counts
        p->DecreaseCounts(this, TP_BOTH);
    }

    else                                    // rotate left
    {
        ptp1 = p->LeftChild();
        GetChildren(&ptp2, &ptp3);
        g->ReplaceChild(p, this);

        // recreate my family
        SetFirstChild(p);
        p->MarkLeft();
        if (ptp3)
        {
            p->MarkFirst();
            p->SetNext(ptp3);
        }
        else
        {
            p->MarkLast();
            p->SetNext(this);
        }

        // recreate p's family
        if (ptp1)
        {
            if (ptp2)
            {
                ptp1->MarkFirst();  // CONSIDER (SamBent): not needed?
                ptp1->SetNext(ptp2);
            }
            else
            {
                ptp1->MarkLast();
                ptp1->SetNext(p);
            }
        }
        else
        {
            p->SetFirstChild(ptp2);
        }
        if (ptp2)
        {
            ptp2->MarkRight();
            ptp2->MarkLast();
            ptp2->SetNext(p);
        }

        // adjust cumulative counts
        IncreaseCounts(p, TP_BOTH);
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
    {
        CTreePos tpValid(TRUE);
        Assert(g->IsSplayValid(&tpValid));
    }
#endif
}


void
CTreePos::ReplaceChild(CTreePos *pOld, CTreePos *pNew)
{
    Assert( pOld->Parent() == this );

    pNew->MarkLeft(pOld->IsLeftChild());
    pNew->MarkLast(pOld->IsLastChild());
    pNew->SetNext(pOld->Next());

    if (FirstChild() == pOld)
        SetFirstChild(pNew);
    else
        FirstChild()->SetNext(pNew);
}


void
CTreePos::RemoveChild(CTreePos *pOld)
{
    Assert( pOld->Parent() == this );

    if (FirstChild() == pOld)
    {
        SetFirstChild(pOld->IsLastChild() ? NULL : pOld->Next());
    }
    else
    {
        FirstChild()->MarkLast();
        FirstChild()->SetNext(this);
    }
}


/////////////////////////////////////////////////////////////////////////
//          CMarkup stuff
/////////////////////////////////////////////////////////////////////////

HRESULT
CMarkup::DestroySplayTree( BOOL fReinit )
{
    HRESULT     hr = S_OK;
    CTreePos *  ptp, *ptpNext;
    CTreeNode * pDelayReleaseList = NULL;
    CTreeNode * pExitTreeScList = NULL;
    CNotification   nfExit;
    CRootElement * pElementRoot = Root();
    BOOL        fIsConnectedToPrimary = pElementRoot ? pElementRoot->IsConnectedToPrimaryMarkup() : FALSE;

    // Prime the exittree notification
    nfExit.ElementExittree1(NULL);
    Assert( nfExit.IsSecondChanceAvailable() );

    //
    // Unposition any unembedded markup pointers.  Because there is
    // no pointer pos for these pointers, they will not get notified.
    //

    while ( _pmpFirst )
    {
        hr = THR( _pmpFirst->Unposition() );

        if (hr)
            goto Cleanup;
    }
            
    //
    // The walk used here is destructive.  This is needed
    // because once a CTreePos is released (via ReleaseContents)
    // we can't use it any more.  So before we release a pos,
    // we short circuit other pointers in the tree to not point
    // to it any more.  This way, we only visit (and release) each
    // node only once.
    //

    // set a sentinel value to make the traversal end properly
    if (_tpRoot.FirstChild())
    {
        _tpRoot.FirstChild()->SetNext( NULL );
    }

    // release the tree
    for (ptp=_tpRoot.FirstChild(); ptp; )
    {
        // figure out the next to be deleted
        if (ptp->FirstChild())
        {
            ptpNext = ptp->FirstChild();

            // this is the short circuit
            if( ptpNext->IsLastChild() )
            {
                ptpNext->SetNext( ptp->Next() );
            }
            else
            {
                Assert( ptpNext->Next()->IsLastChild() );
                ptpNext->Next()->SetNext( ptp->Next() );
            }
        }
        else
        {
            ptpNext = ptp->Next();
        }

        if( ptp->IsNode() )
        {
            CTreeNode *     pNode = ptp->Branch();

            ReleaseTreePos( ptp, TRUE );

            if (!pNode->_fInMarkupDestruction)
            {
                pNode->_fInMarkupDestruction = TRUE;
            }
            else
            {
                BOOL    fDelayRelease = FALSE;
                BOOL    fExitTreeSc = FALSE;

                if (pNode->IsFirstBranch())
                {
                    // Prepare and send the exit tree notification
                    CElement *      pElement = pNode->Element();
                    DWORD           dwData = EXITTREE_DESTROY ;
                    WHEN_DBG( BOOL fPassivatePending = FALSE );

                    if (fIsConnectedToPrimary)
                    {
                        dwData |= EXITTREE_DOSURFACECOUNT;
                    }

                    if( pElement->GetObjectRefs() == 1 )
                    {
                        dwData |= EXITTREE_PASSIVATEPENDING;
                        Assert( !pElement->_fPassivatePending );
                        WHEN_DBG( pElement->_fPassivatePending = TRUE );
                        WHEN_DBG( fPassivatePending = TRUE );
                    }

                    pElement->_fExittreePending = TRUE;

                    // NOTE: we may want to bump up the notification SN here
                    nfExit.SetNode( NULL );
                    nfExit.SetElement(pElement);
                    nfExit.SetData( dwData );
                    pElement->Notify(&nfExit);

                    pElement->_fExittreePending = FALSE;

                    // Check to see if we have to delay release
                    fDelayRelease = nfExit.DataAsDWORD() & EXITTREE_DELAYRELEASENEEDED;

                    // Check to see if we have to send ElementExittreeSc
                    fExitTreeSc = nfExit.IsSecondChanceRequested();

                    if (!fDelayRelease && !fExitTreeSc)
                    {
                        // The node is now no longer in the tree so release
                        // the tree's ref on the node
                        pNode->PrivateExitTree();
                    }
                    else
                    {
                        // We will use the node as an item on our delay release
                        // linked list.  Make it dead and use useless fields
                        pNode->PrivateMakeDead();
                        pNode->GetBeginPos()->_pNext = (CTreePos*)pDelayReleaseList;
                        pDelayReleaseList = pNode;
                        pElement->AddRef();

                        WHEN_DBG( pElement->_fDelayRelease = TRUE );
                        WHEN_DBG( pElement->_fPassivatePending = FALSE );
                        WHEN_DBG( fPassivatePending = FALSE );

                        // If we need an exit tree second chance, link it into that list.
                        if( fExitTreeSc )
                        {
                            pNode->GetBeginPos()->_pFirstChild = (CTreePos*)pExitTreeScList;
                            pExitTreeScList = pNode;

                            nfExit.ClearSecondChanceRequested();
                        }
                    }

                    // Remove the element from the tree
                    pElement->__pNodeFirstBranch = NULL;
                    pElement->DelMarkupPtr();
                    pElement->PrivateExitTree(this);

#if DBG==1
                    if (fDelayRelease)
                    {
                        pElement->_fPassivatePending = fPassivatePending;
                    }
#endif

                }
                else
                {
                    // The node is now no longer in the tree so release
                    // the tree's ref on the node
                    pNode->PrivateExitTree();
                }
            }
        }
        else
        {
            ReleaseTreePos( ptp, TRUE );
        }

        ptp = ptpNext;
    }

    // release all the TreePos pools
    while (_pvPool)
    {
        void *pvNextPool = *((void **)_pvPool);

        if (_pvPool != & (_abPoolInitial[0]))
        {
            MemFree(_pvPool);
        }
        _pvPool = pvNextPool;
    }

    memset( & _tpRoot, 0, sizeof( CTreePos ) );
    _ptpFirst = NULL;
    Assert( _pvPool == NULL );
    _ptdpFree = NULL;
    memset( &_abPoolInitial, 0, sizeof( _abPoolInitial ) );

    _tpRoot.MarkLast();
    _tpRoot.MarkRight();

    WHEN_DBG( _cchTotalDbg = 0 );
    WHEN_DBG( _cElementsTotalDbg = 0 );

    if (fReinit)
    {
        hr = CreateInitialMarkup( pElementRoot );
        if (hr)
        {
            goto Cleanup;
        }
    }

    // Release and delete the text frag context
    delete DelTextFragContext();
    delete DelTopElemCache();

    UpdateMarkupTreeVersion();

    // Send all of the exit tree second chance notifications that we need to
    if (pExitTreeScList)
    {
        nfExit.ElementExittree2( NULL );
    }

    while( pExitTreeScList )
    {
        CElement *      pElement = pExitTreeScList->Element();

        // Get the next link in the list
        pExitTreeScList = (CTreeNode*)pExitTreeScList->GetBeginPos()->_pFirstChild;

        // Send the after exit tree notifications
        // NOTE: we may want to bump up the notification SN here
        nfExit.SetNode( NULL );
        nfExit.SetElement( pElement );
        pElement->Notify(&nfExit);
    }

    // Release all of the elements (and nodes) on our delay release list
    while( pDelayReleaseList )
    {
        CElement * pElement = pDelayReleaseList->Element();
        CTreeNode *pNode = pDelayReleaseList;

        // Get the next link in the list
        pDelayReleaseList = (CTreeNode*)pDelayReleaseList->GetBeginPos()->_pNext;

        // Release the element
        Assert( pElement->_fDelayRelease );
        WHEN_DBG( pElement->_fDelayRelease = FALSE );
        Assert( !pElement->_fPassivatePending || pElement->GetObjectRefs() == 1 );
        pElement->Release();

        // Release any hold the markup has on the node
        pNode->PrivateMarkupRelease();
    }


Cleanup:
    RRETURN(hr);
}

#pragma optimize("", on)

#if DBG==1

BOOL
CMarkup::IsSplayValid() const
{
    CTreePos tpValid(TRUE);
    BOOL result = _tpRoot.IsSplayValid(&tpValid);

    if (result)
    {
        Assert(result = (_ptpFirst == _tpRoot.LeftmostDescendant()));
    }

    return result;
}

#endif

//-----------------------------------------------------------------------------
//
//  Notification Methods
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Send a notification through the tree
//
//  Arguments:  pnf - The notification to send
//
//-----------------------------------------------------------------------------
void
CMarkup::Notify(
    CNotification * pnf )
{
    Assert(pnf);

    CDoc *pDoc = Doc();
    Assert( pDoc );

#if DBG == 1
    {
        BOOL    fQueue = ( pDoc->_fInSendAncestor && pnf->SendTo(NFLAGS_ANCESTORS));

        TraceTagEx((tagNotify, TAG_NONAME,
               "Notify    : (%d, %S) Element(0x%x,%S) Node(0x%x) cp(%d) cch(%d) %S",
               pnf->_sn,
               pnf->Name(),
               pnf->_pElement,
               (pnf->_pElement
                    ? pnf->_pElement->TagName()
                    : _T("")),
               pnf->_pNode,
               pnf->_cp,
               pnf->_cch,
               (fQueue
                    ? _T("QUEUED")
                    : _T(""))));
    }
#endif

    //
    //  If the branch was not supplied, infer it from the affected element
    //

    if (    !pnf->_pNode
        &&  pnf->_pElement)
    {
        pnf->_pNode = pnf->_pElement->GetFirstBranch();
    }

    Assert( pnf->_pNode
        ||  pnf->_pElement
        ||  pnf->IsTreeChange()
        ||  (   pnf->SendTo(NFLAGS_DESCENDENTS)
            &&  pnf->IsRangeValid()));
/*
    TODO (brendand, IE6 bug 56): These asserts fire when clearing the undo-stack. We need to fix that and
        enable these asserts. (brendand)
    Assert( !pnf->Node()
        ||  pnf->Node()->IsInMarkup());
    Assert( !pnf->Node()
        ||  pnf->Node()->GetMarkup() == this);
    Assert( !pnf->Element()
        ||  pnf->Element()->IsInMarkup());
    Assert( !pnf->Element()
        ||  pnf->Element()->GetMarkup() == this);
*/
    Assert( !pnf->SendTo(NFLAGS_ANCESTORS)
        ||  !pnf->SendTo(NFLAGS_DESCENDENTS));

    //
    //  Mark the document as dirty is requested
    //

    if (!pnf->IsFlagSet(NFLAGS_CLEANCHANGE))
    {
        SetModified();
    }

#if DBG==1
    //
    // Need to validate the change synchronously when the change is fired
    // (That is, the check cannot be queued since ValidateChange code can only handle
    //  one change at a time)
    //
    
    if (    pnf->IsTextChange()
        ||  pnf->IsTreeChange())
    {
        ValidateChange(pnf);
    }
#endif

    //
    //  If a notification is blocking the ancestor direction, queue the incoming notification
    //

    if (pDoc->_fInSendAncestor && pnf->SendTo(NFLAGS_ANCESTORS))
    {
        if (!pnf->IsFlagSet(NFLAGS_SYNCHRONOUSONLY))
        {
            if (pnf->Element())
            {
                pnf->Element()->AddRef();
                pnf->SetFlag(NFLAGS_NEEDS_RELEASE);
            }

            pDoc->_aryANotification.AppendIndirect(pnf);
        }
    }
    else
    {
        CDataAry<CNotification> *   paryNotification = pnf->SendTo(NFLAGS_ANCESTORS)
                                                            ? (CDataAry<CNotification> *)(&(pDoc->_aryANotification))
                                                            : NULL;

        if (!pnf->IsFlagSet(NFLAGS_DONOTBLOCK))
        {
            if (pnf->SendTo(NFLAGS_ANCESTORS))
            {
                pDoc->_fInSendAncestor = TRUE;
                pDoc->_pANotifyRootMarkup = this;
            }
        }

        SendNotification(pnf, paryNotification);

        Assert( !pDoc->_fInSendAncestor   || (pDoc->_pANotifyRootMarkup != this));
    }
    return;
}

//-----------------------------------------------------------------------------
//
//  Member:     ElementWantsNotification
//
//  Synopsis:   Check if an element may want to receive a notification
//
//  Arguments:  pElement - Element to notify
//              pnf      - Notification to send
//
//-----------------------------------------------------------------------------
#if DBG==1
BOOL
#else
inline BOOL
#endif
ElementWantsNotification(
    CElement *      pElement,
    CNotification * pnf)
{
    return  !pElement->_fExittreePending
        &&  (   pnf->IsForAllElements()
            ||  (   pElement->CurrentlyHasAnyLayout()
                &&  (   pnf->IsTextChange()
                    ||  pnf->IsTreeChange()
                    ||  pnf->IsLayoutChange()
                    ||  pnf->IsForLayouts()
                    ||  (   pnf->IsForPositioned()
                        &&  (   pElement->IsZParent()
                            ||  pElement->LayoutContainsRelative() ))
                    )
                )
            ||  (   (   IsPositionNotification(pnf)
// TODO (brendand, IE6 bug 59): Rework the categories to include the following:
//         1) text change
//         2) tree change
//         3) layout change
//         4) display change
//         Then, instead of testing for NTYPE_VISIBILITY_CHANGE etc., test for
//         display changes
                    ||  pnf->IsType(NTYPE_VISIBILITY_CHANGE))
                &&  !pElement->IsPositionStatic())
            ||  (   pnf->IsForActiveX()
                &&  pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            ||  (   pnf->IsForFrameSites()
                    &&  ( pElement->Tag() == ETAG_IFRAME || pElement->Tag() == ETAG_FRAME )));
}


//-----------------------------------------------------------------------------
//
//  Member:     NotifyElement
//
//  Synopsis:   Notify a element of a notification
//
//  Arguments:  pElement - Element to notify
//              pnf      - Notification to send
//
//-----------------------------------------------------------------------------
#if DBG==1
void
#else
inline void
#endif
NotifyElement(
    CElement *      pElement,
    CNotification * pnf)
{
    Assert(pElement);
    Assert(ElementWantsNotification(pElement, pnf));
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));

    //  If element has layout(s), pass all notifications to all layouts except those meant
    //  for ActiveX elements
    //  NOTE: Notifications passed to a layout may not also sent to the element

    // Note that Notify() is now a virtual on CLayoutInfo.

    if ( !pnf->IsForActiveX())
    {
        // Send the notifcation to the layout, unless it is a text-change coming
        // from non-slave content (#90138). NotifyAncestors would already have
        // blocked such notifications coming from children, so we only need to
        // bother here about notification from self

        Assert(!(   pnf->IsTextChange()
                &&  pElement->HasSlavePtr()
                &&  pElement->GetFirstBranch()
                &&  pElement->GetFirstBranch()->AmIAncestorOf(pnf->Node())
            ));

        if (!(      pnf->IsTextChange()
                &&  pElement->HasSlavePtr()
                &&  pnf->Node()->Element() == pElement)
                &&  pElement->CurrentlyHasAnyLayout() )
        {
                TraceTagEx((tagNotifyPath, TAG_NONAME,
                           "NotifyPath: (%d) sent to pLayoutInfo(0x%x, %S)",
                           pnf->_sn,
                           pElement->GetLayoutInfo(),
                           pElement->TagName()));

                pElement->GetLayoutInfo()->Notify(pnf);

                if (    pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED)
                    &&  pnf->IsHandled())
                {
                    pnf->SetFlag(NFLAGS_SENDENDED);
                }
        }
    }

    //
    //  If not handled, hand appropriate notifications to the element
    //
    // (KTam) These look like the same conditions that ElementWantsNotification()
    // checks.  Why are we checking them again when we've already asserted that
    // ElementWantsNotification is true?

    if (    !pnf->IsFlagSet(NFLAGS_SENDENDED)
        &&  (   pnf->IsForAllElements()
            ||  (   pnf->IsForActiveX()
                &&  pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            ||  (   (   IsPositionNotification(pnf)
// TODO (brendand, IE6 bug 59): Rework the categories to include the following:
//         1) text change
//         2) tree change
//         3) layout change
//         4) display change
//         Then, instead of testing for NTYPE_VISIBILITY_CHANGE etc., test for
//         display changes
                    ||  (   pnf->IsType(NTYPE_VISIBILITY_CHANGE)
                        &&  !pElement->ShouldHaveLayout()))
                &&  !pElement->IsPositionStatic())
            ||  (   pnf->IsForFrameSites()
                    &&  ( pElement->Tag() == ETAG_IFRAME || pElement->Tag() == ETAG_FRAME ))
            )
       )
    {
        TraceTagEx((tagNotifyPath, TAG_NONAME,
                   "NotifyPath: (%d) sent to pElement(0x%x, %S)",
                   pnf->_sn,
                   pElement,
                   pElement->TagName()));

        pElement->Notify(pnf);

        if (    pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED)
            &&  pnf->IsHandled())
        {
            pnf->SetFlag(NFLAGS_SENDENDED);
        }
    }
}


#if DBG==1
BOOL
#else
inline BOOL
#endif
NotifyTreeNode( CNotification *     pnf,
                CTreeNode *         pNode,
                BOOL                fBubbleUpViewTree,
                BOOL                fFromSlave)
{
    Assert(pnf);
    Assert(!!pnf->ShouldBubbleUpViewTree() == !!fBubbleUpViewTree);
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));
    Assert(pnf->Node());
    Assert(pNode);
    Assert(!(fBubbleUpViewTree && pNode->Element()->HasMasterPtr()));
    Assert(     pNode == pnf->Node()
            ||  pNode->AmIAncestorOf(pnf->Node())
            ||      fBubbleUpViewTree
                &&  pNode->Element()->HasSlavePtr()
                &&  pNode->Element()->GetSlaveIfMaster()->GetFirstBranch()
                &&  (   pNode->Element()->GetSlaveIfMaster()->GetFirstBranch() == pnf->Node()
                     || pNode->Element()->GetSlaveIfMaster()->GetFirstBranch()->AmIAncestorOf(pnf->Node())
                    )
          );
    Assert(!!fFromSlave == !!(fBubbleUpViewTree && pNode->Element()->HasSlavePtr()));

    CElement *  pElement    =   pNode->Element();

    if (fFromSlave && pnf->IsFlagSet(NFLAGS_LAZYRANGE))
    {
        long cp, cch;
        cch = pnf->Node()->Element()->GetFirstAndLastCp(&cp, NULL);
        pnf->SetTextRange(cp, cch);
    }

    if (ElementWantsNotification(pElement, pnf))
    {
        pElement->AddRef();

        NotifyElement(pElement, pnf);

        if (!pElement->IsInMarkup())
        {
            pNode = NULL;
        }
    
        pElement->Release();
    }

    if (!pNode || !pNode->Parent() || pnf->IsFlagSet(NFLAGS_SENDENDED))
        return FALSE;

    if (fFromSlave)
    {
        // Hack for INPUT
        // We know that INPUT's size is not affected by its content, so
        // none of the slave notifications need to beyond the INPUT.
        if (pElement->Tag() == ETAG_INPUT)
        {
            return FALSE;
        }

        pnf->SetNode(pNode);
        pnf->SetElement(pElement);
    }

    return TRUE; // TRUE => continue to bubble up the notification

}


//-----------------------------------------------------------------------------
//
//  Member:     NotifyAncestors
//
//  Synopsis:   Notify all ancestors of a CTreeNode
//
//  Arguments:  pnf - The notification to send
//
//-----------------------------------------------------------------------------
#if DBG==1
void
#else
inline void
#endif
NotifyAncestors(
    CNotification * pnf)
{
    Assert(pnf);
    Assert(pnf->Node());
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));

    if (pnf->IsTextChange())
    {
        // Text-change notifications are special. They walk up the source tree,
        // but also fire off laterally to master layouts. 
        CTreeNode *     pNode = pnf->Node();
        CElement *      pElemTarget;

        pNode = pnf->Node();

        for (;;)
        {
            if (pNode->Element()->HasMasterPtr())
            {
                // Fire off a separate notify on the master's layout
                pElemTarget = pNode->Element()->GetMasterIfSlave();
                if (    pElemTarget->CurrentlyHasAnyLayout() 
                    &&  pElemTarget->IsInMarkup())
                {
                    pElemTarget->GetLayoutInfo()->Notify(pnf);
                    Assert(pElemTarget->IsInMarkup());
                }
            }

            pNode = pNode->Parent();
            if (!pNode)
                break;

            if (pNode->Element()->CurrentlyHasAnyLayout() && !pNode->Element()->HasSlavePtr())
            {
                pNode->Element()->GetLayoutInfo()->Notify(pnf);
                Assert(pNode->IsInMarkup());
                Assert(pNode->Element()->IsInMarkup());
            }
            Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));
        }
    }
    else
    {
        // All other notifications (other than the text-change ones) fall into two two categories:
        // Those that bubble up the source tree (using the parent branch to walk up) and those that
        // bubble up the view tree (using the master branch if there is one and otherwise using the
        // parent branch).

        BOOL            fBubbleUpViewTree   = pnf->ShouldBubbleUpViewTree();
        CTreeNode *     pNode;
        CNotification   nfNew(*pnf);

        pNode = nfNew.Node();
        Assert(pNode);
        if (!(fBubbleUpViewTree && pNode->Element()->HasMasterPtr()))
        {
            pNode = pNode->Parent();
        }

        while (pNode)
        {
            BOOL fFromSlave = FALSE;

            if (fBubbleUpViewTree)
            {
                // Donm't want to bubble view notifications to parent
                // if parent has a slave (#101910)
                if (pNode->Element()->HasSlavePtr())
                    break;

                if (pNode->Element()->HasMasterPtr())
                {
                    fFromSlave = TRUE;
                    pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
                    if (!pNode)
                        break;
                }
            }

            if (!NotifyTreeNode(&nfNew, pNode, fBubbleUpViewTree, fFromSlave))
                break;

            pNode = pNode->Parent();
        }

        if (nfNew.IsFlagSet(NFLAGS_SENDENDED))
        {
            pnf->SetFlag(NFLAGS_SENDENDED);
        }
    }
}



//-----------------------------------------------------------------------------
//
//  Member:     NotifyDescendents
//
//  Synopsis:   Notify decendents of a CTreeNode or range
//
//  Arguments:  pnf - The notification to send
//
//-----------------------------------------------------------------------------

MtDefine(BroadcastNotify, Metrics, "Full Tree Notifications");

#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

void
CMarkup::NotifyDescendents( CNotification * pnf )
{
    CStackPtrAry < CElement *, 32 > aryElements( Mt( Mem ) );

    Assert( pnf->SendTo(NFLAGS_DESCENDENTS) );

#if DBG==1
    // Descendent notifications are order exempt so set their sn to 0xFFFFFFFF
    DWORD   snBefore = pnf->SerialNumber();
    pnf->_sn = (DWORD)-1;
#endif

    BOOL        fSCAvail = pnf->IsSecondChanceAvailable();

    Assert(pnf);
    Assert(  pnf->Element() || pnf->IsRangeValid() );
    Assert( !pnf->Element() || pnf->Element()->IsInMarkup() );
    Assert( !pnf->Element() || pnf->Element()->GetMarkup() == this );

    //
    // Build the list of descendent elements
    //

    BuildDescendentsList( &aryElements, pnf->Element(), pnf, TRUE /* exclude pnf->Element() */ );

    //
    //  Deliver the notification
    //

    if (aryElements.Size())
    {
        CElement **     ppElement;
        int             c;
        CNotification   nfSc;
        CNotification * pnfSend;

        if (fSCAvail)
        {
            nfSc.InitializeSc( pnf );
#if DBG==1
            //(dmitryt, IE6 28623)
            //see comment above about descendent notifications being exempt from SN counting.
            nfSc._sn = (DWORD)-1;
#endif
            pnfSend = &nfSc;
        }
        else
        {
            pnfSend = pnf;
        }

        for (   c = aryElements.Size(), ppElement = & (aryElements[0] );
                c > 0;
                c--, ppElement++ )
        {
            Assert( ppElement && *ppElement );

            if (!pnf->IsFlagSet( NFLAGS_SENDENDED ))
                NotifyElement(*ppElement, pnfSend);

            (*ppElement)->Release();
        }
    }

#if DBG==1
    // Reset the serial number on the notification
    pnf->_sn = snBefore;
#endif

#ifdef PERFMETER
    if (pnf->Element() == Root())
        MtAdd( Mt(BroadcastNotify), 1, aryElements.Size() );
#endif

}

#if DBG==1
void
#else
inline void
#endif
CMarkup::BuildDescendentsList( CStackPtrAry<CElement*,32> *paryElements,
                               CElement *pElement,
                               CNotification *pnf,
                               BOOL fExcludePassedElement // TRUE if pElement shouldn't be processed and potentially added to descendents list; FALSE for recursive calls only
                             )
{
    Assert(pnf);

    HRESULT     hr;

    CTreePos *  ptp;
    CTreePos *  ptpEnd;

    BOOL        fZParentsOnly = pnf->IsFlagSet( NFLAGS_ZPARENTSONLY );
    BOOL        fSCAvail = pnf->IsSecondChanceAvailable();
    BOOL        fBubbleDownViewTree = pnf->ShouldBubbleUpViewTree();

#if DBG
    CTreeNode * pNodeEnd;

    _cBuildDescListCallDepth++;
#endif

    //
    //  Determine the range
    //

    if ( pElement )
    {
        Assert( pElement->IsInMarkup() );
        Assert( pElement->GetMarkup() == this );

        pElement->GetTreeExtent( & ptp, & ptpEnd );

        Assert( ptp );
        
        // Generally fExcludePassedElement is TRUE, since we're interested
        // in "descendents", not "self + descendents".  We want it to be FALSE
        // for recursive calls however (since in those cases, "self" is
        // actually a descendant of the top-level pElement).
        if ( fExcludePassedElement )
            ptp = ptp->NextTreePos();  // start processing with the ptp _after_ the one beginning pElement

        if (pElement == Root() && !fSCAvail)
            paryElements->EnsureSize( paryElements->Size() + NumElems() );

        //
        // Recursively add elements from view slaves if the
        // notification is marked as "bubble through view tree"
        //

        if (fBubbleDownViewTree && (pElement->HasSlavePtr() && pElement->Tag() != ETAG_INPUT) )
        {
            // (dmitryt) don't let layoutChange notifications down into layoutRects
            // this will crash our non-incremental calc of layoutRects. (IE6 14804)
            if(!(pnf->IsLayoutChange() && pElement->IsLinkedContentElement()))
            {
                CElement *pSlaveElem = pElement->GetSlavePtr();
                pSlaveElem->GetMarkup()->BuildDescendentsList( paryElements, pSlaveElem, pnf, FALSE /* make sure pSlaveElem is processed! */ );
            }
        }
    }
    else
    {
        long cpStart, cpEnd, ich;

        AssertSz( _cBuildDescListCallDepth == 1, "Shouldn't have nested calls w/o an element!" );
        Assert( pnf->IsRangeValid() );

        cpStart = pnf->Cp(0);
        cpEnd   = cpStart + pnf->Cch(LONG_MAX);

        ptp     = TreePosAtCp( cpStart, & ich );
        ptpEnd  = TreePosAtCp( cpEnd, & ich );
    }

    if(!ptp || !ptpEnd)
        return;

    Assert( ptp );
    Assert( ptpEnd );
    Assert( ptp->InternalCompare( ptpEnd ) <= 0 );

    WHEN_DBG( pNodeEnd = CTreePosGap( ptpEnd, TPG_LEFT ).Branch(); )

    //
    //  Build a list of target elements
    //  (This allows the tree to change shape as the notification is delivered to each target)
    //

    while ( ptp && 
            ptp != ptpEnd )
    {
        if (ptp->IsBeginElementScope())
        {
            CTreeNode * pNode    = ptp->Branch();
            CElement *  pElement = pNode->Element();

            //
            //  Remember the element if it may want the notification
            //

            if (ElementWantsNotification( pElement, pnf ))
            {
                if (fSCAvail)
                {
                    if (!pnf->IsFlagSet( NFLAGS_SENDENDED ))
                        NotifyElement(pElement, pnf);

                    if (pnf->IsSecondChanceRequested())
                    {
                        hr = paryElements->Append( pElement );
                        if (hr)
                            goto Cleanup;

                        pElement->AddRef();
                        pnf->ClearSecondChanceRequested();
                    }
                }
                else
                {
                    hr = paryElements->Append( pElement );
                    if (hr)
                        goto Cleanup;

                    pElement->AddRef();
                }

                //
                // Recursively add elements from view slaves if the
                // notification is marked as "bubble through view tree"
                //

                if ( fBubbleDownViewTree && (pElement->HasSlavePtr() && pElement->Tag() != ETAG_INPUT) )
                {
                    // (dmitryt) don't let layoutChange notifications down into layoutRects
                    // this will crash our non-incremental calc of layoutRects. (IE6 14804)
                    if(!(pnf->IsLayoutChange() && pElement->IsLinkedContentElement()))
                    {
                        CElement *pSlaveElem = pElement->GetSlavePtr();
                        pSlaveElem->GetMarkup()->BuildDescendentsList( paryElements, pSlaveElem, pnf, FALSE /* make sure pSlaveElem is processed! */ );
                    }
                }
            }

            //
            //  Skip over z-parents (if requested)
            //

            if (fZParentsOnly)
            {
                BOOL fSkipElement;

                fSkipElement =  pNode->IsZParent()
                            ||  (   pnf->IsFlagSet(NFLAGS_AUTOONLY)
                                &&  pElement->ShouldHaveLayout()
                                &&  !pElement->GetUpdatedLayout()->_fAutoBelow);

                //
                // If the element should be skipped, then advance past it
                // (If the element has layout that overlaps with another layout that was not
                //  skipped, then this routine will only skip the portion contained in the
                //  non-skipped layout)
                //

                if (fSkipElement)
                {
                    Assert( !pNodeEnd->SearchBranchToRootForScope( pElement ) );

                    for ( ; ; )
                    {
                        CElement * pElementInner;

                        //
                        //  Get the ending treepos,
                        //  stop if it is for the end of the element
                        //

                        ptp = pNode->GetEndPos();
                        
                        Assert( ptp->IsEndNode() );

                        if (ptp->IsEdgeScope())
                            break;

                        //
                        //  There is overlap, locate the beginning of the next section
                        //  (Tunnel through the inclusions stopping at either the next begin
                        //   node for the current element, the end of the range, or if an
                        //   element with layout ends)
                        //

                        do
                        {
                            ptp           = ptp->NextTreePos();
                            pElementInner = ptp->Branch()->Element();
                            Assert(!ptp->IsEdgeScope()
                                ||  ptp->IsEndNode());
                        }
                        while ( pElementInner != pElement
                            &&  ptp != ptpEnd
                            &&  !(  ptp->IsEdgeScope()
                                &&  pElementInner->ShouldHaveLayout()));

                        //
                        //  If range ended, stop all searching
                        //

                        if (ptp == ptpEnd)
                            goto Cleanup;

                        //
                        //  If the end of an element with layout was encountered,
                        //  treat that as the end of the skipped over element
                        //

                        Assert( !ptp->IsEdgeScope()
                            ||  (   ptp->IsEndNode()
                                &&  pElementInner->ShouldHaveLayout()));

                        if (ptp->IsEdgeScope())
                            break;

                        //
                        //  Otherwise, reset the treenode and skip over the section of the element
                        //

                        Assert( ptp->IsBeginNode() && !ptp->IsEdgeScope() );

                        pNode = ptp->Branch();

                        Assert( pNode->Element() == pElement );
                    }
                }
            }
        }

        ptp = ptp->NextTreePos();
    }

Cleanup:
    WHEN_DBG( _cBuildDescListCallDepth-- );
}


#if DBG != 1
#pragma optimize("", on)
#endif


//-----------------------------------------------------------------------------
//
//  Member:     NotifyTreeLevel
//
//  Synopsis:   Notify objects listening at the tree level
//
//  Arguments:  pnf - Text change notification
//
//-----------------------------------------------------------------------------
void
CMarkup::NotifyTreeLevel(
    CNotification * pnf)
{
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));

    if (pnf->Type() == NTYPE_MARKUP_RENDER_STYLE)
    {
        if( _pHighlightRenSvcProvider )
        {
            _pHighlightRenSvcProvider->OnRenderStyleChange( pnf );
        }
    }
    
    if (pnf->Type() == NTYPE_DISPLAY_CHANGE)
    {
        CTreeNode *pNode = pnf->Node();
        //
        //  Notify the view of the change so that it will rehook the body/frameset display node
        //  when transitioning from display:none back to something visible.
        //  It might be best to instead move the view notifying block from the else below outside
        //  and before this if.  This fix is lower risk, but probably less correct. (greglett)
        //  Fixes #72530.
        //
        if (    pNode->Tag() == ETAG_BODY
            ||  pNode->Tag() == ETAG_FRAMESET)            
        {
            Doc()->GetView()->Notify(pnf);
        }

        while (pNode)
        {
            CElement *pElement = pNode->Element();
            if (pElement->HasFlag(TAGDESC_LIST))
            {
                DYNCAST(CListElement, pElement)->UpdateVersion();
                break;
            }
            pNode = pNode->Parent();
        }
    }
    else
    {
        //
        //  Notify the view of all layout changes
        //

        if (    !pnf->IsTextChange()
            &&  (   pnf->IsLayoutChange()
                ||  pnf->IsForLayouts()))
        {
            Doc()->GetView()->Notify(pnf);
        }
    }
    //
    //  Update the dirty range for any listeners
    //

    if (    pnf->IsTextChange()
        &&  HasChangeNotificationContext())
    {
        CMarkupChangeNotificationContext * pcnc = GetChangeNotificationContext();
        MarkupDirtyRange *          pdr  = pcnc->_aryMarkupDirtyRange;
        int                         cdr  = pcnc->_aryMarkupDirtyRange.Size();
        
        if (cdr && !pcnc->_fOnDirtyRangeChangePosted )
        {
            pcnc->_fOnDirtyRangeChangePosted = TRUE;
            IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CMarkup, OnDirtyRangeChange, ondirtyrangechange), 0, TRUE, "CMarkup::OnDirtyRangeChange"));
        }

        for( ; cdr; cdr--, pdr++)
        {
            pdr->_dtr.Accumulate(pnf, 0, Cch(), FALSE);
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send the current notification and any subsequent notifications
//              which might result
//
//  Arguments:  pnf              - The notification to send
//              paryNotification - Queue of pending notifications (may be NULL)
//
//-----------------------------------------------------------------------------
void
CMarkup::SendNotification(
    CNotification *             pnf,
    CDataAry<CNotification> *   paryNotification)
{
    CNotification   nf;
    int             iRequest = 0;

    for (;;)
    {
        Assert(pnf);

        BOOL        fNeedsRelease = pnf->IsFlagSet(NFLAGS_NEEDS_RELEASE);
        CElement *  pElement      = pnf->_pElement;

        //
        //  Send the notification to "self"
        //

        if (pnf->SendTo(NFLAGS_SELF))
        {
            CElement *  pElementSelf = pElement
                                            ? pElement
                                            : pnf->_pNode->Element();

            Assert(pElementSelf);
            if (ElementWantsNotification(pElementSelf, pnf))
            {
                NotifyElement(pElementSelf, pnf);
            }
        }

        //
        //  If sending to ancestors or descendents and a starting node or range exists,
        //  Send the notification to "ancestors" and "descendents"
        //

        if (    !pnf->IsFlagSet(NFLAGS_SENDENDED)
            &&  (   pnf->_pNode
                ||  pnf->IsRangeValid()))
        {
            if (pnf->SendTo(NFLAGS_ANCESTORS))
            {
                Assert(pnf->_pNode);
                NotifyAncestors(pnf);
            }
            else if (pnf->SendTo(NFLAGS_DESCENDENTS))
            {
                NotifyDescendents(pnf);
            }
        }

        //
        //  Send the notification to listeners at the "tree" level
        //

        if (    !pnf->IsFlagSet(NFLAGS_SENDENDED)
            &&  pnf->SendTo(NFLAGS_TREELEVEL))
        {
            NotifyTreeLevel(pnf);
        }

        //
        //  Release the element (if necessary)
        //  (Elements are AddRef'd only when the associated notification is delayed)
        //

        if (fNeedsRelease)
        {
            Assert(pElement);
            Assert(paryNotification);
            Assert(iRequest <= (*paryNotification).Size());
            WHEN_DBG((*paryNotification)[iRequest-1].ClearFlag(NFLAGS_NEEDS_RELEASE));
            pElement->Release();
        }

        //
        //  Leave or fetch the next notification to send
        //  (Copy the notification into a local in case others should arrive
        //   and cause re-allocation of the array)
        //

        if (    !paryNotification
            ||  iRequest >= (*paryNotification).Size())
            goto Cleanup;

        nf  = (*paryNotification)[iRequest++];
        pnf = &nf;

        //
        //  Ensure notifications no longer part of this markup are sent only to self
        //  (Previously sent notifications can initiate changes such that the elements
        //   of pending notifications are no longer part of this markup)
        //

        if (pnf->Element())
        {
            CMarkup *   pMarkup = pnf->Element()->GetMarkupPtr();

//          Unfortunately, notifications forwarded from nested markups contain the element
//          from the nested markup, hence the more complex check. What should be is, when
//          a notification from a nested markup is forwarded (by CMarkup::NotifyTreeLevel)
//          the contained element et. al. should be changed to the "master" element.
//          This change cannot be made right now because it is potentially de-stabilizing. (brendand)

            if (!pMarkup || pMarkup != this)
            {
                pnf->_grfFlags &= ~NFLAGS_TARGETMASK | NFLAGS_SELF;
            }
        }
    }

Cleanup:
    if (paryNotification)
    {
#if DBG==1
        for (int i=0; i < (*paryNotification).Size(); i++)
            Assert(!(*paryNotification)[i].IsFlagSet(NFLAGS_NEEDS_RELEASE));
#endif

        (*paryNotification).DeleteAll();

        if ( this == Doc()->_pANotifyRootMarkup )
        {
            Doc()->_fInSendAncestor = FALSE;
            Doc()->_pANotifyRootMarkup = NULL;
        }
    }
}

HRESULT
CMarkup::SetTextPosID( CTreePos ** pptpText, long lTextID )
{
    HRESULT     hr = S_OK;

    Assert( pptpText && *pptpText );

    if( ! (*pptpText)->IsData2Pos() )
    {
        CTreePos *  ptpRet;

        ptpRet = AllocData2Pos();
        if( !ptpRet )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        ptpRet->SetType( CTreePos::Text );
        *(LONG *)&ptpRet->DataThis()->t = *(LONG *)&(*pptpText)->DataThis()->t;

        hr = THR( ReplaceTreePos( *pptpText, ptpRet ) );
        if (hr)
            goto Cleanup;

        *pptpText = ptpRet;
    }

    (*pptpText)->DataThis()->t._lTextID = lTextID;

Cleanup:
    RRETURN( hr );
}

CTreePos *
CMarkup::AllocData1Pos()
{
    CTreeDataPos *ptdpNew;

#ifdef SLOWALLOC
    ptdpNew = (CTreeDataPos*)MemAllocClear( Mt(CTreeDataPos), TREEDATA1SIZE );
    ptdpNew->SetFlag(CTreePos::TPF_DATA_POS);
#else
    if (!_ptdpFree)
    {
        void *          pvPoolNew;
        size_t          cPoolSize;

        if (!_pvPool)
        {
            pvPoolNew = (void*)(_abPoolInitial);
            cPoolSize = INITIAL_TREEPOS_POOL_SIZE;
        }
        else
        {
            cPoolSize = s_cTreePosPoolSize;
            pvPoolNew = MemAllocClear(
                            Mt(CMarkup_pvPool), 
                            sizeof(void*) + TREEDATA1SIZE * s_cTreePosPoolSize);
        }

        if (pvPoolNew)
        {
            CTreeDataPos *ptdp;
            int i;

            for (ptdp = (CTreeDataPos*)((void**)pvPoolNew + 1), i = cPoolSize - 1; 
                 i > 0; 
                 ptdp = (CTreeDataPos*)((BYTE*)ptdp + TREEDATA1SIZE), --i)
            {
                ptdp->SetFlag(CTreePos::TPF_DATA_POS);
                ptdp->SetNext((CTreeDataPos*)((BYTE*)ptdp + TREEDATA1SIZE));
            }

            ptdp->SetFlag(CTreePos::TPF_DATA_POS);

            _ptdpFree = (CTreeDataPos*)((void**)pvPoolNew + 1);
            *((void**)pvPoolNew) = _pvPool;
            _pvPool = pvPoolNew;
        }
    }
    ptdpNew = _ptdpFree;
#endif

    if (ptdpNew)
    {
        _ptdpFree = (CTreeDataPos*)(ptdpNew->Next());
        ptdpNew->SetNext(NULL);
    }

#if DBG == 1 || defined(DUMPTREE)
    ptdpNew->SetSN();
#endif

    return ptdpNew;
}

CTreePos *
CMarkup::AllocData2Pos()
{
    CTreeDataPos *ptdpNew;
    ptdpNew = (CTreeDataPos*)MemAllocClear( Mt(CTreeDataPos), TREEDATA2SIZE );

    if( ptdpNew )
    {
        ptdpNew->SetFlag(CTreePos::TPF_DATA_POS|CTreePos::TPF_DATA2_POS);
#if DBG == 1 || defined(DUMPTREE)
        ptdpNew->SetSN();
#endif
    }

    return ptdpNew;
}

#if _WIN64

CTreePos *
CMarkup::AllocData3Pos()
{
    CTreeDataPos *ptdpNew;
    ptdpNew = (CTreeDataPos*)MemAllocClear( Mt(CTreeDataPos), TREEDATA3SIZE );

    if( ptdpNew )
    {
        ptdpNew->SetFlag(CTreePos::TPF_DATA2_POS|CTreePos::TPF_DATA3_POS);
#if DBG == 1 || defined(DUMPTREE)
        ptdpNew->SetSN();
#endif
    }

    return ptdpNew;
}

#endif

inline void
CMarkup::ReleaseTreePos(CTreePos *ptp, BOOL fLastRelease /*= FALSE*/ )
{
    AssertSz(ptp->_cGapsAttached==0, "Destroying a TreePos with TreePosGaps attached");

    switch (ptp->Type())
    {
    case CTreePos::Pointer:
        if (ptp->GetCollapsedWhitespace())
        {
            delete [] ptp->GetCollapsedWhitespace();
        }
        if (ptp->MarkupPointer())
        {
            ptp->MarkupPointer()->OnPositionReleased();
            ptp->DataThis()->p._dwPointerAndGravityAndCling = 0;
        }

    // fall through
    case CTreePos::Text:
        Assert( ptp->IsDataPos() );

#ifdef SLOWALLOC
        MemFree( ptp );
#else
#if _WIN64
        if( ptp->IsData3Pos() )
#else
        if( ptp->IsData2Pos() )
#endif
        {
            MemFree( ptp );
        }
        else if( ! fLastRelease )
        {
            memset( ptp, 0, TREEDATA1SIZE );

            ptp->SetFlag( CTreePos::TPF_DATA_POS );
            ptp->SetNext( _ptdpFree );
            _ptdpFree = ptp->DataThis();
        }
#endif
        break;

    case CTreePos::NodeBeg:
    case CTreePos::NodeEnd:
        // Make sure that we crash if someone
        // tries to use a dead node pos...
        ptp->_pFirstChild = NULL;
        ptp->_pNext = NULL;
        break;
    }
}


void
CMarkup::FreeTreePos(CTreePos *ptp)
{
    Assert(ptp);

    // set a sentinel to make the traversal terminate
    ptp->MarkFirst();
    ptp->SetNext(NULL);

    // release the subtree, adding its nodes to the free list
    while (ptp)
    {
        if (ptp->FirstChild())
        {
            ptp = ptp->FirstChild();
        }
        else
        {
            CTreePos *ptpNext;
            BOOL fRelease = TRUE;
            while (fRelease)
            {
                fRelease = ptp->IsLastChild();
                ptpNext = ptp->Next();
                ReleaseTreePos(ptp);
                ptp = ptpNext;
            }
        }
    }
}


CTreePos *
CMarkup::FirstTreePos() const
{
    return _ptpFirst;
}


CTreePos *
CMarkup::LastTreePos() const
{
    CTreePos *ptpLeft = _tpRoot.FirstChild();

    return (ptpLeft) ? ptpLeft->RightmostDescendant() : NULL;
}



#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreePos *
CMarkup::TreePosAtSourceIndex(long iSourceIndex)
{
    Assert(0<=iSourceIndex);
    WHEN_DBG( long iSIOrig = iSourceIndex; )
    long cElemLeft;
    long cDepth=0;

    CTreePos *ptp = _tpRoot.FirstChild();

    for (;; ++cDepth )
    {
        cElemLeft = ptp->GetElemLeft();

        if (iSourceIndex < cElemLeft)
        {
            ptp = ptp->FirstChild();
            Assert(ptp->IsLeftChild());
        }
        else if (iSourceIndex > cElemLeft || !ptp->IsBeginElementScope())
        {
            iSourceIndex -= cElemLeft + (ptp->IsBeginElementScope()? 1 : 0);
            ptp = ptp->RightChild();
        }
        else
        {
            break;
        }
    }

    TraceTag((tagTreePosAccess, "%p: TreePos at sourceindex %ld  depth %ld",
                this, iSIOrig, cDepth));

    if (ShouldSplay(cDepth))
    {
        ptp->Splay();
    }

    return ptp;
}

CTreePos *
CMarkup::TreePosAtCp ( long cp, long * pcchOffset, BOOL fAdjustForward ) const
{
    long cDepth=0;
    WHEN_DBG( long cpOrig=cp; )

    // Make sure we got a valid cp.
            
    AssertSz( cp >= 1 && cp < Cch(), "Invalid cp - out of document" );

    CTreePos * ptp = _tpRoot.FirstChild();

    for ( ; ptp; ++cDepth )
    {
        if (cp < long( ptp->_cchLeft ))
        {
            ptp = ptp->FirstChild();

            if (!ptp || !ptp->IsLeftChild())
            {
                ptp = FirstTreePos();
                break;          // we fell off the left end
            }
        }
        else
        {
            cp -= ptp->_cchLeft;
            
            if (ptp->IsPointer() || cp && (!ptp->IsText() || cp >= ptp->Cch()))
            {
                cp -= ptp->GetCch();
                ptp = ptp->RightChild();
            }
            else
                break;
        }
    }

    if(!ptp)
        return NULL;

    if (pcchOffset)
        *pcchOffset = cp;

    TraceTag(
        (tagTreePosAccess,
         "%p: TreePos at cp %ld offset %ld depth %ld",
         this, cpOrig, cp, cDepth));

    if (ptp && ShouldSplay(cDepth))
        ptp->Splay();

    // If we are adjusting forward and we are not in the middle of a ptp
    // the go forward past all the empty ptps.
    if (fAdjustForward && cp == 0)
    {
        while(ptp)
        {
            if (   ptp->IsNode()
                && !ptp->IsEdgeScope()
               )
            {
                Assert(ptp->GetCch() == 0);
                ptp = ptp->NextTreePos();
            }
            else
            {
                break;
            }
        }
    }
    
    return ptp;
}

#pragma optimize("", on)

HRESULT
CMarkup::Append(CTreePos *ptpNew)
{
    HRESULT hr = (ptpNew)? S_OK : E_OUTOFMEMORY;
    CTreePos *ptpOldRoot = _tpRoot.FirstChild();

    if (hr)
        goto Cleanup;
    Assert(!ptpNew->Owner() || ptpNew->Owner() == this);

    ptpNew->SetFirstChild(ptpOldRoot);
    ptpNew->MarkLeft();
    ptpNew->MarkLast();
    ptpNew->SetNext(&_tpRoot);

    ptpNew->ClearCounts();
    ptpNew->IncreaseCounts(&_tpRoot, CTreePos::TP_LEFT);

    _tpRoot.SetFirstChild(ptpNew);
    _tpRoot.IncreaseCounts(ptpNew, CTreePos::TP_DIRECT);

    if (ptpOldRoot)
    {
        Assert(ptpOldRoot->IsLastChild());
#if defined(MAINTAIN_SPLAYTREE_THREADS)
        // adjust threads
        CTreePos *ptpRightmost = ptpOldRoot->RightmostDescendant();
        Assert(ptpRightmost->RightThread() == NULL);
        ptpRightmost->SetRightThread(ptpNew);
        ptpNew->SetLeftThread(ptpRightmost);
        ptpNew->SetRightThread(NULL);
#endif
        ptpOldRoot->SetNext(ptpNew);
    }
    else
    {
        _ptpFirst = ptpNew;
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    TraceTag((tagTreePosOps, "%p: Append TreePos cch=%ld",
        this, ptpNew->GetCch()));

Cleanup:
    RRETURN(hr);
}

HRESULT
CMarkup::Insert(CTreePos *ptpNew, CTreePosGap *ptpgInsert)
{
    Assert( ptpgInsert->IsPositioned() );

    return Insert( ptpNew,
                   ptpgInsert->AttachedTreePos(),
                   ptpgInsert->AttachDirection() == TPG_RIGHT );
}

HRESULT
CMarkup::Insert(CTreePos *ptpNew, CTreePos *ptpInsert, BOOL fBefore)
{
    CTreePos *pLeftChild, *pRightChild;
    CTreePos *ptp;
    BOOL fLeftChild;
    HRESULT hr = (ptpNew)? S_OK : E_OUTOFMEMORY;

    if (hr)
        goto Cleanup;

    Assert(!ptpNew->Owner() || ptpNew->Owner() == this);
    Assert(ptpInsert);

    if (!fBefore)
    {
        CTreePos *ptpInsertBefore = ptpInsert->NextTreePos();

        if( ptpInsertBefore )
        {
            ptpInsert = ptpInsertBefore;
        }
        else
        {
            hr = Append( ptpNew );
            goto Cleanup;
        }
    }

    ptpNew->ClearCounts();
    ptpNew->IncreaseCounts(ptpInsert, CTreePos::TP_LEFT);

    ptpInsert->GetChildren(&pLeftChild, &pRightChild);

    ptpInsert->SetFirstChild(ptpNew);

    ptpNew->SetFirstChild(pLeftChild);
    ptpNew->MarkLeft();

    if (pLeftChild)
    {
        ptpNew->MarkLast(pLeftChild->IsLastChild());
        ptpNew->SetNext(pLeftChild->Next());
        pLeftChild->MarkLast();
        pLeftChild->SetNext(ptpNew);
    }
    else if (pRightChild)
    {
        ptpNew->MarkFirst();
        ptpNew->SetNext(pRightChild);
    }
    else
    {
        ptpNew->MarkLast();
        ptpNew->SetNext(ptpInsert);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpNew->SetLeftThread(ptpInsert->LeftThread());
    ptpNew->SetRightThread(ptpInsert);
    if (ptpNew->LeftThread())
        ptpNew->LeftThread()->SetRightThread(ptpNew);
    ptpInsert->SetLeftThread(ptpNew);
#endif

    if (ptpNew->HasNonzeroCounts(CTreePos::TP_DIRECT))
    {
        fLeftChild = TRUE;
        for (ptp = ptpInsert; ptp; ptp = ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->IncreaseCounts(ptpNew, CTreePos::TP_DIRECT);
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }

    if (ptpInsert == _ptpFirst)
    {
        _ptpFirst = ptpNew;
    }

    TraceTag((tagTreePosOps, "%p: Insert TreePos cch=%ld",
        this, ptpNew->GetCch() ));

Cleanup:
#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    RRETURN(hr);
}

HRESULT 
CMarkup::Move(CTreePos *ptpNew, CTreePosGap *ptpgDest)
{
    Assert( ptpgDest->IsPositioned() );

    return Move( ptpNew,
                 ptpgDest->AttachedTreePos(),
                 ptpgDest->AttachDirection() == TPG_RIGHT );
}

HRESULT
CMarkup::Move(CTreePos *ptpMove, CTreePos *ptpDest, BOOL fBefore)
{
    Assert(ptpMove != ptpDest);
    SUBLIST sublist;
    HRESULT hr;

    hr = SpliceOut(ptpMove, ptpMove, &sublist);
    if (!hr)
    {
        Assert(sublist.FirstChild() == ptpMove);
        hr = Insert(ptpMove, ptpDest, fBefore);
    }

    return hr;
}


HRESULT
CMarkup::Split(CTreePos *ptpSplit, long cchLeft, SCRIPT_ID sidNew /*= sidNil */)
{
    WHEN_DBG( CTreePos tpValid(TRUE); )
    CTreePos * ptpNew;
    CTreePos * pLeftChild, * pRightChild;
    HRESULT    hr = S_OK;
    
    Assert( ptpSplit->IsText() && ptpSplit->Cch() >= cchLeft );

    if (sidNew == sidNil)
        sidNew = ptpSplit->Sid();

    ptpNew = NewTextPos( ptpSplit->Cch() - cchLeft, sidNew, ptpSplit->TextID() );

    if (!ptpNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ptpSplit->GetChildren(&pLeftChild, &pRightChild);

    ptpNew->MarkLast();
    ptpNew->SetNext(ptpSplit);
    ptpNew->SetFirstChild(pRightChild);
    if (pRightChild)
    {
        pRightChild->SetNext(ptpNew);
    }

    ptpSplit->DataThis()->t._cch = cchLeft;
    if (pLeftChild)
    {
        pLeftChild->MarkFirst();
        pLeftChild->SetNext(ptpNew);
    }
    else
    {
        ptpSplit->SetFirstChild(ptpNew);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpNew->SetLeftThread(ptpSplit);
    ptpNew->SetRightThread(ptpSplit->RightThread());
    ptpSplit->SetRightThread(ptpNew);
    if (ptpNew->RightThread())
        ptpNew->RightThread()->SetLeftThread(ptpNew);
#endif

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert( IsSplayValid() );
#endif

    TraceTag((tagTreePosOps, "%p: Split TreePos into cch %ld/%ld",
                this, ptpSplit->Cch(), ptpNew->Cch()));

Cleanup:
    RRETURN(hr);
}


HRESULT
CMarkup::Join(CTreePos *ptpJoin)
{
    WHEN_DBG( CTreePos tpValid(TRUE); )
    CTreePos *ptpNext, *ptpParent;
    CTreePos *pLeftChild;

    // put the two TreePos together at the top of the tree, next TreePos on top
    ptpJoin->Splay();
    ptpNext = ptpJoin->NextTreePos();

    // We're joining two text nodes, so we BETTER have a next node.
    Assert( ptpNext);

    ptpNext->Splay();

    Assert( ptpJoin->IsText() && ptpNext->IsText() );

    // take over the next TreePos (my right subtree is empty)
    ptpJoin->DataThis()->t._cch += ptpNext->Cch();
    if (!ptpJoin->IsLastChild())
    {
        ptpJoin->Next()->SetNext(ptpJoin);
        pLeftChild = ptpJoin->LeftChild();
        if (pLeftChild)
        {
            pLeftChild->MarkFirst();
            pLeftChild->SetNext(ptpJoin->Next());
        }
        else
        {
            ptpJoin->SetFirstChild(ptpJoin->Next());
        }
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpJoin->SetRightThread(ptpNext->RightThread());
    if (ptpNext->RightThread())
        ptpNext->RightThread()->SetLeftThread(ptpJoin);
#endif

    // discard the next TreePos
    ptpParent = ptpNext->Parent();
    Assert(ptpParent->Next() == NULL);
    ptpParent->ReplaceChild(ptpNext, ptpJoin);
    ptpNext->SetFirstChild(NULL);
    FreeTreePos(ptpNext);

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert( IsSplayValid() );
#endif

    TraceTag((tagTreePosOps, "%p: Join cch=%ld", this, ptpJoin->Cch()));

    return S_OK;
}

HRESULT 
CMarkup::ReplaceTreePos(CTreePos * ptpOld, CTreePos * ptpNew)
{
    HRESULT hr = S_OK;

    Assert( ! HasUnembeddedPointers() );

    Assert( ptpOld && ptpNew );

    hr = THR( Insert( ptpNew, ptpOld, TRUE ) );
    if (hr)
        goto Cleanup;

    hr = THR( Remove( ptpOld ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//
// This MergeText cannot be used for merging text after pointer pos removal
//

HRESULT
CMarkup::MergeText( CTreePos * ptpMerge )
{
    HRESULT hr = S_OK;
    CTreePos * ptp;

    Assert( ! HasUnembeddedPointers() );

    if (!ptpMerge->IsText())
        goto Cleanup;

    ptp = ptpMerge->PreviousTreePos();

    if (    ptp->IsText() 
        &&  ptp->Sid() == ptpMerge->Sid()
        &&  ptp->TextID() == ptpMerge->TextID() )
    {
        hr = THR( MergeTextHelper( ptp ) );

        if (hr)
            goto Cleanup;

        ptpMerge = ptp;
    }

    ptp = ptpMerge->NextTreePos();

    if (    ptp->IsText() 
        &&  ptp->Sid() == ptpMerge->Sid()
        &&  ptp->TextID() == ptpMerge->TextID() )
    {
        hr = THR( MergeTextHelper( ptpMerge ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkup::MergeTextHelper ( CTreePos * ptpMerge )
{
    HRESULT  hr = S_OK;

    Assert( ptpMerge->IsText() );
    Assert( ptpMerge->NextTreePos()->IsText() );

    hr = THR( Join( ptpMerge ) );

    if (hr)
        goto Cleanup;
Cleanup:

    RRETURN( hr );
}

///////////////////////////////////////////////////////////////////////////////
//
// RemovePointerPos
//
// Removes a pointer pos, making sure unembedded pointers are updated
// properly.  Once can also pass in a ptp/ich pair to make sure it gets
// updated as well.
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CMarkup::RemovePointerPos ( CTreePos * ptp, CTreePos * * pptpUpdate, long * pichUpdate )
{
    HRESULT    hr = S_OK;
    CTreePos * ptpBefore;
    CTreePos * ptpAfter;

    Assert( ptp->IsPointer() );
    Assert( ! pptpUpdate || *pptpUpdate != ptp );

    //
    // Remove the pos from the list, making sure to record the pos before the one
    // being removed
    //

    ptpBefore = ptp->PreviousTreePos();

    hr = THR( Remove( ptp ) );

    if (hr)
        goto Cleanup;

    //
    // Now, see if there are two adjacent text pos's we can merge
    //

    if (ptpBefore->IsText() && (ptpAfter = ptpBefore->NextTreePos())->IsText() &&
        ptpBefore->Sid() == ptpAfter->Sid() && ptpBefore->TextID() == ptpAfter->TextID())
    {
        CMarkupPointer * pmp;

        //
        // Update the incomming ref and unembedded markup pointers
        //
        
        if (pptpUpdate && *pptpUpdate == ptpAfter)
        {
            *pptpUpdate = ptpBefore;
            *pichUpdate += ptpBefore->Cch();
        }

        for ( pmp = _pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            Assert( ! pmp->_fEmbedded );

            if (pmp->_ptpRef == ptpAfter)
            {
                pmp->_ptpRef = ptpBefore;
                
                Assert( ! pmp->_ptpRef->IsPointer() );
                
                Assert(
                    ! pmp->_ptpRef->IsBeginElementScope() ||
                        ! pmp->_ptpRef->Branch()->Element()->IsNoScope() );
                
                pmp->_ichRef += ptpBefore->Cch();
            }
        }

        //
        // Then joing the adjacent text pos's
        //

        hr = THR( Join( ptpBefore ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkup::Remove(CTreePos *ptpStart, CTreePos *ptpFinish)
{
    HRESULT hr;
    SUBLIST sublist;

    hr = SpliceOut(ptpStart, ptpFinish, &sublist);
    if (!hr && sublist.FirstChild())
    {
        FreeTreePos(sublist.FirstChild());

        TraceTag((tagTreePosOps, "%p: Remove cch=%ld", this, sublist._cchLeft));
    }

    RRETURN(hr);
}


HRESULT
CMarkup::SpliceOut(CTreePos *ptpStart, CTreePos *ptpFinish,
                        SUBLIST *pSublistSplice)
{
    CTreePos *ptpSplice;
    CTreePos *ptp;
    BOOL fLeftChild;
    CTreePos *ptpLeftEdge = ptpStart->PreviousTreePos();
    CTreePos *ptpRightEdge = ptpFinish->NextTreePos();
//    CTreePos *ptpPointerHead=NULL, *ptpPointerTail=NULL;
#if defined(MAINTAIN_SPLAYTREE_THREADS)
    CTreePos *ptpLeftmost, *ptpRightmost;
#endif

    pSublistSplice->InitSublist();

    // isolate the splice region near the top of the tree
    if (ptpRightEdge)
    {
        ptpRightEdge->Splay();
    }
    if (ptpLeftEdge)
    {
        ptpLeftEdge->Splay();
    }

    // locate the splice region
    ptpSplice = _tpRoot.FirstChild();
    Assert(ptpSplice);  // _tpRoot.FirstChild() should always return a valid pointer
    if (ptpLeftEdge)
    {
        ptpSplice = ptpLeftEdge->RightChild();

        // call RotateUp to isolate if last step was zig-zig
        if (ptpRightEdge && ptpRightEdge->Parent() == ptpSplice)
        {
            // Assert to make PreFIX happy. If ptpRightEdge is non-null then its
            // parent won't be null and so ptpSplice isn't null.
            Assert(ptpSplice); 

            ptpRightEdge->RotateUp(ptpSplice, ptpSplice->Parent());
        }
    }
    if (ptpRightEdge)
    {
        ptpSplice = ptpRightEdge->LeftChild();
    }

    ptp = ptpSplice->Parent();
    fLeftChild = ptpSplice->IsLeftChild();

    // splice it out
    if (fLeftChild)
    {
        pSublistSplice->IncreaseCounts(ptp, CTreePos::TP_LEFT);
    }
    else
    {
        Assert(ptp->Parent() == &_tpRoot);
        pSublistSplice->IncreaseCounts(&_tpRoot, CTreePos::TP_LEFT);
        pSublistSplice->DecreaseCounts(ptp, CTreePos::TP_BOTH);
    }
    ptp->RemoveChild(ptpSplice);
    pSublistSplice->SetFirstChild(ptpSplice);
    ptpSplice->SetNext(pSublistSplice);
    ptpSplice->MarkLast();
    ptpSplice->MarkLeft();

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpLeftmost = ptpSplice->LeftmostDescendant();
    ptpRightmost = ptpSplice->RightmostDescendant();
    if (ptpLeftmost->LeftThread())
        ptpLeftmost->LeftThread()->SetRightThread(ptpRightmost->RightThread());
    if (ptpRightmost->RightThread())
        ptpRightmost->RightThread()->SetLeftThread(ptpLeftmost->LeftThread());
    ptpLeftmost->SetLeftThread(NULL);
    ptpRightmost->SetRightThread(NULL);
#endif

#if 0 // Don't need this right now
    if (fIgnorePointers)
    {
        CTreePos *ptpSource;

        // find any pointers in the splice region
        for (ptpSource = pSublistSplice->LeftmostDescendant();
             ptpSource;
             /* advance done in body */ )
        {
            CTreePos *ptpNext = ptpSource->NextTreePos();

            if (ptpSource->IsPointer())
            {
                ptpSource->Remove();
                if (ptpPointerTail)
                {
                    ptpPointerTail->SetFirstChild(ptpSource);
                    ptpSource->MarkRight();
                    ptpSource->MarkLast();
                    ptpSource->SetNext(ptpPointerTail);
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                    ptpPointerTail->SetRightThread(ptpSource);
                    ptpSource->SetLeftThread(ptpPointerTail);
#endif
                }
                else
                {
                    ptpPointerHead = ptpSource;
                }
                ptpSource->SetFirstChild(NULL);
                ptpPointerTail = ptpSource;
            }

            ptpSource = ptpNext;
        }

        // restore them to the main list
        if (ptpPointerHead)
        {
            if (fLeftChild)
            {
                ptpPointerHead->MarkLeft();
                if (ptp->FirstChild())
                {
                    ptpPointerHead->MarkFirst();
                    ptpPointerHead->SetNext(ptp->FirstChild());
                }
                else
                {
                    ptpPointerHead->MarkLast();
                    ptpPointerHead->SetNext(ptp);
                }
                ptp->SetFirstChild(ptpPointerHead);
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                // adjust threads
                if (ptp->LeftThread())
                {
                    ptp->LeftThread()->SetRightThread(ptpPointerHead);
                    ptpPointerHead->SetLeftThread(ptp->LeftThread());
                }
                ptpPointerTail->SetRightThread(ptp);
                ptp->SetLeftThread(ptpPointerTail);
#endif
            }
            else
            {
                CTreePos *ptpLeft = ptp->FirstChild();

                ptpPointerHead->MarkRight();
                ptpPointerHead->MarkLast();
                ptpPointerHead->SetNext(ptp);
                if (ptpLeft)
                {
                    ptpLeft->SetNext(ptpPointerHead);
                    ptpLeft->MarkFirst();
                }
                else
                {
                    ptp->SetFirstChild(ptpPointerHead);
                }
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                // adjust threads
                if (ptp->RightThread())
                {
                    ptp->RightThread()->SetLeftThread(ptpPointerTail);
                    ptpPointerTail->SetRightThread(ptp->RightThread());
                }
                ptpPointerHead->SetLeftThread(ptp);
                ptp->SetRightThread(ptpPointerHead);
#endif
            }
        }
    }
#endif // Don't need this right now

    // adjust cumulative counts
    if( pSublistSplice->HasNonzeroCounts( CTreePos::TP_LEFT ) )
    {
        for (; ptp; ptp=ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->DecreaseCounts(pSublistSplice, CTreePos::TP_LEFT);
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }

    // return answers
    TraceTag((tagTreePosOps, "%p: SpliceOut cch=%ld", this, pSublistSplice->_cchLeft));

    if (ptpLeftEdge == NULL)
    {
        _ptpFirst = _tpRoot.LeftmostDescendant();
        if (_ptpFirst == &_tpRoot)
        {
            _ptpFirst = NULL;
        }
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    return S_OK;
}

HRESULT
CMarkup::SpliceIn(SUBLIST *pSublistSplice, CTreePos *ptp)
{
    CTreePos *ptpSplice = pSublistSplice->FirstChild();
    CTreePos *pRightChild;
    CTreePos *ptpPrev;
    BOOL fLeftChild;
    BOOL fNewFirst = (ptp == _ptpFirst);

    Assert(ptpSplice);
    Assert(!ptpSplice->Owner() || ptpSplice->Owner() == this);

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    CTreePos *ptpLeftmost = ptpSplice->LeftmostDescendant();
    CTreePos *ptpRightmost = ptpSplice->RightmostDescendant();
#endif

    if (ptp)
    {
        ptp->Splay();

        ptpPrev = ptp->PreviousTreePos();
        if (ptpPrev)
        {
            ptpPrev->Splay();
        }

        pRightChild = ptp->RightChild();
        if (pRightChild)
        {
            ptpSplice->MarkFirst();
            ptpSplice->SetNext(pRightChild);
        }
        else
        {
            ptpSplice->MarkLast();
            ptpSplice->SetNext(ptp);
        }

        ptp->SetFirstChild(ptpSplice);
        ptpSplice->MarkLeft();

        fLeftChild = TRUE;

#if defined(MAINTAIN_SPLAYTREE_THREADS)
        // adjust threads
        if (ptp->LeftThread())
        {
            ptp->LeftThread()->SetRightThread(ptpLeftmost);
            ptpLeftmost->SetLeftThread(ptp->LeftThread());
        }
        ptpRightmost->SetRightThread(ptp);
        ptp->SetLeftThread(ptpRightmost);
#endif
    }
    else
    {
        ptp = LastTreePos();
        Assert(ptp);
        CTreePos *ptpLeft = ptp->LeftChild();

        if (ptpLeft)
        {
            ptpLeft->MarkFirst();
            ptpLeft->SetNext(ptpSplice);
        }
        else
        {
            ptp->SetFirstChild(ptpSplice);
        }
        ptpSplice->MarkLast();
        ptpSplice->MarkRight();
        ptpSplice->SetNext(ptp);

        fLeftChild = FALSE;

#if defined(MAINTAIN_SPLAYTREE_THREADS)
        // adjust threads
        ptp->SetRightThread(ptpLeftmost);
        ptpLeftmost->SetLeftThread(ptp);
#endif
    }

    for (; ptp; ptp=ptp->Parent())
    {
        if (fLeftChild)
        {
            ptp->IncreaseCounts(pSublistSplice, CTreePos::TP_LEFT);
        }
        fLeftChild = ptp->IsLeftChild();
    }

    if (fNewFirst)
    {
        _ptpFirst = _ptpFirst->LeftmostDescendant();
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif
    TraceTag((tagTreePosOps, "%p: SpliceIn cch=%ld", this, pSublistSplice->_cchLeft));
    return S_OK;
}

//
// CMarkup::InsertPosChain
//
// This method inserts a chain of CTreePoses into the tree.  The
// poses should be chained together in an appropriate way to make
// insertion very cheap.
//
// The first child pointer of every pos should point to the previous
// pos in the chain.  The next pointer should point to the next
// pos in the chain.  The ends should point to NULL.  The last child
// and left child bits should be set on every element.
//
// Eventually, the counts should probably be set to something also so
// that this method doesn't have to run the chain, but I haven't figured
// that out yet.
//

HRESULT
CMarkup::InsertPosChain( 
                CTreePos * ptpChainHead, CTreePos * ptpChainTail, 
                CTreePos * ptpInsertBefore )
{
    CTreePos *pLeftChild, *pRightChild;

    // We can't insert at the beginning or end of the splay tree
    Assert( ptpInsertBefore != _ptpFirst );
    Assert( ptpInsertBefore );

    ptpInsertBefore->GetChildren(&pLeftChild, &pRightChild);

    ptpInsertBefore->SetFirstChild(ptpChainTail);
    ptpChainTail->MarkLeft();

    ptpChainHead->SetFirstChild(pLeftChild);

    if (pLeftChild)
    {
        ptpChainTail->MarkLast(pLeftChild->IsLastChild());
        ptpChainTail->SetNext(pLeftChild->Next());

        pLeftChild->MarkLast();
        pLeftChild->SetNext(ptpChainHead);
    }
    else if (pRightChild)
    {
        ptpChainTail->MarkFirst();
        ptpChainTail->SetNext(pRightChild);
    }
    else
    {
        ptpChainTail->MarkLast();
        ptpChainTail->SetNext(ptpInsertBefore);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpChainHead->SetLeftThread(ptpInsertBefore->LeftThread());
    ptpChainTail->SetRightThread(ptpInsertBefore);
    if (ptpChainHead->LeftThread())
        ptpChainHead->LeftThread()->SetRightThread(ptpChainHead);
    ptpInsertBefore->SetLeftThread(ptpChainTail);
#endif

    // update the order statistics
    {
        CTreePos *  ptp, *ptpPrev = NULL;
        BOOL        fLeftChild = TRUE;
        CTreePos::SCounts   counts;
#if DBG==1
        BOOL fCheckCounts = FALSE;
#endif

        // accumulate/set the chain just inserted
        ptpChainHead->ClearCounts();
        ptpChainHead->IncreaseCounts( ptpInsertBefore, CTreePos::TP_LEFT );
        
        counts.Clear();
        counts.Increase( ptpChainHead );

        for ( ptpPrev = ptpChainHead, ptp = ptpChainHead->Parent(); 
              ptpPrev != ptpChainTail; 
              ptpPrev = ptp, ptp = ptp->Parent() )
        {
            Assert( ptp );

            ptp->ClearCounts();
            ptp->IncreaseCounts( ptpPrev, CTreePos::TP_BOTH );

#if DBG==1
            fCheckCounts = fCheckCounts || !ptp->IsPointer();
#endif

            counts.Increase( ptp );
        }

        // This method isn't used to insert pointers so
        // we must have some sort of count
        Assert( !fCheckCounts || counts.IsNonzero() );
        
        fLeftChild = TRUE;
        for (ptp = ptpInsertBefore; ptp; ptp = ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->IncreaseCounts( &counts );
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    RRETURN(S_OK);
}


//+----------------------------------------------------------------------------
//
//  Member:     FastElemTextSet
//
//  Synopsis:   Fast way to set the entire text of an element (e.g. INPUT).
//              Assumes that there is no overlapping.
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::FastElemTextSet(CElement * pElem, const TCHAR * psz, int c, BOOL fAsciiOnly)
{
    HRESULT         hr = S_OK;
    CTreePos *      ptpBegin;
    CTreePos *      ptpEnd;
    long            cpBegin, cpEnd;

    // make sure pointers are embedded

    hr = THR( EmbedPointers() );
    if (hr)
        goto Cleanup;
    
    // Assert that there is no overlapping into this element
    Assert( ! pElem->GetFirstBranch()->NextBranch() );

    pElem->GetTreeExtent( &ptpBegin, &ptpEnd );
    Assert( ptpBegin && ptpEnd );

    cpBegin = ptpBegin->GetCp() + 1;
    cpEnd = ptpEnd->GetCp();

    if( cpBegin != cpEnd || !fAsciiOnly)
    {
        CTreePosGap tpgBegin( TPG_LEFT ), tpgEnd( TPG_RIGHT );
        Verify( ! tpgBegin.MoveTo( ptpBegin, TPG_RIGHT ) );
        Verify( ! tpgEnd.MoveTo( ptpEnd, TPG_LEFT ) );

        hr = THR( SpliceTreeInternal( & tpgBegin, & tpgEnd ) );
        if (hr)
            goto Cleanup;

    #if DBG == 1
        {
            CTreePos * ptpEndAfter;
            pElem->GetTreeExtent( NULL, &ptpEndAfter );
            Assert( ptpEndAfter == ptpEnd );
        }
    #endif

        hr = THR( InsertTextInternal( ptpEnd, psz, c, NULL ) );
        if (hr)
            goto Cleanup;
    }
    else if (c)
    {
        CTreePos *      ptpText = ptpEnd;
        CTreePosGap     tpgPP(TPG_RIGHT);
        CNotification   nf;
        CInsertSpliceUndo Undo( Doc() );

        Verify( !tpgPP.MoveTo( ptpBegin, TPG_RIGHT ) );
        tpgPP.PartitionPointers( this, FALSE );

        Undo.Init( this, NULL );

        UpdateMarkupContentsVersion();

        Undo.SetData( cpBegin, cpBegin + c );

        // Build a notification (do we HAVE to do this?!?)
        nf.CharsAdded( cpBegin, c, pElem->GetFirstBranch() );

        ptpText = NewTextPos( c );
        hr = THR( Insert( ptpText, tpgPP.AttachedTreePos(), TRUE ) );
        if (hr)
            goto Cleanup;

        // Insert the text
        Verify(
            CTxtPtr( this, cpBegin ).
                InsertRange( c, psz ) == c );

        Notify( &nf );

        Undo.CreateAndSubmit();
    }

Cleanup:
    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////////////////
//      CTreePosGap
/////////////////////////////////////////////////////////////////////////////////

CTreePos *
CTreePosGap::AdjacentTreePos(TPG_DIRECTION eDir) const
{
    Assert(eDir==TPG_LEFT || eDir==TPG_RIGHT);
    AssertSz(_ptpAttach, "Gap is not positioned");
    BOOL fLeft = (eDir == TPG_LEFT);

    return (fLeft==!!_fLeft) ? _ptpAttach
                             : _fLeft ? _ptpAttach->NextTreePos()
                                      : _ptpAttach->PreviousTreePos();
}

#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreeNode *
CTreePosGap::Branch() const
{
    AssertSz(_ptpAttach, "Gap is not positioned");
    BOOL fLeft = _fLeft;
    CTreePos *ptp= _ptpAttach;

    if( !_ptpAttach->IsNode() ) 
    {
        fLeft = FALSE;
        do 
            ptp = ptp->NextTreePos();
        while ( !ptp->IsNode() );  
    }

    return (fLeft == ptp->IsEndNode()) ? ptp->Branch()->Parent()
                                       : ptp->Branch();
}

#if DBG != 1
#pragma optimize("", on)
#endif

BOOL
CTreePosGap::IsValid() const
{
    AssertSz(_ptpAttach, "Gap is not positioned");

    BOOL result = !_ptpAttach->IsNode();

    if (!result)
    {
        CTreePos *ptpLeft = _fLeft ? _ptpAttach : _ptpAttach->PreviousTreePos();
        CTreePos *ptpRight = _fLeft ? _ptpAttach->NextTreePos() : _ptpAttach;

        result = !(
            (ptpLeft->IsEndNode() && !ptpLeft->IsEdgeScope())
         || (ptpRight->IsBeginNode() && !ptpRight->IsEdgeScope())
            );
    }

    return result;
}


void
CTreePosGap::SetAttachPreference(TPG_DIRECTION eDir)
{
    _eAttach = eDir;

    if (eDir!=TPG_EITHER && (eDir==TPG_LEFT)!=!!_fLeft && _ptpAttach)
    {
        if (_fLeft)
        {
            MoveTo(_ptpAttach->NextTreePos(), TPG_LEFT);
        }
        else
        {
            MoveTo(_ptpAttach->PreviousTreePos(), TPG_RIGHT);
        }
    }
}


HRESULT
CTreePosGap::MoveTo(CTreePos *ptp, TPG_DIRECTION eDir)
{
    Assert(ptp && (eDir==TPG_LEFT || eDir==TPG_RIGHT));
    BOOL fLeft = (eDir != TPG_LEFT);        // now from the gap's point of view
    HRESULT hr;

    // adjust for my attach preference
    if (_eAttach!=TPG_EITHER && fLeft!=(_eAttach==TPG_LEFT))
    {
        ptp = fLeft ? ptp->NextTreePos() : ptp->PreviousTreePos();
        fLeft = !fLeft;
    }

    // make sure the requested gap is in the scope of the restricting element
    if (_pElemRestrict)
    {
        if (ptp->SearchBranchForElement(_pElemRestrict, !fLeft) == NULL)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }

    UnPosition();
    _ptpAttach = ptp;
    _fLeft = fLeft;
    WHEN_DBG( _ptpAttach->AttachGap(); )
    hr = S_OK;

Cleanup:
    return hr;
}

HRESULT
CTreePosGap::MoveToCp(CMarkup * pMarkup, long cp)
{
    HRESULT     hr;
    long        ich;
    CTreePos *  ptp;

    ptp = pMarkup->TreePosAtCp( cp, &ich );
    if(!ptp)
        return E_FAIL;
    
    if (ich)
    {
        Assert( ptp->IsText() );

        hr = THR( pMarkup->Split( ptp, ich ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveTo( ptp, TPG_RIGHT ) );
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( MoveTo( ptp, TPG_LEFT ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CTreePosGap::MoveImpl(BOOL fLeft,
                      DWORD dwMoveFlags,
                      CTreePos **pptpEdgeCrossed
                      )
{
    HRESULT hr;
    BOOL fFirstTime = TRUE;
    const BOOL fAttachToCurr = (fLeft == !_fLeft);
    CTreePos *ptpCurr = fAttachToCurr ? _ptpAttach :
            _fLeft ? _ptpAttach->NextTreePos() : _ptpAttach->PreviousTreePos();
    CTreePos *ptpAdv;
    CTreePos *ptpAttach = NULL;

    Assert(_eAttach!=TPG_EITHER ||
            0 == (dwMoveFlags & (TPG_SKIPPOINTERS | TPG_FINDTEXT | TPG_FINDEDGESCOPE)) );

    if (pptpEdgeCrossed)
        *pptpEdgeCrossed = NULL;

    for (ptpAdv = fLeft ? ptpCurr->PreviousTreePos() : ptpCurr->NextTreePos();
         ptpAdv;
         ptpCurr = ptpAdv,  ptpAdv = fLeft ? ptpCurr->PreviousTreePos() : ptpCurr->NextTreePos() )
    {
        ptpAttach = fAttachToCurr ? ptpCurr : ptpAdv;

        if (!fFirstTime)
        {
            // if we've left the scope of the restricting element, fail
            if (_pElemRestrict)
            {
                if (ptpCurr->IsNode() && ptpCurr->IsEdgeScope() &&
                    ptpCurr->Branch()->Element() == _pElemRestrict)
                {
                    ptpAdv = NULL;
                    break;
                }
            }

            // track any begin-scope or end-scope nodes that we cross over
            if (pptpEdgeCrossed && ptpCurr->IsNode() && ptpCurr->IsEdgeScope() )
            {
                AssertSz(*pptpEdgeCrossed == NULL, "Crossed multiple begin or endscope TreePos");
                *pptpEdgeCrossed = ptpCurr;
            }
        }
        else
        {
            // if it's not OK to stay still, force the first advance
            fFirstTime = FALSE;
            if (!(dwMoveFlags & TPG_OKNOTTOMOVE))
                continue;
        }

        // if caller wants a valid gap, advance if we're not in one
        if ((dwMoveFlags & TPG_VALIDGAP))
        {
            CTreePos *ptpLeft = fLeft ? ptpAdv : ptpCurr;
            CTreePos *ptpRight = fLeft ? ptpCurr : ptpAdv;
            if (!CTreePos::IsLegalPosition(ptpLeft, ptpRight))
                continue;
        }

        // if caller wants to skip pointers, advance if we're at one
        if (ptpAttach->IsPointer() && (dwMoveFlags & TPG_SKIPPOINTERS))
            continue;

        // if caller wants a text position, advance if we're not at one
        if (!ptpAttach->IsText() && (dwMoveFlags & TPG_FINDTEXT))
            continue;

        // if caller wants an edge-scope position, advance if we're not at one
        if ((dwMoveFlags & TPG_FINDEDGESCOPE) &&
            !(ptpAttach->IsNode() && ptpAttach->IsEdgeScope()) )
            continue;

        // if we've survived the gauntlet above, we're in a good gap
        break;
    }

    // if we found a good gap, move there
    if (ptpAdv)
    {
        UnPosition();
        _ptpAttach = ptpAttach;
        WHEN_DBG( _ptpAttach->AttachGap(); )
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}


/////////////////////////////////////////////////////////
// Method:      PartitionPointers
//
// Synopsis:    Permute any Pointer treepos around this gap so that the
//              ones with left-gravity come before the ones with right-
//              gravity, and the gap is positioned between the two groups.
//              Within each group, the pointers should be stable - i.e. they
//              maintain their relative positions.
//
//              Normal operation treats empty text poses as pointers
//              with right gravity.  However, if fDOMPartition is TRUE,
//              then empty text poses are treated as content.

// NOTE:        this might be faster if we didn't use gaps internally

void
CTreePosGap::PartitionPointers(CMarkup * pMarkup, BOOL fDOMPartition)
{
    TPG_DIRECTION eSaveAttach = (TPG_DIRECTION)_eAttach;
    CTreePosGap tpgMiddle( TPG_RIGHT );

    Assert( ! AttachedTreePos()->GetMarkup()->HasUnembeddedPointers() );
    Assert( pMarkup );

    // move left to the beginning of the block of pointers
    SetAttachPreference(TPG_LEFT);
    while ( AttachedTreePos()->IsPointer()
        ||      AttachedTreePos()->IsText() && AttachedTreePos()->Cch() == 0 
            &&  (!fDOMPartition || AttachedTreePos()->TextID() == 0 ) )
    {
        MoveLeft();
    }

    // now move right, looking for left-gravity pointers
    SetAttachPreference(TPG_RIGHT);
    tpgMiddle.MoveTo( this );
    while ( AttachedTreePos()->IsPointer()
        ||      AttachedTreePos()->IsText() && AttachedTreePos()->Cch() == 0 
            &&  (!fDOMPartition || AttachedTreePos()->TextID() == 0 ) )
    {
        if (    AttachedTreePos()->IsPointer() 
            &&  AttachedTreePos()->Gravity() == POINTER_GRAVITY_Left)
        {
            // If tpg is in the same place, no need to move the pointer.
            if(AttachedTreePos() != tpgMiddle.AttachedTreePos())
            {
                CTreePos * ptpToMove = AttachedTreePos();

                // Don't move us along with the pointer.
                SetAttachPreference(TPG_LEFT);

                Verify( ! pMarkup->Move(ptpToMove, &tpgMiddle) );

                // So now we're attached to the next pointer.
                SetAttachPreference(TPG_RIGHT);
            }
            else
            {
                // Nothing changed, so move on ahead.
                MoveRight();
                tpgMiddle.MoveTo( this );
            }
        }
        else
        {
            MoveRight();
        }
    }

    // Position myself in the middle
    MoveTo( &tpgMiddle );

    // restore my state
    SetAttachPreference(eSaveAttach);
}

/////////////////////////////////////////////////////////
// Method:      CleanCling
//
// Synopsis:    Assuming that the current gap is in 
//              the middle of a group of pointers that
//              has been positioned

void    
CTreePosGap::CleanCling( CMarkup *pMarkup, TPG_DIRECTION eDir, BOOL fDOMPartition )
{
    Assert( eDir == TPG_LEFT || eDir == TPG_RIGHT );
    BOOL fLeft = eDir == TPG_LEFT;
    CTreePos * ptp = AdjacentTreePos( eDir );
    CTreePos * ptpNext;

    while ( ptp->IsPointer()
        ||      ptp->IsText() && ptp->Cch() == 0 
            &&  (!fDOMPartition || ptp->TextID() == 0 ) )
    {
        ptpNext = fLeft ? ptp->PreviousTreePos() : ptp->NextTreePos();

        if (    ptp->IsPointer() && ptp->Cling()
            ||      ptp->IsText() && ptp->Cch() == 0 
                &&  (!fDOMPartition || ptp->TextID() == 0 ) )
        {
            if (AttachedTreePos() == ptp)
            {
                Assert( AttachDirection() == eDir );
                Move( eDir );
            }

            Verify( ! pMarkup->Remove( ptp ) );
        }

        ptp = ptpNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Class:      CChildIterator
//
///////////////////////////////////////////////////////////////////////////////

CChildIterator::CChildIterator( 
    CElement * pElementParent,
    CElement * pElementChild,
    DWORD dwFlags,
    ELEMENT_TAG *pStopTags,
    long cStopTags,
    ELEMENT_TAG *pChildTags,
    long cChildTags)
{
    AssertSz( !(dwFlags & ~CHILDITERATOR_PUBLICMASK), "Invalid flags passed to CChildIterator constructor" );
    _dwFlags = dwFlags;

#ifndef V4FRAMEWORK // CTreeIterator initializes safetly with NULL Parent
    Assert( pElementParent );
#endif V4FRAMEWORK

    if( pElementChild )
    {
        _pNodeChild = pElementChild->GetFirstBranch();

        Assert( _pNodeChild );

        _pNodeParent = _pNodeChild->SearchBranchToRootForScope( pElementParent );
        Assert( _pNodeParent );
    }
    else
    {
        SetBeforeBeginBit();
        _pNodeChild = NULL;
        _pNodeParent = pElementParent->GetFirstBranch();
    }

    AssertSz( _pNodeParent, "CChildIterator used with parent not in tree -- not a tree bug");

    if (UseTags())
    {
        _pStopTags = pStopTags;
        _cStopTags = cStopTags;

        _pChildTags = pChildTags;
        _cChildTags = cChildTags;
    }
    
#if DBG == 1
    if(_pNodeParent && _pNodeParent->GetMarkup())
        _lTreeVersion = _pNodeParent->GetMarkup()->GetMarkupTreeVersion();
#endif
}


void
CChildIterator::SetChild( CElement * pElementChild )
{
    WHEN_DBG( Invariant() );

    Assert( pElementChild && pElementChild->GetFirstBranch() );

    _pNodeChild = pElementChild->GetFirstBranch();
    _pNodeParent = _pNodeChild->SearchBranchToRootForScope( _pNodeParent->Element() );

    Assert( _pNodeParent );
}

void
CChildIterator::SetBeforeBegin( )
{
    WHEN_DBG( Invariant() );

    _pNodeChild = NULL;
    _pNodeParent = _pNodeParent->Element()->GetFirstBranch();

    Assert( _pNodeParent );

    SetBeforeBeginBit();
    ClearAfterEndBit();
}

void
CChildIterator::SetAfterEnd( )
{
    WHEN_DBG( Invariant() );

    _pNodeChild = NULL;
    _pNodeParent = _pNodeParent->Element()->GetFirstBranch();

    while (_pNodeParent->NextBranch())
        _pNodeParent = _pNodeParent->NextBranch();

    Assert( _pNodeParent );

    ClearBeforeBeginBit();
    SetAfterEndBit();
}

BOOL 
CChildIterator::ReInitWithCurrentChild()
{
    WHEN_DBG( Invariant() );

    // If we are after the end of the child list,
    // we can't go any further
    if( IsAfterEnd() || IsBeforeBegin() )
        return FALSE;

    Assert( _pNodeChild );

    _pNodeParent = _pNodeChild;
    _pNodeChild = NULL;
    SetBeforeBeginBit();

    return TRUE;
}

BOOL 
CChildIterator::ReInitWithParent()
{
    WHEN_DBG( Invariant() );

    Assert( _pNodeParent );

    if ( !_pNodeParent->Parent() )
        return FALSE;

    _pNodeChild = _pNodeParent;
    _pNodeParent = _pNodeParent->Parent();

    ClearBeforeBeginBit();
    ClearAfterEndBit();

    return TRUE;
}

CTreeNode * 
CChildIterator::NextChild()
{
    WHEN_DBG( Invariant() );

    // If we are after the end of the child list,
    // we can't go any further
    if( IsAfterEnd() )
        return NULL;

    CTreePos * ptpCurr;
    CTreeNode *pNodeParentCurr = _pNodeParent;
    BOOL       fFirst = TRUE;

    //
    // Decide where to start.  
    // * If we already have a child either start after that 
    //   child or just inside of it, dependent on the virtual 
    //   IsRecursionStopChildNode call.
    // * If we are before begin, start just inside of the
    //   parent node.
    //
    if( _pNodeChild )
    {
        ptpCurr = IsRecursionStopChildNode( _pNodeChild )
            ? _pNodeChild->GetEndPos()
            : _pNodeChild->GetBeginPos();
    }
    else
    {
        Assert( IsBeforeBeginBit() );
        ClearBeforeBeginBit();

        ptpCurr = _pNodeParent->GetBeginPos();
    }

    Assert( ptpCurr && !ptpCurr->IsUninit() );

    //
    // Do this loop while we have a parent that we are interested in
    //
    while (pNodeParentCurr)
    {
        CTreePos *  ptpParentEnd = pNodeParentCurr->GetEndPos();

        fFirst = FALSE;

        // Since this is a good parent, set the member variable
        _pNodeParent = pNodeParentCurr;

        //
        // Loop through everything under this parent.
        //
        for( ptpCurr = ptpCurr->NextTreePos();
             ptpCurr != ptpParentEnd;
             ptpCurr = ptpCurr->NextTreePos() )
        {
            // If this is a begin node, investigate further
            if( ptpCurr->IsBeginNode() )
            {
                CTreeNode * pNodeChild = ptpCurr->Branch();

                // return this node if we have an edge scope and
                // the child is interesting.
                if( ptpCurr->IsEdgeScope() && 
                    IsInterestingChildNode( pNodeChild ) )
                {
                    _pNodeChild = pNodeChild;
                    return _pNodeChild;
                }
                
                // Decide if we want to skip over this node's
                // subtree
                if( IsRecursionStopChildNode( pNodeChild ) )
                {
                    ptpCurr = pNodeChild->GetEndPos();
                }
            }
        }

        // Move on to the next parent node
        pNodeParentCurr = pNodeParentCurr->NextBranch();
        if( pNodeParentCurr )
        {
            ptpCurr = pNodeParentCurr->GetBeginPos();
        }
    }

    // If we got here, we ran out of parent nodes, so we must be
    // after the end.
    SetAfterEndBit();
    _pNodeChild = NULL;
    return NULL;
}

CTreeNode * 
CChildIterator::PreviousChild()
{
    WHEN_DBG( Invariant() );

    // If we are after the end of the child list,
    // we can't go any further
    if( IsBeforeBegin() )
        return NULL;

    CTreePos * ptpCurr;
    CTreeNode *pNodeParentCurr = _pNodeParent;

    //
    // Decide where to start.  
    // * If we already have a child either start before that 
    //   child or just inside of it, dependent on the virtual 
    //   IsRecursionStopChildNode call.
    // * If we are after end, start just inside of the
    //   parent node.
    //
    if( _pNodeChild )
    {
        ptpCurr = IsRecursionStopChildNode( _pNodeChild )
            ? _pNodeChild->GetBeginPos()
            : _pNodeChild->GetEndPos();
    }
    else
    {
        Assert( IsAfterEndBit() );
        ClearAfterEndBit();

        ptpCurr = _pNodeParent->GetEndPos();
    }

    while( pNodeParentCurr )
    {
        CTreePos * ptpStop = pNodeParentCurr->GetBeginPos();

        // Since this is a good parent, set the member variable
        _pNodeParent = pNodeParentCurr;

        //
        // Loop through everything under this parent.
        //
        for( ptpCurr = ptpCurr->PreviousTreePos();
             ptpCurr != ptpStop;
             ptpCurr = ptpCurr->PreviousTreePos() )
        {
            Assert(     ! ptpCurr->IsNode() 
                    ||  ptpCurr->Branch()->SearchBranchToRootForNode( pNodeParentCurr ) );

            // If this is a begin node, investigate further
            if( ptpCurr->IsEndNode() )
            {
                CTreeNode * pNodeChild = ptpCurr->Branch();
                CTreePos * ptpBegin = pNodeChild->GetBeginPos();

                // return this node if we have an edge scope and
                // the child is interesting.
                if( ptpBegin->IsEdgeScope() && 
                    IsInterestingChildNode( pNodeChild ) )
                {
                    _pNodeChild = pNodeChild;
                    return _pNodeChild;
                }
                
                // Decide if we want to skip over this nodes
                // subtree
                if( IsRecursionStopChildNode( pNodeChild ) )
                {
                    ptpCurr = ptpBegin;
                }
            }
        }

        // Find the previous node in the context chain
        if( pNodeParentCurr == pNodeParentCurr->Element()->GetFirstBranch() )
        {
            pNodeParentCurr = NULL;
        }
        else
        {
            CTreeNode * pNodeTemp = pNodeParentCurr->Element()->GetFirstBranch();
            while( pNodeTemp->NextBranch() != pNodeParentCurr )
            {
                pNodeTemp = pNodeTemp->NextBranch();
            }
            Assert( pNodeTemp );
            pNodeParentCurr = pNodeTemp;
        }

        if( pNodeParentCurr )
        {
            ptpCurr = pNodeParentCurr->GetEndPos();
        }
    }

    // If we got here, we ran out of parent nodes, so we must be
    // before begin.
    SetBeforeBeginBit();
    _pNodeChild = NULL;
    return NULL;
}

#if DBG==1
void
CChildIterator::Invariant()
{
    CMarkup *pMarkup = _pNodeParent->GetMarkup();
    Assert (pMarkup);
    AssertSz( pMarkup->GetMarkupTreeVersion() == _lTreeVersion,
              "CChildIterator used while tree is changing" );
    Assert( !!IsBeforeBeginBit() + !!IsAfterEndBit() + !!_pNodeChild == 1 );
}
#endif


BOOL
CChildIterator::IsInterestingNode(ELEMENT_TAG * pary, long c, CTreeNode * pNode)
{
    if (UseLayout())
    {
        return pNode->ShouldHaveLayout();
    }

    if (UseTags() && c > 0)
    {
        long   i;

        for (i = 0; i < c; i++, pary++)
        {
            if (*pary == pNode->Tag())
                return TRUE;
        }

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\tinfo.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module TINFO.CXX -- tree info related stuff
 *
 *
 *  Owner: <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      5/6/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

//-----------------------------------------------------------------------------
//
//  Function:   InitializeTreeInfo
//
//  Synopsis:   Initializes the tree info structure at the current cp/irun
//
//  Returns:    HR
//
//-----------------------------------------------------------------------------
HRESULT
CTreeInfo::InitializeTreeInfo(CFlowLayout *pFlowLayout, BOOL fIsEditable, LONG cp, CTreePos *ptp)
{
    HRESULT hr = S_FALSE;
    CTreeNode *pNode;
    
    //
    // Setup the easy stuff first
    //
    Assert(pFlowLayout);
    _pFlowLayout = pFlowLayout;
    _fIsEditable = fIsEditable;
    Assert(!!_fIsEditable == !!_pFlowLayout->IsEditable());
    _pMarkup = pFlowLayout->GetContentMarkup();
    _lscpFrontier = cp;
    _cpFrontier = cp;
    _chSynthsBefore = 0;
    _fHasNestedElement = _fHasNestedLayout = _fHasNestedRunOwner = FALSE;
    
    //
    // If a ptp was specified, use it, or find one from basice principles
    //
    if (ptp == NULL)
    {
        LONG cchOffset;
        
        _ptpFrontier = _pMarkup->TreePosAtCp(cp, &cchOffset, TRUE);
        if (_ptpFrontier == NULL)
            goto Cleanup;
    }
    else
    {
        _ptpFrontier = ptp;
    }
    Assert(_ptpFrontier);
    Assert(   _ptpFrontier->GetCp() <= cp
           && _ptpFrontier->GetCp() + _ptpFrontier->GetCch() >= cp
          );
    
    //
    // Figure out if we are positioned at a layout/nested run owner
    //
    if (_ptpFrontier->IsBeginElementScope())
    {
        pNode = _ptpFrontier->Branch();

        if (pNode->ShouldHaveLayout())
        {
            _fHasNestedElement = TRUE;
            _fHasNestedLayout = TRUE;
            if (pNode->Element()->IsRunOwner())
            {
                Assert(pNode->Element() != _pFlowLayout->ElementContent());
                _fHasNestedRunOwner = TRUE;
            }
        }
    }
    
    //
    // How many characters in this tree node?
    //
    if (_ptpFrontier->IsText() && _ptpFrontier->Cch() != 0)
    {
        WHEN_DBG(LONG ichTemp);
        LONG ich = cp - _ptpFrontier->GetCp();
        
        SetCchRemainingInTreePos(_ptpFrontier->Cch() - ich);

#if DBG==1
        if (GetCchRemainingInTreePosReally())
        {
            CTreePos *ptpDbg = _pMarkup->TreePosAtCp(cp, &ichTemp, TRUE);
            while(ptpDbg && ptpDbg->IsPointer())
                ptpDbg = ptpDbg->NextTreePos();
            Assert(_ptpFrontier == ptpDbg);
            Assert(ich == ichTemp);
        }
#endif        
    }
    else if (_ptpFrontier->IsNode() && !_fHasNestedElement)
    {
        if (_ptpFrontier->IsEdgeScope())
            SetCchRemainingInTreePos(1);
        else
            SetCchRemainingInTreePos(0, TRUE);
    }
    else
        SetCchRemainingInTreePos(0);
    
    //
    // Setup the text related state variables
    //
    _tpFrontier.SetCp(cp);
    _pchFrontier = _tpFrontier.GetPch(_cchValid);
    if (_pchFrontier == NULL)
        goto Cleanup;
    _tpFrontier.AdvanceCp(_cchValid);
    
    //
    // Decide the CF's and PF's
    //
    pNode = _ptpFrontier->GetBranch();
    SetupCFPF(TRUE, pNode FCCOMMA LC_TO_FC(pFlowLayout->LayoutContext()));

    if (   !_fHasNestedElement
        && !_fIsEditable
        && _ptpFrontier->IsNode()
        && _pCF->IsDisplayNone()
       )
    {
        _fHasNestedElement = TRUE;
        SetCchRemainingInTreePos(0);
    }

    _fInited = TRUE;

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   SetupCFPF
//
//  Synopsis:   Sets up the CF and PF in the tree info including the 'inner' flags
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CTreeInfo::SetupCFPF(BOOL fIniting, CTreeNode *pNode FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    // Get the CF
    _pCF = pNode->GetCharFormat(FCPARAM);
    _fInnerPF = _fInnerCF = SameScope(pNode, _pFlowLayout->ElementContent());

    if (fIniting)
    {
        _pPF = pNode->GetParaFormat(FCPARAM);
        _iPF = pNode->GetParaFormatIndex(FCPARAM);
        _pFF = pNode->GetFancyFormat(FCPARAM);
        _iFF = pNode->GetFancyFormatIndex(FCPARAM);
    }
    else
    {
        LONG iPF = pNode->GetParaFormatIndex(FCPARAM);
        LONG iFF = pNode->GetFancyFormatIndex(FCPARAM);

        if (iPF != _iPF)
        {
            extern CParaFormat g_pfStock;

            _iPF = iPF;
            _pPF = iPF >= 0 ? GetParaFormatEx(_iPF) : &g_pfStock;
            
        }

        if (iFF != _iFF)
        {
            extern CFancyFormat g_ffStock;

            _iFF = iFF;
            _pFF = iFF >= 0 ? GetFancyFormatEx(_iFF) : &g_ffStock;
        }

        Assert(_pFF == pNode->GetFancyFormat(FCPARAM));
        Assert(_pPF == pNode->GetParaFormat(FCPARAM));
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceTreePos
//
//  Synopsis:   Advances the frontier to the next tree position
//
//  Returns:    Was advance sucessful?
//
//-----------------------------------------------------------------------------
BOOL
CTreeInfo::AdvanceTreePos(FORMAT_CONTEXT FCPARAM)
{
    CTreePos  *ptp  = _ptpFrontier;
    BOOL       fRet = FALSE;
    CTreeNode *pNode;
    BOOL       fCallSetupCFPF;
    
    Assert(GetCchRemainingInTreePos() == 0);
    Assert(_fHasNestedElement == FALSE);

    //
    // If this is the end node then do not go any further.
    //
    if (ptp == _ptpLayoutLast)
    {
        fRet = TRUE;
        goto Cleanup;
    }

    //
    // If we were at an end-ptp, and the ptp after us were a text ptp
    // then we will want to setup the cfpf with the end-ptp's parent node
    // If the next ptp were a node ptp, then the pNode will be overwritten
    //
    pNode = ptp->IsEndNode() ? ptp->Branch()->Parent() : NULL;
    
    // Find a desireable pos to be in
    //
    for(ptp = ptp->NextTreePos(); ; ptp = ptp->NextTreePos())
    {
        Assert(ptp);
        if(!ptp)
        {
            fRet = FALSE;
            goto Cleanup;
        }

        if (   ptp->IsNode()
            || (ptp->IsText() && ptp->Cch())
           )
            break;

        // Since _ptpLayoutLast is a Node above check should have succeeded
        Assert(ptp != _ptpLayoutLast);
    }

    if (ptp->IsNode())
    {
        pNode = ptp->Branch();
        //
        // TODO (SujalP, IE6 bug 62): Might have a problem with overlapping layout-scopes here
        //
        if (   ptp->IsBeginElementScope()
            && pNode->ShouldHaveLayout(FCPARAM)
           )
        {
            CElement *pElement = pNode->Element();
            if (pElement->IsRunOwner())
            {
                Assert(pElement != _pFlowLayout->ElementContent());

#if DBG==1
// There's some issue here with how we get layouts.  Disable debug
// checks for now
#ifndef MULTI_LAYOUT

                CLayout *pLayout1, *pLayout2;

                pLayout1 = _pMarkup->GetRunOwner(pNode, _pFlowLayout);
                Assert( pElement->ShouldHaveLayout() && "Should have confirmed node needs layout!");
                pLayout2 = pElement->GetUpdatedLayout();
                CElement *pElementOwner1 = pLayout1->ElementOwner();

                //
                // NOTE(SujalP): This assert is invalid when we have nested layouts.
                // See bug 54648.
                //
                if (   pElementOwner1
                    && pElementOwner1->IsOverlapped()
                   )
                {
                    pLayout1 = pLayout2;
                }
                    
                Assert(pLayout1 == pLayout2);
#endif // MULTI_LAYOUT
#endif // DBG
                _fHasNestedRunOwner = TRUE;
            }
            _fHasNestedElement = TRUE;
            _fHasNestedLayout = TRUE;
            SetCchRemainingInTreePos(0);
        }
        else if (ptp->IsEdgeScope())
            SetCchRemainingInTreePos(1);
        else
            SetCchRemainingInTreePos(0, TRUE);

        fCallSetupCFPF = (ptp == _ptpLayoutLast) ? FALSE : TRUE;
    }
    else
    {
        fCallSetupCFPF = pNode ? TRUE : FALSE;
        SetCchRemainingInTreePos(ptp->Cch());
    }

    if (fCallSetupCFPF)
    {
        Assert(pNode);
        SetupCFPF(FALSE, pNode FCCOMMA FCPARAM);
        if (   _pCF->IsDisplayNone()
            && !_fHasNestedElement
            && !_fIsEditable
            && ptp->IsBeginElementScope()
           )
        {
            AssertSz(ptp->IsNode(), "Cannot have a hidden text run here!");
            _fHasNestedElement = TRUE;
            SetCchRemainingInTreePos(0);
        }
    }
    
    _ptpFrontier = ptp;
    fRet = TRUE;
    
Cleanup:
    Assert(fRet);
    return fRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceTxtPtr
//
//  Synopsis:   Advances the text pointer further into the text.
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------
BOOL
CTreeInfo::AdvanceTxtPtr()
{
    Assert(_cchValid == 0);

    _pchFrontier = _tpFrontier.GetPch(_cchValid);
    _tpFrontier.AdvanceCp(_cchValid);
    return !!_pchFrontier;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceFrontier.
//
//  Synopsis:   Advances the frontier based on the onerun. Called at the tail end
//              of advance one run.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CTreeInfo::AdvanceFrontier(COneRun *por)
{
    if (por->_lscch == 0 && !por->_fIsNonEdgePos)
    {
        Assert(por->_ptp == _ptpLayoutLast);
        goto Cleanup;
    }

    Assert(!por->IsSyntheticRun());
    if (_fHasNestedElement)
    {
        Assert(_ptpFrontier->IsNode());

        CTreePos  * ptpStart, *ptpStop;
        CElement  * pElement    = _ptpFrontier->Branch()->Element();
        long        cpElemLast  = pElement->GetLastCp();

        pElement->GetTreeExtent(&ptpStart, &ptpStop);
        Assert(ptpStart == _ptpFrontier);
        Assert(ptpStop);

        // for elements overlapping with our layout, advance the frontier to the
        // end of the current layout owner
        if(cpElemLast > _cpLayoutLast)
        {
            ptpStop = _ptpLayoutLast->PreviousTreePos();
        }

        _ptpFrontier = ptpStop;
        _fHasNestedElement  = FALSE;
        _fHasNestedLayout   = FALSE;
        _fHasNestedRunOwner = FALSE;

        //
        // Now advance the cp values past this one run
        //
        Assert(     por->_lscch == pElement->GetElementCch() + 2
                ||  (   cpElemLast > _cpLayoutLast
                    &&  _cpLayoutLast == _cpFrontier + por->_lscch));

        SetCchRemainingInTreePos(0);
        _lscpFrontier += por->_lscch;
        _cpFrontier += por->_lscch;
        
        //
        // Take care of the text related state vars
        //
        if (por->_lscch > _cchValid)
        {
            // The text run ended inside the table
            _tpFrontier.SetCp(_cpFrontier);
            _cchValid = 0;
        }
        else
        {
            _cchValid -= por->_lscch;
            _pchFrontier += por->_lscch;
        }
    }
    else
    {
        Assert(GetCchRemainingInTreePosReally() >= por->_lscch);

        if (_fIsNonEdgePos)
        {
            Assert(por->_lscch == 0);
            Assert(GetCchRemainingInTreePosReally() == 0);
            SetCchRemainingInTreePos(0);
        }
        else
        {
            SetCchRemainingInTreePos(GetCchRemainingInTreePosReally() - por->_lscch);
        }
        _lscpFrontier += por->_lscch;
        _cpFrontier += por->_lscch;
        
        Assert(_cchValid >= por->_lscch);
        _cchValid -= por->_lscch;
        _pchFrontier += por->_lscch;
    }
Cleanup:
    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   FigureNextPtp.
//
//  Synopsis:   Figures the ptp at the cp
//
//  Returns:    CTreePos *
//
//-----------------------------------------------------------------------------
CTreePos *
CLineServices::FigureNextPtp(LONG cp)
{
    COneRun *por = _listCurrent._pTail;
    CTreePos *ptp = NULL;
    LONG cpAtEndOfOneRun;

    Assert(_treeInfo._fInited);
    
    if (!por)
        goto Cleanup;

    ptp = por->_ptp;
    if (ptp->IsBeginElementScope() && ptp->Branch()->ShouldHaveLayout())
    {
        GetNestedElementCch(ptp->Branch()->Element(), &ptp);
    }
    cpAtEndOfOneRun = por->Cp() + (por->IsSyntheticRun() ? 0 : por->_lscch);

    if (cpAtEndOfOneRun <= cp)
    {
        LONG cpAtEndOfPtp;

        if (   !por->IsSyntheticRun()
            && cpAtEndOfOneRun == cp
            && por->_lscch == ptp->GetCch()
           )
            cpAtEndOfPtp = cpAtEndOfOneRun;
        else
            cpAtEndOfPtp = ptp->GetCp() + ptp->GetCch();

        while (cpAtEndOfPtp <= cp)
        {
            Assert(ptp != _treeInfo._ptpLayoutLast);
            if (ptp->IsBeginElementScope() && ptp->Branch()->ShouldHaveLayout())
            {
                GetNestedElementCch(ptp->Branch()->Element(), &ptp);
            }
            else
            {
                ptp = ptp->NextTreePos();
            }
	    if(!ptp)
            {
		ptp = NULL;
                goto Cleanup;
            }
            cpAtEndOfPtp = ptp->GetCp() + ptp->GetCch();
        }
    }
    else
    {
        while (por)
        {
            if (   por->Cp() <= cp
                && por->Cp() + por->_lscch > cp
               )
            {
                break;
            }
            por = por->_pPrev;
        }
        Assert(por);

        //
        // Note(SujalP): Bug63941 shows us the problem that if we ended up on an
        // antisynthetic run, then the cp could anywhere within that run and hence
        // the ptp could be anything -- not necessarily the ptp of the first cp of
        // the run. Hence, if the cp is not the first cp of the anitsynth run then
        // we will derive the ptp from basic principles.
        //
        if (   !por
            || (   por->IsAntiSyntheticRun()
                && por->Cp() != cp
               )
           )
        {
            long junk;
            ptp = _treeInfo._pMarkup->TreePosAtCp(cp, &junk, TRUE);
        }
        else
            ptp = por->_ptp;
    }

#if DBG==1
    {
        long junk;
        CTreePos *ptpDbg = _treeInfo._pMarkup->TreePosAtCp(cp, &junk, TRUE);
        while (ptpDbg 
               && (ptpDbg->IsPointer() 
                   || (ptpDbg->IsNode() && !ptpDbg->IsEdgeScope())))
        {
            ptpDbg = ptpDbg->NextTreePos();
        }
        Assert(ptpDbg == ptp);
    }
#endif
    
    Assert(cp >= ptp->GetCp() && cp < ptp->GetCp() + ptp->GetCch());

Cleanup:
    return ptp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\splice.cxx ===
//+---------------------------------------------------------------------------
//
//  splice.cxx
//
//  CMarkup::SpliceTree implementation
//
//  SpliceTree can remove, copy, or move, or undo a remove 
//  of a range in the tree.
//  
//  Remove: SpliceTree's behavior is to remove all the text in the
//          specified range, as well as all elements that fall completely
//          in the range.
//
//          The sematics are such that if an element is not in a range
//          completely, its end tags will not be moved with respect
//          to other elements.  However, it may be necessary to
//          reduce the number of nodes for that element.  When this
//          happens, the nodes will be removed from the right edge.
//
//          Pointers without cling in the range end up in the space
//          between the end tags and the begin tags (arguably they should
//          stick between the end tags). Pointers with cling are removed.
//
//  Copy:   All the text in the specified range, as well as elements that
//          fall completely in the range, are copied.
//
//          Elements that overlap the range on the left are copied; begin
//          edges are implied at the very beginning of the range, in the
//          same order in which the begin edges appear in the source.
//
//          Elements that overlap the range on the right are copied; end
//          edges are implied at the very end of the range, in the same
//          order in which they appear in the source.
//
//  Move:   All the text in the specified range, as well as elements that
//          fall completely in the range, are moved (removed and inserted
//          into the new location, not copied).
//
//          Elements that overlap on the right or the left are modified
//          using the same rules as Remove, then copied to the new location
//          using the same rules as Copy.
//
//  Undo Remove: This use of SpliceTree is only called from the undo code.
//          Essentially it is a move driven by data that collected in
//          a previous remove.  To complicate matters, we must weave the
//          saved data through the already present tree.
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

PerfDbgExtern(tagPerfWatch)
MtExtern(CollapsedWhitespace);

//+---------------------------------------------------------------------------
//
//  SpliceTree and supporting classes
//
//----------------------------------------------------------------------------

MtDefine(CSpliceTreeEngine_pchRecord, Locals, "CSpliceTreeEngine_pchRecord");
MtDefine(CSpliceTreeEngine_aryElement, Locals, "CSpliceTreeEngine_aryElement");
MtDefine(CSpliceTreeEngine_InsertSplice_aryNodeStack_pv, Locals, "CSpliceTreeEngine::InsertSplice aryNodeStack::_pv");
MtDefine(CSpliceTreeEngine_RemoveSplice_aryDelayRelease_pv, Locals, "CSpliceTreeEngine::RemoveSplice aryDelayRelease::_pv");
MtDefine(CSpliceTreeEngine_pchRemoved, Locals, "CSpliceTreeEngine_pchRemoved");
MtDefine(CSpliceRecordList, Undo, "CSpliceRecordList (used in SpliceTree and undo)");
MtDefine(CSpliceRecordList_pv, CSpliceRecordList, "CSpliceRecordList::_pv");

//+---------------------------------------------------------------------------
//
//  Class:      CSpliceTreeEngine
//
//  Synposis:   The class that actually does the work for SpliceTree
//
//----------------------------------------------------------------------------
class CSpliceTreeEngine
{
public:
    CSpliceTreeEngine( CDoc * pDoc );
    ~CSpliceTreeEngine();
    
    HRESULT Init(CMarkup *pMarkupSource, CTreePosGap *ptpgSourceL, CTreePosGap *ptpgSourceR,
                         CMarkup *pMarkupTarget, CTreePosGap *ptpgTarget, BOOL fRemove, DWORD dwFlags);

    HRESULT InitUndoRemove( CMarkup * pMarkupTarget, CTreePosGap * ptpgTarget,
                            CSpliceRecordList * paryRegion, long cchRemove, 
                            TCHAR * pchRemove, DWORD dwFlags );
                         
    HRESULT RecordSplice();
    HRESULT RemoveSplice();
    HRESULT InsertSplice();

    // Used by RecordSplice
    HRESULT NoteRightElement(CElement *pel);
    HRESULT RecordLeftBeginElement(CElement *pel);
    HRESULT RecordBeginElement(CElement *pel);
    HRESULT RecordEndElement(long cInclTotal, long cInclSkip, BOOL fElementStays, BOOL fSynth);
    HRESULT RecordTextPos(unsigned long cch, unsigned long sid, long lTextID);
    HRESULT RecordPointer(CMarkupPointer *pmp);
    HRESULT RecordCollapsedWhitespace(TCHAR *pchCollapsedWhitespace, BOOL fGravity);
    void    RecordReverse();
    HRESULT RecordText(const TCHAR *pch, long cch);
    HRESULT RecordStory(CTxtPtr *ptx, long cch);
    HRESULT RecordNodeChars(long cch);
    LONG    LeftOverlap();

    // Used by InsertSplice
    CSpliceRecord *FirstRecord();
    CSpliceRecord *NextRecord();
    void GetNodeCharsRemove( long *pcchNode );
    void GetTextRecorded(const TCHAR **ppch, long *pcch);

    // Control flags
    BOOL _fInsert;
    BOOL _fRemove;
    BOOL _fDOMOperation;

    // Source pointers
    CMarkup *_pMarkupSource;
    CTreeNode *_pnodeSourceTop;
    CTreePos *_ptpSourceL;
    CTreePos *_ptpSourceR;
    CTreeNode *_pnodeSourceL;
    CTreeNode *_pnodeSourceR;
    
    // Target pointers
    CMarkup *_pMarkupTarget;
    CTreePos *_ptpTarget;

    // Text
    TCHAR *_pchRecord;
    LONG _cchRecord;
    LONG _cchRecordAlloc;
    
    // Recorded information

    CSpliceRecord *_prec;
    LONG _crec;
    enum WhichAry { AryNone = 0, AryLeft = 1, AryInside = 2, AryDone = 3 } _cAry;
    BOOL _fReversed;

    // Undo source
    CSpliceRecordList * _paryRemoveUndo;
    BOOL                _fNoFreeRecord;
    
    // TreeSync / Remove Undo
    DWORD    _fTreeSyncSource:1;            // Sync-ing source?
    DWORD    _fTreeSyncTarget:1;            // Sync-ing target?
    DWORD    _fRecordRemoveUndo:1;          // Do we need to record remove splice info?
    DWORD    _fDontReleaseRUInfo:1;         // Don't release Remove Undo info - Undo unit now owns

    CSpliceRecordList * _paryRemovedRegion; // Remove splice info.
    TCHAR * _pchRemoved;                    // Text removed

    CElement **_ppelRight;
    
    WHEN_DBG( BOOL  _fRemoveUndo );

    //------------------------------------------
    // Everything below this line will *not*
    // get memset to 0

    CSpliceRecordList _aryLeft;
    CSpliceRecordList _aryInside;
    
    CPtrAry<CElement *> _aryElementRight;

    // Undo classes
    CRemoveSpliceUndo   _RemoveUndo;
    CInsertSpliceUndo   _InsertUndo;
};

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceRecordList dtor
//
//  Synposis:   Releases everything from the CSpliceRecordList
//
//----------------------------------------------------------------------------
CSpliceRecordList::~CSpliceRecordList()
{
    CSpliceRecord * prec = (CSpliceRecord*)PData();
    long            c = Size();

    for( ; c ; c--, prec++ )
    {
        Assert( prec->_type != CTreePos::NodeEnd
            ||  prec->_pel == NULL );

        if (prec->_type == CTreePos::NodeBeg)
        {
            Assert( prec->_pel );
            prec->_pel->Release();
        }
        else if (prec->_type == CTreePos::Pointer)
        {
            if (prec->_fMarkupPointer)
            {
                if (prec->_pPointer)
                    prec->_pPointer->Release();
            }
            else
            {
                delete [] prec->_pchCollapsedWhitespace;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     SpliceTreeEngine constructor
//
//  Synposis:   Zero initialize members
//
//----------------------------------------------------------------------------

CSpliceTreeEngine::CSpliceTreeEngine(CDoc * pDoc) :
    _aryElementRight(Mt(CSpliceTreeEngine_aryElement)),
    _RemoveUndo( pDoc ), _InsertUndo( pDoc )
{
    // Zero up to but not including the arrays
    
    memset(this, 0, offsetof(CSpliceTreeEngine, _aryLeft));
}


//+---------------------------------------------------------------------------
//
//  Method:     SpliceTreeEngine destructor
//
//  Synposis:   Release pointers
//
//----------------------------------------------------------------------------
    
CSpliceTreeEngine::~CSpliceTreeEngine()
{
    CElement **ppel;
    long c;

    for (ppel = _aryElementRight, c = _aryElementRight.Size(); c; ppel++, c--)
    {
        (*ppel)->Release();
    }
    
    if( !_fNoFreeRecord )
        MemFree(_pchRecord);

    if (_pMarkupTarget)
        _pMarkupTarget->PrivateRelease();

    if (_pMarkupSource)
        _pMarkupSource->PrivateRelease();

    // If we recorded info, but undo doesn't need it, delete it.
    if( _fRecordRemoveUndo && !_fDontReleaseRUInfo )
    {
        // We may have bailed out of RemoveSplice as a no-op, leaving _pchRemoved as NULL
        // But in that case, we better not have recorded anything.
        Assert( _paryRemovedRegion && ( _pchRemoved || _paryRemovedRegion->Size() == 0 ) );

        delete _paryRemovedRegion;
        MemFree( _pchRemoved );
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::Init
//
//  Synposis:   Initialize members of CSpliceTreeEngine based on arguments.
//
//              Unpositions gaps that come in as input.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::Init(CMarkup *pMarkupSource, CTreePosGap *ptpgSourceL, CTreePosGap *ptpgSourceR,
                        CMarkup *pMarkupTarget, CTreePosGap *ptpgTarget, BOOL fRemove, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    Assert(_fRemoveUndo == !pMarkupSource);
    Assert(_fRemoveUndo || ptpgSourceL && ptpgSourceL->IsPositioned() && ptpgSourceL->IsValid());
    Assert(_fRemoveUndo || ptpgSourceR && ptpgSourceR->IsPositioned() && ptpgSourceR->IsValid());
    Assert(_fRemoveUndo || ptpgSourceL->AttachedTreePos()->GetMarkup() == pMarkupSource);
    Assert(_fRemoveUndo || ptpgSourceR->AttachedTreePos()->GetMarkup() == pMarkupSource);
    Assert(_fRemoveUndo || ptpgSourceL->Branch() && ptpgSourceR->Branch());
    Assert(_fRemoveUndo || 0 >= ptpgSourceL->AdjacentTreePos(TPG_LEFT)->InternalCompare( ptpgSourceR->AdjacentTreePos(TPG_LEFT)));

    Assert(!_fRemoveUndo || pMarkupTarget);
    Assert(!!pMarkupTarget == !!ptpgTarget);
    Assert(!ptpgTarget || ptpgTarget->AttachedTreePos()->GetMarkup() == pMarkupTarget);
    Assert(!ptpgTarget || (ptpgTarget->IsPositioned() && ptpgTarget->IsValid()));
    Assert(pMarkupTarget || fRemove);

    Assert( !pMarkupTarget || !pMarkupSource || pMarkupTarget->Doc() == pMarkupSource->Doc() );
    
    _fInsert = !!pMarkupTarget;
    _fRemove = fRemove;

    _fDOMOperation = dwFlags & MUS_DOMOPERATION;

    if (_fInsert)
    {
        _pMarkupTarget = pMarkupTarget;
        _pMarkupTarget->PrivateAddRef();

        _InsertUndo.Init( _pMarkupTarget, dwFlags );

        _fTreeSyncTarget = _pMarkupTarget->HasLogManager() && _pMarkupTarget->GetLogManager()->IsAnyoneListening();
        
        if (_pMarkupTarget->Doc()->_lLastTextID)
        {
            _pMarkupTarget->SplitTextID(
                ptpgTarget->AdjacentTreePos( TPG_LEFT ),
                ptpgTarget->AdjacentTreePos( TPG_RIGHT) );
        }

        ptpgTarget->PartitionPointers(_pMarkupTarget, _fDOMOperation);

        _ptpTarget = _pMarkupTarget->NewPointerPos( NULL, FALSE, FALSE );

        if (!_ptpTarget)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(
            _pMarkupTarget->Insert(
                _ptpTarget, ptpgTarget->AdjacentTreePos( TPG_LEFT ), FALSE ) );

        if (hr)
            goto Cleanup;

        ptpgTarget->UnPosition();
    }
    
    if (pMarkupSource)
    {
        _pMarkupSource = pMarkupSource;
        _pMarkupSource->PrivateAddRef();

        if( _fRemove )
        {
            ptpgSourceL->PartitionPointers(_pMarkupSource, _fDOMOperation);
            ptpgSourceR->PartitionPointers(_pMarkupSource, _fDOMOperation);

            if (_pMarkupSource->Doc()->_lLastTextID)
            {
                _pMarkupSource->SplitTextID(
                    ptpgSourceL->AdjacentTreePos( TPG_LEFT ),
                    ptpgSourceL->AdjacentTreePos( TPG_RIGHT) );

                _pMarkupSource->SplitTextID(
                    ptpgSourceR->AdjacentTreePos( TPG_LEFT ),
                    ptpgSourceR->AdjacentTreePos( TPG_RIGHT) );
            }

            _RemoveUndo.Init( _pMarkupSource, dwFlags );

            // See if we need to record TreeSync at all
            _fTreeSyncSource    = _pMarkupSource->HasLogManager() && _pMarkupSource->GetLogManager()->IsAnyoneListening();
            // See if we need to record backwards info for remove (either for TreeSync or for Undo)
            _fRecordRemoveUndo  = _RemoveUndo.AcceptingUndo() || ( _fTreeSyncSource && _pMarkupSource->GetLogManager()->TestBackward() );

            // Now if we're recording info, make a list
            if( _fRecordRemoveUndo )
            {
                _paryRemovedRegion = new CSpliceRecordList();
                if( !_paryRemovedRegion )
                {
                    _fRecordRemoveUndo = FALSE;
                }
            }
        }

        _ptpSourceL = ptpgSourceL->AdjacentTreePos(TPG_RIGHT);
        _ptpSourceR = ptpgSourceR->AdjacentTreePos(TPG_LEFT);
        _pnodeSourceL = ptpgSourceL->Branch();
        _pnodeSourceR = ptpgSourceR->Branch();
        _pnodeSourceTop = _pnodeSourceL->GetFirstCommonAncestorNode(_pnodeSourceR, NULL);
        ptpgSourceL->UnPosition();
        ptpgSourceR->UnPosition();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::InitUndoRemove
//
//  Synposis:   Initialize for the undo of a remove operation
//
//----------------------------------------------------------------------------
HRESULT 
CSpliceTreeEngine::InitUndoRemove(CMarkup * pMarkupTarget, CTreePosGap * ptpgTarget,
                                  CSpliceRecordList * paryRegion, long cchRemove, 
                                  TCHAR * pchRemove, DWORD dwFlags )
{
    HRESULT hr = S_OK;

    WHEN_DBG( _fRemoveUndo = TRUE );

    hr = THR( Init( NULL, NULL, NULL, pMarkupTarget, ptpgTarget, FALSE, dwFlags ) );
    if (hr)
        goto Cleanup;

    Assert( paryRegion );
    _paryRemoveUndo = paryRegion;

    Assert( pchRemove );
    _pchRecord = pchRemove;
    _cchRecord = cchRemove;
    _fNoFreeRecord = TRUE;

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::NoteRightElement
//
//  Synposis:   Note element on the right, in bottom-to-top order
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::NoteRightElement(CElement *pel)
{
    HRESULT hr;

    Assert(!_ppelRight || _ppelRight == _aryElementRight + _aryElementRight.Size() - 1);
    
    hr = THR(_aryElementRight.Append(pel));
    if (hr) 
        goto Cleanup;

    _ppelRight = _aryElementRight + _aryElementRight.Size() - 1;

    pel->AddRef();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordLeftBeginElement
//
//  Synposis:   Records a begin-edge before the left edge of the source;
//              these are fed in reverse (bottom up, right-to-left) order.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordLeftBeginElement(CElement *pel)
{
    HRESULT hr;
    CElement *pelClone = NULL;
    CSpliceRecord *prec;
    long lTreeVersionOld = _pMarkupSource->GetMarkupTreeVersion();

    Assert(_pMarkupTarget && _fInsert);
    
    hr = THR(pel->Clone(&pelClone, _pMarkupTarget->Doc()));
    if (hr)
        goto Cleanup;

    if( lTreeVersionOld != _pMarkupSource->GetMarkupTreeVersion() )
    {
        hr = E_ABORT;
        goto Cleanup;
    }
        
    hr = THR(_aryLeft.AppendIndirect(NULL, &prec));
    if (hr) 
        goto Cleanup;

    prec->_type = CTreePos::NodeBeg;
    prec->_pel = pelClone;
    prec->_fSkip = FALSE;
    pelClone = NULL;

Cleanup:
    CElement::ReleasePtr(pelClone);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordBeginElement
//
//  Synposis:   Records a begin-edge in the source, and clones the
//              element if needed.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordBeginElement(CElement *pel)
{
    HRESULT         hr = S_OK;
    CSpliceRecord * prec;
    BOOL            fElementStays = FALSE;
    CElement *      pelNew = NULL;

    if( _fRemove && _ppelRight && pel == *_ppelRight )
    {
        fElementStays = TRUE;

        if (_ppelRight != _aryElementRight)
            _ppelRight -= 1;
        else
            _ppelRight = NULL;
    }

    // Handle the insert case
    if( _fInsert )
    {
        if (!_fRemove || fElementStays)
        {
            long lTreeVersionOld = _pMarkupSource->GetMarkupTreeVersion();

            hr = THR(pel->Clone(&pelNew, _pMarkupTarget->Doc()));
            if (hr)
                goto Cleanup;

            if( lTreeVersionOld != _pMarkupSource->GetMarkupTreeVersion() )
            {
                hr = E_ABORT;
                goto Cleanup;
            }
        
        }
        else
        {
            pelNew = pel;
            pel->AddRef();
        }
        
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr) 
            goto Cleanup;

        prec->_type = CTreePos::NodeBeg;
        prec->_pel = pelNew;
        prec->_fSkip = FALSE;
        pelNew = NULL;
    }

    // Handle the undo case
    if ( _fRecordRemoveUndo )
    {
        Assert( _paryRemovedRegion );
        hr = THR( _paryRemovedRegion->AppendIndirect( NULL, &prec ) );
        if( hr )
        {
            _fRecordRemoveUndo = FALSE;
            delete _paryRemovedRegion;
            _paryRemovedRegion = NULL;

            // Don't fail the splice just becasue we can't undo it.
            // CONSIDER (JHarding): We may want to let TreeSync clients
            // know they're missing information
            hr = S_OK;
            goto Cleanup;
        }

        prec->_type = CTreePos::NodeBeg;
        prec->_pel = pel;
        pel->AddRef();
        prec->_fSkip = fElementStays;
    }

Cleanup:
    CElement::ReleasePtr(pelNew);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordEndElement
//
//  Synposis:   Records a end-edge in the source, and the amount of
//              overlapping (the depth of the inclusion) at the point
//              at which it ends.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordEndElement(long cInclTotal, long cInclSkip, BOOL fElementStays, BOOL fSynth)
{
    HRESULT hr = S_OK;
    CSpliceRecord *prec;
    
    if (_fInsert)
    {
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr)
            goto Cleanup;

        prec->_type = CTreePos::NodeEnd;
        prec->_pel = NULL;
        prec->_cIncl = cInclTotal - cInclSkip;
    }

    if ( !fSynth && _fRecordRemoveUndo )
    {
        Assert( _paryRemovedRegion );
        hr = THR( _paryRemovedRegion->AppendIndirect( NULL, &prec ) );
        if( hr )
        {
            _fRecordRemoveUndo = FALSE;
            delete _paryRemovedRegion;
            _paryRemovedRegion = NULL;

            // Don't fail the splice just becasue we can't undo it.
            // CONSIDER (JHarding): We may want to let TreeSync clients
            // know they're missing information
            hr = S_OK;
            goto Cleanup;
        }

        prec->_type = CTreePos::NodeEnd;
        prec->_pel = NULL;
        prec->_cIncl = cInclTotal;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::LeftOverlap
//
//  Synposis:   Returns the number of elements partially overlapping range
//              to the left
//
//----------------------------------------------------------------------------
LONG
CSpliceTreeEngine::LeftOverlap()
{
    return _aryLeft.Size();
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordTextPos
//
//  Synposis:   Records a text pos in the source, and merges adjacent
//              text poses if possible (this happens when tree pointers
//              are not copied out of the splice).
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordTextPos(unsigned long cch, unsigned long sid, long lTextID)
{
    HRESULT hr = S_OK;
    CSpliceRecord *prec;

    if (_fInsert)
    {
        if (    _aryInside.Size() 
            &&  (prec = _aryInside + _aryInside.Size() - 1, prec->_type == CTreePos::Text) 
            &&  prec->_sid == sid
            &&  prec->_lTextID == lTextID)
        {
            prec->_cch += cch;
        }
        else
        {
            hr = THR(_aryInside.AppendIndirect(NULL, &prec));
            if (hr)
                goto Cleanup;

            prec->_type = CTreePos::Text;
            prec->_cch = cch;
            prec->_sid = sid;
            prec->_lTextID = lTextID;
        }
    }

    if ( _fRecordRemoveUndo )
    {
        Assert( _paryRemovedRegion );

        prec = _paryRemovedRegion->Size() ? ( (CSpliceRecord*)(*_paryRemovedRegion) + _paryRemovedRegion->Size() - 1 ) : NULL;

        if(    prec
            && prec->_type == CTreePos::Text 
            && prec->_sid == sid
            && prec->_lTextID == lTextID)
        {
            prec->_cch += cch;
        }
        else
        {
            hr = THR( _paryRemovedRegion->AppendIndirect( NULL, &prec ) );
            if( hr )
            {
                _fRecordRemoveUndo = FALSE;
                delete _paryRemovedRegion;
                _paryRemovedRegion = NULL;

                // Don't fail the splice just becasue we can't undo it.
                // CONSIDER (JHarding): We may want to let TreeSync clients
                // know they're missing information
                hr = S_OK;
                goto Cleanup;
            }

            prec->_type = CTreePos::Text;
            prec->_cch = cch;
            prec->_sid = sid;
            prec->_lTextID = lTextID;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordPointer
//
//  Synposis:   Records a markup pointer in the source, and addrefs it.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordPointer(CMarkupPointer *pmp)
{
    HRESULT hr = S_OK;
    CSpliceRecord *prec;
    
    if (_fInsert)
    {
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr)
            goto Cleanup;

        prec->_type = CTreePos::Pointer;
        prec->_fMarkupPointer = TRUE;
        prec->_pPointer = pmp;
        pmp->AddRef();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordCollapsedWhitespace
//
//  Synposis:   Records a collapsed whitespace pointer pos
//
//----------------------------------------------------------------------------
HRESULT 
CSpliceTreeEngine::RecordCollapsedWhitespace(TCHAR *pchCollapsedWhitespace, BOOL fGravity)
{
    HRESULT       hr = S_OK;
    CSpliceRecord *prec;
    TCHAR         *pch;
    
    Assert(pchCollapsedWhitespace);

    if (_fInsert)
    {
        long cch = _tcslen(pchCollapsedWhitespace)+1;

        pch = new(Mt(CollapsedWhitespace)) TCHAR[cch];
        if (!pch)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        memcpy(pch, pchCollapsedWhitespace, cch*sizeof(TCHAR));
            
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr)
        {
            delete [] pch;
            goto Cleanup;
        }

        prec->_type = CTreePos::Pointer;
        prec->_fMarkupPointer = FALSE;
        prec->_pchCollapsedWhitespace = pch;
        prec->_fCollapsedWhitespaceGravity = BYTE(fGravity);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::FirstRecord
//
//  Synposis:   Returns the leftmost item recorded in RecordSplice
//
//----------------------------------------------------------------------------
CSpliceRecord *
CSpliceTreeEngine::FirstRecord()
{
    Assert(_paryRemoveUndo || _fReversed || (!_prec && !_crec && !_cAry));

    // 1. Reverse _aryLeft

    if (!_paryRemoveUndo && !_fReversed)
    {
        CSpliceRecord *precL;
        CSpliceRecord *precR;
        CSpliceRecord rec;

        if (_aryLeft.Size() > 1)
        {
            precL = _aryLeft;
            precR = _aryLeft + _aryLeft.Size() - 1;

            while (precL < precR)
            {
                memcpy(&rec, precL, sizeof(CSpliceRecord));
                memcpy(precL, precR, sizeof(CSpliceRecord));
                memcpy(precR, &rec, sizeof(CSpliceRecord));
                precL += 1;
                precR -= 1;
            }
        }

        _fReversed = TRUE;
    }

    // 2. Return first thing
    
    _prec = NULL;
    _crec = 0;
    _cAry = AryNone;

    return NextRecord();
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::NextRecord
//
//  Synposis:   Advances to the next (to the right) item recorded
//              in RecordSplice
//
//----------------------------------------------------------------------------
CSpliceRecord *
CSpliceTreeEngine::NextRecord()
{
    Assert(_paryRemoveUndo || _fReversed);
    
    _prec += 1;
    
    while (!_crec)
    {
        _cAry = (WhichAry)(_cAry + 1);

        switch (_cAry)
        {
        case AryLeft:
            if (!_paryRemoveUndo)
            {
                _crec = _aryLeft.Size();
                _prec = _aryLeft;
            }
            break;
            
        case AryInside:
            if (!_paryRemoveUndo)
            {
                _crec = _aryInside.Size();
                _prec = _aryInside;
            }
            else
            {
                _crec = _paryRemoveUndo->Size();
                _prec = *_paryRemoveUndo;
            }
            break;
            
        case AryDone:
            return NULL;

        default:
            AssertSz(0, "Iterated past end");
        }
    }
    
    _crec -= 1;

    return _prec;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordStory
//
//  Synposis:   Accumulates text to be copied from the splice.
//
//              ptx should also be advanced by cch
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordStory(CTxtPtr *ptx, long cch)
{
    HRESULT hr = S_OK;
    const TCHAR *pch;
    LONG cchValid;

    Assert( _fInsert );
    
    while (cch)
    {
        pch = ptx->GetPch(cchValid);
        if (!pch)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        if (cchValid > cch)
            cchValid = cch;

        hr = THR(RecordText(pch, cchValid));
        if (hr)
            goto Cleanup;
            
        ptx->AdvanceCp(cchValid);
        cch -= cchValid;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordText
//
//  Synposis:   Records a string
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordText(const TCHAR *pch, long cch)
{
    HRESULT hr = S_OK;

    Assert( _fInsert );
    
    if (_cchRecord + cch > _cchRecordAlloc)
    {
        if (!_cchRecordAlloc)
             _cchRecordAlloc = 16;

        do _cchRecordAlloc *= 2;
            while (_cchRecord + cch > _cchRecordAlloc);
            
        hr = THR(MemRealloc(Mt(CSpliceTreeEngine_pchRecord), (void **)&_pchRecord, _cchRecordAlloc * sizeof(TCHAR)));
        if (hr)
            goto Cleanup;
    }

    memcpy(_pchRecord + _cchRecord, pch, cch * sizeof(TCHAR));

    _cchRecord += cch;

Cleanup:
    RRETURN(hr);
}

static const TCHAR achNodeChars[32] = {
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE,
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE,
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE,
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE };

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordNodeChars
//
//  Synposis:   Records a certain number of nodechars
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordNodeChars(long cch)
{
    HRESULT hr = S_OK;
    LONG cch2;

    Assert( _fInsert );

    cch2 = ARRAY_SIZE(achNodeChars);

    while (cch)
    {
        if (cch < cch2)
            cch2 = cch;
            
        hr = THR(RecordText(achNodeChars, cch2));
        if (hr)
            goto Cleanup;

        cch -= cch2;
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::TextRecorded
//
//  Synposis:   Returns the text recorded by RecordText
//
//----------------------------------------------------------------------------
void
CSpliceTreeEngine::GetTextRecorded(const TCHAR **ppch, long *pcch)
{
    *ppch = _pchRecord;
    *pcch = _cchRecord;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordSplice
//
//  Synposis:   Does not change the tree; is paired with InsertSplice
//
//              Traverses the region to be spliced and records all
//              begin-edges, end-edges, text poses, text, and pointers
//              to be spliced.
//
//              Elements that partially overlap the left or the right
//              of the region are treated specially: implicit begin-edges
//              (on the left) and end-edges (on the right) are noted.
//
//              Elements are cloned into the record if !_fRemove or
//              if they partially overlap the region.
//
//              Differentiates pointers with cling from those
//              without, and only records those with cling.
//
//              Most text is copied verbatim. But elements that entirely
//              cover the region are special: node chars for those
//              elements must be skipped when they appear in inclusions.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordSplice()
{
    // Record all begin edges, end edges, and text
    HRESULT hr = S_OK;
    CTxtPtr tx(_pMarkupSource, _ptpSourceL->GetCp());
    CTreeNode *pnode;
    CTreeNode *pnodeLimit;
    CTreePos *ptp;
    LONG c;
    LONG cIncl;
    LONG cLimit;
    LONG cSkip;
    LONG cch;

    // Step 1: mark and record all the L-overlapping elements and
    // note all the R-overlapping elements

    for (pnode = _pnodeSourceR; pnode != _pnodeSourceTop; pnode = pnode->Parent())
        pnode->Element()->_fMark1 = FALSE;

    for (pnode = _pnodeSourceL; pnode != _pnodeSourceTop; pnode = pnode->Parent())
        pnode->Element()->_fMark1 = TRUE;
        
    for (pnode = _pnodeSourceR; pnode != _pnodeSourceTop; pnode = pnode->Parent())
    {
        if (pnode->Element()->_fMark1 == FALSE)
        {
            hr = THR(NoteRightElement(pnode->Element()));
            if (hr)
                goto Cleanup;
        }
        else
        {
            pnode->Element()->_fMark1 = FALSE;
        }
    }

    if (_fInsert)
    {
        for (pnode = _pnodeSourceL; pnode != _pnodeSourceTop; pnode = pnode->Parent())
        {
            if (pnode->Element()->_fMark1)
            {
                hr = THR(RecordLeftBeginElement(pnode->Element()));
                if (hr)
                    goto Cleanup;
            }
        }

        hr = THR(RecordNodeChars(LeftOverlap()));
        if (hr)
            goto Cleanup;
    }

    // Step 2: scan range, recording all begin-edges, end-edges, and text

    cIncl = 0;
    cch = 0;
    pnodeLimit = _pnodeSourceL;
    
    if (_ptpSourceR->NextTreePos() != _ptpSourceL) for (ptp = _ptpSourceL; ; ptp = ptp->NextTreePos())
    {
        Assert( ptp->InternalCompare( _ptpSourceR ) <= 0 );

        switch (ptp->Type())
        {
        case CTreePos::NodeBeg:
        
            if (ptp->IsEdgeScope())
            {
                Assert(!cIncl);
                
                hr = THR(RecordBeginElement(ptp->Branch()->Element()));
                if (hr)
                    goto Cleanup;

                cch++;
            }
            else
            {
                cIncl -= 1;
            }
            
            break;

        case CTreePos::NodeEnd:
        
            if (ptp->Branch() == pnodeLimit) // it's an inclusion out of which we need to skip some poses
            {
                cSkip = 0;

                for (c = 0; !ptp->IsEdgeScope(); ptp = ptp->NextTreePos(), c += 1)
                    if (!ptp->Branch()->Element()->_fMark1)
                        cSkip += 1;
                
                Assert(ptp->IsEndElementScope());

                hr = THR(RecordEndElement(cIncl + c, cSkip, TRUE, FALSE));
                if (hr)
                    goto Cleanup;

                cch++;
                
                for (; c; ptp = ptp->NextTreePos(), c -= 1);

                pnodeLimit = ptp->IsEdgeScope() ? pnodeLimit->Parent() : ptp->Branch();

                if (cSkip && _fInsert)
                {
                    hr = THR(RecordStory(&tx, cch));
                    if (hr)
                        goto Cleanup;
                        
                    cch = 0;
                }
            }
            else
            {
                if (ptp->IsEdgeScope())
                {
                    hr = THR(RecordEndElement(cIncl, 0, FALSE, FALSE));
                    if (hr)
                        goto Cleanup;

                    cch++;
                }
                else
                {
                    cIncl += 1;
                }
            }

            break;
            
        case CTreePos::Text:

            Assert(cIncl == 0);
        
            hr = THR(RecordTextPos(ptp->Cch(), ptp->Sid(), _fRemove ? ptp->TextID() : 0));
            if (hr)
                goto Cleanup;

            cch += ptp->Cch();
            
            break;

        case CTreePos::Pointer:

            Assert(cIncl == 0);
        
            if (ptp->Cling() && _fRemove && ptp->MarkupPointer())
            {
                hr = THR(RecordPointer(ptp->MarkupPointer()));
                if (hr)
                    goto Cleanup;
            }
            else if (ptp->GetCollapsedWhitespace())
            {
                hr = THR(RecordCollapsedWhitespace(ptp->GetCollapsedWhitespace(), ptp->Gravity()));
                if (hr)
                    goto Cleanup;
            }
        }
        
        if (ptp == _ptpSourceR)
            break;
    }

    Assert(cIncl == 0);
    
    // 3. Flush text
    
    if (cch && _fInsert)
    {
        hr = THR(RecordStory(&tx, cch));
        if (hr)
            goto Cleanup;
    }

    // 4. Finish scan to get right-overlap element end edges in correct order
    if (_fInsert)
    {
        for (pnode = _pnodeSourceR, cLimit = 0; pnode != pnodeLimit; pnode = pnode->Parent(), cLimit += 1);
        pnode = _pnodeSourceR;
        cch = 0;

        while (cLimit)
        {
            for (ptp = pnode->GetEndPos(), cIncl = 0; !ptp->IsEdgeScope(); ptp = ptp->NextTreePos(), cIncl += 1);
        
            if (cIncl < cLimit)
            {
                hr = THR(RecordEndElement(cIncl, 0, FALSE, TRUE));
                if (hr)
                    goto Cleanup;
                cch++;
                cLimit -= 1;
            }
        
            for (; cIncl; ptp = ptp->NextTreePos(), cIncl -= 1);

            pnode = ptp->IsEdgeScope() ? pnode->Parent() : ptp->Branch();
        }

        hr = THR(RecordNodeChars(cch));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN(hr);
    
}

//+---------------------------------------------------------------------------
//
//  Helper functions for sending notifications in InsertSplice
//
//----------------------------------------------------------------------------

static void 
SendTextAddedNotification( CMarkup * pMarkup, CTreeNode * pNode, long cp, long cch )
{
    CNotification nfText;
    
    nfText.CharsAdded( cp, cch, pNode );
    WHEN_DBG( nfText._fNoTextValidate = TRUE );
    
    pMarkup->Notify( nfText );
}

static void 
SendElementAddedNotification( CMarkup * pMarkup, long si, long cel )
{
    CNotification nfElements;
    
    nfElements.ElementsAdded( si, cel );
    WHEN_DBG( nfElements._fNoElementsValidate = TRUE );
    
    pMarkup->Notify( nfElements );
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::InsertSplice
//
//  Synposis:   Inserts the elements and text noted by RecordSplice
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::InsertSplice()
{
    HRESULT hr;

    CSpliceRecord *prec;
    long c, cpTarget;
    CTreeNode *pnodeNew;
    CTreeNode *pnodeCur;
    CTreePos *ptpIns;
    CTreePos *ptp;
    CTreePos *ptpNew;
    long      cchNodeRemove = 0;

    // As we make the pass inserting stuff,
    // we will fix up the parent chain as we hit
    // the end of the node instead of at the begining
    // We do this so that notifications won't go to elements
    // that are currently being inserted.
    CStackPtrAry<CTreeNode *, 32> aryNodeStack(Mt(CSpliceTreeEngine_InsertSplice_aryNodeStack_pv));

    long        siNotify, cElementsNotify = 0;
    long        cpNotify, cchNotify = 0;
    CTreeNode * pNodeNotify;

    // NOTE (JHarding): Potentially when we send notifications from the remove splice phase,
    // someone could have messed with pointers in the target (cough in the editor's direction).
    // So we'll check again here.
    if( _pMarkupTarget->HasUnembeddedPointers() )
    {
        hr = THR( _pMarkupTarget->EmbedPointers() );
        if( hr )
            goto Cleanup;
    }

    ptpIns = _ptpTarget->NextTreePos();
    
    pnodeCur = _ptpTarget->GetBranch();
    pNodeNotify = pnodeCur;

    // Record where we will want to insert the text
    cpTarget = _ptpTarget->GetCp();
    cpNotify = cpTarget;

    siNotify = _ptpTarget->SourceIndex();

    // 1. Prime the node stack
    aryNodeStack.Append( pnodeCur );

    // 2. Replay the recorded tree
    
    for (prec = FirstRecord(); prec; prec = NextRecord())
    {
        switch (prec->_type)
        {
        case CTreePos::NodeBeg:
            
            // If _fSkip is turned on, the make sure that the target
            // and our list are in sync.  Just flush notifications and
            // skip over the pos in the target
            if( prec->_fSkip )
            {
                // Move past any pointer pos
                while (ptpIns->IsPointer())
                    ptpIns = ptpIns->NextTreePos();

                Assert( ptpIns->IsBeginElementScope( prec->_pel ) );

                if( cchNotify )
                    SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                cpNotify += cchNotify + 1;
                cchNotify = 0;
                ++cchNodeRemove;
                pNodeNotify = ptpIns->Branch();

                if( cElementsNotify )
                    SendElementAddedNotification( _pMarkupTarget, siNotify, cElementsNotify );

                siNotify += cElementsNotify + 1;
                cElementsNotify = 0;

                pnodeCur = ptpIns->Branch();
                aryNodeStack.Append( pnodeCur );

                // Advance ptpIns (while adjusting pointers)
                {
                    CTreePosGap tpgAdjust( ptpIns, TPG_RIGHT );
                    tpgAdjust.PartitionPointers(_pMarkupTarget, _fDOMOperation);
                    ptpIns = tpgAdjust.AdjacentTreePos( TPG_RIGHT );
                }
            }
            else
            {
                // The element may have gotten ensured into a markup while it was in the
                // undo stack.  There is no undo unit to pull it out of there, so we have
                // to do it now.
                // NOTE (JHarding): This element going out of the tree can end
                // up calling external code and hosing us.  But there's not really
                // a good time to do it.
                if( prec->_pel->IsInMarkup() )
                {
                    CMarkup * pMarkup = prec->_pel->GetMarkupPtr();

                    Assert( pMarkup->_fEnsuredMarkupDbg );

                    hr = THR( pMarkup->RemoveElementInternal( prec->_pel ) );
                    if( hr )
                        goto Cleanup;
                }

                // Create a new node and insert it in the markup
                pnodeNew = new CTreeNode(pNodeNotify, prec->_pel);
                if (!pnodeNew)
                    goto OutOfMemory;

                ptpNew = pnodeNew->InitBeginPos(TRUE);

                hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
                if (hr)
                    goto Cleanup;

                prec->_pel->__pNodeFirstBranch = pnodeNew;

                prec->_pel->SetMarkupPtr(_pMarkupTarget);
                prec->_pel->PrivateEnterTree();

                pnodeNew->PrivateEnterTree();

                pnodeCur = pnodeNew;
                aryNodeStack.Append( pnodeCur );
                cElementsNotify++;
                cchNotify++; 
            }
            break;

        case CTreePos::NodeEnd:
            // There are three cases we have to handle here:
            // 1) The inclusion is all-new
            // 2) The inclusion is new but includes some elements
            //    which were already in the tree
            // 3) The inclusion already exists and we need to thread
            //    elements through it
            //
            // 1 and 2 happen when fSkip is off.  2 happens as soon
            // as we hit pNodeNotify as we are couting off the inclusions.
            // 3 happens only when fSkip is on.
            {
                CTreePos *  ptpKernel;
                CTreeNode * pNodeStay = pNodeNotify;
                CTreeNode * pNodeCurL;
                long        iNodeStack = aryNodeStack.Size() - 1;
                long        cInclStay = 0;
                BOOL        fInclusionCreated = FALSE;
                BOOL        fSkip = TRUE;

                {
                    CTreeNode * pNodeEnd;

                    if( prec->_cIncl <= iNodeStack )
                    {
                        pNodeEnd = aryNodeStack[ iNodeStack - prec->_cIncl ];
                        fSkip = !pNodeEnd->GetEndPos()->IsUninit();
                    }
                }


                // Move past any pointer pos
                if( fSkip )
                {
                    while (ptpIns->IsPointer())
                        ptpIns = ptpIns->NextTreePos();
                }

                // Create/skip the left half of the inclusion.  We use the parent 
                // chain starting with pNodeNotify as the list of elements already 
                // in the tree and we use aryNodeStack as the total list of elements at
                // this point

                for( c = prec->_cIncl; c; c--, iNodeStack-- )
                {
                    Assert( pnodeCur == aryNodeStack[ aryNodeStack.Size() - 1 ] );

                    if (pnodeCur == pNodeStay)
                    {
                        if( fSkip )
                        {
                            if( cchNotify )
                                SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                            Assert( !ptpIns->IsEdgeScope() );
                            cpNotify += cchNotify;
                            cchNotify = 0;
                        }
                        // We hit case 2 so create an inclusion so we
                        // can sorta treat it like case 3
                        else if (!fInclusionCreated)
                        {
                            CTreePosGap tpgLocation( ptpIns, TPG_LEFT, TPG_LEFT );
                            CTreeNode * pNodeStop = aryNodeStack[ iNodeStack - c ]->Parent();

                            hr = THR( _pMarkupTarget->CreateInclusion( 
                                        pNodeStop, &tpgLocation, NULL, pnodeCur ) );
                            if (hr)
                                goto Cleanup;

                            fInclusionCreated = TRUE;

                            ptpIns = tpgLocation.AdjacentTreePos( TPG_RIGHT );
                        }

                        Assert( ptpIns->IsEndNode() 
                            &&  !ptpIns->IsEdgeScope() 
                            &&  ptpIns->Branch() == pNodeStay );

                        ptpIns = ptpIns->NextTreePos();

                        pNodeStay = pNodeStay->Parent();
                        cInclStay++;
                    }
                    else
                    {
                        // This is an element that is being inserted
                        // so thread it through the inclusion

                        Assert( pnodeCur->GetEndPos()->IsUninit() );
                        ptpNew = pnodeCur->InitEndPos(FALSE);
            
                        hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
                        if (hr)
                            goto Cleanup;

                    }

                    Assert( iNodeStack >= 0 && iNodeStack == aryNodeStack.Size() - 1 );
                    aryNodeStack.Delete( iNodeStack );
                    if( iNodeStack == 0 )
                    {
                        iNodeStack = 1;
                        aryNodeStack.Append( pnodeCur->Parent() );
                    }
                    pnodeCur = aryNodeStack[ iNodeStack - 1 ];
                }

                //
                // Now handle the kernel of the inclusion
                //

                if( fSkip )
                {                            
                    if( cchNotify )
                        SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                    cpNotify += cchNotify + 1;
                    cchNotify = 0;
                    ++cchNodeRemove;

                    Assert( pnodeCur == pNodeStay );
                    Assert( ptpIns->IsEndElementScope() && ptpIns->Branch() == pnodeCur );

                    ptpKernel = ptpIns;
                    ptpIns = ptpIns->NextTreePos();
                }
                else
                {
                    // Insert the kernel of the inclusion
                    Assert( pnodeCur->GetEndPos()->IsUninit() );
                    ptpKernel = pnodeCur->InitEndPos(TRUE);
        
                    hr = THR(_pMarkupTarget->Insert(ptpKernel, ptpIns, TRUE));
                    if (hr)
                        goto Cleanup;

                    cchNotify++;
                }

                pNodeStay = pNodeNotify = pnodeCur->Parent();

                // pop the kernel off of the stack
                Assert( iNodeStack >= 0 && iNodeStack == aryNodeStack.Size() - 1 );
                aryNodeStack.Delete( iNodeStack );
                if( iNodeStack == 0 )
                {
                    iNodeStack = 1;
                    aryNodeStack.Append( pnodeCur->Parent() );
                }
                iNodeStack--;
                pnodeCur = aryNodeStack[ iNodeStack ];

                // reparent the kernel node
                ptpKernel->Branch()->SetParent( pnodeCur );

                //
                // Find the node to send notifications on the right
                //
                if (cInclStay)
                {
                    for( c = cInclStay - 1, ptp = ptpIns; c; c--, ptp = ptp->NextTreePos() )
                    {
                        Assert( ptp->IsBeginNode() && ! ptp->IsEdgeScope() );
                    }

                    Assert( ptp->IsBeginNode() && ! ptp->IsEdgeScope() );

                    pNodeNotify = ptp->Branch();
                }

                //
                // Finish off the right side of the inclusion and fix up the parent
                // chain on the left
                //

                pNodeCurL = ptpKernel->Branch();

                for (ptp = ptpKernel->PreviousTreePos(), c = prec->_cIncl; c; ptp = ptp->PreviousTreePos(), c--)
                {
                    Assert( ptp->IsEndNode() && !ptp->IsEdgeScope() );

                    if( cInclStay && ptp->Branch()->Element() == ptpIns->Branch()->Element() )
                    {
                        // Advance past the node that is already there
                        Assert( pNodeStay == ptpIns->Branch()->Parent() );
                        pNodeStay = ptpIns->Branch();

                        if( fSkip )
                        {
                            if( cchNotify )
                                SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                            cpNotify += cchNotify;
                            cchNotify = 0;
                        }

                        pnodeNew = pNodeStay;

                        ptpIns = ptpIns->NextTreePos();

                        cInclStay--;
                    }
                    else
                    {
                    
                        // Insert a new node into the tree, parented to an element that
                        // is not being inserted
                        pnodeNew = new CTreeNode(pNodeStay, ptp->Branch()->Element());
                        if (!pnodeNew)
                            goto OutOfMemory;

                        ptpNew = pnodeNew->InitBeginPos(FALSE);
                
                        hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
                        if (hr)
                            goto Cleanup;

                        pnodeNew->PrivateEnterTree();
                    }

                    pnodeCur = pnodeNew;
                    aryNodeStack.Append( pnodeCur );

                    // Reparent the node on the left
                    ptp->Branch()->SetParent( pNodeCurL );
                    pNodeCurL = ptp->Branch();
                }

                Assert( pNodeStay == pNodeNotify );

                //
                // Finally, if we skipped over something, partition pointers
                //
                if( fSkip )
                {
                    CTreePosGap tpgAdjust( ptpIns, TPG_LEFT );
                    tpgAdjust.PartitionPointers(_pMarkupTarget, _fDOMOperation);
                    ptpIns = tpgAdjust.AdjacentTreePos( TPG_RIGHT );
                }
            }
            break;

        case CTreePos::Text:

            // CONSIDER (JBeda): do we want to merge with pervious/next text pos here?
            ptpNew = _pMarkupTarget->NewTextPos(prec->_cch, prec->_sid, prec->_lTextID);
            if (!ptpNew)
                goto OutOfMemory;

            hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
            if (hr) 
                goto Cleanup;

            cchNotify += prec->_cch;
            
            break;

        case CTreePos::Pointer:
            {
                CTreePosGap tpg(ptpIns, TPG_LEFT);

                if (prec->_fMarkupPointer)
                {
                    Assert(prec->_pPointer);
                    hr = THR( prec->_pPointer->MoveToGap( & tpg, _pMarkupTarget, TRUE ) );
                    if (hr)
                        goto Cleanup;

                    Assert(ptpIns->PreviousTreePos()->MarkupPointer() == prec->_pPointer);
                }
                else 
                {
                    CTreePos *ptp = _pMarkupTarget->NewPointerPos(NULL, TRUE, TRUE, TRUE);

                    if (!ptp)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    Assert(prec->_pchCollapsedWhitespace);

                    ptp->SetCollapsedWhitespace(prec->_pchCollapsedWhitespace);
                    prec->_pchCollapsedWhitespace = NULL;

                    ptp->SetGravity(prec->_fCollapsedWhitespaceGravity);
                    ptp->SetCling(TRUE);

                    hr = THR(_pMarkupTarget->Insert(ptp, &tpg));
                    if (hr)
                        goto Cleanup;
                }
            }
            break;
        }
    }

    // Flush any left over notifications
    if( cchNotify )
        SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);
    WHEN_DBG( cpNotify += cchNotify );

    if( cElementsNotify )
        SendElementAddedNotification( _pMarkupTarget, siNotify, cElementsNotify );

    // 3. Merge text on the left and right (keeping L and R clear of the action),
    //    and unposition tree pointer at right

    // ptpIns is at the right.  So try to merge with whatever is before it
    _pMarkupTarget->MergeText(ptpIns->PreviousTreePos());

    // _ptpTarget is at the left.  Removing it will merge as
    Assert( ! _pMarkupTarget->HasUnembeddedPointers() );
    Assert( _ptpTarget );
    hr = THR(_pMarkupTarget->RemovePointerPos( _ptpTarget, NULL, NULL ) );
    if (hr)
        goto Cleanup;

    // 4. Insert recorded text
    {
        CTxtPtr tx(_pMarkupTarget, cpTarget);
        const TCHAR *pch;
        LONG cch;

        GetTextRecorded(&pch, &cch);

#if DBG==1
        CTxtPtr tpDbg( _pMarkupTarget, cpTarget );
        for( int cchDbg = cchNodeRemove; cchDbg; cchDbg-- )
        {
            Assert( tpDbg.GetChar() == WCH_NODE );
            tpDbg.NextChar();
        }
#endif
        tx.DeleteRange( cchNodeRemove );

        if (tx.InsertRange(cch, pch) != cch)
            goto OutOfMemory;

        Assert( cpTarget + cch == cpNotify );
        _InsertUndo.SetData( cpTarget, cpTarget + cch );
    }

    // 5. Send ENTERTREE notifications, top town
    
    for (prec = FirstRecord(); prec; prec = NextRecord())
    {
        if (    prec->_type == CTreePos::NodeBeg
            &&  ! prec->_fSkip )
        {
            CNotification nf;
            nf.ElementEntertree(prec->_pel);
            nf.SetData( (_pnodeSourceL == _pnodeSourceR && _fRemove) ? ENTERTREE_MOVE : 0 );
            prec->_pel->Notify(&nf);
        }

    }
    
    _pMarkupTarget->UpdateMarkupTreeVersion();

    _InsertUndo.CreateAndSubmit();

    if( _fTreeSyncTarget )
    {
        if( _paryRemoveUndo )
        {
            IGNORE_HR( _pMarkupTarget->GetLogManager()->InsertSplice( cpTarget, _cchRecord, _pchRecord, NULL, _paryRemoveUndo ) );
        }
        else
        {
            IGNORE_HR( _pMarkupTarget->GetLogManager()->InsertSplice( cpTarget, _cchRecord, _pchRecord, &_aryLeft, &_aryInside ) );
        }
    }

Cleanup:

    Assert( _pMarkupTarget->IsNodeValid() );

    RRETURN(hr);

OutOfMemory:

    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Helper functions for sending notifications in RemoveSplice
//
//----------------------------------------------------------------------------

static void 
SendTextDeletedNotification( CMarkup * pMarkup, CTreeNode * pNode, long cp, long cch )
{
    CNotification nfText;
    
    nfText.CharsDeleted( cp, cch, pNode );
    WHEN_DBG( nfText._fNoTextValidate = TRUE );
    
    pMarkup->Notify( nfText );
}

static void 
SendElementDeletedNotification( CMarkup * pMarkup, long si, long cel )
{
    CNotification nfElements;
    
    nfElements.ElementsDeleted( si, cel );
    WHEN_DBG( nfElements._fNoElementsValidate = TRUE );
    
    pMarkup->Notify( nfElements );
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RemoveSplice
//
//  Synposis:   Remove all
//
//  TODO (JBeda): There might be an issue node caches not being cleared properly.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RemoveSplice()
{
    HRESULT             hr = S_OK;
    long                cchNodeReinsert = 0, cchRemove = 0;
    long                cpBegin = 0, cpEnd = 0;
    long                cp = _ptpSourceR->GetCp() + _ptpSourceR->GetCch();
    long                cElementsExitTotal = 0;
    CStackPtrAry<CElement *, 32> aryDelayRelease(Mt(CSpliceTreeEngine_RemoveSplice_aryDelayRelease_pv));
    CTreePos *          ptpOutsideL;
    CMarkup::CLock      MarkupLock( _pMarkupSource );

    if (!_fRemove || _ptpSourceL == _ptpSourceR->NextTreePos())
        goto Cleanup;

     if( _fTreeSyncSource )
     {
         cpBegin= _ptpSourceL->GetCp();
         cpEnd = _ptpSourceR->GetCp() + _ptpSourceR->GetCch();
     }

    // 0. Get rid of pointers with cling on the edges.  We do this so
    //    that _ptpSourceL/R can be repositioned on non pointer
    //    poses.  We do this so elements can muck with selection
    //    in their exit tree notification.
    while (_ptpSourceL->IsPointer())
    {
        if( _ptpSourceL == _ptpSourceR )
            break;

        if (_ptpSourceL->Cling())
        {
            CTreePos * ptp = _ptpSourceL->NextTreePos();

            Verify( ! _pMarkupSource->Remove( _ptpSourceL ) );

            _ptpSourceL = ptp;
        }
        else
        {
            _ptpSourceL = _ptpSourceL->NextTreePos();
        }
    }

    while (_ptpSourceR->IsPointer())
    {
        if( _ptpSourceL == _ptpSourceR )
            break;

        if (_ptpSourceR->Cling())
        {
            CTreePos * ptp = _ptpSourceR->PreviousTreePos();

            Verify( ! _pMarkupSource->Remove( _ptpSourceR ) );

            _ptpSourceR = ptp;
        }
        else
        {
            _ptpSourceR = _ptpSourceR->PreviousTreePos();
        }
    }

    // 1. Nondestructive: Mark all elements leaving the tree as about 
    //    to leave.  Also send ElementsDeleted to the markup

    if (_ptpSourceR->NextTreePos() != _ptpSourceL)
    {
        CTreeNode * pNodeLimit = _pnodeSourceR;
        CElement *  pelLimit = _pnodeSourceR->Element();
        CElement *  pel;
        CTreePos *  ptp;

        // First go through and set the _fExitTreePending bit on
        // all of the elements that are leaving the tree.  Also
        // send ElementsDeleted notifications to the markup.
        long cElements = 0;

        for (ptp = _ptpSourceR; ; ptp = ptp->PreviousTreePos())
        {
            if (!ptp->IsBeginElementScope())
                goto Previous1;
            
            pel = ptp->Branch()->Element();

            if (pel == pelLimit)
            {
                pNodeLimit = pNodeLimit->Parent();
                pelLimit = pNodeLimit->Element();

                if( cElements )
                {
                    SendElementDeletedNotification( _pMarkupSource, ptp->SourceIndex() + 1, cElements );
                    cElements = 0;
                }

                goto Previous1;
            }
        
            Assert( ! pel->_fExittreePending );
            pel->_fExittreePending = TRUE;
            cElements++;
            cElementsExitTotal++;
            
        Previous1:
            if (ptp == _ptpSourceL)
                break;
        }

        // finish up any elements left
        if( cElements )
        {
            SendElementDeletedNotification( 
                _pMarkupSource, 
                ptp->SourceIndex() + ptp->GetCElements(), 
                cElements );
        }
    }

    // 2. Nondestructive: Actually send the exit tree notification to
    //    the elements that are leaving the markup
    if( cElementsExitTotal )
    {
        CTreeNode * pNodeLimit = _pnodeSourceR;
        CElement *  pelLimit = _pnodeSourceR->Element();
        CElement *  pel;
        CTreePos *  ptp;

        // Now actually send the notification
        for (ptp = _ptpSourceR; ; ptp = ptp->PreviousTreePos())
        {
            if (!ptp->IsBeginElementScope())
                goto Previous2;
            
            pel = ptp->Branch()->Element();

            if (pel == pelLimit)
            {
                pNodeLimit = pNodeLimit->Parent();
                pelLimit = pNodeLimit->Element();
                goto Previous2;
            }
        
            Assert( pel->_fExittreePending );

            {
                CNotification   nf;
                DWORD           dwData = 0;

                if( _pnodeSourceL == _pnodeSourceR && _fInsert )
                    dwData |= EXITTREE_MOVE;

                if( pel->GetObjectRefs() == 1 )
                {
                    dwData |= EXITTREE_PASSIVATEPENDING;
                    Assert( !pel->_fPassivatePending );
                    WHEN_DBG( pel->_fPassivatePending = TRUE );
                }

                nf.ElementExittree1(pel);

                Assert( nf.IsSecondChanceAvailable() );

                nf.SetData( dwData );
                pel->Notify(&nf);

                //
                // During exit tree, someone may have repositioned pointers within the
                // markup.  THey may not be embedded.  Do so now.
                //

                if (_pMarkupSource->HasUnembeddedPointers())
                {
                    hr = THR( _pMarkupSource->EmbedPointers() );

                    if (hr)
                        goto Cleanup;
                }

                dwData = nf.DataAsDWORD();

                if (nf.IsSecondChanceRequested() || (dwData & EXITTREE_DELAYRELEASENEEDED))
                {
                    CElement * pElementStore = pel;

                    WHEN_DBG( pel->_fDelayRelease = TRUE );

                    pel->AddRef();

                    if( nf.IsSecondChanceRequested() )
                        pElementStore = (CElement*)((DWORD_PTR)pElementStore | 0x1);

                    hr = THR( aryDelayRelease.Append( pElementStore ) );

                    if (hr)
                        goto Cleanup;
                }
                WHEN_DBG( else pel->_fDelayRelease = FALSE );
            }

        Previous2:
            if (ptp == _ptpSourceL)
                break;
        }
    }

    // 3. Destructive: remove all text and elements that are completely in the area
    //    being removed.
    {
        CTreePos *  ptp;
        long        cchRemoveNotify = 0;
        CTreePos *  ptpRemoveR = NULL;
        CTreePos *  ptpLast = NULL, * ptpPrev;
        CTreeNode * pNodeNotify = _pnodeSourceR;
        CTreeNode * pNodeCurrStay = _pnodeSourceR;

        long        cInclTotal = 0;
        long        cInclKeep = 0;
        BOOL        fInclEdgeKeep = TRUE;
        BOOL        fWasEdge;

        ptpOutsideL = _ptpSourceL->PreviousTreePos();

        for ( ptp = _ptpSourceR, ptpPrev = ptp->PreviousTreePos(); 
              ptp != ptpOutsideL; 
              ptpLast = ptp, ptp = ptpPrev )
        {
            ptpPrev = ptp->PreviousTreePos();

            switch( ptp->Type() )
            {
            case CTreePos::NodeBeg:
                fWasEdge = ptp->IsEdgeScope();

                {
                    // If we are not an edge, we are in an inclusion
                    if (!ptp->IsEdgeScope())
                        cInclTotal++;

                    // If we are an edge, we can't be in an inclusion
                    Assert( ptp->IsEdgeScope() == !cInclTotal );

                    CTreeNode * pNode = ptp->Branch();
                    CElement *  pElement = pNode->Element();

                    if( fWasEdge )
                        cchRemove++;

                    // This node is really going away...remove
                    // this tree pos and tell the element/node
                    if (pElement->_fExittreePending)
                    {
                        Assert( pNode != pNodeCurrStay );
                        Assert( pNode != pNodeNotify );

                        if (!ptpRemoveR)
                            ptpRemoveR = ptp;

                        _pMarkupSource->Remove( ptp, ptpRemoveR );
                        ptp = NULL;

                        pNode->PrivateExitTree();

                        Assert( ! _pMarkupSource->HasUnembeddedPointers() );

                        if (!cInclTotal)
                        {
#if DBG == 1
                            // If we are delay release, then we want
                            // to clear the passivate pending here to protect
                            // against the assert check in PrivateExitTree
                            BOOL fDelayRelease = pElement->_fDelayRelease;
                            BOOL fPassivatePending = pElement->_fPassivatePending;

                            if (fDelayRelease)
                                pElement->_fPassivatePending = FALSE;
#endif

                            pElement->_fExittreePending = FALSE;

                            pElement->__pNodeFirstBranch = NULL;
                            pElement->DelMarkupPtr();
                            pElement->PrivateExitTree(_pMarkupSource);
                            
                            Assert( ! _pMarkupSource->HasUnembeddedPointers() );

#if DBG == 1
                            // Restore the passivate pending debug flag
                            if (fDelayRelease)
                                pElement->_fPassivatePending = fPassivatePending;
#endif
                        }

                        if( fWasEdge )
                            cchRemoveNotify++;
                    }
                    else
                    // The node is staying, so just remove everything accumulated
                    // and send the text notification.
                    {
                        Assert( pNode == pNodeCurrStay );
                        pNodeCurrStay = pNode->Parent();
                        Assert( !pNodeCurrStay->Element()->_fExittreePending );

                        if (ptpRemoveR)
                            _pMarkupSource->Remove( ptpLast, ptpRemoveR );

                        // Send any needed text notifications
                        if (cchRemoveNotify)
                        {
                            Assert( cp == ptp->GetCp() + fWasEdge ? 1 : 0 );

                            // CONSIDER (JBeda): we can probably get rid of this notification if we
                            // know that we are in an inclusion and the inclusion is going
                            // to be closed
                            SendTextDeletedNotification( 
                                _pMarkupSource, pNodeNotify, cp, cchRemoveNotify);

                            cchRemoveNotify = 0;
                        }

                        if( fWasEdge )
                            cchNodeReinsert++;

                        if (!ptp->IsEdgeScope())
                            cInclKeep++;
                        else
                            pNodeNotify = pNodeCurrStay;
                    }

                    ptpRemoveR = NULL;
                }

                if( fWasEdge )
                    cp--;

                break;

            case CTreePos::NodeEnd:
                fWasEdge = ptp->IsEdgeScope();
                {
                    CTreeNode * pNode = ptp->Branch();
                    CElement *  pElement = pNode->Element();

                    // If we are a non edge, we must be in an inclusion
                    Assert( fWasEdge || cInclTotal );

                    if( fWasEdge )
                        cchRemove++;

                    if( pElement->_fExittreePending )
                    {
                        // mark this node pos to be removed
                        Assert( pNode != pNodeCurrStay );
                        Assert( pNode != pNodeNotify );

                        if (!ptpRemoveR)
                            ptpRemoveR = ptp;

                        if( fWasEdge )
                            cchRemoveNotify++;
                    }
                    else
                    {
                        // Remove anything marked to be removed
                        if (ptpRemoveR)
                            _pMarkupSource->Remove( ptpLast, ptpRemoveR );

                        ptpRemoveR = NULL;

                        pNode->SetParent( pNodeCurrStay );
                        pNodeCurrStay = pNode;

                        if( fWasEdge )
                            cchNodeReinsert++;

                        // If we are the last kept non edge
                        // of an inclusion in which the edge was removed
                        // we have to go back and cleanup the inclusion
                        if (!fWasEdge && cInclKeep == 1 && !fInclEdgeKeep)
                        {
                            CTreePos *  ptpIncl = ptp;
                            CTreePosGap tpgIncl;

                            do
                            {
                                Assert( ptpIncl->IsEndNode() && !ptpIncl->IsEdgeScope() );
                                ptpIncl = ptpIncl->NextTreePos();
                            } while (ptpIncl->IsEndNode());

                            tpgIncl.MoveTo( ptpIncl, TPG_LEFT );

                            Verify( ! _pMarkupSource->CloseInclusion( &tpgIncl ) );

                            // These pointers should no longer be used
                            ptp = NULL;
                            _ptpSourceR = NULL;

                            Assert( cchNodeReinsert >= 0 );

                            // We are now exiting the inclusion and 
                            // pNodeNotify should be back in sync with pNodeCurrStay
                            Assert( pNodeNotify == pNodeCurrStay );
                        }
                        // Send any needed text notifications if we didn't remove the inclusion
                        else if (cchRemoveNotify)
                        {
                            Assert( cp == ptp->GetCp() + fWasEdge ? 1 : 0 );
                            SendTextDeletedNotification(
                                _pMarkupSource, pNodeNotify, cp, cchRemoveNotify);

                            cchRemoveNotify = 0;
                        }
                    }

                    // Fix up the parent chains on the left side of 
                    // the inclusion if there is any so that 
                    // notifications go to the right place.
                    if (fWasEdge)
                    {
                        if (cInclKeep)
                        {
                            CTreePos *  ptpFixup;
                            CTreeNode * pNodeReparent = pNodeCurrStay, *pNodeFixup;
                            long        cInclFixup;
                        
                            for( cInclFixup = cInclKeep, ptpFixup = ptp->PreviousTreePos();
                                 cInclFixup;
                                 ptpFixup = ptpFixup->PreviousTreePos() )
                            {
                                Assert( ptpFixup->IsEndNode() && !ptpFixup->IsEdgeScope() );

                                pNodeFixup = ptpFixup->Branch();

                                if( !pNodeFixup->Element()->_fExittreePending )
                                {
                                    pNodeFixup->SetParent( pNodeReparent );
                                    pNodeReparent = pNodeFixup;

                                    cInclFixup--;
                                }
                            }

                            pNodeNotify = pNodeReparent;
                        }
                        else if( !pElement->_fExittreePending )
                            pNodeNotify = pNodeCurrStay;


                        // this flag will tell us if we have to come back
                        // and close this inclusion later
                        fInclEdgeKeep = !pElement->_fExittreePending;
                    }
                    // keep all of our inclusion data up to date
                    else
                    {
                        cInclTotal--;
                        if (!pElement->_fExittreePending)
                            cInclKeep--;
                    }
                }

                if( fWasEdge )
                    cp--;

                break;
            case CTreePos::Text:
                {
                    Assert( !cInclTotal );

                    long cch = ptp->Cch();
                
                    // Mark the text for removal

                    cp              -= cch;
                    Assert( cp == ptp->GetCp() );
                    cchRemove       += cch;
                    cchRemoveNotify += cch;

                    if ( !ptpRemoveR )
                        ptpRemoveR = ptp;
                }

                break;
            case CTreePos::Pointer:

                Assert( !cInclTotal );

                // If the pointer has cling, mark it for removal, otherwise
                // save the pointer by flushing the remove range
                if (!ptp->Cling())
                {
                    if (ptpRemoveR)
                    {
                        _pMarkupSource->Remove( ptpLast, ptpRemoveR );
                        ptpRemoveR = NULL;
                    }
                }
                else if (!ptpRemoveR)
                {
                    ptpRemoveR = ptp;
                }
                break;
            default:
                AssertSz( FALSE, "Unknown CTreePos type" );
            } // end switch
        } // end loop

        Assert( cp == ptp->GetCp() + ptp->GetCch() );

        // finish up by removing anything marked to be removed and
        // by sending any pending notifications
        if (ptpRemoveR)
        {
            _pMarkupSource->Remove( ptpLast, ptpRemoveR );
        }

        if (cchRemoveNotify)
        {
            SendTextDeletedNotification(
                _pMarkupSource, pNodeNotify, cp, cchRemoveNotify );
        }

        // May need to merge two adjacent remaining textposes
        Verify( !_pMarkupSource->MergeText(ptpOutsideL) );
    }

    // 4. Destructive: Actually muck with the text story
    if( _fRecordRemoveUndo )
    {
        CTxtPtr tp( _pMarkupSource, cp );

        Assert( _paryRemovedRegion );

        _pchRemoved = (TCHAR *)MemAlloc( Mt(CSpliceTreeEngine_pchRemoved), cchRemove * sizeof(TCHAR) );
        if( !_pchRemoved )
        {
            // We now have to abort all attempt at recording this remove
            delete _paryRemovedRegion;
            _paryRemovedRegion  = NULL;
            _fRecordRemoveUndo = FALSE;
        }
        else
        {
            Verify( tp.GetRawText( cchRemove, _pchRemoved ) == cchRemove );
            // At this point, we've recorded all necessary info for undo, so commit it into the undo unit
            if( _RemoveUndo.AcceptingUndo() )
            {
                _RemoveUndo._paryRegion = _paryRemovedRegion;
                _RemoveUndo.SetText( cp, cchRemove, _pchRemoved );
                _fDontReleaseRUInfo = TRUE;
            }
        }
    }

    // If for some reason recording the info failed, set appropriate flags.
    _RemoveUndo._fAcceptingUndo = _RemoveUndo._fAcceptingUndo && _fRecordRemoveUndo;
    _fTreeSyncSource = _fTreeSyncSource && _fRecordRemoveUndo;

    Assert( cchRemove >= cchNodeReinsert );
    if( cchRemove > cchNodeReinsert )
    {
        CTxtPtr tx( _pMarkupSource, cp );

        tx.DeleteRange( cchRemove );

        if (cchNodeReinsert)
        {
            Verify( tx.InsertRepeatingChar( cchNodeReinsert, WCH_NODE ) == cchNodeReinsert );
        }
    }

    Assert( _pMarkupSource->IsNodeValid() );
    _pMarkupSource->UpdateMarkupTreeVersion();

    if( _fTreeSyncSource )
    {
        IGNORE_HR( _pMarkupSource->GetLogManager()->RemoveSplice( cpBegin, 
                                                                  cpEnd, 
                                                                  _paryRemovedRegion, 
                                                                  _pchRemoved, 
                                                                  cchRemove ) );
    }

    _RemoveUndo.CreateAndSubmit();

    // Do delay release/after exit tree notifications
    {
        int         cDelay = aryDelayRelease.Size();
        CElement ** ppElement = aryDelayRelease;

        for( ; cDelay ; cDelay--, ppElement++ )
        {
            CElement *  pElement = (CElement*)((DWORD_PTR)*ppElement & ~0x1);
            BOOL        fExitTreeSc = (DWORD_PTR)*ppElement & 0x1;

            // Send any needed AfterExitTree notification
            if (fExitTreeSc)
            {
                CNotification nf;

                nf.ElementExittree2( pElement );
                pElement->Notify( &nf );
            }

            // Release the element
            Assert( pElement->_fDelayRelease );
            WHEN_DBG( pElement->_fDelayRelease = FALSE );
            Assert( !pElement->_fPassivatePending || pElement->GetObjectRefs() == 1 );
            pElement->Release();
        }
    }

Cleanup:
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Method:     CMarkup::SpliceTree
//
//  Synposis:   Copies, moves, or removes the region of the tree from
//              ptpgStartSource to ptpgEndSource.
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::SpliceTreeInternal(
    CTreePosGap *   ptpgStartSource,
    CTreePosGap *   ptpgEndSource,
    CMarkup *       pMarkupTarget  /* = NULL */,
    CTreePosGap *   ptpgTarget /* = NULL */,
    BOOL            fRemove    /* = TRUE */,
    DWORD           dwFlags    /* = NULL */)
{
    PerfDbgLog(tagPerfWatch, this, "+CMarkup::SpliceTreeInternal");

    HRESULT hr;
    CSpliceTreeEngine engine( Doc() );

    Assert( ptpgStartSource && ptpgEndSource );
    Assert( ptpgStartSource->GetAttachedMarkup() == this );
    Assert( !fRemove || ptpgEndSource->GetAttachedMarkup() == this );

    Assert( ! ptpgStartSource->GetAttachedMarkup()->HasUnembeddedPointers() );
    Assert( !ptpgTarget || ! ptpgTarget->GetAttachedMarkup()->HasUnembeddedPointers() );

    Assert( ! HasUnembeddedPointers() );
    Assert( ! pMarkupTarget || ! pMarkupTarget->HasUnembeddedPointers() );

    //
    // The incoming source gaps must be logically ordered, but they may not be totally
    // ordered.  Make sure of that.
    //

    EnsureTotalOrder( ptpgStartSource, ptpgEndSource );

    hr = THR(engine.Init(this, ptpgStartSource, ptpgEndSource, pMarkupTarget, ptpgTarget, fRemove, dwFlags));
    
    if (hr)
        goto Cleanup;

    if (    engine._fInsert 
        ||  engine._fRemove && engine._fRecordRemoveUndo )
    {
        hr = THR(engine.RecordSplice());
        if (hr)
            goto Cleanup;
    }

    if (engine._fRemove)
    {
        hr = THR(engine.RemoveSplice());
        if (hr)
            goto Cleanup;
    }
    
    if (engine._fInsert)
    {
        hr = THR(engine.InsertSplice());
        if (hr)
            goto Cleanup;
    }

Cleanup:

    PerfDbgLog(tagPerfWatch, this, "-CMarkup::SpliceTreeInternal");

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CMarkup::UndoRemoveSplice
//
//  Synposis:   Undoes the remove part of a splice operation
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::UndoRemoveSplice(
    CMarkupPointer *    pmpBegin,
    CSpliceRecordList * paryRegion,
    long                cchRemove,
    TCHAR *             pchRemove,
    DWORD               dwFlags)
{
    HRESULT hr;
    CTreePosGap       tpgBegin;
    CSpliceTreeEngine engine( Doc() );

    Assert( pmpBegin );

    hr = THR( EmbedPointers() );
    if (hr)
        goto Cleanup;

    Verify( ! tpgBegin.MoveTo( pmpBegin->GetEmbeddedTreePos(), TPG_LEFT ) );

    hr = THR(engine.InitUndoRemove(this, & tpgBegin, paryRegion, cchRemove, pchRemove, dwFlags));
    if (hr)
        goto Cleanup;

    hr = THR(engine.InsertSplice());
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\text.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module TEXT.C -- CTxtPtr implementation |
 *
 *  Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95     alexgo  cleanup and reorganization (use run pointers now)
 *
 *  @todo
 *      On deactivating, collapse buffer gap.  If no text, _prgRun should be
 *      set to point at a global null array.
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_H_
#define X_TREEPOS_H_
#include "treepos.hxx"
#endif

#ifndef X_UNIWBK_H_
#define X_UNIWBK_H_
#include "uniwbk.h"
#endif

#ifndef X_VRSSCAN_H_
#define X_VRSSCAN_H_
#include "vrsscan.h"
#endif

MtDefine(CTxtPtr, Tree, "CTxtPtr")
MtDefine(CTxtPtrFindThaiTypeWordBreak_aryNodePos_pv, Locals, "CTxtPtr::FindThaiTypeWordBreak::aryNodePos::_pv")
MtDefine(CTxtPtrMoveCluster_aryNodePos_pv, Locals, "CTxtPtr::MoveCluster::aryNodePos::_pv")
MtDefine(CTxtPtrItemizeAndBreakRun_aryItems_pv, Locals, "CTxtPtr::ItemizeAndBreakRun::aryItems::_pv")

extern CGlobalCriticalSection g_csJitting;
extern BYTE g_bUSPJitState;

// NB (cthrash) Our partners in Korea have requested that ideographs be
// selected differently in Korean mode.  Turn this debug tag on to force
// Trident into Korean seleciton mode.

DeclareTag( tagKoreanSelection, "TextSelection", "Korean Selection Mode.");

DeclareTag( tagOneCharTextInsert, "TextInsert", "Insert text one character at a time");

DeclareTag( tagUrlDetection, "UrlDetection", "trace Url Auto Detection");

// internal functions
// Text Block management
void TxDivideInsertion(DWORD cch, DWORD ichBlock, DWORD cchAfter,
            DWORD *pcchFirst, DWORD *pcchLast);


//
// Node classifications.
//
enum NODE_CLASS
{
    NODECLASS_NONE = 0,
    NODECLASS_SEPARATOR,
    NODECLASS_NOSCOPE,
    NODECLASS_LINEBREAK,
    NODECLASS_BLOCKBREAK,
    NODECLASS_SITEBREAK,
};

NODE_CLASS
ClassifyNodePos( CTreePos *ptp, BOOL * pfBegin )
{
    CTreeNode   * pNode;
    CFlowLayout * pFL;
    CElement    * pElement;
    ELEMENT_TAG   etag;
    NODE_CLASS    ncClass = NODECLASS_NONE;

    Assert( ptp->IsNode() );

    if( ptp->IsEdgeScope() )
    {
        pNode = ptp->Branch();
        pFL = pNode->GetFlowLayout();
        pElement = pNode->Element();
        etag = (ELEMENT_TAG) pElement->_etag;

        if( pFL && pFL->IsElementBlockInContext( pElement ) )
        {
            if(    etag == ETAG_TABLE
                || etag == ETAG_TEXTAREA
#ifdef  NEVER
                || etag == ETAG_HTMLAREA
#endif
              )
            {
                ncClass = NODECLASS_SITEBREAK;
            }
            else if(    etag == ETAG_TD
                     || etag == ETAG_TH
                     || etag == ETAG_TC )
            {
                ncClass = NODECLASS_SITEBREAK;
            }
            else
            {
                ncClass = NODECLASS_BLOCKBREAK;
            }
        }
        else if (pElement->IsNoScope())
        {
            if( etag == ETAG_BR )
            {
                ncClass = NODECLASS_LINEBREAK;
            }
            else if (pNode->ShouldHaveLayout())
            {
                ncClass = NODECLASS_NOSCOPE;
            }
        }
        else if ( etag == ETAG_RT || etag == ETAG_RP )
        {
            ncClass = NODECLASS_SEPARATOR;
        }

        if( pfBegin )
        {
            *pfBegin = ptp->IsBeginNode();

            // Table cell boundaries are sort of reverse no-scopes.
            if( etag == ETAG_TD || etag == ETAG_TH || etag == ETAG_TC )
                *pfBegin = !*pfBegin;
        }

    }

    return ncClass;
}


/*
 * Classify
 *
 * Synopsis: Classifies the node correpsonding to the character just
 * after _cp.
 *
 * Returns:
 *  NODECLASS_NONE: "Uninteresting" node, such as <B>s, <I>s, etc.
 *  NODECLASS_SEPARATOR: Words separation, such as <RT>s
 *  NODECLASS_NOSCOPE: Nodes with no scope, such as <IMG>s
 *  NODECLASS_LINEBREAK: Line breaks, such as <BR>s
 *  NODECLASS_BLOCKBREAK: Nodes that cause breaks, such as <P>s
 *  NODECLASS_SITEBREAK: Things like <TABLE>s, <TEXTAREA>s
 */

static NODE_CLASS
Classify( CTxtPtr * ptp, BOOL * pfBegin )
{
    CTreePos * ptpScan;

    Assert( ptp->GetChar() == WCH_NODE );

    ptpScan = ptp->_pMarkup->TreePosAtCp( ptp->GetCp(), NULL );
    while( ptpScan->IsText() || ptpScan->IsPointer() )
    {
        Assert( ptpScan->IsPointer() || ptpScan->Cch() == 0 );
        ptpScan = ptpScan->NextTreePos();
    }

    Assert( ptpScan->IsNode() );

    return ClassifyNodePos( ptpScan, pfBegin );
}

/*
 *  IsWhiteSpace(CTxtPtr *)
 *
 *  @func
 *      Used to determine if ch is an EOP char (see IsEOP() for definition),
 *      TAB or blank. This function is used in identifying sentence start
 *      and end.
 *
 *  @devnote
 *      It is very important that ch be unsigned, since to determine if ch is
 *      in a range (from TAB (= 9) to CR (= 13), we need an unsigned compare.
 *      In this way values below range get mapped into very large unsigned
 *      values that have their sign bit set.
 */
BOOL IsWhiteSpace(CTxtPtr *ptp)
{
    TCHAR ch = ptp->GetChar();

    return (    ch == L' '
             || InRange( ch, TAB, CR )
             || (ch | 1) == PS
             || (    ch == WCH_NODE
                  && Classify( ptp, NULL ) ) );
}

/*
 *  IsSentenceTerminator(ch)
 *
 *  @func
 *      Used to determine if ch is a standard sentence terminator character,
 *      namely, '?', '.', or '!'
 */
BOOL IsSentenceTerminator(TCHAR ch)
{
    return ch <= '?' && (ch == '?' || ch == '.' || ch == '!');
}


// ===========================  Invariant stuff  ==================================================

#define DEBUG_CLASSNAME CTxtPtr
#include "_invar.h"

// ===============================  CTxtPtr  ======================================================

/*
 *  CTxtPtr::CTxtPtr(ped, cp)
 *
 *  @mfunc  constructor
 */
CTxtPtr::CTxtPtr (
    CMarkup *pMarkup,   //@parm Ptr to CMarkup instance
    DWORD cp)           //@parm cp to set the pointer to
{
    Reinit(pMarkup, cp);
}

/*
 *  CTxtPtr::CTxtPtr(&tp)
 *
 *  @mfunc  Copy Constructor
 */
CTxtPtr::CTxtPtr (
    const CTxtPtr &tp)
{
    // copy all the values over
    *this = tp;
}

/*
 *  CTxtPtr::Reinit(ped, cp)
 *
 *  @mfunc  reinitializes txt ptr just like constructor
 */
void CTxtPtr::Reinit (
    CMarkup *pMarkup,   //@parm Ptr to CMarkup instance
    DWORD cp)           //@parm cp to set the pointer to
{
    _pMarkup = pMarkup;
    _cp = 0;
    SetRunArray((CRunArray *) &pMarkup->_TxtArray);
    _cp = BindToCp(cp);
}

/*
 *  CTxtPtr::GetChar()
 *
 *  @mfunc
 *      Return character at this text pointer, NULL if text pointer is at
 *      end of text
 *
 *  @rdesc
 *      Character at this text ptr
 */
TCHAR CTxtPtr::GetChar()
{
    LONG         cchValid;
    const TCHAR *pch = GetPch(cchValid);

    return ( pch && cchValid ) ? *pch : 0;
}

/*
 *  CTxtPtr::GetPrevChar()
 *
 *  @mfunc
 *      Return character just before this text pointer, NULL if text pointer
 *      beginning of text
 *
 *  @rdesc
 *      Character just before this text ptr
 */
TCHAR CTxtPtr::GetPrevChar()
{
    long cchValid;
    const TCHAR * pch = GetPchReverse( cchValid );

    return (pch && cchValid) ? *(pch - 1) : 0;
}

/*
 *  CTxtPtr::GetPch(&cchValid)
 *
 *  @mfunc
 *      return a character pointer to the text at this text pointer
 *
 *  @rdesc
 *      a pointer to an array of characters.  May be NULL.  If non-null,
 *      then cchValid is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPch(
    long &  cchValid)       //@parm Count of characters for which the
{
    _TEST_INVARIANT_

    DWORD       ich = GetIch();
    TCHAR *     pchBase;
    CTxtBlk *   ptb = _prgRun ? GetCurrRun() : NULL;

    if( !ptb )
    {
        cchValid = 0;
        return NULL;
    }

    // if we're at the edge of a run, grab the next run or
    // stay at the current run.

    if( GetIch() == ptb->_cch )
    {
        if( GetIRun() < NumRuns() - 1 )
        {
            // set us to the next text block
            ptb = GetNextRun();
            ich = 0;
        }
        else
        {
            //we're at the very end of the text, just return NULL
            cchValid = 0;
            return NULL;
        }
    }

    AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
        "CTxtPtr::GetPch(): _ich bigger than block");

    pchBase = ptb->_pch + ich;


    // Check to see if we need to skip over gap.  Recall that
    // the game may come anywhere in the middle of a block,
    // so if the current ich (note, no underscore, we want
    // the active ich) is beyond the gap, then recompute pchBase
    // by adding in the size of the block.
    //
    // cchValid will then be the number of characters left in
    // the text block (or _cch - ich)

    if(CbOfCch(ich) >= ptb->_ibGap)
    {
        pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;
        cchValid = ptb->_cch - ich;
    }
    else
    {
        //we're valid until the buffer gap (or see below).
        cchValid = CchOfCb(ptb->_ibGap) - ich;
    }

    Assert(cchValid);
    return pchBase;
}

/*
 *  CTxtPtr::GetPchReverse(&cchValidReverse, *pcchValid)
 *
 *  @mfunc
 *      return a character pointer to the text at this text pointer
 *      adjusted so that there are some characters valid *behind* the
 *      pointer.
 *
 *  @rdesc
 *      a pointer to an array of characters.  May be NULL.  If non-null,
 *      then cchValidReverse is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPchReverse(
    long &  cchValidReverse,        //@parm length for reverse
    long *  pcchValid)              //@parm length forward
{
    _TEST_INVARIANT_

    LONG        cchTemp;
    DWORD       ich = GetIch();
    TCHAR *     pchBase;
    CTxtBlk *   ptb = GetCurrRun();

    if( !ptb )
    {
        cchValidReverse = 0;
        return NULL;
    }

    // if we're at the edge of a run, grab the previous run or
    // stay at the current run.

    if( !GetIch() )
    {
        if( GetIRun() )
        {
            // set us to the next text block
            ptb = GetPrevRun();
            ich = ptb->_cch;
        }
        else
        {
            //we're at the very beginning of the text, just return NULL
            cchValidReverse = 0;
            return NULL;
        }
    }

    AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
        "CTxtPtr::GetPchReverse(): _ich bigger than block");

    pchBase = ptb->_pch + ich;

    // Check to see if we need to skip over gap.  Recall that
    // the game may come anywhere in the middle of a block,
    // so if the current ich (note, no underscore, we want
    // the active ich) is at least one char past the gap, then recompute
    // pchBase by adding the size of the gap (so that it's after
    // the gap).  This differs from GetPch(), which works forward and
    // wants pchBase to include the gap size if ich is at the gap, let
    // alone one or more chars past it.
    //
    // Also figure out the count of valid characters.  It's
    // either the count of characters from the beginning of the
    // text block, i.e. ich, or the count of characters from the
    // end of the buffer gap.

    cchValidReverse = ich;                  // Default for ich <= gap offset
    cchTemp = ich - CchOfCb(ptb->_ibGap);   // Calculate displacement
    if(cchTemp > 0)                         // Positive: pchBase is after gap
    {
        cchValidReverse = cchTemp;
        pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;  // Add in gap size
    }
    if ( pcchValid )                         // if client needs forward length
    {
        if ( cchTemp > 0 )
            cchTemp = ptb->_cch - ich;
        else
            cchTemp = -cchTemp;

        *pcchValid = cchTemp;
    }

    return pchBase;
}

/*
 *  CTxtPtr::BindToCp(cp)
 *
 *  @mfunc
 *      set cached _cp = cp (or nearest valid value)
 *
 *  @rdesc
 *      _cp actually set
 *
 *  @comm
 *      This method overrides CRunPtrBase::BindToCp to keep _cp up to date
 *      correctly.
 *
 *  @devnote
 *      Do *not* call this method when high performance is needed; use
 *      AdvanceCp() instead, which advances from 0 or from the cached
 *      _cp, depending on which is closer.
 */
DWORD
CTxtPtr::BindToCp ( DWORD cp )
{
    if(_prgRun)
    {
        //
        // Special case binding to the end of the string to be fast
        //
        if (NumRuns() > 0 && long(cp) == GetTextLength())
        {
            SetIRun( NumRuns() - 1 );

            SetIch( _prgRun->Elem( GetIRun() )->_cch );
            _cp = cp;
        }
        else
        {
            _cp = CRunPtrBase::BindToCp(cp);
        }
    }

    // We want to be able to use this routine to fix up things so we don't do
    // the invariant checking at entry.

    _TEST_INVARIANT_

    return _cp;
}


/*
 *  CTxtPtr::SetCp(cp)
 *
 *  @mfunc
 *      'efficiently' sets cp by advancing from current position or from 0,
 *      depending on which is closer
 *
 *  @rdesc
 *      cp actually set to
 */
DWORD CTxtPtr::SetCp(
    DWORD   cp)     //@parm char position to set to
{
    LONG    cch = (LONG)cp - (LONG)_cp;
    AdvanceCp(cch);

    return _cp;
}

/*
 *  CTxtPtr::AdvanceCp(cch)
 *
 *  @mfunc
 *      Advance cp by cch characters
 *
 *  @rdesc
 *      Actual number of characters advanced by
 *
 *  @comm
 *      We override CRunPtrBase::AdvanceCp so that the cached _cp value
 *      can be correctly updated and so that the advance can be made
 *      from the cached _cp or from 0, depending on which is closer.
 *
 *  @devnote
 *      It's also easy to bind at the end of the story. So an improved
 *      optimization would bind there if 2*(_cp + cch) > _cp + text length.
 */
LONG CTxtPtr::AdvanceCp(
    LONG cch)           // @parm count of chars to advance by
{
    if (!IsValid())
        return 0;

    const LONG  cpSave = _cp;               // Save entry _cp
    LONG        cp = cpSave + cch;          // Requested target cp (maybe < 0)

    if(2*cp < cpSave)                       // Closer to 0 than cached cp
    {
        cp = max(cp, 0L);                    // Don't undershoot
        _cp = CRunPtrBase::BindToCp(cp);
    }
    else
        _cp += CRunPtrBase::AdvanceCp(cch); //  exist

    // NB! the invariant check needs to come at the end; we may be
    // moving 'this' text pointer in order to make it valid again
    // (for the floating range mechanism).

    _TEST_INVARIANT_
    return _cp - cpSave;                    // cch this CTxtPtr moved
}

/*
 *  CTxtPtr::GetText(cch, pch)
 *
 *  @mfunc
 *      get a range of cch characters starting at this text ptr. A literal
 *      copy is made, i.e., with no CR -> CRLF and WCH_EMBEDDING -> ' '
 *      translations.  For these translations, see CTxtPtr::GetPlainText()
 *
 *  @rdesc
 *      count of characters actually copied
 *
 *  @comm
 *      Doesn't change this text ptr
 */

long
CTxtPtr::GetRawText(
    long   cch,          //@parm count of characters to get
    TCHAR *pch)         //@parm buffer to copy the text into
{
    const TCHAR *pchRead;
    long  cchValid;
    long  cchCopy = 0;
    CTxtPtr tp(*this);

    _TEST_INVARIANT_

    // simply take our clone text pointer, and read valid blocks
    // of text until we've either read all the requested text or
    // we've run out of text to read.
    while( cch )
    {
        pchRead = tp.GetPch( cchValid );

        if (!pchRead)
            break;

        cchValid = min( cchValid, cch );
        CopyMemory( pch, pchRead, cchValid * sizeof( TCHAR ) );
        pch += cchValid;
        cch -= cchValid;
        cchCopy += cchValid;
        tp.AdvanceCp( cchValid );

        _TEST_INVARIANT_ON( tp );
    }

    return cchCopy;
}

long
CTxtPtr::GetPlainTextLength ( long cch )
{
    long cchCopy = 0;
    CTxtPtr tp( * this );

    _TEST_INVARIANT_

    while ( cch > 0 )
    {
        long cchValid;
        const TCHAR * pchRead = tp.GetPch( cchValid );

        if (!pchRead || cchValid <= 0)
            break;

        cchValid = min( cchValid, cch );
        cchCopy += cchValid;
        cch -= cchValid;

        //
        // Look for synthetic break chars, and count two chars for them,
        // for we will turn them into \r\n later.
        //

        for ( long i = 0 ; i < cchValid ; i++ )
        {
            TCHAR ch = pchRead[i];

            if (ch == _T('\r'))
                cchCopy++;
            else if (ch == WCH_NODE)
                cchCopy--;
        }

        tp.AdvanceCp( cchValid );
    }

    return cchCopy;
}

/*
 *  CTxtPtr::GetPlainText(cchBuff, pch, cpMost, fTextize)
 *
 *  @mfunc
 *      Copy up to cchBuff characters or up to cpMost, whichever comes
 *      first, translating lone CRs into CRLFs.  Move this text ptr just
 *      past the last character processed.  If fTextize, copy up to but
 *      not including the first WCH_EMBEDDING char. If not fTextize,
 *      replace WCH_EMBEDDING by a blank since RichEdit 1.0 does.
 *
 *  @rdesc
 *      Count of characters copied
 *
 *  @comm
 *      An important feature is that this text ptr is moved just past the
 *      last char copied.  In this way, the caller can conveniently read
 *      out plain text in bufferfuls of up to cch chars, which is useful for
 *      stream I/O.  This routine won't copy the final CR even if cpMost
 *      is beyond it.
 */

long
CTxtPtr::GetPlainText( long cch, TCHAR * pch )
{
    const TCHAR * pchRead;
    long          cchValid;
    CTxtPtr       tp ( * this );
    TCHAR *       pchStart = pch;
    TCHAR *       pchEnd = pch + cch;

    _TEST_INVARIANT_

    // simply take our clone text pointer, and read valid blocks
    // of text until we've either read all the requested text or
    // we've run out of text to read.

    // Assume cch is the count of characters *including* extra \r\n insertions

    while ( pch < pchEnd )
    {
        pchRead = tp.GetPch( cchValid );

        if (!pchRead)
            break;

        const TCHAR * pchReadEnd = pchRead + cchValid;

        for ( ; pchRead < pchReadEnd && pch < pchEnd ; pchRead++ )
        {
            TCHAR ch = *pchRead;

            if (ch == _T('\r'))
            {
                *pch++ = _T('\r');

                Assert( pch < pchEnd );

                *pch++ = _T('\n');
            }
            else if (ch != WCH_NODE)
            {
                *pch++ = ch;
            }
        }

        if (pch < pchEnd)
        {
            tp.AdvanceCp( cchValid );

            _TEST_INVARIANT_ON( tp );
        }
    }

    return pch - pchStart;
}

/*
 *  CTxtPtr::NextChar()
 *
 *  @mfunc
 *      Increment this text ptr and return char it points at
 *
 *  @rdesc
 *      Next char
 */
TCHAR CTxtPtr::NextChar()
{
    _TEST_INVARIANT_

    AdvanceCp(1);
    return GetChar();
}

/*
 *  CTxtPtr::PrevChar()
 *
 *  @mfunc
 *      Decrement this text ptr and return char it points at
 *
 *  @rdesc
 *      Previous char
 */
TCHAR CTxtPtr::PrevChar()
{
    _TEST_INVARIANT_

    return AdvanceCp(-1) ? GetChar() : 0;
}

/*
 *  CTxtPtr::AdjustCpCRLF()
 *
 *  @mfunc
 *      Adjust the position of this text pointer to the beginning of a CRLF,
 *      CRCRLF, or UTF-16 combination if it is in the middle of such a
 *      combination
 *
 *  @rdesc
 *      Number of characters text pointer has been moved by
 *
 *  @future
 *      Adjust to beginning of sequence containing Unicode combining marks
 */
LONG CTxtPtr::AdjustCpCRLF()
{
    _TEST_INVARIANT_

    LONG     cpSave = _cp;
    TCHAR    ch     = GetChar();

//  To support UTF-16, include the following code
//  if((ch & UTF16) == UTF16_TRAIL)
//      AdvanceCp(-1);

    if(!IsASCIIEOP(ch))                         // Early out
        return 0;

    if (ch == LF && cpSave && PrevChar() != CR) // Landed on LF not preceded
    {                                           //  by CR, so go back to LF
        AdvanceCp(1);                           // Else on CR of CRLF or
    }                                           //  second CR of CRCRLF

    if(GetChar() == CR)                         // Land on a CR of CRLF or
    {                                           //  second CR of CRCRLF?
        CTxtPtr tp(*this);

        if(tp.NextChar() == LF)
        {
            tp.AdvanceCp(-2);                   // First CR of CRCRLF ?
            if(tp.GetChar() == CR)              // Yes or CRLF is at start of
                AdvanceCp(-1);                  //  story. Try to back up over
        }                                       //  CR (If at BOS, no effect)
    }
    return _cp - cpSave;
}

/*
 *  CTxtPtr::IsAtEOP()
 *
 *  @mfunc
 *      Return TRUE iff this text pointer is at an end-of-paragraph mark
 *
 *  @rdesc
 *      TRUE if at EOP
 *
 *  @devnote
 *      End of paragraph marks for RichEdit 1.0 and the MLE can be CRLF
 *      and CRCRLF.  For RichEdit 2.0, EOPs can also be CR, VT (0xb - Shift-
 *      Enter), and FF (0xc - page break).
 */
BOOL CTxtPtr::IsAtEOP()
{
    _TEST_INVARIANT_

    TCHAR ch = GetChar();
    BOOL  bRet;

    if(IsASCIIEOP(ch))                          // See if LF <= ch <= CR
    {                                           // Clone tp in case
        CTxtPtr tp(*this);                      //  AdjustCpCRLF moves
        bRet = !tp.AdjustCpCRLF();              // Return TRUE unless in
    }                                           //  middle of CRLF or CRCRLF
    else
    {
        bRet = (ch | 1) == PS;
                                                // Allow synthetic break char
                                                // End of site means end of para.
                                                // Note that text site break
                                                // characters don't denote the
                                                // end of a paragraph.
                                                // and Unicode 0x2028/9 also
    }


    return bRet;
}

/*
 * AdvanceChars
 *
 * Synopsis: Moves by the given number of "interesting" characters - in other
 * words, it skips NODECLASS_NONE node characters.
 */
static long
AdvanceChars( CTxtPtr *ptp, long cch )
{
    long iDir;
    long nMoved = 0;
    long nSkip;
    long cpLimit;

    if( cch > 0)
    {
        iDir = 1;
        cpLimit = ptp->GetTextLength() - 1;
    }
    else
    {
        iDir = -1;
        cch = -cch;
        cpLimit = 1;
    }

    for( ; long(ptp->_cp) != cpLimit && cch; cch-- )
    {
        do
        {
            nSkip = ptp->AdvanceCp( iDir );
            nMoved += nSkip;
        } while (   ptp->GetChar() == WCH_NODE
                 && Classify( ptp, NULL ) == NODECLASS_NONE
                 && nSkip
                 && long(ptp->_cp) != cpLimit );

        // If we can't move any further
        if( !nSkip )
            break;
    }

    return nMoved;
}

/*
 * CTxtPtr::MoveChar( fForward )
 *
 * Synopsis: Moves one character in the given direction, optionally limiting
 *  the search to the given cp.  If cpMost is -1, it will search to the edge
 *  of the document.  This looks strictly at TEXT.
 *
 * Returns: number of characters moved
 */
long
CTxtPtr::MoveChar( BOOL fForward )
{
    long    cpOrig  = _cp;
    long    iDir    = fForward ? 1 : -1;
    long    cch     = fForward ? GetTextLength() - 1 - _cp : _cp - 1;

    // As long as we have room left...
    if( cch-- )
    {
        AdvanceCp( iDir );

        // Move past nodes to user-level text
        while( cch-- && GetChar() == WCH_NODE )
        {
            AdvanceCp( iDir );
        }
    }

    return( _cp - cpOrig );
}


BOOL AutoUrl_IsSpecialChar(TCHAR ch)
{
    return (
        ch == _T(':')
        || ch == _T('/')
        || ch == _T('.')
        || ch == _T('\\')
        || ch == _T('@')
        || ch == _T('#')
        || ch == _T('=')
        || ch == _T('+')
        || ch == _T('&')
        || ch == _T('%')
        || ch == _T('_')
        || ch == _T('"')
        || ch == _T('?')
        || ch == _T('$')
        || ch == _T('~')
        || ch == _T('-')
        || ch == _T(',')
        || ch == _T('|')
        || ch == _T(';')   // (tomfakes) semi-colon is special too
        || ch == ((WCHAR) 0x20ac)   // The Euro.  This cast will cause a non-Unicode compile to fail
        );
}

/*
 *  CTxtPtr::FindWordBreak(action, cpMost)
 *
 *  Synopsis: Finds and moves to the word boundary as specified by action,
 *      and returns the offset from the old position to the new position.
 *
 *  WB_CLASSIFY
 *      Returns char class and word break flags of char at start position.
 *
 *  WB_ISDELIMITER
 *      Returns TRUE iff char at start position is a delimeter.
 *
 *  WB_LEFT (MOVEUNIT_PREVPROOFWORD)
 *      Finds nearest proof word beginning before start position.
 *
 *  WB_LEFTBREAK (MOVEUNIT_PREVWORDEND)
 *      Finds nearest word end before start position.
 *
 *  WB_MOVEWORDLEFT (MOVEUNIT_PREVWORDBEGIN)
 *      Finds nearest word beginning before start position.
 *      This value is used during CTRL+LEFT key processing.
 *
 *  WB_MOVEWORDRIGHT (MOVEUNIT_NEXTWORDBEGIN)
 *      Finds nearest word beginning after start position.
 *      This value is used during CTRL+RIGHT key processing.
 *
 *  WB_RIGHT (MOVEUNIT_NEXTPROOFWORD)
 *      Finds nearest proof word beginning after start position.
 *
 *  WB_RIGHTEDGE == WB_RIGHTBREAK (MOVEUNIT_NEXTWORDEND)
 *      Finds nearest word end after start position.
 *
 *
 *  NB (t-johnh): WB_MOVEURLLEFT/RIGHT are used for the autodetector to
 *      determine a range of characters that should be checked for being a
 *      URL.  This is no way implies that the given boundary is the boundary
 *      of a URL, just that should the tp be positioned in a URL, that would
 *      be the end of it.
 *
 *  WB_MOVEURLLEFT
 *      Finds previous boundary of what could be a URL
 *
 *  WB_MOVEURLRIGHT
 *      Finds next boundary of what could be a URL
 *
 *  @rdesc
 *      Character offset from start of buffer (pch) of the word break
 *
 *
 *  Note: The word navigation actions are grouped into 2 different groups
 *      which follow the same pattern:  WB_MOVEWORDRIGHT, WB_RIGHT, and
 *      WB_LEFTBREAK are group 1; WB_MOVEWORDLEFT, WB_LEFT, and WB_RIGHTBREAK
 *      are group 2.  The two steps in finding the appropriate word break
 *      are (a) Find the end of the current word, and (b) Skip whitespace to
 *      the edge of the next.
 *      The group 1 actions perform step (a) and then step (b).  The group
 *      2 actions perform step (b) and then step (a). In addition, the end-
 *      seeking actions (LEFT/RIGHTBREAK) must adjust for the fact that the
 *      tp is position just _before_ the last character in a word.
 *
 */
long CTxtPtr::FindWordBreak( int action, BOOL fAutoURL )
{
    _TEST_INVARIANT_

    CTxtPtr     tp( *this );
    TCHAR       chPrev, chNext;
    long        iDir = ( action & 1 ) ? 1 : -1;

    long        cpLast = 0;
    long        cpOrig = _cp;
    long        cch;
    BOOL        fEnd = ( action == WB_LEFTBREAK || action == WB_RIGHTBREAK );


    if( action == WB_CLASSIFY || action == WB_ISDELIMITER )
    {
        // NOTE (t-johnh): Things that were calling WB_CLASSIFY and
        // WB_ISDELIMITER were based upon the old kinsoku classification,
        // rather than the new character classes and word breaking classes.
        // Any code calling with these actions should be modified to use
        // character classes and/or word break classes.
        AssertSz( FALSE, "WB_CLASSIFY and WB_ISDELIMITER are no longer valid." );

        return 0;
    }

    // Moving left, we need to be looking at the prev char.
    if( iDir == -1 && tp._cp > 1 )
        tp.AdvanceCp( -1 );

    cch = ( iDir == 1 ) ? GetTextLength() - 1 - tp._cp : tp._cp - 1;

    //
    // Set up the tp to be prior to the first interesting character -
    //  this is our start position
    //

    while( cch && tp.GetChar() == WCH_NODE && !Classify( &tp, NULL ) )
    {
        tp.AdvanceCp( iDir );
        --cch;
    }


    // Initial state
    cpLast = tp._cp;

    if( !cch )
        goto done;

    chNext = tp.GetChar();

    // If starting at Thai-type, we need to go into FTTWB
    if(!fAutoURL && NoWhiteBetweenWords( chNext ) )
    {
        // Re-adjust for FTTWB
        if( iDir == -1 )
            tp.AdvanceCp( 1 );

        long cchOffset = tp.FindThaiTypeWordBreak( action );
        cpLast = tp._cp + cchOffset;

        goto done;
    }


    //
    // NextBegin, NextProof, PrevEnd: First step is to get out of the
    //  current word
    //

    if(    action == WB_MOVEWORDRIGHT
        || action == WB_RIGHT
        || action == WB_LEFTBREAK )
    {
        if( chNext == WCH_NODE )
        {
            chNext = _T(' ');
        }

        for( ; ; )
        {
            chPrev = chNext;

            do
            {
                tp.AdvanceCp( iDir );
                --cch;
            } while( cch && tp.GetChar() == WCH_NODE && !Classify( &tp, NULL ) );

            chNext = tp.GetChar();

            //
            // Conditions for leaving a word:
            // 1) !cch                  => ran out of characters
            // 2) chNext == WCH_NODE    => Hit an interesting node
            // 3) NoWhiteBetweenWords(chNext) and not auto URL detection => Transition to Thai type
            // 4) WordBreakBoundary     => Word boundary between chars
            // (Varies depending on direction and type of word break)
            //
            if(    !cch
                || chNext == WCH_NODE
                || (!fAutoURL && NoWhiteBetweenWords( chNext ))
                || ( action == WB_RIGHT && IsProofWordBreakBoundary( chPrev, chNext ) )
                || ( action == WB_MOVEWORDRIGHT && IsWordBreakBoundaryDefault( chPrev, chNext ) )
                || ( action == WB_LEFTBREAK && IsWordBreakBoundaryDefault( chNext, chPrev ) ) )
            {
                break;
            }
        }
    }

    //
    // All options: Skip past whitespace.  Note that for
    // Next/prev proof word, this has been done/would be done anyway
    //
    while(    cch
           && (    chNext == WCH_NODE
                || WordBreakClassFromCharClass( CharClassFromCh( chNext ) ) == wbkclsSpaceA ) )
    {
        // No-scope nodes are basically one-character words, but only
        //  on the appropriate edge.
        if( chNext == WCH_NODE )
        {
            BOOL fBegin;
            NODE_CLASS nc = Classify( &tp, &fBegin );
            if (    (   nc == NODECLASS_NOSCOPE || nc == NODECLASS_SEPARATOR )
                     && ( ( fEnd ) ? !fBegin : fBegin ) )
                break;
        }

        chPrev = chNext;

        tp.AdvanceCp( iDir );
        --cch;
        chNext = tp.GetChar();
    }

    cpLast = tp._cp;



    //
    // NextBegin, NextProof and PrevEnd: Done here, except that PrevEnd is
    //  one character too far, so account for that (but only if we actually
    //  did find some non-node, non-spacing character
    //

    if(    action == WB_MOVEWORDRIGHT
        || action == WB_RIGHT
        || action == WB_LEFTBREAK )
    {
        // If we did find text or no-scope of a previous word, then we
        // should be just past it for WB_LEFTBREAK
        if(    action == WB_LEFTBREAK
            && (    (    chNext != WCH_NODE
                      && WordBreakClassFromCharClass(
                            CharClassFromCh( chNext ) ) != wbkclsSpaceA )
                 || (    chNext == WCH_NODE
                      && (    Classify( &tp, NULL ) == NODECLASS_NOSCOPE
                           || Classify( &tp, NULL ) == NODECLASS_SEPARATOR ) ) ) )
        {
            Assert( (long)tp._cp < cpOrig );
            ++cpLast;
        }

        goto done;
    }

    if( !cch )
        goto done;



    if( chNext == WCH_NODE )
    {
        chNext = _T(' ');
    }
    else if(!fAutoURL && NoWhiteBetweenWords( chNext ) )
    {
        if(iDir == -1)
            tp.AdvanceCp(1);
        // Moving from space->Thai, we need to go into FTTWB
        long cchOffset = tp.FindThaiTypeWordBreak( action );
        cpLast = tp._cp + cchOffset;

        goto done;
    }

    //
    // NextEnd, NextProof and PrevBegin: Need to move to the next
    //  breaking boundary (see conditions for leaving a word above)
    //
    for( ; ; )
    {
        chPrev = chNext;
        cpLast = tp._cp;

        do
        {
            tp.AdvanceCp( iDir );
            --cch;
        } while( cch && tp.GetChar() == WCH_NODE && !Classify( &tp, NULL ) );

        chNext = tp.GetChar();

        // Same break conditions as above
        if(    !cch
            || chNext == WCH_NODE
            || (!fAutoURL && NoWhiteBetweenWords( chNext ))
            || ( action == WB_LEFT && IsProofWordBreakBoundary( chNext, chPrev ) )
            || ( action == WB_MOVEWORDLEFT && IsWordBreakBoundaryDefault( chNext, chPrev ) )
            || ( action == WB_RIGHTBREAK && IsWordBreakBoundaryDefault( chPrev, chNext ) ) )
        {
            if( !cch )
                cpLast = tp._cp;
            break;
        }
    }

    //
    // cpLast is now the cp just before the last character of the
    //  word.  For NextEnd, we want to be past this character.
    //
    if( action == WB_RIGHTBREAK )
    {
        Assert( (long)tp._cp > cpOrig );
        if( cch )
            ++cpLast;
    }

done:
    Assert( cpLast >= 0 && cpLast < GetTextLength() );

    SetCp( cpLast );
    return _cp - cpOrig;
}

/*
 *  CTxtPtr::FindBlockBreak
 *
 *  Synopsis: Moves to the next paragraph in the direction specified by
 *      fForward.  Paragraphs are defined by nodes classified as BlockBreaks
 *
 *  Returns: Offset to the paragraph beginning.
 *
 */
long
CTxtPtr::FindBlockBreak( BOOL fForward )
{
    long            cchOffset;
    CTreePos *      ptp     = _pMarkup->TreePosAtCp( _cp, &cchOffset );
    long            cpBound = fForward ? GetTextLength() - 1 : 1;
    long            cpOrig  = _cp;
    long            cpNew   = _cp;

    if(    ( fForward && ptp->GetCp() >= cpBound )
        || ( !fForward && ptp->GetCp() <= 1 ) )
        goto Done;

    if( fForward )
    {
        //
        // Move out of this paragraph
        //
        do
        {
            ptp = ptp->NextTreePos();
            Assert( ptp );

            // Hitting a table begin from outside, we skip the table
            if( ptp->IsNode() && ptp->IsBeginElementScope() )
            {
                CTreeNode * pNode       = ptp->Branch();
                CElement *  pElement    = pNode->Element();

                if( ClassifyNodePos( ptp, NULL ) == NODECLASS_SITEBREAK )
                {
                    // Skip to the ending treepos
                    pElement->GetTreeExtent( NULL, &ptp );
                    Assert( ptp );
                    ptp = ptp->NextTreePos();
                }
            }
        } while(    ptp->GetCp() < cpBound
                 && (   !ptp->IsNode()
                     ||  ClassifyNodePos( ptp, NULL ) < NODECLASS_BLOCKBREAK ) );

        //
        // And into the next - until we see text or noscope.
        //
        while(    ptp->GetCp() < cpBound
               && (    !ptp->IsText()
                    && !(    ptp->IsNode()
                          && (    ClassifyNodePos( ptp, NULL ) == NODECLASS_NOSCOPE
                               || ClassifyNodePos( ptp, NULL ) == NODECLASS_SEPARATOR ) ) ) )
        {
            ptp = ptp->NextTreePos();
        }

        cpNew = min(ptp->GetCp(), cpBound);
    }
    else
    {
        //
        // Move to the previous paragraph (text or noscope)
        //
        do
        {
            ptp = ptp->PreviousTreePos();
        } while(    ptp->GetCp() > 1
                 && (    !ptp->IsText()
                      && !(    ptp->IsNode()
                            && (    ClassifyNodePos( ptp, NULL ) == NODECLASS_NOSCOPE
                                 || ClassifyNodePos( ptp, NULL ) == NODECLASS_SEPARATOR ) ) ) );

        // Now, find a blockbreak to define a paragraph boundary
        while(    ptp->GetCp() > 1
               && (    !ptp->IsNode()
                    ||  ClassifyNodePos( ptp, NULL ) < NODECLASS_BLOCKBREAK ) )
        {
            ptp = ptp->PreviousTreePos();

            // Hitting a table end from outside, we skip the table
            if( ptp->IsNode() && ptp->IsEndElementScope() )
            {
                CTreeNode * pNode       = ptp->Branch();
                CElement *  pElement    = pNode->Element();

                if( ClassifyNodePos( ptp, NULL ) == NODECLASS_SITEBREAK )
                {
                    // Skip to the beginning treepos
                    pElement->GetTreeExtent( &ptp, NULL );
                    Assert( ptp );
                    ptp = ptp->PreviousTreePos();
                }
            }
        }

        // Adjust back forward to actual text-type stuff
        while(    ptp->GetCp() < cpOrig
               && (    !ptp->IsText()
                    && !(    ptp->IsNode()
                          && (    ClassifyNodePos( ptp, NULL ) == NODECLASS_NOSCOPE
                               || ClassifyNodePos( ptp, NULL ) == NODECLASS_SEPARATOR ) ) ) )
        {
            ptp = ptp->NextTreePos();
        }

        // No greater than cpOrig, and no less than cpMost
        cpNew = max(min(ptp->GetCp(), cpOrig), 1L);
    }

Done:
    SetCp( cpNew );
    return _cp - cpOrig;
}


//
// AutoUrl stuff
//

#define AUTOURL_WILDCARD_CHAR   _T('\b')

//+---------------------------------------------------------------------------

// used by UrlAutodetector and associated helper functions
enum {
    AUTOURL_TEXT_PREFIX,
    AUTOURL_HREF_PREFIX
};

// A PrefixMatchContext keeps track of state for pattern
// matching.  Basically, when we see a character that could
// imply a URL prefix ('/', ':', '.', '\', '@'), we attempt
// to match, in parallel, the prefixes we know that end
// with that character.
typedef struct {
    const TCHAR *   pchPattern;
    long            iCharsLeft;
    BOOL            fMatched;
}
PrefixMatchContext;

typedef struct {
    UINT  iTextLength;                    // Number of characters in the text prefix
    UINT  iSignificantLength;             // Number of characters of significance when comparing HREF_PREFIXs for equality
    const TCHAR* pszPattern[2];           // the text prefix and the href prefix
}
AUTOURL_TAG;

// NOTE (JHarding): Entries in this table must be kept in sync with
// the corresponding table in EDUTIL.CXX.  However, this table
// contains additional information and is reordered to optimize
// for detecting URLs
// This table is sorted by the final character of the text prefix.
// This way, we can optimize our pattern match by only attempting to
// match when we see one of these characters, and then only attempting
// to match patterns that end in that character.

AUTOURL_TAG const s_urlTags[] = {
    { 7, 7, {_T("http://"),      _T("http://")}},           // 0    -   /
    { 8, 8, {_T("https://"),     _T("https://")}},          // 1    -   /
    { 6, 6, {_T("ftp://"),       _T("ftp://")}},            // 2    -   /
    { 9, 9, {_T("gopher://"),    _T("gopher://")}},         // 3    -   /
    { 7, 7, {_T("file://"),      _T("file://")}},           // 4    -   /
    { 7, 7, {_T("nntp://"),      _T("nntp://")}},           // 5    -   /
    { 7, 7, {_T("ldap://"),      _T("ldap://")}},           // 6    -   /
    { 8, 8, {_T("ldaps://"),     _T("ldaps://")}},          // 7    -   /
    { 6, 6, {_T("mic://"),       _T("mic://")}},            // 8    -   /
    { 5, 5, {_T("news:"),        _T("news:")}},             // 9    -   :
    { 6, 6, {_T("snews:"),       _T("snews:")}},            // 10   -   :
    { 7, 7, {_T("telnet:"),      _T("telnet:")}},           // 11   -   :
    { 5, 5, {_T("wais:"),        _T("wais:")}},             // 12   -   :
    { 7, 7, {_T("mailto:"),      _T("mailto:")}},           // 13   -   :
    { 7, 7, {_T("newsrc:"),      _T("newsrc:")}},           // 14   -   :
    { 4, 0, {_T("url:"),         _T("")}},                  // 15   -   :
    { 8, 8, {_T("outlook:"),     _T("outlook:")}},          // 16   -   :
    { 4, 7, {_T("www."),         _T("http://www.")}},       // 17   -   .
    { 4, 6, {_T("ftp."),         _T("ftp://ftp.")}},        // 18   -   .
    { 7, 9, {_T("gopher."),      _T("gopher://gopher.")}},  // 19   -   .
    { 7, 10, {_T("file:\\\\"),   _T("file:///\\\\")}},      // 20   -   '\\'
    { 2,  8, {_T("\\\\"),        _T("file://\\\\")}},       // 21   -   '\\'
};

// This is the largest search space for a given trigger character.  This MUST
// be kept up to date with the above table.
#define MAX_SEARCH_SPACE 10

// NOTE (JHarding): This table lists offsets into the above table of URL tags.
// Each entry in this table reflects the first offset in the above table of
// prefixes ending in the character specified in comments for the entry.
// For example, s_anOffsets[1] is 10, with comment ':'.  This means the first
// entry in s_UrlTags that keys off of a colon is s_UrlTags[10].
int const s_anOffsets[] = {
    0,          // '/'
    9,          // ':'
    17,         // '.'
    20,         // '\\'
    22,         // End
};

// Special characters as defined by RFC 822 for the local part of
// e-mail addresses.
static inline AutoUrl_IsEmailSpecialChar( TCHAR ch )
{
    return (   ch <= 31     ||
               ch == '('    ||
               ch == ')'    ||
               ch == '<'    ||
               ch == '>'    ||
               ch == '@'    ||
               ch == ','    ||
               ch == ';'    ||
               ch == ':'    ||
               ch == '\\'   ||
               ch == '"'    ||
               ch == '.'    ||
               ch == '['    ||
               ch == ']' );
}

//+----------------------------------------------------------------------------
//
//  Method: AutoUrl_EmailWildcard
//
//  Synopsis: Handles checking for an e-mail wildcard URL.  This is anything
//      of the format "A@B.C".  Additionally, the A component can be a quoted
//      string per RFC 822, so a full url of something like
//      ""Homer Simpson"@fox.com" is conceivable.
//
//+----------------------------------------------------------------------------
HRESULT CTxtPtr::AutoUrl_EmailWildcard( BOOL *pfFound )
{
    BOOL    fFound          = FALSE;
    BOOL    fQuotedLocal    = FALSE;
    BOOL    fHaveSeenText   = FALSE;
    HRESULT hr              = S_OK;
    long    cpSave          = _cp;
    long    cpStart         = _cp;
    TCHAR   ch;
    BOOL    fSpaceFoundInQuoted  = FALSE;

    Assert( pfFound );

    // Scan backwards for local-part of e-mail addr
    for( ; ; )
    {
        do
        {
            AdvanceCp( -1 );
        } while( ( ch = GetChar() ) == WCH_NODE && !Classify( this, NULL ) );

        // Interesting node - end of local-part
        if( ch == WCH_NODE )
            break;
        else
        {

            if( ch == '"' && !fHaveSeenText )
            {
                fQuotedLocal = TRUE;
                continue;
            }

            if( fQuotedLocal && IsURLBreak( ch ) )
            {
                fSpaceFoundInQuoted = TRUE;
                continue;
            }

            // CONSIDER (jharding): Escaped quotes, ie. \" should not toggle fQuotedLocal,
            // But Word ignores these.
            // CONSIDER (jharding): Also, once we see that we're in a quoted local, we
            // currently don't give up until we see an interesting node.  We probably should
            // just take up to the first space in this case.
            if( ch == '"' && fQuotedLocal )
            {
                fQuotedLocal = FALSE;
                cpStart = _cp;
                break;
            }
            else if( ch == '@' && fQuotedLocal && fSpaceFoundInQuoted )
            {
                // IE Bug# 18648 (mharper): to avoid the situation where "homer@simpson family"@fox.com
                // can cause an endless loop.
                fFound = FALSE;
                goto Cleanup;
            }
            else if( !fQuotedLocal &&
                        ( ( AutoUrl_IsEmailSpecialChar( ch ) && ch != '.' ) ||
                          IsURLBreak(ch) ) )
                break;

            fHaveSeenText = TRUE;
            cpStart = _cp;
        }
    }

    // If we didn't see real text or didn't finish a quoted local, no URL.
    if( !fHaveSeenText || fQuotedLocal )
        goto Cleanup;

    SetCp( cpSave + 1 );

    fFound = TRUE;

    //
    // We no longer require the '.' in the domain name to be work 2k compat.
    //

#if 0
    fHaveSeenText = FALSE;

    // Now scan forwards for domain part
    for( ; ; )
    {
        while( ( ch = GetChar() ) == WCH_NODE && !Classify( this, NULL ) )
        {
            AdvanceCp( 1 );
        }

        if( ch == WCH_NODE )
            break;
        else
        {
            if( ch == '.' )
            {
                if( fHaveSeenText )
                {
                    fFound = TRUE;
                    break;
                }
            }
            else
            {
                if( AutoUrl_IsEmailSpecialChar( ch ) ||
                    wbkclsSpaceA == WordBreakClassFromCharClass( CharClassFromCh( ch ) ) )
                    break;
                fHaveSeenText = TRUE;
            }
        }

        AdvanceCp( 1 );
    }
#endif

Cleanup:
    *pfFound = fFound;
    if( fFound )
    {
        SetCp( cpStart );
    }
    else
    {
        SetCp( cpSave );
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Method: AutoUrl_ScanForPrefix
//
//  Synopsis: Scans for a URL prefix (or e-mail address) in the text, in
//      the specified direction.  The search is performed by scanning text
//      for certain "trigger" characters, which signify the possibility of
//      a URL.  These are slash(/), colon(:), period(.), backslash(\), and
//      at(@).
//      When one of these characters is encountered, the appropriate prefixes
//      are selected out of the table to match against.  It then attempts
//      to match the longest possible prefix (so that things like "file:\\"
//      match over "\\".  If a prefix matches, it sets *pfFound to true and
//      *pcpStart to the starting cp over the prefix.
//
//  (t-amolke 01/06/99) Added parameter pchQuoted - NULL if _cp is neither "
//      nor >. Otherwise, it is the corresponding character. While scanning
//      for prefix if pchQuoted is non-NULL, then we should keep going back
//      till we get a matching " or <, and not stop after seeing a space.
//+----------------------------------------------------------------------------
MtDefine( CTxtPtr_AutoUrl_ScanForPrefix_aryCtxs_pv, Locals, "CTxtPtr::AutoUrl_ScanForPrefix aryCtxs::_pv" );
HRESULT CTxtPtr::AutoUrl_ScanForPrefix( int iDir, BOOL *pfFound, long *pcpStart , TCHAR *pchQuoted /* = NULL */ )
{
    CStackDataAry<PrefixMatchContext, MAX_SEARCH_SPACE> aryCtxs(Mt(CTxtPtr_AutoUrl_ScanForPrefix_aryCtxs_pv));
    CTxtPtr tpClone( *this );
    BOOL    fFound  = FALSE;
    long    cch     = 0;
    long    cpStart = _cp;
    HRESULT hr      = S_OK;

    Assert( pfFound && pcpStart );

    // Set up for backwards scan
    if( -1 == iDir )
    {
        if( tpClone._cp > 1 )
            tpClone.AdvanceCp( -1 );
        else
            goto Cleanup;
    }

    for( ; ; )
    {
        TCHAR   ch      = tpClone.GetChar();
        long    cpSave  = tpClone._cp;
        long    cpMatched = cpSave;
        int     nOffset = 0;
        int     nPatterns;
        int     nIndex;
        int     nLeft;
        int     nLongest = -1;

        switch( ch )
        {
            // Check to see if we've got something
            // The patterns are organized by what keys the URL, so that we can limit
            // our search to a contiguous subset of the table.
            case '/':
            case ':':
            case '.':
            case '\\':
                // Determine which offset to use
                switch( ch )
                {
                    case '/' : nOffset = 0; break;
                    case ':' : nOffset = 1; break;
                    case '.' : nOffset = 2; break;
                    case '\\': nOffset = 3; break;
                }

                // Total number of patterns to check
                nPatterns = s_anOffsets[ nOffset + 1 ] - s_anOffsets[ nOffset ];
                Assert( nPatterns <= MAX_SEARCH_SPACE );

                // Make sure we've got enough space to parallel search all patterns of this type
                aryCtxs.EnsureSize( nPatterns );

                // Set up our contexts
                for( nIndex = 0; nIndex < nPatterns; nIndex++ )
                {
                    AUTOURL_TAG tagCurr = s_urlTags[ s_anOffsets[ nOffset ] + nIndex ];

                    // We already know the last character matched.
                    aryCtxs[ nIndex ].iCharsLeft = tagCurr.iTextLength - 1;
                    aryCtxs[ nIndex ].pchPattern = tagCurr.pszPattern[0] + tagCurr.iTextLength - 2;
                    aryCtxs[ nIndex ].fMatched = TRUE;
                }

                nLeft = nPatterns;

                while( nLeft )
                {
                    TCHAR chScan;
                    do
                    {
                        tpClone.AdvanceCp( -1 );
                        chScan = tpClone.GetChar();
                    } while( chScan == WCH_NODE && !Classify( &tpClone, NULL ) );

                    // Grab the character and convert to lowercase
                    if( chScan <= _T('Z') && chScan >= _T('A') )
                        chScan += 0x20;

                    // For each pattern
                    for( nIndex = 0; nIndex < nPatterns; nIndex++ )
                    {
                        // If it hasn't already been ruled out, check the next char
                        if( aryCtxs[ nIndex ].iCharsLeft )
                        {
                            if( chScan != *aryCtxs[ nIndex ].pchPattern )
                            {
                                // This one failed.
                                --nLeft;
                                aryCtxs[ nIndex ].iCharsLeft = 0;
                                aryCtxs[ nIndex ].fMatched = FALSE;
                            }
                            else
                            {
                                if( --aryCtxs[ nIndex ].iCharsLeft == 0 )
                                {
                                    nLongest = nIndex;
                                    cpMatched = tpClone._cp;
                                    --nLeft;
                                }
                                --aryCtxs[ nIndex ].pchPattern;
                            }
                        }
                    }

                }

                if( -1 != nLongest )
                {
                    // Schweet - we found something.
                    fFound = TRUE;
                    cpStart = cpMatched;
                    tpClone.SetCp( cpSave );
                    goto Cleanup;
                }
                else
                {
                    ++cch;
                    tpClone.SetCp( cpSave + iDir );
                }

                break;
            case '@':
                // Wildcard match
                tpClone.AutoUrl_EmailWildcard( &fFound );
                if( fFound )
                {
                    cpStart = tpClone._cp;
                    tpClone.SetCp( cpSave );
                    goto Cleanup;
                }
                else if( !tpClone.AdvanceCp( iDir ) )
                    goto NoMatch;

                break;
            case WCH_NODE:
                // Check to see if we've hit a boundary
                if( Classify( &tpClone, NULL ) )
                    goto NoMatch;

                if( !tpClone.AdvanceCp( iDir ) )
                    goto NoMatch;

                break;
            default:
                // Look for a space-type character.  We will look past one space-type
                // character in front of us to handle hitting space in front of a
                // URL (to separate it from preceding text).

                WBKCLS wbkcls = WordBreakClassFromCharClass( CharClassFromCh( ch ) );

                // Now we also need to take into consideration whether we are looking for a
                // matching quote or not
                if (pchQuoted)
                {
                    TCHAR chMatchingQuote = (*pchQuoted == '>') ? '<' : *pchQuoted;
                    if( chMatchingQuote == ch && ( long(tpClone._cp) != cpStart-1 ) )
                        goto NoMatch;
                }
                else
                {
                    if( wbkclsSpaceA == wbkcls && ( iDir == -1 || long(tpClone._cp) != cpStart ) )
                        goto NoMatch;
                }

                ++cch;

                if( !tpClone.AdvanceCp( iDir ) )
                    goto NoMatch;
        }

        if( cch >= MAX_URL_LENGTH || tpClone._cp <= 1 || long(tpClone._cp) >= GetTextLength() - 1 )
NoMatch:
            break;
    }


Cleanup:
    *pfFound = fFound;
    if( fFound )
    {
        *pcpStart = cpStart;
    }
    SetCp( tpClone._cp );
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Method: AutoUrl_FindAndVerifyBoundaries
//
//  Synopsis: Finds the appropriate boundaries for the URL and verifies that
//      they are valid.  The only characters allowed to prefix an autodetected
//      URL are: Whitespace, Open Paren('('), Open Angle Bracket ('<'),
//      Quote ('"'), as well as interesting nodes.
//      Anything else means that the URL should not be autodetected at this
//      point.
//
//+----------------------------------------------------------------------------
HRESULT CTxtPtr::AutoUrl_FindAndVerifyBoundaries( BOOL *pfValid, long cpStart, long *pcpEnd )
{
    Assert( pfValid && pcpEnd );

    HRESULT hr = S_OK;
    CTxtPtr tpClone( _pMarkup, cpStart );
    BOOL    fValid  = FALSE;
    long    cpSave  = _cp;
    long    cpEnd   = cpSave;
    TCHAR   ch;

    // Find the character preceeding the start of the URL.
    while( ( ch = tpClone.GetPrevChar() ) == WCH_NODE )
    {
        tpClone.AdvanceCp( -1 );
        if( Classify( &tpClone, NULL ) )
            break;
    }

    // Quote chars, open paren, space, and interesting nodes are OK.
    if( ch != _T('"')   &&
        ch != _T('<')   &&
        ch != _T('(')   &&
        ch != WCH_NODE  &&
        !IsURLBreak(ch)
        )
    {
        goto Cleanup;
    }

    // Now find the end of the URL
    tpClone.SetCp( cpSave );

    for( ; ; )
    {
        TCHAR ch = tpClone.GetChar();

        // If we hit space or a node character, we be done.
        if( ch == WCH_NODE && Classify( &tpClone, NULL ) ||
            IsURLBreak(ch)
            )
            break;

        // Advance past this character
        tpClone.AdvanceCp( 1 );

        // Don't update our end position for a node character.
        // Don't update for Korean Hangul chars, either (bug 63801).
        if( ch != WCH_NODE && WordBreakClassFromCharClass( CharClassFromCh( ch ) ) != wbkclsHangul )
            cpEnd = tpClone._cp;
    }

    // Reset tpClone to the last committed position.
    tpClone.SetCp( cpEnd );

    // Any punctuation mark should be trimmed from the end of the URL
    // NOTE (krisma): apparently '/' and '\' aren't considered punction symbols by CharClassFromCh.
    while( long(tpClone._cp) > cpStart &&
           ( (WordBreakClassFromCharClass( CharClassFromCh( tpClone.GetPrevChar() ) ) == wbkclsPunctSymb)
             || tpClone.GetPrevChar() == WCH_NODE ) )
    {
        tpClone.AdvanceCp( -1 );
    }

    // JHarding (95006) if we didn't find anything interesting after the prefix trigger, it's
    // not valid.  We can do the straight +1 check, because cpSave was always the last trigger
    // character, so we're guaranteed that
    // if tpClone.cp == cpSave + 1, then there were no interesting characters after the trigger
    // if tpClone.cp < cpSave + 1, then the trigger itself got trimmed off.
    // either way, this isn't valid.
    // Note that this is a discrepancy with Word, who considers "ftp." with the quotes to be a
    // URL.
    if( long(tpClone._cp) <= cpSave + 1 )
        goto Cleanup;

    fValid      = TRUE;
    *pcpEnd     = tpClone._cp;

Cleanup:
    *pfValid    = fValid;
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Method: IsInsideUrl
//
//  Synopsis:   Determines if the TxtPtr is inside or at the end of a URL.
//      If it is, this function returns TRUE and sets pcpStart and pcpEnd to
//      the start and end cps of the url containing the TxtPtr.
//
//  (t-amolke 06/01/99) Modified to handle quoted URLs - If we find a quote
//      ( " or > ) at the current cp, then we go into quoted URL mode. In
//      this mode, the URL is scanned backwards till a matching quote
//      ( " or < ) is found.
//-----------------------------------------------------------------------------
BOOL CTxtPtr::IsInsideUrl( long *pcpStart, long *pcpEnd )
{
    HRESULT     hr      = S_OK;
    BOOL        fFound  = FALSE;
    BOOL        fValid  = FALSE;
    CTxtPtr     tpClone( *this );
    CTxtPtr     tpStart( *this );
    CTreePos *  ptp;
    CTreeNode * pNode;
    long        cchIgnore;
    TCHAR       chQuoted;
    TCHAR *     pchQuoted;

    Assert( pcpStart && pcpEnd );

    // Look at the current char. If it is a white space go back on position
    // e.g. "www.cnn.com"_ If the user just hit the space after the quoted
    // URL, we need to scan from the quote at the end.
    chQuoted = tpClone.GetChar();
    WBKCLS wbkcls = WordBreakClassFromCharClass( CharClassFromCh( chQuoted ) );
    if (wbkclsSpaceA == wbkcls)
    {
        // Move tpClone back and to keep them synchronized, move this back.
        PrevChar();
        chQuoted = tpClone.PrevChar();
    }

    // Look past punctuation for the quote
    tpStart.SetCp(GetCp());
    while (chQuoted
           && WordBreakClassFromCharClass(CharClassFromCh(GetChar())) == wbkclsPunctSymb
           && GetChar() != '"'
           && GetChar() != '>'
           )
   {
        // Move tpClone back and to keep them synchronized, move this back.
        PrevChar();
        chQuoted = tpClone.PrevChar();
   }

    // if chQuoted is a quote then pchQuoted points to the quote, else is NULL.
    if (chQuoted != '"' && chQuoted != '>')
    {
        SetCp(tpStart.GetCp());
        tpClone.SetCp(tpStart.GetCp());

        pchQuoted = NULL;
    }
    else
        pchQuoted = &chQuoted;

    // Check if we're inside an anchor
    ptp = _pMarkup->TreePosAtCp( _cp, &cchIgnore );
    Assert( ptp );
    pNode = _pMarkup->SearchBranchForAnchor( ptp->GetBranch() );

    // Found anchor
    if( pNode )
    {
        CElement *  pElement;
        CTreePos *  ptpStart;
        CTreePos *  ptpEnd;
        long        cpStart, cpEnd;

        pElement = pNode->Element();
        Assert( pElement );
        pElement->GetTreeExtent( &ptpStart, &ptpEnd );
        Assert( ptpStart->IsNode() && ptpEnd->IsNode() );

        // Use the insides of the anchor as our URL.
        cpStart = ptpStart->GetCp() + ptpStart->GetCch();
        cpEnd   = ptpEnd->GetCp();

        tpClone.SetCp( cpStart );

        // Verify that it's autodetectable
        hr = THR( tpClone.AutoUrl_ScanForPrefix( 1, &fFound, pcpStart, pchQuoted ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            *pcpEnd = cpEnd;
            fValid  = TRUE;
        }

        goto Cleanup;
    }

    // No anchor - Run backwards and then forwards.
    // We need to keep going backwards when we find an autodetectable
    // URL on an invalid boundary.  This accounts for things like
    // url:http://www.foo.com where we'd match "www." and then "http://"
    // and then finally "url:".
    do
    {
        hr = THR( tpClone.AutoUrl_ScanForPrefix( -1, &fFound, pcpStart, pchQuoted ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            hr = THR( tpClone.AutoUrl_FindAndVerifyBoundaries( &fValid, *pcpStart, pcpEnd ) );
            if( hr )
                goto Cleanup;
        }
    } while( fFound && !fValid );

    // If we didn't find anything backwards, reset and look forwards.
    if( !fFound || !fValid )
    {
        tpClone.SetCp( _cp );

        hr = THR( tpClone.AutoUrl_ScanForPrefix( 1, &fFound, pcpStart, pchQuoted ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            hr = THR( tpClone.AutoUrl_FindAndVerifyBoundaries( &fValid, *pcpStart, pcpEnd ) );
            if( hr )
                goto Cleanup;
        }
    }

    if( fFound && fValid )
    {
        // If we are looking for quoted URL (pchQuoted != NULL) then we better find a matching
        // quote just before the URL. Otherwise we fail.
        // If we are not looking for quoted URL and we find a quote just before the URL, then
        // we do not recognize the URL

        TCHAR chStart;
        CTxtPtr tpStart(*this);
        BOOL bStartQuote = FALSE;

        tpStart.SetCp(*pcpStart-1);
        chStart = tpStart.GetChar();

        // If we are in quoted mode, we must find a proper matching quote at the start of URL
        if (pchQuoted)
        {
            if ((chQuoted == '"' && chStart == '"') ||
                (chQuoted == '>' && chStart == '<'))
                    bStartQuote = TRUE;
        }
        // else any type of quote at the start is illegal.
        else
        {
            if (chStart == '"' || chStart == '<' || chStart == '>')
                bStartQuote = TRUE;
        }

        // How do we modify URL boundaries before setting up the URL?
        //
        //         pchQuoted               bStartQuote    Action
        //           !NULL                      TRUE         set extent of URL from starting
        //                                                   quote to ending quote
        //           !NULL                      FALSE        Fail
        //           NULL                       TRUE         Fail
        //           NULL                       FALSE        Nothing
        if (pchQuoted)
            if (bStartQuote)
                *pcpEnd = _cp;
            else
                fFound = FALSE;
        else
            if (bStartQuote)
                fFound = FALSE;

        SetCp( tpClone._cp );
        goto Cleanup;
    }


Cleanup:
    return ( fFound && fValid && !hr );
}


//+----------------------------------------------------------------------------
//
//  Method: FindUrl
//
//  Synopsis:   Finds the requested URL boundary, looking in the specified
//      direction.
//
//-----------------------------------------------------------------------------
MtDefine( CTxtPtr_FindUrl_aryWord_pv, Locals, "CTxtPtr::FindUrl aryWord::_pv" );
BOOL
CTxtPtr::FindUrl( BOOL fForward, BOOL fBegin, long cpBoundary )
{
    long cpStart, cpEnd = 0;
    int iDir = fForward ? 1 : -1;
    BOOL fFound;
    BOOL fValid;
    HRESULT hr;

    do
    {
        fValid = FALSE;
        hr = THR( AutoUrl_ScanForPrefix( iDir, &fFound, &cpStart, NULL ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            long cchIgnore;
            CTreePos    *   ptp     = _pMarkup->TreePosAtCp( _cp, &cchIgnore );
            CTreeNode   *   pNode   = _pMarkup->SearchBranchForAnchor( ptp->GetBranch() );

            if( pNode )
            {
                CElement    *   pElement = pNode->Element();
                CTreePos    *   ptpStart;
                CTreePos    *   ptpEnd;

                pElement->GetTreeExtent( &ptpStart, &ptpEnd );

                cpEnd   = ptpEnd->GetCp();

                Assert( cpStart == ptpStart->GetCp() + ptpStart->GetCch() );

                fValid = TRUE;
            }
            else
            {
                hr = THR( AutoUrl_FindAndVerifyBoundaries( &fValid, cpStart, &cpEnd ) );
                if( hr )
                    goto Cleanup;
            }
        }

        if( !fFound || !fValid )
        {
            AdvanceCp( iDir );
        }
    }
    while( ( !fFound || !fValid ) && ( cpBoundary == -1 ||
                                       ( fForward && long(_cp) <= cpBoundary ) ||
                                       (!fForward && long(_cp) >= cpBoundary ) ) );

Cleanup:
    if( fFound && fValid )
        SetCp( fBegin ? cpStart : cpEnd );

    return fFound && fValid;
}


/*
 *  CTxtPtr::InsertRepeatingChar(cch, ch)
 *
 *  @mfunc
 *      insert a character a number of tiems
 *
 *  @rdesc
 *      count of new characters added
 *
 *  @comm   SideEffects: <nl>
 *      moves this text pointer to end of replaced text <nl>
 *      moves text block array <nl>
 */
long
CTxtPtr::InsertRepeatingChar(
    LONG cch,                   //@parm number of chars to insert
    TCHAR ch)                   //@parm character to insert
{
    Assert( cch > 0 );
    TCHAR ach[32];
    TCHAR *pch;
    LONG cch2;
    LONG cchLeft;

    // fill up temp array with chars
    for (cch2 = min((LONG)ARRAY_SIZE(ach), cch), pch = ach; cch2; pch += 1,
cch2 -= 1)
        *pch = ch;

    // Insert chars in chunks
    for (cchLeft = cch; cchLeft; cchLeft -= cch2)
    {
        cch2 = InsertRange(min((LONG)ARRAY_SIZE(ach), cchLeft), ach);
        if (!cch2)
            break;
    }

    return cch - cchLeft;
}

/*
 *  TxFindEOP (pchBuff, cch)
 *
 *  @func
 *      Given a string, find the offset to the next EOP marker
 *
 *  @rdesc
 *      Offset to next EOP marker
 *
 *  @devnote
 *      This could probably be replaced by FindEOP()
 */
LONG TxFindEOP(
    const TCHAR *pchBuff,       //@parm the string buffer to look in
    LONG cch)                  //@parm the number valid characters
{
    LONG cchToUse = 0;

    for(; cchToUse < cch && *pchBuff != CR && *pchBuff != LF;
          cchToUse++, pchBuff++) ;

#if DBG==1
    if(cchToUse != cch)
        TraceTag((tagWarning, "TxFindEOP(): found CR or LF at %ld of %ld", cchToUse, cch));
#endif

    return cchToUse;
}

/*
 *  CTxtPtr::InsertRange(cch, pch)
 *
 *  @mfunc
 *      Insert a range of characters at this text pointer
 *
 *  @rdesc
 *      Count of characters successfully inserted
 *
 *  @comm Side Effects: <nl>
 *      moves this text pointer to end of inserted text <nl>
 *      moves the text block array <nl>
 */
long CTxtPtr::InsertRange (
    DWORD cch,              //@parm length of text to insert
    TCHAR const *pch)       //@parm text to insert
{
    _TEST_INVARIANT_

    DWORD cchSave = cch;
    DWORD cchInBlock;
    DWORD cchFirst;
    DWORD cchLast = 0;
    DWORD ctbNew;
    long cRuns;
    CTxtBlk *ptb;

#if DBG == 1
    if (IsTagEnabled(tagOneCharTextInsert) && cch > 1)
    {
        long cchTotal = 0;
        long cchInserted;

        while (cch)
        {
            cchInserted = InsertRange(1, pch);
            AssertSz(cchInserted == 1, "Failed to insert single char in one-char-at-a-time mode");
            pch += 1;
            cch -= 1;
            cchTotal += 1;
        }

        return cchTotal;
    }
#endif

    // Ensure text array is allocated
    cRuns = NumRuns();

    if(!cRuns)
    {
        LONG    cbSize = -1;

        // If we don't have any blocks, allocate first block to be big enuf
        // for the inserted text *only* if it's smaller than the normal block
        // size. This allows us to be used efficiently as a display engine
        // for small amounts of text.

        if (_pMarkup->_fIncrementalAlloc)
        {
            if( cch < CchOfCb(cbBlockInitial) )
                cbSize = CbOfCch(cch);
        }

        if( !((CTxtArray *)_prgRun)->AddBlock(0, cbSize) )
        {
            goto done;
        }
    }

    ptb = GetCurrRun();
    cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
    AssertSz(ptb->_cbBlock <= cbBlockMost, "block too big");

    // try and resize without splitting...
    if(cch > cchInBlock &&
        cch <= cchInBlock + CchOfCb(cbBlockMost - ptb->_cbBlock)
        && (!_pMarkup->IsStreaming() || _pMarkup->_fIncrementalAlloc))
    {
        if (!ptb->ResizeBlock(min((DWORD)cbBlockMost,
                                  CbOfCch(ptb->_cch + cch +
                                          (_pMarkup->_fIncrementalAlloc
                                           ? 0 : cchGapInitial)))))
        {
            goto done;
        }
        cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
    }
    if(cch <= cchInBlock)
    {
        // all fits into block without any hassle
        ptb->MoveGap(GetIch());
        CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cch));
        _cp             += cch;                 // *this points at end of
        SetIch( GetIch() + cch );
        ptb->_cch       += cch;
        ((CTxtArray *)_prgRun)->_cchText    += cch;
        ptb->_ibGap     += CbOfCch(cch);

        return long( cch );
    }

    // logic added (dbau 11/98): before splitting:
    // first try using free space that's in the next block. If we
    // blindly split all the time, we can end up with a pile of mostly-empty
    // huge blocks resulting from splitting one nearly-full block near its edge
    // repeatedly. Note that the problem is exacerbated by our initial small block.
    // To fix the general case, we also need to add logic to try using the
    // previous block as well (not done yet - maybe we should rewrite the
    // whole thing with these considerations...)

    if (cRuns > GetIRun() + 1)
    {
        CTxtBlk *ptbAdj;

        ptbAdj = GetNextRun();
        if (ptbAdj)
        {
            DWORD cchInAdj = CchOfCb(ptbAdj->_cbBlock) - ptbAdj->_cch;
            if (cch <= cchInAdj + cchInBlock)
            {
                // ooh, we have enough room. Do the shuffling around and the insert
                DWORD cchPostGap;

                // move the gaps to the right place
                ptb->MoveGap(GetIch());
                ptbAdj->MoveGap(0);

                cchPostGap = ptb->_cch - GetIch();

                if (cch <= cchInBlock + cchPostGap)
                {
                    // Case 1: if post-gap text is moved to the second block,
                    // all the new text fits in first block

                    // move as much as we can to the second block to maximize gap in the first block
                    DWORD cchToMove = (cchPostGap <= cchInAdj) ? cchPostGap : cchInAdj;
                    CopyMemory(ptbAdj->_pch + CchOfCb(ptbAdj->_cbBlock) - ptbAdj->_cch - cchToMove,
                               ptb->_pch + CchOfCb(ptb->_cbBlock) - cchToMove, CbOfCch(cchToMove));

                    // Slide anything remaining in the first block to the right
                    if (cchToMove < cchPostGap)
                        MoveMemory(ptb->_pch + CchOfCb(ptb->_cbBlock) - cchPostGap + cchToMove,
                                   ptb->_pch + CchOfCb(ptb->_cbBlock) - cchPostGap, CbOfCch(cchPostGap - cchToMove));

                    // Copy the inserted text
                    CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cch));

                    // Then update pointers and counters
                    _cp             += cch;
                    SetIch(GetIch() + cch);
                    ptb->_cch       += cch - cchToMove;
                    ptb->_ibGap     += CbOfCch(cch);
                    ptbAdj->_cch    += cchToMove;
                    ((CTxtArray *)_prgRun)->_cchText    += cch;

                    return long(cch);
                }
                else
                {
                    // Case 2: even after moving post-gap text to the second block,
                    // the new text will overflow to the second block.

                    // move all post-gap text to the second block
                    CopyMemory(ptbAdj->_pch + CchOfCb(ptbAdj->_cbBlock) - ptbAdj->_cch - cchPostGap,
                               ptb->_pch + CchOfCb(ptb->_cbBlock) - cchPostGap, CbOfCch(cchPostGap));

                    // move the part of the new text that fits in the first block
                    CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cchInBlock + cchPostGap));

                    // move the part of the new text that needs to go in the second block
                    CopyMemory(ptbAdj->_pch, pch + cchInBlock + cchPostGap, CbOfCch(cch - cchInBlock - cchPostGap));

                    // Then update pointers and counters
                    _cp             += cch;
                    SetIRun(GetIRun() + 1);
                    SetIch(cch - cchInBlock - cchPostGap);
                    ptb->_cch       += cchInBlock;
                    ptb->_ibGap     = 0;                     // first gap is empty; its location is moot
                    ptbAdj->_cch    += cch - cchInBlock;
                    ptbAdj->_ibGap  = CbOfCch(cch - cchInBlock - cchPostGap);
                    ((CTxtArray *)_prgRun)->_cchText    += cch;

                    return long(cch);
                }
            }
        }
    }

    // won't all fit in this block

    // figure out best division into blocks
    TxDivideInsertion(cch, GetIch(), ptb->_cch - GetIch(), & cchFirst, &cchLast);

    if (GetIch() == ptb->_cch)
    {
        // BUGFIX (dbau): we should not do a split at the very end of a block,
        // or else we'll introduce an empty block, which causes problems.
        // NOTE (dbau): I don't know if the beginning-of-the-block case is exposed
        // to a similar problem.
        // (Really, when splitting _near_ either edge of a block, we also should try
        // to use an adjacent block's gap instead of always creating a whole new
        // block - but most cases are already fixed by the use-adjacent logic above;
        // further fixes should probably wait until a rewrite).

        ptb->MoveGap(GetIch());
        cchFirst = CchOfCb(ptb->_cbBlock) - ptb->_cch;
        cchLast = 0;
    }
    else
    {
        // Subtract cchLast up front so return value isn't negative
        // if SplitBlock() fails
        cch -= cchLast; // don't include last block in count for middle blocks

        // split block containing insertion point

        // ***** moves _prgtb ***** //
        if(!((CTxtArray *)_prgRun)->SplitBlock(GetIRun(), GetIch(), cchFirst, cchLast,
            _pMarkup->IsStreaming()))
        {
            goto done;
        }
        ptb = GetCurrRun();            // recompute ptb after (*_prgRun) moves
    }

    // copy into first block (first half of split)
    if(cchFirst > 0)
    {
        AssertSz(ptb->_ibGap == CbOfCch(GetIch()), "split first gap in wrong place");
        AssertSz(cchFirst <= CchOfCb(ptb->_cbBlock) - ptb->_cch, "split first not big enough");

        CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cchFirst));
        cch             -= cchFirst;
        pch             += cchFirst;
        SetIch( GetIch() + cchFirst );
        ptb->_cch       += cchFirst;
        ((CTxtArray *)_prgRun)->_cchText    += cchFirst;
        ptb->_ibGap     += CbOfCch(cchFirst);
    }

    // copy into middle blocks
    // NOTE: review (jonmat) I increased the size for how large a split block
    // could be and this seems to increase the performance, we need to test the
    // block size difference on a retail build, however. 5/15/1995
    ctbNew = cch / cchBlkInsertmGapI /* cchBlkInitmGapI */;
    if(ctbNew <= 0 && cch > 0)
        ctbNew = 1;
    for(; ctbNew > 0; ctbNew--)
    {
        cchInBlock = cch / ctbNew;
        AssertSz(cchInBlock > 0, "nothing to put into block");

        // ***** moves _prgtb ***** //
        SetIRun( GetIRun() + 1 );
        if(!((CTxtArray *)_prgRun)->AddBlock(GetIRun(),
            CbOfCch(cchInBlock + cchGapInitial)))
        {
            BindToCp(_cp);  //force a rebind;
            goto done;
        }
        // NOTE: next line intentionally advances ptb to next CTxtBlk

        ptb = GetCurrRun();
        AssertSz(ptb->_ibGap == 0, "New block not added correctly");

        CopyMemory(ptb->_pch, pch, CbOfCch(cchInBlock));
        cch             -= cchInBlock;
        pch             += cchInBlock;
        SetIch( cchInBlock );
        ptb->_cch       = cchInBlock;
        ((CTxtArray *)_prgRun)->_cchText    += cchInBlock;
        ptb->_ibGap     = CbOfCch(cchInBlock);
    }
    AssertSz(cch == 0, "Didn't use up all text");

    // copy into last block (second half of split)
    if(cchLast > 0)
    {
        AssertSz(GetIRun() < NumRuns()-1, "no last block");
        SetIRun( GetIRun() + 1 );
        ptb = GetRunAbs(GetIRun());
        AssertSz(ptb->_ibGap == 0,  "split last gap in wrong place");
        AssertSz(cchLast <= CchOfCb(ptb->_cbBlock) - ptb->_cch,
                                    "split last not big enuf");

        CopyMemory(ptb->_pch, pch, CbOfCch(cchLast));
        // don't subtract cchLast from cch; it's already been done
        SetIch( cchLast );
        ptb->_cch       += cchLast;
        ((CTxtArray *)_prgRun)->_cchText    += cchLast;
        ptb->_ibGap     = CbOfCch(cchLast);
        cchLast = 0;                        // Inserted all requested chars
    }

done:
    AssertSz(cch + cchLast <= cchSave, "don't insert more than was asked for");

    cch = cchSave - cch - cchLast;          // # chars successfully inserted
    _cp += cch;

    AssertSz (GetTextLength() ==
                ((CTxtArray *)_prgRun)->GetCch(),
                "CTxtPtr::InsertRange(): _prgRun->_cchText screwed up !");
    return long( cch );
}


/*
 *  TxDivideInsertion(cch, ichBlock, cchAfter, pcchFirst, pcchLast)
 *
 *  @func
 *      Find best way to distribute an insertion
 *
 *  @rdesc
 *      nothing
 */
void TxDivideInsertion(
    DWORD cch,              //@parm length of text to insert
    DWORD ichBlock,         //@parm offset within block to insert text
    DWORD cchAfter,         //@parm length of text after insertion in block
    DWORD *pcchFirst,       //@parm exit: length of text to put in first block
    DWORD *pcchLast)        //@parm exit: length of text to put in last block
{
    DWORD cchFirst = max(0L, (LONG)(cchBlkCombmGapI - ichBlock));
    DWORD cchLast  = max(0L, (LONG)(cchBlkCombmGapI - cchAfter));
    DWORD cchPartial;
    DWORD cchT;

    // Fill first and last blocks to min block size if possible

    cchFirst = min(cch, cchFirst);
    cch     -= cchFirst;
    cchLast = min(cch, cchLast);
    cch     -= cchLast;

    // How much is left over when we divide up the rest?
    cchPartial = cch % cchBlkInsertmGapI;
    if(cchPartial > 0)
    {
        // Fit as much as the leftover as possible in the first and last
        // w/o growing the first and last over cbBlockInitial
        cchT        = max(0L, (LONG)(cchBlkInsertmGapI - ichBlock - cchFirst));
        cchT        = min(cchT, cchPartial);
        cchFirst    += cchT;
        cch         -= cchT;
        cchPartial  -= cchT;
        if(cchPartial > 0)
        {
            cchT    = max(0L, (LONG)(cchBlkInsertmGapI - cchAfter - cchLast));
            cchT    = min(cchT, cchPartial);
            cchLast += cchT;
        }
    }
    *pcchFirst = cchFirst;
    *pcchLast = cchLast;
}


/*
 *  CTxtPtr::DeleteRange(cch)
 *
 *  @mfunc
 *      Delete cch characters starting at this text pointer
 *
 *  @rdesc
 *      nothing
 *
 *  @comm Side Effects: <nl>
 *      moves text block array
 */
void CTxtPtr::DeleteRange(
    DWORD cch)      //@parm length of text to delete
{
    _TEST_INVARIANT_

    DWORD       cchInBlock;
    DWORD       ctbDel = 0;                 // Default no blocks to delete
    DWORD       itb;
    CTxtBlk *   ptb = GetCurrRun();

    AssertSz(ptb,
        "CTxtPtr::DeleteRange: want to delete, but no text blocks");

    if (cch > GetTextLength() - _cp)// Don't delete beyond EOT
        cch = GetTextLength() - _cp;

    ((CTxtArray *)_prgRun)->_cchText -= cch;

    // remove from first block
    ptb->MoveGap(GetIch());
    cchInBlock = min(long(cch), ptb->_cch - GetIch());
    cch -= cchInBlock;
    ptb->_cch -= cchInBlock;

#if DBG==1
    ((CTxtArray *)_prgRun)->Invariant();
#endif

    for(itb = ptb->_cch ? GetIRun() + 1 : GetIRun();
            cch && long(cch) >= GetRunAbs(itb)->_cch; ctbDel++, itb++)
    {
        // More to go: scan for complete blocks to remove
        cch -= GetRunAbs(itb)->_cch;
    }

    if(ctbDel)
    {
        // ***** moves (*_prgRun) ***** //
        itb -= ctbDel;
        ((CTxtArray *)_prgRun)->RemoveBlocks(itb, ctbDel);
    }


    // remove from last block
    if(cch > 0)
    {
        ptb = GetRunAbs(itb);
        AssertSz(long(cch) < ptb->_cch, "last block too small");
        ptb->MoveGap(0);
        ptb->_cch -= cch;
#if DBG==1
        ((CTxtArray *)_prgRun)->Invariant();
#endif

    }

    if (    ((CTxtArray *)_prgRun)->CombineBlocks(GetIRun())
        ||  GetIRun() >= NumRuns()
        || !GetRunAbs(GetIRun())->_cch)
        BindToCp(_cp);                  // Empty block or blocks combined: force tp rebind

    AssertSz (GetTextLength() ==
                ((CTxtArray *)_prgRun)->GetCch(),
                "CTxtPtr::DeleteRange(): _prgRun->_cchText screwed up !");
}


/*
 * Method: FindText
 *
 * Synopsis: This does a search optimized for ascii text, using the
 *  Knuth-Morris-Pratt string matching algorithm as described in
 *  "Introduction to Algorithms" by Cormen, Leiserson and Rivest.
 *
 *  The basic idea of the algorithm is to calculate a "prefix function"
 *  (which is a bit of a misnomer for backwards searching) that contains
 *  information about how the pattern to be found matches against itself.
 *  When a partial match fails, all the characters up to the failing point
 *  are known, so there's no reason to look at them again.  By using the
 *  prefix function, we know where the next possible match could occur, so
 *  we skip up to that point.
 *
 *  Positions this at the beginning of the match if found; if not, this does
 *  not move.  Returns the cp just after the match if found; if not, returns
 *  -1.
 */

MtDefine( CTxtPtr_FindAsciiText_aryPrefixFunction_pv, Locals, "CTxtPtr::FindAsciiText aryPrefixFunction::_pv" );
MtDefine( CTxtPtr_FindAsciiText_aryPatternBuffer_pv, Locals, "CTxtPtr::FindAsciiText aryPatterBuffer::_pv" );
LONG CTxtPtr::FindText(
    LONG            cpLimit,
    DWORD           dwFlags,
    TCHAR const *   pch,
    long            cchToFind )
{
    CStackPtrAry<LONG_PTR, 20>  aryPrefixFunction( Mt(CTxtPtr_FindAsciiText_aryPrefixFunction_pv) );
    CStackPtrAry<LONG_PTR, 20>  aryPatternBuffer(  Mt(CTxtPtr_FindAsciiText_aryPatternBuffer_pv) );

    // Flags
    BOOL            fIgnoreCase;
    BOOL            fWholeWord;
    BOOL            fRaw;
    long            iDir;

    const TCHAR *   pchCurr = pch;
    LONG            cchMatched = 0;
    LONG            cch;

    CTxtPtr         tp( *this );

    Assert( pchCurr );
    AssertSz( cchToFind > 0, "Zero length pattern should get caught before here" );

    //
    // Argument checking and set-up
    //

    // Set up our options from dwFlags
    fIgnoreCase    = !(FR_MATCHCASE & dwFlags);
    fWholeWord     =   FR_WHOLEWORD & dwFlags;
    fRaw           =   FINDTEXT_RAW & dwFlags;

    iDir = ( FINDTEXT_BACKWARDS & dwFlags ) ? -1 : 1;

    //
    // Compute the prefix function
    //
    {
        LONG          cchDone;
        LONG          cchPrefixLength = 0;

        aryPrefixFunction.EnsureSize( cchToFind );
        aryPatternBuffer.EnsureSize(  cchToFind );

        // If we're searching backwards, start at the end of the pattern
        if( -1 == iDir )
        {
            pchCurr += cchToFind - 1;
        }

        for( cchDone = 0; cchDone < cchToFind; cchDone++ )
        {
            // Make sure we've just got ascii
            if( !fRaw && *pchCurr >= 0xff )
            {
                return FindComplexHelper(
                        cpLimit,
                        dwFlags,
                        pch,
                        cchToFind );
            }

            // Copy into the buffer - for a case insensitive compare,
            // convert to lower case if necessary
            TCHAR ch = *pchCurr;

            if( fIgnoreCase){
                CharLowerBuffW((LPWSTR)&ch, 1);
            }

            aryPatternBuffer.Append(ch);

            // We can't extend the current match
            while(  cchPrefixLength > 0
                &&  aryPatternBuffer[cchPrefixLength] != aryPatternBuffer[cchDone] )
            {
                // Go to the next smallest match
                cchPrefixLength = (LONG)aryPrefixFunction.Item( cchPrefixLength - 1 );
            };

            // The first entry is always 0
            if( cchDone && aryPatternBuffer[cchPrefixLength] == *pchCurr )
            {
                ++cchPrefixLength;
            }

            aryPrefixFunction.Append( cchPrefixLength );
            pchCurr += iDir;
        }
    }   // Done with prefix function


    //
    // Perform the search
    //

    // Set/check the limit - cch is the amount of characters left
    // in the document in the appropriate direction.
    if( 1 == iDir )
    {
        LONG cchText = GetTextLength();

        if( cpLimit < 0 || cpLimit > cchText )
            cpLimit = cchText;

        cch = cpLimit - _cp;
    }
    else
    {
        if( cpLimit < 0 )
            cpLimit = 0;

        // Make sure we didn't get a limit farther down than us
        Assert( cpLimit <= (LONG)_cp);

        cch = _cp - cpLimit;
    }

    // Make sure the limit is valid.
    Assert(   ( iDir == -1 && cpLimit <= (long)_cp )
           || ( iDir ==  1 && cpLimit >= (long)_cp ) );

    // Make sure we have enough characters to attempt to match
    if ( cchToFind > cch )
    {
        return -1;
    }

    // Outer loop: Keep getting chunks while there's text left
    while( cch > 0 )
    {
        long    cchChunk;
        TCHAR   chCurr;

        // Get the current chunk of text.  cchChunk is how many
        // characters are left in the current chunk.
        if( 1 == iDir )
        {
            pchCurr = tp.GetPch( cchChunk );
            cchChunk = min( cch, cchChunk );
            tp.AdvanceCp( cchChunk );
        }
        else
        {
            // GetPchReverse returns a pointer to the character
            // just after tp, but with text _before_ the pointer,
            // so we skip back to the first thing before this spot.
            pchCurr = tp.GetPchReverse( cchChunk );
            --pchCurr;
            cchChunk = min( cch, cchChunk );
            tp.AdvanceCp( -cchChunk );
        }

        cch -= cchChunk;

        Assert( cch >= 0 );


        // Chunk loop: This does the main bulk of the work
        while( cchChunk > 0 )
        {
            // In case this chunk starts with node characters, skip 'em.
            while( cchChunk && *pchCurr == WCH_NODE )
            {
                pchCurr += iDir;
                --cchChunk;
            }

            if( !cchChunk )
                break;

            chCurr = *pchCurr;

            // Make sure we've just got ascii
            if( chCurr >= 0xff )
            {
                return FindComplexHelper(
                        cpLimit,
                        dwFlags,
                        pch,
                        cchToFind );
            }

            if( fIgnoreCase)
                CharLowerBuffW((LPWSTR)&chCurr, 1);

            if( chCurr == WCH_NONBREAKSPACE)
            {
                // &nbsp's have their own character, but should match spaces.
                chCurr = _T(' ');
            }

            // While we can't match any more characters, try jumping back
            // to a smaller match and see if we can match from there
            while( cchMatched > 0 && chCurr != aryPatternBuffer[cchMatched] )
            {
                cchMatched = (LONG)aryPrefixFunction[cchMatched - 1];
            }

            // If the next character matches, then increment match count
            if( chCurr == aryPatternBuffer[cchMatched] )
            {
                ++cchMatched;
            }

            // Matched the string - now do some checking
            if( cchMatched == cchToFind)
            {
                CTxtPtr tpStart( _pMarkup, tp._cp );
                CTxtPtr tpEnd ( *this );
                long    cchLength;

                // Here we have to set pointers at the beginning and
                // end of the match.  We only know the edge of the match
                // that we most recently saw (end if going forward,
                // beginning if going backward), so we start from there
                // and count characters to the other side, checking
                // for breaking nodes on the way.
                if( -1 == iDir )
                {
                    // Move tp to the beginning of match
                    tpStart.AdvanceCp( cchChunk - 1 );
                    tpEnd.SetCp( tpStart._cp);

                    // We want to be at the cp just after the last
                    // character matched, so go right before it, and
                    // then one more cp past.
                    for( cchLength = cchToFind; cchLength; tpEnd.AdvanceCp( 1 ) )
                    {
                        if( tpEnd.GetChar() != WCH_NODE )
                        {
                            --cchLength;
                        }
                        else if( Classify( &tpEnd, NULL ) != NODECLASS_NONE )
                            goto invalid_match;
                    }
                }
                else
                {
                    tpStart.AdvanceCp( -cchChunk + 1 );
                    tpEnd.SetCp( tpStart._cp );

                    for( cchLength = cchToFind; cchLength; )
                    {
                        tpStart.AdvanceCp( -1 );

                        if( tpStart.GetChar() != WCH_NODE )
                        {
                            --cchLength;
                        }
                        else if( Classify( &tpStart, NULL ) != NODECLASS_NONE )
                            goto invalid_match;
                    }
                }

                // Check for whole word matching
                if(     !fWholeWord
                    || ( ( tpStart.IsAtBOWord() || tpStart.IsAtEOWord() ) &&
                         ( tpEnd.IsAtBOWord() || tpEnd.IsAtEOWord() ) ) )
                {
                    SetCp(tpStart._cp);
                    return tpEnd._cp;
                }

                // Either we didn't satisfy the whole word match, or
                // there was a break in the middle, so skip to next
                // smallest match

invalid_match:
                cchMatched = (LONG)aryPrefixFunction[cchMatched - 1];
            }

            // Next char - if we run out of chars in this chunk,
            // we'll drop out of the loop and get some more.
            pchCurr += iDir;
            --cchChunk;

        } // while( cchChunk > 0 )

    } // while( cch > 0 )

    // We ran out of characters without finding a match.
    return -1;
}


typedef struct
{
    long cp;
    long cch;
} StripRecord;


// TODO (t-johnh): This will be replaced with a new version once some stuff
//  is added to shlwapi.

MtDefine( CTxtPtr_FindComplexHelper_aryMatchBuffer_pv, Locals, "CTxtPtr::FindComplexHelper aryMatchBuffer::_pv" );
MtDefine( CTxtPtr_FindComplexHelper_aryPatternBuffer_pv, Locals, "CTxtPtr::FindComplexHelper aryPatternBuffer::_pv" );
MtDefine( CTxtPtr_FindComplexHelper_aryStripped_pv, Locals, "CTxtPtr::FindComplexHelper aryStripped::_pv" );

LONG CTxtPtr::FindComplexHelper(
    LONG            cpLimit,
    DWORD           dwFlags,
    TCHAR const *   pch,
    long            cchToFind )
{
    CDataAry<TCHAR>       aryMatchBuffer( Mt(CTxtPtr_FindComplexHelper_aryMatchBuffer_pv) );
    CDataAry<TCHAR>       aryPatternBuffer( Mt(CTxtPtr_FindComplexHelper_aryPatternBuffer_pv) );
    CDataAry<StripRecord> aryStripped( Mt(CTxtPtr_FindComplexHelper_aryStripped_pv) );

    TCHAR WCH_ALEF = 0x0627;

    _TEST_INVARIANT_

    CTxtPtr         tp(*this);      // Keeps track of where we're looking

    LONG            cch;
    long            cchText = GetTextLength();

    // Flags
    BOOL            fIgnoreCase;
    BOOL            fWholeWord;
    long            iDir;

    // For tree navigation
    long            cchOffset;
    CTreePos *      ptp  = _pMarkup->TreePosAtCp( _cp, &cchOffset );

    // For buffer navigation
    const TCHAR *   pchCurr;
    long            cchPatternSize;
    long            cchForward;
    long            cchLeft;
    long            nIndex;         // For looping through records
    long            nRecords;       // of stripped characters


    Assert(pch);

    //
    // Argument checking and set-up
    //

    // Set up our options from dwFlags
    fIgnoreCase    = !(FR_MATCHCASE & dwFlags);
    fWholeWord     =   FR_WHOLEWORD & dwFlags;

    iDir = (FINDTEXT_BACKWARDS & dwFlags ) ? -1 : 1;

    // They didn't give us any characters to find!
    if(cchToFind <= 0)
    {
        return -1;
    }

    // Doctor up the pattern to match
    {
        cchLeft = cchToFind;

        aryPatternBuffer.EnsureSize( cchToFind );
        cchPatternSize = 0;
        pchCurr       = pch;

        for( ; cchLeft; cchLeft--, pchCurr++ )
        {
            // If we're ignoring Diacritics/Kashidas, we want to
            // strip them out of our pattern.
            if(   ( !( dwFlags & FR_MATCHDIAC ) && IsBiDiDiacritic( *pchCurr ) )
               || ( !( dwFlags & FR_MATCHKASHIDA ) && *pchCurr == WCH_KASHIDA ) )
            {
                continue;
            }
            else if( !( dwFlags & FR_MATCHALEFHAMZA ) && IsAlef( *pchCurr ) )
            {
                aryPatternBuffer[cchPatternSize++] = WCH_ALEF;
            }
            else
            {
                aryPatternBuffer[cchPatternSize++] = *pchCurr;
            }
        }

        aryPatternBuffer.SetSize( cchPatternSize );
    }

    // Set/check the limiting cp for search.
    if( 1 == iDir )
    {
        if( cpLimit < 0 || cpLimit > cchText )
            cpLimit = cchText;
    }
    else
    {
        if( cpLimit < 0 )
            cpLimit = 0;
    }

    // Loop through paragraphs, buffering up the interesting text
    // and attempting to match on it.
    for( ; ; )
    {
        StripRecord    sr;
        BOOL           fStripping;
        long           cchPara;
        CTxtPtr        tpParaStart( *this );
        CTxtPtr        tpParaEat( *this );
        CTxtPtr        tpParaEnd( *this );

        sr.cp = 0;      // init
        sr.cch = 0;
        //////////////////////////////////////////////////////////////////
        //
        // Step 1: Define the paragraph boundaries by getting node
        // information from the tree.
        //
        //////////////////////////////////////////////////////////////////

        cch = 0;
        nRecords = 0;
        fStripping = FALSE;

        // If moving backwards, set ptp to the first interesting pos
        // in the paragraph.

        if (iDir == -1)
        {
            // Skip back to an embedding or block break

            for ( ; ; )
            {
                CTreePos * pPrevPos = ptp->PreviousTreePos();

                if (!pPrevPos)
                    break;

                if (ptp->IsNode() && ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE)
                    break;

                ptp = pPrevPos;
            }

            // Then move forward to the interesting one.
            ptp = ptp->NextTreePos();

            // Paragraph starts here, but

            tpParaStart.SetCp( ptp->GetCp() );

            // Limit our buffer start based on tp and the limit

            if (tpParaStart._cp > tp._cp)
                tpParaStart.SetCp( tp._cp );
            else if (long( tpParaStart._cp ) < cpLimit)
                tpParaStart.SetCp( cpLimit );

            tpParaEnd.SetCp( tp._cp );
        }
        else
        {
            // Moving forwards, find the end of this paragraph

            for ( ; ; )
            {
                if (!ptp)
                    break;

                if (ptp->IsNode() && ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE)
                    break;

                ptp = ptp->NextTreePos();
            }


            tpParaEnd.SetCp( ptp ? ptp->GetCp() : cpLimit );

            // Limit the buffer ending based on the limit.

            if (long(tpParaEnd._cp) > cpLimit)
                tpParaEnd.SetCp( cpLimit );

            tpParaStart.SetCp( tp._cp );
        }

        // Make sure we've got enough space.
        // NOTE (t-johnh): This will be a quite
        // wasteful (twice the space needed), but better than repeated
        // allocations to grow the buffer.  The thing is, I can't just
        // Append with a DataAry - I'd have to allocate new StripRecords
        // and AppendIndirect - this way I can just use [] and assign.

        if (tpParaEnd._cp < tpParaStart._cp)
            goto no_match;

        aryMatchBuffer.EnsureSize( tpParaEnd._cp - tpParaStart._cp );
        aryStripped.EnsureSize( tpParaEnd._cp - tpParaStart._cp );

        //////////////////////////////////////////////////////////////////
        //
        // Step 2: Build up the buffer from tpParaStart to tpParaEnd
        // by stripping out any un-interesting characters and storing
        // StripRecords noting where we pulled out characters so that
        // we can rebuild Cp's later.
        //
        //////////////////////////////////////////////////////////////////

        cchPara = tpParaEnd._cp - tpParaStart._cp;
        tpParaEat.SetCp( tpParaStart.GetCp() );
        while( cchPara )

        {
            long cchChunk;

            pch = tpParaEat.GetPch( cchChunk );
            cchChunk = min(cchChunk, cchPara);
            tpParaEat.AdvanceCp( cchChunk );
            cchPara -= cchChunk;

            while( cchChunk )
            {
                // Do we want to strip this character out of our buffer?
                if(   ( *pch == WCH_NODE )
                   || ( !( dwFlags & FR_MATCHDIAC ) && IsBiDiDiacritic( *pch ) )
                   || ( !( dwFlags & FR_MATCHKASHIDA ) && *pch == WCH_KASHIDA )
                  )
                {
                    if( !fStripping )
                    {
                        // If we're not stripping yet, set up a new
                        // strip record.
                        fStripping = TRUE;
                        sr.cp  = cch;
                        sr.cch = 1;
                    }
                    else
                    {
                        // otherwise, just tally up another character.
                        ++sr.cch;
                    }
                }
                else
                {
                    // Real character
                    if( fStripping )
                    {
                        // If we were stripping, save the record.
                        aryStripped[nRecords++] = sr;
                        fStripping = FALSE;
                    }

                    if( !( dwFlags & FR_MATCHALEFHAMZA ) && IsAlef( *pch ) )
                    {
                        aryMatchBuffer[cch++] = WCH_ALEF;
                    }
                    else
                    {
                        aryMatchBuffer[cch++] = *pch;
                    }
                }

                ++pch;
                --cchChunk;
            }
        }

        // Set the correct sizes for our buffers.
        aryMatchBuffer.SetSize( cch );
        aryStripped.SetSize( nRecords );



        //////////////////////////////////////////////////////////////////
        //
        // Step 3: Scan through this buffer in the appropriate direction
        // looking for a match, and then verify it if necessary.
        //
        //////////////////////////////////////////////////////////////////

        if( 1 == iDir )
        {
            // Search forward from buffer start
            pchCurr = (TCHAR *)aryMatchBuffer;
            cchForward = cch;
        }
        else
        {
            // Search backwards from buffer end.
            pchCurr = (TCHAR *)aryMatchBuffer + cch - 1;
            cchForward = 1;
        }

        // Now that we've got our buffer, try and match on it.
        cchLeft = cch;

        while( cchLeft > 0 )
        {
            if( 2 == CompareStringAltW(
                        LOCALE_USER_DEFAULT,
                        SORT_STRINGSORT | ( fIgnoreCase ? ( NORM_IGNORECASE | NORM_IGNOREWIDTH ) : 0 ),
                        pchCurr,
                        min(cchForward, cchPatternSize),
                        aryPatternBuffer,
                        cchPatternSize ) )
            {
                CTxtPtr tpStart( _pMarkup, tpParaStart._cp + pchCurr - aryMatchBuffer );
                CTxtPtr tpEnd( *this );

                // Move start to the match point, and adjust for stripped nodes.
                for( nIndex = 0, nRecords = aryStripped.Size();
                     nRecords > 0 && aryStripped[nIndex].cp <= pchCurr - aryMatchBuffer;
                     nRecords--, nIndex++ )
                {
                    tpStart.AdvanceCp( aryStripped[nIndex].cch );
                }

                // Now do the same for the ending cp.
                tpEnd.SetCp( tpStart._cp + cchPatternSize );
                for( ;
                     nRecords > 0 && aryStripped[nIndex].cp < pchCurr + cchPatternSize - aryMatchBuffer;
                     nRecords--, nIndex++ )
                {
                    tpEnd.AdvanceCp( aryStripped[nIndex].cch );
                }

                if( !fWholeWord ||
                    ( ( tpStart.IsAtBOWord() || tpStart.IsAtEOWord() ) &&
                      ( tpEnd.IsAtBOWord()   || tpEnd.IsAtEOWord() ) ) )
                {
                    SetCp( tpStart._cp );
                    return tpEnd._cp;
                }
            }

            pchCurr += iDir;
            cchForward -= iDir;
            --cchLeft;
        }

        // No match if we've hit the limit.
        if( (long)tpParaStart._cp == cpLimit || (long)tpParaEnd._cp == cpLimit )
            goto no_match;

        // Move over to the next paragraph.
        if( 1 == iDir )
        {
            ptp = _pMarkup->TreePosAtCp( tpParaEnd._cp, &cchOffset );
            while( ptp->IsNode() && ( !ptp->IsEdgeScope() ||
                                      ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE ) )
            {
                ptp = ptp->NextTreePos();
                if ( !ptp )
                    goto no_match;
            }
            tp.SetCp( ptp->GetCp() );
        }
        else
        {
            ptp = _pMarkup->TreePosAtCp( tpParaStart._cp - 1, &cchOffset );

            while( ptp->IsNode() && ( !ptp->IsEdgeScope() ||
                                      ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE ) )
            {
                ptp = ptp->PreviousTreePos();
                if ( !ptp )
                    goto no_match;
            }
            tp.SetCp( ptp->GetCp() + ptp->GetCch() );
        }

     }
no_match:
     return -1;
}


/*
 *  CTxtPtr::FindBOSentence(cch)
 *
 *  @mfunc
 *      Find beginning of sentence in the document.
 *
 *  @rdesc
 *      Count of chars moved *this moves
 *
 *  @comm
 *      This routine defines a sentence as a character string that ends with
 *      period followed by at least one whitespace character or the EOD.  This
 *      should be replacable so that other kinds of sentence endings can be
 *      used.  This routine also matches initials like "M. " as sentences.
 *      We could eliminate those by requiring that sentences don't end with
 *      a word consisting of a single capital character.  Similarly, common
 *      abbreviations like "Mr." could be bypassed.  To allow a sentence to
 *      end with these "words", two blanks following a period could be used
 *      to mean an unconditional end of sentence.
 */
LONG CTxtPtr::FindBOSentence ( BOOL fForward )
{
    _TEST_INVARIANT_

    LONG    cchWhite = 0;                       // No whitespace chars yet
    long    cpSave   = _cp;                     // Save value for return
    long    cch      = fForward ? GetTextLength() - 1 - _cp : _cp - 1;
    BOOL    fST;                                // TRUE if sent terminator
    LONG    iDir     = fForward ? 1 : -1;       // AdvanceCp() increment
    CTxtPtr tp(*this);                          // tp to search with


    //
    // If moving forward, backup over whitespace.
    // This makes sure we recognize a new sentence
    // if we were in whitespace between 2 previous
    // sentences.
    //
    if(iDir == 1)
    {
        while( IsWhiteSpace(&tp) && cch )
        {
            long cchMoved = AdvanceChars( &tp, -1 );

            cch -= cchMoved;
            if( !cchMoved )
                break;
        }
    }

    while( cch )
    {
        //
        // Find a sentence terminator
        //
        for( fST = FALSE; cch; )
        {
            fST = IsSentenceTerminator( tp.GetChar() );
            if( fST )
                break;

            cch -= iDir * AdvanceChars( &tp, iDir );
        }

        // No ST, or hit forward end of document
        if( !fST || ( fForward && !cch ) )
            break;

        //
        // Skip forward past whitespace
        //
        cchWhite = 0;
        cch -= iDir * AdvanceChars( &tp, 1 );
        while(    IsWhiteSpace( &tp )
               && (    ( fForward && cch )
                    || ( !fForward && long(tp._cp) < cpSave ) ) )
        {
            cchWhite++;
            cch -= iDir * AdvanceChars( &tp, 1 );
        }

        //
        // Needed whitespace, but if we're moving backwards,
        // make sure we actually are prior to start position.
        //
        if( cchWhite && ( fForward || long(tp._cp) < cpSave ) )
            break;

        //
        // Didn't match - adjust prior to ST if backwards
        //
        if( !fForward )
        {
            cch += AdvanceChars( &tp, -cchWhite - 2 );
        }
    }

    if(cchWhite || !cch )                       // If sentence found or got
        SetCp(tp._cp);                          //  start/end of story, set
                                                //  _cp to tp's
    return _cp - cpSave;                        // Tell caller cch moved
}

/*
 *  CTxtPtr::IsAtBOWord()
 *
 *  @mfunc
 *      Return TRUE iff *this is at the beginning of a word, that is,
 *      the char at _cp isn't whitespace and either _cp = 0 or the char at
 *      _cp - 1 is whitespace.
 *
 *  @rdesc
 *      TRUE iff *this is at the beginning of a Word
 */
BOOL CTxtPtr::IsAtBOWord()
{
    if(!_cp || IsAtEOP())                   // Story beginning is also
        return TRUE;                        //  a word beginning

    CTxtPtr tp(*this);
    AdvanceChars( &tp, -1 );
    tp.FindWordBreak(WB_MOVEWORDRIGHT);
    return _cp == tp._cp;
}

/*
 *  CTxtPtr::IsAtEOWord()
 *
 *  @mfunc
 *      Return TRUE iff *this is at the end of a word.
 *
 *  @rdesc
 *      TRUE iff *this is at the end of a Word
 */
BOOL CTxtPtr::IsAtEOWord()
{
    if(!_cp == (GetTextLength() - 1) || IsAtEOP())      // Story end is also
        return TRUE;                                    //  a word end

    CTxtPtr tp(*this);
    AdvanceChars( &tp, -1 );
    tp.FindWordBreak(WB_RIGHTBREAK);
    return _cp == tp._cp;
}

/*
 * CTxtPtr::MoveCluster( fForward )
 *
 * Synopsis: Moves one cluster in the given direction. A cluster is defined as
 * one or more characters that are grouped into a unit.  This looks strictly
 * at TEXT.
 *
 * Returns: number of characters moved
 */
#define MAX_MOVE_BUFFER  33
#define NODE_EXTRA       20

long
CTxtPtr::MoveCluster( BOOL fForward )
{
    TCHAR aryItemize [ MAX_MOVE_BUFFER ];
    CStackDataAry <TCHAR, MAX_MOVE_BUFFER + NODE_EXTRA> aryNodePos(Mt(CTxtPtrFindThaiTypeWordBreak_aryNodePos_pv));
    SCRIPT_LOGATTR arySLA [ MAX_MOVE_BUFFER ];
    long cchMove, cchBefore, cchAfter, lHoldNode;
    long cchNodesSkipped = 0;
    long cpSave, cchText;
    BOOL fMovedPastSignificantNodes = FALSE;
    CTxtPtr tp(*this);
    BOOL fCurrentIsNode = FALSE;
    TCHAR ch;

    cchMove = cchBefore = cchAfter = lHoldNode = 0;

    cpSave = GetCp();
    cchText = GetTextLength();

    // Adjust starting position
    if(cchText)
    {
        //
        // Note, we don't include the root node's WCH_NODE chars as valid chars to deal with.
        //

        int  iDir = fForward ? 1 : -1;
        long cchLeft = fForward ? cchText - 1 - tp._cp : tp._cp;

        //
        // If we are going backward, and there are characters behind us
        //

        if (!fForward && cchLeft)
        {
            tp.AdvanceCp( -1 );
            cchLeft--;
        }

        //
        // Skip over all non scope node chars
        //

        fMovedPastSignificantNodes = FALSE;

        while ( cchLeft && tp.GetChar() == WCH_NODE )
        {
            switch ( Classify( & tp, NULL ) )
            {
            case NODECLASS_NONE       :
                break;

            case NODECLASS_SEPARATOR  :
            case NODECLASS_LINEBREAK  :
            case NODECLASS_BLOCKBREAK :
            case NODECLASS_SITEBREAK  :
                fMovedPastSignificantNodes = TRUE;
                break;

            case NODECLASS_NOSCOPE    :
                fMovedPastSignificantNodes = TRUE;

                //
                // Move past the two node chars to get past this noscope, then
                // set cchLeft to 0 to blow out of the loop
                //

                tp.AdvanceCp( 2 * iDir );

                cchLeft = 0;
                break;

            default :
                AssertSz( 0, "Unexpected Node class" );
                break;
            }

            if (cchLeft != 0)
            {
                tp.AdvanceCp( iDir );
                ++cchNodesSkipped;
                cchLeft--;
            }
        }
    }


    //
    // If the current character is not a clustering char, then we can quickly
    // deal with it.
    //
    // paulnel - we want to handle password characters in Clusters as normal text
    //           since it is drawn as normal text (with "*")
    ch = tp.GetChar();
    if (!IsMoveByClusterChar( ch ) || tp.IsPasswordChar())
    {
        //
        // If we are moving backwards, we have already adjusted to the correct
        // position.  Otherwise, if we are moving forward to the next beginning of
        // a cluster, only do so if we have not skipped past any significant
        // 'synthetic' characters.  THis deals with the case of "a</p><p>b" where
        // one moves from just after the 'a' to just before the 'b'.
        //

#ifndef NO_UTF16
        if (IsSurrogateChar(ch))
        {
            if (!fMovedPastSignificantNodes)
            {
                if (fForward)
                {
                    if (   cchText > 1
                        && IsHighSurrogateChar(ch))
                    {
                        CTxtPtr tpNext(tp);

                        ch = tpNext.NextChar();

                        if (IsLowSurrogateChar(ch))
                        {
                            tp.AdvanceCp( 2 );
                        }
                    }
                }
                else
                {
                    if (   tp._cp > 0
                        && IsLowSurrogateChar(ch))
                    {
                        CTxtPtr tpPrev(tp);

                        ch = tpPrev.PrevChar();

                        if (IsHighSurrogateChar(ch))
                        {
                            tp.AdvanceCp( -1 );
                        }
                    }
                }
            }
        }
        else
#endif
        if (fForward && !fMovedPastSignificantNodes)
            tp.AdvanceCp( 1 );

        SetCp( tp.GetCp() );

        return GetCp() - cpSave;
    }

    //
    // Did we just arrive on a Thai type character? Move to it.
    //
    // TODO (paulnel, IE6 bug 64): if moving backwards do we need to adjust the _cp?
    if(fMovedPastSignificantNodes)
    {
        SetCp( tp.GetCp() );

        return GetCp() - cpSave;
    }

    tp.SetCp( cpSave );
    if(tp.GetChar() == WCH_NODE)
        fCurrentIsNode = TRUE;

    if(!tp.PrepThaiTextForBreak(FALSE,
                                fForward,
                                fCurrentIsNode,
                                cchText,
                                &aryNodePos,
                                aryItemize,
                                &cchBefore,
                                &cchAfter,
                                &cchMove,
                                &lHoldNode))
    {
        cchMove = AdvanceCp(cchMove);
        return cchMove;
    }

    long offset = ItemizeAndBreakRun( aryItemize, &cchBefore, &cchAfter, arySLA );

    if (fForward)
    {

        do
        {
            cchBefore++;
            cchAfter--;
            cchMove++;

        }
        while ( cchAfter >= 0 && ! arySLA[cchBefore].fCharStop );

    }
    else
    {
        // go backwards in the attribute array until the first word break is encountered

        while ( cchBefore > 0 && ! arySLA[cchBefore].fCharStop )
        {
            cchBefore--;
            cchMove--;

        }

        // We decremented cchBefore before passing it in to be itemized.
        // Therefore we need to increase the offset to move it to the
        // correct place.
        offset++;

    }

    Assert(offset + cchMove >= 0 &&
           offset + cchMove < aryNodePos.Size());
    Assert( fForward ? aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] >= 0
                     : aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] <= 0);

    if( fForward )
    {
        cchMove += aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] + cchNodesSkipped;
    }
    else
    {
        Assert( offset > 0 );

        cchMove += aryNodePos [ offset + cchMove ] - aryNodePos [ offset - 1 ] - cchNodesSkipped;
    }

    AdvanceCp( cchMove );

    return cchMove;
}

//+----------------------------------------------------------------------------
//
//  Member: MoveClusterEnd
//
//  Synopsis: Moves the TxtPtr to the next cluster ending in the given
//      direction.  This accounts for non-interesting nodes, too.
//
//-----------------------------------------------------------------------------
long CTxtPtr::MoveClusterEnd( BOOL fForward )
{
    long cpOrig = _cp;
    long cpSave = _cp;
    long cch;

    // To set up for previous end, we have to start at the next begin

    if (!fForward)
        MoveCluster( TRUE );

    for( ; ; )
    {
        if( fForward && !MoveCluster( TRUE ) )
            break;

        // Set limits
        cch     = fForward ? _cp -cpSave : _cp - 1;
        cpSave  = _cp;

        // Scan backwards across nodes,
        while( cch && GetPrevChar() == WCH_NODE )
        {
            AdvanceCp( -1 );
            --cch;
        }

        cch = cpSave - _cp;

        // Then scan forward across un-interesting nodes
        while( cch && GetChar() == WCH_NODE && !Classify( this, NULL ) )
        {
            AdvanceCp( 1 );
            --cch;
        }

        // Make sure we're ending up in the right direction
        if(    (  fForward && long(_cp) > cpOrig )
            || ( !fForward && long(_cp) < cpOrig ) )
            break;

        // If not, try the next one
        if( !MoveCluster( fForward ) )
            break;
    }

    return _cp - cpOrig;
}

/*
 *  CTxtPtr::FindThaiTypeWordBreak(int action )
 *
 *  @mfunc
 *      Find a word break in Thai script and move this text pointer to it.
 *
 *  @rdesc
 *      Offset from cp of the word break
 */
#define MAX_BREAK_BUFFER 75

LONG CTxtPtr::FindThaiTypeWordBreak(
    int     action)     //@parm Direction of movement in run
                        // NOTE: The limit character MUST be on a block boundary if < 47 characters
                        //       to give certainty of valid break location.
{
    long    cchMove = 0;

    if(action == WB_MOVEWORDRIGHT || action == WB_MOVEWORDLEFT ||
       action == WB_RIGHTBREAK || action == WB_LEFTBREAK)
    {

        TCHAR aryItemize[MAX_BREAK_BUFFER];
        CStackDataAry <TCHAR, MAX_BREAK_BUFFER + NODE_EXTRA> aryNodePos(Mt(CTxtPtrFindThaiTypeWordBreak_aryNodePos_pv));
        SCRIPT_LOGATTR arySLA[MAX_BREAK_BUFFER];
        long  cchBefore = 0;
        long  cchAfter = 0;
        CTxtPtr tp(*this);
        BOOL  fForward = (action == WB_RIGHTBREAK || action == WB_MOVEWORDRIGHT);

        // Set up for ScriptItemize(). We need to re-itemize the string instead
        // of using the cached _Analysis struct because we don't know how many
        // characters are involved.

        // Make sure the current character is ThaiType
        Assert(fForward ? NoWhiteBetweenWords(tp.GetChar()) : NoWhiteBetweenWords(tp.GetPrevChar()));

        if(!tp.PrepThaiTextForBreak(TRUE,
                                    fForward,
                                    GetChar() == WCH_NODE,
                                    GetTextLength(),
                                    &aryNodePos,
                                    aryItemize,
                                    &cchBefore,
                                    &cchAfter,
                                    &cchMove))
        {
            cchMove = AdvanceCp(cchMove);
            return cchMove;
        }

        if( !fForward && cchBefore > 0 )
        {
            cchBefore--;
            cchMove--;
        }

        long offset = ItemizeAndBreakRun(aryItemize, &cchBefore, &cchAfter, arySLA);

        if(fForward)
        {
            do
            {
                cchBefore++;
                cchAfter--;
                cchMove++;

            }while(    cchAfter >= 0
                   && (  !(arySLA[cchBefore].fSoftBreak)
                       || (action == WB_MOVEWORDRIGHT ? (arySLA[cchBefore].fWhiteSpace) : FALSE) )
                   && ( action != WB_RIGHTBREAK || wbkclsSpaceA != WordBreakClassFromCharClass( CharClassFromCh( aryItemize[cchBefore] ) ) ) );


            // if we are at the end of Thai text and have spaces, move past the spaces
            if(cchAfter == -1)
            {
                tp.AdvanceCp(cchMove + aryNodePos[offset + cchMove] - aryNodePos[offset]);

                while(IsCharBlank(tp.GetChar()) || (tp.GetChar() == WCH_NODE && !Classify (&tp, NULL)))
                {
                    aryNodePos[offset + cchMove] += 1;
                    if(tp.AdvanceCp(1) != 1)
                        break;
                }

            }

        }
        else
        {
            // go backwards in the attribute array until the first word break is encountered
            while(cchBefore > 0 && !(arySLA[cchBefore].fSoftBreak))
            {
                cchBefore--;
                cchMove --;
            }

        }

        // Adjust back to original position for calculating node characters.
        offset += fForward ? 0 : 1;

        Assert( offset + cchMove >= 0 &&
                offset + cchMove < aryNodePos.Size() );
        Assert( (action & 1) ? aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] >= 0
                             : aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] <= 0);
        cchMove += aryNodePos[offset + cchMove] - aryNodePos[offset];

    }

    return cchMove;                            // Offset of where to break

}

/*
 *  CTxtPtr::PrepThaiTextForBreak(int action )
 *
 *  @mfunc
 *      Prepare text for Thai breaking by removing all nodes from the text to be
 *      itemized. paryNodePos will keep track of node positions so the tp can
 *      be moved correctly.
 *
 *  @rdesc
 *      TRUE/FALSE to indicate completion of preparing the itemize array.
 */
#define BREAK_BEFORE     30
#define BREAK_AFTER      30
#define MOVE_BEFORE      16
#define MOVE_AFTER       15

BOOL
CTxtPtr::PrepThaiTextForBreak(
        BOOL fWordBreak,
        BOOL fForward,
        BOOL fCurrentIsNode,
        long cchText,
        CDataAry<TCHAR> *paryNodePos,
        TCHAR *paryItemize,
        long *pcchBefore,
        long *pcchAfter,
        long *pcchMove,
        long *plHoldNode)
{
    long cpSave = GetCp();
    long cchCtrlBefore = 0;
    long cchCtrlAfter = 0;
    long cchTotal = 0;
    long cch = 0;
    long cchBeforeMax = fWordBreak ? BREAK_BEFORE : MOVE_BEFORE;
    long cchAfterMax = fWordBreak ? BREAK_AFTER : MOVE_AFTER;
    BOOL  fOffEnd = FALSE;

    if(!paryNodePos || !paryItemize || !pcchBefore || !pcchAfter || !pcchMove)
        return FALSE;

    // Advance until cchAfterMax characters have passed or a non-ThaiType character
    // is encountered. If we encounter a breaking type of WCH_NODE we will
    // stop looking. Space type characters are included

    if( !fCurrentIsNode || !Classify(this, NULL) )
    {
        while(*pcchAfter < cchAfterMax)
        {
            TCHAR chCur = NextChar();

            if (NoWhiteBetweenWords( chCur ) || IsMoveByClusterChar( chCur ) ||
                wbkclsSpaceA == WordBreakClassFromCharClass( CharClassFromCh( chCur ) ) )
                *pcchAfter += 1;
            else if (chCur == WCH_NODE)
            {
                if(Classify( this, NULL ))
                    break;

                cchCtrlAfter++;
            }
            else
            {
                if(chCur == 0)
                    fOffEnd = TRUE;
                break;
            }
        }
    }

    // (paulnel) We are making an assumption that a node character is always present at the
    // end of a story
    Assert(fOffEnd ? cchCtrlAfter > 0 : cchCtrlAfter >= 0);

    // Back up until cchAfterMax characters have passed or a non-ThaiType character
    // is encountered. If we encounter a breaking type of WCH_NODE we will
    // stop looking. Space type characters are included
    SetCp( cpSave );

    while ( *pcchBefore < cchBeforeMax )
    {
        TCHAR chCur = PrevChar();

        if (NoWhiteBetweenWords( chCur ) || IsMoveByClusterChar( chCur ) ||
            wbkclsSpaceA == WordBreakClassFromCharClass( CharClassFromCh( chCur ) ) )
            *pcchBefore += 1;
        else if (chCur == WCH_NODE)
        {
            if(_cp == 0 || Classify( this, NULL ))
                break;

            cchCtrlBefore++;
        }
        else
            break;
    }

    if (fForward && *pcchAfter == 0)
    {
        *pcchMove = 1;
        return FALSE;
    }
    else if (!fForward && *pcchBefore == 0)
    {
        *pcchMove = 0;
        return FALSE;
    }

    if(*pcchBefore == 0)
        cchCtrlBefore = 0;

    // Position the tp to the start of the Thai-type text. If we do not have
    // *pcchBefore, don't move for ctrl chars.
    Assert(*pcchBefore + cchCtrlBefore <= cpSave &&
           cpSave + *pcchAfter + cchCtrlAfter < cchText);

    SetCp(cpSave - *pcchBefore - cchCtrlBefore);

    cch = *pcchBefore + *pcchAfter + (fCurrentIsNode ? 0 : 1); // we need to include ourself
    cchTotal = cch + cchCtrlBefore + cchCtrlAfter;

    long cchValid;
    paryNodePos->Grow(cchTotal + 1);
    cchValid = GetRawText(cchTotal, *paryNodePos);

    Assert(cchValid == cchTotal);

    // Strip out any control characters
    long lCount = 0;
    long lTotal = 0;
    long lNode = 0;
    const TCHAR* pchCur = (*paryNodePos);

    while ( lCount < cch )
    {
        Assert( lTotal <= cchTotal );

        if (*pchCur != WCH_NODE)
        {
            // paulnel and john harding - If we have a space type character we want
            // to force it to be a normal space character so that Uniscribe keeps it
            // as part of the Thai type text run during itemization.
            if(wbkclsSpaceA != WordBreakClassFromCharClass( CharClassFromCh( *pchCur ) ))
                paryItemize[lCount] = *pchCur;
            else
                paryItemize[lCount] = _T(' ');

            (*paryNodePos)[lCount] = lNode;
            lCount++;
        }
        else
        {
            lNode++;
            if(lCount == *pcchBefore)
            {
                if(plHoldNode)
                    *plHoldNode += 1;
            }
        }

        lTotal++;
        pchCur++;
    }

    Assert(lCount <= cchTotal);

    // subtract the ending node so we don't walk off of the end.
    if(!fWordBreak)
    {
        (*paryNodePos)[lCount] = cchCtrlBefore + cchCtrlAfter + (fCurrentIsNode ? 1 : 0) - (fOffEnd ? 1 : 0);
    }
    else
    {
        (*paryNodePos)[lCount] = lNode;
    }
    paryNodePos->SetSize( lCount + 1 );

    Assert( cch == lCount );

    if(!fForward && !fWordBreak)
    {
        Assert( *pcchBefore > 0 );

        *pcchBefore -= 1;
        *pcchAfter +=1;
        *pcchMove -=1;
    }

    if(fCurrentIsNode && *pcchAfter > 0)
        *pcchAfter -= 1;

    return TRUE;
}

/*
 *  CTxtPtr::ItemizeAndBreakRun
 *
 *  @mfunc
 *      Uses Uniscribe to itemize Thai type text and mark word and character boundaries.
 *
 *  @rdesc
 *      Offset from the beginning of the string to the run in which the desired
 *      breaking opportunities will be used. This will help match up with the
 *      aryNodePos array
 */
long
CTxtPtr::ItemizeAndBreakRun(TCHAR* aryItemize, long* pcchBefore, long* pcchAfter, SCRIPT_LOGATTR* arySLA)
{
    HRESULT hr;
    CStackDataAry<SCRIPT_ITEM, 8> aryItems(Mt(CTxtPtrItemizeAndBreakRun_aryItems_pv));
    int cItems, nItem;
    long offset = 0;
    long cch = *pcchBefore + *pcchAfter + 1;

    // Prepare SCRIPT_ITEM buffer
    if (FAILED(aryItems.Grow(8)))
    {
        // We should always be able to grow to 8 itemse as we are based on
        // a CStackDataAry of this size.
        Assert(FALSE);
    }

    // Call ScriptItemize() wrapper in usp.cxx.
    if(g_bUSPJitState == JIT_OK)
        hr = ScriptItemize(aryItemize, cch, 16,
                           NULL, NULL, &aryItems, &cItems);
    else
        hr = E_PENDING;

    if (FAILED(hr))
    {
        if(hr == USP10_NOT_FOUND)
        {
            g_csJitting.Enter();
            if(g_bUSPJitState == JIT_OK)
            {
                g_bUSPJitState = JIT_PENDING;

                // We must do this asyncronously.
                IGNORE_HR(GWPostMethodCall(_pMarkup->Doc(),
                                           ONCALL_METHOD(CDoc, FaultInUSP, faultinusp),
                                           0, FALSE, "CDoc::FaultInUSP"));

            }
            g_csJitting.Leave();
        }
        // ScriptItemize() failed (for whatever reason). We are unable to
        // break, so assume we've got a single word and return.
        goto done;
    }

    // Find the SCRIPT_ITEM containing cp.
    for(nItem = aryItems.Size() - 1;
        *pcchBefore < aryItems[nItem].iCharPos;
        nItem--);
    if (nItem < 0 || nItem + 1 >= aryItems.Size())
    {
        // Somehow the SCRIPT_ITEM array has gotten messed up. We can't
        // break, so assume we've got a single word and return.
        goto done;
    }

    // Adjust cch to correspond to the text indicated by this item.
    cch = aryItems[nItem + 1].iCharPos - aryItems[nItem].iCharPos;
    *pcchBefore -= aryItems[nItem].iCharPos;
    *pcchAfter = cch - *pcchBefore - 1;

    Assert(*pcchBefore >= 0 && *pcchAfter >= 0 && *pcchBefore + *pcchAfter + 1 == cch);

    // do script break
    hr = ScriptBreak(aryItemize + aryItems[nItem].iCharPos, cch,
                     (SCRIPT_ANALYSIS *) &aryItems[nItem].a,
                     arySLA);

    if (FAILED(hr))
    {
        // ScriptBreak() failed (for whatever reason). We are unable to break,
        // so assume we've got a single word and return.
        goto done;
    }

    offset = *pcchBefore + aryItems[nItem].iCharPos;
done:
    return offset;                            // Offset of where to break
}


//
// Bookmark get/set methods
//

#define BOOKMARK_CURRENT_VERSION 2

// Structures
struct NastyCharsCounts
{
    long cchEmbed;
    long cchLineBreak;
    long cchBlockBreak;
    long cchWordBreak;
    long cchTxtSiteBreak;
    long cchTxtSiteEnd;
    long cchMiscNasty;
};

#define NUM_ADJACENT_CHARS 10

struct BookEnd
{
    long cp;

    NastyCharsCounts nastyCounts;

    char cchLeft, cchRight;
    TCHAR achLeft [ NUM_ADJACENT_CHARS ];
    TCHAR achRight [ NUM_ADJACENT_CHARS ];
};

struct Bookmark
{
    TCHAR chZero;

    char chVersion;
    char chDegenerate;

    BookEnd left;
    BookEnd right; // Only if not degenerate
};

/*
 * FindBookend:
 *
 * Synopsis: Looks forward or backward, as specified by fForward, trying
 *  to find the given bookend.  If found, the given CTxtPtr will be positioned
 *  at the bookend.
 *
 * Returns: TRUE if found, FALSE if not.
 */
static BOOL FindBookend( CTxtPtr * ptp, BookEnd & bookend, BOOL fForward )
{
    long    cpOrig     = ptp->_cp;
    long    cchLeft, cchRight, cch;
    BOOL    fFoundIt   = FALSE;
    TCHAR   achLeft[NUM_ADJACENT_CHARS], achRight[NUM_ADJACENT_CHARS];

    //
    // Make copies of the achLeft/Right strings, stripping out
    // non-text characters that don't exist now.
    //
    for( cch = 0, cchLeft = 0; cch < bookend.cchLeft; cch++ )
    {
        if( IsValidWideChar( bookend.achLeft[cch] ) )
            achLeft[cchLeft++] = bookend.achLeft[cch];
    }
    for( cch = 0, cchRight = 0; cch < bookend.cchRight; cch++ )
    {
        if( IsValidWideChar( bookend.achRight[cch] ) )
            achRight[cchRight++] = bookend.achRight[cch];
    }

    // Now scan along in the given direction, trying to match achLeft/Right
    for( ; ; )
    {
        long cpSave = ptp->_cp;

        if (0 == cchLeft)
        {
            // If there is no left text, automatically match
            fFoundIt = TRUE;
        }
        else
        {
            for( cch = 0; ptp->MoveChar( FALSE ) && ptp->GetChar() == achLeft[cch]; )
            {
                // Matched achLeft
                if( ++cch >= cchLeft )
                {
                    fFoundIt = TRUE;
                    break;
                }
            }
        }


        ptp->SetCp( cpSave );

        // Only check achRight if we matched achLeft.
        if( fFoundIt )
        {
            fFoundIt = FALSE;
            cch = 0;

            if (0 == cchRight)
            {
                fFoundIt = TRUE;
            }
            else
            {
                for( cch = 0; ptp->GetChar() == achRight[cch]; )
                {
                    // Matched achRight
                    if( ++cch >= cchRight )
                    {
                        fFoundIt = TRUE;
                        break;
                    }

                    // out of characters
                    if( !ptp->MoveChar( TRUE ) )
                        break;
                }
            }
        }

        ptp->SetCp( cpSave );

        if( fFoundIt )
            return TRUE;

        if( !ptp->MoveChar( fForward ) )
            break;
    }

    // Couldn't find it.
    ptp->SetCp( cpOrig );
    return FALSE;
}

/*
 * Member: CTxtPtr::MoveToBookmark
 *
 * Synopsis: Moves this to the beginning of given bookmark, and moves
 *  pTxtPtrend to the end of the bookmark.  If bookmark can not be found,
 *  neither is moved.
 *
 * Returns: S_OK if found, S_FALSE if not.
 */
HRESULT CTxtPtr::MoveToBookmark( BSTR bstrBookmark, CTxtPtr *pTxtPtrEnd )
{
    HRESULT             hr      = S_OK;
    Bookmark            bm;
    long                cchBookmark;
    TCHAR *             pch;

    BOOL                fFoundIt;


    Assert( pTxtPtrEnd );

    //
    // Parse out and verify the bookmark string.
    //
    cchBookmark = FormsStringLen( bstrBookmark );

    cchBookmark *= sizeof(TCHAR);

    if (cchBookmark != sizeof( Bookmark ) &&
        cchBookmark != sizeof( Bookmark ) - sizeof( BookEnd ))
    {
        goto InvalidBookmark;
    }

    memcpy( & bm, & bstrBookmark[ 0 ], cchBookmark );

    cchBookmark /= sizeof(TCHAR);

    pch = (TCHAR *) & bm;

    for ( ; ; )
    {
        for (int i = 0 ; i < cchBookmark ; i++ )
            pch[i]--;

        if (bm.chZero == 0)
            break;
    }

    if (bm.chVersion > char( BOOKMARK_CURRENT_VERSION ))
        goto InvalidBookmark;

    //
    // Look for bookends
    //

    // Adjust inside of document
    if (bm.left.cp >= GetTextLength())
        bm.left.cp = GetTextLength() - 1;

    SetCp( bm.left.cp );
    fFoundIt =    FindBookend( this, bm.left, FALSE )
               || FindBookend( this, bm.left, TRUE );

    if( !bm.chDegenerate )
    {
        // Adjust inside of document
        if (bm.right.cp >= GetTextLength())
            bm.right.cp = GetTextLength() - 1;

        pTxtPtrEnd->SetCp( bm.right.cp );
        fFoundIt = fFoundIt && (    FindBookend( pTxtPtrEnd, bm.right, FALSE )
                                 || FindBookend( pTxtPtrEnd, bm.right, TRUE ) );
    }
    else
    {
        pTxtPtrEnd->SetCp( _cp );
    }


    // If we couldn't find it, return S_FALSE to notify caller.
    if( !fFoundIt )
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );

InvalidBookmark:
    hr = E_INVALIDARG;
    goto Cleanup;
}

static void CountNasties (
    CTxtPtr * pTxtPtr, long cp, NastyCharsCounts & nasties )
{
    long cchLeft;
    long cpSave = pTxtPtr->_cp;

    nasties.cchEmbed = 0;
    nasties.cchLineBreak = 0;
    nasties.cchBlockBreak = 0;
    nasties.cchWordBreak = 0;
    nasties.cchTxtSiteBreak = 0;
    nasties.cchTxtSiteEnd = 0;
    nasties.cchMiscNasty = 0;

    // Count word breaks.
    while( long(pTxtPtr->_cp) < cp )
    {
        nasties.cchWordBreak++;
        pTxtPtr->FindWordBreak( WB_MOVEWORDRIGHT );
    }

    pTxtPtr->SetCp( cpSave );
    cchLeft = cp - pTxtPtr->_cp;

    // Count everything else.
    while( cchLeft-- > 0)
    {
        BOOL    fBegin;

        if ( WCH_NODE == pTxtPtr->GetChar() )
        {
            switch( Classify( pTxtPtr, &fBegin ) )
            {
            case NODECLASS_NONE:        nasties.cchMiscNasty++;     break;
            case NODECLASS_SEPARATOR:   nasties.cchEmbed++;         break;
            case NODECLASS_NOSCOPE:     nasties.cchEmbed++;         break;
            case NODECLASS_LINEBREAK:   nasties.cchLineBreak++;     break;
            case NODECLASS_BLOCKBREAK:  nasties.cchBlockBreak++;    break;
            case NODECLASS_SITEBREAK:
                if( fBegin )
                    nasties.cchTxtSiteBreak++;
                else
                    nasties.cchTxtSiteEnd++;
                break;
            }
        }
        pTxtPtr->AdvanceCp( 1 );
    }

}

/*
 * ComputeAdjacent:
 *
 * Synopsis: Computes the text adjacent to the given TxtPtr and fills
 *  bookend appropriately.
 */
static void ComputeAdjacent (
    CTxtPtr * pTxtPtr, BookEnd & bookend )
{
    long    cch, cpSave;
    long    cchText = pTxtPtr->GetTextLength();
    TCHAR * pch;

    cpSave = pTxtPtr->GetCp();
    pch = bookend.achLeft;

    // Look left
    for( cch = 0, pTxtPtr->MoveChar( FALSE );
         pTxtPtr->_cp > 1 && cch < NUM_ADJACENT_CHARS;
         cch++, pTxtPtr->MoveChar( FALSE ) )
    {
        *pch++ = pTxtPtr->GetChar();
    }
    bookend.cchLeft = cch;

    // Look right, but make sure we start at text.
    pTxtPtr->SetCp( cpSave );

    if( pTxtPtr->GetChar() == WCH_NODE )
        pTxtPtr->MoveChar( TRUE );

    pch = bookend.achRight;
    for( cch = 0;
         long(pTxtPtr->_cp) < cchText - 1 && cch < NUM_ADJACENT_CHARS;
         cch++, pTxtPtr->MoveChar( TRUE ) )
    {
        *pch++ = pTxtPtr->GetChar();
    }
    bookend.cchRight = cch;
}

/*
 * Member: CTxtPtr::GetBookmark
 *
 * Synopsis: Gets a bookmark string represnting the positions of
 * this and pTxtPtrEnd, and fills *pbstrBookmark with the string.
 */
HRESULT CTxtPtr::GetBookmark(
    BSTR *pbstrBookmark,
    CTxtPtr *pTxtPtrEnd )
{
    HRESULT     hr      = S_OK;
    long        cchBookmark;
    TCHAR       achBookmark[ sizeof( Bookmark ) / sizeof( TCHAR ) + 1 ];
    Bookmark    bm;

    bm.chZero = 0;
    bm.chVersion = char(BOOKMARK_CURRENT_VERSION);
    bm.chDegenerate = pTxtPtrEnd->_cp == _cp;

    // Left edge
    bm.left.cp = _cp;
    SetCp( 1 );
    CountNasties( this, bm.left.cp, bm.left.nastyCounts );
    Assert( long(_cp) == bm.left.cp );

    ComputeAdjacent( this, bm.left );

    // Right edge
    if( !bm.chDegenerate )
    {
        bm.right.cp = pTxtPtrEnd->_cp;
        pTxtPtrEnd->SetCp( bm.left.cp );

        CountNasties( pTxtPtrEnd, bm.right.cp, bm.right.nastyCounts );
        Assert( long(pTxtPtrEnd->_cp) == bm.right.cp );
        ComputeAdjacent( pTxtPtrEnd, bm.right );
    }

    //
    // Garble the bookmark.
    //
    cchBookmark = sizeof( Bookmark );

    if (bm.chDegenerate)
        cchBookmark -= sizeof( BookEnd );

    memcpy( achBookmark, & bm, cchBookmark );

    cchBookmark /= sizeof( TCHAR );

    for ( ; ; )
    {
        BOOL fFoundZero = FALSE;

        for ( int i = 0 ; i < cchBookmark ; i++ )
            if (++achBookmark[i] == 0)
                fFoundZero = TRUE;

        if (!fFoundZero)
            break;
    }

    hr = THR( FormsAllocStringLen( achBookmark, cchBookmark, pbstrBookmark ) );

    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


/*
 * Member: CTxtPtr::IsPasswordChar
 *
 * Synopsis: Find out if _cp has the char format to indicate
 * that it is a password character. Used to bypass cluster movement
 * for cluster type text
 */
BOOL CTxtPtr::IsPasswordChar()
{
    long        ich;
    CTreePos *  ptp = _pMarkup->TreePosAtCp( _cp, &ich );

    if(ptp->IsText())
        return ptp->GetBranch()->GetCharFormat()->_fPassword;
    else
        return FALSE;
}


BOOL CTxtPtr::IsAtWordBreak()
{
    TCHAR   chBefore = WCH_NODE, chAfter = WCH_NODE;
    long    cchText = GetTextLength();
    long    cpSave = _cp;
    long    cpRight;

    // Find the next character
    while( long(_cp) < cchText - 1 &&
           ( chAfter = GetChar() ) == WCH_NODE      &&
           Classify( this, NULL ) == NODECLASS_NONE )
    {
        AdvanceCp( 1 );
    }

    // Interesting nodes are breaks, as is running off the end of the doc
    if( chAfter == WCH_NODE || long(_cp) >= cchText - 1 )
        return TRUE;

    cpRight = _cp;
    SetCp( cpSave - 1 );

    while( _cp > 1 &&
           ( chBefore = GetChar() ) == WCH_NODE     &&
           Classify( this, NULL ) == NODECLASS_NONE )
    {
        AdvanceCp( -1 );
    }

    // Interesting nodes are breaks, as is running off the end of the doc
    if( chBefore == WCH_NODE || long(_cp) <= 1 )
        return TRUE;

    // If we've got 2 Thai-type chars, we have to use the dictionary word moves
    if( NoWhiteBetweenWords(chBefore) && NoWhiteBetweenWords(chAfter) )
    {
        SetCp( cpRight );
        FindWordBreak( WB_MOVEWORDRIGHT, FALSE );
        FindWordBreak( WB_MOVEWORDLEFT, FALSE );
        return( long(_cp) == cpRight );
    }

    // Otherwise, check the table
    return IsWordBreakBoundaryDefault( chBefore, chAfter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\txtdefs.h ===
#ifndef I_TXTDEFS_H_
#define I_TXTDEFS_H_
#pragma INCMSG("--- Beg 'txtdefs.h'")

#ifndef X_UNIPROP_H_
#define X_UNIPROP_H_
#include "uniprop.h"
#endif

#define SYS_ALTERNATE		0x20000000
#define SYS_PREVKEYSTATE	0x40000000

#ifdef UNICODE
#define CbOfCch(_x) (DWORD)((_x) * sizeof(WCHAR))
#define CchOfCb(_x) (DWORD)((_x) / sizeof(WCHAR))
#else
#define CbOfCch(_x) (_x)
#define CchOfCb(_x) (_x)
#endif

// Logical unit definition
#define LX_PER_INCH 1440
#define LY_PER_INCH 1440

// Use explicit ASCII values for LF and CR, since MAC compilers
// interchange values of '\r' and '\n'
#define LF          10
#define CR          13
#define FF          TEXT('\f')
#define TAB         TEXT('\t')
#define VT          TEXT('\v')
#define PS          0x2029

inline BOOL IsASCIIEOP(TCHAR ch)
{
    return InRange( ch, LF, CR );
}

    //
    // This builds an HGLOBAL from a unicode html string
    //

HRESULT HtmlStringToSignaturedHGlobal (
    HGLOBAL * phglobal, const TCHAR * pStr, long cch );

HGLOBAL DuplicateHGlobal   (HGLOBAL hglobal);
HGLOBAL TextHGlobalAtoW    (HGLOBAL hglobal);
HGLOBAL TextHGlobalWtoA    (HGLOBAL hglobal);
INT     CountMatchingBits  (const DWORD *a, const DWORD *b, INT total);

//
// Unicode support
//

typedef BYTE CHAR_CLASS;
typedef BYTE SCRIPT_ID;
typedef BYTE DIRCLS;

// TODO (cthrash) Need to fix to reflect new partition table
// Selected Partition ids (used by FHangingPunct)
// Partitions are normally NOT named as they are used as transient index into the
// XXXXFromQPid arrays only. These 6 are an exception to avoid a largely redundant table.

#define qpidCommaN  18
#define qpidCommaH  19
#define qpidCommaW  20
#define qpidQuestN  32
#define qpidCenteredN   37
#define qpidPeriodN 41
#define qpidPeriodH 42
#define qpidPeriodW 43

extern const DIRCLS s_aDirClassFromCharClass[];
extern const UNIPROP s_aPropBitsFromCharClass[];

BOOL AreDifferentScriptIDs(SCRIPT_ID * psidFirst, SCRIPT_ID sidSecond);

inline DIRCLS
DirClassFromCh(WCHAR ch)
{
    return s_aDirClassFromCharClass[CharClassFromChSlow(ch)];
}

inline BOOL
IsGlyphableChar(WCHAR ch)
{
    // Temporary hack for Hangul Jamo range (Old Hangul characters)
    // They should by assigned to a different partition and have
    // similar properties to Surrogates
    if (InRange(ch, 0x1100, 0x11FF))
        return TRUE;
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fNeedsGlyphing;
}

inline BOOL
IsCombiningMark(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fCombiningMark;
}

inline BOOL
IsZeroWidthChar(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fZeroWidth;
}

inline BOOL
HasWhiteBetweenWords(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fWhiteBetweenWords;
}

inline BOOL 
NoWhiteBetweenWords(WCHAR ch)
{
    return !HasWhiteBetweenWords(ch);
}

inline BOOL
IsMoveByClusterChar(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fMoveByCluster;
}


inline BOOL IsBiDiDiacritic(WCHAR ch)
{
    return (InRange(ch, 0x0591, 0x06ED) && IsCombiningMark(ch));
}

#define WCH_CP1252_MIN WCHAR(0x0152)
#define WCH_CP1252_MAX WCHAR(0x2122)

BYTE InWindows1252ButNotInLatin1Helper(WCHAR ch);

inline BYTE InWindows1252ButNotInLatin1(WCHAR ch)
{
    return InRange(ch, WCH_CP1252_MIN, WCH_CP1252_MAX) ? InWindows1252ButNotInLatin1Helper(ch) : 0;
}
    
#pragma INCMSG("--- End 'txtdefs.h'")
#else
#pragma INCMSG("*** Dup 'txtdefs.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\txtparse.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       txtparse.cxx
//
//  Contents:   CHtmTextContext class
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  Function:   InPre
//
//  Synopsis:   This computes the pre status of a branch after an element goes
//              out of scope.  The branch before the element goes out of scope
//              is passed in, as well as the element going out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
InPre ( CTreeNode * pNodeCur, CTreeNode * pNodeEnd )
{
    CTreeNode *pNode;

    for ( pNode = pNodeCur ; pNode ; pNode = pNode->Parent() )
    {
        if (!pNodeEnd || DifferentScope( pNode, pNodeEnd ))
        {
            switch ( TagPreservationType( pNode->Tag()) )
            {
            case WSPT_PRESERVE : return pNode;
            case WSPT_COLLAPSE : return NULL;
            case WSPT_NEITHER  : break;
            default            : Assert( 0 );
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\txtelems.cxx ===
//+---------------------------------------------------------------------
//
//   File:      txtelems.cxx
//
//  Contents:   Element class
//
//  Classes:    CElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_TXTELEMS_HXX_
#define X_TXTELEMS_HXX_
#include "txtelems.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#define _cxx_
#include "textelem.hdl"

MtDefine(CTextElement, Elements, "CTextElement")

const CElement::CLASSDESC CTextElement::s_classdesc =
{
    {
        &CLSID_HTMLTextElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLTextElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLTextElement,         // _pfnTearOff

    NULL                                    // _pAccelsRun
};


HRESULT CTextElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CTextElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\uuid.cxx ===
/*  
 *  UUID.C
 *
 *  Purpose:
 *      provide definitions for locally used GUID's
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#undef DEFINE_GUID
#undef DEFINE_OLEGUID

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const IID name \
        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

// REMARK: presumably TOM should have official MS GUIDs
// To make pre-compiled headers work better, we just copy the
// guid definitions here.  Make sure they don't change!

DEFINE_GUID(LIBID_TOM,          0x8CC497C9, 0xA1DF,0x11ce,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextDocument,  0x8CC497C0, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextSelection, 0x8CC497C1, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextRange,     0x8CC497C2, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextFont,      0x8CC497C3, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextPara,      0x8CC497C4, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\txtsite.cxx ===
//+---------------------------------------------------------------------
//
//   File:      txtsite.cxx
//
//  Contents:   Text site class
//
//  Classes:    CTxtSite
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__IME_H_
#define X__IME_H_
#include "_ime.h"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_DOCPRINT_HXX_
#define X_DOCPRINT_HXX_
#include "docprint.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#define _cxx_
#include "txtedit.hdl"

DeclareTag(tagPaginate, "Print", "Pagination output");

// force functions to load through dynamic wrappers
#ifndef X_COMCTRLP_H_
#define X_COMCTRLP_H_
#ifdef WINCOMMCTRLAPI
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#endif
#include "comctrlp.h"
#endif

ExternTag(tagMsoCommandTarget);
ExternTag(tagFormatCaches);
ExternTag(tagLayout);

MtDefine(CTxtSite, Elements, "CTxtSite")
MtDefine(CTxtSite_pDropTargetSelInfo, CTxtSite, "CTxtSite::_pDropTargetSelInfo")
MtDefine(CTxtSiteScrollRangeIntoView_aryRects_pv, Locals, "CTxtSite::ScrollRangeIntoView aryRects::_pv")
MtDefine(CTxtSiteBranchFromPointEx_aryRects_pv, Locals, "CTxtSite::SiteBranchFromPointEx aryRects::_pv")
MtDefine(CTxtSiteDrop_arySites_pv, Locals, "CTxtSite::Drop arySites::_pv")
MtDefine(CTxtSiteGetChildElementTopLeft_aryRects_pv, Locals, "CTxtSite::GetChildElementTopLeft aryRects::_pv")
MtDefine(CTxtSitePaginate_aryValues_pv, Locals, "CTxtSite::Paginate aryValues::_pv")


#if DBG==1
extern void TestMarkupServices(CElement *);
#endif

// Commented out the following 4 lines because unused due to #ifdef NEVER in code:
// #pragma BEGIN_CODESPACE_DATA
// TCHAR szCRLF[]  = TEXT("\r\n");
// TCHAR szCR[]    = TEXT("\r");
// #pragma END_CODESPACE_DATA

WORD  ConvVKey (WORD vKey);
WORD        wConvScroll(WORD wparam);


#ifdef NEVER
// not used
#ifndef NO_PROPERTY_PAGE
const CLSID * const CTxtSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE
#endif // NEVER

CElement::ACCELS CTxtSite::s_AccelsTxtSiteRun    = CElement::ACCELS (&CElement::s_AccelsElementRun,    IDR_ACCELS_TXTSITE_RUN);

//+------------------------------------------------------------------------
//
//  Member:     CTxtSite, ~CTxtSite
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CTxtSite::CTxtSite (ELEMENT_TAG etag, CDoc *pDoc)
  : super(etag, pDoc)
{
    _fOwnsRuns = TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTxtSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTxtSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT     hr;

    *ppv = NULL;

    if (iid == CLSID_CTextSite)
    {
        *ppv = this;        // weak ref.
        return S_OK;
    }
    else if IID_TEAROFF(this, IHTMLTextContainer, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return hr;
}


/*
 *  CTxtSite::Init ()
 *
 *  @mfunc
 *      Initializes this CTxtSite. Called by CreateTextServices()
 */

#ifndef X_TXTELEMS_HXX_
#define X_TXTELEMS_HXX_
#include "txtelems.hxx"
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CTxtSite::Detach
//
//--------------------------------------------------------------------------


BOOL PointInRectAry(POINT pt, CStackDataAry<RECT, 1> &aryRects)
{
    for (int i = 0; i < aryRects.Size(); i++)
    {
        RECT rc = aryRects[i];
        if (PtInRect(&rc, pt))
            return TRUE;
    }
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     wConvScroll
//
//  Synopsis:   Interchange horizontal and vertical commands for vertical
//              text site.
//
//-------------------------------------------------------------------------

//
WORD wConvScroll(WORD wparam)
{
    switch(wparam)
    {
        case SB_BOTTOM:
            return SB_TOP;

        case SB_LINEDOWN:
            return SB_LINEUP;

        case SB_LINEUP:
            return SB_LINEDOWN;

        case SB_PAGEDOWN:
            return SB_PAGEUP;

        case SB_PAGEUP:
            return SB_PAGEDOWN;

        case SB_TOP:
            return SB_BOTTOM;

        default:
            return wparam;
    }
}


WORD ConvVKey (WORD vKey)
{
    switch(vKey)
    {
        case VK_LEFT:
            return VK_DOWN;

        case VK_RIGHT:
            return VK_UP;

        case VK_UP:
            return VK_LEFT;

        case VK_DOWN:
            return VK_RIGHT;

        default:
            return vKey;
    }
}

//+------------------------------------------------------------------
//
//  Members: [get/put]_scroll[top/left] and get_scroll[height/width]
//
//  Synopsis : IHTMLTextContainer members. _dp is in pixels.
//
//------------------------------------------------------------------

HRESULT
CTxtSite::get_scrollHeight(long *plValue)
{
    RRETURN(super::get_scrollHeight(plValue));
}

HRESULT
CTxtSite::get_scrollWidth(long *plValue)
{
    RRETURN(super::get_scrollWidth(plValue));
}

HRESULT
CTxtSite::get_scrollTop(long *plValue)
{
    RRETURN(super::get_scrollTop(plValue));
}

HRESULT
CTxtSite::get_scrollLeft(long *plValue)
{
    RRETURN(super::get_scrollLeft(plValue));
}

HRESULT
CTxtSite::put_scrollTop(long lPixels)
{
    RRETURN(super::put_scrollTop(lPixels));
}


HRESULT
CTxtSite::put_scrollLeft(long lPixels)
{
    RRETURN(super::put_scrollLeft(lPixels));
}


//+-----------------------------------------------------------------
//
//  member [put_|get_]onscroll
//
//  synopsis - just delegate to CElement. these are here because this
//      property migrated from here to elemetn.
//+-----------------------------------------------------------------
STDMETHODIMP
CTxtSite::put_onscroll(VARIANT v)
{
    RRETURN(super::put_onscroll(v));
}
STDMETHODIMP
CTxtSite::get_onscroll(VARIANT * p)
{
    RRETURN(super::get_onscroll(p));
}

//+-------------------------------------------------------------------------------
//
//  Member:     createControlRange
//
//  Synopsis:   Implementation of the automation interface method.
//              This creates a default structure range (CAutoTxtSiteRange) and
//              passes it back.
//
//+-------------------------------------------------------------------------------
HRESULT
CTxtSite::createControlRange(IDispatch ** ppDisp)
{
    RRETURN(SetErrorInfo(THR(CElement::createControlRange(ppDisp))));
}

//////////////////////////////  Line Dump  ///////////////////////////////////////

#if DBG == 1 || defined(DUMPTREE)


// Use this inside asserts checking to see that the document is inplace.
// This code is DBG==1 only, so if you obviously can't use it anywhere
// in the ship build.  The key here is the CPrintDoc's lie.


// Made this static so I would not have to declare FILE in _edit.h
HANDLE g_f;

void WriteFileAnsi (
    HANDLE hFile, LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite )
{
    char buffer [ 1024 ];
    long _cchLen;
    DWORD nbw;

    _cchLen = WideCharToMultiByte(
        CP_ACP, 0, LPWSTR( lpBuffer ), nNumberOfBytesToWrite,
        buffer, ARRAY_SIZE(buffer), NULL, NULL );

    WriteFile( hFile, buffer, _cchLen, & nbw, NULL );
}

void WriteString ( HANDLE hFile, TCHAR * pszStr )
{
    WriteFileAnsi( hFile, pszStr, _tcslen(pszStr) );
}

void WriteChar ( HANDLE hFile, TCHAR ch, int nRepeat )
{
    Assert( nRepeat >= 0 );

    while (nRepeat--)
        WriteFileAnsi( hFile, & ch, 1 );
}

void __cdecl WriteHelp ( HANDLE hFile, TCHAR * format, ... )
{
    va_list arg;

    va_start( arg, format );

    WriteHelpV( hFile, format, &arg );
}

void WriteHelpV( HANDLE hFile, TCHAR * format, va_list * parg )
{
    TCHAR achBuf [ 1024 ];

    VFormat( 0, achBuf, ARRAY_SIZE(achBuf), format, parg );

    WriteFileAnsi( hFile, achBuf, _tcslen(achBuf) );
}

void WriteFormattedString( HANDLE hFile, TCHAR * pch, long cch )
{
    if (!pch)
        return;

    for ( int i = 0 ; i < cch ; i++ )
    {
        TCHAR ch = pch[i];

        if (ch >= 1 && ch <= 26)
        {
            if (ch == _T('\r'))
                WriteString( hFile,  _T("\\r"));
            else if (ch == _T('\n'))
                WriteString( hFile, _T("\\n"));
            else
            {
                WriteHelp( hFile, _T("[<0d>]"), (long)int(ch) );
            }
        }
        else
        {
            switch ( ch )
            {
            case 0 :
                WriteString( hFile, _T("[NULL]"));
                break;

            case WCH_NODE:
                WriteString( hFile, _T("[Node]"));
                break;

            case WCH_NBSP :
                WriteString( hFile, _T("[NBSP]"));
                break;

            default :
                if (ch < 256 && _istprint(ch))
                {
                    WriteChar(hFile, ch);
                }
                else
                {
                    TCHAR achHex[9];

                    Format( 0, achHex, ARRAY_SIZE(achHex), _T("<0x>"), ch);

                    StrCpy( achHex, TEXT("[U+") );
                    StrCpy( achHex + 3, achHex + 4 );
                    StrCpy( achHex + 7, TEXT("]") );

                    WriteString( hFile, achHex );
                }

                break;
            }
        }
    }
}

BOOL InitDumpFile ( BOOL fOverwrite /* = FALSE */ )
{
    Assert( g_f == 0 );

    g_f = CreateFile(
#ifdef UNIX
            _T("tree.dump"),
#else
            fOverwrite ? _T("c:\\ff.txt") : _T("c:\\ee."),
#endif
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            fOverwrite ? CREATE_ALWAYS : OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (g_f == INVALID_HANDLE_VALUE)
    {
        g_f = 0;
        return FALSE;
    }

    SetFilePointer( g_f, GetFileSize( g_f, 0 ), 0, 0 );

    static int cDumps = 0;

    WriteHelp( g_f,
        _T("------------- Dump <0d> ------------------------------- \r\n\r\n" ),
        (long)cDumps++ );

    return TRUE;
}

void CloseDumpFile ( )
{
    CloseHandle( g_f );

    g_f = 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_dxfrobj.h ===
/*
 *  _DXFROBJ.H
 *
 *  Purpose:
 *      Class declaration for an OLE data transfer object (for use in
 *      drag drop and clipboard operations)
 *
 *  Author:
 *      alexgo (4/25/95)
 */

#ifndef I__DXFEROBJ_H_
#define I__DXFEROBJ_H_
#pragma INCMSG("--- Beg '_dxfrobj.h'")

class CFlowLayout;

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

/*
 *  CTextXBag
 *
 *  Purpose:
 *      holds a "snapshot" of some text data that can be used
 *      for drag drop or clipboard operations
 *
 *  Notes:
 *      TODO (alexgo): add in support for TOM<-->TOM optimized data
 *      transfers
 */

MtExtern(CTextXBag)

class CSelDragDropSrcInfo;

typedef enum tagDataObjectInfo
{
    DOI_NONE            = 0,
    DOI_CANUSETOM       = 1,    // TOM<-->TOM optimized data transfers
    DOI_CANPASTEPLAIN   = 2,    // plain text pasting available
    DOI_CANPASTERICH    = 4,    // rich text pasting available  (TODO: alexgo)
    DOI_CANPASTEOLE     = 8     // object may be pasted as an OLE embedding
                                // (note that this flag may be combined with
                                // others). (TODO: alexgo)
    //TODO (alexgo): more possibilites:  CANPASTELINK, CANPASTESTATICOLE
} DataObjectInfo;

typedef enum CREATE_FLAGS
{
    CREATE_FLAGS_NoIE4SelCompat = 0x00001,  // Disable IE 4 selection compat
    CREATE_FLAGS_ExternalMask   = 0x0FFFF,  // Mask of external flags
    CREATE_FLAGS_SupportsHtml   = 0x10000,  // Supports HTML
};

class CTextXBag : public CBaseBag
{
    typedef CBaseBag super;
public:

    STDMETHODIMP QueryInterface(REFIID iid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHOD(EnumFormatEtc)( DWORD dwDirection,
            IEnumFORMATETC **ppenumFormatEtc);
    STDMETHOD(GetData)( LPFORMATETC pformatetcIn, STGMEDIUM *pmedium );
    STDMETHOD(QueryGetData)( LPFORMATETC pformatetc );
    STDMETHOD(SetData) (LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease);

    static HRESULT  Create(CMarkup *             pMarkup,
                           DWORD                 dwFlags,
                           ISegmentList *        pSegmentList, 
                           BOOL                  fDragDrop,
                           CTextXBag **          ppTextXBag,
                           CSelDragDropSrcInfo * pSelDragDropSrcInfo = NULL);

    static HRESULT  GetDataObjectInfo(IDataObject *   pdo,      
                                      DWORD *         pDOIFlags);

    //
    // Others
    //

private:
    // NOTE: private cons/destructor, may not be allocated on the stack as
    // this would break OLE's current object liveness rules
    CTextXBag();
    virtual ~CTextXBag();

    HRESULT     SetKeyState();
    HRESULT     FillWithFormats(CMarkup *       pMarkup,
                                DWORD           dwFlags,
                                ISegmentList *  pSegmentList );

    HRESULT     SetTextHelper(CMarkup *     pMarkup,
                              ISegmentList *pSegmentList,
                              DWORD         dwSaveHtmlFlags,
                              CODEPAGE      cp,
                              DWORD         dwStmWrBuffFlags,
                              HGLOBAL *     phGlobalText,
                              int           iFETCIndex,
                              BOOL          fSetToNull = TRUE );

    HRESULT     SetText         (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );

    HRESULT     SetUnicodeText  (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );

    HRESULT     SetCFHTMLText   (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );

    HRESULT     SetLazyRTFText  (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );
                                 
    HRESULT     ConvertHTMLToRTF(HGLOBAL hHTMLText, 
                                 HGLOBAL *phRTFText);

    HRESULT     GetHTMLText    (HGLOBAL      *  phGlobal, 
                                ISegmentList *  pSegmentList,
                                CMarkup      *  pMarkup, 
                                DWORD           dwSaveHtmlMode,
                                CODEPAGE        codepage, 
                                DWORD           dwStrWrBuffFlags);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CTextXBag))

    long        _cFormatMax;    // maximum formats the array can store
    long        _cTotal;        // total number of formats in the array
    FORMATETC * _prgFormats;    // the array of supported formats
    CSelDragDropSrcInfo * _pSelDragDropSrcInfo;

public:
    HGLOBAL     _hText;             // handle to the ansi plain text
    HGLOBAL     _hUnicodeText;      // handle to the plain UNICODE text
    HGLOBAL     _hRTFText;          // handle to the RTF text
    HGLOBAL     _hCFHTMLText;       // handle to the CFHTML (in utf-8)

    CGenDataObject*  _pGenDO;          // Generic Data Transfer Object
    UINT        _fRtfConverted : 1; // RTF converted
};


//
//  Some globally useful FORMATETCs

extern FORMATETC g_rgFETC[];
extern const DWORD g_rgDOI[];
extern const int CFETC;

enum FETCINDEX                          // Keep in sync with g_rgFETC[]
{
    iHTML,                              // HTML (in ANSI)
    iRtfFETC,                           // RTF
    iUnicodeFETC,                       // Unicode plain text
    iAnsiFETC,                          // ANSI plain text
//    iFilename,                          // Filename
    iRtfAsTextFETC,                     // Pastes RTF as text
    iFileDescA,                         // FileGroupDescriptor
    iFileDescW,                         // FileGroupDescriptorW
    iFileContents,                      // FileContents
    iShellIdList,                       // Shell IDList Array
    iUniformResourceLocator             // UniformResourceLocator
//    iEmbObj,                            // Embedded Object
//    iEmbSrc,                            // Embed Source
//    iObtDesc,                           // Object Descriptor
//    iLnkSrc,                            // Link Source
//    iMfPict,                            // Metafile
//    iDIB,                               // DIB
//    iBitmap,                            // Bitmap
//    iRtfNoObjs,                         // RTF with no objects
//    iTxtObj,                            // Richedit Text
//    iRichEdit                           // RichEdit Text w/formatting
};

#define cf_HTML                     g_rgFETC[iHTML].cfFormat
//#define cf_RICHEDIT               g_rgFETC[iRichEdit].cfFormat
//#define cf_EMBEDDEDOBJECT         g_rgFETC[iEmbObj].cfFormat
//#define cf_EMBEDSOURCE            g_rgFETC[iEmbSrc].cfFormat
//#define cf_OBJECTDESCRIPTOR       g_rgFETC[iObtDesc].cfFormat
//#define cf_LINKSOURCE             g_rgFETC[iLnkSrc].cfFormat
#define cf_RTF                      g_rgFETC[iRtfFETC].cfFormat
//#define cf_RTFNOOBJS              g_rgFETC[iRtfNoObjs].cfFormat
//#define cf_TEXTOBJECT             g_rgFETC[iTxtObj].cfFormat
#define cf_RTFASTEXT                g_rgFETC[iRtfAsTextFETC].cfFormat
//#define cf_FILENAME               g_rgFETC[iFilename].cfFormat
#define cf_FILEDESCA                g_rgFETC[iFileDescA].cfFormat
#define cf_FILEDESCW                g_rgFETC[iFileDescW].cfFormat
#define cf_FILECONTENTS             g_rgFETC[iFileContents].cfFormat
#define cf_SHELLIDLIST              g_rgFETC[iShellIdList].cfFormat
#define cf_UNIFORMRESOURCELOCATOR   g_rgFETC[iUniformResourceLocator].cfFormat

#pragma INCMSG("--- End '_dxfrobj.h'")
#else
#pragma INCMSG("*** Dup '_dxfrobj.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_font.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _FONT.H -- Declaration of classes comprising font caching |
 *
 *  Purpose:
 *      Font cache
 *
 *  Owner: <nl>
 *      David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Jon Matousek <nl>
 *
 *  History: <nl>
 *      8/6/95      jonmat Devised dynamic expanding cache for widths.
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */

#ifndef I__FONT_H_
#define I__FONT_H_
#pragma INCMSG("--- Beg '_font.h'")

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_FONTINFO_HXX_
#define X_FONTINFO_HXX_
#include "fontinfo.hxx"
#endif

#ifndef X_FONTCACHE_HXX_
#define X_FONTCACHE_HXX_
#include "fontcache.hxx"
#endif

enum CONVERTMODE
{
    CM_UNINITED = -1,
    CM_NONE,            // Use Unicode (W) CharWidth/TextOut APIs
    CM_MULTIBYTE,       // Convert to MBCS using WCTMB and _wCodePage
    CM_SYMBOL,          // Use low byte of 16-bit chars (for SYMBOL_CHARSET
                        //  and when code page isn't installed)
    CM_FEONNONFE,       // FE on non-FE if on Win95
};

// Forwards
class CFontCache;
class CCcs;
class CBaseCcs;

extern const INT maxCacheSize[];

//----------------------------------------------------------------------------
// Font selection wrappers
//----------------------------------------------------------------------------
#if DBG==1
    #define FONTIDX HFONT
    #define HFONT_INVALID NULL
//    #define FONTIDX size_t
//    #define HFONT_INVALID 0

    HFONT   SelectFontEx(XHDC hdc, HFONT hfont);
    BOOL    DeleteFontEx(HFONT hfont);
#else
    #define FONTIDX HFONT
    #define HFONT_INVALID NULL

    inline  HFONT SelectFontEx(XHDC _hdc_, HFONT hfont) { return SelectFont(_hdc_.GetFontInfoDC(), hfont) ; }
    #define DeleteFontEx(hfont)         DeleteObject(hfont)
#endif
//----------------------------------------------------------------------------

BOOL GetCharWidthHelper(XHDC hdc, UINT c, LPINT piWidth);

//----------------------------------------------------------------------------
// CWidthCache - lightweight Unicode width cache
//
// We have a separate, optimized cache for the lowest 128
// characters.  This cache just has the width, and not the character
// since we know the cache is big enough to hold all the widths
// in that range.  For all the higher characters, we have caches with
// both the width and the character whose width is stored, since
// there could be collisions.
//----------------------------------------------------------------------------
#define FAST_WIDTH_CACHE_SIZE    128
// TOTALCACHES is the number of caches not counting the "fast" one.
#define TOTALCACHES         3

MtExtern(CWidthCache);
class CWidthCache
{
public:
    typedef LONG CharWidth;

    typedef struct {
        TCHAR   ch;
        CharWidth width;
    } CacheEntry;

    static BOOL  IsCharFast(TCHAR ch)       { return ch < FAST_WIDTH_CACHE_SIZE; }

    BOOL   FastWidthCacheExists() const     { return _pFastWidthCache != NULL; }

    // Doesn't check if this will work.  Just does it.
    CharWidth  BlindGetWidthFast(const TCHAR ch) const;

    BOOL    PopulateFastWidthCache(XHDC hdc, CBaseCcs* pBaseCcs, CDocInfo * pdci);  // Third param is HACK for Generic TextOnly Printer

    // Use this one if we run out of memory in GetEntry;
    CacheEntry ceLastResort;

    //@cmember  Called before GetWidth
    BOOL    CheckWidth ( const TCHAR ch, LONG &rlWidth );

    //@cmember  Fetch width if CheckWidth ret FALSE.
    BOOL    FillWidth ( XHDC hdc,
                        CBaseCcs * pBaseCcs,
                        const TCHAR ch,
                        LONG &rlWidth );

    void    SetCacheEntry( TCHAR ch, CharWidth width );

    //@cmember  Fetch the width.
    INT     GetWidth ( const TCHAR ch );

    //@cmember  Free dynamic mem.
    ~CWidthCache();

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CWidthCache))

private:
    void ThreadSafeCacheAlloc(void** ppCache, size_t iSize);
    CacheEntry * GetEntry(const TCHAR ch);

private:
    CharWidth  * _pFastWidthCache;
    CacheEntry * (_pWidthCache[TOTALCACHES]);

};

inline CWidthCache::CharWidth 
CWidthCache::BlindGetWidthFast(const TCHAR ch) const
{
    Assert(FastWidthCacheExists());
    Assert(IsCharFast(ch));
    return _pFastWidthCache[ch];
}

inline void
CWidthCache::SetCacheEntry(TCHAR ch, CharWidth width)
{
    if (!IsCharFast(ch))
    {
        CacheEntry* pce= GetEntry(ch);
        pce->ch= ch;
        pce->width= width;
    }
    else
    {
        Assert( _pFastWidthCache );
        _pFastWidthCache[ch]= width;
    }
}

inline int
CACHE_SWITCH(const TCHAR ch)
{
    if (ch < 0x4E00)
    {
        Assert( !CWidthCache::IsCharFast(ch) );
        return 0;
    }
    else if (ch < 0xAC00)
        return 1;
    else
        return 2;
}

inline CWidthCache::CacheEntry *
CWidthCache::GetEntry(const TCHAR ch)
{
    // Figure out which cache we're in.
    Assert( !IsCharFast(ch) );

    int i= CACHE_SWITCH( ch );
    Assert( i>=0 && i < TOTALCACHES );

    CacheEntry ** ppEntry = &_pWidthCache[i];

    if (!*ppEntry)
    {
        ThreadSafeCacheAlloc( (void **)ppEntry, sizeof(CacheEntry) * (maxCacheSize[i] + 1) );

        // Assert that maxCacheSize[i] is of the form 2^n-1
        Assert( ((maxCacheSize[i] + 1) & maxCacheSize[i]) == 0 );

        // Failed, need to return a pointer to something,
        // just to avoid crashing. Layout will look bad.
        if (!*ppEntry)
            return &ceLastResort;
    }

    // logical & is really a MOD, as all of the bits
    // of cacheSize are turned on; the value of cacheSize is
    // required to be of the form 2^n-1.
    return &(*ppEntry)[ ch & maxCacheSize[i] ];
}

//----------------------------------------------------------------------------
// class CBaseCcs
//----------------------------------------------------------------------------

// Win2k, NT and Win9x can not reliably return measurement info for fonts bigger then ~30K
// So we use smaller fonts and scale measurements. See CBaseCcs::GetFontWithMetrics()
const int MAX_SAFE_FONT_SIZE = 16000;

MtExtern(CBaseCcs);
class CBaseCcs
{
    friend class CFontCache;
    friend class CCcs;
    friend CWidthCache::FillWidth( XHDC hdc, class CBaseCcs *, const TCHAR, LONG & );
    friend CWidthCache::PopulateFastWidthCache( XHDC hdc, CBaseCcs *, CDocInfo * );

private:
    SCRIPT_CACHE _sc;           // handle for Uniscribe (USP.DLL) script cache
    CWidthCache  _widths;

    DWORD   _dwRefCount;        // ref. count
    DWORD   _dwAge;             // for LRU algorithm

    FONTIDX _hfont;             // Windows font index/handle

    BYTE    _bCrc;              // check sum for quick comparison with charformats
    BYTE    _bPitchAndFamily;   // For CBaseCcs::Compare; identical to _lf.lfPitchAndFamily except in PRC hack

    SHORT   _sAdjustFor95Hack;  // Compute discrepancy between GetCharWidthA and W once.

    BYTE    _fConvertNBSPsSet             : 1; // _fConvertNBSPs and _fConvertNBSPsIfA have been set
    BYTE    _fConvertNBSPs                : 1; // Font requires us to convert NBSPs to spaces
    BYTE    _fLatin1CoverageSuspicious    : 1; // font probably does not adequately cover Latin1
    BYTE    _fUnused                      : 6; //
    
public:
    BYTE    _fHasInterestingData          : 1; // TRUE if the font has something interesting (like monospaced, overhang etc)
    BYTE    _fTTFont                      : 1; // TRUE if TrueType font
    BYTE    _fFixPitchFont                : 1; // font with fix character width
    BYTE    _fFEFontOnNonFEWin95          : 1;

    BYTE    _fHeightAdjustedForFontlinking: 1;
    BYTE    _fPrinting                    : 1;
    BYTE    _fScalingRequired             : 1; // TRUE if font is big so we create smaller font
                                               // and use scaling to obtain measurements
                                               // (workaround for W2K, NT and W9x bug)

    LONG    _yCfHeight;     // Height of font in TWIPs.
    LONG    _yHeight;       // total height of the character cell in logical units.
    LONG    _yDescent;      // distance from baseline to bottom of character cell in logical units.
    LONG    _xAveCharWidth; // average character width in logical units.
    LONG    _xMaxCharWidth; // max character width in logical units.
    USHORT  _sCodePage;     // code page for font.
    SHORT   _xOverhangAdjust;// overhang for synthesized fonts in logical units.
    SHORT   _xOverhang;     // font's overhang.
    SHORT   _xUnderhang;    // font's underhang.
    SHORT   _sPitchAndFamily;    // For getting the right widths.
    BYTE    _bCharSet;
    BYTE    _bConvertMode;  // CONVERTMODE casted down to a byte
    LONG    _xDefDBCWidth;  // default width for DB Character
    SCRIPT_IDS _sids;       // Font script ids.  Cached value from CFontInfo.
    DWORD   _dwLangBits;    // For old-style fontlinking.  TODO (cthrash, IE5 bug 112152) retire this.

    // NOTE (paulpark): The LOGFONT structure includes a font name.  We keep _latmLFFaceName in sync with
    // this font name.  It always points into the atom table in the global font-cache to the same thing.
    // For this reason you must never directly change _latmLFFaceName or _lf.lfFaceName without changing
    // the other.  In fact you should just use the two mutator methods: SetLFFaceName and SetLFFaceNameAtm.
    LOGFONT _lf;                // the log font as returned from GetObject().
    LONG    _latmLFFaceName;    // For faster string-name comparisons.  The atom table is in the FontCache.
    LONG    _latmBaseFaceName;  // base facename -- for fontlinking
    LONG    _latmRealFaceName;  // What font did GDI actually give us when we selected it?  Aka, the "Rendering Font."
    LONG    _yOriginalHeight;   // pre-adjusted height -- for fontlinking

    float   _flScaleFactor;     // used if _fScalingRequired is TRUE

#if DBG == 1
    static LONG s_cTotalCccs;
    static LONG s_cMaxCccs;
#endif

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CBaseCcs))

    CBaseCcs ()
    {
        _hfont = HFONT_INVALID;
        _dwRefCount = 1;
#if DBG == 1
        s_cMaxCccs = max(s_cMaxCccs, ++s_cTotalCccs);
#endif
    }
    ~CBaseCcs ()
    {
        if (_hfont != HFONT_INVALID)
            DestroyFont();

        // make sure script cache is freed
        ReleaseScriptCache();

        WHEN_DBG(s_cTotalCccs--);

    }

    BOOL    Init(XHDC hdc, const CCharFormat * const pcf, CDocInfo * pdci, LONG latmBaseFaceName, BOOL fForceTTFont);
    void    AddRef()    { InterlockedIncrement((LONG *)&_dwRefCount); }
    void    Release()   { PrivateRelease(); }
    void    ReleaseScriptCache();

    typedef struct tagCompareArgs
    {
        CCharFormat * pcf;
        LONG lfHeight;
        LONG latmBaseFaceName;
        BOOL fTTFont;
    } CompareArgs;

    BOOL Compare( CompareArgs * pCompareArgs );
    BOOL CompareForFontLink( CompareArgs * pCompareArgs );

    void GetAscentDescent(LONG *pyAscent, LONG *pyDescent) const;
    CONVERTMODE GetConvertMode(BOOL fEnhancedMetafile, BOOL fMetafile) const;

    //
    // Width Cache Functions Exposed
    //
    BOOL    Include( XHDC hdc, TCHAR ch, LONG &rlWidth );  // Slow, reliable.
    // Assumes ascii.  No checking.  Will crash if > 128.
    BOOL    EnsureFastCacheExists(XHDC hdc, CDocInfo * pdci);   // HACK - Second parameter not needed.  Hack for Generic/TextOnly Printer

    // Mutators for _lf.szFaceName
    void SetLFFaceNameAtm(LONG latmFaceName);
    void SetLFFaceName(const TCHAR * szFaceName);
    void VerifyLFAtom();

    void EnsureLangBits(XHDC hdc);

    void FixupForFontLink(XHDC hdc, const CBaseCcs * const pBaseBaseCcs, BOOL fFEFont);

    BOOL    HasFont() const { return (_hfont != HFONT_INVALID); }
    FONTIDX PushFont(XHDC hdc);
    void    PopFont(XHDC hdc, FONTIDX hfontOld);

    BOOL    GetLogFont(LOGFONT * plf) const;

private:
    BOOL    MakeFont(XHDC hdc, const CCharFormat * const pcf, CDocInfo * pdci, BOOL fForceTTFont);
    void    DestroyFont();
    BOOL    GetTextMetrics(XHDC hdc, CODEPAGE codepage, LCID lcid);
    BOOL    GetFontWithMetrics(XHDC hdc, TCHAR* szNewFaceName, CODEPAGE codepage, LCID lcid);

    BOOL    FillWidths ( XHDC hdc, TCHAR ch, LONG &rlWidth );
    void    PrivateRelease();

    BOOL    NeedConvertNBSPs(XHDC hdc, CDoc *pDoc);  // Set _fConvertNBSPs/_fConvertNBSPsIfA flags
    BOOL    ConvertNBSPs(XHDC hdc, CDoc * pDoc);

#if DBG==1
    HFONT   GetHFont() const;
#else
    HFONT   GetHFont() const { return _hfont; }
#endif
};

inline void 
CBaseCcs::GetAscentDescent(LONG *pyAscent, LONG *pyDescent) const
{
    *pyAscent  = _yHeight - _yDescent;
    *pyDescent = _yDescent;
}

inline BOOL 
CBaseCcs::ConvertNBSPs(XHDC hdc, CDoc *pDoc)
{
    return ((_fConvertNBSPsSet || NeedConvertNBSPs(hdc, pDoc)) && _fConvertNBSPs);
}

inline BOOL 
CBaseCcs::EnsureFastCacheExists(XHDC hdc, CDocInfo * pdci)
{
    if (!_widths.FastWidthCacheExists())
    {
        _widths.PopulateFastWidthCache(hdc, this, pdci);
    }
    return _widths.FastWidthCacheExists();
}

#if DBG!=1
inline FONTIDX
CBaseCcs::PushFont(XHDC hdc)
{
    FONTIDX hfontOld = (HFONT)GetCurrentObject(hdc, OBJ_FONT);

    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr( this );
        SelectFontEx(hdc, _hfont);
    }
    
    return hfontOld;
}

inline void
CBaseCcs::PopFont(XHDC hdc, FONTIDX hfontOld)
{
    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr(NULL);
        SelectFontEx(hdc, hfontOld);
    }        
}
#endif

//----------------------------------------------------------------------------
// CCcs - caches font metrics and character size for one font
//----------------------------------------------------------------------------
MtExtern(CCcs);
class CCcs
{
    friend class CFontCache;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CCcs))

    CCcs()                              { _hdc = NULL; _pBaseCcs = NULL; _fForceTTFont = FALSE; }
    CCcs(const CCcs& ccs)               { memcpy(this, &ccs, sizeof(ccs)); }

    XHDC GetHDC()                       { return _hdc; }
    const CBaseCcs * GetBaseCcs() const { return _pBaseCcs; }
    BOOL GetForceTTFont() const         { return _fForceTTFont; }
    void SetForceTTFont(BOOL fTT)       { _fForceTTFont = !!fTT; }

    void Release();
    BOOL Include(TCHAR ch, LONG &rlWidth);
    void EnsureLangBits();
    BOOL ConvertNBSPs(XHDC hdc, CDoc *pDoc);
    SCRIPT_CACHE * GetUniscribeCache();
    void SetConvertMode(CONVERTMODE cm);
    void MergeSIDs(SCRIPT_IDS sids);
    void MergeLangBits(DWORD dwLangBits);

    FONTIDX PushFont(XHDC hdc);
    void    PopFont(XHDC hdc, FONTIDX hfontOld);

private:
    void SetHDC(XHDC hdc)               { _hdc = hdc; }
    void SetBaseCcs(CBaseCcs *pBaseCcs) { _pBaseCcs = pBaseCcs; }

private:
    XHDC       _hdc;
    CBaseCcs *_pBaseCcs;
    BYTE      _fForceTTFont : 1;
};

inline void 
CCcs::Release()
{
    if (_pBaseCcs)
    {
        _pBaseCcs->PrivateRelease(); 
        _pBaseCcs = NULL;
    }
}

inline BOOL 
CCcs::Include(TCHAR ch, LONG &rlWidth)
{
    Assert(_pBaseCcs);
    return _pBaseCcs->Include(_hdc, ch, rlWidth);
}

inline void 
CCcs::EnsureLangBits()
{
    Assert(_pBaseCcs);
    _pBaseCcs->EnsureLangBits(_hdc);
}

inline BOOL 
CCcs::ConvertNBSPs(XHDC hdc, CDoc *pDoc)
{
    Assert(_pBaseCcs);
    return _pBaseCcs->ConvertNBSPs(hdc, pDoc);
}

inline SCRIPT_CACHE * 
CCcs::GetUniscribeCache()
{
    Assert(_pBaseCcs);
    return &_pBaseCcs->_sc;
}

inline void 
CCcs::SetConvertMode(CONVERTMODE cm)
{
    Assert(_pBaseCcs);
    _pBaseCcs->_bConvertMode = cm;
}

inline void 
CCcs::MergeSIDs(SCRIPT_IDS sids)
{
    Assert(_pBaseCcs);
    _pBaseCcs->_sids |= sids;
}

inline void 
CCcs::MergeLangBits(DWORD dwLangBits)
{
    Assert(_pBaseCcs);
    _pBaseCcs->_dwLangBits |= dwLangBits;
}

inline FONTIDX 
CCcs::PushFont(XHDC hdc)
{
    Assert(_pBaseCcs);
    return _pBaseCcs->PushFont(hdc);
}

inline void 
CCcs::PopFont(XHDC hdc, FONTIDX hfontOld)
{
    Assert(_pBaseCcs);
    _pBaseCcs->PopFont(hdc, hfontOld);
}


// This function tries to get the width of this character,
// returning TRUE if it can.
// It's called "Include" just to confuse people.
// GetCharWidth would be a better name.
#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

inline
BOOL
CBaseCcs::Include ( XHDC hdc, TCHAR ch, LONG &rlWidth )
{
    if (_widths.IsCharFast(ch))
    {
        Assert(_widths.FastWidthCacheExists());
        // ASCII case -- really optimized.
        rlWidth= _widths.BlindGetWidthFast(ch);
        return TRUE;
    }
    else if (_widths.CheckWidth( ch, rlWidth ))
    {
        return TRUE;
    }
    else
    {
        return FillWidths( hdc, ch, rlWidth );
    }
}

/*
 *  CWidthCache::CheckWidth(ch, rlWidth)
 *
 *  @mfunc
 *      check to see if we have a width for a TCHAR character.
 *
 *  @comm
 *      Used prior to calling FillWidth(). Since FillWidth
 *      may require selecting the map mode and font in the HDC,
 *      checking here first saves time.
 *
 *  @rdesc
 *      returns TRUE if we have the width of the given TCHAR.
 *
 *  Note: This should not be called for ascii characters --
 *    a faster codepath should be taken.  This asserts against it.
 */
inline BOOL
CWidthCache::CheckWidth (
    const TCHAR ch,  //@parm char, can be Unicode, to check width for.
    LONG &rlWidth ) //@parm the width of the character
{
    Assert( !IsCharFast(ch) );

    CacheEntry widthData = *GetEntry ( ch );

    if( ch == widthData.ch )
    {
        rlWidth = widthData.width;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

inline void
CBaseCcs::VerifyLFAtom()
{
#if DBG==1
    const TCHAR * szFaceName = fc().GetFaceNameFromAtom(_latmLFFaceName);
        // If this assert fires that means somebody is directly modifying either _latmLFFaceName
        // or _lf.lffacename.  You should never modify these directly, but instead use the
        // SetLFFaceName or SetLFFaceNameAtm mutator methods, as these are sure to keep the
        // actual string and the atomized value in sync.
#ifdef UNIX
    Assert( !StrCmpC( _lf.lfFaceName, szFaceName ) );
#else
    Assert( !StrCmpIC( _lf.lfFaceName, szFaceName ) );
#endif
#endif
}

#if DBG != 1
#pragma optimize("", on)
#endif

#pragma INCMSG("--- End '_font.h'")
#else
#pragma INCMSG("*** Dup '_font.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\txtsaver.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       txtsaver.cpp
//
//  Contents:   Objects used for saving textedit object to stream
//
//  Classes:    CTextSaver
//              CRangeSaver
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif


DeclareTag(tagSaveShowSelection, "Save", "Save: Show CF_HTML selection");

MtDefine(CRangeSaver_local_aryElements_pv, Locals, "CRangeSaver local func aryElements::_pv")


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver constructor
//
//  Synopsis:   Set up a range saver object.
//
//----------------------------------------------------------------------------

CRangeSaver::CRangeSaver(
    CMarkupPointer *    pLeft,
    CMarkupPointer *    pRight,
    DWORD               dwFlags,
    CStreamWriteBuff *  pswb,
    CMarkup *           pMarkup,
    CElement *          pelContainer )
    : CTreeSaver( pMarkup )
{
    Initialize( pLeft, pRight, dwFlags, pswb, pMarkup, pelContainer );
}


void
CRangeSaver::Initialize(
    CMarkupPointer *    pLeft,
    CMarkupPointer *    pRight,
    DWORD               dwFlags,
    CStreamWriteBuff *  pswb,
    CMarkup *           pMarkup,
    CElement *          pelContainer )
{
    Assert( pLeft && pRight && pswb && pMarkup );
    Assert( pLeft->IsPositioned() && pRight->IsPositioned() );
    Assert( pLeft->Markup() == pMarkup );
    Assert( pRight->Markup() == pMarkup );

    IGNORE_HR( pMarkup->EmbedPointers () );

    // Set CTreeSaver data
    _pswb            = pswb;
    _pMarkup         = pMarkup;
    _pelContainer    = pelContainer;
    _fSymmetrical    = TRUE;

    Verify( ! _tpgStart.MoveTo( pLeft->GetEmbeddedTreePos(), TPG_RIGHT ) );
    _tpgStart.SetAttachPreference( TPG_RIGHT );
    Verify( ! _tpgStart.MoveRight( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    _fLBStartLeft = FALSE;
        
    Verify( ! _tpgEnd.MoveTo( pRight->GetEmbeddedTreePos(), TPG_RIGHT ) );
    _tpgEnd.SetAttachPreference( TPG_RIGHT );
    Verify( ! _tpgEnd.MoveRight( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    _fLBEndLeft = FALSE;    

    Assert( !_pelContainer 
        ||  (   _tpgStart.Branch()->SearchBranchToRootForScope( pelContainer )
            &&  _tpgEnd.Branch()->SearchBranchToRootForScope( pelContainer ) ) );

    // Set CRangeSaver data
    _dwFlags         = dwFlags;
    memset(&_header, 0, sizeof(_header));

    if( ! (_dwFlags & RSF_NO_IE4_COMPAT_SEL) )
    {
        DoIE4SelectionCollapse();
    }

    // Compute fragment element
    if( _dwFlags & RSF_NO_IE4_COMPAT_FRAG )
    {
        CTreeNode * pNodeLeft = _tpgStart.Branch();
        CTreeNode * pNodeRight = _tpgEnd.Branch();
        CTreeNode * pNodeCommon;

        pNodeCommon = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
        Assert( pNodeCommon );

        _pelFragment = pNodeCommon->Element();
    }
    else
    {
        ComputeIE4Fragment();
    }

    if(     !(_dwFlags & RSF_NO_IE4_COMPAT_SEL) 
        &&  _dwFlags & RSF_SELECTION )
    {
        ComputeIE4Selection();
    }
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::IE4CompatRangeContext
//
//  Synopsis:   Tries to figure out the same context element
//              that IE4 would have.
//
//----------------------------------------------------------------------------

CTreeNode *
CRangeSaver::IE4CompatRangeContext(CTreePos *ptpStart, CTreePos *ptpEnd)
{

    CTreeNode * pNodeReturn;
    CTreePos * ptpTry;
    CDoc     * pDoc = _pMarkup->Doc();
    CBodyElement *pBody;

    Assert(pDoc);

    pDoc->GetBodyElement(&pBody);

    Assert(pBody);

    //
    // Move our ptp's out to get to Node pos's
    //

    while( !ptpStart->IsNode() || !ptpStart->IsBeginNode() )
    {
        ptpStart = ptpStart->PreviousTreePos();
        Assert( ptpStart );
    }

    while( !ptpEnd->IsNode() || !ptpEnd->IsEndNode() )
    {
        ptpEnd = ptpEnd->NextTreePos();
        Assert( ptpEnd );
    }

    //
    // Move them out further to include nodes that influence us but not the adjacent run.
    //

    ptpTry = ptpStart;
    do
    {
        ptpStart = ptpTry;
        ptpTry = ptpStart->PreviousNonPtrTreePos();
        Assert( ptpTry );
    } while( ptpTry->IsNode() && ptpTry->IsBeginNode()
         && !pBody->GetFlowLayout()->IsElementBlockInContext( ptpTry->Branch()->Element() )
        );

    ptpTry = ptpEnd;
    do
    {
        ptpEnd = ptpTry;
        ptpTry = ptpEnd->NextNonPtrTreePos();
        Assert( ptpTry );
    } while( ptpTry->IsNode() && ptpTry->IsEndNode()
         && !pBody->GetFlowLayout()->IsElementBlockInContext( ptpTry->Branch()->Element() )
        );

    pNodeReturn= ptpStart->Branch()->GetFirstCommonAncestor( ptpEnd->Branch(), NULL );

    return pNodeReturn;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::SaveSelection
//
//  Synopsis:   Called by CTreeSaver::Save to signify where the selection
//              begins and ends
//
//----------------------------------------------------------------------------
HRESULT 
CRangeSaver::SaveSelection( BOOL fEnd )
{
    HRESULT hr = S_OK;

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        if (fEnd)
        {
            //
            // Record the offset for the selection end
            //
            hr = GetStmOffset(&_header.iSelectionEnd);
            if (hr)
                goto Cleanup;

#if DBG == 1
            if (IsTagEnabled(tagSaveShowSelection))
            {
                _pswb->Write(_T("[SELEND]"));
            }
#endif
        }
        else        
        {
            //
            // Record the offset for the selection beginning
            //
#if DBG == 1
            if (IsTagEnabled(tagSaveShowSelection))
            {
                _pswb->Write(_T("[SELSTART]"));
            }
#endif
            
            hr = GetStmOffset(&_header.iSelectionStart);
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::DoIE4SelectionCollapse
//
//  Synopsis:   Moves the gaps in to simulate the range that
//              IE4 started with when doing a range save
//
//----------------------------------------------------------------------------
void
CRangeSaver::DoIE4SelectionCollapse()
{
    // TODO (JBeda): handle a range with no content under it!

    // Move the start gap in until we hit real content
    _tpgStart.SetAttachPreference( TPG_RIGHT );

    while(  !(  _tpgStart.AttachedTreePos()->IsText() 
            &&  _tpgStart.AttachedTreePos()->Cch() ) )
    {
        // never cross container boundries
        if(     _tpgStart.AttachedTreePos()->IsNode()
            &&  _tpgStart.AttachedTreePos()->IsEdgeScope()
            &&  _tpgStart.AttachedTreePos()->Branch()->IsContainer() )
            break;

        // If we hit a LB char and we don't have it marked
        // on our left, break
        if(     !_fLBStartLeft 
            &&  LineBreakChar( &_tpgStart ) )
            break;

        _fLBStartLeft = FALSE;

        if( _tpgStart == _tpgEnd )
            break;

        Verify( ! _tpgStart.MoveRight() );
    }

    Verify( !_tpgStart.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    // Move the end gap in until we hit real content
    _tpgEnd.SetAttachPreference( TPG_LEFT );

    while(  !(  _tpgEnd.AttachedTreePos()->IsText() 
            &&  _tpgEnd.AttachedTreePos()->Cch() ) 
        &&  ! _fLBEndLeft )
    {
        // never cross container boundries
        if(     _tpgEnd.AttachedTreePos()->IsNode()
            &&  _tpgEnd.AttachedTreePos()->IsEdgeScope()
            &&  _tpgEnd.AttachedTreePos()->Branch()->IsContainer() )
            break;

        if( _tpgStart == _tpgEnd )
            break;

        Verify( ! _tpgEnd.MoveLeft() );

        if (LineBreakChar( &_tpgEnd ))
        {
            _fLBEndLeft = TRUE;
            break;
        }
    }

    Verify( !_tpgEnd.MoveRight( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::ComputeIE4Fragment
//
//  Synopsis:   Tries to figure out the same fragment element
//              that IE4 would have.
//
//----------------------------------------------------------------------------

void    
CRangeSaver::ComputeIE4Fragment()
{
    CTreeNode * pNodeLeft = _tpgStart.Branch();
    CTreeNode * pNodeRight = _tpgEnd.Branch();
    CTreePosGap tpgLeft, tpgRight;

    // Compute the first common element ancestor for the range
    pNodeLeft = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
    Assert( pNodeLeft );

    pNodeRight = pNodeRight->SearchBranchToRootForScope( pNodeLeft->Element() );
    Assert( pNodeRight );

    _pelFragment = pNodeRight->Element();

    // Include any phrase element which starts at this "run"
    while(  ! IsElementBlockInContainer( _pelFragment )
        &&  ! ScopesLeftOfStart( _pelFragment )
        &&  _pelFragment != _pelContainer )
    {
        // move to the next parent that covers the entire range
        pNodeLeft = pNodeLeft->Parent();
        pNodeRight = pNodeRight->Parent();

        pNodeLeft = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
        Assert( pNodeLeft );

        pNodeRight = pNodeRight->SearchBranchToRootForScope( pNodeLeft->Element() );
        Assert( pNodeRight );

        _pelFragment = pNodeRight->Element();
    }

    // If the fragment is selected completely, move up an element
    if (    ! ScopesLeftOfStart( _pelFragment )
        &&  ! ScopesRightOfEnd( _pelFragment )
        &&  !(  _pelFragment->HasFlowLayout()
            &&  _pelFragment->GetFlowLayout()->GetContentMarkup() == _pMarkup )
        &&  _pelFragment != _pelContainer 
        &&  ! _pelFragment->IsRoot() )
    {
        // move to the next parent that covers the entire range
        pNodeLeft = pNodeLeft->Parent();
        pNodeRight = pNodeRight->Parent();

        pNodeLeft = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
        Assert( pNodeLeft );

        pNodeRight = pNodeRight->SearchBranchToRootForScope( pNodeLeft->Element() );
        Assert( pNodeRight );

        _pelFragment = pNodeRight->Element();
    }

    Assert( _tpgStart.Branch()->SearchBranchToRootForScope( _pelFragment ) );
    Assert( _tpgEnd.Branch()->SearchBranchToRootForScope( _pelFragment ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::ComputeIE4Selection
//
//  Synopsis:   Tries to figure out the same selection
//              that IE4 would have.
//
//----------------------------------------------------------------------------
void    
CRangeSaver::ComputeIE4Selection()
{
    CTreePosGap tpgTemp( TPG_LEFT );
    BOOL        fLBLeft;
    CTreeNode * pNodeAbove;

    // Move the start gap in until we hit real content
    Verify( !tpgTemp.MoveTo( &_tpgStart ) );
    fLBLeft = _fLBStartLeft;

    pNodeAbove = tpgTemp.Branch();

    while(  !(  tpgTemp.AttachedTreePos()->IsText() 
            &&  tpgTemp.AttachedTreePos()->Cch() ) 
        &&  ! fLBLeft )
    {
        // Never cross container boundries
        if (    tpgTemp.AttachedTreePos()->IsNode()
            &&  tpgTemp.AttachedTreePos()->IsEdgeScope()
            &&  tpgTemp.AttachedTreePos()->Branch()->IsContainer() )
            break;

        if( tpgTemp.AttachedTreePos()->IsBeginElementScope()
           &&   pNodeAbove->SearchBranchToRootForScope(tpgTemp.Branch()->Element()) )
        {
            if (tpgTemp.AttachedTreePos()->Branch()->Element() == _pelFragment )
                break;

            Verify( ! _tpgStart.MoveTo( tpgTemp.AttachedTreePos(), TPG_LEFT ) );
            _fLBStartLeft = LineBreakChar( &_tpgStart );
        }

        Verify( ! tpgTemp.MoveLeft() );

        if (LineBreakChar( &tpgTemp ))
            fLBLeft = TRUE;
    }

    Verify( !_tpgStart.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    // Move the end gap in until we hit real content
    Verify( !tpgTemp.MoveTo( &_tpgEnd ) );
    fLBLeft = _fLBEndLeft;

    pNodeAbove = tpgTemp.Branch();

    tpgTemp.SetAttachPreference( TPG_RIGHT );

    while(  !(  tpgTemp.AttachedTreePos()->IsText() 
            &&  tpgTemp.AttachedTreePos()->Cch() ) )
    {
        // If we hit a LB char and we don't have it marked
        // on our left, break
        if (    !fLBLeft 
            &&  LineBreakChar( &tpgTemp ) )
            break;

        // Never cross container boundries
        if (    tpgTemp.AttachedTreePos()->IsNode()
            &&  tpgTemp.AttachedTreePos()->IsEdgeScope()
            &&  tpgTemp.AttachedTreePos()->Branch()->IsContainer() )
            break;

        if(     tpgTemp.AttachedTreePos()->IsEndElementScope() 
           &&   pNodeAbove->SearchBranchToRootForScope(tpgTemp.Branch()->Element()) )
        {
            if (tpgTemp.AttachedTreePos()->Branch()->Element() == _pelFragment )
                break;

            Verify( ! _tpgEnd.MoveTo( tpgTemp.AttachedTreePos(), TPG_RIGHT ) );
            _fLBEndLeft = FALSE;
        }

        fLBLeft = FALSE;
        Verify( ! tpgTemp.MoveRight() );
    }

    Verify( !_tpgEnd.MoveRight( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::GetStmOffset
//
//  Synopsis:   Returns the current offset in the output stream.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::GetStmOffset(LONG * plOffset)
{
    HRESULT        hr;
    ULARGE_INTEGER ulRet;
    LARGE_INTEGER  lSeekZero  = {0,0};

    hr = _pswb->Seek(lSeekZero, STREAM_SEEK_CUR, &ulRet);
    if (hr)
        goto Cleanup;

#ifdef UNIX
    *plOffset = U_QUAD_PART(ulRet);
#else
    *plOffset = ulRet.QuadPart;
#endif

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::SetStmOffset
//
//  Synopsis:   Sets the offset in the output stream.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::SetStmOffset(LONG lOffset)
{
    LARGE_INTEGER l;

#ifdef UNIX
    QUAD_PART(l) = lOffset;
#else
    l.QuadPart = lOffset;
#endif

    RRETURN(_pswb->Seek(l, STREAM_SEEK_SET, NULL));
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::Save
//
//  Synopsis:   Save the range to the stream _pswb.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::Save()
{
    HRESULT    hr = S_OK;
    if (_dwFlags & RSF_NO_ENTITIZE_UNKNOWN)
    {
        // Do not entitize unknown characters if asked not to
        _pswb->SetEntitizeUnknownChars(FALSE);
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        // The rtf converter requires pampered html
        _pswb->SetFlags(WBF_FOR_RTF_CONV);
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Write an empty cfhtml header.  We will go back later and fill
        // it out properly once we have the correct offsets.
        //
        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = GetStmOffset(&_header.iHTMLStart);
        if (hr)
            goto Cleanup;
    }

    //
    // Open up the context, starting with the doc header.
    //
    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        _pMarkup->WriteDocHeader(_pswb);

        hr = WriteOpenContext();
        if (hr)
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        //
        // Save any html header information needed for the rtf converter.
        // For now this is <HTML> and a charset <META> tag.
        //
        TCHAR achCharset[MAX_MIMECSET_NAME];

        if (GetMlangStringFromCodePage(_pswb->GetCodePage(), achCharset,
            ARRAY_SIZE(achCharset)) == S_OK)
        {
            DWORD dwOldFlags = _pswb->ClearFlags(WBF_ENTITYREF);

            _pswb->Write(_T("<HTML><META HTTP-EQUIV=\"content-type\" ")
                                 _T("CONTENT=\"text/html;charset="));
            _pswb->Write(achCharset);
            _pswb->Write(_T("\">"));
            _pswb->NewLine();

            _pswb->RestoreFlags(dwOldFlags);
        }
    }

    //
    // The real meat -- where we call the superclass.
    //
    if ( (_dwFlags & RSF_FRAGMENT) || (_dwFlags & RSF_SELECTION) )
    {

        //
        // Call the superclass to save the body 
        //
 
        hr = CTreeSaver::Save();
        if (hr)
            goto Cleanup;

    }

    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        hr = WriteCloseContext();
        if( hr )
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Save the current position as the end of html, and go back
        // to the beginning to write the header with the offsets we
        // now know.
        //
        hr = GetStmOffset(&_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(0);
        if (hr)
            goto Cleanup;

        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

    }

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::SaveSegmentList
//
//  Synopsis:   Save the range to the stream _pswb.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::SaveSegmentList(ISegmentList* pSegmentList, CMarkup* pMarkup)
{
    HRESULT                 hr = S_OK;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pSegment = NULL;

    
    if (_dwFlags & RSF_NO_ENTITIZE_UNKNOWN)
    {
        // Do not entitize unknown characters if asked not to
        _pswb->SetEntitizeUnknownChars(FALSE);
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        // The rtf converter requires pampered html
        _pswb->SetFlags(WBF_FOR_RTF_CONV);
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Write an empty cfhtml header.  We will go back later and fill
        // it out properly once we have the correct offsets.
        //
        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = GetStmOffset(&_header.iHTMLStart);
        if (hr)
            goto Cleanup;
    }

    //
    // Open up the context, starting with the doc header.
    //
    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        _pMarkup->WriteDocHeader(_pswb);

        hr = WriteOpenContext();
        if (hr)
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        //
        // Save any html header information needed for the rtf converter.
        // For now this is <HTML> and a charset <META> tag.
        //
        TCHAR achCharset[MAX_MIMECSET_NAME];

        if (GetMlangStringFromCodePage(_pswb->GetCodePage(), achCharset,
            ARRAY_SIZE(achCharset)) == S_OK)
        {
            DWORD dwOldFlags = _pswb->ClearFlags(WBF_ENTITYREF);

            _pswb->Write(_T("<HTML><META HTTP-EQUIV=\"content-type\" ")
                                 _T("CONTENT=\"text/html;charset="));
            _pswb->Write(achCharset);
            _pswb->Write(_T("\">"));
            _pswb->NewLine();

            _pswb->RestoreFlags(dwOldFlags);
        }
    }

    //
    // The real meat -- where we call the superclass.
    //
    if ( (_dwFlags & RSF_FRAGMENT) || (_dwFlags & RSF_SELECTION) )
    {

        //
        // Call the superclass to save the body 
        //
        CDoc                    *pDoc = pMarkup->Doc();
        CMarkupPointer          mpStart( pDoc );
        CMarkupPointer          mpEnd( pDoc );
        BOOL                    fFirst = TRUE;
        LONG                    iHTMLStart      = _header.iHTMLStart;
        LONG                    iFragmentStart  = _header.iFragmentStart;
        LONG                    iSelectionStart = _header.iSelectionStart;

        hr = THR( pSegmentList->CreateIterator( &pIter ) );
        if( hr )
            goto Cleanup;

        while( pIter->IsDone() == S_FALSE )
        {
            hr = THR( pIter->Current( &pSegment ) );
            if( hr )
                goto Cleanup;
                
            hr = THR( pSegment->GetPointers( &mpStart, &mpEnd) );        
            if( hr )
                goto Cleanup;

            Initialize(&mpStart, &mpEnd, _dwFlags, _pswb, mpStart.Markup(), NULL);

            hr = CTreeSaver::Save();
            if (hr)
                goto Cleanup;

            if( fFirst )
            {
                fFirst = FALSE;
                if( _header.iSelectionStart > iSelectionStart )
                {
                    iSelectionStart = _header.iSelectionStart;
                }
            }

            hr = THR( pIter->Advance() );
            if( hr )
                goto Cleanup;

            ClearInterface(&pSegment);
        }

        _header.iHTMLStart      = iHTMLStart;
        _header.iFragmentStart  = iFragmentStart;
        _header.iSelectionStart = iSelectionStart;
    }

    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        hr = WriteCloseContext();
        if( hr )
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Save the current position as the end of html, and go back
        // to the beginning to write the header with the offsets we
        // now know.
        //
        hr = GetStmOffset(&_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(0);
        if (hr)
            goto Cleanup;

        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

    }

Cleanup:

    ReleaseInterface(pIter);
    ReleaseInterface(pSegment);
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::WriteCFHTMLHeader
//
//  Synopsis:   Writes the CF-HTML header to _pswb.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::WriteCFHTMLHeader()
{
    HRESULT     hr;
    TCHAR *     pchOut = NULL;
    DWORD       dwOldFlags = _pswb->ClearFlags( WBF_ENTITYREF  );

    Assert(_dwFlags & RSF_CFHTML_HEADER);

    _pswb->SetFlags(WBF_NO_WRAP);

    static TCHAR szCfHtmlHeaderFormat[] =
        _T("Version:<0s>\r\n")
        _T("StartHTML:<1d9>\r\n")
        _T("EndHTML:<2d9>\r\n")
        _T("StartFragment:<3d9>\r\n")
        _T("EndFragment:<4d9>\r\n")
        _T("StartSelection:<5d9>\r\n")
        _T("EndSelection:<6d9>\r\n")
        _T("SourceURL:<7s>\r\n");

    Format(
        FMT_OUT_ALLOC,
        & pchOut, 512,
        szCfHtmlHeaderFormat,
        _T("1.0"),
        (long)_header.iHTMLStart, (long)_header.iHTMLEnd, (long)_header.iFragmentStart,
        (long)_header.iFragmentEnd, (long)_header.iSelectionStart, (long)_header.iSelectionEnd,
#if defined(UNIX) || defined(_MAC)
        (LPCTSTR)
#endif
        CMarkup::GetUrl(_pMarkup->GetWindowedMarkupContext()));

    
    // Do not let _pswb mess with forced cr/lfs in this string

    _pswb->BeginPre();

    hr = _pswb->Write(pchOut);
    
    if (hr)
        goto Cleanup;

    _pswb->EndPre();

Cleanup:
    delete [] pchOut;
    
    _pswb->RestoreFlags(dwOldFlags);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Members:    CRangeSaver::WriteOpenContext
//
//  Synopsis:   Writes out all tags that come into of scope between
//              _pelFragment and the root.
//
//----------------------------------------------------------------------------
HRESULT
CRangeSaver::WriteOpenContext()
{
    HRESULT hr = S_OK;
    CStackPtrAry<CElement *, 32> aryElements(Mt(CRangeSaver_local_aryElements_pv));
    CTreeNode * pNodeCur;

    // First find the context of _pelFragment that is above the start.
    pNodeCur = _tpgStart.Branch();
    Assert( pNodeCur );

    pNodeCur = pNodeCur->SearchBranchToRootForScope( _pelFragment );
    Assert( pNodeCur );

    // build an array of all of the elements that we want to write out
    for( ; pNodeCur ; pNodeCur = pNodeCur->Parent() )
    {
        aryElements.Append( pNodeCur->Element() );
    }

    // Write out our array of elements
    {
        CElement **ppElement;
        int        iElement;

        for( iElement = aryElements.Size(), ppElement = &(aryElements[iElement-1]);
             iElement > 0;
             iElement--, ppElement-- )
        {
            if (! *ppElement)
                continue;

            if( (*ppElement)->Tag() != ETAG_ROOT )
            {
                hr = THR( SaveElement( *ppElement, FALSE ) );
                if (hr)
                    goto Cleanup;
            }

            if (*ppElement == _pelFragment)
            {
                DWORD dwFlags = _pswb->ClearFlags(WBF_ENTITYREF);
        
                hr = _pswb->Write(_T("<!--StartFragment-->"));
                if( hr )
                    goto Cleanup;

                _pswb->RestoreFlags(dwFlags);

                hr = GetStmOffset(&_header.iFragmentStart);
                if (hr)
                    goto Cleanup;

                if (_header.iSelectionStart == 0)
                    _header.iSelectionStart = _header.iFragmentStart;
            }

            if ( (*ppElement)->Tag() == ETAG_HTML && (_dwFlags & RSF_CONTEXT) )
            {
                // Make sure not to save out elements we do not want in cfhtml,
                // such as meta charset tags and styles.
                CElement * pHead = _pMarkup->GetHeadElement();

                if( pHead )
                {
                    DWORD dwFlags = _pswb->SetFlags( WBF_NO_CHARSET_META | WBF_NO_OBJECTS );

                    hr = THR( pHead->Save(_pswb, FALSE) );
                    if (hr)
                        goto Cleanup;

                    CTreeSaver ts( pHead, _pswb );
                    hr = ts.Save();
                    if (hr)
                        goto Cleanup;

                    hr = THR( pHead->Save(_pswb, TRUE) );
                    if (hr)
                        goto Cleanup;

                    _pswb->RestoreFlags(dwFlags);

                    // There may be elements that start in the head and overlap
                    // over our current stack.  We don't want to write out the
                    // start for these elements twice so zero them out here
                    {
                        CTreePos * ptpCur;

                        pHead->GetTreeExtent( NULL, &ptpCur );
                        Assert( ptpCur );

                        ptpCur = ptpCur->NextTreePos();

                        while( ptpCur->IsBeginNode() && ! ptpCur->IsEdgeScope() )
                        {
                            int iIndex = aryElements.Find( ptpCur->Branch()->Element() );
                            if( iIndex != -1 )
                                aryElements[iIndex] = NULL;

                            ptpCur = ptpCur->NextTreePos();
                        }
                    } // no duplicates
                } // pHead
            } // ETAG_HTML

            if (*ppElement && *ppElement != _pelFragment)
            {
                hr = _pswb->NewLine();
                if (hr)
                    goto Cleanup;
            }

        } // for loop
    } // write out array

Cleanup:
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
//  Members:    CRangeSaver::WriteCloseContext
//
//  Synopsis:   Writes out all tags that go out of scope between
//              _pelFragment and the root.
//
//----------------------------------------------------------------------------
HRESULT
CRangeSaver::WriteCloseContext()
{
    HRESULT hr = S_OK;
    CTreeNode * pNodeCur;

    pNodeCur = _tpgEnd.Branch();
    Assert( pNodeCur );

    pNodeCur = pNodeCur->SearchBranchToRootForScope( _pelFragment );
    Assert( pNodeCur );

    // build an array of all of the elements that we want to write out
    for( ; pNodeCur; pNodeCur = pNodeCur->Parent() )
    {
        CElement * pElementCur = pNodeCur->Element();

        if( pElementCur == _pelFragment )
        {
            DWORD dwFlags = _pswb->ClearFlags(WBF_ENTITYREF);

            hr = GetStmOffset(&_header.iFragmentEnd);
            if (hr)
                goto Cleanup;

            if (_header.iSelectionEnd == 0)
                _header.iSelectionEnd = _header.iFragmentEnd;

            hr = _pswb->Write(_T("<!--EndFragment-->"));
            if (hr)
                goto Cleanup;

            _pswb->RestoreFlags(dwFlags);
        }

        if (pElementCur->Tag() != ETAG_ROOT)
        {
            hr = THR( SaveElement( pElementCur, TRUE ) );
            if (hr)
                goto Cleanup;

            hr = THR( ForceClose( pElementCur ) );
            if (hr)
                goto Cleanup;

            hr = _pswb->NewLine();
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\util.cxx ===
/*
 *  UTIL.C
 *
 *  Purpose:
 *      Implementation of various useful utility functions
 *
 *  Author:
 *      alexgo (4/25/95)
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx" // for cstrinw
#endif

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

/*
 *  DuplicateHGlobal
 *
 *  Purpose:
 *      duplicates the passed in hglobal
 */

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal )
{
    UINT    flags;
    DWORD   size;
    HGLOBAL hNew;
    BYTE *  pSrc;
    BYTE *  pDest;

    if( hglobal == NULL )
    {
        return NULL;
    }

    flags = GlobalFlags(hglobal);

    size = GlobalSize(hglobal);
    if (size == 0)
    {
    	return NULL;
    }

    hNew = GlobalAlloc(flags, size);

    if( hNew )
    {
        pDest = (BYTE *)GlobalLock(hNew);
        pSrc = (BYTE *)GlobalLock(hglobal);

        if( pDest == NULL || pSrc == NULL )
        {
            GlobalUnlock(hNew);
            GlobalUnlock(hglobal);
            GlobalFree(hNew);

            return NULL;
        }

        memcpy(pDest, pSrc, size);

        GlobalUnlock(hNew);
        GlobalUnlock(hglobal);
    }

    return hNew;
}

/*
 *  TextHGlobalAtoW (hglobalA)
 *
 *  Purpose:
 *      translates a unicode string contained in an hglobal and
 *      wraps the ansi version in another hglobal
 *
 *  Notes: 
 *      does *not* free the incoming hglobal
 */

HGLOBAL TextHGlobalAtoW( HGLOBAL hglobalA )
{
    LPSTR   pstr;
    HGLOBAL hnew = NULL;
    DWORD   cbSize;

    if( !hglobalA )
    {
        return NULL;
    }

    pstr = (LPSTR)GlobalLock(hglobalA);
    if (pstr == NULL)
    {
    	return NULL;
    }

    CStrInW  strinw(pstr);

    cbSize = (strinw.strlen() + 1) * sizeof(WCHAR);
    hnew = GlobalAlloc(GMEM_MOVEABLE, cbSize);

    if( hnew )
    {
        LPWSTR pwstr = (LPWSTR)GlobalLock(hnew);
        
        if( pwstr )
        {
            memcpy(pwstr, (WCHAR *)strinw, cbSize);
        
            GlobalUnlock(hnew);
        }
    }

    GlobalUnlock(hglobalA);
    
    return hnew;
}

/*
 *  TextHGlobalAtoW
 *
 *  Purpose:
 *      converts a unicode text hglobal into a newly allocated
 *      allocated hglobal with ANSI data
 *
 *  Notes:
 *      does *NOT* free the incoming hglobal 
 */
    
HGLOBAL TextHGlobalWtoA( HGLOBAL hglobalW )
{
    LPCWSTR  pwstr;
    HGLOBAL hnew = NULL;
    DWORD   cbSize;

    if( !hglobalW )
    {
        return NULL;
    }

    pwstr = (LPCWSTR)GlobalLock(hglobalW);
    if (pwstr == NULL)
    {
    	return NULL;
    }

    CStrIn  strin(pwstr);

    cbSize = (strin.strlen() + 1) * sizeof(CHAR);
    hnew = GlobalAlloc(GMEM_MOVEABLE, cbSize);

    if( hnew )
    {
        LPSTR pstr = (LPSTR)GlobalLock(hnew);
        
        if( pstr )
        {
            memcpy(pstr, (CHAR *)strin, cbSize);
        
            GlobalUnlock(hnew);
        }
    }

    GlobalUnlock(hglobalW);
    
    return hnew;
}   

/*
 *  CountMatchingBits ( const DWORD *a, const DWORD *b, INT total )
 *
 *  @mfunc
 *      Count matching bit fields.
 *  @comm
 *      This is used to help decide how good the match is between
 *      code page bit fields. Mainly for KB/font switching support.
 *  Author:
 *      Jon Matousek
 */
INT CountMatchingBits(const DWORD *a, const DWORD *b, INT total)
{
    static INT  bitCount[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };
    INT         i, c, matchBits;

    c = 0;
    for (i = 0; i < total; i++ )
    {
        //matchBits = ~(*a++ ^ *b++);   // 1 and 0's
        matchBits = *a++ & *b++;        // 1 only.
        c += bitCount [ (matchBits >> 0)    & 15];
        c += bitCount [ (matchBits >> 4)    & 15];
        c += bitCount [ (matchBits >> 8)    & 15];
        c += bitCount [ (matchBits >> 12)   & 15];
        c += bitCount [ (matchBits >> 16)   & 15];
        c += bitCount [ (matchBits >> 20)   & 15];
        c += bitCount [ (matchBits >> 24)   & 15];
        c += bitCount [ (matchBits >> 28)   & 15];
    }

    return c;
}

//+----------------------------------------------------------------------------
//
//  Function:   HtmlStringToHGlobal
//
//  Synopsis:   Build an HGLOBAL from a unicode html string.  Specifivally, it
//              places the correct signature at the beginning of the HGLOBAL so
//              paste code knows what it is.
//
//-----------------------------------------------------------------------------

HRESULT
HtmlStringToSignaturedHGlobal (
    HGLOBAL * phglobal, const TCHAR * pStr, long cch )
{
    HRESULT hr = S_OK;
    char *  pStrHtmlText = NULL;
    long    cbStr;
    long    lGlobalSize;
    DWORD   lHGSize;

    Assert( cch >= -1 );
    Assert( phglobal );

    //
    // Allocate enough for the string, unicode signature and zero terminator
    //
    
    cbStr = (cch < 0 ? _tcslen( pStr ) : cch) * sizeof( TCHAR );
    
    lGlobalSize = cbStr + sizeof( WCHAR ) + sizeof( TCHAR );

    *phglobal = GlobalAlloc( GMEM_MOVEABLE, lGlobalSize );
    if (!*phglobal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    lHGSize = GlobalSize(*phglobal);
    if (lHGSize == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pStrHtmlText = (char *) GlobalLock( *phglobal );
    if (!pStrHtmlText)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    //
    // Put the unicaode signature at the beginning, followed by the raw string,
    // a zero terminator and then finally followed by any zeros needed to fill
    // in the rest of the hglobal (if we got one bigger than we asked for).
    //

    * (WCHAR *) pStrHtmlText = NATIVE_UNICODE_SIGNATURE;
    
    memcpy( pStrHtmlText + sizeof( WCHAR ), pStr, cbStr );
    
    memset(
        pStrHtmlText + cbStr + sizeof( WCHAR ),
        0, lHGSize - cbStr - sizeof( WCHAR ) );

    GlobalUnlock(*phglobal);

Cleanup:

    RRETURN( hr );
    
Error:

    if (*phglobal)
        GlobalFree( *phglobal );
    
    *phglobal = 0;

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_disp.h ===
/*
 *  _DISP.H
 *
 *  Purpose:
 *      DISP class
 *
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#ifndef I_DISP_H_
#define I_DISP_H_
#pragma INCMSG("--- Beg '_disp.h'")

#ifndef X__LINE_H_
#define X__LINE_H_
#include "_line.h"
#endif

ExternTag(tagDebugRTL);

class CFlowLayout;
class CBgRecalcInfo;

class CDispNode;
class CLed;
class CLineFull;
class CLineCore;
class CLineOtherInfo;
class CLinePtr;
class CMeasurer;
class CLSMeasurer;
class CTxtSite;
class CRecalcLinePtr;
class CRecalcTask;
class CLSRenderer;
class CNotification;
class COneRun;

class CShape;
class CWigglyShape;
enum NAVIGATE_DIRECTION;

class CDrawInfoRE;
class CSelection;

// Helper
long ComputeLineShift(htmlAlign  atAlign,
                      BOOL       fRTLDisplay,
                      BOOL       fRTLLine,
                      BOOL       fMinMax,
                      long       xWidthMax,
                      long       xWidth,
                      UINT *     puJustified,
                      long *     pdxRemainder = NULL);

// ============================  CLed  ====================================
// Line Edit Descriptor - describes impact of an edit on line breaks

MtExtern(CLed);
MtExtern(CRelDispNodeCache);

class CLed
{
public:
    LONG _cpFirst;          // cp of first affected line
    LONG _iliFirst;         // index of first affected line
    LONG _yFirst;           // y offset of first affected line

    LONG _cpMatchOld;       // pre-edit cp of first matched line
    LONG _iliMatchOld;      // pre-edit index of first matched line
    LONG _yMatchOld;        // pre-edit y offset of first matched line

    LONG _cpMatchNew;       // post-edit cp of first matched line
    LONG _iliMatchNew;      // post-edit index of first matched line
    LONG _yMatchNew;        // post-edit y offset of bottom of first matched line

    LONG _yExtentAdjust;    // the pixel amount by which any line in the changed lines
                            // draws outside its line height
public:
    CLed();

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CLed))

    VOID    SetNoMatch();
};

class CAlignedLine
{
public:
    CLineCore * _pLine;
    LONG    _yLine;
};

class CRelDispNode
{
public:

    CRelDispNode() 
    { 
        _pElement = NULL;
        _pDispNode = NULL;
    };

    ~CRelDispNode() 
        {  ClearContents();  };

    // Helper Functions
    //----------------------------

    void ClearContents ()
    {
        if (_pElement)
        {
            _pElement->SubRelease();
            _pElement = NULL;
        }

        if (_pDispNode)
        {
            DestroyDispNode();
        }
    }

    void DestroyDispNode();
    
    CElement * GetElement () { return _pElement; }

    void SetElement( CElement * pNewElement )
    {
        if (_pElement)
            _pElement->SubRelease();

        _pElement = pNewElement;

        if (_pElement)
            _pElement->SubAddRef();
    }

    // Data Members 
    //----------------------------
    long        _ili;
    long        _yli;
    long        _cLines;
    CPoint      _ptOffset;
    LONG        _xAnchor;   // x-coordinate for anchoring children disp nodes
    CDispNode * _pDispNode;

private:
    CElement  * _pElement;
};

class CRelDispNodeCache : public CDispClient
{
public:

    CRelDispNodeCache(CDisplay * pdp) : _aryRelDispNodes(Mt(CRelDispNodeCache))
    {
        _pdp = pdp;
    }

    virtual void            GetOwner(
                                CDispNode const* pDispNode,
                                void ** ppv);

    virtual void            DrawClient(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *cookie,
                                void *pClientData,
                                DWORD dwFlags);

    virtual void            DrawClientBackground(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags);

    virtual void            DrawClientBorder(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

    virtual void            DrawClientScrollbar(
                                int whichScrollbar,
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                LONG contentSize,
                                LONG containerSize,
                                LONG scrollAmount,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

    virtual void            DrawClientScrollbarFiller(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

    virtual BOOL            HitTestContent(
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData,
                                BOOL fDeclinedByPeer);

    virtual BOOL            HitTestFuzzy(
                                const POINT *pptHitInParentCoords,
                                CDispNode *pDispNode,
                                void *pClientData);

    virtual BOOL            HitTestScrollbar(
                                int whichScrollbar,
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData)
    {
        return FALSE;
    }

    virtual BOOL            HitTestScrollbarFiller(
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData)
    {
        return FALSE;
    }

    virtual BOOL            HitTestBorder(
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData)
    {
        return FALSE;
    }

    virtual BOOL            ProcessDisplayTreeTraversal(
                                void *pClientData)
    {
        return TRUE;
    }
                                          
    
    // called only for z ordered items
    virtual LONG            GetZOrderForSelf(CDispNode const* pDispNode);

    virtual LONG            CompareZOrder(
                                CDispNode const* pDispNode1,
                                CDispNode const* pDispNode2);

    virtual BOOL            ReparentedZOrder()
    {
        return FALSE;
    }
    
    virtual void            HandleViewChange(
                                DWORD          flags,
                                const RECT *   prcClient,
                                const RECT *   prcClip,
                                CDispNode *    pDispNode)
    {
    }


    // provide opportunity for client to fire_onscroll event
    virtual void            NotifyScrollEvent(
                                RECT *  prcScroll,
                                SIZE *  psizeScrollDelta)
    {
    }

    virtual DWORD           GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
    {
        return 0;
    }

    virtual void            DrawClientLayers(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *cookie,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

#if DBG==1
    virtual void            DumpDebugInfo(
                                HANDLE hFile,
                                long level,
                                long childNumber,
                                CDispNode const* pDispNode,
                                void* cookie) {}
#endif
    CRelDispNode *  operator [] (long i) { return &_aryRelDispNodes[i]; }
    long            Size()               { return _aryRelDispNodes.Size(); }
    void            DestroyDispNodes();
    CDispNode *     FindElementDispNode(CElement * pElement);
    void            SetElementDispNode(CElement * pElement, CDispNode * pDispNode);
    void            EnsureDispNodeVisibility(CElement * pElement = NULL);
    void            HandleDisplayChange();
    void            Delete(long iPosFrom, long iPosTo);

    // To handle invalidate notifications on relative elements:
    // See CFlowLayout::Notify() handling of invalidation.
    void            Invalidate( CElement *pElement, const RECT * prc = NULL, int nRects = 1 );

    void InsertAt(long iPos, CRelDispNode & rdn)
    {
        _aryRelDispNodes.InsertIndirect(iPos, &rdn);
    }
    CDisplay    * GetDisplay() const { return _pdp; }

    virtual BOOL            GetAnchorPoint(CDispNode*, CPoint*);

private:
    CDataAry <CRelDispNode> _aryRelDispNodes;
    CDisplay *              _pdp;
};

inline CLed::CLed()
{
}

typedef enum
{
    FNFL_NONE = 0x0,
    FNFL_STOPATGLYPH = 0x1,
} FNFL_FLAGS;

// ==========================  CDisplay  ====================================
// display - keeps track of line breaks for a device
// all measurements are in pixels on rendering device,
// EXCEPT xWidthMax and yHeightMax which are in twips

MtExtern(CDisplay)
;

class CDisplay : public CLineArray
{
    friend class CFlowLayout;
    friend class CLinePtr;
    friend class CLed;
    friend class CRecalcLinePtr;
    friend class CLSMeasurer;

protected:

    DWORD _fInBkgndRecalc          :1; //  0 - avoid reentrant background recalc
    DWORD _fLineRecalcErr          :1; //  1 - error occured during background recalc
    DWORD _fNoUpdateView           :1; //  2 - don't update visible view
    DWORD _fWordWrap               :1; //  3 - word wrap text
    DWORD _fWrapLongLines          :1; //  4 - true if we want to wrap long lines
    DWORD _fRecalcDone             :1; //  5 - is line recalc done ?
    DWORD _fNoContent              :1; //  6 - if there is no real content, table cell's compute
                                       //      width differently.
    DWORD _dxCaret                 :2; //  7-8 - caret width, 1 for edit 0 for browse
    DWORD _fMinMaxCalced           :1; //  9 - Min/max size is valid and cached
    DWORD _fRecalcMost             :1; // 11 - Do we recalc the most neg/pos lines?
    DWORD _fRTLDisplay             :1; // 12 - TRUE if outer flow is right-to-left
    DWORD _fHasRelDispNodeCache    :1; // 13 - TRUE if we have a relative disp node cache
    DWORD _fHasMultipleTextNodes   :1; // 14 - TRUE if we have more than one disp node for text flow
    DWORD _fNavHackPossible        :1; // 15 - TRUE if we can have the NAV BR hack
    DWORD _fContainsHorzPercentAttr :1;// 16 - TRUE if we've handled an element that has horizontal percentage attributes (e.g. indents, padding)
    DWORD _fContainsVertPercentAttr :1;// 17 - TRUE if we've handled an element that has vertical percentage attributes (e.g. indents, padding)
    DWORD _fDefPaddingSet          :1; // 18 - TRUE if one of the _defPadding* variables below has been set
    DWORD _fHasLongLine            :1; // 19 - TRUE if has a long line that might overflow on Win9x platform
    DWORD _fHasNegBlockMargins     :1; // 20 - TRUE if any one line has negative block margins
    DWORD _fLastLineAligned        :1; // 21 - TRUE if there is line(s) with last line alignment 
    
    LONG  _dcpCalcMax;                 // - last cp for which line breaks have been calc'd + 1
    LONG  _yCalcMax;                   // - height of calculated lines
    LONG  _yHeightMax;                 // - max height of this display (-1 for infinite)
    LONG  _xWidth;                     // - width of longest calculated line
    LONG  _yHeight;                    // - sum of heights of calculated lines
    LONG  _yMostNeg;                   // - Largest negative offset that a line or its contents
                                       // extend from the actual y offset of any given line
    LONG  _yMostPos;
    LONG  _xWidthView;                 // - view rect width
    LONG  _yHeightView;                // - view rect height

public:
    LONG    _xMinWidth;             // min possible width with word break
    LONG    _xMaxWidth;             // max possible width without word break
    LONG    _yBottomMargin;         // bottom margin is not taken into account
                                    // in lines. Left, Right margins of the
                                    // TxtSite are accumulated in _xLeft & _xRight
                                    // of each line respectively

protected:
    LONG  _defPaddingTop;              // top default padding
    LONG  _defPaddingBottom;           // bottom default padding

#if (DBG==1)
    CFlowLayout * _pFL;                // flow layout associated with this line array
public:    
    CStr          _cstrFonts;          // Used to return the fonts used on a line in debug mode
    BOOL          _fBuildFontList;     // Do we build a font list?
protected:
#endif

private:
    CHtPvPv _htStoredRFEs;          //Hash table to store results of RFE for block elements
                                    //without layout while rendering. Otherwise nested block
                                    //elements can be computed too many times, each time 
                                    //walking all lines covered by block element.
public:
    void ClearStoredRFEs();

private:

    // Layout
    BOOL    RecalcPlainTextSingleLine(CCalcInfo * pci);
    BOOL    RecalcLines(CCalcInfo * pci);
    BOOL    RecalcLinesWithMeasurer(CCalcInfo * pci, CLSMeasurer * pme);
    BOOL    RecalcLines(CCalcInfo * pci,
                        long cpFirst,
                        LONG cchOld,
                        LONG cchNew,
                        BOOL fBackground,
                        CLed *pled,
                        BOOL fHack = FALSE);
    BOOL    AllowBackgroundRecalc(CCalcInfo * pci, BOOL fBackground = FALSE);

    LONG    CalcDisplayWidth();

    void    NoteMost(CLineFull *pli);
    void    RecalcMost();

    // Helpers
    BOOL    CreateEmptyLine(CLSMeasurer * pMe,
                            CRecalcLinePtr * pRecalcLinePtr,
                            LONG * pyHeight, BOOL fHasEOP );

    void    DrawBackgroundAndBorder(CFormDrawInfo * pDI,
                                    long            cpIn,
                                    LONG            ili,
                                    LONG            lCount,
                                    LONG          * piliDrawn,
                                    LONG            yLi,
                                    const RECT    * rcView,
                                    const RECT    * rcClip,
                                    const CPoint  * ptOffset);

    void    DrawBackgroundForFirstLine(CFormDrawInfo * pDI,
                                       long            cpIn,
                                       LONG            ili,
                                       const RECT    * prcView,
                                       const RECT    * prcClip,
                                       const CPoint  * pptOffset);
    
    void    DrawElementBackground(CTreeNode *,
                                    CDataAry <RECT> * paryRects,  RECT * prcBound,
                                    const RECT * prcView, const RECT * prcClip,
                                    CFormDrawInfo * pDI, BOOL fPseudo);

    void    DrawElementBorder(CTreeNode *,
                                    CDataAry <RECT> * paryRects, RECT * prcBound,
                                    const RECT * prcView, const RECT * prcClip,
                                    CFormDrawInfo * pDI);
    
    // Computes the indent for a given Node and a left and/or
    // right aligned site that a current line is aligned to.
    void    ComputeIndentsFromParentNode(CCalcInfo * pci, CTreeNode * pNode, DWORD dwFlags,
                                         LONG * pxLeftIndent, LONG * pxRightIndent);                                    

public:
    void    SetNavHackPossible()  { _fNavHackPossible = TRUE; }
    BOOL    GetNavHackPossible()  { return _fNavHackPossible; }

    void    SetLastLineAligned()  { _fLastLineAligned = TRUE; }
    BOOL    GetLastLineAligned()  { return _fLastLineAligned; }
    
    void    RecalcLineShift(CCalcInfo * pci, DWORD grfLayout);
    void    RecalcLineShiftForNestedLayouts();

    void    DrawRelElemBgAndBorder(
                     long            cp,
                     CTreePos      * ptp,
                     CRelDispNode  * prdn,
                     const RECT    * prcView,
                     const RECT    * prcClip,
                     CFormDrawInfo * pDI);

    void    DrawElemBgAndBorder(
                     CElement        *   pElementRelative,
                     CDataAry <RECT> *   paryRects,
                     const RECT      *   prcView,
                     const RECT      *   prcClip,
                     CFormDrawInfo   *   pDI,
                     const CPoint    *   pptOffset,
                     BOOL                fDrawBackground,
                     BOOL                fDrawBorder,
                     LONG                cpStart,
                     LONG                cpFinish,
                     BOOL                fClipToCPs,
                     BOOL                fNonRelative = FALSE,
                     BOOL                fPseudo = FALSE);

    void GetExtraClipValues(LONG *plLeftV, LONG *plRightV);
    
protected:

    void    InitLinePtr ( CLinePtr & );

    // Helper to retrieve the layout context of the flowlayout that owns us
    CLayoutContext *LayoutContext() const;

    // Helper to undo the effects of measuring a line
    void UndoMeasure( CLayoutContext *pLayoutContext, long cpStart, long cpEnd );

public:
    CTreeNode *FormattingNodeForLine(DWORD        dwFlags,      // IN
                                     LONG         cpForLine,    // IN
                                     CTreePos    *ptp,          // IN
                                     LONG         cchLine,      // IN
                                     LONG        *pcch,         // OUT
                                     CTreePos   **pptp,         // OUT
                                     BOOL        *pfMeasureFromStart) const;  // OUT

    CTreeNode* EndNodeForLine(LONG         cpEndForLine,               // IN
                              CTreePos    *ptp,                        // IN
                              CCalcInfo   *pci,                        // IN
                              LONG        *pcch,                       // OUT
                              CTreePos   **pptp,                       // OUT
                              CTreeNode  **ppNodeForAfterSpace) const; // OUT

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDisplay))

    CDisplay ();
    ~CDisplay();

    BOOL    Init();

    CFlowLayout *   GetFlowLayout() const;
    CElement *      GetFlowLayoutElement() const;
    CMarkup *       GetMarkup() const;

    void    Detach();

    // Getting properties

    BOOL    GetWordWrap() const             { return _fWordWrap; }
    void    SetWordWrap(BOOL fWrap)         { _fWordWrap = fWrap; }

    BOOL    GetWrapLongLines() const        { return _fWrapLongLines; }
    void    SetWrapLongLines(BOOL fWrapLongLines)
                                            { _fWrapLongLines = fWrapLongLines; }
    BOOL    NoContent() const               { return _fNoContent; }
    BOOL    HasLongLine() const             { return _fHasLongLine; }

    // maximum height and width
    LONG    GetMaxWidth() const             { return max(long(_xWidthView), GetWidth()); }
    LONG    GetMaxHeight() const            { return max(long(_yHeightView), GetHeight()); }

    LONG    GetCaret() const                { return _dxCaret; }

    BOOL    IsRTLDisplay() const            { return _fRTLDisplay; }
    void    SetRTLDisplay(BOOL fRTL)        { _fRTLDisplay = fRTL; }

    // Width, height and line count (all text)
    LONG    GetWidth() const                { return (_xWidth + _dxCaret); }
    LONG    GetHeight() const               { return (_yHeightMax + _yBottomMargin); }
    void    GetSize(CSize * psize) const
            {
                psize->cx = GetWidth();
                psize->cy = GetHeight();
            }
    void    GetSize(SIZE * psize) const
            {
                GetSize((CSize *)psize);
            }
    LONG    LineCount() const               { return CLineArray::Count(); }

    // View rectangle
    LONG    GetViewWidth() const            { return _xWidthView; }
    LONG    GetViewHeight() const           { return _yHeightView; }
    void    SetViewSize(const RECT &rcView);

    int     GetRTLOverflow() const
            {
                if (IsRTLDisplay() && _xWidth > _xWidthView)
                {
                    return _xWidth - _xWidthView;
                }
                return 0;
            }

    void    GetViewWidthAndHeightForChild(
                CParentInfo * ppri,
                long        * pxWidth,
                long        * pyHeight,
                BOOL fMinMax = FALSE);

    void    GetPadding(CParentInfo * ppri, long lPadding[], BOOL fMinMax = FALSE);

    LONG    GetFirstCp() const;
    LONG    GetLastCp() const;
    inline LONG GetFirstVisibleCp() const;
    inline LONG GetFirstVisibleLine() const;
    LONG    GetMaxCpCalced() const;

    // Line info
    LONG    CpFromLine(LONG ili, LONG *pyLine = NULL) const;
    void    Notify(CNotification * pnf);

    LONG    YposFromLine(CCalcInfo * pci, LONG ili, LONG *pyHeight_IgnoreNeg);

    void    RcFromLine(RECT *prc, LONG top, LONG ili, CLineCore *pli, CLineOtherInfo *ploi);

    BOOL    IsLogicalFirstFrag(LONG ili);
    
    enum LFP_FLAGS
    {
        LFP_ZORDERSEARCH    = 0x00000001,   // Hit lines on a z-order basis (default is source order)
        LFP_IGNOREALIGNED   = 0x00000002,   // Ignore frame lines (those for aligned content)
        LFP_IGNORERELATIVE  = 0x00000004,   // Ignore relative lines
        LFP_INTERSECTBOTTOM = 0x00000008,   // Intersect at the bottom (instead of the top)
        LFP_EXACTLINEHIT    = 0x00000010,   // find the exact line hit, do not return the
                                            // closest line hit.
    };

    LONG    LineFromPos(
                    const CRect &   rc,
                    DWORD           grfFlags = 0) const
            {
                return LineFromPos(rc, NULL, NULL, grfFlags);
            }
    LONG    LineFromPos (
                    const CRect &   rc,
                    LONG *          pyLine,
                    LONG *          pcpLine,
                    DWORD           grfFlags = 0,
                    LONG            iliStart = -1,
                    LONG            iliFinish = -1) const;

    enum CFP_FLAGS
    {
        CFP_ALLOWEOL                = 0x0001,
        CFP_EXACTFIT                = 0x0002,
        CFP_IGNOREBEFOREAFTERSPACE  = 0x0004,
        CFP_NOPSEUDOHIT                 = 0x0008
    };

    // Point <-> cp conversion
    LONG    CpFromPointReally(
         POINT            pt,                   // Point to compute cp at (client coords)
         CLinePtr * const prp,                  // Returns line pointer at cp (may be NULL)
         CMarkup **       ppMarkup,             // Markup which cp belongs to (in case of viewlinking)
         DWORD            dwFlags,              
         BOOL *           pfRightOfCp = NULL,
         LONG *           pcchPreChars = NULL,
         BOOL *           pfHitGlyph = NULL);

    LONG    CpFromPoint(POINT       pt,
                        CLinePtr * const prp,
                        CTreePos ** pptp,             // tree pos corresponding to the cp returned
                        CLayout **  ppLayout,
                        DWORD       dwFlags,
                        BOOL *      pfRightOfCp = NULL,
                        BOOL *      pfPseudoHit = NULL,
                        LONG *      pcchPreChars = NULL,
                        CCalcInfo * pci = NULL);

    LONG    CpFromPointEx(LONG      ili,
                        LONG        yLine,
                        LONG        cp,
                        POINT       pt,
                        CLinePtr * const prp,
                        CTreePos ** pptp,             // tree pos corresponding to the cp returned
                        CLayout **  ppLayout,
                        DWORD       dwFlags,
                        BOOL *      pfRightOfCp,
                        BOOL *      pfPseudoHit,
                        LONG *      pcchPreChars,
                        BOOL *      pfGlyphHit,
                        BOOL *      pfBulletHit,
                        CCalcInfo * pci);

    LONG    PointFromTp (
                    LONG cp,
                    CTreePos * ptp,
                    BOOL fAtEnd,
                    BOOL fAfterPrevCp,
                    POINT &pt,
                    CLinePtr * const prp,
                    UINT taMode,
                    CCalcInfo * pci = NULL,
                    BOOL *pfComplexLine = NULL,
                    BOOL *pfRTLFlow = NULL);

    LONG    RenderedPointFromTp (
                    LONG cp,
                    CTreePos * ptp,
                    BOOL fAtEnd,
                    POINT &pt,
                    CLinePtr * const prp,
                    UINT taMode,
                    CCalcInfo * pci,
                    BOOL *pfRTLFlow);

    void    RegionFromElement(
                        CElement       * pElement,
                        CDataAry<RECT> * paryRects,
                        CPoint         * pptOffset = NULL,
                        CFormDrawInfo  * pDI = NULL,
                        DWORD            dwFlags  = 0,
                        long             cpStart  = -1,
                        long             cpFinish = -1,
                        RECT *           prcBoundingRect = NULL
                        );
    void    RegionFromRange(
                    CDataAry<RECT> *    paryRects,
                    long                cp,
                    long                cch);

    CFlowLayout *MoveLineUpOrDown(NAVIGATE_DIRECTION iDir, BOOL fVertical, CLinePtr& rp, POINT ptCaret, LONG *pcp, BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL);
    CFlowLayout *NavigateToLine  (NAVIGATE_DIRECTION iDir, CLinePtr& rp, POINT pt,    LONG *pcp, BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL);
    BOOL      IsTopLine(CLinePtr& rp);
    BOOL      IsBottomLine(CLinePtr& rp);

    // Line break recalc.
    void    FlushRecalc();
    BOOL    RecalcView(CCalcInfo * pci, BOOL fFullRecalc);
    BOOL    UpdateView(CCalcInfo * pci, long cpFirst, LONG cchOld, LONG cchNew);
    BOOL    UpdateViewForLists(RECT *prcView, long cpFirst,
                               long  iliFirst, long  yPos,  RECT *prcInval);

    // Background recalc
    VOID    StartBackgroundRecalc(DWORD grfLayout);
    VOID    StepBackgroundRecalc(DWORD dwTimeOut, DWORD grfLayout);
    VOID    StopBackgroundRecalc();
    BOOL    WaitForRecalc(LONG cpMax, LONG yMax, CCalcInfo * pci = NULL);
    BOOL    WaitForRecalcIli(LONG ili, CCalcInfo * pci = NULL);
    BOOL    WaitForRecalcView(CCalcInfo * pci = NULL);
    inline CBgRecalcInfo * BgRecalcInfo();
    inline HRESULT EnsureBgRecalcInfo();
    inline void DeleteBgRecalcInfo();
    inline BOOL HasBgRecalcInfo() const;
    inline BOOL CanHaveBgRecalcInfo() const;
    //inline LONG DCpCalcMax() const;
    //inline LONG YCalcMax() const;
    inline LONG YWait() const;
    inline LONG CPWait() const;
    inline CRecalcTask * RecalcTask() const;
    inline DWORD BgndTickMax() const;

    // Selection
    void ShowSelected(CTreePos* ptpStart, CTreePos* ptpEnd, BOOL fSelected);

    HRESULT GetWigglyFromRange(CDocInfo * pdci, long cp, long cch, CShape ** ppShape);

    //
    // Text change notification stuff
    //

#if DBG==1
    void    CheckLineArray();
    void    CheckView();
    BOOL    VerifyFirstVisible();
    HRESULT GetFonts(long iLine, BSTR* pbstrFonts);
#endif
#if DBG==1 || defined(DUMPTREE)
    void DumpLines ( );
    void DumpLineText(HANDLE hFile, CTxtPtr* ptp, long iLine);
#endif

    // Misc helpers

    void    GetRectForChar(CCalcInfo   *pci,
                           LONG        *pTop,
                           LONG        *pBottom,
                           LONG         yTop,
                           LONG         yProposed,
                           CLineFull   *pli,
                           CTreePos    *ptp);

    void    GetTopBottomForCharEx(CCalcInfo  *pci, LONG      *pTop, LONG  *pBottom,
                                  LONG       yTop, CLineFull *pli,  LONG  xPos,
                                  LONG  yProposed, CTreePos  *ptp,  BOOL *pfBulletHit);

    void    GetClipRectForLine(RECT *prcClip, LONG top, LONG xOrigin, CLineCore *pli, CLineOtherInfo *ploi) const;

    // Rendering
    void    Render( CFormDrawInfo * pDI,
                    const RECT    & rcView,
                    const RECT    & rcRender,
                    CDispNode     * pDispNode);

    BOOL IsLastTextLine(LONG ili);
    void SetCaretWidth(int dx) { Assert (dx >=0); _dxCaret = dx; }

    void    DestroyFlowDispNodes();

    CDispNode * AddLayoutDispNode(
                    CParentInfo *   ppi,
                    CTreeNode *     pTreeNode,
                    long            dx,
                    long            dy,
                    CDispNode *     pDispSibling
                    );
    CDispNode * AddLayoutDispNode(
                    CParentInfo *   ppi,
                    CLayout *       pLayout,
                    long            dx,
                    long            dy,
                    CDispNode *     pDispSibling
                    );
    CDispNode * GetPreviousDispNode(LONG cp, LONG iliStart);
    void        AdjustDispNodes(CDispNode * pdnLastUnchanged, 
                                CDispNode * pdnLastChanged, 
                                CLed * pled
        );

    HRESULT HandleNegativelyPositionedContent(CLineFull   * pliNew,
                                              CLSMeasurer * pme,
                                              CDispNode   * pDNBefore,
                                              long          iLinePrev,
                                              long          yHeight);

    HRESULT InsertNewContentDispNode(CDispNode *  pDNBefore,
                                     CDispNode ** ppDispContent,
                                     long         iLine,
                                     long         yHeight);

    inline BOOL          HasRelDispNodeCache() const;
    HRESULT              SetRelDispNodeCache(void * pv);
    CRelDispNodeCache *  GetRelDispNodeCache() const;
    CRelDispNodeCache *  DelRelDispNodeCache();

    void SetVertPercentAttrInfo(BOOL fPercent) { _fContainsVertPercentAttr = fPercent; }
    void SetHorzPercentAttrInfo(BOOL fPercent) { _fContainsHorzPercentAttr = fPercent; }
    void ElementResize(CFlowLayout * pFlowLayout, BOOL fForceResize);


    // CRelDispNodeCache wants access to GetRelNodeFlowOffset()
    void GetRelNodeFlowOffset(CDispNode * pDispNode, CPoint * ppt);

    // Fontlinking support
    BOOL GetAveCharSize(CCalcInfo * pci, SIZE * psizeChar);
    BOOL GetCcs(CCcs * pccs, COneRun * por, XHDC hdc, CDocInfo * pdi, BOOL fFontLink = TRUE);

protected:
    // Rel line support
    CRelDispNodeCache * EnsureRelDispNodeCache();

    void    UpdateRelDispNodeCache(CLed * pled);

    void    AddRelNodesToCache( long cpStart, LONG yPos,
                                LONG iliStart, LONG iliFinish,
                                CDataAry<CRelDispNode> * prdnc);

    void    VoidRelDispNodeCache();
#if DBG==1
    CRelDispNodeCache * _pRelDispNodeCache;
#endif
    CDispNode *     FindElementDispNode(CElement * pElement) const
    {
        return HasRelDispNodeCache()
                ? GetRelDispNodeCache()->FindElementDispNode(pElement)
                : NULL;
    }
    void SetElementDispNode(CElement * pElement, CDispNode * pDispNode)
    {
        if (HasRelDispNodeCache())
            GetRelDispNodeCache()->SetElementDispNode(pElement, pDispNode);
    }
    void EnsureDispNodeVisibility(CElement * pElement = NULL)
    {
        if (HasRelDispNodeCache())
            GetRelDispNodeCache()->EnsureDispNodeVisibility(pElement);
    }
    void HandleDisplayChange()
    {
        if (HasRelDispNodeCache())
            GetRelDispNodeCache()->HandleDisplayChange();
    }
    void GetRelElementFlowOffset(CElement * pElement, CPoint * ppt);
    void TranslateRelDispNodes(const CSize & size, long lStart);
    void ZChangeRelDispNodes();
    void RegionFromElementCore(
                              CElement       * pElement,
                              CDataAry<RECT> * paryRects,
                              CPoint         * pptOffset = NULL,
                              CFormDrawInfo  * pDI = NULL,
                              DWORD            dwFlags  = 0,
                              long             cpStart  = -1,
                              long             cpFinish = -1,
                              RECT *           prcBoundingRect = NULL
        );
    void SetRelDispNodeContentOrigin(CDispNode *pDispNode);
};

#define ALIGNEDFEEDBACKWIDTH    4

inline CDispNode *
CDisplay::AddLayoutDispNode(
    CParentInfo *   ppi,
    CTreeNode *     pTreeNode,
    long            dx,
    long            dy,
    CDispNode *     pDispSibling
    )
{
    Assert(pTreeNode);
    Assert(pTreeNode->Element());
    Assert(pTreeNode->Element()->ShouldHaveLayout());

    return AddLayoutDispNode(ppi, pTreeNode->Element()->GetUpdatedLayout( ppi->GetLayoutContext() ),
        dx, dy, pDispSibling
        );
}

/*
 *  CDisplayL::InitLinePtr ( CLinePtr & plp )
 *
 *  @mfunc
 *      Initialize a CLinePtr properly
 */
inline
void CDisplay::InitLinePtr (
    CLinePtr & plp )        //@parm Ptr to line to initialize
{
    plp.Init( * this );
}

inline BOOL
CDisplay::HasRelDispNodeCache() const
{
    return _fHasRelDispNodeCache;
}

#if DBG!=1
#define CheckView()
#define CheckLineArray()
#endif

//+----------------------------------------------------------------------------
//
//  Class:  CFlowLayoutBreak (flow layout break)
//
//  Note:   Implementation of flow layout break.
//
//-----------------------------------------------------------------------------
MtExtern(CFlowLayoutBreak_pv); 
MtExtern(CFlowLayoutBreak_arySiteTask_pv); 

class CFlowLayoutBreak 
    : public CLayoutBreak
{
public:
    struct CSiteTask
    {
        CTreeNode * _pTreeNode;     // task is for this node 
        LONG        _xMargin;       // for left aligned objects left margin, 
                                    // for right aligned objects right margin 
    };
    DECLARE_CDataAry(CArySiteTask, CSiteTask, Mt(Mem), Mt(CFlowLayoutBreak_arySiteTask_pv));

    DECLARE_MEMALLOC_NEW_DELETE(Mt(CFlowLayoutBreak_pv));

    CFlowLayoutBreak() 
    {
        _pElementPBB    = NULL;
        _pMarkupPointer = NULL;

        _xLeftMargin    = 
        _xRightMargin   = 0;

        _xPadLeft       = 
        _xPadRight      = 0;

        _grfFlags       = 0;
    }

    virtual ~CFlowLayoutBreak();

    void SetFlowLayoutBreak(
        CMarkupPointer *pMarkupPointer, 
        LONG xLeftMargin, 
        LONG xRightMargin, 
        LONG xPadLeft, 
        LONG xPadRight) 
    {
        Assert(pMarkupPointer); 
        _pMarkupPointer = pMarkupPointer; 
        _xLeftMargin    = xLeftMargin; 
        _xRightMargin   = xRightMargin; 
        _xPadLeft       = xPadLeft; 
        _xPadRight      = xPadRight; 
    }

    CMarkupPointer *GetMarkupPointer() 
    { 
        Assert(_pMarkupPointer);
        return _pMarkupPointer; 
    }

    LONG GetLeftMargin()
    {
        return (_xLeftMargin);
    }

    LONG GetRightMargin()
    {
        return (_xRightMargin);
    }

    LONG GetPadLeft()
    {
        return (_xPadLeft);
    }

    LONG GetPadRight()
    {
        return (_xPadRight);
    }

    BOOL HasSiteTasks() const 
    {
        return (_arySiteTask.Size() != 0);
    }

    CArySiteTask *GetSiteTasks()
    {
        return (&_arySiteTask);
    }

public: 
    union 
    {
        DWORD   _grfFlags;

        struct 
        {
            DWORD   _fClearLeft     : 1;    //  0
            DWORD   _fClearRight    : 1;    //  1
            DWORD   _fAutoClear     : 1;    //  2

            DWORD   _fUnused        : 29;   //  3 - 31
        };
    };

    CElement       *    _pElementPBB;           // an element caused page-break-before on a line.

private:
    CMarkupPointer *    _pMarkupPointer;        // markup point indicating start position in the CDisplay. 
    LONG                _xLeftMargin;           // left margin layout finished 
    LONG                _xRightMargin;          // right margin layout finished 
    LONG                _xPadLeft;              // left padding 
    LONG                _xPadRight;             // right padding 
    CArySiteTask        _arySiteTask;           // array with site tasks
};

#pragma INCMSG("--- End '_disp.h'")
#else
#pragma INCMSG("*** Dup '_disp.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_doc.h ===
/*
 *  @doc INTERNAL
 *
 *  @module _DOC.H  CTxtStory declaration |
 *
 *  Purpose:
 *      Encapsulate the plain-text document data (text blocks, cchText)
 *
 *  Original Authors: <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95 alexgo  commented and cleaned up
 *
 */

#ifndef I__DOC_H_
#define I__DOC_H_
#pragma INCMSG("--- Beg '_doc.h'")

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif

class CTreeNode;

MtExtern(CTxtArray)

#define cbBlockCombine  CbOfCch(3072)
#define cbBlockMost     CbOfCch(49152)
#define cbBlockInitial  CbOfCch(4096)
#define cchGapInitial   128
#define cchBlkCombmGapI (CchOfCb(cbBlockCombine) - cchGapInitial)
#define cchBlkInitmGapI (CchOfCb(cbBlockInitial) - cchGapInitial)

#define cchBlkInsertmGapI   (CchOfCb(cbBlockInitial)*5 - cchGapInitial)

// Switch the return value to flip between before/after space

class CElement;
class CTxtPtr;
class CTxtArray;
class CTable;
class CTreePos;
struct CTextChange;
enum  ELEMENT_TAG;

/*
 *  CTxtRun
 *
 *  @class  Formalizes a run of text. A range of text with same attribute,
 * (see CFmtDesc) or within the same line (see CLine), etc. Runs are kept
 * in arrays (see CArray) and are pointed to by CRunPtr's of various kinds.
 * In general the character position of a run is computed by summing the
 * length of all preceding runs, altho it may be possible to start from
 * some other cp, e.g., for CLines, from CDisplay::_cpFirstVisible.
 */

class CTxtRun
{
public:

    CTxtRun ( ) { _cch = 0; }

    long _cch;
};

/*
 *  CTxtBlk
 *
 *  @class  A text block; a chunk of UNICODE text with a buffer gap to allow
 *  for easy insertions and deletions.
 *
 *  @base   protected | CTxtRun
 *
 *  @devnote    A text block may have four states: <nl>
 *      NULL:   No data allocated for the block <nl>
 *              <md CTxtBlk::_pch> == NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> == 0 <nl>
 *
 *      empty:  All of the available space is a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *
 *      normal: There is both data and a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> != 0     <nl>
 *              <md CTxtBlk::_ibGap> != 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *
 *      full:   The buffer gap is of zero size <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> <gt>= 0  <nl>
 *              <md CTxtBlk::_ibGap> <gt> 0 <nl>
 *              <md CTxtBlk::_cbBlock> == _cch * sizeof(WCHAR) <nl>
 *
 *  The position of the buffer gap is given by _ibGap.  With _cch and _cbBlock,
 *  it's possible to figure out the *size* of the gap by simply calculating:
 *  <nl>
 *      size = _cbBlock - (_cch * sizeof(character))
 *
 */

class CTxtBlk : public CTxtRun
{
    friend class CTxtPtr;
    friend class CTxtArray;

protected:

    CTxtBlk ( ) { InitBlock( 0 ); }

  ~ CTxtBlk ( ) { FreeBlock(); }

                                    //@cmember  Initializes the block to the
                                    //# of bytes given by <p cb>
    BOOL    InitBlock(DWORD cb);
                                    //@cmember  Sets a block to the NULL state
    VOID    FreeBlock();
                                    //@cmember  Moves the buffer gap in a
                                    //block
    VOID    MoveGap(DWORD ichGap);
                                    //@cmember  Resizes a block to <p cbNew>
                                    //bytes
    BOOL    ResizeBlock(DWORD cbNew);

private:

    TCHAR   *_pch;          // Pointer to the text data
    DWORD   _ibGap;         // BYTE offset of the gap
    DWORD   _cbBlock;       // Size of the block in bytes
};


/*
 *  CTxtArray
 *
 *  @class  A dynamic array of <c CTxtBlk> classes
 *
 *  @base public | CArray<lt>CTxtBlk<gt>
 */
class CTxtArray : public CArray<CTxtBlk>
{
    friend class CTxtPtr;
    friend class CMarkup;

public:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(CTxtArray))

#if DBG==1
                                    //@cmember  Invariant support
    BOOL Invariant( void ) const;
#endif
                                    //@cmember  Constructor
    CTxtArray();
                                    //@cmember  Destructor
    ~CTxtArray();
                                    //@cmember  Gets the total number of
                                    //characters in the array.
    long    GetCch () const;

                                    //@cmember Removes all data from the array
    VOID    RemoveAll();

private:
    BOOL    AddBlock(DWORD itbNew, LONG cb);
                                    //@cmember  Removes the given number of
                                    //blocks
    VOID    RemoveBlocks(DWORD itbFirst, DWORD ctbDel);
                                    //@cmember  Combines blocks adjacent to itb
    BOOL    CombineBlocks(DWORD itb);
                                    //@cmember  Splits a block
    BOOL    SplitBlock(DWORD itb, DWORD ichSplit, DWORD cchFirst,
                DWORD cchLast, BOOL fStreaming);
                                    //@cmember  Shrinks all blocks to their minimal
                                    //size
    VOID    ShrinkBlocks();
                                    //@cmember  Copies a chunk of text into the
                                    //given location
    LONG    GetChunk(TCHAR **ppch, DWORD cch, TCHAR *pchChunk, DWORD cchCopy) const;
                                    //@cmember  The total number of characters in the
                                    //this text array.
    DWORD   _cchText;
};

#pragma INCMSG("--- End '_doc.h'")
#else
#pragma INCMSG("*** Dup '_doc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_fontlnk.h ===
#ifndef I__FONTLNK_H_
#define I__FONTLNK_H_
#pragma INCMSG("--- Beg '_fontlnk.h'")

class CCcs;
class COneRun;
class CBaseCcs;

// HACK (cthrash) We do not ever font link for SYMBOL_CHARSET fonts.  This
// makes the FS_SYMBOL bit useless for us.  What we'd like to do, is to
// distinguish the ASCII portion from FS_LATIN1, since basically all fonts
// claim to have FS_LATIN1 when in reality many of them only contain the
// ASCII portion of Latin-1.  So here's the hack - all fonts have SBITS_ASCII
// set.  This simplifies the loop in CRenderer.

#define SBITS_LATIN1               FS_LATIN1
#define SBITS_LATIN2               FS_LATIN2
#define SBITS_CYRILLIC             FS_CYRILLIC
#define SBITS_GREEK                FS_GREEK
#define SBITS_TURKISH              FS_TURKISH
#define SBITS_HEBREW               FS_HEBREW
#define SBITS_ARABIC               FS_ARABIC
#define SBITS_BALTIC               FS_BALTIC
#define SBITS_JISJAPAN             FS_JISJAPAN
#define SBITS_CHINESESIMP          FS_CHINESESIMP
#define SBITS_WANSUNG              FS_WANSUNG
#define SBITS_CHINESETRAD          FS_CHINESETRAD
#define SBITS_ASCII                FS_SYMBOL       // <- see comment above
#define SBITS_SURROGATE_A          0x20000000L
#define SBITS_SURROGATE_B          0x40000000L

// For symbol fonts we want to assume they can handle everything.
#define SBITS_ALLLANGS DWORD(-1)

// FontLinkTextOut uMode values
#define FLTO_BOTH           0
#define FLTO_TEXTEXTONLY    1
#define FLTO_TEXTOUTONLY    2

DWORD GetFontScriptBits(XHDC hdc, const TCHAR *szFaceName, LOGFONT *plf);
DWORD GetLangBits(WCHAR wc);

BOOL NeedsFontLinking(XHDC hdc, CCcs * pccs, LPCTSTR pch, int cch, CDoc *pDoc);
void DrawUnderlineStrikeOut(int x, int y, int iLength, XHDC hDC, HFONT hFont, const GDIRECT *prc);
void VanillaTextOut(CCcs *pccs, XHDC hdc, int x, int y, UINT fuOptions, const GDIRECT *prc, LPCTSTR pString, UINT cch, UINT uCodePage, int *piDx);
int FontLinkTextOut(XHDC hdc, int x, int y, UINT fuOptions, const GDIRECT *prc, LPCTSTR pString, UINT cch, CDocInfo *pdci, const CCharFormat *pCF, UINT uMode);

BOOL SelectScriptAppropriateFont( SCRIPT_ID sid, BYTE bCharSet, CDoc * pDoc, CMarkup * pMarkup, CCharFormat * pcf );
BOOL ScriptAppropriateFaceNameAtom( SCRIPT_ID sid, CDoc * pDoc, BOOL fFixed, const CCharFormat * const pcf, CMarkup * pMarkup, LONG * platmFontFace );

// Fontlinking support functions
BOOL      ShouldSwitchFontsForPUA(XHDC hdc, UINT uiFamilyCodePage, const CBaseCcs * pBaseCcs, const CCharFormat * pcf, SCRIPT_ID * psid);

#pragma INCMSG("--- End '_fontlnk.h'")
#else
#pragma INCMSG("*** Dup '_fontlnk.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_line.h ===
/*
 *  _LINE.H
 *
 *  Purpose:
 *      CLine* classes
 *
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */

#ifndef I__LINE_H_
#define I__LINE_H_
#pragma INCMSG("--- Beg '_line.h'")

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X_LOI_HXX_
#define X_LOI_HXX_
#include <loi.hxx>
#endif

class CLineFull;
class CDisplay;
class CLSMeasurer;
class CLayoutContext;

enum JUSTIFY
{
    JUSTIFY_LEAD,
    JUSTIFY_CENTER,
    JUSTIFY_TRAIL,
    JUSTIFY_FULL
};

// ============================  CLine*  =====================================
// line - keeps track of a line of text
// All metrics are in rendering device units

MtExtern(CLineCore)

class CLineCore : public CTxtRun
{
public:
    LONG    _iLOI;          // index into the other line information
    LONG    _xWidth;        // text line width - does not include line left and
                            // trailing whitespace
    LONG    _yHeight;       // line height (amount y coord is advanced for this line).
    LONG    _xRight;        // Right indent (for blockquotes).
    LONG    _xLineWidth;    // width of line from margin to margin (possibly > view width)

#if !defined(MW_MSCOMPATIBLE_STRUCT)

    // Line flags.
    union
    {
        DWORD _dwFlagsVar;   // To access them all at once.
        struct
        {
#endif
            //
            unsigned int _fCanBlastToScreen : 1;
            unsigned int _fHasBulletOrNum : 1;    // Set if the line has a bullet
            unsigned int _fFirstInPara : 1;
            unsigned int _fForceNewLine : 1;      // line forces a new line (adds vertical space)

            //
            unsigned int _fLeftAligned : 1;       // line is left aligned
            unsigned int _fRightAligned : 1;      // line is right aligned
            unsigned int _fClearBefore : 1;       // clear line created by a line after the cur line(clear on a p)
            unsigned int _fClearAfter : 1;        // clear line created by a line after the cur line(clear on a br)

            //
            unsigned int _fHasAligned : 1;        // line contains a embeded char's for
            unsigned int _fHasBreak : 1;          // Specifies that the line ends in a break character.
            unsigned int _fHasEOP : 1;            // set if ends in paragraph mark
            unsigned int _fHasEmbedOrWbr : 1;     // has embedding or wbr char

            //
            unsigned int _fHasBackground : 1;     // has bg color or bg image
            unsigned int _fHasNBSPs : 1;          // has nbsp (might need help rendering)
            unsigned int _fHasNestedRunOwner : 1; // has runs owned by a nested element (e.g., a CTable)
            unsigned int _fHidden:1;              // Is this line hidden?

            //
            unsigned int _fEatMargin : 1;         // Line should act as bottom margin.
            unsigned int _fPartOfRelChunk : 1;    // Part of a relative line chunk
            unsigned int _fFrameBeforeText : 1;   // this means this frame belongs to the
                                                  // next line of text.
            unsigned int _fDummyLine : 1;         // dummy line

            //
            unsigned int _fHasTransmittedLI : 1;  // Did this line transfer the bullet to a line after it?
            unsigned int _fAddsFrameMargin : 1;   // line adds frame margin space to adjoining lines
            unsigned int _fSingleSite : 1;        // Set if the line contains one of our
                                                  // sites that always lives on its own line,
                                                  // but still in the text stream.(like tables and HR's)
            unsigned int _fHasParaBorder : 1;     // TRUE if this line has a paragraph border around it.

            //
            unsigned int _fRelative : 1;          // relatively positioned line
            unsigned int _fFirstFragInLine : 1;   // first fragment or chunk of one screen line
            unsigned int _fRTLLn : 1;             // TRUE if the line has RTL direction orientation.
            unsigned int _fPageBreakBefore : 1;   // TRUE if this line has an element w/ page-break-before attribute

            //
            unsigned int _fPageBreakAfter   : 1;  // TRUE if this line has an element w/ page-break-after attribute
            unsigned int _fJustified        : 2;  // current line is justified.
                                                  // 00 - left/notset       -   01 - center justified
                                                  // 10 - right justified   -   11 - full justified

            unsigned int _fLookaheadForGlyphing : 1;  // We need to look beyond the current
                                                        // run to determine if glyphing is needed.

#if !defined(MW_MSCOMPATIBLE_STRUCT)
        };
    };

    DWORD& _dwFlags() { return _dwFlagsVar; }
#else

    DWORD& _dwFlags() { return *(DWORD*)(&_xRight + 1); }

#endif

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CLineCore))

    CLineOtherInfo *oi() const { Assert(_iLOI != -1); return (CLineOtherInfo *)GetLineOtherInfoEx(_iLOI); }
    CLineOtherInfo *oi(CLineInfoCache *pLineInfoCache) const
            { Assert(_iLOI != -1); return (CLineOtherInfo *)GetLineOtherInfoEx(_iLOI, pLineInfoCache); }
    void operator =(const CLineFull& lif);

    inline LONG CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                     BOOL fExactfit=FALSE, LONG *pyHeightRubyBase = NULL,
                     BOOL *pfGlyphHit = NULL, LONG *pyProposed = NULL) const;
    
    BOOL IsLeftAligned() const  { return _fLeftAligned; }
    BOOL IsRightAligned() const { return _fRightAligned; }
    BOOL HasMargins(CLineOtherInfo *ploi) const     { return ploi->HasMargins(); }
    BOOL HasAligned() const     { return _fHasAligned; }
    BOOL IsFrame() const        { return _fRightAligned || _fLeftAligned; }
    BOOL IsClear() const        { return _fClearBefore  || _fClearAfter; }
    BOOL IsBlankLine() const    { return IsClear() || IsFrame(); }
    BOOL IsTextLine() const     { return !IsBlankLine(); }
    BOOL IsNextLineFirstInPara(){ return (_fHasEOP || (!_fForceNewLine && _fFirstInPara)); }
    BOOL IsRTLLine() const      { return _fRTLLn; }

    void ClearAlignment() { _fRightAligned = _fLeftAligned = FALSE; }
    void SetLeftAligned() { _fLeftAligned = TRUE; }
    void SetRightAligned() { _fRightAligned = TRUE; }

    LONG GetTextRight(CLineOtherInfo *ploi, BOOL fLastLine=FALSE) const { return (long(_fJustified) == JUSTIFY_FULL && !_fHasEOP && !_fHasBreak && !fLastLine
                                        ? ploi->_xLeftMargin + _xLineWidth - _xRight
                                        : ploi->_xLeftMargin + ploi->_xLeft + _xWidth + ploi->_xLineOverhang); }
    LONG GetRTLTextRight(CLineOtherInfo *ploi) const { return ploi->_xRightMargin + _xRight; }
    LONG GetRTLTextLeft(CLineOtherInfo *ploi) const { return (long(_fJustified) == JUSTIFY_FULL && !_fHasEOP && !_fHasBreak
                                        ? ploi->_xRightMargin + _xLineWidth - ploi->_xLeft
                                        : ploi->_xRightMargin + _xRight + _xWidth + ploi->_xLineOverhang); }

    void AdjustChunkForRtlAndEnsurePositiveWidth(CLineOtherInfo const *ploi, 
                                                 LONG xStartChunk, LONG xEndChunk, 
                                                 LONG *pxLeft, LONG *pxRight);

    // Amount to advance the y coordinate for this line.
    LONG GetYHeight() const
    {
        return _yHeight;
    }

    // Offset to add to top of line for hit testing.
    // This takes into account line heights smaller than natural.
    LONG GetYHeightTopOff(CLineOtherInfo *ploi) const
    {
        return ploi->_yHeightTopOff;
    }

    // Offset to add to bottom of line for hit testing.
    LONG GetYHeightBottomOff(CLineOtherInfo *ploi) const
    {
        return (ploi->_yExtent - (_yHeight - ploi->_yBeforeSpace)) + GetYHeightTopOff(ploi);
    }

    // Total to add to the top of the line space to get the actual
    // top of the display part of the line.
    LONG GetYTop(CLineOtherInfo *ploi) const
    {
        return GetYHeightTopOff(ploi) + ploi->_yBeforeSpace;
    }

    LONG GetYBottom(CLineOtherInfo *ploi) const
    {
        return GetYHeight() + GetYHeightBottomOff(ploi);
    }

    LONG GetYMostTop(CLineOtherInfo *ploi) const
    {
        return min(GetYTop(ploi), GetYHeight());
    }

    LONG GetYLineTop(CLineOtherInfo *ploi) const
    {
        return min(0L, GetYMostTop(ploi));
    }

    LONG GetYLineBottom(CLineOtherInfo *ploi) const
    {
        return max(GetYBottom(ploi), GetYHeight());
    }
    
    void RcFromLine(CLineOtherInfo *ploi, RECT & rcLine, LONG yTop)
    {
        rcLine.top      = yTop + GetYTop(ploi);
        rcLine.bottom   = yTop + GetYBottom(ploi);
        rcLine.left     = ploi->_xLeftMargin;
        rcLine.right    = ploi->_xLeftMargin + _xLineWidth;
    }

    void AddRefOtherInfo()
    {
        Assert(_iLOI != -1);
        AddRefLineOtherInfoEx(_iLOI);
    }
    void ReleaseOtherInfo()
    {
        Assert(_iLOI != -1);
        ReleaseLineOtherInfoEx(_iLOI);
        _iLOI = -1;
    }
    void CacheOtherInfo(const CLineOtherInfo& loi)
    {
        _iLOI = CacheLineOtherInfoEx(loi);
        Assert(_iLOI >= 0);
    }
    inline void AssignLine(CLineFull& lif);

    // Methods to access values for aligned object lines   
    CElement *AO_Element(CLineOtherInfo *ploi);
    // TODO (KTam, IE6 bug 52): Fix other AO_* callers of AO_GetUpdatedLayout, remove default context param.
    CLayout *AO_GetUpdatedLayout(CLineOtherInfo *ploi, CLayoutContext *pLayoutContext = NULL);
    LONG AO_GetFirstCp(CLineOtherInfo *ploi, LONG cpLine);
    LONG AO_GetLastCp(CLineOtherInfo *ploi, LONG cpLine);
    void AO_GetSize(CLineOtherInfo *ploi, CSize *pSize);
    const CFancyFormat * AO_GetFancyFormat(CLineOtherInfo *ploi);
    LONG AO_GetXProposed(CLineOtherInfo *ploi);
    LONG AO_GetYProposed(CLineOtherInfo *ploi);
};

class CLineFull : public CLineCore, public CLineOtherInfo
{
public:
    CLineFull()
    {
        Init();
    }
    
    void Init()
    {
        ZeroMemory(this, sizeof(CLineFull));
        _iLOI = -1;
    }
    
    CLineFull(const CLineCore& li)
    {
        memcpy((CLineCore*)this, &li, sizeof(CLineCore));
        if(_iLOI >= 0)
        {
            *((CLineOtherInfo*)this) = *li.oi();
        }
        else
        {
            ZeroMemory((CLineOtherInfo*)this, sizeof(CLineOtherInfo));
        }
    }

    CLineFull(const CLineFull& lif)
    {
        memcpy(this, &lif, sizeof(CLineFull));
    }

    BOOL operator ==(const CLineFull& li) const
    {
#ifdef _WIN64
	BOOL fRet = (!memcmp((CLineCore*)this, (CLineCore*)(&li), sizeof(CLineCore)))
			&& (!memcmp((CLineOtherInfo*)this, (CLineOtherInfo*)(&li), sizeof(CLineOtherInfo)));
#else
        BOOL fRet = !memcmp(this, &li, sizeof(CLineFull));
#endif
        return fRet;
    }

#if DBG==1
    BOOL operator ==(const CLineCore& li)
    {
        CLineFull lif = li;
        return (*this == lif);
    }

    BOOL operator ==(const CLineOtherInfo& li)
    {
        BOOL fRet = memcmp((CLineOtherInfo*)this, &li, sizeof(CLineOtherInfo));
        return !fRet;
    }
#endif

    LONG CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                     BOOL fExactfit=FALSE, LONG *pyHeightRubyBase = NULL,
                     BOOL *pfGlyphHit = NULL, LONG *pyProposed = NULL) const;
    LONG GetTextRight(BOOL fLastLine=FALSE) const
            { return CLineCore::GetTextRight((CLineOtherInfo*)this, fLastLine);}
    LONG GetRTLTextRight() const
            { return CLineCore::GetRTLTextRight((CLineOtherInfo*)this);}
    LONG GetRTLTextLeft() const
            { return CLineCore::GetRTLTextLeft((CLineOtherInfo*)this);}
    LONG GetYHeightTopOff() const
            { return CLineCore::GetYHeightTopOff((CLineOtherInfo*)this);}
    LONG GetYHeightBottomOff() const
            { return CLineCore::GetYHeightBottomOff((CLineOtherInfo*)this);}
    LONG GetYTop() const
            { return CLineCore::GetYTop((CLineOtherInfo*)this);}
    LONG GetYBottom() const
            { return CLineCore::GetYBottom((CLineOtherInfo*)this);}
    LONG GetYMostTop() const
            { return CLineCore::GetYMostTop((CLineOtherInfo*)this);}
    LONG GetYLineTop() const
            { return CLineCore::GetYLineTop((CLineOtherInfo*)this);}
    LONG GetYLineBottom() const
            { return CLineCore::GetYLineBottom((CLineOtherInfo*)this);}
    void RcFromLine(RECT & rcLine, LONG yTop)
            { CLineCore::RcFromLine((CLineOtherInfo*)this, rcLine, yTop);}

    // helpers
    static LONG CalcLineWidth(CLineCore const * pli, CLineOtherInfo const * ploi)
            {
                return         ploi->_xLeft
                             + pli->_xWidth 
                             + ploi->_xLineOverhang 
                             + pli->_xRight
                             - ploi->_xNegativeShiftRTL; 
            }
    LONG CalcLineWidth() const
            { return CalcLineWidth(this, this); }
};

// ==========================  CLineArray  ===================================
// Array of lines

MtExtern(CLineArray)
MtExtern(CLineArray_pv)

class CLineArray : public CArray<CLineCore>
{
public:
    typedef CArray<CLineCore> super;
    
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CLineArray))
    CLineArray() : CArray<CLineCore>(Mt(CLineArray_pv)) {};

#if DBG==1
    virtual void Remove(DWORD ielFirst, LONG celFree, ArrayFlag flag);
    virtual void Clear (ArrayFlag flag);
    virtual BOOL Replace(DWORD iel, LONG cel, CArrayBase *par);
#endif
    
    void Forget(DWORD iel, LONG cel);
    void Forget() { Forget(0, Count()); }
};

// ==========================  CLinePtr  ===================================
// Maintains position in a array of lines

MtExtern(CLinePtr)

class CLinePtr : public CRunPtr<CLineCore>
{
protected:
    CDisplay   *_pdp;

public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CLinePtr))
    CLinePtr (CDisplay *pdp) {Hijack(pdp);}
    CLinePtr (CLinePtr& rp) : CRunPtr<CLineCore> (rp)   {}

    void Init ( CLineArray & );

    CDisplay *GetPdp() { return _pdp;}

    // The new display hijack's this line ptr
    void    Hijack(CDisplay *pdp);

    // Alternate initializer
    void    RpSet(LONG iRun, LONG ich)  { CRunPtr<CLineCore>::SetRun(iRun, ich); }

    // Direct cast to a run index
    operator LONG() const { return GetIRun(); }

    // Get the run index (line number)
    LONG GetLineIndex () { return GetIRun(); }
    LONG GetAdjustedLineLength();

    CLineOtherInfo *oi();
    
    CLineCore * operator -> ( ) const
    {
        return CurLine();
    }

    CLineCore * CurLine() const
    {
        return (CLineCore *)_prgRun->Elem( GetIRun() );
    }

    CLineCore & operator * ( ) const
    {
        return *((CLineCore *)_prgRun->Elem( GetIRun() ));
    }

    CLineCore & operator [ ] ( long dRun );

    BOOL    NextLine(BOOL fSkipFrame, BOOL fSkipEmptyLines); // skip frames
    BOOL    PrevLine(BOOL fSkipFrame, BOOL fSkipEmptyLines); // skip frames

    // Character position control
    LONG    RpGetIch ( ) const { return GetIch(); }
    BOOL    RpAdvanceCp(LONG cch, BOOL fSkipFrame = TRUE);
    BOOL    RpSetCp(LONG cp, BOOL fAtEnd, BOOL fSkipFrame = TRUE, BOOL fSupportBrokenLayout = FALSE);
    LONG    RpBeginLine(void);
    LONG    RpEndLine(void);

    void RemoveRel (LONG cRun, ArrayFlag flag)
    {
        CRunPtr<CLineCore>::RemoveRel(cRun, flag);
    }

    BOOL Replace(LONG cRun, CLineArray *parLine);

    // Assignment from a run index
    CRunPtrBase& operator =(LONG iRun) {SetRun(iRun, 0); return *this;}

    LONG    FindParagraph(BOOL fForward);

    // returns TRUE if the ptr is *after* the *last* character in the line
    BOOL IsAfterEOL() { return GetIch() == CurLine()->_cch; }

    BOOL IsLastTextLine();

private:
    CLineOtherInfo *_pLOI;
    LONG _iLOI;
};

inline LONG
CLineCore::CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                       BOOL fExactfit, LONG *pyHeightRubyBase,
                       BOOL *pfGlyphHit, LONG *pyProposed) const
{
    CLineFull lif = *this;
    return lif.CchFromXpos(me, x, y, pdx, fExactfit, pyHeightRubyBase, pfGlyphHit, pyProposed);
}

inline BOOL CLineOtherInfo::operator ==(const CLineFull& li)
{
    return Compare((CLineOtherInfo *)&li);
}

inline void CLineOtherInfo::operator =(const CLineFull& li)
{
    memcpy(this, (CLineOtherInfo*)&li, sizeof(CLineOtherInfo));
}

inline void CLineCore::operator =(const CLineFull& lif)
{
    memcpy(this, (CLineCore*)&lif, sizeof(CLineCore));
    //this is a good assert, it prevents break of refcounting
    //for cached CLineOtherInfo. Use CLineCore::AssignLine for
    //deep copy if CLineOtherInfo is there.
    AssertSz(_iLOI == -1, "It should never happen, use AssignLine if there is CLineOtherInfo");
}

inline void CLineCore::AssignLine(CLineFull& lif)
{
    Assert(this);
        // The cast below to CLineOtherInfo is not strictly necessary
        // Its there just to make the line of code more clearer.
    lif.CacheOtherInfo((CLineOtherInfo)lif);
    memcpy(this, (CLineCore*)&lif, sizeof(CLineCore));
}

#pragma INCMSG("--- End '_line.h'")
#else
#pragma INCMSG("*** Dup '_line.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_runptr.h ===
/*
 *  @doc INTERNAL
 *
 *  @module _RUNPTR.H -- Text run and run pointer class defintion |
 *  
 *  Original Author:    <nl>
 *      Christian Fortini
 *
 *  History: <nl>
 *      6/25/95 alexgo  Commenting and Cleanup
 */

#ifndef I__RUNPTR_H_
#define I__RUNPTR_H_
#pragma INCMSG("--- Beg '_runptr.h'")

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

MtExtern(CRunArray)
MtExtern(CRunArray_pv)

class CRunArray : public CArray<CTxtRun>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CRunArray))
    CRunArray() : CArray<CTxtRun>(Mt(CRunArray_pv)) {};
};

/*
 *  CRunPtrBase
 *
 *  @class  Base run pointer functionality.  Keeps a position within an array
 *      of text runs.
 *
 *  @devnote    Run pointers go through three different possible states :
 *
 *  NULL:   there is no data and no array (frequently a startup condition) <nl>
 *          <mf CRunPtrBsae::SetRunArray> will transition from this state to 
 *          to the Empty state.  It is typically the derived class'
 *          to define when that method should be called.
 *
 *          <md CRunPtrBase::_prgRun> == NULL <nl>
 *          <md CRunPtrBase::_iRun> == 0 <nl>
 *          <md CRunPtrBase::_ich> == 0 <nl>
 *
 *  Empty:  an array class exists, but there is no data (can happen if all 
 *          of the elements in the array are deleted). <nl>
 *          <md CRunPtrBase::_prgRun> != NULL <nl>
 *          <md CRunPtrBase::_iRun> == 0 <nl>
 *          <md CRunPtrBase::_ich> <gt>= 0 <nl>
 *          <md CRunPtrBase::_prgRun>-<gt>Elem[0] == NULL <nl>
 *
 *  Normal: the array class exists and has data <nl>
 *          <md CRunPtrBase::_prgRun> != NULL <nl>
 *          <md CRunPtrBase::_iRun> >= 0 <nl>
 *          <md CRunPtrBase::_ich> >= 0 <nl>
 *          <md CRunPtrBase::_prgRun>-<gt>Elem[<md CRunPtrBase::_iRun>] 
 *                  != NULL <nl>        
 *  
 *  Note that in order to support the empty and normal states, the actual 
 *  array element at <md CRunPtrBase::_iRun> must be explicitly fetched in
 *  any method that may need it.
 *
 *  Currently, there is no way to transition to the NULL state from any of
 *  the other states.  If we needed to, we could support that by explicitly 
 *  fetching the array from the document on demand.
 *
 *  Note that only <md CRunPtrBase::_iRun> is kept.  We could also keep 
 *  a pointer to the actual run (i.e. _pRun).  Earlier versions of this
 *  engine did in fact do this.  I've opted to not do this for several
 *  reasons: <nl>
 *      1. _pRun is *always* available by calling Elem(_iRun).
 *      Therefore, there is nominally no need to keep both _iRun and _pRun.<nl>
 *      2. Run pointers are typically used to either just move around
 *      and then fetch data or move and fetch data every time (like during 
 *      a measuring loop).  In the former case, there is no need to always
 *      bind _pRun; you can just do it on demand.  In the latter case, the
 *      two models are equivalent.  
 *
 */

class CRunPtrBase
{
private:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))

public:
    
    WHEN_DBG( BOOL Invariant ( ) const; )
    WHEN_DBG( long GetTotalCch ( ) const; )

    CRunPtrBase ( CRunArray * prgRun )
    {
        _prgRun = prgRun; 
        __iRun = 0; 
        __ich = 0; 
    }
    
    CRunPtrBase ( CRunPtrBase & rp )
    {
        *this = rp;
    }

    void SetRunArray ( CRunArray * prgRun )
    {
        _prgRun = prgRun;
    }
                                    
    BOOL SetRun( long iRun, long ich );

    BOOL NextRun ( );
    BOOL PrevRun ( );
    
    CTxtRun * GetRunRel ( long cRun ) const
    {
        Assert( _prgRun );
        
        return _prgRun->Elem( GetIRun() + cRun );
    }
    
    long NumRuns ( ) const
    {
        return _prgRun->Count();
    }

    BOOL OnLastRun ( )
    {
        Assert( GetIRun() < NumRuns() );
        
        return NumRuns() == 0 || GetIRun() == NumRuns() - 1;
    }

    BOOL OnFirstRun ( )
    {
        Assert( GetIRun() < NumRuns() );
        
        return GetIRun() == 0;
    }

    DWORD   BindToCp ( DWORD cp );
    
    DWORD   GetCp ( ) const;
    
    long    AdvanceCp ( long cch );
    
    BOOL    AdjustBackward ( );

    BOOL    AdjustForward ( );

    long    GetCchRemaining ( ) const { return GetRunRel( 0 )->_cch - GetIch(); }

    long    GetCchRun() { return GetRunRel( 0 )->_cch; }

    long GetIRun ( ) const { return __iRun; }
    
    void SetIRun ( long iRunNew )
    {
        __iRun = iRunNew;
    }

    long GetIch ( ) const { return __ich; }
    
    void SetIch ( long ichNew )
    {
        __ich = ichNew;
    }

    BOOL IsValid() const
    {
        return __iRun < long( _prgRun->Count() );
    }

protected:
    
    CRunArray * _prgRun;

private:
    
    //
    // WARNING: Do NOT access these members directly. Use accessors.
    //
    
    long __iRun;
    long __ich;
};


/*
 *  CRunPtr (template)
 *
 *  @class  a template over CRunPtrBase allowing for type-safe versions of
 *      run pointers
 * 
 *  @tcarg  class   | CElem | run array class to be used
 *
 *  @base   public | CRunPtrBase
 */
template <class CRunElem>
class CRunPtr : public CRunPtrBase
{
private:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))

public:
    
    CRunPtr() : CRunPtrBase( 0 ) { }
    
    CRunPtr ( CRunArray * prgRun ) : CRunPtrBase ( prgRun ) { }
    
    CRunPtr ( CRunPtrBase & rp ) : CRunPtrBase ( rp ) { }

    // Array management 
                                        
    CRunElem * Add (DWORD cRun, DWORD *pielIns)    //@cmember Add <p cRun>     
    {                                           // elements at end of array
        Assert(_prgRun != NULL);
        return (CRunElem *)_prgRun->Add(cRun, pielIns);
    }
                                        
    CRunElem * Insert (DWORD cRun)                 //@cmember Insert <p cRun>
    {                                           // elements at current pos
        Assert(_prgRun != NULL);
        return (CRunElem *)_prgRun->Insert(GetIRun(), cRun);
    }
                                        
    CRunElem * InsertAtRel (long dRun, DWORD cRun)
    {                                           // elements at current pos
        Assert(_prgRun != NULL);
        return (CRunElem *)_prgRun->Insert(GetIRun() + dRun, cRun);
    }

    void RemoveRel (LONG cRun, ArrayFlag flag)  //@cmember Remove <p cRun>
    {                                           // elements at current pos
         Assert(_prgRun != NULL);
         _prgRun->Remove (GetIRun(), cRun, flag);
    }
    
    void RemoveAbs ( long iRun, LONG cRun, ArrayFlag flag )
    {
         Assert(_prgRun != NULL);
         _prgRun->Remove( iRun, cRun, flag );
    } 
                                        //@cmember  Replace <p cRun> elements
                                        // at current position with those
                                        // from <p parRun>
    BOOL Replace (LONG cRun, CRunArray *parRun)
    {
        Assert(_prgRun != NULL);
        return _prgRun->Replace(GetIRun(), cRun, parRun);
    }

    CRunElem * GetRunAbs ( LONG iRun ) const
    {
        Assert( _prgRun != NULL );
        return (CRunElem *) _prgRun->Elem( iRun );
    }

    CRunElem * GetRunRel ( LONG dRun ) const
    {
        return (CRunElem *) CRunPtrBase::GetRunRel( dRun );
    }

    CRunElem * GetCurrRun ( void ) const
    {
        return GetRunAbs( GetIRun() );
    }
    
    CRunElem * GetPrevRun ( )
    {
        Assert( GetIRun() == 0 || (GetIRun() >= 0 && GetIRun() < NumRuns()) );

        if (GetIRun() == 0)
            return NULL;

        return GetRunAbs(GetIRun() - 1);
    }
    
    CRunElem * GetNextRun ( )
    {
        long nRuns = NumRuns();
        long iRun = GetIRun() + 1;

        Assert( GetIRun() == 0 || (GetIRun() >= 0 && GetIRun() < nRuns) );

        if (nRuns == 0 || iRun == nRuns)
            return NULL;

        return GetRunAbs( iRun );
    }
};

#pragma INCMSG("--- End '_runptr.h'")
#else
#pragma INCMSG("*** Dup '_runptr.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_ime.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _ime.h -- support for IME APIs |
 *
 *  Purpose:
 *      Most everything to do with FE composition string editing passes
 *      through here.
 *
 *  Authors: <nl>
 *      Jon Matousek  <nl>
 *      Justin Voskuhl  <nl>
 *      Hon Wah Chan  <nl>
 *
 *  History: <nl>
 *      10/18/1995      jonmat  Cleaned up level 2 code and converted it into
 *                              a class hierarchy supporting level 3.
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 *
 */

#ifndef I__IME_H_
#define I__IME_H_
#pragma INCMSG("--- Beg '_ime.h'")

#ifndef NO_IME
class CFlowLayout;

// defines for some FE Codepages
#define _JAPAN_CP           932
#define _KOREAN_CP          949
#define _CHINESE_TRAD_CP    950
#define _CHINESE_SIM_CP     936

// special virtual keys copied from Japan MSVC ime.h
#define VK_KANA         0x15
#define VK_KANJI        0x19

// defines for IME Level 2 and 3
#define IME_LEVEL_2     2
#define IME_LEVEL_3     3
#define IME_PROTECTED   4


extern BOOL forceLevel2;    // Force level 2 composition processing if TRUE.

MtExtern(CIme)

/*
 *  IME
 *
 *  @class  base class for IME support.
 *
 *  @devnote
 *      For level 2, at caret IMEs, the IME will draw a window directly over the text giving the
 *      impression that the text is being processed by the application--this is called pseudo inline.
 *      All UI is handled by the IME. This mode is currenlty bypassed in favor of level 3 true inline (TI);
 *      however, it would be trivial to allow a user preference to select this mode. Some IMEs may have
 *      a "special" UI, in which case level 3 TI is *NOT* used, necessitating level 2.
 *
 *      For level 2, near caret IMEs, the IME will draw a very small and obvious window near the current
 *      caret position in the document. This currently occurs for PRC(?) and Taiwan.
 *      All UI is handled by the IME.
 *
 *      For level 3, at caret IMEs, the composition string is drawn by the application, which is called
 *      true inline, bypassing the level 2 "composition window".
 *      Currently, we allow the IME to support all remaining UI *except* drawing of the composition string.
 */
class CIme
{
    friend LRESULT OnGetIMECompositionMode ( CFlowLayout &ts );
    friend BOOL IMECheckGetInvertRange(CFlowLayout *ts, LONG *, LONG *);
    friend HRESULT CompositionStringGlue ( const LPARAM lparam, CFlowLayout &ts );
    friend HRESULT EndCompositionGlue ( CFlowLayout &ts );
    friend void CheckDestroyIME ( CFlowLayout &ts );


    //@access   Protected data
    protected:
    INT       _imeLevel;                            //@cmember IME Level 2 or 3
    BOOL      _fKorean;                             //@cmember In Hangeul mode?

    LONG      _iFormatSave;                         //@cmember  format before we started IME composition mode.

    BOOL      _fHoldNotify;                         //@cmember hold notify until we have result string

    INT       _dxCaret;                             //@cmember current IME caret width
    BOOL      _fIgnoreIMEChar;                      //@cmember Level 2 IME use to eat WM_IME_CHAR message

    public:
#ifdef MERGEFUN
    CTxtRange *_prgUncommitted;                     //Current uncommitted range, for the CRenderer
    CTxtRange *_prgInverted;                        //Current inverted range, for the CRenderer
#endif

    //@access   Public methods
    public:
    BOOL    _fDestroy;                              //@cmember set when object wishes to be deleted.
    INT     _compMessageRefCount;                   //@cmember so as not to delete if recursed.
    BOOL    _fUnderLineMode;                        //@cmember save original Underline mode

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CIme))

                                                    //@cmember  Handle WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts ) = 0;
                                                    //@cmember  Handle WM_IME_COMPOSITION and WM_IME_ENDCOMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts ) = 0;
                                                    //@cmember  Handle post WM_IME_CHAR to update comp window.
    virtual void PostIMEChar( CFlowLayout &ts ) = 0;

                                                    //@cmember  Handle WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts ) = 0;

    enum TerminateMode
    {
            TERMINATE_NORMAL = 1,
            TERMINATE_FORCECANCEL = 2
    };

    void    TerminateIMEComposition(CFlowLayout &ts,
                CIme::TerminateMode mode);          //@cmember  Terminate current IME composition session.

    BOOL    IsKoreanMode() { return _fKorean; }     //@cmember  check for Korean mode

    BOOL    HoldNotify() { return _fHoldNotify; }   //@cmember  check if we want to hold sending change notification
                                                    //@cmember  check if we need to ignore WM_IME_CHAR messages
    BOOL    IgnoreIMECharMsg() { return _fIgnoreIMEChar; }

    INT     GetIMECaretWidth() { return _dxCaret; } //@cmember  return current caret width
    void    SetIMECaretWidth(INT dxCaretWidth)
    {
        _dxCaret = dxCaretWidth;                    //@cmember  setup current caret width
    }
    static  void    CheckKeyboardFontMatching ( UINT cp, CFlowLayout &ts, LONG *iFormat ); //@cmember  Check current font/keyboard matching.

    INT     GetIMELevel ()                          //@cmember  Return the current IME level.
    {
        return _imeLevel;
    }

    BOOL    IsProtected()
    {
        return _imeLevel == IME_PROTECTED;
    }

    //@access   Protected methods
    protected:                                      //@cmember  Get composition string, convert to unicode.

    static INT GetCompositionStringInfo( HIMC hIMC, DWORD dwIndex, WCHAR *uniCompStr, INT cchUniCompStr, BYTE *attrib, INT cbAttrib, LONG *cursorCP, LONG *cchAttrib );
    HRESULT CheckInsertResultString ( const LPARAM lparam, CFlowLayout &ts );


    void    SetCompositionFont ( CFlowLayout &ts, BOOL *pbUnderLineMode ); //@cmember  Setup for level 2 and 3 composition and candidate window's font.
    void    SetCompositionForm ( CFlowLayout &ts );    //@cmember  Setup for level 2 IME composition window's position.

public:
    CIme( CFlowLayout &ts );
    CIme(); // for CIme_Protected;
    ~CIme();
};

/*
 *  IME_Lev2
 *
 *  @class  Level 2 IME support.
 *
 */
class CIme_Lev2 : public CIme
{

    //@access   Public methods
    public:                                         //@cmember  Handle level 2 WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts );
                                                    //@cmember  Handle level 2 WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
                                                    //@cmember  Handle post WM_IME_CHAR to update comp window.
    virtual void PostIMEChar( CFlowLayout &ts );
                                                    //@cmember  Handle level 2 WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts );

    CIme_Lev2( CFlowLayout &ts );
    ~CIme_Lev2();
};

/*
 *  IME_PROTECTED
 *
 *  @class  IME_PROTECTED
 *
 */
class CIme_Protected : public CIme
{
    //@access   Public methods
    public:                                         //@cmember  Handle level 2 WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts )
        {_imeLevel  = IME_PROTECTED; return S_OK;}
                                                    //@cmember  Handle level 2 WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
                                                    //@cmember  Handle post WM_IME_CHAR to update comp window.
    virtual void PostIMEChar( CFlowLayout &ts )
        {}
                                                    //@cmember  Handle level 2 WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts )
        {return S_FALSE;}
};

/*
 *  IME_Lev3
 *
 *  @class  Level 3 IME support.
 *
 */
class CIme_Lev3 : public CIme_Lev2
{
    //@access   Private data
    private:

    //@access   Protected data
    protected:

    //@access   Public methods
    public:                                         //@cmember  Handle level 3 WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts );
                                                    //@cmember  Handle level 3 WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
                                                    //@cmember  Handle level 3 WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts );

    BOOL            SetCompositionStyle (   CFlowLayout &ts, CCharFormat &CF, UINT attribute );

    CIme_Lev3( CFlowLayout &ts ) : CIme_Lev2 ( ts ) {};

};

/*
 *  Special IME_Lev3 for Korean Hangeul -> Hanja conversion
 *
 *  @class  Hangual IME support.
 *
 */
class CIme_HangeulToHanja : public CIme_Lev3
{
    //@access   Private data
    private:
    LONG    _xWidth;                                //@cmember width of Korean Hangeul char

    public:
    CIme_HangeulToHanja( CFlowLayout &ts, LONG xWdith );
                                                    //@cmember  Handle Hangeul WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts );
                                                    //@cmember  Handle Hangeul WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
};

// CImeDummy class, exists solely to handle the case where we get a compsition string
// and we have no CIme-derived class instantiated.

class CImeDummy : public CIme
{
public:
    virtual HRESULT StartComposition( CFlowLayout &ts ) { RRETURN(E_FAIL); }
    virtual HRESULT CompositionString( const LPARAM lparam,
                                       CFlowLayout &ts ) { RRETURN(E_FAIL); }
    virtual void    PostIMEChar( CFlowLayout &ts ) {};
    virtual HRESULT IMENotify (const WPARAM wparam,
                               const LPARAM lparam,
                               CFlowLayout &ts ) { RRETURN(E_FAIL); }

    CImeDummy( CFlowLayout &ts ) : CIme( ts ) {};
};

// Glue functions to call the respective methods of an IME object stored in the ts.
HRESULT StartCompositionGlue ( CFlowLayout &ts, BOOL IsProtected );
HRESULT CompositionStringGlue ( const LPARAM lparam, CFlowLayout &ts );
HRESULT EndCompositionGlue ( CFlowLayout &ts );
void    PostIMECharGlue ( CFlowLayout &ts );
HRESULT IMENotifyGlue ( const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts ); // @parm the containing text edit.

// IME helper functions.
void    IMECompositionFull ( CFlowLayout &ts );
LRESULT OnGetIMECompositionMode ( CFlowLayout &ts );
BOOL    IMECheckGetInvertRange(CFlowLayout *ts, LONG *, LONG *, LONG *, LONG *);
void    CheckDestroyIME ( CFlowLayout &ts );
BOOL    IMEHangeulToHanja ( CFlowLayout &ts );

/*
 *  IgnoreIMEInput()
 *
 *  @devnote
 *      This is to ignore the IME character.  By translating
 *      message with result from pImmGetVirtualKey, we
 *      will not receive START_COMPOSITION message.  However,
 *      if the host has already called TranslateMessage, then,
 *      we will let START_COMPOSITION message to come in and
 *      let IME_PROTECTED class to do the work.
 */
HRESULT IgnoreIMEInput( HWND hwnd, CFlowLayout &ts, DWORD lParam );
#endif // !NO_IME

#pragma INCMSG("--- End '_ime.h'")
#else
#pragma INCMSG("*** Dup '_ime.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_txtsave.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       _txtsave.h
//
//  Contents:   Objects used for saving forms to the stream
//
//  Classes:    CTextSaver
//              CRangeSaver
//
//----------------------------------------------------------------------------

#ifndef I__TXTSAVE_H_
#define I__TXTSAVE_H_
#pragma INCMSG("--- Beg '_txtsave.h'")

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

class CStreamWriteBuff;
class CElement;

//
//  Flags for use with the range saver
//
enum
{
    RSF_CFHTML_HEADER =         0x1,    // include CF-HTML header
    RSF_FRAGMENT =              0x2,    // include the fragment
    RSF_CONTEXT =               0x4,    // include the context
    RSF_FOR_RTF_CONV =          0x8,    // mode friendly to the RTF converter
    RSF_SELECTION =             0x10,   // include the selection
    RSF_NO_ENTITIZE_UNKNOWN =   0x20,   // do not entitize unknown characters
    RSF_NO_IE4_COMPAT_SEL =     0x40,   // don't compute selection according to IE4 rules
    RSF_NO_IE4_COMPAT_FRAG =    0x80    // don't compute fragment according to IE4 rules
};

#define RSF_CFHTML (RSF_CFHTML_HEADER | RSF_FRAGMENT | RSF_SELECTION | RSF_CONTEXT)
#define RSF_HTML   (RSF_FRAGMENT | RSF_SELECTION | RSF_CONTEXT)

//+---------------------------------------------------------------------------
//
//  Class:      CRangeSaver
//
//  Synopsis:   This class is designed to write a given range to a stream
//              with various formatting options.
//
//----------------------------------------------------------------------------

class CRangeSaver : public CTreeSaver
{
public:
    CRangeSaver(
        CMarkupPointer *    pLeft,
        CMarkupPointer *    pRight,
        DWORD               dwFlags,
        CStreamWriteBuff *  pswb,
        CMarkup *           pMarkup,
        CElement *          pelContainer = NULL );

    HRESULT Save();

    HRESULT SaveSegmentList(ISegmentList*  pSegmentList, CMarkup*  pMarkup);

private:

    void Initialize(
        CMarkupPointer *    pLeft,
        CMarkupPointer *    pRight,
        DWORD               dwFlags,
        CStreamWriteBuff *  pswb,
        CMarkup *           pMarkup,
        CElement *          pelContainer );

protected:
    //
    // CF-HTML header offset information
    //
    struct tagCFHTMLHeader
    {
        LONG iHTMLStart, iHTMLEnd;
        LONG iFragmentStart, iFragmentEnd;
        LONG iSelectionStart, iSelectionEnd;
    }
    _header;

    HRESULT SaveSelection( BOOL fEnd );

    //
    // Internal helpers
    //
    HRESULT GetStmOffset(LONG * plOffset);
    HRESULT SetStmOffset(LONG lOffset);
    HRESULT WriteCFHTMLHeader();
    HRESULT WriteOpenContext();
    HRESULT WriteCloseContext();

    void    DoIE4SelectionCollapse();
    void    ComputeIE4Fragment();
    void    ComputeIE4Selection();

    DWORD       _dwFlags;
};

#pragma INCMSG("--- End '_txtsave.h'")
#else
#pragma INCMSG("*** Dup '_txtsave.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\cfpf.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module CFPF.C -- -- RichEdit CCharFormat and CParaFormat Classes |
 *
 *  Created: <nl>
 *      9/1995 -- Murray Sargent <nl>
 *
 *  @devnote
 *      The this ptr for all methods points to an internal format class, i.e.,
 *      either a CCharFormat or a CParaFormat, which uses the cbSize field as
 *      a reference count.  The pCF or pPF argument points at an external
 *      CCharFormat or CParaFormat class, that is, pCF->cbSize and pPF->cbSize
 *      give the size of their structure.  The code still assumes that both
 *      internal and external forms are derived from the CHARFORMAT(2) and
 *      PARAFORMAT(2) API structures, so some redesign would be necessary to
 *      obtain a more space-efficient internal form.
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FCACHE_HXX_
#define X_FCACHE_HXX_
#include "fcache.hxx"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_TABLE_H_
#define X_TABLE_H_
#include "table.h"
#endif

#ifndef X_CAPTION_H_
#define X_CAPTION_H_
#include "caption.h"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TOMCONST_H_
#define X_TOMCONST_H_
#include "tomconst.h"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

MtExtern(CFancyFormat_pszFilters);

DeclareTag(tagRecalcStyle, "Recalc Style", "Recalc Style trace")

extern DWORD g_dwPlatformID;
extern BOOL g_fInWin98Discover;



struct
{
    const TCHAR* szGenericFamily;
    DWORD        dwWindowsFamily;
}
const s_fontFamilyMap[] =
{
    { _T("sans-serif"), FF_SWISS },
    { _T("serif"),      FF_ROMAN },
    { _T("monospace"),  FF_MODERN },
    { _T("cursive"),    FF_SCRIPT },
    { _T("fantasy"),    FF_DECORATIVE }
};


/*
 *  CCharFormat::Compare(pCF)
 *
 *  @mfunc
 *      Compare this CCharFormat to *<p pCF>
 *
 *  @rdesc
 *      TRUE if they are the same
 *
 *  @devnote
 *      Compare simple types in memcmp.  If equal, compare complex ones
 */
BOOL CCharFormat::Compare (const CCharFormat *pCF) const
{
    BOOL fRet;

    Assert( _bCrcFont      == ComputeFontCrc() );
    Assert( pCF->_bCrcFont == pCF->ComputeFontCrc() );

    fRet = memcmp(this, pCF, offsetof(CCharFormat, _bCrcFont));

    // If the return value is TRUE then the CRC's should be the same.
    // That is, either the return value is FALSE, or the CRC's are the same.
    Assert( (!!fRet) || (_bCrcFont == pCF->_bCrcFont) );

    return (!fRet);
}


/*
 *  CCharFormat::CompareForLayout(pCF)
 *
 *  @mfunc
 *      Compare this CCharFormat to *<p pCF> and return FALSE if any
 *      attribute generally requiring a re-layout is different.
 *
 *  @rdesc
 *      TRUE if charformats are closed enough to not require relayout
 */
BOOL CCharFormat::CompareForLayout (const CCharFormat *pCF) const
{
    BYTE * pb1, * pb2;

    Assert( _bCrcFont      == ComputeFontCrc() );
    Assert( pCF->_bCrcFont == pCF->ComputeFontCrc() );

    if (_fNoBreak          != pCF->_fNoBreak          ||
        _fNoBreakInner     != pCF->_fNoBreakInner     ||
        _fVisibilityHidden != pCF->_fVisibilityHidden ||
        _fRelative         != pCF->_fRelative)
        return FALSE;

    pb1 = (BYTE*) &((CCharFormat*)this)->_wFontSpecificFlags();
    pb2 = (BYTE*) &((CCharFormat*)pCF)->_wFontSpecificFlags();

    if(memcmp(pb1, pb2, offsetof(CCharFormat, _ccvTextColor) -
                        offsetof(CCharFormat,
                                 _wFontSpecificFlags())))
        return FALSE;

    if( _latmFaceName != pCF->_latmFaceName )
        return FALSE;

    return TRUE;
}


/*
 *  CCharFormat::CompareForLikeFormat(pCF)
 *
 *  @mfunc
 *      Compare this CCharFormat to *<p pCF> and return FALSE if any
 *      attribute generally requiring a different Cccs is found.
 *
 *  @rdesc
 *      TRUE if charformats are close enough to not require a different Cccs.
 *      This is generally used in scripts like Arabic that have connecting
 *      characters
 */
BOOL CCharFormat::CompareForLikeFormat(const CCharFormat *pCF) const
{
    BYTE * pb1, * pb2;

    Assert(pCF != NULL);
    Assert(_bCrcFont == ComputeFontCrc());
    Assert(pCF->_bCrcFont == pCF->ComputeFontCrc());

    // 86212: superscript does not cause a different crc to be made. Check
    // font specific flags to make sure we interrupt shaping
    if (_bCrcFont == pCF->_bCrcFont)
    {
        pb1 = (BYTE*) &((CCharFormat*)this)->_wFontSpecificFlags();
        pb2 = (BYTE*) &((CCharFormat*)pCF)->_wFontSpecificFlags();

        if(memcmp(pb1, pb2, offsetof(CCharFormat, _ccvTextColor) -
                            offsetof(CCharFormat,
                                     _wFontSpecificFlags())))
        {
            return FALSE;
        }
        return TRUE;
    }

    return FALSE;
}


/*
 *  CCharFormat::InitDefault(hfont)
 *
 *  @mfunc
 *      Returns the font family name
 *
 *
 *  @rdesc
 *      HRESULT = (if success) ? string : NULL
 */

const TCHAR *  CCharFormat::GetFamilyName() const
{
    int     n;

    for( n = 0; n < ARRAY_SIZE( s_fontFamilyMap ); ++n )
    {
        if(_bPitchAndFamily == s_fontFamilyMap[ n ].dwWindowsFamily)
            return s_fontFamilyMap[ n ].szGenericFamily;
    }

    return NULL;
}


/*
 *  CCharFormat::InitDefault(hfont)
 *
 *  @mfunc
 *      Initialize this CCharFormat with information coming from the font
 *      <p hfont>
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CCharFormat::InitDefault (
    HFONT hfont)        //@parm Handle to font info to use
{
    LONG twips;
    LOGFONT lf;

    memset((LPBYTE)this, 0, sizeof(CCharFormat));

    // 0 enum value means normal
    _cuvLetterSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));
    _cuvWordSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));

    // If hfont isn't defined, get LOGFONT for default font
    if (!hfont)
        hfont = (HFONT)GetStockObject(SYSTEM_FONT);

    // Get LOGFONT for passed hfont
    if (!GetObject(hfont, sizeof(LOGFONT), &lf))
        return E_FAIL;

    /* COMPATIBILITY ISSUE:
     * RichEdit 1.0 selects hfont into a screen DC, gets the TEXTMETRIC,
     * and uses tm.tmHeight - tm.tmInternalLeading instead of lf.lfHeight
     * in the following. The following is simpler and since we have broken
     * backward compatibility on line/page breaks, I've left it (murrays).
     */

    //// NOTE (cthrash) g_sizePixelsPerInch is only valid for the screen.
    // twips = MulDivQuick( lf.lfHeight, TWIPS_PER_INCH, g_sizePixelsPerInch.cy );
    // NOTE (mikhaill) -- changed MulDivQuick to TwipsFromDeviceY() during
    // CDocScaleInfo cleanup. Kept comments above, because "g_uiDisplay is only
    // valid for the screen" would sound strange.

    twips = g_uiDisplay.TwipsFromDeviceY(lf.lfHeight);

    if(twips < 0)
        twips = - twips;

    SetHeightInTwips( twips );

    _fBold = lf.lfWeight >= FW_BOLD;
    _fItalic = lf.lfItalic;
    _fUnderline = lf.lfUnderline;
    _fStrikeOut = lf.lfStrikeOut;

    _wWeight = (WORD)lf.lfWeight;

    _bCharSet = lf.lfCharSet;
    _fNarrow = IsNarrowCharSet(lf.lfCharSet);
    _bPitchAndFamily = lf.lfPitchAndFamily;

    SetFaceName(lf.lfFaceName);

    // 0 enum value means 'below'
    _bTextUnderlinePosition = styleTextUnderlinePositionAuto;

    return NOERROR;
}

TCHAR g_achFaceName[LF_FACESIZE];
LONG g_latmFaceName = 0;

/*
 *  CCharFormat::InitDefault( OPTIONSETTINGS *pOS, BOOL fKeepFaceIntact )
 *
 *  @mfunc
 *      Initialize this CCharFormat with given typeface and size
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT
CCharFormat::InitDefault (
    OPTIONSETTINGS * pOS,
    CODEPAGESETTINGS * pCS,
    BOOL fKeepFaceIntact )
{
    if (fKeepFaceIntact)
    {
        LONG latmOldFaceName= _latmFaceName;
        BYTE bOldCharSet = _bCharSet;
        BYTE bPitchAndFamily = _bPitchAndFamily;
        BOOL fNarrow = _fNarrow;
        BOOL fExplicitFace = _fExplicitFace;

        // Zero out structure

        memset((LPBYTE)this, 0, sizeof(CCharFormat));

        // restore cached values
        
        SetFaceNameAtom(latmOldFaceName);
        _bCharSet = bOldCharSet;
        _bPitchAndFamily = bPitchAndFamily;
        _fNarrow = fNarrow;
        _fExplicitFace = fExplicitFace;
    }
    else
    {
        // Zero out structure

        memset((LPBYTE)this, 0, sizeof(CCharFormat));

        if (pCS)
        {
            SetFaceNameAtom(pCS->latmPropFontFace);
            _bCharSet = pCS->bCharSet;
            _fNarrow = IsNarrowCharSet(_bCharSet);
        }
        else
        {
            if (g_latmFaceName == 0)
            {
                Verify(LoadString(GetResourceHInst(), IDS_HTMLDEFAULTFONT, g_achFaceName, LF_FACESIZE));
                g_latmFaceName = fc().GetAtomFromFaceName(g_achFaceName);
            }

            SetFaceNameAtom(g_latmFaceName);
            _bCharSet = DEFAULT_CHARSET;
        }

        // These are values are all zero.
        // _bPitchAndFamily = DEFAULT_PITCH;
        // _fExplicitFace = FALSE;
    }

    _cuvLetterSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));
    _cuvWordSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));

    SetHeightInTwips( ConvertHtmlSizeToTwips(3) );

    _ccvTextColor.SetValue( pOS ? pOS->crText()
                                : GetSysColorQuick(COLOR_BTNTEXT),
                           FALSE);

    _wWeight = 400;

    // 0 enum value means 'below'
    _bTextUnderlinePosition = styleTextUnderlinePositionAuto;

    return NOERROR;
}

/*
 *  CCharFormat::ComputeCrc()
 *
 *  @mfunc
 *      For fast font cache lookup, calculate CRC.
 *
 *  @devnote
 *      The font cache stores anything that has to
 *      do with measurement of metrics. Any font attribute
 *      that does not affect this should NOT be counted
 *      in the CRC; things like underline and color are not counted.
 */

WORD
CCharFormat::ComputeCrc() const
{
    BYTE    bCrc = 0;
    BYTE*   pb;
    BYTE *  pend = (BYTE*)&_bCrcFont;

    for (pb = (BYTE*)&((CCharFormat*)this)->_wFlags(); pb < pend; pb++)
        bCrc ^= *pb;

    return (WORD)bCrc;
}


//+----------------------------------------------------------------------------
// CCharFormat::ComuteFontCrc
//
// Synopsis:    Compute the font specific crc, assumes all the members that
//              effect the font are grouped together and are between
//              _wFontSpecificFlags and _bCursorIdx.
//              It is important the we do not have non specific
//              members in between to avoid creating fonts unnecessarily.
//
//-----------------------------------------------------------------------------

BYTE
CCharFormat::ComputeFontCrc() const
{
    BYTE bCrc, * pb, * pbend;

    Assert( & ((CCharFormat*)this)->_wFlags() < & ((CCharFormat*)this)->_wFontSpecificFlags() );

    bCrc = 0;

    pb    = (BYTE*) & ((CCharFormat*)this)->_wFontSpecificFlags();
    pbend = (BYTE*) & _bCursorIdx;

    for ( ; pb < pbend ; pb++ )
        bCrc ^= *pb;

    return bCrc;
}

void
CCharFormat::SetHeightInTwips(LONG twips)
{
    _fSizeDontScale = FALSE;
    _yHeight = twips;
}

void
CCharFormat::SetHeightInNonscalingTwips(LONG twips)
{
    _fSizeDontScale = TRUE;
    _yHeight = twips;
}

void
CCharFormat::ChangeHeightRelative(int diff)
{
    // This is a crude approximation.

    _yHeight = ConvertHtmlSizeToTwips( ConvertTwipsToHtmlSize( _yHeight ) + diff );
}

static TwipsFromHtmlSize[9][7] =
{
// scale fonts up for TV
#ifndef NTSC
  { 120, 160, 180, 200, 240, 320, 480 },
#endif
  { 140, 180, 200, 240, 320, 400, 600 },
  { 151, 200, 240, 271, 360, 480, 720 },
  { 200, 240, 280, 320, 400, 560, 840 },
  { 240, 280, 320, 360, 480, 640, 960 }
// scale fonts up for TV
#ifdef NTSC
  ,
  { 280, 320, 360, 400, 560, 720, 1080 }
#endif
  ,
  { 320, 360, 400, 440, 600, 760, 1120 }
  ,
  { 360, 400, 440, 480, 640, 800, 1160 }
  ,
  { 400, 440, 480, 520, 680, 840, 1200 }
  ,
  { 440, 480, 520, 560, 720, 880, 1240 }
};

static
LONG ScaleTwips( LONG iTwips, LONG iBaseLine, LONG iBumpDown )
{
    // iTwips:    the initial (unscaled) size in twips
    // iBaseLine: the baseline to use to scale (should be between 0-4)
    // iBumpDown: how many units to bump down (should be betweem 0-2)

    // If we are in the default baseline font and do not want to bump down, we do not
    //  need to scale.
    if( iBaseLine == BASELINEFONTDEFAULT && !iBumpDown )
        return iTwips;

    LONG lHtmlSize = ConvertTwipsToHtmlSize( iTwips );

    if( lHtmlSize > 7 || lHtmlSize <= iBumpDown ||
            TwipsFromHtmlSize[2][lHtmlSize - 1] != iTwips )
        // If we are out of range or do not match a table entry, scale manually
        return MulDivQuick( iTwips, iBaseLine + 4 - iBumpDown, 6 );
    else
    {
        // Scale according to IE table above.
        // the ratio is roughly as follows (from the IE table):
        //
        //   smallest small medium large largest
        //       1     5/4   6/4    7/4    8/4
        //
        // so if we scale that to medium, we have
        //
        //   smallest small medium large largest
        //      4/6    5/6     1    7/6    8/6

        lHtmlSize = max( 1L, lHtmlSize - iBumpDown );
        return TwipsFromHtmlSize[iBaseLine][lHtmlSize-1];
    }
}

LONG
CCharFormat::GetHeightInTwipsEx(LONG yHeight, BOOL fSubSuperSized, CDoc * pDoc) const
{
    if (!pDoc)
        return 0;

    LONG twips;
    LONG iBaseline;
    LONG iBumpDown = 0;

    // If we want super or subscript, we want to bump the font size down one notch
    if (fSubSuperSized)
        ++iBumpDown;

    if (_fSCBumpSizeDown)
        ++iBumpDown;

    if (_fSizeDontScale)
    {
        // For intrinsics, we don't want to change the pitch size
        // regardless of the z1oom factor (lBaseline).  We may want
        // to bump down if we get super or subscript, however.
        iBaseline = BASELINEFONTDEFAULT;
    }
    else
    {
        if (_fBumpSizeDown)
            ++iBumpDown;

        // If CDoc is a HTML dialog, use default font size.
        // NOTE (greglett)
        // With print preview, we want this info to be switchable per markup.
        // The baseline font info is still global information - one value per instance.
        // However, whether or not to apply that default is a per-markup thing (template vs. content document).
        // We could solve by putting a _sFontScale on CMarkup or such, or maybe use _fSizeDontScale above.
        // That also allows us to remove the below check in this ubercommonly called funcion - yay!
        if (    (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
            &&  !pDoc->IsPrintDialog() )
        {
            iBaseline = BASELINEFONTDEFAULT;
        }
        else
        {
            iBaseline = pDoc->GetBaselineFont();
            Assert(pDoc->GetBaselineFont() >= 0 && pDoc->GetBaselineFont() <= 4);
        }
    }

    twips = ScaleTwips(yHeight, iBaseline * (g_fHighContrastMode ? 2 : 1), iBumpDown);
    Assert(twips >=0 && "twips height is negative");

    return twips;
}

LONG
CCharFormat::GetHeightInPixels(XHDC xhdc, CDocInfo * pdci) const
{
    int heightTwips = GetHeightInTwips(pdci->_pDoc);
    return pdci->DeviceFromTwipsY(heightTwips);
}

LONG
CCharFormat::GetHeightInPixelsEx(LONG yHeight, CDocInfo * pdci) const
{
    // Convert yHeight from device pixels to twips
    LONG lTwips = pdci->TwipsFromDeviceY(yHeight);

    // Scale twips
    lTwips = GetHeightInTwipsEx(lTwips, _fSubSuperSized, pdci->_pDoc);

    // Convert twips back to initial units
    return pdci->DeviceFromTwipsY(lTwips);

}


//------------------------- CParaFormat Class -----------------------------------

/*
 *  CParaFormat::AddTab(tbPos, tbAln, tbLdr)
 *
 *  @mfunc
 *      Add tabstop at position <p tbPos>, alignment type <p tbAln>, and
 *      leader style <p tbLdr>
 *
 *  @rdesc
 *      (success) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Tab struct that overlays LONG in internal rgxTabs is
 *
 *          DWORD   tabPos : 24;
 *          DWORD   tabType : 4;
 *          DWORD   tabLeader : 4;
 */
HRESULT CParaFormat::AddTab (
    LONG    tbPos,      //@parm New tab position
    LONG    tbAln,      //@parm New tab alignment type
    LONG    tbLdr)      //@parm New tab leader style
{
    LONG    Count   = _cTabCount;
    LONG    iTab;
    LONG    tbPosCurrent;

    if ((DWORD)tbAln > tomAlignBar ||               // Validate arguments
        (DWORD)tbLdr > tomLines ||                  // Comparing DWORDs causes
        (DWORD)tbPos > 0xffffff || !tbPos)          //  negative values to be
    {                                               //  treated as invalid
        return E_INVALIDARG;
    }

    LONG tbValue = tbPos + (tbAln << 24) + (tbLdr << 28);

    for(iTab = 0; iTab < Count &&                   // Determine where to insert
        tbPos > GetTabPos(_rgxTabs[iTab]);           //  insert new tabstop
        iTab++) ;

    if(iTab < MAX_TAB_STOPS)
    {
        tbPosCurrent = GetTabPos(_rgxTabs[iTab]);
        if(iTab == Count || tbPosCurrent != tbPos)
        {
            MoveMemory(&_rgxTabs[iTab + 1],          // Shift array up
                &_rgxTabs[iTab],                     //  (unless iTab = Count)
                (Count - iTab)*sizeof(LONG));

            if(Count < MAX_TAB_STOPS)               // If there's room,
            {
                _rgxTabs[iTab] = tbValue;            //  store new tab stop,
                _cTabCount++;                        //  increment tab count,
                return NOERROR;                     //  signal no error
            }
        }
        else if(tbPos == tbPosCurrent)              // Update tab since leader
        {                                           //  style or alignment may
            _rgxTabs[iTab] = tbValue;                //  have changed
            return NOERROR;
        }
    }
    return S_FALSE;
}

/*
 *  CParaFormat::Compare(pPF)
 *
 *  @mfunc
 *      Compare this CParaFormat to *<p pPF>
 *
 *  @rdesc
 *      TRUE if they are the same
 *
 *  @devnote
 *      First compare all of CParaFormat except rgxTabs
 *      If they are identical, compare the _cTabCount elemets of rgxTabs.
 *      If still identical, compare _cstrBkUrl
 *      Return TRUE only if all comparisons succeed.
 */
BOOL CParaFormat::Compare (const CParaFormat *pPF) const
{
    BOOL fRet;
    Assert(pPF);

    fRet = memcmp(this, pPF, offsetof(CParaFormat, _rgxTabs));
    if (!fRet)
    {
        fRet = memcmp(&_rgxTabs, &pPF->_rgxTabs, _cTabCount*sizeof(LONG));
    }
    return (!fRet);
}

/*
 *  CParaFormat::DeleteTab(tbPos)
 *
 *  @mfunc
 *      Delete tabstop at position <p tbPos>
 *
 *  @rdesc
 *      (success) ? NOERROR : S_FALSE
 */
HRESULT CParaFormat::DeleteTab (
    LONG     tbPos)         //@parm Tab position to delete
{
    LONG    Count   = _cTabCount;
    LONG    iTab;

    if(tbPos <= 0)
        return E_INVALIDARG;

    for(iTab = 0; iTab < Count; iTab++)         // Find tabstop for position
    {
        if (GetTabPos(_rgxTabs[iTab]) == tbPos)
        {
            MoveMemory(&_rgxTabs[iTab],          // Shift array down
                &_rgxTabs[iTab + 1],             //  (unless iTab is last tab)
                (Count - iTab - 1)*sizeof(LONG));
            _cTabCount--;                        // Decrement tab count and
            return NOERROR;                     //  signal no error
        }
    }
    return S_FALSE;
}

/*
 *  CParaFormat::GetTab (iTab, ptbPos, ptbAln, ptbLdr)
 *
 *  @mfunc
 *      Get tab parameters for the <p iTab> th tab, that is, set *<p ptbPos>,
 *      *<p ptbAln>, and *<p ptbLdr> equal to the <p iTab> th tab's
 *      displacement, alignment type, and leader style, respectively.  The
 *      displacement is given in twips.
 *
 *  @rdesc
 *      HRESULT = (no <p iTab> tab) ? E_INVALIDARG : NOERROR
 */
HRESULT CParaFormat::GetTab (
    long    iTab,           //@parm Index of tab to retrieve info for
    long *  ptbPos,         //@parm Out parm to receive tab displacement
    long *  ptbAln,         //@parm Out parm to receive tab alignment type
    long *  ptbLdr) const   //@parm Out parm to receive tab leader style
{
    AssertSz(ptbPos && ptbAln && ptbLdr,
        "CParaFormat::GetTab: illegal arguments");

    if(iTab < 0)                                    // Get tab previous to, at,
    {                                               //  or subsequent to the
        if(iTab < tomTabBack)                       //  position *ptbPos
            return E_INVALIDARG;

        LONG i;
        LONG tbPos = *ptbPos;
        LONG tbPosi;

        *ptbPos = 0;                                // Default tab not found
        for(i = 0; i < _cTabCount &&                 // Find *ptbPos
            tbPos > GetTabPos(_rgxTabs[i]);
            i++) ;

        tbPosi = GetTabPos(_rgxTabs[i]);             // tbPos <= tbPosi
        if(iTab == tomTabBack)                      // Get tab info for tab
            i--;                                    //  previous to tbPos
        else if(iTab == tomTabNext)                 // Get tab info for tab
        {                                           //  following tbPos
            if(tbPos == tbPosi)
                i++;
        }
        else if(tbPos != tbPosi)                    // tomTabHere
            return S_FALSE;

        iTab = i;
    }
    if((DWORD)iTab >= (DWORD)_cTabCount)             // DWORD cast also
        return E_INVALIDARG;                        //  catches values < 0

    iTab = _rgxTabs[iTab];
    *ptbPos = iTab & 0xffffff;
    *ptbAln = (iTab >> 24) & 0xf;
    *ptbLdr = iTab >> 28;
    return NOERROR;
}

/*
 *  CParaFormat::InitDefault()
 *
 *  @mfunc
 *      Initialize this CParaFormat with default paragraph formatting
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CParaFormat::InitDefault()
{
    memset((LPBYTE)this, 0, sizeof(CParaFormat));

    _fTabStops = TRUE;

    _bBlockAlign   = htmlBlockAlignNotSet;

#if lDefaultTab <= 0
#error "default tab (lDefaultTab) must be > 0"
#endif

    _cTabCount = 1;
    _rgxTabs[0] = lDefaultTab;

    // Note that we don't use the inline method here because we want to
    // allow anyone to override.
    _cuvLeftIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvRightIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvNonBulletIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvOffsetPoints.SetValue(0, CUnitValue::UNIT_POINT);

   _fHasScrollbarColors = FALSE;

   // default bullet position is outside
   _bListPosition = styleListStylePositionOutSide;

    return NOERROR;
}


/*
 *  CParaFormat::ComputeCrc()
 *
 *  @mfunc
 *      For fast font cache lookup, calculate CRC.
 *
 *  @devnote
 *      Compute items that deal with measurement of the element.
 *      Items which are purely stylistic should not be counted.
 */
WORD
CParaFormat::ComputeCrc() const
{
    DWORD dwCrc = 0, *pdw;

    for (pdw = (DWORD*)this; pdw < (DWORD*)(this+1); pdw++)
        dwCrc ^= *pdw;

    return HIWORD(dwCrc)^LOWORD(dwCrc);
}

// Font height conversion data.  Valid HTML font sizes ares [1..7]
// NB (cthrash) These are in twips, and are in the 'smallest' font
// size.  The scaling takes place in CFontCache::GetCcs().

// TODO (IE6 track bug 20)
// TODO (cthrash) We will need to get these values from the registry
// when we internationalize this product, so as to get sizing appropriate
// for the target locale.
// NOTE (johnv): Where did these old numbers come from?  The new ones now correspond to
// TwipsFromHtmlSize[2] defined above.
// static const int aiSizesInTwips[7] = { 100, 130, 160, 200, 240, 320, 480 };

// scale fonts up for TV
#ifdef NTSC
static const int aiSizesInTwips[7] = { 200, 240, 280, 320, 400, 560, 840 };
#elif defined(UNIX) // Default font size could be 13 (13*20=260)
static const int aiSizesInTwips[7] = { 151, 200, 260, 271, 360, 480, 720 };
#else
static const int aiSizesInTwips[7] = { 151, 200, 240, 271, 360, 480, 720 };
#endif

int
ConvertHtmlSizeToTwips(int nHtmlSize)
{
    // If the size is out of our conversion range do correction
    // Valid HTML font sizes ares [1..7]
    nHtmlSize = max( 1, min( 7, nHtmlSize ) );

    return aiSizesInTwips[ nHtmlSize - 1 ];
}

// ConvertFontSizeToTwipsInStrictCSS
//
// Synopsis:
//   In non-strict css mode the enums XX-LARGE, X-LARGE, LARGE, MEDIUM, SMALL, X-SMALL, XX-SMALL
//   are mapped to html sizes 7, ..., 1. NORMAL is mapped to 3 and therefore is the same size like
//   SMALL. In strict mode we want to have NORMAL same size as MEDIUM.
int
ConvertFontSizeToTwips(int nFontSize, BOOL fIsStrictCSS)
{
    int lFontSize = 0;
    // If the size is out of our conversion range do correction
    // Valid HTML font sizes ares [0..6]
    nFontSize = max( 0, min( 6, nFontSize) );

    if (fIsStrictCSS)
    {
        // In strict mode we take 2/3 of the smallest size for XX-SMALL; Everything else is moved one
        // down.
        lFontSize = (nFontSize == 0) ? /* XX-SMALL */ (aiSizesInTwips[1] * 2 / 3) : aiSizesInTwips[nFontSize-1];
    }
    else
    {
        // In compatible mode the mapping is XX-SMALL:1, X-SMALL:0..., XX-LARGE:5, 
        lFontSize = aiSizesInTwips[nFontSize];
    }
    return lFontSize;
}


int
ConvertTwipsToHtmlSize(int nFontSize)
{
    int nNumElem = ARRAY_SIZE(aiSizesInTwips);

    // Now convert the point size to size units used by HTML
    // Valid HTML font sizes ares [1..7]
    int i;
    for(i = 0; i < nNumElem; i++)
    {
        if(nFontSize <= aiSizesInTwips[i])
            break;
    }

    return i + 1;
}

// ===================================  CFancyFormat  =========================

//-----------------------------------------------------------------------------
//
//  Function:   CFancyFormat
//
//-----------------------------------------------------------------------------

CFancyFormat::CFancyFormat()
{
    _pszFilters = NULL;
    _iExpandos = -1;
    _iCustomCursor = -1;
    _iPEI = -1;
}

//-----------------------------------------------------------------------------
//
//  Function:   CFancyFormat
//
//-----------------------------------------------------------------------------

CFancyFormat::CFancyFormat(const CFancyFormat &ff)
{
    _pszFilters = NULL;
    _iExpandos = -1;
    _iCustomCursor = - 1;
    _iPEI = -1;
    *this = ff;
}

//-----------------------------------------------------------------------------
//
//  Function:   ~CFancyFormat
//
//-----------------------------------------------------------------------------

CFancyFormat::~CFancyFormat()
{
    if (_pszFilters)
    {
        MemFree(_pszFilters);
        _pszFilters = NULL;
    }
    if(_iExpandos >= 0)
    {
        TLS(_pStyleExpandoCache)->ReleaseData(_iExpandos);
        _iExpandos = -1;
    }
    if(_iPEI >= 0)
    {
        TLS(_pPseudoElementInfoCache)->ReleaseData(_iPEI);
        _iPEI = -1;
    }
    if(_iCustomCursor >= 0)
    {
        TLS(_pCustomCursorCache)->ReleaseData(_iCustomCursor);
        _iCustomCursor = -1;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   InitDefault
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------

void 
CFancyFormat::InitDefault()
{
    int  iOrigiExpandos, iOrigiPEI, iOrigCC;
    BYTE i;

    if (_pszFilters)
        MemFree(_pszFilters);

    // We want expandos to be inherited
    iOrigiExpandos = _iExpandos;
    iOrigiPEI = _iPEI;
    iOrigCC = _iCustomCursor;
    
    memset((LPBYTE)this, 0, sizeof(CFancyFormat));
    _bd._ccvBorderColorLight.Undefine();
    _bd._ccvBorderColorDark.Undefine();
    _bd._ccvBorderColorHilight.Undefine();
    _bd._ccvBorderColorShadow.Undefine();
    _cuvSpaceBefore.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvSpaceAfter.SetValue(0, CUnitValue::UNIT_POINT);

    // We are setting all border sides to the same value, so it doesn't matter
    // if we set logical or physical values.
    CColorValue ccvUndefine;
    CUnitValue cuvNull;
    ccvUndefine.Undefine();
    cuvNull.SetNull();
    for (i = 0; i < SIDE_MAX; i++)
    {
        _bd.SetBorderColor(i, ccvUndefine);
        _bd.SetBorderWidth(i, cuvNull);
        _bd.SetBorderStyle(i, (BYTE)-1);
    }

    _ccvBackColor.Undefine();
    ClearBgPosX();
    ClearBgPosY();
    SetBgRepeatX(TRUE);
    SetBgRepeatY(TRUE);

    // Restore the orignial value
    _iExpandos = (SHORT)iOrigiExpandos;
    _iPEI      = (SHORT)iOrigiPEI;
    _iCustomCursor = (SHORT) iOrigCC;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFancyFormat::operator=
//
//  Synopsis:   Replace members of this struct by another
//
//-----------------------------------------------------------------------------

CFancyFormat&
CFancyFormat::operator=(const CFancyFormat &ff)
{
    if(_iExpandos >= 0)
        TLS(_pStyleExpandoCache)->ReleaseData(_iExpandos);
    if (_pszFilters)
       MemFree(_pszFilters);
    if(_iCustomCursor >= 0 )
        TLS( _pCustomCursorCache)->ReleaseData(_iCustomCursor );
        
    memcpy(this, &ff, sizeof(*this));

    if (_pszFilters)
    {
        // Handle OOM here?
        MemAllocString(Mt(CFancyFormat_pszFilters), _pszFilters, &_pszFilters);
    }

    // Addref the new expando table
    if(_iExpandos >= 0)
        TLS(_pStyleExpandoCache)->AddRefData(_iExpandos);
    if(_iPEI >= 0)
        TLS(_pPseudoElementInfoCache)->AddRefData(_iPEI);
    if(_iCustomCursor >= 0)
        TLS(_pCustomCursorCache)->AddRefData(_iCustomCursor);

    return *this;
}

//+----------------------------------------------------------------------------
//
//  Member:     CFancyFormat::Compare
//
//  Synopsis:   Compare 2 structs
//              return TRUE iff equal, else FALSE
//
//-----------------------------------------------------------------------------

BOOL
CFancyFormat::Compare(const CFancyFormat *pFF) const
{
    Assert(pFF);

    BOOL fRet = memcmp(this, pFF, offsetof(CFancyFormat, _pszFilters));
    if (!fRet)
    {
        fRet = (_pszFilters && pFF->_pszFilters)
                ? _tcsicmp(_pszFilters, pFF->_pszFilters)
                : ((!_pszFilters && !pFF->_pszFilters) ? FALSE : TRUE);
    }
    return !fRet;
}



//+----------------------------------------------------------------------
//  CFancyFormat::CompareForLayout(pFF)
// 
//      Compare this CFancyFormat to *<p pFF> and return FALSE if any
//      attribute generally requiring a re-layout is different. return
//      TRUE if they are close enough to only require invalidation
//
//--------------------------------------------------------------------
BOOL CFancyFormat::CompareForLayout (const CFancyFormat *pFF) const
{
    Assert(pFF);

    CFancyFormat ffNew;
    BOOL fRet;

    memcpy(&ffNew, this, sizeof(CFancyFormat));
    ffNew._fHasExplicitUnderline = pFF->_fHasExplicitUnderline;
    ffNew._fHasExplicitOverline = pFF->_fHasExplicitOverline;
    ffNew._fHasExplicitLineThrough = pFF->_fHasExplicitLineThrough;
    ffNew._lZIndex = pFF->_lZIndex;
    ffNew._lImgCtxCookie = pFF->_lImgCtxCookie;
    ffNew._bPageBreaks = pFF->_bPageBreaks;
    ffNew._iExpandos = pFF->_iExpandos;
    ffNew._iCustomCursor = pFF->_iCustomCursor;
    ffNew._fBgRepeatX = pFF->_fBgRepeatX;
    ffNew._fBgRepeatY = pFF->_fBgRepeatY;
    ffNew._pszFilters = NULL;
    for(int i = SIDE_TOP; i < SIDE_MAX; i++)
    {
        ffNew._cuvPositions[i] = pFF->_cuvPositions[i];
        ffNew._cuvClip[i] = pFF->_cuvClip[i];
    }

    fRet = ffNew.Compare(pFF);
    ffNew._iExpandos = ffNew._iPEI = ffNew._iCustomCursor = -1;
    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Member:     CFancyFormat::ComputeCrc
//
//  Synopsis:   Compute Hash
//
//-----------------------------------------------------------------------------

WORD
CFancyFormat::ComputeCrc() const
{
    DWORD dwCrc = 0;
    size_t z;
    size_t size = offsetof(CFancyFormat, _pszFilters)/sizeof(DWORD);

    for (z = 0; z < size; z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    if (_pszFilters)
    {
        TCHAR *psz = _pszFilters;

        while (*psz)
        {
            dwCrc ^= (*psz++);
        }
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

//+------------------------------------------------------------------------
//
//  Member:     CFancyFormat::HasBackgrounds
//
//  Synopsis:   Check to see if backgrounds have been set
//
//-------------------------------------------------------------------------
CFancyFormat::HasBackgrounds(BOOL fIsPseudo) const
{
    if (fIsPseudo)
    {
        if (_iPEI >= 0)
        {
            const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(_iPEI);
            return (pPEI->_ccvBackColor.IsDefined() || pPEI->_lImgCtxCookie);
        }
        else
            return FALSE;
    }
    else
    {
        return (   _ccvBackColor.IsDefined()
                || _lImgCtxCookie);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPseudoElementInfo::ComputeCrc
//
//  Synopsis:   Compute Hash
//
//-------------------------------------------------------------------------
WORD
CPseudoElementInfo::ComputeCrc() const
{
    DWORD dwCrc=0, z;

    for (z=0;z<sizeof(CPseudoElementInfo)/sizeof(DWORD);z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

HRESULT
CPseudoElementInfo::InitDefault()
{
    BYTE i;
    
    memset(this, 0, sizeof(CPseudoElementInfo));

    _ccvBackColor.Undefine();

    _bd._ccvBorderColorLight.Undefine();
    _bd._ccvBorderColorDark.Undefine();
    _bd._ccvBorderColorHilight.Undefine();
    _bd._ccvBorderColorShadow.Undefine();

    // We are setting all border sides to the same value, so it doesn't matter
    // if we set logical or physical values.
    CColorValue ccvUndefine;
    CUnitValue cuvNull;
    ccvUndefine.Undefine();
    cuvNull.SetNull();
    for (i = 0; i < SIDE_MAX; i++)
    {
        _bd.SetBorderColor(i, ccvUndefine);
        _bd.SetBorderWidth(i, cuvNull);
        _bd.SetBorderStyle(i, (BYTE)-1);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CopyAttrVal
//
//  Synopsis:   Copies wSize bytes of dwSrc onto pDest
//
//-------------------------------------------------------------------------
inline void CopyAttrVal(BYTE *pDest, DWORD dwSrc, WORD wSize)
{
    switch (wSize)
    {
    case 1:
        *(BYTE*) pDest  = (BYTE) dwSrc;
        break;
    case 2:
        *(WORD*) pDest  = (WORD) dwSrc;
        break;
    case 4:
        *(DWORD*) pDest  = (DWORD) dwSrc;
        break;
    default:
        Assert(0);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyClear
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Clear Type
//
//-----------------------------------------------------------------------------
void ApplyClear(CElement * pElem, htmlClear hc, CFormatInfo *pCFI)
{
    BOOL fClearLeft = FALSE;
    BOOL fClearRight = FALSE;

    switch (hc)
    {
    case htmlClearBoth:
    case htmlClearAll:
        fClearLeft  = fClearRight = TRUE;
        break;
    case htmlClearLeft:
        fClearLeft  = TRUE;
        fClearRight = FALSE;
        break;
    case htmlClearRight:
        fClearRight = TRUE;
        fClearLeft  = FALSE;
        break;
    case htmlClearNone:
        fClearLeft  = fClearRight = FALSE;
        break;
    case htmlClearNotSet:
        AssertSz(FALSE, "Invalid Clear value.");
        break;
    }

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._fClearLeft  = fClearLeft;
    pCFI->_ff()._fClearRight = fClearRight;
    pCFI->UnprepareForDebug();
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontFace
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Face
//
//-----------------------------------------------------------------------------

struct CFBAG
{
    CCharFormat * pcf;
    BOOL fMatched;
    BYTE bFamily;
    BYTE bPitch;

    CFBAG(CCharFormat * pcfArg)
    {
        pcf = pcfArg;
        fMatched = FALSE;
        bFamily = 0;
        bPitch = 0;
    };
};

static int CALLBACK
__ApplyFontFace_Compare(const LOGFONT FAR * lplf, 
                        const TEXTMETRIC FAR * lptm, 
                        DWORD FontType, 
                        LPARAM lParam)
{
    // Prefer TrueType fonts
    struct CFBAG * pcfbag = (struct CFBAG *)lParam;
    if (   (TRUETYPE_FONTTYPE & FontType) 
        || !pcfbag->fMatched)
    {
        pcfbag->fMatched = TRUE;
        pcfbag->pcf->_bCharSet = lplf->lfCharSet;
        pcfbag->pcf->_bPitchAndFamily = lplf->lfPitchAndFamily;
        pcfbag->pcf->SetFaceName(lplf->lfFaceName);
    }
    return !(TRUETYPE_FONTTYPE & FontType);
}

static int CALLBACK
__ApplyFontFace_CompareFamily(const LOGFONT FAR * lplf, 
                              const TEXTMETRIC FAR * lptm, 
                              DWORD FontType, 
                              LPARAM lParam)
{
    if (   (lplf->lfPitchAndFamily & 0xf0) == ((struct CFBAG *)lParam)->bFamily
        && lplf->lfCharSet != SYMBOL_CHARSET)   // Skip 'Symbol' font
    {
        return __ApplyFontFace_Compare(lplf, lptm, FontType, lParam);
    }
    return TRUE;
}

static int CALLBACK
__ApplyFontFace_ComparePitch(const LOGFONT FAR * lplf, 
                              const TEXTMETRIC FAR * lptm, 
                              DWORD FontType, 
                              LPARAM lParam)
{
    if (   (lplf->lfPitchAndFamily & 0x0f) == ((struct CFBAG *)lParam)->bPitch
        && lplf->lfCharSet != SYMBOL_CHARSET)   // Skip 'Symbol' font
    {
        return __ApplyFontFace_Compare(lplf, lptm, FontType, lParam);
    }
    return TRUE;
}

static BOOL 
__ApplyFontFace_IsDeviceFontExists(HDC hDC, 
                                   LPLOGFONT lpLogfont, 
                                   struct CFBAG & cfbag, 
#if DBG==1
                                   CCharFormat *pCF, 
#endif
                                   FONTENUMPROC lpEnumFontFamExProc,
                                   BOOL fCheckAlternate)
{
    // (1) Check the system if we have a facename match

    EnumFontFamiliesEx(hDC, lpLogfont, lpEnumFontFamExProc, (LPARAM)&cfbag, 0);
    if (   !cfbag.fMatched 
        && lpLogfont->lfCharSet != DEFAULT_CHARSET)
    {
    // (2) If cannot match in current charset, ignore charset and enumerate again.

        BYTE lfCharSet = lpLogfont->lfCharSet;
        lpLogfont->lfCharSet = DEFAULT_CHARSET;
        EnumFontFamiliesEx(hDC, lpLogfont, lpEnumFontFamExProc, (LPARAM)&cfbag, 0);
        lpLogfont->lfCharSet = lfCharSet;
    }

    if (   fCheckAlternate 
        && !cfbag.fMatched)
    {
    // (3) Check if we have an known alternate name, and see if the system has a match

        const TCHAR * pAltFace = AlternateFontName(lpLogfont->lfFaceName);
        if (pAltFace)
        {
            Assert(_tcsclen(pAltFace) < LF_FACESIZE);

            LOGFONT lf = *lpLogfont;
            StrCpyN(lf.lfFaceName, pAltFace, LF_FACESIZE);

            __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                               pCF,
#endif
                                               lpEnumFontFamExProc, FALSE);
        }
    }
#if DBG==1
    else if (cfbag.fMatched)
    {
        // NOTE (cthrash) Terribly hack for Mangal.  When we
        // enumerate for Mangal, which as Indic font, GDI says we
        // have font with a GDI charset of ANSI.  This is simply
        // false, and furthermore will not create the proper font
        // when we do a CreateFontIndirect.  Hack this so we have
        // some hope of handling Indic correctly.

        // This hack has been removed. We are using EnumFontFamiliesEx,
        // and we are expecting better results.

#if defined(UNIX) || defined(_MAC)
        if (StrCmpIC( szFaceName, TEXT("Mangal")) == 0)
        {
            Assert(pCF->_bCharSet == DEFAULT_CHARSET);
        }
#else
        if (   (((*(DWORD *)lpLogfont->lfFaceName) & 0xffdfffdf) == 0x41004d)
            && StrCmpIC(lpLogfont->lfFaceName, TEXT("Mangal")) == 0)
        {
            Assert(pCF->_bCharSet == DEFAULT_CHARSET);
        }
#endif
    }
#endif // DBG==1

    return cfbag.fMatched;
}

//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_MatchGenericFamily, static
//
//  Synopsis:   If the supplied face name maps to a generic font family, 
//              fill in the appropriate pCF members and return TRUE. 
//              Otherwise, leave pCF untouched and return FALSE.
//
//-----------------------------------------------------------------------------

static BOOL
__ApplyFontFace_MatchGenericFamily(HDC hDC,
                                   TCHAR * szFamilyName, 
                                   BYTE bCharSet,
                                   struct CFBAG & cfbag, 
                                   CCharFormat * pCF)
{
    Assert(_tcsclen(szFamilyName) < LF_FACESIZE);

    int n;
    for (n = 0; n < ARRAY_SIZE(s_fontFamilyMap); ++n)
    {
        if (StrCmpIC(szFamilyName, s_fontFamilyMap[n].szGenericFamily) == 0)
        {
            LOGFONT lf;
            lf.lfCharSet = bCharSet;
            lf.lfPitchAndFamily = 0;
            lf.lfFaceName[0] = _T('\0');
            cfbag.bFamily = s_fontFamilyMap[n].dwWindowsFamily;
            BOOL fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                             pCF,
#endif
                                                             __ApplyFontFace_CompareFamily, FALSE);

            // If enumeration failed for generic font family, use following:
            //   * sans-serif   (FF_SWISS) - use default font
            //   * serif        (FF_ROMAN) - use default font
            //   * monospace   (FF_MODERN) - fixed pitch font
            //   * cursive     (FF_SCRIPT) - italic serif
            //   * fantasy (FF_DECORATIVE) - serif
            if (!fFound)
            {
                switch (s_fontFamilyMap[n].dwWindowsFamily)
                {
                case FF_SWISS:
                case FF_ROMAN:
                    // It shouldn't ever happen. Assert below.
                    break;

                case FF_MODERN:
                    cfbag.bPitch = FIXED_PITCH;
                    fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                pCF,
#endif
                                                                __ApplyFontFace_ComparePitch, FALSE);
                    break;

                case FF_SCRIPT:
                    cfbag.pcf->_fItalic = TRUE;
                    // fall through

                case FF_DECORATIVE:
                    cfbag.bFamily = FF_ROMAN;
                    fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                pCF,
#endif
                                                                __ApplyFontFace_CompareFamily, FALSE);
                    break;
                }
            }

            Assert(fFound);  // It shouldn't ever happen.
            return fFound;
        }
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_MatchDownloadedFont, static
//
//  Synopsis:   If the supplied face name maps to a successfully 
//              downloaded (embedded) font, fill in the appropriate 
//              pCF members and return TRUE. Otherwise, leave pCF untouched 
//              and return FALSE.
//
//-----------------------------------------------------------------------------

static BOOL
__ApplyFontFace_MatchDownloadedFont(TCHAR * szFaceName, 
                                    CCharFormat * pCF, 
                                    CMarkup * pMarkup)
{
    CStyleSheetArray * pStyleSheets = pMarkup->GetStyleSheetArray();
    if (!pStyleSheets)
        return FALSE;

    return pStyleSheets->__ApplyFontFace_MatchDownloadedFont(szFaceName, pCF, pMarkup);
}

//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_ExtractFamilyName, static
//
//  Synopsis:   From the comma-delimited font-family property, extract the
//              next facename.
//
//              As of IE5, we also decode hex-encoded unicode codepoints.
//
//  Returns:    Pointer to scan the next iteration.
//
//-----------------------------------------------------------------------------

static TCHAR *
__ApplyFontFace_ExtractFamilyName(TCHAR * pchSrc, 
                                  TCHAR achFaceName[LF_FACESIZE])
{
    enum PSTATE
    {
        PSTATE_START,
        PSTATE_COPY,
        PSTATE_HEX
    } state = PSTATE_START;

    TCHAR * pchDst = achFaceName;
    TCHAR * pchDstStop = achFaceName + LF_FACESIZE - 1;
    TCHAR chHex = 0;
    TCHAR chStop = _T(',');
    TCHAR * pchSrcOneAfterStart = pchSrc;

    achFaceName[0] = 0;

    while (pchDst < pchDstStop)
    {
        const TCHAR ch = *pchSrc++;

        if (!ch)
        {
            if (chHex)
            {
                *pchDst++ = chHex;
            }

            --pchSrc; // backup for outer while loop.
            break;
        }

        switch (state)
        {
            case PSTATE_START:
                if (ch == _T(' ') || ch == _T(',')) // skip leading junk
                {
                    break;
                }

                pchSrcOneAfterStart = pchSrc;

                state = PSTATE_COPY;

                if (ch == _T('\"') || ch == _T('\'')) // consume quote.
                {
                    pchSrcOneAfterStart++;
                    chStop = ch;
                    break;
                }

                // fall through if non of the above

            case PSTATE_COPY:
                if (ch == chStop)
                {
                    pchDstStop = pchDst; // force exit
                }
                else if (ch == _T('\\'))
                {
                    chHex = 0;
                    state = PSTATE_HEX;
                }
                else
                {
                    *pchDst++ = ch;
                }
                break;

            case PSTATE_HEX:
                if (InRange( ch, _T('a'), _T('f')))
                {
                    chHex = (chHex << 4) + (ch - _T('a') + 10);
                }
                else if (InRange( ch, _T('A'), _T('F')))
                {
                    chHex = (chHex << 4) + (ch - _T('A') + 10);
                }
                else if (InRange( ch, _T('0'), _T('9')))
                {
                    chHex = (chHex << 4) + (ch - _T('0'));
                }
                else if (chHex)
                {
                    *pchDst++ = chHex;
                    --pchSrc; // backup
                    state = PSTATE_COPY;
                    chHex = 0;
                }
                else
                {
                    *pchDst++ = ch;
                }
        }
    }

    // Trim off trailing white space.

    while (pchDst > achFaceName && pchDst[-1] == _T(' '))
    {
        --pchDst;
    }
    *pchDst = 0;

    return (achFaceName[0] == _T('@') && achFaceName[1]) ? pchSrcOneAfterStart : pchSrc;
}

BOOL
MapToInstalledFont(LPCTSTR szFaceName, BYTE * pbCharSet, LONG * platmFaceName)
{
    Assert(pbCharSet);
    Assert(platmFaceName);

    HDC hDC = TLS(hdcDesktop);

    LOGFONT lf;
    lf.lfCharSet = *pbCharSet;
    lf.lfPitchAndFamily = 0;
    Assert(_tcsclen(szFaceName) < LF_FACESIZE);
    StrCpyN(lf.lfFaceName, szFaceName, LF_FACESIZE);

    CCharFormat cf;
    struct CFBAG cfbag(&cf);

    BOOL fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                     &cf,
#endif
                                                     __ApplyFontFace_Compare, TRUE);
    if (fFound)
    {
        *pbCharSet = cf._bCharSet;
        *platmFaceName = cf._latmFaceName;
    }

    return fFound;
}

void
ApplyAtFontFace(CCharFormat *pCF, CDoc *pDoc, CMarkup * pMarkup)
{
    Assert(pCF->NeedAtFont() && !pCF->_fExplicitAtFont);

    const TCHAR * pszFaceNameOriginal = fc().GetFaceNameFromAtom(pCF->_latmFaceName);
    if (pszFaceNameOriginal && pszFaceNameOriginal[0] != _T('@'))
    {
        TCHAR szFaceName[LF_FACESIZE];
        szFaceName[0] = _T('@');
        _tcsncpy(szFaceName + 1, pszFaceNameOriginal, LF_FACESIZE - 2);
        szFaceName[LF_FACESIZE - 1] = 0;

        ApplyFontFace(pCF, szFaceName, AFF_ATFONTPASS | AFF_ATFONTSRCH, pDoc, pMarkup);
    }
}

void
RemoveAtFontFace(CCharFormat *pCF, CDoc *pDoc, CMarkup * pMarkup)
{
    Assert(!pCF->NeedAtFont() && !pCF->_fExplicitAtFont);

    const TCHAR * pszFaceNameOriginal = fc().GetFaceNameFromAtom(pCF->_latmFaceName);
    if (pszFaceNameOriginal && pszFaceNameOriginal[0] == _T('@'))
    {
        TCHAR szFaceName[LF_FACESIZE];
        _tcsncpy(szFaceName, pszFaceNameOriginal + 1, LF_FACESIZE - 1);
        Assert(_tcsclen(szFaceName) < LF_FACESIZE);

        ApplyFontFace(pCF, szFaceName, AFF_ATFONTPASS, pDoc, pMarkup);
    }
}

void
ApplyFontFace(CCharFormat *pCF, LPTSTR p, DWORD dwFlags, CDoc *pDoc, CMarkup * pMarkup)
{
    // Often fonts are specified as a comma-separated list, so we need to
    // just pick the first one in the list which is installed on the user's
    // system.
    // Note: If no fonts in the list are available pCF->szFaceName will not
    //       be touched.

    HDC hDC = TLS(hdcDesktop);
    CODEPAGESETTINGS * pCS = pMarkup->GetCodepageSettings();
    BYTE bCharSet = pCS ? pCS->bCharSet : pDoc->PrimaryMarkup()->GetCodepageSettings()->bCharSet;
    const BOOL fIsPrintDoc = pMarkup && pMarkup->IsPrintMedia();
    CFontCache *pfc = &fc();

    if (p && p[0])
    {
        TCHAR *pStr;
        TCHAR  szFaceName[LF_FACESIZE];
        BOOL   fCacheHit = FALSE;

        // Because we have a cache for most recently used face names
        // that is used for all instances, we enclose the whole thing
        // in a critical section.
        if (!fIsPrintDoc)
            EnterCriticalSection(&pfc->_csFaceCache);

        pStr = (LPTSTR)p;
        while (*pStr)
        {
            struct CFBAG cfbag(pCF);
            BOOL fFound;

            pStr = __ApplyFontFace_ExtractFamilyName(pStr, szFaceName);

            if (!szFaceName[0])
                break;

            // When we're on the screen, we use a cache to speed things up.
            // We don't use if for the printer because we share the cache
            // across all DCs, and we don't want to have matching problems
            // across DCs.
            if (!fIsPrintDoc)
            {
                // The atom name for the given face name.
                LONG lAtom = pfc->FindAtomFromFaceName(szFaceName);

                // Check to see if it's the same as a recent find.
                if (lAtom)
                {
                    int i;
                    for (i = 0; i < pfc->_iCacheLen; i++)
                    {
                        // Check the facename and charset.
                        if (lAtom == pfc->_fcFaceCache[i]._latmFaceName &&
                            bCharSet == pfc->_fcFaceCache[i]._bCharSet)
                        {
                            pCF->_bCharSet = pfc->_fcFaceCache[i]._bCharSet;
                            pCF->_bPitchAndFamily = pfc->_fcFaceCache[i]._bPitchAndFamily;
                            pCF->SetFaceNameAtom(pfc->_fcFaceCache[i]._latmFaceName);
                            pCF->_fExplicitFace = pfc->_fcFaceCache[i]._fExplicitFace;
                            pCF->_fNarrow = pfc->_fcFaceCache[i]._fNarrow;
#if DBG==1
                            pfc->_iCacheHitCount++;
#endif
                            fCacheHit = TRUE;
                            break;
                        }
                    }
                }
                if (fCacheHit)
                    break;
            }
            else
            {
                // Evil, evil hack for IE6 34752
                // The "hi-res" (complex transform)  selection we use when picking fonts
                // doesn't work at measure time.  This should be fixed.
                // Instead, we pretend that "System" is "Arial" while in a layout rect.
                // Please remove this if the device fonts/hi-res non TT font engine get fixes.
                if (_tcsicmp(szFaceName, _T("System")) == 0)
                {
                    _tcscpy(szFaceName, _T("Arial"));
                }
            }

            //
            // Check to see if the font exists. If so, break and return
            //

            // (1) Check our download font list to see if we have a match

            fFound = __ApplyFontFace_MatchDownloadedFont(szFaceName, pCF, pMarkup);

            if (!fFound)
            {
                LOGFONT lf;
                lf.lfCharSet = bCharSet;
                lf.lfPitchAndFamily = 0;
                StrCpyN(lf.lfFaceName, szFaceName, LF_FACESIZE);

            // (2) Check if device font exists

                fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                            pCF,
#endif
                                                            __ApplyFontFace_Compare, TRUE);

            // (3) Check for generic family names (Serif, etc.)

                if (!fFound)
                {
                    fFound = __ApplyFontFace_MatchGenericFamily(hDC, szFaceName, bCharSet, cfbag, pCF);

            // (4) In case of printing check if desktop device font exists

                    if (!fFound && fIsPrintDoc)
                        fFound = __ApplyFontFace_IsDeviceFontExists(TLS(hdcDesktop), &lf, cfbag, 
#if DBG==1
                                                                    pCF,
#endif
                                                                    __ApplyFontFace_Compare, TRUE);

            // (5) In some cases we can ask for non-existing @font. 
            //     In this case ignore font face and ask only for charset. Returned font name 
            //     is existing font, so it is more likely that we have corresponding @font.
            //     But do it only for FE charsets.

                    if (   !fFound 
                        && (dwFlags & AFF_ATFONTSRCH)
                        && IsFECharset(bCharSet) && szFaceName[0] == _T('@'))
                    {
                        Assert(lf.lfCharSet == bCharSet);
                        Assert(lf.lfPitchAndFamily == 0);

                        // There is possiblity that using following logic we don't find any
                        // @font. In this case restore original CF values, because we 
                        // prefer to use original font then fallback font.
                        BYTE bOrigCharSet = pCF->_bCharSet;
                        BYTE bOrigPitchAndFamily = pCF->_bPitchAndFamily;
                        BYTE latmOrigFaceName = pCF->_latmFaceName;

                        FONTENUMPROC lpEnumFontFamExProc = __ApplyFontFace_Compare;
#if NEVER
                        // NOTE (grzegorz): Following code should be enabled, but due
                        // to ForceTT fonts issues need to remove it.
                        // Need to fix every call of GetCss() to get the right font.
                        if (pCF->_bPitchAndFamily)
                        {
                            lpEnumFontFamExProc = __ApplyFontFace_CompareFamily;
                            cfbag.bFamily = (pCF->_bPitchAndFamily & 0xf0);
                        }
#endif

                        lf.lfFaceName[0] = 0;
                        fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                    pCF,
#endif
                                                                    lpEnumFontFamExProc, FALSE);
                        if (fFound)
                        {
                            cfbag.fMatched = FALSE;
                            lf.lfFaceName[0] = _T('@');
                            _tcsncpy(lf.lfFaceName + 1, fc().GetFaceNameFromAtom(pCF->_latmFaceName), LF_FACESIZE - 2);
                            lf.lfFaceName[LF_FACESIZE - 1] = 0;
                            fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                        pCF,
#endif
                                                                        lpEnumFontFamExProc, FALSE);
                            if (!fFound)
                            {
                                // Restore original CF values (see comment above)
                                pCF->_bCharSet = bOrigCharSet;
                                pCF->_bPitchAndFamily = bOrigPitchAndFamily;
                                pCF->SetFaceNameAtom(latmOrigFaceName);
                            }
                        }
                    }
                }
            }

            if (fFound)
            {

                // (greglett)
                // Enabling this hack causes problems when printing fonts that don't exist in a local character
                // set (e.g.: Tahoma font on a localized KOR Win98 - Bug 101341).
                // This should work okay, as the new fontlinking code should pick up that the font does not support
                // the given charset and link in a font that does.
#ifdef PRINT_HACKS
                //
                // HACK (cthrash) Font enumeration doens't work on certain
                // drivers.  Insist on the charset rather than the facename.
                //

                if (   VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID
                    && cfbag.fMatched
                    && pCF->_bCharSet != bCharSet
                    && pCF->_bCharSet != SYMBOL_CHARSET
                    && pCF->_bCharSet != OEM_CHARSET
                    && fIsPrintDoc)
                {
                    pCF->_bCharSet = bCharSet;
                }
#endif

                pCF->_fExplicitFace = TRUE;
                pCF->_fNarrow = IsNarrowCharSet(pCF->_bCharSet);
                break;
            }
        }

        // Update the cache and leave the critical section.
        if (!fIsPrintDoc)
        {
            if (!fCacheHit)
            {
                int iCacheNext = pfc->_iCacheNext;
                pfc->_fcFaceCache[iCacheNext]._bCharSet = pCF->_bCharSet;
                pfc->_fcFaceCache[iCacheNext]._bPitchAndFamily = pCF->_bPitchAndFamily;
                pfc->_fcFaceCache[iCacheNext]._latmFaceName = pCF->_latmFaceName;
                pfc->_fcFaceCache[iCacheNext]._fExplicitFace = pCF->_fExplicitFace;
                pfc->_fcFaceCache[iCacheNext]._fNarrow = pCF->_fNarrow;

                pfc->_iCacheNext++;
                if (pfc->_iCacheLen < CFontCache::cFontFaceCacheSize)
                    pfc->_iCacheLen++;
                if (pfc->_iCacheNext >= CFontCache::cFontFaceCacheSize)
                    pfc->_iCacheNext = 0;
            }
            LeaveCriticalSection(&pfc->_csFaceCache);
        }

        // If we picked up @font, store this information
        pCF->_fExplicitAtFont = !(dwFlags & AFF_ATFONTPASS) && 
            (fc().GetFaceNameFromAtom(pCF->_latmFaceName)[0] == _T('@')) ;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleLargerSmaller
//
//  Synopsis:   Helper function called from ApplyFontSize to handle "larger"
//              and "smaller" font sizes.  Returns TRUE if we handled a "larger"
//              or "smaller" case, returns FALSE if we didn't do anything.
//
//-----------------------------------------------------------------------------

static BOOL HandleLargerSmaller(long *plSize, long lUnitValue )
{
    long lSize = *plSize;
    const int nNumElem = ARRAY_SIZE(aiSizesInTwips);
    int i;

    switch (lUnitValue)
    {
    case styleFontSizeLarger:
        // Look for a larger size in the abs. size array
        for (i=0 ; i < nNumElem ; ++i)
        {
            if (aiSizesInTwips[i] > lSize)
            {
                *plSize = aiSizesInTwips[i];
                return TRUE;
            }
        }
        // We are bigger than "xx-large"; use factor of 1.5x
        *plSize = lSize * 3 / 2;
        return TRUE;
    case styleFontSizeSmaller:
        // If we are more than 1.5x bigger than the largest size in the
        // abs. size array, then only shrink down by 1.5x.
        if ( (lSize * 2 / 3) > aiSizesInTwips[nNumElem-1] )
        {
            *plSize = lSize * 2 / 3;
            return TRUE;
        }
        // Look for a smaller size in the abs. size array
        for (i=nNumElem-1 ; i >= 0 ; --i)
        {
            if (aiSizesInTwips[i] < lSize)
            {
                *plSize = aiSizesInTwips[i];
                return TRUE;
            }
        }
        // We are smaller than "xx-small"; use factor of 1/1.5x
        *plSize = lSize * 2 / 3;
        return TRUE;
    default:
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontSize
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Size
//
//-----------------------------------------------------------------------------
void ApplyFontSize(
    CFormatInfo *pCFI,
    const CUnitValue *pCUV,
    BOOL fAlwaysUseMyFontSize,
    BOOL fComputingFirstLetter,
    BOOL fComputingFirstLine)
{
    LONG lSize;
    BOOL fScale = FALSE;
    CUnitValue::UNITVALUETYPE uvt;
    CCharFormat *pCF   = &pCFI->_cf();
    CTreeNode   *pNode = pCFI->_pNodeContext;

    Assert( pNode );
    Assert( pCF );

    if ( pCUV->IsNull() )
        return;

    // See what value we inherited in the CF.  lSize is in twips.
    lSize = pCF->GetHeightInTwips( pNode->Doc() );

    if (fComputingFirstLine && !pCFI->_fUseParentSizeForPseudo)
    {
        if (pCFI->_fSecondCallForFirstLine)
        {
            lSize = pCFI->_lParentHeightForFirstLine;
        }
        else
        {
            pCFI->_lParentHeightForFirstLine = lSize;
            pCFI->_fSecondCallForFirstLine = TRUE;
        }
    }
    else if (fComputingFirstLetter && !pCFI->_fUseParentSizeForPseudo)
    {
        if (pCFI->_fSecondCallForFirstLetter)
        {
            lSize = pCFI->_lParentHeightForFirstLetter;
        }
        else
        {
            pCFI->_lParentHeightForFirstLetter = lSize;
            pCFI->_fSecondCallForFirstLetter = TRUE;
        }
    }
    else
    {
        // But use our parent element's value if we can get it, as per CSS1 spec for font-size.
        // However, if we are computing first letter and our block element has a first-line
        // spec, then that firstline spec is our "parent" and we need to respect its size.
        // However, the parent over here is the body and not the block element. Hence the
        // check for fUseParentSize above.
        CTreeNode * pNodeParent = pNode->Parent();
        if (pNodeParent)
        {
            const CCharFormat *pParentCF = pNodeParent->GetCharFormat();
            if (pParentCF)
            {
                lSize = pParentCF->GetHeightInTwips( pNodeParent->Doc() );
                fScale = !pParentCF->_fSizeDontScale;
            }
        }
    }
    
    uvt = pCUV->GetUnitType();

    switch(uvt)
    {
    case CUnitValue::UNIT_RELATIVE:     // Relative to the base font size
        {
            LONG lBaseFontHtmlSize = 3;

            // Base fonts don't inherit through table cells or other
            // text sites.
            pNode = pNode->SearchBranchToFlowLayoutForTag( ETAG_BASEFONT );

            if (pNode)
                lBaseFontHtmlSize = DYNCAST(CBaseFontElement, pNode->Element())->GetFontSize();

            lSize = ConvertHtmlSizeToTwips( lBaseFontHtmlSize + pCUV->GetUnitValue() );
        }
        fScale = TRUE;
        break;
    case CUnitValue::UNIT_PERCENT:
        lSize = MulDivQuick( lSize, pCUV->GetPercent(), 100 );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_EM:
        lSize = MulDivQuick(lSize, pCUV->GetUnitValue(), CUnitValue::TypeNames[CUnitValue::UNIT_EM].wScaleMult);
        break;
//        UNIT_EN,            // en's ( relative to width of an "n" character in current-font )
    case CUnitValue::UNIT_EX:
        // NOTE (mikhaill, grzegorz): following "* 2" should be kind of approximation, since we do not
        // actually extract sizes of letter "x" for UNIT_EX (nor "m" for UNIT_EM). This can affect
        // tags with declaration like style = "font-size:1ex" that currently is not used in DRT.
        lSize = MulDivQuick( lSize, pCUV->GetUnitValue(), CUnitValue::TypeNames[CUnitValue::UNIT_EX].wScaleMult * 2 );
        break;
    case CUnitValue::UNIT_POINT:  // Convert from points to twips
        lSize = MulDivQuick( pCUV->GetUnitValue(), 20, CUnitValue::TypeNames[CUnitValue::UNIT_POINT].wScaleMult );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_ENUM:
        if ( !HandleLargerSmaller( &lSize, pCUV->GetUnitValue() ) ) // lSize modified if ret=true
        {
            BOOL fIsStrictCSS = pNode->GetMarkup()->IsStrictCSS1Document();
            lSize = ConvertFontSizeToTwips( pCUV->GetUnitValue(), fIsStrictCSS);
        }
        fScale = TRUE;
        break;
    case CUnitValue::UNIT_INTEGER:
        lSize = ConvertHtmlSizeToTwips( pCUV->GetUnitValue() );
        fScale = TRUE;
        break;
    case CUnitValue::UNIT_PICA:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 240, CUnitValue::TypeNames[CUnitValue::UNIT_PICA].wScaleMult );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_INCH:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 1440, CUnitValue::TypeNames[CUnitValue::UNIT_INCH].wScaleMult );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_CM:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 144000, CUnitValue::TypeNames[CUnitValue::UNIT_CM].wScaleMult * 254 );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_MM:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 144000, CUnitValue::TypeNames[CUnitValue::UNIT_MM].wScaleMult * 2540 );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_PIXELS:
        {
            CUnitValue cuv;

            cuv.SetRawValue( pCUV->GetRawValue() );
            THR( cuv.ConvertToUnitType( CUnitValue::UNIT_POINT, 1, CUnitValue::DIRECTION_CY, lSize ) );
            lSize = MulDivQuick( cuv.GetUnitValue(), 20, CUnitValue::TypeNames[CUnitValue::UNIT_POINT].wScaleMult );
            fScale = FALSE;
        }
        break;
    default:
        //AssertSz(FALSE,"Suspicious CUnitValue in ApplyFontSize.");
        break;
    }

    if ( lSize < 0 )
        lSize = -lSize;

    if (pCF->_fBumpSizeDown &&
        uvt != CUnitValue::UNIT_RELATIVE &&
        uvt != CUnitValue::UNIT_PERCENT &&
        uvt != CUnitValue::UNIT_TIMESRELATIVE)
    {
        // For absolute font size specifications, element which normally
        // may have set fBumpSize down must cancel it (nav compatibility).
        pCF->_fBumpSizeDown = FALSE;
    }


    // Make sure that size is within the abs. size array range if
    // 'Always Use My Font Size' is chosen from the option settings
    if (fAlwaysUseMyFontSize)
    {
        long nSizes = ARRAY_SIZE(aiSizesInTwips);
        lSize = (lSize < aiSizesInTwips[0]) ? aiSizesInTwips[0] : ((lSize > aiSizesInTwips[nSizes-1]) ? aiSizesInTwips[nSizes-1] : lSize);
    }

    if ( fScale )
        pCF->SetHeightInTwips( lSize );
    else
        pCF->SetHeightInNonscalingTwips( lSize );
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyBaseFont
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Base Font Size
//
//-----------------------------------------------------------------------------
inline void ApplyBaseFont(CCharFormat *pCF, long lSize)
{
    pCF->SetHeightInTwips( ConvertHtmlSizeToTwips(lSize) );
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontStyle
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Style
//
//-----------------------------------------------------------------------------
inline void ApplyFontStyle(CCharFormat *pCF, styleFontStyle sfs)
{
    if ( sfs == styleFontStyleNotSet )
        return;

    if ( ( sfs == styleFontStyleItalic ) || ( sfs == styleFontStyleOblique ) )
        pCF->_fItalic = TRUE;
    else
        pCF->_fItalic = FALSE;
}


//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontWeight
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Weight
//
//-----------------------------------------------------------------------------
inline void ApplyFontWeight(CCharFormat *pCF, styleFontWeight sfw )
{
    if ( sfw == styleFontWeightNotSet  )
        return;

    if ( sfw == styleFontWeightBolder )
    {
        pCF->_wWeight = (WORD)min( 900, pCF->_wWeight+300 );
    }
    else if ( sfw == styleFontWeightLighter )
    {
        pCF->_wWeight = (WORD)max( 100, pCF->_wWeight-300 );
    }
    else
    {
        //See wingdi.h and our enum table
        //we currently do not handle relative boldness
        Assert(1 == styleFontWeight100);

        if ( sfw == styleFontWeightNormal )
            sfw = styleFontWeight400;
        if ( sfw == styleFontWeightBold )
            sfw = styleFontWeight700;

        pCF->_wWeight = 100 * (DWORD) sfw;
    }

    if (FW_NORMAL < pCF->_wWeight)
        pCF->_fBold = TRUE;
    else
        pCF->_fBold = FALSE;
}

BOOL g_fSystemFontsNeedRefreshing = TRUE;
#define NUM_SYS_FONTS 6
static LOGFONTW alfSystemFonts[ NUM_SYS_FONTS ]; // sysfont_caption, sysfont_icon, sysfont_menu, sysfont_messagebox, sysfont_smallcaption, sysfont_statusbar
extern int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch); // defined in core\wrappers\unicwrap.cxx

void RefreshSystemFontCache( void )
{
#ifdef WINCE
    GetObject(GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), &alfSystemFonts[ sysfont_icon ]);

    memcpy( &alfSystemFonts[ sysfont_caption ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_menu ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_messagebox ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_smallcaption ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_statusbar ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
#else

    SystemParametersInfo( SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &alfSystemFonts[ sysfont_icon ], 0 );
    if (VER_PLATFORM_WIN32_WINDOWS != g_dwPlatformID)
    {
        NONCLIENTMETRICS ncm;
        
        ncm.cbSize  = sizeof(NONCLIENTMETRICS);
        if ( SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 ) )
        {   // Copy fonts into place
            memcpy( &alfSystemFonts[ sysfont_caption ], &ncm.lfCaptionFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_menu ], &ncm.lfMenuFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_messagebox ], &ncm.lfMessageFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_smallcaption ], &ncm.lfSmCaptionFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_statusbar ], &ncm.lfStatusFont, sizeof(LOGFONT) );
        }
    }
    else
    {   // Probably failed due to Unicodeness, try again with short char version of NCM.
        NONCLIENTMETRICSA ncma;

        ncma.cbSize = sizeof(NONCLIENTMETRICSA);
        if ( SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncma, 0 ) )
        {   // Copy the fonts and do the Unicode conversion.
            memcpy( &alfSystemFonts[ sysfont_caption ], &ncma.lfCaptionFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_caption ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_caption ].lfFaceName),
                             ncma.lfCaptionFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_menu ], &ncma.lfMenuFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_menu ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_menu ].lfFaceName),
                             ncma.lfMenuFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_messagebox ], &ncma.lfMessageFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_messagebox ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_messagebox ].lfFaceName),
                             ncma.lfMessageFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_smallcaption ], &ncma.lfSmCaptionFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_smallcaption ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_smallcaption ].lfFaceName),
                             ncma.lfSmCaptionFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_statusbar ], &ncma.lfStatusFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_statusbar ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_statusbar ].lfFaceName),
                             ncma.lfStatusFont.lfFaceName, -1 );
        }
    }
#endif // WINCE
    g_fSystemFontsNeedRefreshing = FALSE;
}

void ApplySystemFont( CCharFormat *pCF, Esysfont eFontType )
{
    LOGFONT *lplf = NULL;
    long lSize = 1;

    if ( g_fSystemFontsNeedRefreshing )
        RefreshSystemFontCache();

    if ( ( eFontType < sysfont_caption ) || ( eFontType > sysfont_statusbar ) )
        return;

    lplf = &alfSystemFonts[ eFontType ];

    pCF->SetFaceName( lplf->lfFaceName );
    pCF->_bCharSet = lplf->lfCharSet;
    pCF->_fNarrow = IsNarrowCharSet(lplf->lfCharSet);
    pCF->_bPitchAndFamily = lplf->lfPitchAndFamily;
    pCF->_wWeight = lplf->lfWeight;
    pCF->_fBold = (pCF->_wWeight > 400);
    pCF->_fItalic = lplf->lfItalic;
    pCF->_fUnderline = lplf->lfUnderline;
    pCF->_fStrikeOut = lplf->lfStrikeOut;

    lSize = g_uiDisplay.TwipsFromDeviceY(lplf->lfHeight);
    if ( lSize < 0 )
        lSize = -lSize;
    pCF->SetHeightInTwips( lSize );
}

void ApplySiteAlignment (CFormatInfo *pCFI, htmlControlAlign at, CElement * pElem)
{
    if (at == htmlControlAlignNotSet)
        return;

    BYTE va = styleVerticalAlignAuto;
    switch (at)
    {
    case htmlControlAlignLeft:
        if(pElem->Tag() == ETAG_LEGEND)
            pCFI->_bCtrlBlockAlign = htmlBlockAlignLeft;
        break;
    case htmlControlAlignCenter:
        pCFI->_bCtrlBlockAlign = htmlBlockAlignCenter;
        va = styleVerticalAlignMiddle;
        break;
    case htmlControlAlignRight:
        if(pElem->Tag() == ETAG_LEGEND)
            pCFI->_bCtrlBlockAlign = htmlBlockAlignRight;
        break;
    case htmlControlAlignTextTop:
        va = styleVerticalAlignTextTop;
        break;
    case htmlControlAlignAbsMiddle:
        va = styleVerticalAlignAbsMiddle;
        break;
    case htmlControlAlignBaseline:
        va = styleVerticalAlignBaseline;
        break;
    case htmlControlAlignAbsBottom:
        va = styleVerticalAlignBottom;
        break;
    case htmlControlAlignBottom:
        va = styleVerticalAlignTextBottom;
        break;
    case htmlControlAlignMiddle:
        va = styleVerticalAlignMiddle;
        break;
    case htmlControlAlignTop:
        va = styleVerticalAlignTop;
        break;
    default:
        Assert(FALSE);
    }

    if (styleVerticalAlignAuto != va)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff().SetVerticalAlign((styleVerticalAlign)va);
        pCFI->UnprepareForDebug();
    }
    pCFI->_bControlAlign = at;
}

void ApplyParagraphAlignment ( CFormatInfo *pCFI, htmlBlockAlign at, CElement *pElem )
{
    if ( at == htmlBlockAlignNotSet )
        return;

    switch(at)
    {
    case htmlBlockAlignRight:
    case htmlBlockAlignLeft:
    case htmlBlockAlignCenter:
        pCFI->_bBlockAlign = at;
        break;
    case htmlBlockAlignJustify:
        if (pElem->Tag() != ETAG_CAPTION)   // ignore Justify for captions,
                                            // we use Justify enum in cpation.pdl just to be consistent
                                            // with the rest of the block alignment enums.
        {
            pCFI->_bBlockAlign = at;
        }
        break;
    default:
        if (pElem->Tag() == ETAG_CAPTION)
        {
            // There's some trickyness going on here.  The caption.pdl
            // specifies the align as DISPID_A_BLOCKALIGN - which means it
            // gets written into the lrcAlign - but caption has two extra
            // ( vertical ) enum values that we need to map onto the equivalent
            // vertical alignment values.

            if ((BYTE)at == htmlCaptionAlignTop || (BYTE)at == htmlCaptionAlignBottom)
            {
                at = (htmlBlockAlign)((BYTE)at == htmlCaptionAlignTop? htmlCaptionVAlignTop: htmlCaptionVAlignBottom);
                if (pCFI->_ppf->_bTableVAlignment != (BYTE)at)
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._bTableVAlignment = (BYTE)at;
                    pCFI->UnprepareForDebug();
                }
                break;
            }
        }
        pCFI->_bBlockAlign = htmlBlockAlignNotSet;
        break;
    }
}

void ApplyVerticalAlignment(CFormatInfo *pCFI, BYTE va, CElement *pElem)
{
    switch (pElem->Tag())
    {
    case ETAG_TD:
    case ETAG_TH:
    case ETAG_COL:
    case ETAG_COLGROUP:
    case ETAG_TBODY:
    case ETAG_TFOOT:
    case ETAG_THEAD:
    case ETAG_TR:
    case ETAG_CAPTION:
        {
            htmlCellVAlign cvt = htmlCellVAlignNotSet;

            switch (va)
            {
            case styleVerticalAlignTop:
            case styleVerticalAlignTextTop:
                cvt = htmlCellVAlignTop;
                break;
            case styleVerticalAlignTextBottom:
            case styleVerticalAlignBottom:
                cvt = htmlCellVAlignBottom;
                break;
            case styleVerticalAlignBaseline:
                cvt = htmlCellVAlignBaseline;
                break;
            case styleVerticalAlignMiddle:
            default:
                cvt = pElem->Tag() != ETAG_CAPTION ? htmlCellVAlignMiddle : htmlCellVAlignTop;
                break;
            }
            if (pCFI->_ppf->_bTableVAlignment != cvt)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = cvt;
                pCFI->UnprepareForDebug();
            }
        }
        break;
    default:
        {
            htmlControlAlign at = htmlControlAlignNotSet;
            BOOL fSetCtrl       = TRUE;

            switch (va)
            {
            case styleVerticalAlignSub:
            case styleVerticalAlignSuper:
                fSetCtrl = FALSE;
                break;

            case styleVerticalAlignTextBottom:
            case styleVerticalAlignBaseline:
                at = htmlControlAlignNotSet;
                break;
            case styleVerticalAlignTop:
                at = htmlControlAlignTop;
                break;
            case styleVerticalAlignTextTop:
                at = htmlControlAlignTextTop;
                break;
            case styleVerticalAlignMiddle:
                at = htmlControlAlignMiddle;
                break;
            case styleVerticalAlignBottom:
                at = htmlControlAlignAbsBottom;
                break;
            }

            if (fSetCtrl)
                pCFI->_bControlAlign = at;
        }
        break;
    }
}

void ApplyTableVAlignment ( CParaFormat *pPF, htmlCellVAlign at)
{
    if ( at == htmlCellVAlignNotSet )
        return;
    pPF ->_bTableVAlignment = at;

}

void ApplyLineHeight( CCharFormat *pCF, CUnitValue *cuv )
{
    Assert( pCF && cuv );

    if ( ( cuv->GetUnitType() == CUnitValue::UNIT_ENUM ) && ( cuv->GetUnitValue() == styleNormalNormal ) )
        cuv->SetNull();

    pCF->_cuvLineHeight = *cuv;

}

BOOL ConvertCSSToFmBorderStyle( long lCSSBorderStyle, BYTE *pbFmBorderStyle )
{
    switch ( lCSSBorderStyle )
    {
    case styleBorderStyleNotSet: // No change
        return FALSE;
    case styleBorderStyleDotted:
        *pbFmBorderStyle = fmBorderStyleDotted;
        break;
    case styleBorderStyleDashed:
        *pbFmBorderStyle = fmBorderStyleDashed;
        break;
    case styleBorderStyleDouble:
        *pbFmBorderStyle = fmBorderStyleDouble;
        break;
    case styleBorderStyleSolid:
        *pbFmBorderStyle = fmBorderStyleSingle;
        break;
    case styleBorderStyleGroove:
        *pbFmBorderStyle = fmBorderStyleEtched;
        break;
    case styleBorderStyleRidge:
        *pbFmBorderStyle = fmBorderStyleBump;
        break;
    case styleBorderStyleInset:
        *pbFmBorderStyle = fmBorderStyleSunken;
        break;
    case styleBorderStyleOutset:
        *pbFmBorderStyle = fmBorderStyleRaised;
        break;
    case styleBorderStyleWindowInset:
        *pbFmBorderStyle = fmBorderStyleWindowInset;
        break;
    case styleBorderStyleNone:
        *pbFmBorderStyle = fmBorderStyleNone;
        break;
    default:
        Assert( FALSE && "Unknown Border Style!" );
        return FALSE;
    }
    return TRUE;
}

void ApplyLang(CCharFormat *pCF, LPTSTR achLang)
{
    if (!pCF)
        return;

    pCF->_lcid = mlang().LCIDFromString(achLang);
}

//+------------------------------------------------------------------------
//
//  Method:     ::ApplyAttrArrayValues
//
//  Synopsis:   Apply all the CAttrValues in a CAttrArray to a given set of formats.
//
//      If passType is APPLY_All, work normally.  If passType is APPLY_ImportantOnly,
//  then only apply attrvals with the "!important" bit set.  If passType is
//  APPLY_NoImportant, then only apply attrvals that do not have the "!important"
//  bit set - but if pfContainsImportant is non-NULL, set it to TRUE if you see
//  an attrval with the "!important" bit set.
//
//+------------------------------------------------------------------------
HRESULT ApplyAttrArrayValues (
    CStyleInfo *pStyleInfo,
    CAttrArray **ppAA,
    CachedStyleSheet *pStyleCache /* = NULL */,
    ApplyPassType passType /*=APPLY_All*/,
    BOOL *pfContainsImportant /*=NULL*/,
    BOOL fApplyExpandos /*= TRUE */,
    DISPID dispidSetValue /* = 0 */)
{
    // Apply all Attr values
    HRESULT hr = S_OK;

    Assert(ppAA);
    if ( !*ppAA || (*ppAA) -> Size() == 0 )
        return S_OK;

    if (passType == APPLY_Behavior)
    {
        hr = THR(ApplyBehaviorProperty(
            *ppAA,
            (CBehaviorInfo*) pStyleInfo,
            pStyleCache));
    }
    else // if (passType != APPLY_Init)
    {
        CFormatInfo *pCFI;
        CAttrValue *pAV;  //The current AttrValue.  Only valid when nAA>0
        INT i;
        VARIANT varVal;
        
        pAV = (CAttrValue *)*(CAttrArray *)(*ppAA);

        pCFI = (CFormatInfo*)pStyleInfo;

        // Apply regular attributes
        for ( i = 0 ; i < (*ppAA) -> Size() ; i++, pAV++ )
        {
            // When applying extra values apply only the value that was requested
            if ((pCFI->_eExtraValues & ComputeFormatsType_GetValue) && 
                pAV->GetDISPID() != pCFI->_dispIDExtra)
                continue;

            pAV->GetAsVariantNC(&varVal);

            // Apply these only if they're set & actual properties
            if ( pAV->IsStyleAttribute() )
            {
                if ( ( passType == APPLY_All ) ||   // Normal pass
                     ( passType == APPLY_NoImportant && !pAV->IsImportant() ) ||    // Only non-important properties
                     ( passType == APPLY_ImportantOnly && pAV->IsImportant() ) )    // Important properties only
                {                    
                    hr = THR(ApplyFormatInfoProperty ( pAV->GetPropDesc(), pAV->GetDISPID(),
                        varVal, pCFI, pStyleCache, ppAA  ));
                    if ( hr )
                        break;

                    // If there's an expression with the same DISPID, now is the time to delete it.
                    //
                    // NOTE: (michaelw) this work should go away when CAttrValueExpression comes into being.
                    //
                    // If dispidSetValue is set then we do not overwrite expressions with that dispid
                    // dispidSetValue == 0 means that we overwrite any and all expressions
                    //
                    // Expression values never overwrite expressions (hence the !pAV->IsExpression())
                    //
                    if (!pAV->IsExpression() && pCFI->_pff->_fHasExpressions && ((dispidSetValue == 0) || (dispidSetValue != pAV->GetDISPID())))
                    {
                        CAttrArray *pAA = pCFI->GetAAExpando();

                        if (pAA)
                        {
#if DBG == 1
                            {
                                CAttrValue *pAVExpr = pAA->Find(pAV->GetDISPID(), CAttrValue::AA_Expression, NULL, FALSE);
                                if (pAVExpr)
                                {
                                    TraceTag((tagRecalcStyle, "ApplyAttrArrayValues: overwriting expression: dispid: %08x expr: %ls with value dispid: %08x", pAVExpr->GetDISPID(), pAVExpr->GetLPWSTR(), pAV->GetDISPID()));
                                }
                            }
#endif
                            pAA->FindSimpleAndDelete(pAV->GetDISPID(), CAttrValue::AA_Expression);
                        }

                    }
                }
                if ( pfContainsImportant && pAV->IsImportant())
                    *pfContainsImportant = TRUE;

            }
            else if(fApplyExpandos && passType != APPLY_ImportantOnly && (pAV->AAType() == CAttrValue::AA_Expando))
            {
                CAttrArray * pAA = pCFI->GetAAExpando();
                hr = THR(CAttrArray::Set(&pAA, pAV->GetDISPID(), &varVal, NULL, CAttrValue::AA_Expando));
                if(hr)
                    break;
            }
            else if (   fApplyExpandos 
                     && passType != APPLY_ImportantOnly 
                     && pAV->AAType() == CAttrValue::AA_Expression
                     && pCFI->GetMatchedBy() == pelemNone
                    )
            {

                TraceTag((tagRecalcStyle, "ApplyAttrArrayValues: cascading expression %08x '%ls'", pAV->GetDISPID(), pAV->GetLPWSTR()));
                CAttrArray *pAA = pCFI->GetAAExpando();
                hr = THR(CAttrArray::Set(&pAA, pAV->GetDISPID(), &varVal, NULL, CAttrValue::AA_Expression));
                if (hr)
                    break;
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._fHasExpressions = TRUE;
                pCFI->UnprepareForDebug();
            }
        }  // eo for ( i = 0 ; i < (*ppAA) -> Size() ; i++, pAV++ )
    } // eo if (passType != APPLY_Init)

    RRETURN(hr);
}

// Convert attribute to style list types.
static styleListStyleType ListTypeToStyle (htmlListType type)
{
    styleListStyleType retType;
    switch (type)
    {
        default:
        case htmlListTypeNotSet:
            retType = styleListStyleTypeNotSet;
            break;
        case htmlListTypeLargeAlpha:
            retType = styleListStyleTypeUpperAlpha;
            break;
        case htmlListTypeSmallAlpha:
            retType = styleListStyleTypeLowerAlpha;
            break;
        case htmlListTypeLargeRoman:
            retType = styleListStyleTypeUpperRoman;
            break;
        case htmlListTypeSmallRoman:
            retType = styleListStyleTypeLowerRoman;
            break;
        case htmlListTypeNumbers:
            retType = styleListStyleTypeDecimal;
            break;
        case htmlListTypeDisc:
            retType = styleListStyleTypeDisc;
            break;
        case htmlListTypeCircle:
            retType = styleListStyleTypeCircle;
            break;
        case htmlListTypeSquare:
            retType = styleListStyleTypeSquare;
            break;
    }
    return retType;
}

//+---------------------------------------------------------------------------
//
// Helper class: CUrlStringIterator
//
//----------------------------------------------------------------------------

class CUrlStringIterator
{
public:

    CUrlStringIterator();
    ~CUrlStringIterator();
    void            Init(LPTSTR pch);
    void            Unroll();
    void            Step();
    inline BOOL     IsEnd()   { return 0 == _pchStart[0]; };
    inline BOOL     IsError() { return S_OK != _hr; }
    inline LPTSTR   Current() { return _pchStart; };

    HRESULT _hr;
    LPTSTR  _pch;
    LPTSTR  _pchStart;
    LPTSTR  _pchEnd;
    TCHAR   _chEnd;
};

CUrlStringIterator::CUrlStringIterator()
{
    memset (this, 0, sizeof(*this));
}

CUrlStringIterator::~CUrlStringIterator()
{
    Unroll();
}

void
CUrlStringIterator::Init(LPTSTR pch)
{
    _hr = S_OK;
    _pch = pch;

    Assert (_pch);

    Step();
}

void
CUrlStringIterator::Unroll()
{
    if (_pchEnd)
    {
        *_pchEnd = _chEnd;
        _pchEnd =  NULL;
    }
}

void
CUrlStringIterator::Step()
{
    Unroll();

    //
    // CONSIDER (alexz) using a state machine instead
    //

    _pchStart = _pch;

    // skip spaces or commas
    while (_istspace(*_pchStart) || _T(',') == *_pchStart)
        _pchStart++;

    if (0 == *_pchStart)
        return;

    // verify presence of "URL" prefix
    if (0 != StrCmpNIC(_pchStart, _T("URL"), 3))
        goto Error;

    _pchStart += 3; // step past "URL"

    // skip spaces between "URL" and "("
    while (_istspace(*_pchStart))
        _pchStart++;

    // verify presence of "("
    if (_T('(') != *_pchStart)
        goto Error;

    _pchStart++; // step past "("

    // skip spaces following "("
    while (_istspace(*_pchStart))
        _pchStart++;

    // verify that not end yet
    if (0 == *_pchStart)
        goto Error;

    // if quoted string...
    if (_T('\'') == *_pchStart || _T('"') == *_pchStart)
    {
        TCHAR       chClosing;

        chClosing = *_pchStart;
        _pchStart++;

        _pch = _pchStart;

        while (0 != *_pch && chClosing != *_pch)
            _pch++;

        // verify that not end yet
        if (0 == *_pch)
            goto Error;

        _pchEnd = _pch;

        _pch++; // step past quote
    }
    else // if not quoted
    {
        _pch = _pchStart;

        // scan to end, ")" or space
        while (0 != *_pch && _T(')') != *_pch && !_istspace(*_pch))
            _pch++;

        // verify that not end yet
        if (0 == *_pch)
            goto Error;

        _pchEnd = _pch;
    }

    // skip spaces
    while (_istspace(*_pch))
        _pch++;

    if (_T(')') != *_pch)
        goto Error;

    _pch++;

    // null-terminate current url (Unroll restores it)
    _chEnd = *_pchEnd;
    *_pchEnd = 0;

    return;

Error:
    _pchEnd = NULL;
    _hr = E_INVALIDARG;
    return;
}

//+---------------------------------------------------------------------------
//
// Helper:      ApplyBehaviorProperty
//
//----------------------------------------------------------------------------

HRESULT
ApplyBehaviorProperty (
    CAttrArray *        pAA,
    CBehaviorInfo *     pInfo,
    CachedStyleSheet *  pSheetCache)
{
    HRESULT             hr = S_OK;
    LPTSTR              pchUrl;
    CAttrValue *        pAV;
    AAINDEX             aaIdx = AA_IDX_UNKNOWN;
    CUrlStringIterator  iterator;

    pAV = pAA->Find(DISPID_A_BEHAVIOR, CAttrValue::AA_Attribute, &aaIdx);
    if (!pAV)
        goto Cleanup;

    pInfo->_acstrBehaviorUrls.Free();

    Assert (VT_LPWSTR == pAV->GetAVType());

    pchUrl = pAV->GetString();
    if (!pchUrl || !pchUrl[0])
        goto Cleanup;

    iterator.Init(pchUrl);
    while (!iterator.IsEnd() && !iterator.IsError())
    {
        hr = THR(pInfo->_acstrBehaviorUrls.AddNameToAtomTable(iterator.Current(), NULL));
        if (hr)
            goto Cleanup;

        iterator.Step();
    }

Cleanup:
    RRETURN (hr);
}

BOOL FilterForPseudoCore(DISPID aSupport[], LONG len, DISPID dispID)
{
    LONG i;
    for (i = 0; i < len; i++)
    {
        if (aSupport[i] == dispID)
            return TRUE;
    }
    return FALSE;
}

BOOL FilterForPseudoElement(EPseudoElement pPseudoElem, DISPID dispID)
{
    static DISPID aSupportedByBoth[] = {
        // Font properties
        DISPID_A_FONT, DISPID_A_FONTSIZE, DISPID_A_FONTSTYLE, DISPID_A_FONTVARIANT,
        DISPID_A_FONTFACE, DISPID_A_BASEFONT, DISPID_A_FONTWEIGHT,

        // Color and background
        DISPID_A_COLOR, DISPID_BACKCOLOR, DISPID_A_BACKGROUNDIMAGE, DISPID_A_BACKGROUNDPOSX,
        DISPID_A_BACKGROUNDPOSY, DISPID_A_BACKGROUNDREPEAT, DISPID_A_BACKGROUNDATTACHMENT,

        // Text properties
        DISPID_A_TEXTDECORATION, DISPID_A_VERTICALALIGN, DISPID_A_TEXTTRANSFORM,

        // Line height and clear
        DISPID_A_LINEHEIGHT, DISPID_A_CLEAR,
    };
    static DISPID aSupportedByLetter[] = {
        // Margins
        DISPID_A_MARGINTOP, DISPID_A_MARGINBOTTOM,
        DISPID_A_MARGINLEFT, DISPID_A_MARGINRIGHT,

        // Borders
        DISPID_A_BORDERTOPSTYLE, DISPID_A_BORDERRIGHTSTYLE,
        DISPID_A_BORDERBOTTOMSTYLE, DISPID_A_BORDERLEFTSTYLE,
        
        DISPID_A_BORDERTOPCOLOR, DISPID_A_BORDERRIGHTCOLOR,
        DISPID_A_BORDERBOTTOMCOLOR, DISPID_A_BORDERLEFTCOLOR,
        
        DISPID_A_BORDERTOPWIDTH, DISPID_A_BORDERRIGHTWIDTH,
        DISPID_A_BORDERBOTTOMWIDTH, DISPID_A_BORDERLEFTWIDTH,

        // Padding
        DISPID_A_PADDINGTOP, DISPID_A_PADDINGRIGHT,
        DISPID_A_PADDINGBOTTOM, DISPID_A_PADDINGLEFT,

        // Float
        DISPID_A_FLOAT,
    };
    static DISPID aSupportedByLine[] = {
        // Character spearation
        DISPID_A_WORDSPACING, DISPID_A_LETTERSPACING,
    };
    BOOL fRet;
    
    if (FilterForPseudoCore(aSupportedByBoth, ARRAY_SIZE(aSupportedByBoth), dispID))
    {
        fRet = TRUE;
    }
    else if (pPseudoElem == pelemFirstLine)
    {
        fRet = FilterForPseudoCore(aSupportedByLine, ARRAY_SIZE(aSupportedByLine), dispID);
    }
    else
    {
        Assert(pPseudoElem == pelemFirstLetter);
        fRet = FilterForPseudoCore(aSupportedByLetter, ARRAY_SIZE(aSupportedByLetter), dispID);
    }
    return fRet;
}

styleLayoutFlow
FilterTagForAlwaysHorizontal(CElement * pElem,
                             styleLayoutFlow wFlowMe,
                             styleLayoutFlow wFlowParent)
{
    styleLayoutFlow wFlowRet = wFlowMe;
#define X(Y) case ETAG_##Y:
    switch(pElem->Tag())
    {
        X(APPLET)   X(AREA)     X(BASE)     X(BASEFONT) X(BGSOUND)  
        X(BODY)     X(COL)      X(COLGROUP) X(FRAME)    X(FRAMESET) X(HEAD)
        X(HTML)     X(IFRAME)   X(IMG)      X(ISINDEX)  X(LINK)     X(MAP)
        X(META)     X(NOFRAMES) X(NOSCRIPT) X(OBJECT)   X(OPTION)   X(PARAM)
        X(SCRIPT)   X(SELECT)   X(STYLE)    X(TABLE)    X(TBODY)    X(TFOOT)
        X(THEAD)    X(TR)       X(GENERIC)  X(OPTGROUP)
        {
            if (   wFlowParent  == styleLayoutFlowVerticalIdeographic
                || wFlowMe      == styleLayoutFlowVerticalIdeographic
               )
            {
                wFlowRet = styleLayoutFlowHorizontal;
            }
            break;
        }
        X(BR) X(WBR)
        {
            wFlowRet = wFlowParent;
            break;
        }
        X(INPUT)
        {
            if (DYNCAST(CInput, pElem)->GetType() == htmlInputImage)
                wFlowRet = styleLayoutFlowHorizontal;
            break;
        }
        default:
            break;
    }
#undef X
    return wFlowRet;
}

BOOL CanApplyMarginProperties(CTreeNode *pNode)
{
    CMarkup *pMarkup = pNode->GetMarkup();
    BOOL fApply;

    if (pNode->Tag() == ETAG_HTML)
    {
        if (   pMarkup->IsPrimaryMarkup()
            || pMarkup->IsPendingPrimaryMarkup()
           )
            fApply = TRUE;
        else
            fApply = FALSE;
    }
    else
        fApply = TRUE;
    return fApply;
}

//+---------------------------------------------------------------------------
//
// Helper:      ApplyFormatInfoProperty
//
//----------------------------------------------------------------------------

HRESULT
ApplyFormatInfoProperty (
    const PROPERTYDESC * pPropertyDesc,
    DISPID dispID,
    VARIANT varValue,
    CFormatInfo *pCFI,
    CachedStyleSheet *pSheetCache,
    CAttrArray  **ppAA )
{
    HRESULT hr = S_OK;

    Assert(pCFI && pCFI->_pNodeContext);

    CElement * pElem          = pCFI->_pNodeContext->Element();
    CMarkup *pMarkup          = pCFI->_pNodeContext->GetMarkup();
    BOOL fComputingFirstLetter = FALSE;
    BOOL fComputingFirstLine = FALSE;

    if (pCFI->GetMatchedBy() != pelemNone)
    {
        CTreeNode *pNode = pCFI->_pNodeContext;
        if (pCFI->GetMatchedBy() == pelemFirstLetter)
        {
            // Call to apply only the first letter relevant properties
            if (FilterForPseudoElement(pelemFirstLetter, dispID))
            {
                CComputeFormatState * pcfState;
                if (    pMarkup->HasCFState() 
                    &&  (pcfState = pMarkup->GetCFState()) != NULL
                    &&  pcfState->GetComputingFirstLetter(pNode))
                {
                    fComputingFirstLetter = TRUE;
                    goto Doit;
                }
                else
                {
                    if (!pCFI->_pff->_fHasFirstLetter)
                    {
                        pCFI->PrepareFancyFormat();
                        pCFI->_ff()._fHasFirstLetter = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                    if (!pCFI->_ppf->_fHasPseudoElement)
                    {
                        pCFI->PrepareParaFormat();
                        pCFI->_pf()._fHasPseudoElement = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                }
            }
        }
        else if (pCFI->GetMatchedBy() == pelemFirstLine)
        {
            // call to apply only the first line relevant properties
            if (FilterForPseudoElement(pelemFirstLine, dispID))
            {
                CComputeFormatState * pcfState;
                if (    pMarkup->HasCFState() 
                    &&  (pcfState = pMarkup->GetCFState()) != NULL
                    &&  pcfState->GetComputingFirstLine(pNode))
                {
                    if (SameScope(pNode, pcfState->GetBlockNodeLine()))
                    {
                        fComputingFirstLine = TRUE;
                        goto Doit;
                    }
                }
                else
                {
                    if (!pCFI->_pff->_fHasFirstLine)
                    {
                        pCFI->PrepareFancyFormat();
                        pCFI->_ff()._fHasFirstLine = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                    if (!pCFI->_ppf->_fHasPseudoElement)
                    {
                        pCFI->PrepareParaFormat();
                        pCFI->_pf()._fHasPseudoElement = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                }
            }
        }
        else
        {
            // Its unknown, do not do anything
        }
        goto Cleanup;
    }

Doit:
    switch ( dispID )
    {
    case STDPROPID_XOBJ_HEIGHT:
        {
            const CUnitValue * pcuv = (const CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetHeight(*pcuv);
                pCFI->_ff().SetHeightPercent(
                         pCFI->_ff().GetHeight().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_TOP).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_BOTTOM).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_WIDTH:
        {
            const CUnitValue * pcuv = (const CUnitValue *)&V_I4(&varValue);
            if ( !pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetWidth(*pcuv);
                pCFI->_ff().SetWidthPercent(
                         pCFI->_ff().GetWidth().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_LEFT).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_RIGHT).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_TOP:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_TOP, *pcuv);
                pCFI->_ff().SetHeightPercent(
                         pCFI->_ff().GetHeight().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_TOP).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_BOTTOM).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_BOTTOM:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_BOTTOM, *pcuv);
                pCFI->_ff().SetHeightPercent(TRUE);
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_LEFT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_LEFT, *pcuv);
                pCFI->_ff().SetWidthPercent(
                         pCFI->_ff().GetWidth().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_LEFT).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_RIGHT).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_RIGHT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_RIGHT, *pcuv);
                pCFI->_ff().SetWidthPercent(TRUE);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_VERTICALALIGN:
        {
            BYTE va;
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);

            if (pcuv->IsNullOrEnum())
            {
                va = pcuv->GetUnitValue();
                if (va >= styleVerticalAlignNotSet)
                    va = styleVerticalAlignAuto;
            }
            else
            {
                va = pcuv->IsPercent() ? styleVerticalAlignPercent : styleVerticalAlignNumber;
            }

            pCFI->PrepareFancyFormat();
            pCFI->PrepareCharFormat();
            pCFI->_ff().SetVerticalAlignValue(*pcuv);
            pCFI->_ff().SetVerticalAlign(va);
            pCFI->_ff().SetCSSVerticalAlign(TRUE);
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
            pCFI->UnprepareForDebug();

            ApplyVerticalAlignment(pCFI, va, pElem);
        }
        break;

    case STDPROPID_XOBJ_CONTROLALIGN:
        {
            BOOL fIsInputNotImage   = (pElem->Tag() == ETAG_INPUT 
                                    && DYNCAST(CInput, pElem)->GetType() != htmlInputImage);
            if (fIsInputNotImage)
               break;
            pCFI->_fCtrlAlignLast = TRUE;
            ApplySiteAlignment(pCFI, (htmlControlAlign) V_I4(&varValue), pElem);
        }
        break;

    case DISPID_A_LISTTYPE:
        {   // This code treads a careful line with Nav3/Nav4/IE3 compat.  Before changing it,
            // please consult CWilso and/or AryeG.
            pCFI->PrepareParaFormat();
            pCFI->_pf().SetListStyleType(ListTypeToStyle ((htmlListType)V_I4(&varValue)));
            if (pElem->Tag() == ETAG_LI)
            {   // LIs inside OLs can't be converted to ULs via attribute, or vice versa.
                switch (pCFI->_pf().GetListStyleType())
                {
                case styleListStyleTypeSquare:
                case styleListStyleTypeCircle:
                case styleListStyleTypeDisc:
                    if (pCFI->_ppf->_cListing.GetType() == CListing::NUMBERING)
                        pCFI->_pf().SetListStyleType(styleListStyleTypeDecimal);
                    break;
                case styleListStyleTypeLowerRoman:
                case styleListStyleTypeUpperRoman:
                case styleListStyleTypeLowerAlpha:
                case styleListStyleTypeUpperAlpha:
                case styleListStyleTypeDecimal:
                    if (pCFI->_ppf->_cListing.GetType() == CListing::BULLET)
                        pCFI->_pf().SetListStyleType(styleListStyleTypeDisc);
                    break;
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_LISTSTYLETYPE:
        {
            styleListStyleType lst = (styleListStyleType)(V_I4(&varValue));
            if (lst != styleListStyleTypeNotSet)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf().SetListStyleType(lst);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_LISTSTYLEPOSITION:
        {
            styleListStylePosition lsp = (styleListStylePosition)(V_I4(&varValue));
            if (lsp != styleListStylePositionNotSet)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bListPosition = lsp;
                pCFI->_pf()._fExplicitListPosition = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BACKGROUNDIMAGE:
        if (pCFI->_fAlwaysUseMyColors)
            break;

        pCFI->_fMayHaveInlineBg = TRUE;
        // fall through!
    case DISPID_A_LISTSTYLEIMAGE:
        // fall through
        {
            TCHAR * pchURL = NULL;
            TCHAR * pchURLToSet;
            CStr *  pcstr = NULL;
            
            Assert(varValue.vt == VT_LPWSTR);

            // If the sheet this attribute is in has an absolute URL then use this
            // url as the base url to construct the relative URL passed in.
            if (varValue.byref && ((LPTSTR)varValue.byref)[0])
            {
                TCHAR *pchAbsURL = pSheetCache
                                   ? pSheetCache->GetBaseURL()
                                   : NULL;

                if (pchAbsURL)
                {
                    hr = THR(ExpandUrlWithBaseUrl(pchAbsURL,
                                                   (LPTSTR)varValue.byref,
                                                   &pchURL));

                    // E_POINTER implies that there was a problem with the URL.
                    // We don't want to set the format, but we also don't want
                    // to propagate the HRESULT to ApplyFormat, as this would
                    // cause the format caches not to be created. (cthrash)

                    if (hr)
                    {
                        hr = (hr == E_POINTER) ? S_OK : hr;
                        break;
                    }
                }
            }

            pchURLToSet = pchURL
                               ? pchURL
                               : (TCHAR *)varValue.byref;

            if (DISPID_A_BACKGROUNDIMAGE == dispID)
            {
                pcstr = (fComputingFirstLetter || fComputingFirstLine) ? 
                            &pCFI->_cstrPseudoBgImgUrl : 
                            &pCFI->_cstrBgImgUrl;
                if (fComputingFirstLetter)
                {
                    pCFI->_fBgImageInFLetter = TRUE;
                }
                else if (fComputingFirstLine)
                {
                    pCFI->_fBgImageInFLine = TRUE;
                }
            }
            else if (DISPID_A_LISTSTYLEIMAGE == dispID)
            {
                pcstr = &pCFI->_cstrLiImgUrl;
            }
            pCFI->_fHasSomeBgImage = TRUE;
            pcstr->Set(pchURLToSet);
            MemFreeString(pchURL);
        }
        break;

    case DISPID_A_BORDERTOPSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_TOP, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_TOP, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_TOP, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;
        
    case DISPID_A_BORDERRIGHTSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_RIGHT, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_RIGHT, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_RIGHT, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;
        
    case DISPID_A_BORDERBOTTOMSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_BOTTOM, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_BOTTOM, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_BOTTOM, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;
        
    case DISPID_A_BORDERLEFTSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_LEFT, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_LEFT, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_LEFT, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_MARGINTOP:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                pCFI->_fHasCSSTopMargin = !!pPropertyDesc->IsStyleSheetProperty();
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_TOP, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_TOP, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_TOP, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case DISPID_A_MARGINBOTTOM:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_BOTTOM, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_BOTTOM, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_BOTTOM, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_MARGINLEFT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                pCFI->_fHasCSSLeftMargin = !!pPropertyDesc->IsStyleSheetProperty();
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_LEFT, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_LEFT, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_LEFT, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_MARGINRIGHT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_RIGHT, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_RIGHT, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_RIGHT, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_CLEAR:
        if (fComputingFirstLetter || fComputingFirstLine)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fClearFromPseudo = TRUE;
            pCFI->UnprepareForDebug();
        }
        ApplyClear(pElem, (htmlClear) V_I4(&varValue), pCFI);
        break;

    case DISPID_A_PAGEBREAKBEFORE:
        if (V_I4(&varValue))
        {
            pCFI->PrepareFancyFormat();
            SET_PGBRK_BEFORE(pCFI->_ff()._bPageBreaks,V_I4(&varValue));

            pCFI->UnprepareForDebug();
        }
        break;
    case DISPID_A_PAGEBREAKAFTER:
        if (V_I4(&varValue))
        {
            pCFI->PrepareFancyFormat();
            SET_PGBRK_AFTER(pCFI->_ff()._bPageBreaks,V_I4(&varValue));

            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_COLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._ccvTextColor = *pccv;
                pCFI->_fFontColorSet = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_DISPLAY:
        // We can only display this element if the parent is not display:none.
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bDisplay = V_I4(&varValue);
        pCFI->_fDisplayNone = !!(pCFI->_ff()._bDisplay == styleDisplayNone);
        // Some elements have a default of TRUE for _fRectangular, set in ApplyDefaultFormats.  Don't disturb that!
        if (V_I4(&varValue) == styleDisplayInlineBlock)
            pCFI->_ff()._fRectangular = TRUE;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_VISIBILITY:
        if (!g_fInWin98Discover ||
            !pCFI->_pcfSrc->_fVisibilityHidden)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bVisibility = V_I4(&varValue);

            if (pCFI->_pff->_bVisibility == styleVisibilityHidden)
                 pCFI->_fVisibilityHidden = TRUE;
            else if (pCFI->_pff->_bVisibility == styleVisibilityVisible)
                 pCFI->_fVisibilityHidden = FALSE;
            else if (pCFI->_pff->_bVisibility == styleVisibilityInherit)
                 pCFI->_fVisibilityHidden = pCFI->_pcfSrc->_fVisibilityHidden;
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_IMEMODE:
    case DISPID_A_RUBYOVERHANG:
    case DISPID_A_RUBYALIGN:
        if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        break;

    case DISPID_A_SCROLLBARBASECOLOR:
    case DISPID_A_SCROLLBARFACECOLOR:
    case DISPID_A_SCROLLBAR3DLIGHTCOLOR:
    case DISPID_A_SCROLLBARSHADOWCOLOR:
    case DISPID_A_SCROLLBARHIGHLIGHTCOLOR:
    case DISPID_A_SCROLLBARDARKSHADOWCOLOR:
    case DISPID_A_SCROLLBARARROWCOLOR:
    case DISPID_A_SCROLLBARTRACKCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            pCFI->PrepareParaFormat();
            pCFI->_pf()._fHasScrollbarColors = !pccv->IsNull();
            pCFI->UnprepareForDebug();
            if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
            {
                *pCFI->_pvarExtraValue = varValue;
            }
        }
        break;

    case DISPID_A_RUBYPOSITION:
        if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
        }
        if(pElem->Tag() == ETAG_RUBY)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fIsRuby = (styleRubyPositionInline != V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_TEXTTRANSFORM:
        {
            if ( styleTextTransformNotSet != V_I4(&varValue) )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._bTextTransform = (BYTE)V_I4(&varValue);
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_LETTERSPACING:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._cuvLetterSpacing = *puv;
                pCFI->_cf()._fHasLetterOrWordSpacing = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

        
    case DISPID_A_WORDSPACING:
    {
        CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
        if ( !puv->IsNull() )
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._cuvWordSpacing = *puv;
            pCFI->_cf()._fHasLetterOrWordSpacing = TRUE;
            pCFI->UnprepareForDebug();
        }
    }
    break;
        
    case DISPID_A_OVERFLOWX:
        if ( V_I4(&varValue) != styleOverflowNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetOverflowX((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_OVERFLOWY:
        if ( V_I4(&varValue) != styleOverflowNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetOverflowY((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_OVERFLOW:
        if ( V_I4(&varValue) != styleOverflowNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetOverflowX((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->_ff().SetOverflowY((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_PADDINGTOP:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_TOP, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_TOP, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentVertPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingTopSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_PADDINGRIGHT:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_RIGHT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_RIGHT, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentHorzPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingRightSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_PADDINGBOTTOM:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_BOTTOM, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_BOTTOM, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentVertPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingBottomSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_PADDINGLEFT:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_LEFT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_LEFT, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentHorzPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingLeftSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TABLEBORDERCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                pCFI->_ff()._bd.SetBorderColor(SIDE_TOP, *pccv);
                pCFI->_ff()._bd.SetBorderColor(SIDE_RIGHT, *pccv);
                pCFI->_ff()._bd.SetBorderColor(SIDE_BOTTOM, *pccv);
                pCFI->_ff()._bd.SetBorderColor(SIDE_LEFT, *pccv);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TABLEBORDERCOLORLIGHT:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                pCFI->_ff()._bd._ccvBorderColorLight = *pccv;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TABLEBORDERCOLORDARK:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                pCFI->_ff()._bd._ccvBorderColorDark = *pccv;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERTOPCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_TOP, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_TOP );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_TOP, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_TOP );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_BORDERRIGHTCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_RIGHT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_RIGHT );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_RIGHT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_RIGHT );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_BORDERBOTTOMCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_BOTTOM, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_BOTTOM );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_BOTTOM, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_BOTTOM );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERLEFTCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_LEFT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_LEFT );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_LEFT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_LEFT );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_BORDERTOPWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_TOP, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_TOP, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERRIGHTWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_RIGHT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_RIGHT, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERBOTTOMWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_BOTTOM, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_BOTTOM, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERLEFTWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_LEFT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_LEFT, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_POSITION:
        if (V_I4(&varValue) != stylePositionNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bPositionType = (BYTE)V_I4(&varValue);
            // Body's don't support being positioned, even though they are a positioning parent by default.
            pCFI->_ff()._fRelative = (pElem->Tag() != ETAG_BODY)  
                ? (pCFI->_ff()._bPositionType == stylePositionrelative)
                : FALSE;
            pCFI->_fRelative = pCFI->_ff()._fRelative;
            pCFI->UnprepareForDebug();

            #if DBG==1
            if(pCFI->_pff->_bPositionType == stylePositionabsolute || pCFI->_pff->_bPositionType == stylePositionrelative)
            {
                // 
                // (IEv60 35609) If formats are computed during unloading content CDoc::UnloadContents() first 
                // clears _fRegionCollection flag and then calls CMarkup::TearDownMarkup() that caused the Assert 
                // below to fire. There are two possible incorrectnesses that cause this behaviour: 
                // 1) The order of operation in CDoc::UnloadContents() described above;
                // 2) The fact that formats are calculated during unload (more information can be found in 
                //    the bug's description. 
                // Currently we are changing Assert to Check in order to avoid regressions and suppress AF in 
                // WindowsXP CHK builds. 
                // 
                Check(pElem->Doc()->_fRegionCollection &&
                        "Inconsistent _fRegionCollection flag, user style sheet sets the position?");
            }
            #endif
        }
        break;

    case DISPID_A_ZINDEX:
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._lZIndex = V_I4(&varValue);
        pCFI->UnprepareForDebug();
        break;

    case DISPID_BACKCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull())
            {
                BOOL fTransparent = (pccv->GetType()
                                    == CColorValue::TYPE_TRANSPARENT);

                
                if (fTransparent)
                {
                    //
                    // The assumption that ancestor's draw background color
                    // is not true in the following case(s):
                    //

                    if (!pElem->GetMarkup()->IsPrimaryMarkup())
                    {
                        if (fComputingFirstLetter || fComputingFirstLine)
                        {
                            pCFI->PreparePEI();
                            pCFI->_pei()._ccvBackColor.Undefine();
                        }
                        else
                        {
                            pCFI->PrepareFancyFormat();
                            pCFI->_ff()._ccvBackColor.Undefine();
                            pCFI->_ff().SetThemeDisabled(TRUE);
                        }
                    }
                    //BODY can't be transparent in compat mode (non CSS1)
                    if (    pElem->Tag() != ETAG_BODY
                         || pMarkup->IsHtmlLayout() )
                    {
                        if (fComputingFirstLetter || fComputingFirstLine)
                        {
                            pCFI->PreparePEI();
                            pCFI->_pei()._ccvBackColor.Undefine();
                        }
                        else
                        {
                            pCFI->PrepareFancyFormat();
                            pCFI->_ff()._ccvBackColor.Undefine();
                            pCFI->_ff().SetThemeDisabled(TRUE);
                        }
                    }
                }
                else
                {
                    if (fComputingFirstLetter || fComputingFirstLine)
                    {
                        pCFI->PreparePEI();
                        pCFI->_pei()._ccvBackColor = *pccv;
                    }
                    else
                    {
                        pCFI->PrepareFancyFormat();
                        pCFI->_ff()._ccvBackColor = *pccv;
                        pCFI->_ff().SetThemeDisabled(TRUE);
                    }
                }
                pCFI->UnprepareForDebug();                

                if (fComputingFirstLetter)
                    pCFI->_fBgColorInFLetter = TRUE;
                
                // site draw their own background, so we dont have
                // to inherit their background info
                pCFI->_fHasBgColor = !fTransparent;

                pCFI->_fMayHaveInlineBg = TRUE;
            }
        }
        break;

    case DISPID_A_BACKGROUNDPOSX:
        {
            // Return the value if extra info is requested
            if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
            {
                *pCFI->_pvarExtraValue = varValue;
                break;
            }
            CUnitValue *cuv = (CUnitValue *)&V_I4(&varValue);
            if ( !cuv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                if ( cuv->GetUnitType() == CUnitValue::UNIT_ENUM )
                {
                    long lVal = 0;
                    switch ( cuv->GetUnitValue() )
                    {
                    //  styleBackgroundPositionXLeft - do nothing.
                    case styleBackgroundPositionXCenter:
                        lVal = 50;
                        break;
                    case styleBackgroundPositionXRight:
                        lVal = 100;
                        break;
                    }
                    pCFI->_ff().SetBgPosXValue(lVal * CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult, CUnitValue::UNIT_PERCENT);
                }
                else
                {
                    pCFI->_ff().SetBgPosX(*cuv);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BACKGROUNDPOSY:
        {
            // Return the value if extra info is requested
            if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
            {
                *pCFI->_pvarExtraValue = varValue;
                break;
            }
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if ( !pcuv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                if ( pcuv->GetUnitType() == CUnitValue::UNIT_ENUM )
                {
                    long lVal = 0;
                    switch ( pcuv->GetUnitValue() )
                    {
                    //  styleBackgroundPositionXLeft - do nothing.
                    case styleBackgroundPositionYCenter:
                        lVal = 50;
                        break;
                    case styleBackgroundPositionYBottom:
                        lVal = 100;
                        break;
                    }
                    pCFI->_ff().SetBgPosYValue(lVal * CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult, CUnitValue::UNIT_PERCENT);
                }
                else
                {
                    pCFI->_ff().SetBgPosY(*pcuv);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BACKGROUNDREPEAT:
        {
            const LONG lRepeat = V_I4(&varValue);

            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetBgRepeatX(lRepeat == styleBackgroundRepeatRepeatX ||
                                     lRepeat == styleBackgroundRepeatRepeat);
            pCFI->_ff().SetBgRepeatY(lRepeat == styleBackgroundRepeatRepeatY ||
                                     lRepeat == styleBackgroundRepeatRepeat);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_BACKGROUNDATTACHMENT:
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fBgFixed = V_I4(&varValue) == styleBackgroundAttachmentFixed;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LANG:
        Assert ( varValue.vt == VT_LPWSTR );
        pCFI->PrepareCharFormat();
        ApplyLang(&pCFI->_cf(), (LPTSTR) varValue.byref);
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_FLOAT:
        if (   pElem->Tag() != ETAG_BODY
            && pElem->Tag() != ETAG_FRAMESET
            && pElem->Tag() != ETAG_HTML
            && V_I4(&varValue) != styleStyleFloatNotSet
           )
        {
            pCFI->PrepareFancyFormat();
            if (fComputingFirstLetter)
            {
                styleStyleFloat sf = styleStyleFloat(V_I4(&varValue));
                if (styleStyleFloatLeft == sf)
                {
                    pCFI->_ff()._fHasAlignedFL = TRUE;
                }
            }
            else
                pCFI->_ff()._bStyleFloat = (BYTE)V_I4(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_CLIPRECTTOP:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_TOP, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_CLIPRECTLEFT:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_LEFT, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_CLIPRECTRIGHT:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_RIGHT, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_CLIPRECTBOTTOM:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_BOTTOM, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_FILTER:
        {
            if (pCFI->_cstrFilters.Set(varValue.byref ? (LPTSTR)varValue.byref : NULL) == S_OK)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._pszFilters = pCFI->_cstrFilters;
                pCFI->_fHasFilters = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TEXTINDENT:
        {
            CUnitValue *cuv = (CUnitValue *)&V_I4(&varValue);
            if ( !cuv->IsNull() )
            {
                pCFI->_cuvTextIndent.SetRawValue(V_I4(&varValue));
            }
        }
        break;

    case DISPID_A_TABLELAYOUT:
        // table-layout CSS2 attribute
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bTableLayout = V_I4(&varValue) == styleTableLayoutFixed;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_BORDERCOLLAPSE:
        // border-collapse CSS2 attribute
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._bBorderCollapse = V_I4(&varValue) == styleBorderCollapseCollapse;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_DIR:
        {
            BOOL fRTL = FALSE;
            BOOL fExplicitDir = TRUE;

            switch (V_I4(&varValue))
            {
            case htmlDirNotSet:
                fExplicitDir = FALSE;
                //fall through
            case htmlDirLeftToRight:
                fRTL = FALSE;
                break;
            case htmlDirRightToLeft:
                fRTL = TRUE;
                break;
            default:
                Assert("Fix the .PDL");
                break;
            }

            pCFI->_fBidiEmbed = TRUE;

            pCFI->PrepareCharFormat();
            pCFI->PrepareFancyFormat();
            pCFI->_cf()._fRTL = fRTL;
            pCFI->_ff().SetExplicitDir(fExplicitDir);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_DIRECTION:
        {
            BOOL fRTL = FALSE;
            BOOL fExplicitDir = TRUE;

            switch (V_I4(&varValue))
            {
            case styleDirLeftToRight:
                fRTL = FALSE;
                break;
            case styleDirRightToLeft:
                fRTL = TRUE;
                break;
            case styleDirNotSet:
            case styleDirInherit:
                // Use our parent element's value.
                fRTL = pCFI->_pcfSrc->_fRTL;
                fExplicitDir = FALSE;
                break;
            default:
                Assert("Fix the .PDL");
                break;
            }

            pCFI->PrepareCharFormat();
            pCFI->PrepareFancyFormat();
            pCFI->_cf()._fRTL = fRTL;
            pCFI->_ff().SetExplicitDir(fExplicitDir);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_UNICODEBIDI:
        switch (V_I4(&varValue))
        {
        case styleBidiEmbed:
            pCFI->_fBidiEmbed = TRUE;
            pCFI->_fBidiOverride = FALSE;
            break;
        case styleBidiOverride:
            pCFI->_fBidiEmbed = TRUE;
            pCFI->_fBidiOverride = TRUE;
            break;
        case styleBidiNotSet:
        case styleBidiNormal:
            pCFI->_fBidiEmbed = FALSE;
            pCFI->_fBidiOverride = FALSE;
            break;
        case styleBidiInherit:
            pCFI->_fBidiEmbed = pCFI->_pcfSrc->_fBidiEmbed;
            pCFI->_fBidiOverride = pCFI->_pcfSrc->_fBidiOverride;
            break;
        }
        break;

    case DISPID_A_TEXTAUTOSPACE:
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fTextAutospace = varValue.lVal;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LINEBREAK:
        if (V_I4(&varValue) != styleLineBreakNotSet)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fLineBreakStrict = V_I4(&varValue) == styleLineBreakStrict ? TRUE : FALSE;
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_WORDBREAK:
        if (V_I4(&varValue) != styleWordBreakNotSet)
        {
            Assert( V_I4(&varValue) >= 1 && V_I4(&varValue) <= 3 );
            pCFI->PrepareParaFormat();
            pCFI->_pf()._fWordBreak = V_I4(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_WORDWRAP:
        if (V_I4(&varValue) != styleWordWrapNotSet)
        {
            Assert( V_I4(&varValue) >= 1 && V_I4(&varValue) <= 2 );
            pCFI->PrepareParaFormat();
            pCFI->_pf()._fWordWrap = V_I4(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_TEXTJUSTIFY:
        pCFI->_uTextJustify = V_I4(&varValue);
        break;

    case DISPID_A_TEXTALIGNLAST:
        pCFI->_uTextAlignLast = V_I4(&varValue);
        break;
       
    case DISPID_A_TEXTJUSTIFYTRIM:
        pCFI->_uTextJustifyTrim = V_I4(&varValue);
        break;

    case DISPID_A_TEXTKASHIDA:        
        pCFI->_cuvTextKashida.SetRawValue(V_I4(&varValue));
        break;

    case DISPID_A_TEXTKASHIDASPACE:
        pCFI->_cuvTextKashidaSpace.SetRawValue(V_I4(&varValue));
        break;

    case DISPID_A_WHITESPACE:
        switch (V_I4(&varValue))
        {
            case styleWhiteSpacePre:
                if (pElem->GetMarkup()->SupportsCollapsedWhitespace())
                {
                    pCFI->PrepareParaFormat();            
                    pCFI->_pf()._fTabStops = TRUE;
                    pCFI->_pf()._fHasPreLikeParent = TRUE;
                    pCFI->PrepareFancyFormat();            
                    pCFI->_ff().SetWhitespace(TRUE); 
                    pCFI->UnprepareForDebug();
                    
                    pCFI->_fPre = TRUE;
                    pCFI->_fInclEOLWhite = TRUE;
                    pCFI->_fNoBreak = TRUE;
                }
                break;
                
            case styleWhiteSpaceNowrap:
            case styleWhiteSpaceNormal:
            {
                BOOL fNoWrap = (V_I4(&varValue) == styleWhiteSpaceNowrap);
                    
                if (pElem->GetMarkup()->SupportsCollapsedWhitespace())
                {
                    pCFI->PrepareParaFormat();            
                    pCFI->_pf()._fTabStops = FALSE;
                    pCFI->_pf()._fHasPreLikeParent = FALSE;
                    pCFI->_pf()._fPreInner = FALSE;
                    pCFI->_pf()._fPre = FALSE;
                    
                    pCFI->PrepareFancyFormat();            
                    pCFI->_ff().SetWhitespace(TRUE); 
                    
                    if (!fNoWrap)
                    {
                        pCFI->PrepareCharFormat();
                        pCFI->_cf()._fNoBreak = FALSE;
                        pCFI->_cf()._fNoBreakInner = FALSE;
                    }
                    pCFI->UnprepareForDebug();
                    
                    pCFI->_fPre = FALSE;
                    pCFI->_fInclEOLWhite = FALSE;
                }
                pCFI->_fNoBreak = fNoWrap;
                break;
            }
        }
        
        break;

    case DISPID_A_NOWRAP:
        if ( V_I4(&varValue) )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fHasNoWrap = TRUE;
            pCFI->UnprepareForDebug();
            pCFI->_fNoBreak = TRUE;
        }
        break;


    case DISPID_A_TEXTDECORATION:
        {
            long lTDBits = V_I4(&varValue);
            BOOL fInsideAnchor = FALSE;
            
            pCFI->PrepareCharFormat();
            pCFI->PrepareFancyFormat();

            if (   pCFI->_pcf->_fUnderline
                && (lTDBits & TD_NONE)
               )
            {
                CTreeNode *pNode = pCFI->_pNodeContext->Parent();
                if (pNode)
                    fInsideAnchor = !!pElem->GetMarkup()->SearchBranchForAnchorLink(pNode);
            }

            // Clear text explicity set decoration attributes
            if (pCFI->_pff->_fHasExplicitUnderline || fInsideAnchor)
            {
                pCFI->_cf()._fUnderline = 0;
                pCFI->_ff()._fHasExplicitUnderline   = 0;
            }
            if (pCFI->_pff->_fHasExplicitOverline)
            {
                pCFI->_cf()._fOverline  = 0;
                pCFI->_ff()._fHasExplicitOverline    = 0;
            }
            if (pCFI->_pff->_fHasExplicitLineThrough)
            {
                pCFI->_cf()._fStrikeOut = 0;
                pCFI->_ff()._fHasExplicitLineThrough = 0;
            }

            // Set text decoration attributes
            if (lTDBits & TD_UNDERLINE)
            {
                if (!pCFI->_cf()._fAccelerator || !(pElem->Doc()->_wUIState & UISF_HIDEACCEL))
                {
                    pCFI->_cf()._fUnderline = 1;
                    pCFI->_ff()._fHasExplicitUnderline = 1;
                }
            }
            if (lTDBits & TD_OVERLINE)
            {
                pCFI->_cf()._fOverline  = 1;
                pCFI->_ff()._fHasExplicitOverline = 1;
            }
            if (lTDBits & TD_LINETHROUGH)
            {
                pCFI->_cf()._fStrikeOut = 1;
                pCFI->_ff()._fHasExplicitLineThrough = 1;
            }


            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_ACCELERATOR:
        {
            BOOL fAccelerator = (V_I4(&varValue) == styleAcceleratorTrue);

            pCFI->PrepareCharFormat();

            pCFI->_cf()._fAccelerator = fAccelerator;
            if (fAccelerator)
            {
                pElem->Doc()->_fHaveAccelerators = TRUE;
                if (pElem->Doc()->_wUIState & UISF_HIDEACCEL)
                    pCFI->_cf()._fUnderline = FALSE;
                else
                    pCFI->_cf()._fUnderline = TRUE;
            }

            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_FONT:
        {
            Esysfont eFontType = FindSystemFontByName( (LPTSTR)varValue.byref );
            if ( eFontType != sysfont_non_system )
            {
                pCFI->PrepareCharFormat();
                ApplySystemFont( &pCFI->_cf(), eFontType );
                pCFI->_fFontSet = TRUE;
                pCFI->UnprepareForDebug();                
            }
        }
        break;
    case DISPID_A_FONTSIZE:
        // Return the value if extra info is requested by currentStyle
        if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        if (!pCFI->_fAlwaysUseMyFontSize)
        {
            pCFI->PrepareCharFormat();
            ApplyFontSize(pCFI,
                          (CUnitValue*) (void*) &V_I4(&varValue),
                          pElem->Doc()->_pOptionSettings->fAlwaysUseMyFontSize,
                          fComputingFirstLetter,
                          fComputingFirstLine
                         );
            pCFI->_fFontHeightSet = TRUE;
            pCFI->UnprepareForDebug();            
        }
        break;
        
    case DISPID_A_FONTSTYLE:
        if (pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        pCFI->PrepareCharFormat();
        ApplyFontStyle(&pCFI->_cf(), (styleFontStyle) V_I4(&varValue));
        pCFI->UnprepareForDebug();        
        // Save the value if extra info is requested
        break;
    case DISPID_A_FONTVARIANT:
        if (pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fSmallCaps = (V_I4(&varValue) == styleFontVariantSmallCaps);
        pCFI->UnprepareForDebug();
        break;
    case DISPID_A_FONTFACE:
        // Return the unmodified value if requested for currentStyle
        if (pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        if (!pCFI->_fAlwaysUseMyFontFace)
        {
            pCFI->PrepareCharFormat();
            ApplyFontFace(&pCFI->_cf(), (LPTSTR)V_BSTR(&varValue), AFF_NONE, pElem->Doc(), pElem->GetMarkup());
            if (pCFI->_pcf->NeedAtFont() && !pCFI->_pcf->_fExplicitAtFont)
            {
                ApplyAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
            }
            pCFI->_fFontSet = TRUE;
            pCFI->UnprepareForDebug();
        }
        break;
    case DISPID_A_BASEFONT:
        pCFI->PrepareCharFormat();
        ApplyBaseFont(&pCFI->_cf(), (long) V_I4(&varValue));
        pCFI->_fFontHeightSet = TRUE;
        pCFI->UnprepareForDebug();        
        break;
    case DISPID_A_FONTWEIGHT:
        pCFI->PrepareCharFormat();
        ApplyFontWeight(&pCFI->_cf(), (styleFontWeight) V_I4(&varValue));
        pCFI->_fFontWeightSet = TRUE;
        pCFI->UnprepareForDebug();        
        break;
    case DISPID_A_LINEHEIGHT:
        pCFI->PrepareCharFormat();
        ApplyLineHeight(&pCFI->_cf(), (CUnitValue*) &V_I4(&varValue));
        pCFI->UnprepareForDebug();
        break;
    case DISPID_A_TABLEVALIGN:
        pCFI->PrepareParaFormat();
        ApplyTableVAlignment(&pCFI->_pf(), (htmlCellVAlign) V_I4(&varValue) );
        pCFI->UnprepareForDebug();
        break;

    case STDPROPID_XOBJ_BLOCKALIGN:
        pCFI->_fCtrlAlignLast = FALSE;
        ApplyParagraphAlignment(pCFI, (htmlBlockAlign) V_I4(&varValue), pElem);
        break;

    case DISPID_A_CURSOR:
        {
            pCFI->PrepareCharFormat();
            Assert( V_VT( & varValue ) == VT_I4 );
            
            pCFI->_cf()._bCursorIdx = V_I4( & varValue );            
            if (  pCFI->_cf()._bCursorIdx == styleCursorcustom )
            {
                CCustomCursor* pCursor = pCFI->GetCustomCursor();
                
                if ( pCursor )
                {
                    CStr cstrCustom;
                    pPropertyDesc->GetBasicPropParams()->GetCustomString( ppAA, &cstrCustom );
                    
                    pCursor->Init( cstrCustom ,pElem  );
                }
            }            
            pCFI->UnprepareForDebug();
        }
        break;
    case STDPROPID_XOBJ_DISABLED:
        if (V_BOOL(&varValue))
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fDisabled = V_BOOL(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_LAYOUTGRIDCHAR:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._cuvCharGridSizeInner = (CUnitValue)(V_I4(&varValue));

        // In case of change of layout-grid-char, layout-grid-mode must be updated 
        // if its value is not set. This helps handle default values.
        if (    pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNotSet
            ||  (   pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeNone
                &&  pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeBoth))
        {
            pCFI->PrepareCharFormat();

            // Now _uLayoutGridModeInner can be one of { 000, 101, 110, 111 }
            // it means that layout-grid-mode is not set

            if (pCFI->_pf()._cuvCharGridSizeInner.IsNull())
            {   // clear deduced char mode
                pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeLine);
                if (pCFI->_cf()._uLayoutGridModeInner == styleLayoutGridModeNone)
                    pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
            }
            else
            {   // set deduced char mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeChar);
            }
        }
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LAYOUTGRIDLINE:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._cuvLineGridSizeInner = (CUnitValue)(V_I4(&varValue));

        // In case of change of layout-grid-line, layout-grid-mode must be updated 
        // if its value is not set. This helps handle default values.
        if (    pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNotSet
            ||  (   pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeNone
                &&  pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeBoth))
        {
            pCFI->PrepareCharFormat();

            // Now _uLayoutGridModeInner can be one of { 000, 101, 110, 111 }
            // it means that layout-grid-mode is not set

            if (pCFI->_pf()._cuvLineGridSizeInner.IsNull())
            {   // clear deduced line mode
                pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeChar);
                if (pCFI->_cf()._uLayoutGridModeInner == styleLayoutGridModeNone)
                    pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
            }
            else
            {   // set deduced line mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeLine);
            }
        }
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LAYOUTGRIDMODE:
        pCFI->PrepareCharFormat();
        pCFI->_cf()._uLayoutGridModeInner = V_I4(&varValue);

        // Handle default values of layout-grid-mode.
        if (pCFI->_cf()._uLayoutGridModeInner == styleLayoutGridModeNotSet)
        {
            if (!pCFI->_ppf->_cuvCharGridSizeInner.IsNull())
            {   // set deduced char mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeChar);
            }
            if (!pCFI->_ppf->_cuvLineGridSizeInner.IsNull())
            {   // set deduced line mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeLine);
            }
        }
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LAYOUTGRIDTYPE:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._uLayoutGridTypeInner = V_I4(&varValue);
        pCFI->UnprepareForDebug();
        break;

#ifdef IE6_WYSIWYG_OM
    case DISPID_A_ROTATE:
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._lRotationAngle = (long)(V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;
#endif //IE6_WYSIWYG_OM
    case DISPID_A_ZOOM:
        {
            if (    pElem->Tag() != ETAG_HTML
                ||  !pMarkup->IsHtmlLayout() )
            {
                pCFI->PrepareFancyFormat();

                CUnitValue cuv = (CUnitValue)(V_I4(&varValue));

                switch (cuv.GetUnitType())
                {
                case CUnitValue::UNIT_ENUM:
                    Assert (cuv.GetRawValue() == 0xf); // we only have 1 enum && its value = 0
                    pCFI->_ff()._flZoomFactor = 0.0;
                    break;

                case CUnitValue::UNIT_PERCENT:
                    pCFI->_ff()._flZoomFactor = 1.0*cuv.GetPercent() / CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult;
                    break;

                case CUnitValue::UNIT_FLOAT:
                    // "2" is 200%; 1.25 is 125%; 1 is 100% ...
                    pCFI->_ff()._flZoomFactor = 1.0*cuv.GetUnitValue() / CUnitValue::TypeNames[CUnitValue::UNIT_FLOAT].wScaleMult;
                    break;

                default:
                    hr = E_INVALIDARG;
                    break;
                }

                if (pCFI->_ff()._flZoomFactor < 0.0)
                    pCFI->_ff()._flZoomFactor = 0.0;  // use 'Normal" if they set a negative zoom

                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_LAYOUTFLOW:
    case DISPID_A_WRITINGMODE:
        {
            styleLayoutFlow flow;

            if (DISPID_A_LAYOUTFLOW == dispID)
            {
                flow = (styleLayoutFlow)V_I4(&varValue);
            }
            else
            {
                // layout-flow and writing mode are synonyms in trident
                switch((styleWritingMode)V_I4(&varValue))
                {
                    case styleWritingModeLrtb:   flow = styleLayoutFlowHorizontal; break;
                    case styleWritingModeTbrl:   flow = styleLayoutFlowVerticalIdeographic; break;
                    case styleWritingModeNotSet:
                    default:                     flow = styleLayoutFlowNotSet; break;
                }
            }

            CTreeNode * pNodeParent = pCFI->_pNodeContext->Parent();
            styleLayoutFlow flowParent = pNodeParent ? (styleLayoutFlow)pNodeParent->GetCharFormat()->_wLayoutFlow : styleLayoutFlowHorizontal;

            flow = FilterTagForAlwaysHorizontal(pElem, flow, flowParent);
            
            if (flow != styleLayoutFlowNotSet)
            {
                pCFI->PrepareCharFormat();

                if (flow != pCFI->_pcf->_wLayoutFlow)
                {

                    // Check if layout-flow is changing
                    bool fSelfHorizontal   = (styleLayoutFlowHorizontal == flow);
                    bool fParentHorizontal = (styleLayoutFlowHorizontal == flowParent);
                    pCFI->PrepareFancyFormat();
                    if (fSelfHorizontal != fParentHorizontal)
                    {
                        pCFI->_ff()._fLayoutFlowChanged = TRUE;
                        pElem->GetMarkup()->_fHaveDifferingLayoutFlows = TRUE;                        
                    }
                    else
                    {
                        pCFI->_ff()._fLayoutFlowChanged = FALSE;
                    }

                    pCFI->_cf()._wLayoutFlow = flow;

                    if (!pCFI->_pcf->_fExplicitAtFont)
                    {
                        if (pCFI->_pcf->NeedAtFont())
                        {
                            ApplyAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                        else
                        {
                            RemoveAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                    }
                }
                else if (pCFI->_pcf->_latmFaceName != pCFI->_pcfSrc->_latmFaceName)
                {
                    if (!pCFI->_pcf->_fExplicitAtFont)
                    {
                        if (pCFI->_pcf->NeedAtFont())
                        {
                            ApplyAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                        else
                        {
                            RemoveAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                    }
                }
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._fLayoutFlowSet = TRUE;
                pCFI->_cf()._fWritingModeUsed = DISPID_A_WRITINGMODE == dispID;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TEXTUNDERLINEPOSITION:
        {
            styleTextUnderlinePosition up = (styleTextUnderlinePosition)V_I4(&varValue);
            if (up != styleTextUnderlinePositionNotSet)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._bTextUnderlinePosition = (styleTextUnderlinePosition)V_I4(&varValue);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TEXTOVERFLOW:
        {
            styleTextOverflow to = (styleTextOverflow)V_I4(&varValue);
            if (to != styleTextOverflowNotSet)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetTextOverflow(to);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_MINHEIGHT:
        {
            const CUnitValue * pcuv = (const CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetMinHeight(*pcuv);
                pCFI->_ff().SetMinHeightPercent(pcuv->IsPercent());
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_EDITABLE:
        {
            BOOL fEditable = FALSE;

            //
            // For IE5.5 - we will not allow contentEditable to be set on tables, or parts of tables.
            //

            if (    pElem->_etag != ETAG_TABLE
                &&  pElem->_etag != ETAG_HTML
                &&  !pElem->IsTablePart(  ) )
            {
            
                switch ((htmlEditable)V_I4(&varValue))
                {

                case htmlEditableInherit:
                    // _fParentEditable can be set only for input and text area, if so, fall thru and set to true.
                    if (!pCFI->_fParentEditable)
                        break;
                    // else fall through ...

                case htmlEditableTrue:
                    fEditable = TRUE;
                    // fall through ...

                case htmlEditableFalse:
                    // change only if different.
                    if (pCFI->_pcf->_fEditable != fEditable)
                    {
                        pCFI->PrepareCharFormat();
                        pCFI->_cf()._fEditable = fEditable;
                    }

                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._fContentEditable = fEditable;
                    pCFI->UnprepareForDebug();

                    break;

                default:
                    Assert("Invalid Editable property value");
                    break;
                }
   

                // cache the contentEditable attribute on the element.
            
                pElem->_fEditable = fEditable;
                
                // Set a flag to indicate that we should not set the default values for input\textarea from (_fEditAtBrowse)
                // in ComputeFormats, after the call to ApplyDefaultFormats, as contentEditable has been explicity set
                pCFI->_fEditableExplicitlySet = TRUE;
            }
            
        }
        break;

    case DISPID_INTERNAL_MEDIA_REFERENCE:
        {
            mediaType media = (mediaType) V_I4(&varValue);
            
            // PRINT is the only media currently handled
            if (mediaTypePrint == media)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetMediaReference(media);
                pCFI->UnprepareForDebug();
            }
            else
                AssertSz(0, "unexpected media type");
        }
        break;

    default:
        break;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member:      SwapSelectionColors
//
// Synopsis:    Decide if we need to swap the windows selection colors
//              based on the current text color.
//
// Returns:     TRUE: If swap, FALSE otherwise
//
//----------------------------------------------------------------------------
BOOL
CCharFormat::SwapSelectionColors() const
{
    BOOL fSwapColor;
    COLORREF crTextColor, crNewTextColor, crNewBkColor;

    if(_ccvTextColor.IsDefined())
    {
        crTextColor = _ccvTextColor.GetColorRef();

        crNewTextColor = GetSysColor (COLOR_HIGHLIGHTTEXT);
        crNewBkColor   = GetSysColor (COLOR_HIGHLIGHT);
        fSwapColor = ColorDiff (crTextColor, crNewTextColor) <
                     ColorDiff (crTextColor, crNewBkColor);
    }
    else
    {
        fSwapColor = FALSE;
    }

    return fSwapColor;
}

BOOL
CCharFormat::AreInnerFormatsDirty()
{
    return(   _fHasBgImage
           || _fHasBgColor
           || _fRelative
           || _fBidiEmbed
           || _fBidiOverride
           || _fPadBord
           || _fHasInlineMargins
           || _fHasInlineBg
          );
}

void
CCharFormat::ClearInnerFormats()
{
    _fHasBgImage = FALSE;
    _fHasBgColor = FALSE;
    _fRelative   = FALSE;
    _fBidiEmbed  = FALSE;
    _fBidiOverride = FALSE;
    _fPadBord    = FALSE;
    _fHasInlineMargins = FALSE;
    _fHasInlineBg = FALSE;
    _fHasDirtyInnerFormats = FALSE;
    Assert(!AreInnerFormatsDirty());
}

BOOL
CParaFormat::AreInnerFormatsDirty()
{
    CUnitValue cuvZeroPoints, cuvZeroPercent;
    LONG lZeroPoints, lZeroPercent;
    cuvZeroPoints.SetPoints(0);
    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    lZeroPoints = cuvZeroPoints.GetRawValue();
    lZeroPercent = cuvZeroPercent.GetRawValue();

    return( _fTabStops
        ||  _fCompactDL
        ||  _fResetDLLevel
        ||  _cuvLeftIndentPoints.GetRawValue() != lZeroPoints
        ||  _cuvLeftIndentPercent.GetRawValue() != lZeroPercent
        ||  _cuvRightIndentPoints.GetRawValue() != lZeroPoints
        ||  _cuvRightIndentPercent.GetRawValue() != lZeroPercent
        ||  _cuvNonBulletIndentPoints.GetRawValue() != lZeroPoints
        ||  _cTabCount != 0);
}

void
CParaFormat::ClearInnerFormats()
{
    CUnitValue cuvZeroPoints, cuvZeroPercent;
    LONG lZeroPoints, lZeroPercent;
    cuvZeroPoints.SetPoints(0);
    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    lZeroPoints = cuvZeroPoints.GetRawValue();
    lZeroPercent = cuvZeroPercent.GetRawValue();

    _fTabStops = FALSE;
    _fCompactDL = FALSE;
    _fResetDLLevel = FALSE;
    _cuvLeftIndentPoints.SetRawValue(lZeroPoints);
    _cuvLeftIndentPercent.SetRawValue(lZeroPercent);
    _cuvRightIndentPoints.SetRawValue(lZeroPoints);
    _cuvRightIndentPercent.SetRawValue(lZeroPercent);
    _cuvNonBulletIndentPoints.SetRawValue(lZeroPoints);
    _cTabCount = 0;
    _fHasDirtyInnerFormats = FALSE;
    Assert(!AreInnerFormatsDirty());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\_text.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _TEXT.H -- Declaration for a CTxtRun pointer |
 *
 *  CTxtRun pointers point at the plain text runs (CTxtArray) of the
 *  backing store and derive from CRunPtrBase via the CRunPtr template.
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#ifndef I__TEXT_H_
#define I__TEXT_H_
#pragma INCMSG("--- Beg '_text.h'")

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

MtExtern(CTxtPtr)

/*
 *  CTxtPtr
 *
 *  @class
 *      provides access to the array of characters in the backing store
 *      (i.e. <c CTxtArray>)
 *
 *  @base   public | CRunPtr<lt>CTxtArray<gt>
 *
 *  @devnote
 *      The state transitions for this object are the same as those for
 *      <c CRunPtrBase>.  <md CTxtPtr::_cp> simply caches the current
 *      cp (even though it can be derived from _iRun and _ich).  _cp is
 *      used frequently enough (and computing may be expensive) that
 *      caching the value is worthwhile.
 *
 *      CTxtPtr's *may* be put on the stack, but do so with extreme
 *      caution.  These objects do *not* float; if a change is made to
 *      the backing store while a CTxtPtr is active, it will be out
 *      of sync and may lead to a crash.  If such a situation may
 *      exist, use a <c CTxtRange> instead (as these float and keep
 *      their internal text && format run pointers up-to-date).
 *
 *      Otherwise, a CTxtPtr is a useful, very lightweight plain
 *      text scanner.
 */
class CTxtPtr : public CRunPtr<CTxtBlk>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CTxtPtr))

    inline CTxtPtr(CMarkup * pMarkup);
    CTxtPtr(CMarkup * pMarkup, DWORD cp);   //@cmember  Constructor
    CTxtPtr(const CTxtPtr &tp);         //@cmember  Copy Constructor
    CTxtPtr() { }

    void    Reinit(CMarkup * pMarkup, DWORD cp);
    long    GetRawText( long cch, TCHAR *pch ); //@cmember  Fetch <p cch> characters
    long    GetPlainText(  long cch, TCHAR *pch ); // Fetch pch chars cnvrt crlf
    long    GetPlainTextLength ( long cch );
    TCHAR   NextChar();             //@cmember Advance to & return next char
    TCHAR   PrevChar();             //@cmember Backup to & return previous char
    TCHAR   GetChar();              //@cmember Fetch char at current cp
    TCHAR   GetPrevChar();          //@cmember Fetch char at previous cp
    long    GetTextLength() const   //@cmember Get total cch for this document
    {
        return ((CTxtArray *)_prgRun)->_cchText;
    }
    const TCHAR* GetPch(long & cchValid);//@cmember Get ptr to block of chars

                            //@cmember  Get ptr to a reverse block of chars
    const TCHAR* GetPchReverse(long & cchValidReverse, long * cchvalid = NULL);

    // The text array has its own versions of these methods (overuling
    // those in runptr base so that <md CTxtPtr::_cp> can be correctly
    // maintained.

    DWORD   BindToCp(DWORD cp); //@cmember  Rebinds text pointer to cp
    DWORD   SetCp(DWORD cp);    //@cmember  Sets the cp for the run ptr
    DWORD   GetCp() const       //@cmember  Gets the current cp
    {
        // NB!  we do not do invariant checking here so the floating
        // range mechanism can work OK
        return _cp;
    };
    LONG    AdvanceCp(LONG cch);    //@cmember  Advance cp by cch chars

    // Advance/backup/adjust safe over CRLF and UTF-16 word pairs
    LONG    AdjustCpCRLF();     //@cmember  Backup to start of DWORD char
    BOOL    IsAtEOP();          //@cmember  Is current cp at an EOP marker?
    BOOL    IsAtBOWord();       //@cmember  At beginning of word?
    BOOL    IsAtEOWord();       //@cmember  At end of word?
    BOOL    IsAtWordBreak();    //@cmember  Is at a word break?


    // Search

    LONG FindComplexHelper (
        LONG cpMost, DWORD dwFlags, TCHAR const *, long cchToFind );

    LONG FindText (
        LONG cpMost, DWORD dwFlags, TCHAR const *, long cchToFind );

    // Word break & MoveUnit support
    long    MoveChar(BOOL fForward);
    long    MoveCluster(BOOL fForward);
    long    MoveClusterEnd(BOOL fForward);
    LONG    FindWordBreak(INT action, BOOL fAutoURL=FALSE);//@cmember  Find next word break
    LONG    FindBOSentence(BOOL fForward);   //@cmember  Find beginning of sentence
    long    FindBlockBreak(BOOL fForward);

    HRESULT AutoUrl_ScanForPrefix( int iDir, BOOL *pfFound, long *pcpStart, TCHAR *pchQuoted = NULL );
    HRESULT AutoUrl_EmailWildcard( BOOL *pfFound );
    HRESULT AutoUrl_FindAndVerifyBoundaries( BOOL *pfValid, long cpStart, long *pcpEnd );
    BOOL    IsInsideUrl( long *pcpStart, long *pcpEnd );
    BOOL    FindUrl( BOOL fForward, BOOL fBegin, long cpBoundary );
    BOOL    IsPasswordChar();

    // Bookmark support
    HRESULT MoveToBookmark( BSTR bstrBookmark, CTxtPtr *pTxtPtrEnd );
    HRESULT GetBookmark( BSTR *pbstrBookmark, CTxtPtr *pTxtPtrEnd );
    
                            //@cmember  Insert ch into the text stream cch times
    long    InsertRepeatingChar( LONG cch, TCHAR ch );

                                    //@cmember  Insert a range of text helper
                                    // for ReplaceRange
    long    InsertRange(DWORD cch, TCHAR const *pch);
    void    DeleteRange(DWORD cch); //@cmember  Delete range of text helper
                                    // for ReplaceRange
    DWORD       _cp;        //@cmember  character position in text stream

    CMarkup *   _pMarkup;       //@cmember  pointer to the overall text edit class;
                            //needed for things like the word break proc and
                            // used a lot by derived classes

    // We will protect any specific Thai related functions from the outside world
    // Keep the entry point to these through MoveCluster and FindWordBreak
private:
    LONG    FindThaiTypeWordBreak(INT action);
    BOOL    PrepThaiTextForBreak(BOOL fWordBreak,
                                 BOOL fForward,
                                 BOOL fCurrentIsNode,
                                 long cchText,
                                 CDataAry<TCHAR> *paryNodePos,
                                 TCHAR *paryItemize,
                                 long *pcchBefore,
                                 long *pcchAfter,
                                 long *pcchMove,
                                 long *plHoldNode=NULL);
    long    ItemizeAndBreakRun(TCHAR* aryItemize, long* pcchBefore, long* pcchAfter, SCRIPT_LOGATTR* arySLA);
};


// =======================   Misc. routines  ====================================================

void     TxCopyText(TCHAR const *pchSrc, TCHAR *pchDst, LONG cch);
LONG     TxFindEOP(const TCHAR *pchBuff, LONG cch);
INT      CALLBACK TxWordBreakProc(TCHAR const *pch, INT ich, INT cb, INT action);

inline
CTxtPtr::CTxtPtr ( CMarkup * pMarkup )
  : CRunPtr < CTxtBlk > ( (CRunArray *) & pMarkup->_TxtArray )
{
    _pMarkup = pMarkup;
    _cp = 0;
}

#pragma INCMSG("--- End '_text.h'")
#else
#pragma INCMSG("*** Dup '_text.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\array.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module ARRAY.C -- Generic Array Implementation |
 *
 *  Original Author: <nl>
 *      Christian Fortini
 *
 *  History: <nl>
 *      6/25/95  alexgo  Cleanup and Commented
 *
 *
 */


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif


#define celGrow 8

//
//  Invariant support
//
#define DEBUG_CLASSNAME CArrayBase
#include "_invar.h"


// =============================  Utility routines  =========================

/*
 *  PTRUNION
 *
 *  @struct PTRUNION | A union of the different types of pointers.  Useful for copying
 *  memory around
 */
typedef union tagPointerUnion
{
    BYTE *pb;   //@field A byte pointer
    WORD *pw;   //@field A word pointer
    DWORD *pd;  //@field A dword pointer
} PTRUNION;


// ===================================  CArrayBase  ================================================

#if DBG == 1
/*
 *  CArrayBase::Invariant
 *
 *  @mfunc  Tests the array state to make sure it is valid.  DEBUG only
 *
 *  @rdesc  TRUE if the tests succeed, FALSE otherwise
 */
BOOL CArrayBase::Invariant(void) const
{
    Assert(_cbElem > 0 );

    if( _prgel == NULL )
    {
        Assert(_cel == 0);
        Assert(_celMax == 0);

        // we go ahead and return a value here so that
        // this function can be executed in the "watch"
        // window of various debuggers
        if( _cel != 0 || _celMax != 0 )
            return FALSE;
    }
    else
    {
        Assert(_celMax > 0 );
        Assert(_cel <= _celMax);

        if( _celMax == 0 || _cel > _celMax )
            return FALSE;
    }

    return TRUE;
}
#endif

/*
 *  CArrayBase::ArAdd
 *
 *  @mfunc  Adds <p celAdd> elements to the end of the array.
 *
 *  @rdesc  A pointer to the start of the new elements added.  If non-NULL,
 *  <p pielIns> will be set to the index at which elements were added.
 */

void *
CArrayBase::ArAdd (
    DWORD celAdd,     // the number of elements to add
    DWORD * pielIns ) // where to store the index of the first element added
{
    char *  pel;
    DWORD   celNew;

    _TEST_INVARIANT_

    if (_cel + celAdd > _celMax)                 // need to grow
    {
        HRESULT hr;

        //
        // When we grow the array we grow it in units of celGrow.  However,
        // to make sure we don't grow small arrays too large, and get too much
        // unused space, we allocate only as much space as needed up to
        // celGrow.
        //

        if (_cel + celAdd <= celGrow)
            celNew = _cel + celAdd - _celMax;
        else
            celNew = max( DWORD( celGrow ), celAdd + celGrow - celAdd % celGrow );

        pel = _prgel;

        hr = MemRealloc(_mt, (void **) & pel, (_celMax + celNew) * _cbElem);

        MemSetName((pel, "CArrayBase data - %d elements", celNew));

        if(hr)
            return NULL;

        _prgel = pel;

        pel += _cel * _cbElem;

        _celMax += celNew;
    }
    else
    {
        pel = _prgel + _cel * _cbElem;
    }

    ZeroMemory( pel, celAdd * _cbElem );

    if (pielIns)
        *pielIns = _cel;

    _cel += celAdd;

    return pel;
}

/*
 *  CArrayBase::ArInsert
 *
 *  @mfunc Inserts <p celIns> new elements at index <p iel>
 *
 *  @rdesc A pointer to the newly inserted elements.  Will be NULL on
 *  failure.
 */
void* CArrayBase::ArInsert(
    DWORD iel,      //@parm the index at which to insert
    DWORD celIns    //@parm the number of elements to insert
)
{
    char *pel;
    DWORD celNew;
    HRESULT hr;

    _TEST_INVARIANT_

    AssertSz(iel <= _cel, "CArrayBase::Insert() - Insert out of range");

    if(iel >= _cel)
        return ArAdd(celIns, NULL);

    if(_cel + celIns > _celMax)             // need to grow
    {
        AssertSz(_prgel, "CArrayBase::Insert() - Growing a non existent array !");

        celNew = max (DWORD(celGrow), celIns + celGrow - celIns % celGrow);
        pel = _prgel;
        hr = MemRealloc(_mt, (void **) & pel, (_celMax + celNew)*_cbElem);
        if(hr)
        {
            AssertSz(FALSE, "CArrayBase::Insert() - Couldn't realloc line array");
            return NULL;
        }
        MemSetName((pel, "CArrayBase data - %d elements", celNew));

        _prgel = pel;
        _celMax += celNew;
    }
    pel = _prgel + iel * _cbElem;
    if(iel < _cel)              // Nove Elems up to make room for new ones
    {
        MoveMemory(pel + celIns*_cbElem, pel, (_cel - iel)*_cbElem);
        ZeroMemory(pel, celIns * _cbElem);
    }

    _cel += celIns;


    return pel;
}

/*
 *  CArrayBase::Remove
 *
 *  @mfunc  Removes the <p celFree> elements from the array starting at index
 *  <p ielFirst>.  If <p celFree> is negative, then all elements after
 *  <p ielFirst> are removed.
 *
 *  @rdesc nothing
 */
void CArrayBase::Remove(
    DWORD ielFirst,     //@parm the index at which elements should be removed
    LONG celFree,       //@parm the number of elements to remove.
    ArrayFlag flag      //@parm what to do with the left over memory (delete or leave
                        //alone.
)
{
    char *pel;

    _TEST_INVARIANT_

    if (celFree < 0)
        celFree = _cel - ielFirst;

    AssertSz(ielFirst + celFree <= _cel, "CArrayBase::Free() - Freeing out of range");

    if (_cel > ielFirst + celFree)
    {
        pel = _prgel + ielFirst * _cbElem;
        MoveMemory(pel, pel + celFree * _cbElem,
            (_cel - ielFirst - celFree) * _cbElem);
    }

    _cel -= celFree;

    if((flag == AF_DELETEMEM) && _cel < _celMax - celGrow)
    {
        HRESULT hr;

        // shrink array
        _celMax = _cel + celGrow - _cel % celGrow;
        pel = _prgel;
        hr = MemRealloc(_mt, (void **) & pel, _celMax * _cbElem);
        // we don't care if it fails since we're shrinking
        if (!hr)
            _prgel = pel;
    }
}

/*
 *  CArrayBase::Clear
 *
 *  @mfunc  Clears the entire array, potentially deleting all of the memory
 *  as well.
 *
 *  @rdesc  nothing
 */
void CArrayBase::Clear(
    ArrayFlag flag  //@parm Indicates what should be done with the memory
                    //in the array.  One of AF_DELETEMEM or AF_KEEPMEM
)
{
    _TEST_INVARIANT_

    if( flag == AF_DELETEMEM )
    {
        MemFree(_prgel);
        _prgel = NULL;
        _celMax = 0;
    }
    _cel = 0;
}

/*
 *  CArrayBase::Replace
 *
 *  @mfunc  Replaces the <p celRepl> elements at index <p ielRepl> with the
 *  contents of the array specified by <p par>.  If <p celRepl> is negative,
 *  then the entire contents of <p this> array starting at <p ielRepl> should
 *  be replaced.
 *
 *  @rdesc  Returns TRUE on success, FALSE otherwise.
 */
BOOL CArrayBase::Replace(
    DWORD ielRepl,      //@parm the index at which replacement should occur
    LONG celRepl,       //@parm the number of elements to replace (may be
                        //negative, indicating that all
    CArrayBase *par     //@parm the array to use as the replacement source
)
{
    _TEST_INVARIANT_

    DWORD celMove = 0;
    DWORD celIns = par->Count();

    if (celRepl < 0)
        celRepl = _cel - ielRepl;

    AssertSz(ielRepl + celRepl <= _cel, "CArrayBase::ArReplace() - Replacing out of range");

    celMove = min(celRepl, (LONG)celIns);

    if (celMove > 0)
    {
        MoveMemory(Elem(ielRepl), par->Elem(0), celMove * _cbElem);
        celIns -= celMove;
        celRepl -= celMove;
        ielRepl += celMove;
    }

    Assert(celRepl >= 0);
    Assert(celIns + celMove == par->Count());

    if(celIns > 0)
    {
        Assert(celRepl == 0);
        void *pelIns = ArInsert (ielRepl, celIns);
        if (!pelIns)
            return FALSE;
        MoveMemory(pelIns, par->Elem(celMove), celIns * _cbElem);
    }
    else if(celRepl > 0)
        Remove (ielRepl, celRepl, AF_DELETEMEM);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\clrngprs.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CLRNGPRS_HXX_
#define X_CLRNGPRS_HXX_
#include <clrngprs.hxx>
#endif


MtDefine(CCellRangeParser, ObjectModel, "CCellRangeParser")


CCellRangeParser::CCellRangeParser(LPCTSTR szRange)
{
    int nCurIndex;

    _fFailed = FALSE;
    _fOneValue = FALSE;

    if(szRange == NULL || *szRange == 0)
        goto Fail;
    
    // Remove all the spaces, convert to uppercase, replace .. with : and
    // store in _strNormString
    Normalize(szRange);

    nCurIndex = 0;

    if(!GetColumn(&nCurIndex, &(_RangeRect.left)))
        goto Fail;
    if(!GetNumber(&nCurIndex, &(_RangeRect.top)))
        goto Fail;
    
    if(_strNormString[nCurIndex] == 0)
    {
        _fOneValue = TRUE;
        _RangeRect.right = _RangeRect.left;
        _RangeRect.bottom = _RangeRect.top;
        goto Done;
    }

    if(((LPCTSTR)_strNormString)[nCurIndex++] != _T(':'))
        goto Fail;
    
    if(!GetColumn(&nCurIndex, &(_RangeRect.right)))
        goto Fail;
    if(!GetNumber(&nCurIndex, &(_RangeRect.bottom)))
        goto Fail;
Done:
    return;

Fail:
    _fFailed = TRUE;
    goto Done;
}


#define eStart       0
#define eSeenLetter1 1
#define eSeenNumber1 2
#define eSeenSepar   3
#define eSeenLetter2 4
#define eSeenNumber2 5
        
void 
CCellRangeParser::Normalize(LPCTSTR szRange)
{
    TCHAR       c, cAppnd;
    int         i;
    int         nLen = _tcslen(szRange);
    int         nState;
    int         nDigit;

    _strNormString.ReAlloc(nLen + 1); 
    _strNormString.SetLengthNoAlloc(0);
    nState = eStart;

    for(i = 0; i < nLen; i++)
    {
        c = szRange[i];
        if(_istspace(c))
            continue;
        else if((c == _T('.') && szRange[i+1] == _T('.')) || c == _T(':'))
        {
            if(nState == eSeenNumber1)
            {
                cAppnd = _T(':');
                if(c == _T('.')) i++;
                nState++;
            }
            else
                goto Fail;
        }
        else if(_istalpha(c))
        {
            if(nState == eSeenSepar || nState == eStart)
            {
                cAppnd = c;
                if(_istalpha(szRange[i+1]))
                {
                    _strNormString.Append(&cAppnd, 1);
                    i++;
                    cAppnd = szRange[i];
                }
                nState++;
            }
            else
                goto Fail;
        } else if(_istdigit(c))
        {
            if(nState == eSeenLetter1 || nState == eSeenLetter2)
            {
                // Remove heading 0's
                while(c == _T('0'))
                {
                    i++;
                    c = szRange[i];
                }
                if(!_istdigit(c))
                    goto Fail;
                cAppnd = c;
                // make sure that no more then 5 digits are processed
                nDigit = 0;
                while(_istdigit(szRange[i+1]))
                {
                    if(nDigit > 5)
                        goto Fail;
                    nDigit++;
                    _strNormString.Append(&cAppnd, 1);
                    i++;
                    cAppnd = szRange[i];
                }
                nState++;
            }
            else
                goto Fail;
        }
        _strNormString.Append(&cAppnd, 1);
    } /* for */


    if(nState != eSeenNumber1 && nState != eSeenNumber2)
        goto Fail;

    if(nState == eSeenNumber1)
        _fOneValue = TRUE;

    CharUpper(_strNormString);

    return;
Fail:
    _fFailed = TRUE;
    return;
}

BOOL 
CCellRangeParser::GetColumn(int *pnCurIndex, long *pnCol)
{
    int nVal;

    if(_fFailed)
        return FALSE;

    if(_strNormString.Length() == 0 || !_istalpha(_strNormString[*pnCurIndex]))
    {
        _fFailed = TRUE;
        return FALSE;
    }

  nVal = _strNormString[*pnCurIndex] - _T('A');
  
  (*pnCurIndex)++;

  if(_istalpha(_strNormString[*pnCurIndex]))
  {
      // A translates to 0 but AA to 1*26+0 so we need 26*(nVal+1)
      nVal = 26 * (nVal + 1) + (_strNormString[*pnCurIndex] - _T('A'));
      (*pnCurIndex)++;
  }

  *pnCol = nVal;

  return TRUE;
}

BOOL 
CCellRangeParser::GetNumber(int *pnCurIndex, long *pnRow)
{
    int nVal;

    if(_fFailed)
        return FALSE;

    if(_strNormString.Length() == 0 || !_istdigit(_strNormString[*pnCurIndex]))
    {
        _fFailed = TRUE;
        return FALSE;
    }

  nVal = _strNormString[*pnCurIndex] - _T('0');
  
  (*pnCurIndex)++;

  while(_istdigit(_strNormString[*pnCurIndex]))
  {
      nVal = 10 * nVal + (_strNormString[*pnCurIndex] - _T('0'));
      (*pnCurIndex)++;
  }

  // Adjust for the fact that first row is row 1 and return the value
  *pnRow = nVal - 1;
  
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\collbase.cxx ===
//=================================================================
//
//   File:      collbase.cxx
//
//  Contents:   CCollectionBase class
//
//  Classes:    CCollectionBase
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif



//+---------------------------------------------------------------
// CCollectionBase::InvokeEx, IDispatch
// Provides access to properties and members of the object
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
// We override this to support ordinal and named member access to the
// elements of the collection.
//----------------------------------------------------------------

STDMETHODIMP
CCollectionBase::InvokeEx(DISPID    dispidMember,
               LCID                 lcid,
               WORD                 wFlags,
               DISPPARAMS          *pdispparams,
               VARIANT             *pvarResult,
               EXCEPINFO           *pexcepinfo,
               IServiceProvider    *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // Is the dispid an ordinal index? (array access)
    if (IsCollectionDispID(dispidMember))
    {
        if (wFlags & DISPATCH_PROPERTYPUT) 
        {
            goto Cleanup;       // collection is RO return DISP_E_MEMBERNOTFOUND
        }
        else if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (pvarResult)
            {
                hr = GetItem(dispidMember - DISPID_COLLECTION_MIN, pvarResult);
            }
        }
    }
    else
    {
        // CBase knows how to handle expando
        hr = THR_NOTRACE(super::InvokeEx(dispidMember,
                         lcid,
                         wFlags,
                         pdispparams,
                         pvarResult,
                         pexcepinfo,
                         pSrvProvider));
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//  CCollectionBase::GetDispID, IDispatchEx
//
//  Overridden to output a particular dispid range collection accessing.
//----------------------------------------------------------------

STDMETHODIMP
CCollectionBase::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr;
    long        lIdx;

    if (!pid)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Could be an ordinal access
    hr = ttol_with_error(bstrName, &lIdx);
    if (hr)
    {
    // Not ordinal access; could be named 
        lIdx = FindByName(bstrName, !!(grfdex & fdexNameCaseSensitive));
    }

    *pid = DISPID_COLLECTION_MIN + lIdx;

    hr =  S_OK;

    if (lIdx == -1 || !IsLegalIndex(lIdx) || !IsCollectionDispID(*pid))
    {
        // Otherwise delegate to CBase impl for expando support etc.
        hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));
    }


Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//  CCollectionBase::GetNextDispID, IDispatchEx
//
//  Supports enumerating our collection indices in addition to the
//  collection's own properties.
//----------------------------------------------------------------

STDMETHODIMP
CCollectionBase::GetNextDispID(DWORD grfdex, DISPID id, DISPID *prgid)
{
    HRESULT     hr = S_OK;
    long        lIdx;

    if (!prgid)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Are we enumerating?
    if (!IsCollectionDispID(id))
    {
        // No, so delegate to CBase for normal properties
        hr = super::GetNextDispID(grfdex, id, prgid);
        if (hr)
        {
            // Start drilling into the collection.
            if (IsLegalIndex(0))
            {
                *prgid = DISPID_COLLECTION_MIN;
                hr = S_OK;
            }
        }
    }
    else
    {
        // Drill into the collection
        lIdx = id - DISPID_COLLECTION_MIN + 1;

        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if (!IsCollectionDispID(id+1) || !IsLegalIndex(lIdx))
        {
            *prgid = DISPID_UNKNOWN;
            hr = S_FALSE;
            goto Cleanup;
        }

        ++id;
        *prgid = id;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CCollectionBase::GetMemberName(DISPID id, BSTR *pbstrName)
{
    HRESULT hr;

    if (!pbstrName)
        return E_INVALIDARG;
    
    *pbstrName = NULL;

    // Are we enumerating?
    if (!IsCollectionDispID(id))
    {
        // No, so delegate to CBase for normal properties
        super::GetMemberName(id, pbstrName);
    }
    else
    {
        // Drill into the collection
        long lIdx;
        LPCTSTR szName;
        TCHAR ach[20];

        lIdx = id - DISPID_COLLECTION_MIN;

        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if (!IsCollectionDispID(id) || !IsLegalIndex(lIdx))
            goto Cleanup;

        szName = GetName(lIdx);
        if ( !szName )
        {
            // No name return index
            hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), lIdx);
            if (hr)
                return hr;
            szName = ach;
        }
        hr = THR(FormsAllocString(szName, pbstrName));
        if ( hr )
            return hr;
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

//+---------------------------------------------------------------
//  CCollectionBase::IsLegalIndex
//
//  Returns TRUE if given number is in the range of collection
//  indexes.
//----------------------------------------------------------------

BOOL 
CCollectionBase::IsLegalIndex(long lIdx)
{
    HRESULT    hr;
    
    // GetItem with NULL pointer means we want to cheeck the 
    // index only
    hr = THR(GetItem(lIdx, NULL));
    if(!hr)
        return TRUE;

    return FALSE;
}


//+---------------------------------------------------------------
//  CCollectionBase::GetIDsOfNames, IDispatch
//
// We need our IDispatch methods because if we don't provide them CBase
//  implementaion will be called (they are not virtual)
//----------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CCollectionBase::GetIDsOfNames(REFIID riid, LPTSTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid)
{
    if (!IsEqualIID(riid, IID_NULL)) 
        RRETURN(E_INVALIDARG);
    return GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid);
}


//+---------------------------------------------------------------
//  CCollectionBase::Invoke, IDispatch
//
// We need our IDispatch methods because if we don't provide them CBase
//  implementaion will be called (they are not virtual)
//----------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CCollectionBase::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
         DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
         UINT FAR* puArgErr)
{
    if (!IsEqualIID(riid, IID_NULL)) 
        RRETURN(E_INVALIDARG);
    return InvokeEx(dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL);
}

//+------------------------------------------------------------------------
//
//  Member:     CCollectionBase::item
//
//-------------------------------------------------------------------------

HRESULT
CCollectionBase::GetItemHelper(VARIANT * pvarIndex, VARIANT * pvarRet)
{
    HRESULT     hr = S_OK;
    CVariant    varArg;
    long        idx;

    if (!pvarRet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // ECMA rule - return empty for access beyond array bounds
    V_VT(pvarRet) = VT_EMPTY;

    switch (V_VT(pvarIndex))
    {
    case VT_BSTR:
    case VT_LPWSTR:

        idx = FindByName(V_BSTR(pvarIndex), /* fCaseSensitive = */TRUE);

        break;

    default:

        hr = THR(varArg.CoerceVariantArg(pvarIndex, VT_I4));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        idx = V_I4(&varArg);

        break;
    }

    if (idx < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItem(idx, pvarRet));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\collect.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       collect.cxx
//
//  Contents:   CCollectionCache, CElementCollectionBase and CElementCollection
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_TCELL_HXX_
#define X_TCELL_HXX_
#include "tcell.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_CLRNGPRS_HXX_
#define X_CLRNGPRS_HXX_
#include <clrngprs.hxx>
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include <frame.hxx>
#endif

#ifndef X_WINDOW_HXX_
#define X_WIDNOW_HXX_
#include <window.hxx>
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#define _cxx_
#include "collect.hdl"

MtDefine(CElementCollection, Tree, "CElementCollection")
MtDefine(CCollectionCache, Tree, "CCollectionCache")

MtDefine(CElementAryCacheItem, CCollectionCache, "CElementAryCacheItem")
MtDefine(CElementAryCacheItem_aryElements_pv, CElementAryCacheItem, "CElementAryCacheItem::_aryElements._pv")

MtDefine(CCollectionCacheItem, XCollectionCacheItem, "CCollectionCacheItem")
MtDefine(CCollectionCache_aryItems_pv, CCollectionCache, "CCollectionCache::_aryItems::_pv")
MtDefine(CCollectionCache_aryItems_pary, CCollectionCache, "CCollectionCache::_aryItems[i].pary")
MtDefine(CCollectionCache_aryItems_pary_pv, CCollectionCache, "CCollectionCache::_aryItems[i].pary->_pv")
MtDefine(CCollectionCacheGetNewEnum_pary, Tree, "CCollectionCache::GetNewEnum pary")
MtDefine(CCollectionCacheGetNewEnum_pary_pv, Tree, "CCollectionCache::GetNewEnum pary->_pv")

//====================================================================
//
//  Class CElementCollectionBase, CElementCollection methods
//
//===================================================================

//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CElementCollectionBase::s_classdesc =
{
    0,                              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CElementCollection::s_classdesc =
{
    0,                              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLElementCollection,    // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CElementCollection::CElementCollection(CCollectionCache *pCollectionCache, long lIndex)
    : super(pCollectionCache, lIndex)
{
    if (lIndex == CMarkup::ELEMENT_COLLECTION && pCollectionCache->GetReservedSize() == CMarkup::NUM_DOCUMENT_COLLECTIONS)
    {
        IDispatch *pDispDocument;
        CMarkup *pMarkup = DYNCAST(CMarkup, pCollectionCache->GetBase());
        Assert(pMarkup->Document());
        IGNORE_HR(pMarkup->Document()->QueryInterface(IID_IDispatch, (void **)&pDispDocument));
        Assert(pDispDocument);
        DYNCAST(CAllCollectionCacheItem, pCollectionCache->GetCacheItem(lIndex))->SetDispDocument(pDispDocument);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CElementCollectionBase::CElementCollectionBase(
        CCollectionCache *pCollectionCache,
        long lIndex)
    : super(), _pCollectionCache(pCollectionCache), _lIndex(lIndex)
{
    // Tell the base to live longer than us
    _pCollectionCache->GetBase()->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     ~CElementCollectionBase
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CElementCollectionBase::~CElementCollectionBase()
{
    // release subobject count
    _pCollectionCache->GetBase()->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     ~CElementCollection
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CElementCollection::~CElementCollection()
{
    _pCollectionCache->ClearDisp(_lIndex);
    if (_lIndex == CMarkup::ELEMENT_COLLECTION && _pCollectionCache->GetReservedSize() == CMarkup::NUM_DOCUMENT_COLLECTIONS)
    {
        CAllCollectionCacheItem *pCItem = DYNCAST(CAllCollectionCacheItem, _pCollectionCache->GetCacheItem(_lIndex));
        Assert(pCItem);
        ClearInterface(&(pCItem->_pDispDocument));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   vanilla implementation
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IHTMLElementCollection *)this, IUnknown)
        QI_INHERITS((IHTMLElementCollection *)this, IDispatch)
        QI_INHERITS(this, IDispatchEx)
        QI_TEAROFF(this, IHTMLElementCollection2, NULL)
        QI_TEAROFF(this, IHTMLElementCollection3, NULL)

        default:
            if (iid == CLSID_CElementCollection)
            {
                *ppv = this;
                return S_OK;
            }

            if (iid == IID_IHTMLElementCollection)
                *ppv = (IHTMLElementCollection *)this;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetTypeInfoCount, IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetTypeInfoCount (UINT FAR* pctinfo)
{
    return super::GetTypeInfoCount(pctinfo);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetTypeInfo, IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetTypeInfo(
                UINT itinfo,
                LCID lcid,
                ITypeInfo ** pptinfo)
{
    return super::GetTypeInfo(itinfo, lcid, pptinfo);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollection::GetIDsOfNames, IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetIDsOfNames(
                REFIID                riid,
                LPOLESTR *            rgszNames,
                UINT                  cNames,
                LCID                  lcid,
                DISPID FAR*           rgdispid)
{
    RRETURN(THR_NOTRACE(GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid)));
}


HRESULT
CElementCollectionBase::Invoke(
    DISPID          dispidMember,
    REFIID,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *)
{
    return InvokeEx(dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}
//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::Invoke, IDispatch
//
//  Synopsis:   Return the value of the property.
//
//  Note:       If the dispidMember passed to Invoke is DISPID_UNKNOWN we'll
//              return VT_EMPTY.  This allow VBScript/JavaScript to test
//              isnull( ) or comparision to null.
//----------------------------------------------------------------------------
HRESULT
CElementCollectionBase::InvokeEx(
                DISPID          dispidMember,
                LCID            lcid,
                WORD            wFlags,
                DISPPARAMS *    pdispparams,
                VARIANT *       pvarResult,
                EXCEPINFO *     pexcepinfo,
                IServiceProvider *pSrvProvider)
{
    HRESULT             hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchInvokeCollection(this,
                                  &super::InvokeEx,
                                  _pCollectionCache,
                                  _lIndex,
                                  dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL,
                                  pSrvProvider);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetDispID, IDispatchEx
//
//  Synopsis:   defer to cache
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchGetDispIDCollection(this,
                                     &super::GetDispID,
                                     _pCollectionCache,
                                     _lIndex,
                                     bstrName,
                                     grfdex,
                                     pid);

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElementCollection::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT CElementCollectionBase::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT CElementCollectionBase::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}



//+-------------------------------------------------------------------------
//
//  Method:     CElementCollection::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CElementCollectionBase::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetNextDispID, IDispatchEx
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElementCollectionBase::GetNextDispID(
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchGetNextDispIDCollection(this,
                                         &super::GetNextDispID,
                                         _pCollectionCache,
                                         _lIndex,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CElementCollectionBase::GetMemberName(
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
                                         &super::GetMemberName,
                                         _pCollectionCache,
                                         _lIndex,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

HRESULT
CElementCollectionBase::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo
//
//  Synopsis:   defer to the collection cache
//
//-------------------------------------------------------------------------

HRESULT
CElementCollectionBase::CloseErrorInfo(HRESULT hr)
{
    return _pCollectionCache->CloseErrorInfo(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::get_length(long * plSize)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetLength(_lIndex, plSize)));
}

//+------------------------------------------------------------------------
//
//  Member:     put_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::put_length(long lSize)
{
    RRETURN(SetErrorInfo(E_NOTIMPL));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Item(_lIndex, var1, var2, ppResult)));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;
    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(_lIndex, var1, var2, ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::tags(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Tags(_lIndex, var1, ppdisp)));
}

HRESULT
CElementCollection::Tags(LPCTSTR szTagName, IDispatch ** ppdisp)
{
    RRETURN(_pCollectionCache->Tags(_lIndex, szTagName, ppdisp));
}

//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::urns(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Urns(_lIndex, var1, ppdisp)));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::get__newEnum(IUnknown ** ppEnum)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetNewEnum(_lIndex, ppEnum)));
}


//+------------------------------------------------------------------------
//
//  Member:     toString
//
//  Synopsis:   This is impplemented on all objects
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};



//====================================================================
//
//  Class CCollectionCache Methods:
//
//====================================================================

//+------------------------------------------------------------------------
//
//  Member:     ~CCollectionCache
//
//  Synopsis:   Constructor
//
//-------------------------------------------------------------------------

CCollectionCache::CCollectionCache(
        CBase * pBase,
        CMarkup * pMarkup,
        PFN_CVOID_ENSURE pfnEnsure /* = NULL */,
        PFN_CVOID_CREATECOL pfnCreation /* = NULL */,
        PFN_CVOID_REMOVEOBJECT pfnRemove /* = NULL */,    
        PFN_CVOID_ADDNEWOBJECT pfnAddNewObject /* = NULL */ )
        :   _pBase(pBase), 
            _pfnEnsure(pfnEnsure),     
            _pfnRemoveObject(pfnRemove), 
            _lReservedSize(0),
            _pfnAddNewObject(pfnAddNewObject),
            _pMarkup(pMarkup),   
            _pfnCreateCollection(pfnCreation),
            _aryItems(Mt(CCollectionCache_aryItems_pv))
{
    Assert(pBase);  // Required.
}

//+------------------------------------------------------------------------
//
//  Member:     ~CCollectionCache
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------

CCollectionCache::~CCollectionCache()
{
    CacheItem * pce = _aryItems;
    UINT cSize = _aryItems.Size();

    for (; cSize--; ++pce)
    {
        delete pce->_pCacheItem;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   Setup the cache.  This call is required if part of the
//              cache is to be reserved.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::InitReservedCacheItems(long lReservedSize, long lFromIndex /*= 0*/,
                       long lIdentityIndex  /*= -1*/)
{
    HRESULT hr = E_INVALIDARG;
    CacheItem * pce = NULL;
    long l = 0;
    long i;

    Assert ( lReservedSize > 0 );
    Assert ( lFromIndex <= lReservedSize && lFromIndex >= 0 );
    Assert ( lIdentityIndex == -1 || (lIdentityIndex >= 0 && lIdentityIndex < _lReservedSize ));

    // Clear the reserved part of the cache.

    hr = THR(_aryItems.EnsureSize(lReservedSize));
    if (hr)
        goto Cleanup;

    pce = _aryItems;

    memset(_aryItems, 0, lReservedSize * sizeof(CacheItem));
    _aryItems.SetSize(lReservedSize);

    // Reserved items always use the CCollectionCacheItem
    for ( l = lFromIndex, pce = _aryItems+lFromIndex  ; l < lReservedSize ; l++, ++pce)
    {
        pce->Init();
        pce->_pCacheItem = new CElementAryCacheItem ();
        if (pce->_pCacheItem == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        MemSetName((pce->_pCacheItem, "CacheItem"));
    }
    
    if (lIdentityIndex != -1 ) 
        _aryItems[lIdentityIndex].fIdentity = TRUE;

Cleanup:
    if (hr)
    {
        for (i=l-1, --pce ;i >= lFromIndex; i--, --pce)
        {
            delete pce->_pCacheItem;
        }
        _aryItems.SetSize(0);
    }
    else
    {
        _lReservedSize = lReservedSize;
    }
    RRETURN(hr);
}

HRESULT
CCollectionCache::InitCacheItem(long lCacheIndex, CCollectionCacheItem *pCacheItem)
{
    Assert ( pCacheItem );
    Assert ( lCacheIndex >= 0 && lCacheIndex < _aryItems.Size() );
    Assert ( !_aryItems [ lCacheIndex ]._pCacheItem ); // better not be initialized all ready

    _aryItems [ lCacheIndex ].Init();
    _aryItems [ lCacheIndex ]._pCacheItem = pCacheItem;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     UnloadContents
//
//  Synopsis : called when the contents of the cache need to be freed up
//      but the cache itself needs to stick around
//
//+------------------------------------------------------------------------
HRESULT
CCollectionCache::UnloadContents()
{
    long l;

    for (l = _aryItems.Size()-1; l>=0; l--)
    {
        _aryItems[l]._lCollectionVersion = 0;

        if (_aryItems[l]._pCacheItem)
            _aryItems[l]._pCacheItem->DeleteContents();
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CreateCollectionHelper
//
//  Synopsis:   Wrapper for private member, if no CreateCollection function is
//      provided, default to creating a CElementCollectionBase. If a create function
//      IS provided, then the base object has a derived collection that it wants
//
//      This returns IDispatch because that is the form that the callers need
//---------------------------------------------------------------------------
HRESULT
CCollectionCache::CreateCollectionHelper(IDispatch ** ppIEC, long lIndex)
{
    HRESULT hr = S_OK;

    *ppIEC = NULL;

    if (_pfnCreateCollection)
    {
        hr = THR( CALL_METHOD( (CVoid *)(void *)_pBase, _pfnCreateCollection, (ppIEC, lIndex)));
    }
    else
    {
        CElementCollection *    pobj;

        pobj = new CElementCollection(this, lIndex);
        if (!pobj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pobj->QueryInterface(IID_IDispatch, (void **) ppIEC));
        pobj->Release();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     GetIntoAry
//
//  Synopsis:   Return the element at the specified index.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIntoAry(
        long lIndex,
        long lIndexElement,
        CElement ** ppElem)
{
    if (lIndexElement >= _aryItems[lIndex]._pCacheItem->Length())
        RRETURN(DISP_E_MEMBERNOTFOUND);

    if (lIndexElement < 0)
        RRETURN(E_INVALIDARG);

    *ppElem = _aryItems[lIndex]._pCacheItem->GetAt (lIndexElement);

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     GetIntoAry
//
//  Synopsis:   Return the index of the specified element.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIntoAry(
        long lIndex,
        CElement * pElement,
        long * plIndexElement)
{
    CCollectionCacheItem    *pCacheItem = _aryItems[lIndex]._pCacheItem;
    CElement                *pElem;
    long                    lElemIndex = 0;
 
    Assert ( plIndexElement );

    *plIndexElement = -1;

    // Using GetNext() should be more efficient than using GetAt();
    pCacheItem->MoveTo( 0 );
    do
    {
        pElem = pCacheItem->GetNext();
        if ( pElem && pElem == pElement )
        {
            *plIndexElement = lElemIndex;
            break;
        }
        lElemIndex++;
    } while ( pElem );


    RRETURN(*plIndexElement == -1 ? DISP_E_MEMBERNOTFOUND : S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     GetIntoAry
//
//  Synopsis:   Return the element with a given name
//
//  Returns:    S_OK, if it found the element.  *ppNode is set
//              S_FALSE, if multiple elements w/ name were found.
//                  *ppNode is set to the first element in list.
//              Other errors.
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIntoAry(
        long lCollectionIndex,
        LPCTSTR Name,
        BOOL fTagName,
        CElement ** ppElem,
        long iStartFrom /* = 0*/,
        BOOL fCaseSensitive /* = FALSE */)
{
    HRESULT                 hr = S_OK;
    CElement *              pElemFirstMatched = NULL;
    CElement *              pElemLastMatched = NULL;
    CElement *              pElem;
    CCollectionCacheItem *  pCacheItem = _aryItems[lCollectionIndex]._pCacheItem;
    BOOL                    fLastOne = FALSE;

    Assert(ppElem);
    *ppElem = NULL;

    if (iStartFrom == -1)
    {
        iStartFrom = 0;
        fLastOne = TRUE;
    }

    for(pCacheItem->MoveTo( iStartFrom );;)
    {
        pElem = pCacheItem->GetNext();
        if ( !pElem )
            break;

        if ( CompareName( pElem, Name, fTagName, fCaseSensitive) )
        {
            if ( !pElemFirstMatched )
                pElemFirstMatched = pElem;
            pElemLastMatched = pElem;
        }
        
        if (pElem->Tag() == ETAG_OBJECT || pElem->Tag() == ETAG_APPLET)
        {
            CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
            int l = pObj->_aryParams.Size();
            for (int i = 0;i < l; i++)
            {
                if (CompareName(pObj->_aryParams[i], Name, fTagName, fCaseSensitive))
                {
                    if (!pElemFirstMatched)
                        pElemFirstMatched = pObj->_aryParams[i];
                    pElemLastMatched = pObj->_aryParams[i];
                }
            }
        }
    }

    if ( !pElemLastMatched )
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (pCacheItem->IsRangeSyntaxSupported())
        {
            CCellRangeParser    cellRangeParser(Name);
            if(!cellRangeParser.Failed())
            {
                hr = S_FALSE;   // for allowing expando and properties/methods on the collection (TABLE_CELL_COLLECTION)
            }
        }

        goto Cleanup;
    }

    // A collection can be marked to always return the last matching name,
    // rather than the default first matching name.
    if ( DoGetLastMatchedName ( lCollectionIndex ) )
    {
        *ppElem = pElemLastMatched;
    }
    else
    {
        // The iStartFrom has higher precedence on which element we really
        // return first or last in the collection.
        *ppElem = fLastOne ? pElemLastMatched : pElemFirstMatched;
    }

    // return S_FALSE if we have more than one element that matced
    hr = (pElemFirstMatched == pElemLastMatched ) ? S_OK : S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

// Invalid smart collections - one using the _fIsValid technique
void 
CCollectionCache::InvalidateAllSmartCollections(void)
{
    long l;
    for ( l = _aryItems.Size()-1 ; l >= 0 ; l-- )
    {
		_aryItems[l]._fIsValid = FALSE;
    }
}


// Invalidate "dump" collections - ones using old-style version management
void 
CCollectionCache::Invalidate(void)
{
    long l;
    for ( l = _aryItems.Size()-1 ; l >= 0 ; l-- )
    {
        _aryItems[l]._lCollectionVersion  = 0;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureAry
//
//  Synopsis:   Make sure this index is ready for access.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::EnsureAry(long lIndex)
{
    HRESULT hr = S_OK;

    if (_pfnEnsure && lIndex < _lReservedSize)
    {
        // Ensure the reserved part of the collection
        hr = THR( CALL_METHOD( (CVoid *)(void *)_pBase, 
            _pfnEnsure, 
            (lIndex,&_aryItems[lIndex]._lCollectionVersion)));
        if (hr)
            goto Cleanup;
    }


    // Ensuring a dynamic collection, need to make sure all its dependent collections
    // are ensured
    if (lIndex >= _lReservedSize)
    {
        // Ensure the collection we're based upon
        // note that this is a recursove call
        hr = THR(EnsureAry(_aryItems[lIndex].sIndex));
        if (hr)
            goto Cleanup;

        // If we're a different version than the collection we're based upon, rebuild ourselves now
        if ( _aryItems[lIndex]._lCollectionVersion != 
            _aryItems[_aryItems[lIndex].sIndex]._lCollectionVersion )
        {
            switch (  _aryItems[lIndex].Type )
            {
            case CacheType_Tag:
                // Rebuild based on name
                hr = THR(BuildNamedArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    TRUE,
                    _aryItems[lIndex]._pCacheItem,
                    0,
                    _aryItems[lIndex].fIsCaseSensitive));
                break;

            case CacheType_Named:
                // Rebuild based on tag name
                hr = THR(BuildNamedArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    FALSE,
                    _aryItems[lIndex]._pCacheItem,
                    0,
                    _aryItems[lIndex].fIsCaseSensitive));
                break;

            case CacheType_Children:
            case CacheType_DOMChildNodes:
                // Rebuild all children
                hr = THR(BuildChildArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].pElementBase,
                    _aryItems[lIndex]._pCacheItem,
                    FALSE));
                break;

            case CacheType_AllChildren:
                // Rebuild all children
                hr = THR(BuildChildArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].pElementBase,
                    _aryItems[lIndex]._pCacheItem,
                    TRUE));
                break;

            case CacheType_CellRange:
                // Rebuild cells acollection
                hr = THR(BuildCellRangeArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    &(_aryItems[lIndex].rectCellRange),
                    _aryItems[lIndex]._pCacheItem));
                break;

            case CacheType_FreeEntry:
                // Free collection waiting to be reused
                break;

            case CacheType_Urn:
                hr = THR(BuildNamedArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    TRUE,
                    _aryItems[lIndex]._pCacheItem,
                    0,
                    _aryItems[lIndex].fIsCaseSensitive,
                    TRUE));
                break;

            default:
                Assert(0);
                break;
            }
        }
        _aryItems[lIndex]._lCollectionVersion = 
            _aryItems[_aryItems[lIndex].sIndex]._lCollectionVersion;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     ClearDisp
//
//  Synopsis:   Clear the reference to this dispatch ptr out of the cache.
//
//              At this point,  any reference that the disp (collection)
//                may have (due to being a named collection) on other collections
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::ClearDisp(long lIndex)
{
    Assert ( lIndex >= 0 && lIndex <_aryItems.Size() );

    // Find the collection in the cache & clear it down
    _aryItems[lIndex].pdisp = NULL;
    // Mark it as free
    _aryItems[lIndex].Type = CacheType_FreeEntry;

    if ( lIndex >= _lReservedSize )
    {
        if (_aryItems[lIndex]._pCacheItem)
        {
            short sDepend;

            delete _aryItems[lIndex]._pCacheItem;
            _aryItems[lIndex]._pCacheItem = NULL;

            sDepend = _aryItems[lIndex].sIndex;
            if (sDepend >= _lReservedSize)
            {
                _aryItems[sDepend].pdisp->Release();
            }
        }
        _aryItems[lIndex].cstrName.Free();
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////}


//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr from the RESERVED part of the cache.
//              If fIdentity is not set, then everything works as planned.
//              If set, then we QI the base Object and return that
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(long lIndex, IDispatch ** ppdisp)
{
    CacheItem * pce;

    Assert((lIndex >= 0) && (lIndex < _aryItems.Size()));

    HRESULT hr = S_OK;

    *ppdisp = NULL;

    pce = &_aryItems[lIndex];

    // if not identity and there is a colllection, addref and return it
    if (!pce->fIdentity)
    {
        if (pce->pdisp)
            pce->pdisp->AddRef();
        else
        {
            IDispatch * pdisp;

            hr = THR(CreateCollectionHelper(&pdisp, lIndex));
            if (hr)
                goto Cleanup;

            //We're not dependant on any other collection
            pce = &_aryItems[lIndex];
            pce->pdisp = pdisp;
            pce->sIndex = -1;
        }

        *ppdisp = pce->pdisp;
    }
    else
        hr = THR_NOTRACE(DYNCAST(CElement, _pBase)->QueryInterface(
                    IID_IDispatch,
                    (void**) ppdisp));

Cleanup:
    RRETURN(hr);
}

// Find pElement in the lIndex base Collection
HRESULT 
CCollectionCache::CreateChildrenCollection(long lCollectionIndex, 
    CElement *pElement, 
    IDispatch **ppDisp,
    BOOL fAllChildren,
    BOOL fDOMCollection)
{
    CacheItem *             pce;
    long                    lSize = _aryItems.Size(),l;
    HRESULT                 hr = S_OK;
    CollCacheType Type = fAllChildren ? 
            CacheType_AllChildren :
            (fDOMCollection) ? CacheType_DOMChildNodes
                             : CacheType_Children;

    Assert (ppDisp);
    *ppDisp = NULL;

    hr = THR(EnsureAry(lCollectionIndex));
    if (hr)
        goto Cleanup;

    // Try and locate an exiting collection
    pce = &_aryItems[_lReservedSize];

    // Return this named collection if it already exists.
    for (l = _lReservedSize; l < lSize; ++l, ++pce)
    {
        if ( pce->Type == Type && 
             pElement == pce->pElementBase )
        {
            pce->pdisp->AddRef();
            *ppDisp = pce->pdisp;
            goto Cleanup;
        }
    }

    // Didn't find it, create a new collection

    hr = THR(GetFreeIndex(&l));  // always returns Idx from non-reserved part of cache
    if (hr)
        goto Cleanup;

    hr = THR(CreateCollectionHelper(ppDisp, l));
    if (hr)
        goto Cleanup;

    pce = &_aryItems[l];
    pce->Init();

    Assert (!pce->_pCacheItem);
    pce->_pCacheItem = new CElementAryCacheItem();
    if ( !pce->_pCacheItem )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(BuildChildArray (lCollectionIndex, pElement, pce->_pCacheItem, fAllChildren ));
    if ( hr )
        goto Cleanup;

    pce->pElementBase = pElement;
    pce->pdisp = *ppDisp;

    pce->sIndex = lCollectionIndex;       // Remember the index we depend on.
    pce->Type = Type;
    
Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr from the NON-RESERVED part of the cache.
//              N.B. non-reserved can never be identity collecitons,
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(
        long lIndex,
        LPCTSTR Name,
        CollCacheType  CacheType,
        IDispatch ** ppdisp,
        BOOL fCaseSensitive /*= FALSE */,
        RECT *pRect /* = NULL */,
        BOOL fAlwaysCollection /* = FALSE */)
{
    CPtrAry<CElement *> *   paryNamed = NULL;
    long                    lSize = _aryItems.Size();
    long                    l;
    HRESULT                 hr = S_OK;
    CacheItem             * pce;
    CRect                   rectCellRange(CRect::CRECT_EMPTY);

    // named arrays are always built into an AryCacheItem
    CElementAryCacheItem           aryItem;

    Assert(CacheType == CacheType_Tag || 
           CacheType == CacheType_Named || 
           CacheType == CacheType_CellRange ||
           CacheType == CacheType_Urn);

    typedef int ( *COMPAREFN)( LPCTSTR, LPCTSTR );
    COMPAREFN CompareFn = fCaseSensitive ? FormsStringCmp : FormsStringICmp;

    *ppdisp = NULL;

    pce = &_aryItems[_lReservedSize];

    // Return this named collection if it already exists.
    for (l = _lReservedSize; l < lSize; ++l, ++pce)
    {
        if(pce->Type == CacheType && lIndex == pce->sIndex && 
             pce->fIsCaseSensitive == (unsigned)fCaseSensitive &&
                            !CompareFn(Name, (BSTR) pce->cstrName))
        {
            pce->pdisp->AddRef();
            *ppdisp = pce->pdisp;
            goto Cleanup;
        }
    }

    // Build the list
    if(CacheType != CacheType_CellRange)
        hr = THR(BuildNamedArray(lIndex, Name, CacheType == CacheType_Tag, 
            &aryItem, 0, fCaseSensitive, CacheType == CacheType_Urn ));
    else
    {           
        if(!pRect)
            // Mark the rect as empty
            rectCellRange.right = -1;
        else
            // Use the passed in rect
            rectCellRange = *pRect;
        hr = THR(BuildCellRangeArray(lIndex, Name, &rectCellRange, &aryItem));
    }

    if (hr)
        goto Cleanup;

    // Return based on what the list of named elements looks like.
    if (!aryItem.Length() && !((CacheType == CacheType_Tag) || (CacheType == CacheType_Urn) || fAlwaysCollection))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Error;
    }
    // The tags method ALWAYS should return a collection (else case)
    else if (aryItem.Length() == 1 && !((CacheType == CacheType_Tag) || (CacheType == CacheType_Urn) || fAlwaysCollection))
    {
        CElement *pElem = aryItem.GetAt ( 0 );
        hr = THR(pElem->QueryInterface(IID_IDispatch, (void **) ppdisp));
        // Keep the ppdisp around we'll return that and just release the array.
        goto Cleanup2;
    }
    else
    {
        CElementAryCacheItem *pAryItem;

        hr = THR(GetFreeIndex(&l));  // always returns Idx from non-reserved part of cache
        if (hr)
            goto Error;

        hr = THR(CreateCollectionHelper(ppdisp, l ));
        if (hr)
            goto Error;

        pce = &_aryItems[l];
        pce->Init();

        hr = THR(pce->cstrName.Set(Name));
        if (hr)
            goto Error;

        Assert (!pce->_pCacheItem);
        pce->_pCacheItem = new CElementAryCacheItem();
        if ( !pce->_pCacheItem )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // Copy the array. 
        // For perf reasons assume that the destination collection is a 
        // ary cache - which it is for now, by design
        //
        pAryItem = DYNCAST(CElementAryCacheItem, pce->_pCacheItem);
        pAryItem->CopyAry ( &aryItem ); // this just copies the ptrarray _pv across

        pce->pdisp = *ppdisp;
        pce->sIndex = lIndex;       // Remember the index we depend on.
        pce->Type = CacheType;
        pce->fIsCaseSensitive = fCaseSensitive;

        // Save the range for the cell range type cache so we do not need to parse
        //  the name later
        if(CacheType == CacheType_CellRange)
            pce->rectCellRange = rectCellRange;

        // The collection this named collection was built from is now
        // used to rebuild (ensure) this collection. so we need to
        // put a reference on it so that it will not go away and its
        // location re-assigned by another call to GetFreeIndex.
        // The matching Release() will be done in the dtor
        // although it is not necessary to addref the reserved collections
        //  it is done anyhow, simply for consistency.  This addref
        // only needs to be done for non-reserved collections

        if (lIndex >= _lReservedSize)
        {
            _aryItems[lIndex].pdisp->AddRef();
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    ClearInterface(ppdisp);

Cleanup2:
    delete paryNamed;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr on an element from the cache.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(long lIndex, long lIndexElement, IDispatch ** ppdisp)
{
    CElement *pElem;

    Assert((lIndex >= 0) && (lIndex < _aryItems.Size()));

    *ppdisp = NULL;

    if (lIndexElement >= _aryItems[lIndex]._pCacheItem->Length())
        RRETURN(DISP_E_MEMBERNOTFOUND);

    if (lIndexElement<0)
        RRETURN(E_INVALIDARG);

    pElem = _aryItems [ lIndex ]._pCacheItem->GetAt( lIndexElement );
    Assert(pElem );

    RRETURN(THR(pElem->QueryInterface(IID_IDispatch, (void **)ppdisp)));
}


//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr on an element from the cache.
//      Return the nth element that mathces the name
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(
        long lIndex,
        LPCTSTR Name,
        long lNthElement,
        IDispatch ** ppdisp,
        BOOL fCaseSensitive )
{
    long                    lSize,l;
    HRESULT                 hr = DISP_E_MEMBERNOTFOUND;
    CCollectionCacheItem *  pItem;
    CElement *              pElem;

    Assert((lIndex >= 0) && (lIndex < _aryItems.Size()));
    Assert(ppdisp);

    pItem = _aryItems[lIndex]._pCacheItem;

    *ppdisp = NULL;

    // if lIndexElement is too large, just pretend we
    //  didn't find it rather then erroring out
    if (lNthElement < 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lSize = pItem->Length();

    if (lNthElement >= lSize)
        goto Cleanup;

    for (l = 0; l < lSize; ++l)
    {
        pElem = pItem->GetAt(l);
        Assert(pElem);
        if (CompareName(pElem, Name, FALSE, fCaseSensitive) && !lNthElement--)
            RRETURN(THR(pElem->QueryInterface(IID_IDispatch, (void **) ppdisp)));
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetFreeIndex
//
//  Synopsis:   Get a free slot from the NON-RESERVED part of the cache.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetFreeIndex(long * plIndex)
{
    CacheItem * pce;
    long    lSize = _aryItems.Size();
    long    l;
    HRESULT hr = S_OK;

    pce = &_aryItems[_lReservedSize];

    // Look for a free slot in the non-reserved part of the cache.
    for (l = _lReservedSize; l < lSize; ++l, ++pce)
    {
        if (pce->Type == CacheType_FreeEntry)
        {
            Assert (!pce->pdisp);
            *plIndex = l;
            goto Cleanup;
        }
    }

    // If we failed to find a free slot then grow the cache by one.
    hr = THR(_aryItems.EnsureSize(l + 1));
    if (hr)
        goto Cleanup;
    _aryItems.SetSize(l + 1);

    pce = &_aryItems[l];

    memset(pce, 0, sizeof(CacheItem));
    pce->fOKToDelete = TRUE;

    *plIndex = lSize;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CompareName
//
//  Synopsis:   Compares a bstr with an element, either by name rules or
//              as a tagname.
//
//-------------------------------------------------------------------------


BOOL
CCollectionCache::CompareName(CElement * pElement, LPCTSTR Name, 
                              BOOL fTagName, 
                              BOOL fCaseSensitive /* = FALSE */ )
{
    BOOL    fCompare;
    typedef int ( *COMPAREFN)( LPCTSTR, LPCTSTR );
    COMPAREFN CompareFn = fCaseSensitive ? FormsStringCmp : FormsStringICmp;

    if (fTagName)
    {
        fCompare = !CompareFn(Name, pElement->TagName());
    }
    else if ( pElement->IsNamed() )
    {
        BOOL fHasName;
        LPCTSTR pchId = pElement->GetAAname();

        // do we have a name
        fHasName = !!(pchId);

        fCompare = pchId ? !CompareFn(Name, pchId) : FALSE;
        if (!fCompare)
        {
            pchId = pElement->GetAAid();
            fCompare = pchId ? !CompareFn(Name, pchId) : FALSE;
        }

        if (!fCompare)
        {
            pchId = pElement->GetAAuniqueName();
            fCompare = pchId ? !CompareFn(Name, pchId) : FALSE;
        }
    }
	else
		fCompare = FALSE;

    return fCompare;
}

HRESULT 
CCollectionCache::BuildChildArray( 
    long lCollectionIndex, // Index of collection on which this child collection is based
    CElement* pRootElement,
    CCollectionCacheItem *pIntoCacheItem,
    BOOL fAll )
{
    long                    lSize;
    HRESULT                 hr = S_OK;
    long                    lSourceIndex;
    CCollectionCacheItem *  pFromCacheItem;
    CElement *              pElem;
    CTreeNode *             pNode;

    Assert(lCollectionIndex >=0 && lCollectionIndex < _aryItems.Size());
    Assert(pIntoCacheItem );
    Assert(pRootElement);

    pFromCacheItem = _aryItems[lCollectionIndex]._pCacheItem;

    // 
    // NOTE rgardner - about this fn & the "assert(lCollectionIndex==0)"
    // As a result this fn is not very generic. This assert also assumes that
    // we're item 0 in the all collection. However, this is currently the only situation
    // this fn is called, and making the assumption optimizes the code
    //

    Assert(lCollectionIndex==0); 

    pIntoCacheItem->ResetContents();

    // Didn't find it, create a new collection
    lSourceIndex = pRootElement->GetSourceIndex();
    // If we are outside the tree return
    if(lSourceIndex < 0)
        goto Cleanup;

    lSize = pFromCacheItem->Length();

    if (lSourceIndex >= lSize)
    {
        // This should never happen
        // No match - Return error 
        Assert(0);
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
   
    // Now locate all the immediate children of the element and add them to the array
    for (;;)
    {
        pElem = pFromCacheItem->GetAt(++lSourceIndex) ;
        if ( !pElem )
            break;
        pNode = pElem->GetFirstBranch();
        Assert(pNode);
        // optimize search to spot when we go outside scope of element
        if (!pNode->SearchBranchToRootForScope ( pRootElement ))
        {
            // outside scope of element
            break;
        }
        // If the fall flag is on it means all direct descendants
        // Otherwise it means only immediate children
        if ( fAll || ( pNode->Parent() && 
            pNode->Parent()->Element() == pRootElement ))
        {
            pIntoCacheItem->AppendElement(pElem);
        }
    }
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     BuildNamedArray
//
//  Synopsis:   Fills in an array based on names found in the array of the
//              given index.
//              If we are building a named array on the ELEMENT_COLLECTION
//              we check if we have already created a collection of all
//              named elements, if not, we build it, if yes, we use this
//              collection to access all named elements
//
//  Result:     S_OK
//              E_OUTOFMEMORY
//
//  Note: It is now the semantics of this function to always return a
//        named array (albeit with a size of 0) instead of returning
//        DISPID_MEMBERNOTFOUND.  This allows for Tags to return an empty
//        collection.
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::BuildNamedArray(
        long lCollectionIndex,
        LPCTSTR Name,
        BOOL fTagName,
        CCollectionCacheItem *pIntoCacheItem,
        long iStartFrom,
        BOOL fCaseSensitive,
        BOOL fUrn /* = FALSE */)
{
    HRESULT                 hr = S_OK;
    CElement *              pElem;
    CCollectionCacheItem *  pFromCacheItem;
    BOOL                    fAddElement;

    Assert ( lCollectionIndex >=0 && lCollectionIndex < _aryItems.Size() );
    Assert ( pIntoCacheItem );

    pFromCacheItem = _aryItems[lCollectionIndex]._pCacheItem;
    pIntoCacheItem->ResetContents(); 


    for ( pFromCacheItem->MoveTo( iStartFrom ) ;; ) 
    {
        pElem = pFromCacheItem->GetNext();
        if ( !pElem )
            break;

        if (fTagName && (pElem->Tag() == ETAG_OBJECT || pElem->Tag() == ETAG_APPLET))
        {
            CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
            int l = pObj->_aryParams.Size();
            if (l && !FormsStringICmp(Name, _T("PARAM")))
            {
                for (int i = 0;i < l; i++)
                {
                    hr = THR(pIntoCacheItem->AppendElement(pObj->_aryParams[i]));
                    if (hr)
                        goto Cleanup;
                }
                continue;
            }
        }

        if (fUrn)
        {
            // 'Name' is the Urn we are looking for.  Check if this element has the requested Urn
            fAddElement = pElem->HasPeerWithUrn(Name);
        }
        else if ( CompareName( pElem, Name, fTagName, fCaseSensitive) )
        {
            fAddElement = TRUE;
        }
        else
            fAddElement = FALSE;

        if (fAddElement)
        {
            hr = THR(pIntoCacheItem->AppendElement(pElem));
            if (hr)
                goto Cleanup;
        }
    } 

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     BuildCellRangeArray
//
//  Synopsis:   Fills in an array based on range of cells found in the array of the
//              given index.
//              We first check if we have already created a collection of all
//              cells, if not, we build it, if yes, we use this collection to access 
//              all cells
//
//  Result:     S_OK
//              E_OUTOFMEMORY
//
//  Note: It is now the semantics of this function to always return a
//        named array (albeit with a size of 0) instead of returning
//        DISPID_MEMBERNOTFOUND.  This allows us to return an empty
//        collection.
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::BuildCellRangeArray(long lCollectionIndex, LPCTSTR szRange, 
                             RECT *pRect,  CCollectionCacheItem *pIntoCacheItem )
{
    CCollectionCacheItem *  pFromCacheItem;
    HRESULT                 hr = S_OK;
    CTableCell            * pCell;
    CElement *              pElem;

    Assert(pRect);
    Assert(lCollectionIndex >=0 && lCollectionIndex < _aryItems.Size());
    Assert(pIntoCacheItem );

    pFromCacheItem = _aryItems[lCollectionIndex]._pCacheItem;

    if(pRect->right == -1)
    {
        // The rect is empty, parse it from the string
        CCellRangeParser        cellRangeParser(szRange);
        if(cellRangeParser.Failed())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        cellRangeParser.GetRangeRect(pRect);
    }

    pIntoCacheItem->ResetContents();

    // Build a list of cells in the specified range
    for ( pFromCacheItem->MoveTo(0);; )
    {
        pElem = pFromCacheItem->GetNext();
        if ( !pElem )
            break;
        if (pElem->Tag() != ETAG_TD && pElem->Tag() != ETAG_TH)
            break;
        pCell = DYNCAST(CTableCell, pElem);
        if (pCell->IsInRange(pRect))
        {
            hr = THR(pIntoCacheItem->AppendElement(pElem));
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::GetIDsOfNames
//
//  Synopsis:   Helper to support the following syntax
//
//                  Document.TextBox1.Text = "abc"
//
//----------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIDsOfNames(
        long        lCollectionIndex,
        REFIID      iid,
        TCHAR **    rgszNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid)
{
    // Call GetDispID with CaseSensitive flag set to 0
    RRETURN(GetDispID(lCollectionIndex,
                      rgszNames[0], 
                      fdexFromGetIdsOfNames,
                      rgdispid));
}

//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::Invoke
//
//  Synopsis:   Helper to support the following syntax
//
//                  Document.TextBox1.Text = "abc"
//
//----------------------------------------------------------------------------

HRESULT
CCollectionCache::Invoke(
        long            lCollectionIndex,
        DISPID          dispid,
        REFIID          iid,
        LCID            lcid,
        WORD            wFlags,
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr,
        RETCOLLECT_KIND returnCollection /* = RETCOLLECT_ALL */  )
{
    HRESULT     hr=E_FAIL;
    IDispatch * pDisp = NULL;
    LPCTSTR pch = NULL;

    hr = THR(EnsureAry(lCollectionIndex));
    if (hr)
        goto Cleanup;


    // Is the dispid a collection ordinal index?
    if (IsOrdinalCollectionMember ( lCollectionIndex, dispid ))
    {
        if ( wFlags & DISPATCH_PROPERTYPUT )
        {
            if ( !_pfnAddNewObject )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            if ( ! (pdispparams && pdispparams->cArgs == 1) )
            {
                // No result type we need one for the get to return.
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }
            // Only allow VARIANT of type IDispatch to be put
            if ( pdispparams->rgvarg[0].vt == VT_NULL )
            {
                // the options collection is special. it allows
                // options[n] = NULL to be specified. in this case
                // map the invoke to a delete on that appropriate index
                if (_aryItems[lCollectionIndex].fSettableNULL)
                {
                    hr = THR(Remove(lCollectionIndex, 
                                    dispid - GetOrdinalMemberMin(lCollectionIndex)));
                    // Like Nav - silently ignore the put if its's outside the current range
                    if ( hr == E_INVALIDARG )
                        hr = S_OK;
                }
                else
                {
                    hr = E_INVALIDARG;
                }

                goto Cleanup;
            }
            else if ( pdispparams->rgvarg[0].vt != VT_DISPATCH )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            // All OK, let the collection cache validate the Put
            hr = THR ( CALL_METHOD( (CVoid *)(void *)_pBase, _pfnAddNewObject, ( 
                    lCollectionIndex, 
                    V_DISPATCH ( pdispparams->rgvarg ), 
                    dispid - GetOrdinalMemberMin(lCollectionIndex) )));

            if ( hr )
                goto Cleanup;
        }
        else if ( wFlags & DISPATCH_PROPERTYGET )
        {
            VARIANTARG      v1, v2;
            long lIdx = dispid - GetOrdinalMemberMin(lCollectionIndex);

            if ( ! ( (lIdx >= 0) && (lIdx < SizeAry(lCollectionIndex)) ) )
            {
                hr = S_OK;
                if ( pvarResult )
                {
                    VariantClear(pvarResult);
                    pvarResult->vt = VT_NULL;
                    hr = S_OK;
                    goto Cleanup;
                }
            }

            v1.vt = VT_I4;
            v1.lVal = lIdx;

            // Always get the item by index.
            v2.vt = VT_ERROR;

            if (pvarResult)
            {
                hr = Item(lCollectionIndex, v1, v2, &(pvarResult->pdispVal));
                if (!hr)
                {
                    if (!(pvarResult->pdispVal))
                    {
                        hr = E_FAIL;        // use super::Invoke
                    }
                    else
                    {
                        pvarResult->vt = VT_DISPATCH;
                    }
                }
            }
        }
    }
    else if(IsNamedCollectionMember(lCollectionIndex, dispid))
    {
        BOOL        fCaseSensitive;
        long        lOffset;

        lOffset = GetNamedMemberOffset(lCollectionIndex, dispid, &fCaseSensitive);

        hr = THR(GetAtomTable()->GetNameFromAtom(dispid - lOffset, &pch));
        if (hr)
            goto Cleanup;

        if ( returnCollection == RETCOLLECT_ALL && !DoGetLastMatchedName(lCollectionIndex))
        {
            // GetDisp can return a disp ptr to a collection if name matches more than one item
            hr = THR_NOTRACE(GetDisp(
                lCollectionIndex,
                pch,
                CacheType_Named,
                &pDisp,
                fCaseSensitive));
            if (FAILED(hr))
            {
                hr = THR_NOTRACE(GetDisp(
                    lCollectionIndex,
                    pch,
                    CacheType_CellRange,
                    &pDisp,
                    fCaseSensitive));
            }
        }
        else 
        {
            CElement * pElementTemp;
            long lIndex = (returnCollection == RETCOLLECT_LASTITEM) ? -1 : 0;

            // Here GetIntoAry will only return the first/last item that matches the name
            hr = THR_NOTRACE(GetIntoAry(
                    lCollectionIndex,
                    pch,
                    FALSE,
                    &pElementTemp,
                    lIndex,
                    fCaseSensitive));
            if (hr && hr != S_FALSE)
                goto Cleanup;

            hr = THR(pElementTemp->QueryInterface(IID_IDispatch, (void **)&pDisp));
            if (hr)
                goto Cleanup;
        }

        if(hr)
            goto Cleanup;
        //
        //  Special handling for controls accessed as members
        //

        if (wFlags == DISPATCH_PROPERTYGET ||
            wFlags == (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
        {
            if (!pvarResult)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            // cArgs==1 when Doc.foo(0) is used and =0 when Doc.foo.count
            //  this is only an issue when there are multiple occurances
            //  of foo, and a collection is supposed to be returned by
            //  document.foo
            if (pdispparams->cArgs > 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                goto Cleanup;
            }
            else  if (pdispparams->cArgs == 1)
            {
                hr = THR(pDisp->Invoke(
                        DISPID_VALUE,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr));
            }
            else
            {
                V_VT(pvarResult) = VT_DISPATCH;
                V_DISPATCH(pvarResult) = pDisp;
                pDisp->AddRef();
            }
        }
        else if (wFlags == DISPATCH_PROPERTYPUT ||
            wFlags == DISPATCH_PROPERTYPUTREF)
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                goto Cleanup;
            }

            hr = THR(pDisp->Invoke(
                    DISPID_VALUE,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr));
        }
        else
        {
            // Any other kind of invocation is not valid.
            hr = DISP_E_MEMBERNOTFOUND;
        }
    }
    else
    {
        Assert(FALSE);
    }
Cleanup:
    ReleaseInterface(pDisp);
    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::GetDispID, IDispatchEx
//
//  Synopsis:   Support insuring if the name is an index into the collection
//              or passing off to property/expando support.
//
//  Note:       If the name is not known index, property or expando in the
//              collection the returned dispid is DISPID_UNKNOWN with a result
//              of S_OK.  Then on the invoke if DISPID_UNKNOWN is encountered
//              we'll return VT_EMPTY.  This allow VBScript/JavaScript to test
//              isnull( ) or comparision to null.
//
//----------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDispID(long lIndex, BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr = E_FAIL;
    long        lIdx = 0;
    long        lAtom;
    CElement * pNode;

    // Could the name be an index.  We check for index first, index for a
    // collection object takes precidence over expando.  As a result if an
    // expando "5" exist then the collection grows to have an item 5 we'll find
    // item and not the expando "5".  If the collection item 5 is removed then
    // we'd find the expando 5.  In addtion we'll allow [""] to index item 0 of
    // the collection.

    // Insure the string is really a number.
    hr = ttol_with_error(bstrName, &lIdx);
    if (!hr)
    {
        // Try to map name to a named element in the collection.
        // Ignore it if we're not promoting ordinals
        if ( !CanPromoteOrdinals (lIndex ) )
        {
            hr = DISP_E_UNKNOWNNAME;
            goto Cleanup;
        }

        if ( _pfnAddNewObject )
        {
            // The presence of _pfnAddNewObject indicates that the collection
            // allows setting to arbitrary indices. Expando on the collection
            // is not allowed.
            *pid = GetOrdinalMemberMin(lIndex)+lIdx;
            if (*pid > GetOrdinalMemberMax(lIndex) )
            {
                hr = DISP_E_UNKNOWNNAME;
            }
            goto Cleanup;
        }
        else
        {
            // Without a _pfnAddNewObject, the collection only supports
            // access to ordinals in the current range. Other accesses
            // become expando.
            hr = THR(EnsureAry(lIndex));
            if (hr)
                goto Cleanup;

            if ( (lIdx >= 0) && (lIdx < SizeAry(lIndex)) )
            {
                *pid = GetOrdinalMemberMin(lIndex)+lIdx;
                if (*pid > GetOrdinalMemberMax(lIndex) )
                {
                    hr = DISP_E_UNKNOWNNAME;
                }
            }
            else
            {
                hr = DISP_E_UNKNOWNNAME;
            }
        }
    }
    else
    {
        long        lMax;
        BOOL        fCaseSensitive;

        // If we don't promote named items - nothing more to do
        if ( !CanPromoteNames(lIndex)  )
        {
            hr = DISP_E_UNKNOWNNAME;
            goto Cleanup;
        }

        hr = THR(EnsureAry(lIndex));
        if (hr)
            goto Cleanup;

        Assert ( _aryItems[lIndex].dispidMin != 0 );
        Assert ( _aryItems[lIndex].dispidMax != 0 );

        fCaseSensitive = ( grfdex & fdexNameCaseSensitive ) != 0;
        //
        // Search the collection for the given name
        //

        hr = THR_NOTRACE(GetIntoAry(
                lIndex,
                bstrName,
                FALSE,
                &pNode, 
                0,
                fCaseSensitive));
        if (FAILED(hr))
        {
            hr = DISP_E_UNKNOWNNAME;
            goto Cleanup;
        }

        //
        // Since we found the element in the elements collection,
        // update atom table.
        //
        Assert(bstrName);
        hr = THR(GetAtomTable()->AddNameToAtomTable(bstrName, &lAtom));
        if (hr)
            goto Cleanup;
        //
        // lAtom is the index into the atom table.  Offset this by
        // base.
        //
        if(fCaseSensitive)
        {
            lAtom += GetSensitiveNamedMemberMin(lIndex);
            lMax = GetSensitiveNamedMemberMax(lIndex);
        }
        else
        {
            lAtom += GetNotSensitiveNamedMemberMin(lIndex);
            lMax = GetNotSensitiveNamedMemberMax(lIndex);
        }

        *pid = lAtom;
        if (*pid > lMax)
        {
            hr = DISP_E_UNKNOWNNAME;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::GetNextDispID, IDispatchEx
//
//  Synopsis:   Supports enumerating through all properties, attributes,
//              expandos, and indexes (numbers and names) of a collection.
//
//----------------------------------------------------------------------------
HRESULT
CCollectionCache::GetNextDispID(
                long lIndex,
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr = S_FALSE;
    long        lItmIndex;

    // Enumerating the indexes then enumerate each index of the collection.

    if (IsOrdinalCollectionMember (lIndex, id))
    {
        lItmIndex = id - GetOrdinalMemberMin(lIndex) + 1;

        // Make sure our collection is up-to-date.
        hr = THR(EnsureAry(lIndex));
        if (hr)
            goto Error;

        // Is the number within range for an item in the collection?
        if (lItmIndex < 0 || (lItmIndex >= SizeAry(lIndex)))
            goto Error;

        *prgid = GetOrdinalMemberMin(lIndex) + lItmIndex;

        // Is the index too large?
        if (*prgid > GetOrdinalMemberMax(lIndex) )
            goto Error;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);

Error:
    hr = S_FALSE;
    *prgid = DISPID_UNKNOWN;
    goto Cleanup;
}

HRESULT
CCollectionCache::GetMemberName(
                long lIndex,
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr = S_FALSE;
    long        lItmIndex;
    TCHAR       ach[20];
    CElement *  pElem;
    LPCTSTR     peName;

    if (IsOrdinalCollectionMember (lIndex, id))
    {
        lItmIndex = id - GetOrdinalMemberMin(lIndex);

        // Make sure our collection is up-to-date.
        hr = THR(EnsureAry(lIndex));
        if (hr)
            goto Error;

        // Is the number within range for an item in the collection?
        if (lItmIndex < 0 || (lItmIndex >= SizeAry(lIndex)))
            goto Error;

        // If this fails then we've got real problems the collection
        // size and elements it points to is VERY BAD.

        if ( !_aryItems[lIndex].fDontPromoteNames )
        {
            THR(GetIntoAry(lIndex, lItmIndex, &pElem));
            Assert(pElem);
            peName = pElem->GetIdentifier();
        }
        else
        {
            peName = NULL;
        }
        // If the element doesn't have name associated with it then
        // return the index number.
        if (!peName || !_tcslen(peName))
        {
            // Make a string out of the index.
            hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), lItmIndex);
            if (hr)
                goto Cleanup;

            peName = ach;
        }

        hr = FormsAllocString(peName, pbstrName);
    }

Cleanup:
    return hr;

Error:
    hr = S_FALSE;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     GetLength
//
//  Synopsis:   collection object model helper
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetLength(long lCollection, long * plSize)
{
    HRESULT hr;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get its current size.
    *plSize = SizeAry(lCollection);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Item
//
//  Synopsis:   collection object model
//
//              we handle the following parameter cases:
//                  0 params            : by index = 0
//                  1 params bstr       : by name, index = 0
//                  1 params #          : by index
//                  2 params bstr, #    : by name, index
//                  2 params #, bstr    : by index, ignoring bstr
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Item(long lCollection, VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    VARIANT *   pvarName = NULL;
    VARIANT *   pvarOne  = NULL;
    VARIANT *   pvarIndex = NULL;
    long        lIndex = 0;
    HRESULT     hr=E_INVALIDARG;

    if (!ppResult)
        goto Cleanup;

    *ppResult = NULL;

    pvarOne = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarOne)==VT_BSTR) || V_VT(pvarOne)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarOne) & VT_BYREF) ?
            V_VARIANTREF(pvarOne) : pvarOne;

        if ((V_VT(&var2) != VT_ERROR ) &&
            (V_VT(&var2) != VT_EMPTY ))
        {
            pvarIndex = &var2;
        }
    }
    else if ((V_VT(&var1) != VT_ERROR )&&
             (V_VT(&var1) != VT_EMPTY ))
    {
        pvarIndex = &var1;
    }

    if (pvarIndex)
    {
        VARIANT varNum;

         VariantInit(&varNum);
         hr = THR(VariantChangeTypeSpecial(&varNum,pvarIndex,VT_I4));
         if (hr)
            goto Cleanup;

         lIndex = V_I4(&varNum);
    }

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get a collection or element of the specified object.
    if (pvarName)
    {
        BSTR    Name = V_BSTR(pvarName);

        if (pvarIndex)
        {
            hr = THR(GetDisp(lCollection,
                             Name,
                             lIndex,
                             ppResult,
                             FALSE));   // BUBUG rgardner - shouldn't ignore case
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(GetDisp(lCollection,
                             Name,
                             CacheType_Named,
                             ppResult,
                             FALSE));   // BUBUG rgardner - shouldn't ignore case
            if (FAILED(hr))
            {
                HRESULT hrSave = hr;    // save error code, and see if it a cell range
                hr = THR_NOTRACE(GetDisp(
                    lCollection,
                    Name,
                    CacheType_CellRange,
                    ppResult,
                    FALSE));            // BUBUG rgardner - shouldn't ignore case
                if (hr)
                {
                    hr = hrSave;        // restore error code
                    goto Cleanup;
                }
            }
        }
    }
    else
    {
        hr = THR(GetDisp(lCollection,
                         lIndex,
                         ppResult));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // If we didn't find anything, make sure to just return NULL.
    if (hr == DISP_E_MEMBERNOTFOUND)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}

HRESULT
CCollectionCache::GetElemAt(long lCollection, long *plCurrIndex, IDispatch **ppCurrNode)
{
    HRESULT hr;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    *ppCurrNode = NULL;

    if (*plCurrIndex < 0)
    {
        *plCurrIndex = 0;
        goto Cleanup;
    }
    else if (*plCurrIndex > SizeAry(lCollection) - 1)
    {
        *plCurrIndex = SizeAry(lCollection) - 1;
        goto Cleanup;
    }

    hr = THR(GetDisp(lCollection, *plCurrIndex, ppCurrNode));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     Tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Tags(long lCollection, VARIANT var1, IDispatch ** ppdisp)
{
    VARIANT *   pvarName = NULL;
    HRESULT     hr=E_INVALIDARG;

    if (!ppdisp)
        goto Cleanup;

    *ppdisp = NULL;

    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ?
        V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ?
            V_VARIANTREF(pvarName) : pvarName;
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR(Tags(lCollection, V_BSTR(pvarName), ppdisp));

Cleanup:
    RRETURN(hr);
}

HRESULT
CCollectionCache::Tags(long lCollection, LPCTSTR szTagName, IDispatch ** ppdisp)
{
    HRESULT hr;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get a collection of the specified tags.
    hr = THR(GetDisp( lCollection,
                      szTagName,
                      CacheType_Tag,
                      (IDispatch**)ppdisp,
                      FALSE)); // Case sensitivity ignored for TagName
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     Urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Urns(long lCollection, VARIANT var1, IDispatch ** ppdisp)
{
    VARIANT *   pvarName = NULL;
    HRESULT     hr=E_INVALIDARG;

    if (!ppdisp)
        goto Cleanup;

    *ppdisp = NULL;

    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ?
        V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ?
            V_VARIANTREF(pvarName) : pvarName;
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get a collection of the elements with the specified urn
    hr = THR(GetDisp( lCollection,
                      V_BSTR(pvarName),
                      CacheType_Urn,
                      (IDispatch**)ppdisp,
                      FALSE)); // Case sensitivity ignored for Urn
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetNewEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetNewEnum(long lCollection, IUnknown ** ppEnum)
{
    CPtrAry<LPUNKNOWN> *    pary = NULL;
    long                    lSize;
    long                    l;
    HRESULT                 hr=E_INVALIDARG;

    if (!ppEnum)
        goto Cleanup;

    *ppEnum = NULL;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    pary = new(Mt(CCollectionCacheGetNewEnum_pary)) CPtrAry<LPUNKNOWN>(Mt(CCollectionCacheGetNewEnum_pary_pv));
    if (!pary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    lSize = SizeAry(lCollection);

    hr = THR(pary->EnsureSize(lSize));
    if (hr)
        goto Error;

    // Now make a snapshot of our collection.
    for (l = 0; l < lSize; ++l)
    {
        IDispatch * pdisp;

        hr = THR(GetDisp(lCollection, l, &pdisp));
        if (hr)
            goto Error;

        Verify(!pary->Append(pdisp));
    }

    // Turn the snapshot into an enumerator.
    hr = THR(pary->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **) ppEnum, FALSE, TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    pary->ReleaseAll();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     Remove
//
//  Synopsis:   remove the item in the collection at the given index
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Remove(long lCollection, long lItemIndex)
{
    HRESULT hr;

    if ((lItemIndex < 0) || (lItemIndex >= SizeAry(lCollection)))
        hr = E_INVALIDARG;
    else
    {
        if (_pfnRemoveObject)
            hr = THR ( CALL_METHOD( (CVoid *)(void *)_pBase, _pfnRemoveObject, 
                                    (lCollection, lItemIndex)));
        else
            hr = CTL_E_METHODNOTAPPLICABLE;
    }

    RRETURN( hr);
}

////////////////////////////////////////////////////////////////////////////////
//
//  Automation helper routines used by collection classes.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT
DispatchInvokeCollection(CBase *             pThis,
                         InvokeExPROC        SuperInvokeFunction,
                         CCollectionCache *  pCollectionCache,
                         long                lCollectionIdx,
                         DISPID              dispidMember,
                         REFIID              riid,
                         LCID                lcid,
                         WORD                wFlags,
                         DISPPARAMS *        pdispparams,
                         VARIANT *           pvarResult,
                         EXCEPINFO *         pexcepinfo,
                         UINT *              puArgErr,
                         IServiceProvider *  pSrvProvider,
                         RETCOLLECT_KIND     returnCollection /* = RETCOLLECT_ALL */)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    IHTMLWindow2   *pOmWindow = NULL;

    if (pCollectionCache && pCollectionCache->IsDISPIDInCollection ( lCollectionIdx, dispidMember ) )
    {
        // Note that CCollectionCache::Invokedoesn't need a punkCaller
        hr = pCollectionCache->Invoke(lCollectionIdx,
                                      dispidMember,
                                      riid,
                                      lcid,
                                      wFlags,
                                      pdispparams,
                                      pvarResult,
                                      pexcepinfo,
                                      puArgErr,
                                      returnCollection );
    }

    // for IE3 compat, name access of IFrames should return the om window
    if (lCollectionIdx == CMarkup::NAVDOCUMENT_COLLECTION &&
        !hr &&
        pvarResult &&
        V_VT(pvarResult) == VT_DISPATCH &&
        V_DISPATCH(pvarResult))
    {
        CElement       * pElem     = NULL;

        hr = THR_NOTRACE(V_DISPATCH(pvarResult)->QueryInterface(CLSID_CElement, (void**)&pElem));
        if (hr)
        {
            // what we have may be a collection pointer, so just mask the error
            // and return like we used to.
            hr = S_OK;
            goto Cleanup;
        }

        // For IE3.0 compatibility return named IFRAMEs as elements from the
        // document.  The window IDispatch'd object returned must be a 
        // security object (WindowProxy).
        if (pElem->Tag() == ETAG_IFRAME)
        {
            // the above QI does NOT addref. so we need to do it here before
            // the release in the variantClear
            CElement::CLock lock(pElem);

            VariantClear(pvarResult);

            // If the element is in a markup and has a window, then secure the
            // object we return in the context of that window.
            Assert(pElem->GetNearestMarkupForScriptCollection());

            COmWindowProxy *    pProxyContaining = pElem->GetNearestMarkupForScriptCollection()->Window();
            VARIANTARG          varIn;

            V_VT(&varIn) = VT_DISPATCH;
            V_DISPATCH(&varIn) = (IHTMLWindow2*)DYNCAST(CFrameSite, pElem)->_pWindow;

            Assert(pProxyContaining);

            // secure the window object in the context of the caller 
            hr = THR(pProxyContaining->SecureObject(&varIn, 
                                                    pvarResult, 
                                                    pSrvProvider, 
                                                    NULL, 
                                                    TRUE));

        }
    }

    // If above didn't work then try to get the property/expando.
    if (hr && pThis)
    {
        hr = THR_NOTRACE(CALL_METHOD( pThis, SuperInvokeFunction, (dispidMember,
                                                       lcid,
                                                       wFlags,
                                                       pdispparams,
                                                       pvarResult,
                                                       pexcepinfo,
                                                       pSrvProvider)));
    }

Cleanup:
    ReleaseInterface(pOmWindow);
    RRETURN(hr);
}



HRESULT
DispatchGetDispIDCollection(CBase *             pThis,
                            GetDispIDPROC       SuperGetDispIDFunction,
                            CCollectionCache *  pCollectionCache,
                            long                lCollectionIdx,
                            BSTR                bstrName,
                            DWORD               grfdex,
                            DISPID    *         pid)
{
    HRESULT     hr;

    Assert(pThis);
    Assert(pCollectionCache);

    hr = THR_NOTRACE(pCollectionCache->GetDispID(lCollectionIdx,
                                                 bstrName,
                                                 grfdex,
                                                 pid));

    // The collectionCache GetIDsOfNamesEx will return S_OK w/ DISPID_UNKNOW
    // if the name isn't found, catastrophic errors are of course returned.
    if (hr || (!hr && *pid == DISPID_UNKNOWN))
    {
        hr = THR_NOTRACE(CALL_METHOD( pThis, SuperGetDispIDFunction, (bstrName, grfdex, pid)));
    }

    RRETURN(hr);
}


HRESULT
DispatchGetNextDispIDCollection(CBase *             pThis,
                                GetNextDispIDPROC   SuperGetNextDispIDFunction,
                                CCollectionCache *  pCollectionCache,
                                long                lCollectionIdx,
                                DWORD               grfdex,
                                DISPID              id,
                                DISPID *            pid)
{
    HRESULT hr = S_FALSE;

    Assert(pThis);
    Assert(pCollectionCache);

    // Are we enumerating the collection indexes?
    if ( !pCollectionCache->IsOrdinalCollectionMember ( lCollectionIdx, id ) )
    {
        // No, so continue enumerating regular attributes, properties, and
        // expandos.
        hr = THR(CALL_METHOD( pThis, SuperGetNextDispIDFunction, (grfdex,
                                                      id,
                                                      pid)));

        // Have we reached the end of the properties, attributes and expandos
        // for the collection?
        if (hr)
        {
            // Yes, so only return a DISPID_UNKNOWN if the collection has no
            // items otherwise return the index 0 of the collection.
            if (pCollectionCache->SizeAry(lCollectionIdx) > 0)
            {
                *pid = pCollectionCache->GetOrdinalMemberMin ( lCollectionIdx );
                hr = S_OK;
            }
        }
    }
    // If we didn't or we're enumerating in the collection index range then go
    // right to the collection cache.
    else
    {
        hr = THR(pCollectionCache->GetNextDispID(lCollectionIdx,
                                                 grfdex,
                                                 id,
                                                 pid));
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
DispatchGetMemberNameCollection(CBase *                 pThis,
                                GetGetMemberNamePROC    SuperGetMemberNameFunction,
                                CCollectionCache *      pCollectionCache,
                                long                    lCollectionIdx,
                                DISPID                  id,
                                BSTR *                  pbstrName)
{
    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;

    Assert(pThis);
    Assert(pCollectionCache);

    // Are we enumerating the collection indexes?
    if ( !pCollectionCache->IsOrdinalCollectionMember ( lCollectionIdx, id ) )
    {
        // No, so continue enumerating regular attributes, properties, and
        // expandos.
        CALL_METHOD( pThis, SuperGetMemberNameFunction, (id, pbstrName));
    }
    // If we didn't or we're enumerating in the collection index range then go
    // right to the collection cache.
    else
    {
        pCollectionCache->GetMemberName(lCollectionIdx,
                                        id,
                                        pbstrName);
    }

    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

// returns the correct offset of given dispid in given collection and the 
// case sensetivity flag (if requested)


long
CCollectionCache::GetNamedMemberOffset(long lCollectionIndex, DISPID dispid, 
                             BOOL *pfCaseSensitive /* =  NULL */)
{
    LONG        lOffset;
    BOOL        fSensitive;

    Assert(IsNamedCollectionMember(lCollectionIndex, dispid));

    // Check to see wich half of the dispid space the value goes
    if(IsSensitiveNamedCollectionMember(lCollectionIndex, dispid))
    {
        lOffset = GetSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = TRUE;
    }
    else
    {
        lOffset = GetNotSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = FALSE;
    }

    // return the sensitivity flag if required
    if(pfCaseSensitive != NULL)
        *pfCaseSensitive = fSensitive;

    return lOffset;
}


CAtomTable * 
CCollectionCache::GetAtomTable (BOOL *pfExpando)
{   
    if (pfExpando) 
        *pfExpando = Markup() ? Markup()->_fExpando : TRUE; 

    if (Markup())
        return &(Markup()->Doc()->_AtomTable);
    else
        return DYNCAST(CEventObj, _pBase)->GetAtomTable(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\extdl.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_EXTDL_HXX_
#define X_EXTDL_HXX_
#include "extdl.hxx"
#endif

MtDefine(CExternalDownload, Utilities, "CExternalDownload")

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Helper:     UnicodeStringFromAnsiStream
//
//+---------------------------------------------------------------------------

HRESULT
UnicodeStringFromAnsiStream(LPTSTR * ppch, IStream * pStream)
{
    HRESULT     hr;
    STATSTG     statstg;
    ULONG       ulLen;
    ULONG       ulLenRead;
    LPSTR       pchAnsi = NULL;
    LPTSTR      pchEnd;
    ULONG       cch;

    Assert (ppch);

    //
    // get stream length
    //

    hr = THR(pStream->Stat(&statstg, STATFLAG_NONAME));
    if (hr)
        goto Cleanup;

    ulLen = statstg.cbSize.LowPart;
    if (statstg.cbSize.HighPart || 0xFFFFFFFF == ulLen)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // read stream into buffer
    //

    pchAnsi = new char[ulLen + 1];
    if (!pchAnsi)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pStream->Read(pchAnsi, ulLen, &ulLenRead));
    if (hr)
        goto Cleanup;
    if (ulLen != ulLenRead)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // convert ANSI to unicode and normalize CRs
    //

    // get length
    cch = MultiByteToWideChar(CP_ACP, 0, pchAnsi, ulLen, NULL, 0);

    (*ppch) = new TCHAR[cch + 1];
    if (!(*ppch))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // convert now
    Verify(cch == (ULONG) MultiByteToWideChar(CP_ACP, 0, pchAnsi, ulLen, (*ppch), cch));

    pchEnd = (*ppch) + cch;
    cch -= NormalizerChar((*ppch), &pchEnd);
    (*ppch)[cch] = _T('\0');


Cleanup:
    delete pchAnsi;

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CExternalDownload
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::CExternalDownload
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CExternalDownload::CExternalDownload()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::~CExternalDownload
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CExternalDownload::~CExternalDownload()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::Download
//
//  (static)
//
//-------------------------------------------------------------------------

HRESULT
CExternalDownload::Download(
    LPTSTR      pchUrl,
    IDispatch * pdispCallbackFunction,
    CDoc *      pDoc,
    CElement *  pElement)
{
    HRESULT             hr;
    CExternalDownload * pDownload;

    pDownload = new CExternalDownload();
    if (!pDownload)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pDownload->Init(pchUrl, pdispCallbackFunction, pDoc, pElement));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::Download
//
//-------------------------------------------------------------------------

HRESULT
CExternalDownload::Init (
    LPTSTR      pchUrl,
    IDispatch * pdispCallbackFunction,
    CDoc *      pDoc,
    CElement *  pElement)
{
    HRESULT         hr;
    TCHAR   cBuf[pdlUrlLen];
    LPTSTR          pchExpandedUrl = cBuf;
    CBitsCtx *      pBitsCtx = NULL;

    //
    // general init
    //

    _pDoc = pDoc;
    ReplaceInterface (&_pdispCallbackFunction, pdispCallbackFunction);

    //
    // launch download
    //

    hr = THR(_pDoc->ExpandUrl(pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, pElement));
    if (hr)
        goto Cleanup;

    hr = THR(_pDoc->NewDwnCtx(DWNCTX_BITS, pchExpandedUrl, NULL, (CDwnCtx **)&pBitsCtx));
    if (hr)
        goto Cleanup;

    SetBitsCtx(pBitsCtx);


Cleanup:
    if (pBitsCtx)
        pBitsCtx->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::Done
//
//-------------------------------------------------------------------------

HRESULT
CExternalDownload::Done ()
{
    SetBitsCtx(NULL);

    ClearInterface (&_pdispCallbackFunction);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CExternalDownload::SetBitsCtx
//
//+---------------------------------------------------------------------------

void
CExternalDownload::SetBitsCtx(CBitsCtx * pBitsCtx)
{
    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }
    _pBitsCtx = pBitsCtx;

    if (_pBitsCtx)
    {
        _pBitsCtx->AddRef();

        if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
        {
            OnDwnChan(_pBitsCtx);
        }
        else
        {
            _pBitsCtx->SetProgSink(_pDoc->GetProgSink());
            _pBitsCtx->SetCallback(OnDwnChanCallback, this);
            _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CExternalDownload::OnDwnChan
//
//+---------------------------------------------------------------------------

void
CExternalDownload::OnDwnChan(CDwnChan * pDwnChan)
{
    HRESULT     hr;
    IStream *   pStream = NULL;
    LPTSTR      pchString = NULL;

    if (_pBitsCtx->GetState() & DWNLOAD_COMPLETE)
    {
        // If unsecure download, may need to remove lock icon on Doc
        if (_pDoc)
        {
            _pDoc->OnSubDownloadSecFlags(_pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
        }
        
        //
        // data downloaded successfully - get it
        //

        hr = THR(_pBitsCtx->GetStream(&pStream));
        if (hr)
            goto Cleanup;

        hr = THR(UnicodeStringFromAnsiStream(&pchString, pStream));
        if (hr)
            goto Cleanup;
    }
    else
        hr = E_FAIL;

    //
    // invoke the callback function
    //

    if (_pdispCallbackFunction)
    {
        VARIANT     varArg;
        DISPPARAMS  dispparams = {&varArg, NULL, 1, 0};
        EXCEPINFO   excepinfo;
        UINT        nArgErr;

        // if the string was downloaded successfully
        if (S_OK == hr)
        {
            // invoke with VT_BSTR and the string
            V_VT(&varArg) = VT_BSTR;
            hr = THR(FormsAllocString (STRVAL(pchString), &V_BSTR(&varArg)));
            if (hr)
                goto Cleanup;
        }
        else
        {
            // otherwise invoke with VT_NULL
            VariantInit(&varArg);
            V_VT(&varArg) = VT_NULL;
        }

        IGNORE_HR(_pdispCallbackFunction->Invoke(
            DISPID_VALUE, IID_NULL, LOCALE_SYSTEM_DEFAULT,
            DISPATCH_METHOD, &dispparams, NULL, &excepinfo, &nArgErr));
    }

    //
    // finalize
    //

    if (_pBitsCtx && (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_STOPPED | DWNLOAD_ERROR)))
    {
        _pBitsCtx->SetProgSink(NULL);
        
        IGNORE_HR(Done());
        delete this;
    }

    // ! here the instance of class is deallocated from memory, be carefull not to use it

Cleanup:
    delete pchString;

    ReleaseInterface(pStream);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\eventobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       eventobj.cxx
//
//  Contents:   Implementation of CEventObject class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_WINBASE_H_
#define X_WINBASE_H_
#include "winbase.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for CDataSourceProvider
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#define _cxx_
#include "eventobj.hdl"

MtDefine(CEventObj, ObjectModel, "CEventObj")
MtDefine(BldEventObjElemsCol, PerfPigs, "Build CEventObj::EVENT_BOUND_ELEMENTS_COLLECTION")

//=======================================================================
//
//  #defines  -- this section contains a nubmer of pound defines of functions that
//    are repreated throughout this file.  there are not quite enough to warrent
//    a functional re-write, but enough to make the redundant code difficult to
//    read.
//
//=======================================================================

//=======================================================================

#define MAKESUREPUTSAREALLOWED          \
    if(!_fReadWrite)                    \
    {                                   \
        hr = DISP_E_MEMBERNOTFOUND;     \
        goto Cleanup;                   \
    }


#define GETKEYVALUE(fnName,  MASK)   \
    HRESULT CEventObj::get_##fnName (VARIANT_BOOL *pfAlt)   \
{                                                       \
    HRESULT         hr;                                 \
    EVENTPARAM *    pparam;                             \
                                                        \
    hr = THR(GetParam(&pparam));                        \
    if (hr)                                             \
        goto Cleanup;                                   \
                                                        \
    *pfAlt = VARIANT_BOOL_FROM_BOOL(pparam->_sKeyState & ##MASK); \
                                                        \
Cleanup:                                                \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);      \
}                                                       \

#define PUTKEYVALUE(fnName,  MASK)                      \
    HRESULT CEventObj::put_##fnName (VARIANT_BOOL fPressed)   \
{                                                       \
    HRESULT         hr;                                 \
    EVENTPARAM *    pparam;                             \
                                                        \
    MAKESUREPUTSAREALLOWED                              \
                                                        \
    hr = THR(GetParam(&pparam));                        \
    if (hr)                                             \
        goto Cleanup;                                   \
                                                        \
    if(fPressed)                                        \
        pparam->_sKeyState |= ##MASK;                    \
    else                                                \
        pparam->_sKeyState &= ~##MASK;                   \
                                                        \
                                                        \
Cleanup:                                                \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);      \
}




//=======================================================================

HRESULT
CEventObj::GenericGetElement (IHTMLElement** ppElement, DISPID dispid)
{
    EVENTPARAM *    pparam;
    HRESULT         hr      = S_OK;
    CTreeNode  *    pTarget = NULL;
    long            lSubDiv = -1;
    IUnknown   *    pUnk;

    if (!ppElement)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppElement = NULL;

    if (S_OK == GetUnknownPtr(dispid, &pUnk))
    {
        goto Cleanup;
    }

    *ppElement = (IHTMLElement *)pUnk;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    switch (dispid)
    {
    case DISPID_CEventObj_srcElement:
        pTarget = pparam->_pNode;
        lSubDiv = pparam->_lSubDivisionSrc;
        break;  
    case DISPID_CEventObj_fromElement:
        pTarget = pparam->_pNodeFrom;
        lSubDiv = pparam->_lSubDivisionFrom;
        break;  
    case DISPID_CEventObj_toElement:
        pTarget = pparam->_pNodeTo;
        lSubDiv = pparam->_lSubDivisionTo;
        break;
    default:
        Assert(FALSE);
        break;
    }

    if (!pTarget || pTarget->Element() == pTarget->Doc()->PrimaryRoot())
        goto Cleanup;

    if (lSubDiv >= 0)
    {
        if (pTarget->Tag() == ETAG_IMG )
        {
            CAreaElement * pArea = NULL;
            CImgElement *pImg = DYNCAST(CImgElement, pTarget->Element());

            if (pImg->GetMap())
            {
                pImg->GetMap()->GetAreaContaining(lSubDiv, &pArea);
                if (pArea)
                    pTarget = pArea->GetFirstBranch();
            }
        }
    }

    if (!pTarget)
        goto Cleanup;

    if (pTarget == pTarget->Element()->GetFirstBranch())
    {
        hr = THR(pTarget->Element()->QueryInterface(IID_IHTMLElement, (void **)ppElement));
    }
    else
    {
        hr = THR(pTarget->GetInterface(IID_IHTMLElement, (void **)ppElement));
    }

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


HRESULT
CEventObj::GenericPutElement (IHTMLElement* pElement, DISPID dispid)
{
    RRETURN(PutUnknownPtr(dispid, pElement));
}

//=======================================================================

#define GET_STRING_VALUE(fnName, strName)       \
    HRESULT CEventObj::get_##fnName  (BSTR *p)  \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    if (!p)                                     \
    {                                           \
        hr = E_POINTER;                         \
        goto Cleanup;                           \
    }                                           \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    hr = FormsAllocString(pparam->##strName(), p);      \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);      \
}


#define PUT_STRING_VALUE(fnName, strName)       \
    HRESULT CEventObj::put_##fnName  (BSTR p)   \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    if (!p)                                     \
    {                                           \
        hr = E_POINTER;                         \
        goto Cleanup;                           \
    }                                           \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##strName(p);                       \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}


//=======================================================================

HRESULT
CEventObj::GenericGetLong(long * plongRet, ULONG uOffset)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!plongRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *plongRet = -1;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *plongRet = *(long *)(((BYTE *)pparam) + uOffset);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


HRESULT 
CEventObj::GenericGetLongPtr (LONG_PTR * pLongPtr, ULONG uOffset)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pLongPtr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLongPtr = NULL;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pLongPtr = *(LONG_PTR *)(((BYTE *)pparam) + uOffset);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}



#define PUT_LONG_VALUE(fnName, propName )       \
    HRESULT CEventObj::put_##fnName (long lLongVal) \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##propName = lLongVal;              \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}

#define PUT_LONG_VALUEX(fnName, propName )       \
    HRESULT CEventObj::put_##fnName (long lLongVal) \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsX(lLongVal);  \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}

#define PUT_LONG_VALUEY(fnName, propName )       \
    HRESULT CEventObj::put_##fnName (long lLongVal) \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsY(lLongVal);  \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}

#define PUT_OFFSET_VALUEX(fnName, propName, flagName)               \
    HRESULT CEventObj::put_##fnName (long lLongVal)                 \
{                                                                   \
    HRESULT         hr;                                             \
    EVENTPARAM *    pparam;                                         \
                                                                    \
    MAKESUREPUTSAREALLOWED                                          \
                                                                    \
    hr = THR(GetParam(&pparam));                                    \
    if (hr)                                                         \
        goto Cleanup;                                               \
                                                                    \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsX(lLongVal);\
    pparam->##flagName = TRUE;                                      \
                                                                    \
Cleanup:                                                            \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);                  \
}

#define PUT_OFFSET_VALUEY(fnName, propName, flagName)               \
    HRESULT CEventObj::put_##fnName (long lLongVal)                 \
{                                                                   \
    HRESULT         hr;                                             \
    EVENTPARAM *    pparam;                                         \
                                                                    \
    MAKESUREPUTSAREALLOWED                                          \
                                                                    \
    hr = THR(GetParam(&pparam));                                    \
    if (hr)                                                         \
        goto Cleanup;                                               \
                                                                    \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsY(lLongVal);\
    pparam->##flagName = TRUE;                                      \
                                                                    \
Cleanup:                                                            \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);                  \
}

//=======================================================================

//---------------------------------------------------------------------------
//
//  CEventObj ClassDesc
//
//---------------------------------------------------------------------------

const CBase::CLASSDESC CEventObj::s_classdesc =
{
    &CLSID_CEventObj,                // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLEventObj,             // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};



//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::CreateEventObject
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::Create(
    IHTMLEventObj** ppEventObj,
    CDoc *          pDoc,
    CElement *      pElement,
    CMarkup *       pMarkup,
    BOOL            fCreateAttached /* = TRUE*/,
    LPTSTR          pchSrcUrn, /* = NULL */
    EVENTPARAM *    pParam /*=NULL*/
)
{
    HRESULT         hr;
    CEventObj *     pEventObj = NULL;

    if (!ppEventObj)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEventObj = NULL;

    if (   fCreateAttached 
        && pDoc 
        && pDoc->_pparam 
        && pDoc->_pparam->pEventObj)
    {
        Assert( ! pParam );
        pEventObj = pDoc->_pparam->pEventObj;
        pEventObj->AddRef();
    }
    else
    {
        pEventObj = new CEventObj(pDoc);
        if (!pEventObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj, (void **)ppEventObj));
    if (hr)
        goto Cleanup;

    if (!fCreateAttached )
    {
        pEventObj->_pparam = new EVENTPARAM(pDoc,
                                            pElement,
                                            pMarkup,
                                            /* fInitState = */ !pParam,
                                            /* fPush = */ FALSE,
                                            pParam);
        if (!pEventObj->_pparam)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pEventObj->_pparam->pEventObj = pEventObj;

        // This is an XTag event object, mark it as read/write
        pEventObj->_fReadWrite = TRUE;
    }
    else if ( pParam )
    {
        pEventObj->_pparam = new EVENTPARAM( pParam ) ;
        if (!pEventObj->_pparam)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pEventObj->_pparam->pEventObj = pEventObj;        
    }

    if (fCreateAttached || !pParam || !pElement)
        hr = pEventObj->SetAttributes(pDoc);

    if (pchSrcUrn)
        pEventObj->_pparam->SetSrcUrn(pchSrcUrn);

Cleanup:
    if (pEventObj)
        pEventObj->Release();

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::SetAttributes
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::SetAttributes(CDoc * pDoc)
{
    HRESULT      hr = S_OK;
    EVENTPARAM * pparam = pDoc ? pDoc->_pparam : _pparam;
    CMarkup *    pMarkupContext = NULL;
    BOOL         fExpando = TRUE;

    if (!pparam || !pparam->GetType())
        goto Cleanup;

    pMarkupContext = GetMarkupContext();
    if (pMarkupContext)
    {
        fExpando = pMarkupContext->_fExpando;
        pMarkupContext->_fExpando = TRUE;
    }

    // script error expandos
    if (!StrCmpIC(_T("error"), pparam->GetType()))
    {
        CVariant varErrorMessage(VT_BSTR);
        CVariant varErrorUrl(VT_BSTR);
        CVariant varErrorLine(VT_I4);
        CVariant varErrorCharacter(VT_I4);
        CVariant varErrorCode(VT_I4);

        hr = FormsAllocString(pparam->errorParams.pchErrorMessage, &varErrorMessage.bstrVal);
        if (hr)
            goto Cleanup;
        hr = FormsAllocString(pparam->errorParams.pchErrorUrl, &varErrorUrl.bstrVal);
        if (hr)
            goto Cleanup;
        V_I4(&varErrorLine) =           pparam->errorParams.lErrorLine;
        V_I4(&varErrorCharacter) =      pparam->errorParams.lErrorCharacter;
        V_I4(&varErrorCode) =           pparam->errorParams.lErrorCode;

        hr = SetExpando(_T("errorMessage"), &varErrorMessage);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorUrl"), &varErrorUrl);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorLine"), &varErrorLine);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorCharacter"), &varErrorCharacter);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorCode"), &varErrorCode);
    }

    // ShowMessage expandos
    else if (!StrCmpIC(_T("message"), pparam->GetType()))
    {
        CVariant varMessageText(VT_BSTR);
        CVariant varMessageCaption(VT_BSTR);
        CVariant varMessageStyle(VT_UI4);
        CVariant varMessageHelpFile(VT_BSTR);
        CVariant varMessageHelpContext(VT_UI4);

        hr = FormsAllocString(pparam->messageParams.pchMessageText, &varMessageText.bstrVal);
        if (hr)
            goto Cleanup;
        hr = FormsAllocString(pparam->messageParams.pchMessageCaption, &varMessageCaption.bstrVal);
        if (hr)
            goto Cleanup;
        hr = FormsAllocString(pparam->messageParams.pchMessageHelpFile, &varMessageHelpFile.bstrVal);
        if (hr)
            goto Cleanup;
        V_UI4(&varMessageStyle)         = pparam->messageParams.dwMessageStyle;
        V_UI4(&varMessageHelpContext)   = pparam->messageParams.dwMessageHelpContext;

        hr = SetExpando(_T("messageText"), &varMessageText);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageCaption"), &varMessageCaption);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageStyle"), &varMessageStyle);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageHelpFile"), &varMessageHelpFile);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageHelpContext"), &varMessageHelpContext);
        if (hr)
            goto Cleanup;
    }
    
    // property sheet dialog expandos
    else if (!StrCmpIC(_T("propertysheet"), pparam->GetType()))
    {
        // we are using a VARIANT and not a CVariant because we do not want to free the
        // array here
        VARIANT varpaPropertysheetPunks;
        V_VT(&varpaPropertysheetPunks) = VT_SAFEARRAY;
        V_ARRAY(&varpaPropertysheetPunks) = pparam->propertysheetParams.paPropertysheetPunks;

        hr = SetExpando(_T("propertysheetPunks"), &varpaPropertysheetPunks);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (pMarkupContext)
        pMarkupContext->_fExpando = fExpando;

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::COnStackLock::COnStackLock
//
//--------------------------------------------------------------------------

CEventObj::COnStackLock::COnStackLock(IHTMLEventObj * pEventObj)
{
    HRESULT     hr;

    Assert (pEventObj);

    _pEventObj = pEventObj;
    _pEventObj->AddRef();

    hr = THR(pEventObj->QueryInterface (CLSID_CEventObj, (void**)&_pCEventObj));
    if (hr)
        goto Cleanup;

    _pCEventObj->_pparam->Push();

Cleanup:
    return;
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::COnStackLock::~COnStackLock
//
//--------------------------------------------------------------------------

CEventObj::COnStackLock::~COnStackLock()
{
    _pCEventObj->_pparam->Pop();
    _pEventObj->Release();
}

//---------------------------------------------------------------------------
//
//  Member:     CEventObj::CEventObj
//
//  Synopsis:   constructor
//
//---------------------------------------------------------------------------

CEventObj::CEventObj(CDoc * pDoc)
{
    _pDoc = pDoc;
    _pMarkupContext = NULL;
    if (pDoc)
        _pDoc->SubAddRef();
    else
    {
        _pAtomTable = new CAtomTable();
    }
}

//---------------------------------------------------------------------------
//
//  Member:     CEventObj::~CEventObj
//
//  Synopsis:   destructor
//
//---------------------------------------------------------------------------

CEventObj::~CEventObj()
{
    if (_pDoc)
        _pDoc->SubRelease();

    if (_pAtomTable)
    {
        _pAtomTable->Free();
        delete _pAtomTable;
    }

    if (_pMarkupContext)
        _pMarkupContext->SubRelease();

    delete _pCollectionCache;
    delete _pparam;
}

//---------------------------------------------------------------------------
//
//  Member:     CEventObj::GetParam
//
//---------------------------------------------------------------------------

HRESULT
CEventObj::GetParam(EVENTPARAM ** ppParam)
{
    Assert (ppParam);

    if (_pparam)
    {
        // gaurenteed to be here if pdoc is NULL
        (*ppParam) = _pparam;
    }
    else
    {
        if (_pDoc->_pparam)
        {
            (*ppParam) = _pDoc->_pparam;
        }
        else
        {
            (*ppParam) = NULL;
            RRETURN (DISP_E_MEMBERNOTFOUND);

        }
    }
    RRETURN (S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTMLEventObj, NULL)
    QI_TEAROFF(this, IHTMLEventObj2, NULL)
    QI_TEAROFF(this, IHTMLEventObj3, NULL)
    QI_TEAROFF(this, IHTMLEventObj4, NULL)
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    default:
        if (IsEqualGUID(iid, CLSID_CEventObj))
        {
            *ppv = this;
            return S_OK;
        }

        // Primary default interface, or the non dual
        // dispinterface return the same object -- the primary interface
        // tearoff.
        if (DispNonDualDIID(iid))
        {
            HRESULT hr = CreateTearOffThunk( this,
                                        (void *)s_apfnIHTMLEventObj,
                                        NULL,
                                        ppv);
            if (hr)
                RRETURN(hr);
        }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the event's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CEventObj::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    if (!_pCollectionCache)
    {
        Assert(_pDoc);

        _pCollectionCache = new CCollectionCache(
                this,          // double cast needed for Win16.
                GetMarkupContext(),
                ENSURE_METHOD(CEventObj, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(NUMBER_OF_EVENT_COLLECTIONS));
        if (hr)
            goto Error;
    }

    hr = THR( _pCollectionCache->EnsureAry( 0 ) );

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the event's collections, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CEventObj::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    HRESULT hr = S_OK;
    EVENTPARAM *    pparam;
    int i;

    // Nothing to do so get out.
    if (*plCollectionVersion)
        goto Cleanup;

    MtAdd(Mt(BldEventObjElemsCol), +1, 0);

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    // Reset the collections.
    for (i = 0; i < NUMBER_OF_EVENT_COLLECTIONS; i++)
    {
        _pCollectionCache->ResetAry(i);
    }

    // Reload the bound elements collection
    if (pparam->pProvider)
    {
        hr = pparam->pProvider->
                LoadBoundElementCollection(_pCollectionCache, EVENT_BOUND_ELEMENTS_COLLECTION);
        if (hr)
        {
            _pCollectionCache->ResetAry(EVENT_BOUND_ELEMENTS_COLLECTION);
        }
    }

    *plCollectionVersion = 1;   // to mark it done

Cleanup:
    RRETURN(hr);
}

HRESULT
CEventObj::get_contentOverflow(VARIANT_BOOL * pVB)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pVB)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pVB = VARIANT_BOOL_FROM_BOOL(pparam->_fOverflow);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_nextPage(BSTR *p)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;
    LPCTSTR         pstrLeftRight;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    switch (pparam->GetOverflowType())
    {
    case OVERFLOWTYPE_LEFT:
        pstrLeftRight = TEXT("left");
        break;
    case OVERFLOWTYPE_RIGHT:
        pstrLeftRight = TEXT("right");
        break;
    default:
        pstrLeftRight = TEXT("");
    }

    hr = FormsAllocString(pstrLeftRight, p);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::get_srcElem
//  Method:     CEventObj::get_fromElement
//  Method:     CEventObj::get_toElement
//
//  Synopsis:   Per IEventObj.  see macro defined at the top of this file.
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::get_srcElement (IHTMLElement** ppElement)
{
    return GenericGetElement(ppElement, DISPID_CEventObj_srcElement);
}


HRESULT
CEventObj::get_fromElement (IHTMLElement** ppElement)
{
    return GenericGetElement(ppElement, DISPID_CEventObj_fromElement);
}


HRESULT
CEventObj::get_toElement (IHTMLElement** ppElement)
{
    return GenericGetElement(ppElement, DISPID_CEventObj_toElement);
}


HRESULT
CEventObj::put_srcElement (IHTMLElement* pElement)
{
    return GenericPutElement(pElement, DISPID_CEventObj_srcElement);
}


HRESULT
CEventObj::put_fromElement (IHTMLElement* pElement)
{
    return GenericPutElement(pElement, DISPID_CEventObj_fromElement);
}


HRESULT
CEventObj::put_toElement (IHTMLElement* pElement)
{
    return GenericPutElement(pElement, DISPID_CEventObj_toElement);
}


//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::get_button
//  Method:     CEventObj::get_keyCode      KeyCode of a key event
//  Method:     CEventObj::get_reason       reason enum for ondatasetcomplete
//  Method:     CEventObj::get_clientX      Per IEventObj, in client coordinates
//  Method:     CEventObj::get_clientY      Per IEventObj, in client coordinates
//  Method:     CEventObj::get_screenX      Per IEventObj, in screen coordinates
//  Method:     CEventObj::get_screenY      Per IEventObj, in screen coordinates
//
//  Synopsis:   Per IEventObj
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::get_button (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _lButton ));
}

HRESULT
CEventObj::get_keyCode (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _lKeyCode ));
}

HRESULT
CEventObj::get_reason (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _lReason ));
}

HRESULT
CEventObj::get_clientX (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _clientX )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_clientY (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _clientY )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_screenX (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _screenX )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_screenY (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _screenY )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_offsetX (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _offsetX )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
    
}

HRESULT
CEventObj::get_offsetY (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _offsetY )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_x (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _x )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_y (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _y )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}


PUT_LONG_VALUE(button, _lButton);
PUT_LONG_VALUE(reason, _lReason);
PUT_LONG_VALUEX(clientX, _clientX);
PUT_LONG_VALUEY(clientY, _clientY);
PUT_LONG_VALUEX(screenX, _screenX);
PUT_LONG_VALUEY(screenY, _screenY);
PUT_OFFSET_VALUEX(offsetX, _offsetX, _fOffsetXSet);
PUT_OFFSET_VALUEY(offsetY, _offsetY, _fOffsetYSet);
PUT_LONG_VALUEX(x, _x);
PUT_LONG_VALUEY(y, _y);

//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::put_keyCode
//
//  Synopsis:   Puts the keyCode
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::put_keyCode(long lKeyCode)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    // SECURITY ALERT:- we cannot allow a user to set the keycode if the 
    // srcElement is an <input type=file>, otherwise it is possible for 
    // a page to access any file off the user's HardDrive without them
    // knowing (see  bug 49620 for a more complete description)
    // HTA's (trusted Doc's) should allow this.
    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    // is the srcElement an input , and if so is the type: file ?

    if (pparam->_pNode &&
        (pparam->_pNode->Tag() == ETAG_INPUT) &&
        (DYNCAST(CInput, pparam->_pNode->Element())->GetAAtype() == htmlInputFile) &&
        _pDoc &&
        !(pparam->_pNode->Element()->GetMarkup()->IsMarkupTrusted()))
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        pparam->_lKeyCode = lKeyCode;
    }

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

//+---------------------------------------------------------------
//
//  Method : get_repeat
//
//  Synopsis : returns a vbool indicating whether this was a repeated event
//          as in the case of holing a key down
//
//--------------------------------------------------------------

HRESULT
CEventObj::get_repeat (VARIANT_BOOL *pfRepeat)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfRepeat)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfRepeat = VARIANT_BOOL_FROM_BOOL(pparam->fRepeatCode);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_shiftLeft (VARIANT_BOOL *pfShiftLeft)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfShiftLeft)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfShiftLeft = VARIANT_BOOL_FROM_BOOL(pparam->_fShiftLeft);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_altLeft (VARIANT_BOOL *pfAltLeft)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfAltLeft)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfAltLeft = VARIANT_BOOL_FROM_BOOL(pparam->_fAltLeft);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_ctrlLeft (VARIANT_BOOL *pfCtrlLeft)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfCtrlLeft)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfCtrlLeft = VARIANT_BOOL_FROM_BOOL(pparam->_fCtrlLeft);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_imeCompositionChange(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}

HRESULT
CEventObj::get_imeNotifyCommand(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _wParam ));
}

HRESULT
CEventObj::get_imeNotifyData(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}


HRESULT
CEventObj::get_imeRequest(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _wParam ));
}

HRESULT
CEventObj::get_imeRequestData(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}

HRESULT
CEventObj::get_keyboardLayout(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}

HRESULT
CEventObj::get_wheelDelta (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _wheelDelta ));
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::get_altKey, get_ctrlKey, get_shiftKey
//
//  Synopsis:   Per IEventObj.  see macro defined at the top of this file.
//
//--------------------------------------------------------------------------

GETKEYVALUE(altKey, VB_ALT);
GETKEYVALUE(ctrlKey, VB_CONTROL);
GETKEYVALUE(shiftKey, VB_SHIFT);


PUTKEYVALUE(altKey, VB_ALT);
PUTKEYVALUE(ctrlKey, VB_CONTROL);
PUTKEYVALUE(shiftKey, VB_SHIFT);


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::get_cancelBubble
//
//  Synopsis:   Cancels the event bubbling. Used by CElement::FireEvents
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::get_cancelBubble(VARIANT_BOOL *pfCancel)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfCancel)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfCancel = VARIANT_BOOL_FROM_BOOL(pparam->fCancelBubble);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::put_cancelBubble
//
//  Synopsis:   Cancels the event bubbling. Used by CElement::FireEvents
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::put_cancelBubble(VARIANT_BOOL fCancel)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->fCancelBubble = fCancel ? TRUE : FALSE;

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::get_returnValue
//
//  Synopsis:   Retrieve the current cancel status.
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::get_returnValue(VARIANT * pvarReturnValue)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pvarReturnValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    hr = THR(VariantCopy(pvarReturnValue, &pparam->varReturnValue));

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::put_returnValue
//
//  Synopsis:   Cancels the default action of an event.
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::put_returnValue(VARIANT varReturnValue)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    hr = THR(VariantCopy (&pparam->varReturnValue, &varReturnValue));
    
    
Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}




//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_type
//
//  Synopsis :  For Nav 4.2 compatability. this returns a string which is the
//              type of this event.
//
//----------------------------------------------------------------------------
GET_STRING_VALUE(type, GetType )

PUT_STRING_VALUE(type, CopyType )

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_propertyName
//
//  Synopsis :  For the onproperty change event, this returnes the name of the
//     property that changed
//
//----------------------------------------------------------------------------

GET_STRING_VALUE(propertyName, GetPropName)

PUT_STRING_VALUE(propertyName, CopyPropName)

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_qualifier
//
//  Synopsis :  Qualifier argument to ondatasetchanged, ondataavailable, and
//              ondatasetcomplete events
//
//----------------------------------------------------------------------------

GET_STRING_VALUE(qualifier, GetQualifier)

PUT_STRING_VALUE(qualifier, CopyQualifier)

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_srcUrn
//
//----------------------------------------------------------------------------

GET_STRING_VALUE(srcUrn, GetSrcUrn)

PUT_STRING_VALUE(srcUrn, CopySrcUrn)

//+-------------------------------------------------------------------------
//
//  Method:     EVENTPARAM::GetParentCoordinates
//
//  Synopsis:   Helper function for getting the parent coordinates
//              notset/statis -- doc coordinates
//              relative      --  [styleleft, styletop] +
//                                [x-site.rc.x, y-site.rc.y]
//              absolute      --  [A_parent.rc.x, A_parent.rc.y,] +
//                                [x-site.rc.x, y-site.rc.y]
//
//  Parameters : px, py - the return point 
//               fContainer :  TRUE - COORDSYS_BOX
//                             FALSE - COORDSYS_CONTENT
//
//  these parameters are here for NS compat. and as such the parent defined
//  for the positioning are only ones that are absolutely or relatively positioned
//  or the body.
//
//--------------------------------------------------------------------------


HRESULT
EVENTPARAM::GetParentCoordinates(long * px, long * py)
{
    CPoint         pt(0,0);
    HRESULT        hr = S_OK;
    CLayout *      pLayout;
    CElement *     pElement;
    CDispNode *    pDispNode;
    CRect          rc;
    CTreeNode    * pZNode = _pNode;

    if (!_pNode || !_pNode->_pNodeParent)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // First, determine if we need to climb out of a slavetree
    //---------------------------------------------------------
    if (_pNode->Element()->HasMasterPtr())
    {
        Assert(_pNode->GetMarkup());

        CElement *pElemMaster;

        pElemMaster = _pNode->Element()->GetMasterPtr();
        if (!pElemMaster)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
        
        pZNode = pElemMaster->GetFirstBranch();
        if (!pZNode)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
    }

    // now the tricky part. We have a Node for the element that 
    // the event is on, but the "parent" that we are reporting
    // position information for is not constant. The parent is the 
    // first ZParent of this node that is relatively positioned
    // The canvas element (primary BODY/FRAMESET in non CSS1, HTML in CSS1) is
    // always a valid place to stop.
    // Absolutely positioned elements DON'T COUNT.
    //---------------------------------------------------------

    // walk up looking for a positioned thing.
    {
        Assert(pZNode->GetMarkup());

        while (     pZNode
                &&  !pZNode->IsRelative()
                &&  pZNode->Tag() != ETAG_ROOT
                &&  pZNode->GetMarkup()->GetCanvasElement() != pZNode->Element() )
        {
            pZNode = pZNode->ZParentBranch();
        }
    }

    pElement = pZNode ? pZNode->Element() : NULL;

    // now we know the element that we are reporting a position wrt
    // and so we just need to get the dispnode and the position info
    //---------------------------------------------------------
    if(pElement)
    {
        pLayout = pElement->GetUpdatedNearestLayout( _pLayoutContext );

        if(pLayout)
        {
            pDispNode = pLayout->GetElementDispNode(pElement);

            if(pDispNode)
            {
                CElement *pElementContent = pLayout->ElementContent();
                if (pElementContent && !pElementContent->HasVerticalLayoutFlow())
                {
                    pDispNode->TransformPoint(pt, COORDSYS_BOX, &pt, COORDSYS_GLOBAL);
                }
                else
                {
                    CRect rcBounds;
                    pDispNode->GetBounds(&rcBounds, COORDSYS_GLOBAL);
                    pt.x = rcBounds.left;
                    pt.y = rcBounds.top;
                }
            }
        }
    }

    // adjust for the offset of the mouse wrt the postition of the parent
    pt.x = _clientX - pt.x + _ptgClientOrigin.x;
    pt.y = _clientY - pt.y + _ptgClientOrigin.y;


    // and return the values.
    if (px)
        *px = pt.x;
    if (py)
        *py = pt.y;

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}
//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_srcFilter
//
//  Synopsis :  Return boolean of the filter that fired the event.
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_srcFilter(IDispatch **pFilter)
{
    HRESULT         hr = S_OK;
    EVENTPARAM *    pparam;

    if (!pFilter)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Try to get from attr array in first
    if(S_OK == GetDispatchPtr(DISPID_CEventObj_srcFilter, pFilter))
        goto Cleanup;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pFilter = NULL;

    if ( pparam->psrcFilter )
    {
        hr = pparam->psrcFilter->QueryInterface (
            IID_IDispatch, (void**)&pFilter );
        if ( hr == E_NOINTERFACE )
            hr = S_OK; // Just return NULL - some filters aren't automatable
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_bookmarks
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_bookmarks(IHTMLBookmarkCollection **ppBookmarkCollection)
{
    HRESULT         hr = E_NOTIMPL;
    EVENTPARAM *    pparam;
    IUnknown      * pUnk;

    if (!ppBookmarkCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppBookmarkCollection = NULL;

    if(S_OK == GetUnknownPtr(DISPID_CEventObj_bookmarks, &pUnk))
    {
        *ppBookmarkCollection = (IHTMLBookmarkCollection *)pUnk;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    if (pparam->pProvider)
    {
        hr = pparam->pProvider->get_bookmarks(ppBookmarkCollection);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_recordset
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_recordset(IDispatch **ppDispRecordset)
{
    HRESULT         hr = S_OK;
    EVENTPARAM *    pparam;

    if (!ppDispRecordset)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispRecordset = NULL;

    if(!GetDispatchPtr(DISPID_CEventObj_recordset, ppDispRecordset))
        goto Cleanup;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    if (pparam->pProvider)
    {
        hr = pparam->pProvider->get_recordset(ppDispRecordset);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_dataFld
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_dataFld(BSTR *pbstrDataFld)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;
    AAINDEX         aaIndex;

    if (!pbstrDataFld)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDataFld = NULL;

    aaIndex = FindAAIndex(DISPID_CEventObj_dataFld, CAttrValue::AA_Internal);
    if(aaIndex != AA_IDX_UNKNOWN)
    {
        BSTR bstrStr;
        hr = THR(GetIntoBSTRAt(aaIndex, &bstrStr));
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(bstrStr, pbstrDataFld));
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    if (pparam->pProvider)
    {
        hr = pparam->pProvider->get_dataFld(pbstrDataFld);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_boundElements
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_boundElements(IHTMLElementCollection **ppElementCollection)
{
    HRESULT         hr = S_OK;
    IUnknown      * pUnk;

    if (!ppElementCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppElementCollection = NULL;

    if(S_OK == GetUnknownPtr(DISPID_CEventObj_boundElements, &pUnk))
    {
        *ppElementCollection = (IHTMLElementCollection *)pUnk;
        goto Cleanup;
    }

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(EVENT_BOUND_ELEMENTS_COLLECTION,
                                        (IDispatch **)ppElementCollection));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::put_repeat(VARIANT_BOOL fRepeat)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->fRepeatCode = BOOL_FROM_VARIANT_BOOL(fRepeat);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::put_shiftLeft(VARIANT_BOOL fShiftLeft)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->_fShiftLeft = BOOL_FROM_VARIANT_BOOL(fShiftLeft);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::put_ctrlLeft(VARIANT_BOOL fCtrlLeft)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->_fCtrlLeft = BOOL_FROM_VARIANT_BOOL(fCtrlLeft);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::put_altLeft(VARIANT_BOOL fAltLeft)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->_fAltLeft = BOOL_FROM_VARIANT_BOOL(fAltLeft);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::put_boundElements(struct IHTMLElementCollection *pColl)
{
    RRETURN(PutUnknownPtr(DISPID_CEventObj_boundElements, pColl));
}


HRESULT
CEventObj::put_dataFld(BSTR strFld)
{
    HRESULT     hr;

    MAKESUREPUTSAREALLOWED

    hr = THR(AddBSTR(DISPID_CEventObj_dataFld, strFld, CAttrValue::AA_Internal));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::put_recordset(struct IDispatch *pDispatch)
{
    RRETURN(PutDispatchPtr(DISPID_CEventObj_recordset, pDispatch));
}


HRESULT
CEventObj::put_bookmarks(struct IHTMLBookmarkCollection *pColl)
{
    RRETURN(PutUnknownPtr(DISPID_CEventObj_bookmarks, pColl));
}


HRESULT
CEventObj::put_srcFilter(struct IDispatch *pDispatch)
{
    RRETURN(PutDispatchPtr(DISPID_CEventObj_srcFilter, pDispatch));
}


HRESULT
EVENTPARAM::CalcRestOfCoordinates()
{
    HRESULT     hr = S_OK;
    CLayout   * pLayout = NULL;

    if(_pNode)
    {
        hr = THR_NOTRACE(GetParentCoordinates(&_x, &_y));
        if(hr)
            goto Cleanup;

        pLayout = _pNode->GetUpdatedNearestLayout( _pLayoutContext );
        if (!pLayout)
        {
            _offsetX = -1;
            _offsetY = -1;
            goto Cleanup;
        }
        else
        {
            CPoint ptGlobal(_clientX, _clientY);
            CPoint ptLocal;
            pLayout->PhysicalGlobalToPhysicalLocal(ptGlobal, &ptLocal);
            _offsetX = ptLocal.x;
            _offsetY = ptLocal.y;
#if 0
            //
            // I would love to keep this assert, but the problem is that the old code was buggy when
            // we changed the border on the element and then we fired an event without calcing. In that
            // case the old code would account for the newly set borders while they are not shown on the
            // screen. The new way does not have that problem and that is where they differ and hence
            // the assert. So I am just commenting it out. If there is a bug where the reported offset*
            // on the event object is incorrect, then first uncomment this block of code to see if
            // the assert fires. If it does, then maybe the new code is buggy. BTW, the DRT at this
            // time passes without this assert firing.
            //
            {
                CElement *pElement = pLayout->ElementContent();

                // NOTES(SujalP): 
                // (1) The row seems to be buggy. If the border is applied to
                // the table thru a stylesheet, then the border ends up on the row too
                // but does not when its applied thru the border attribute (!)
                // (2) When we do not have a display node, GetPositionLeft returns
                // a bogus number (not zero as one would expect). Hence, in that case
                // just do not try to remain compat with the "bogus' number :-)
                // (3) (KTam) The body's GetBorderInfo always returns 0
                // if we're printing, so avoid the assert in that case.
                if (   !pLayout->ElementContent()->HasVerticalLayoutFlow()
                    && pElement->Tag() != ETAG_TR
                    && pLayout->GetElementDispNode()
                    && pLayout->GetElementDispNode()->HasParent()
                    && !( pElement->Tag() == ETAG_BODY && pElement->GetMarkup() && pElement->GetMarkup()->IsPrintMedia() )
                   )
                {
                    CBorderInfo bi;
                    long pl = pLayout->GetPositionLeft(COORDSYS_GLOBAL);
                    long pt = pLayout->GetPositionTop(COORDSYS_GLOBAL);
                    pElement->GetBorderInfo(NULL, &bi, FALSE);
                    Assert(_offsetX == _clientX - pl + pLayout->GetXScroll() - bi.aiWidths[SIDE_LEFT]);
                    Assert(_offsetY == _clientY - pt + pLayout->GetYScroll() - bi.aiWidths[SIDE_TOP]);
                }
            }
#endif
        }
    }

Cleanup:
    RRETURN(hr);
}


void
EVENTPARAM::SetClientOrigin(CElement * pElement, const POINT * pptClient)
{
    if (pElement)
        pElement->GetClientOrigin(&_ptgClientOrigin);

    if (pptClient)
    {
        _clientX = pptClient->x - _ptgClientOrigin.x;
        _clientY = pptClient->y - _ptgClientOrigin.y;

    }
}

void
EVENTPARAM::SetNodeAndCalcCoordinates(CTreeNode *pNewNode, BOOL fFixClientOrigin /*=FALSE*/)
{
    if(_pNode != pNewNode)
    {
        if (fFixClientOrigin)
        {
            POINT ptOrgOld = _ptgClientOrigin;

            if (!pNewNode)
            {
                _ptgClientOrigin = g_Zero.pt;
            }
            else
            {
                Assert(_pNode);
                Assert(_pNode->GetMarkup()->Root()->GetMasterPtr() == pNewNode->Element());

                SetClientOrigin(pNewNode->Element(), NULL);
            }

            _clientX -= (_ptgClientOrigin.x - ptOrgOld.x);
            _clientY -= (_ptgClientOrigin.y - ptOrgOld.y);
        }

        _pNode = pNewNode;
        if (_pNode)
            CalcRestOfCoordinates();
    }
}

void
EVENTPARAM::SetNodeAndCalcCoordsFromOffset(CTreeNode *pNewNode)
{
    Assert(_fOffsetXSet || _fOffsetYSet);
    _pNode = pNewNode;
    if(_pNode)
    {
        POINT pt = {0,0};
        CLayout *pLayout = _pNode->GetUpdatedNearestLayout(_pLayoutContext);

        if (_fOffsetXSet || _fOnStack || _offsetX)
        {
            // either X offset is set explicity or implicity as a result of being in a nested event.
            Assert(_fOffsetXSet || (_fOnStack && _fOffsetYSet) || (_offsetX && _fOffsetYSet));
            if (pLayout)
            {
                CPoint ptLocal(_offsetX, 0);
                CPoint ptGlobal;
                pLayout->PhysicalLocalToPhysicalGlobal(ptLocal, &ptGlobal);
                pt.x = _clientX = ptGlobal.x;
            }
        }
        else
        {
            // Y offset is set explicity, but X offset is not set (explicitly or implicitly) 
            // -- event param created on heap --- calculate it based upon clientX of current location
            Assert(!_fOnStack && _fOffsetYSet);
            if (pLayout)
            {
                CPoint ptGlobal(_clientX, 0);
                CPoint ptLocal;
                pLayout->PhysicalGlobalToPhysicalLocal(ptGlobal, &ptLocal);
                _offsetX = ptLocal.x;
            }
            else
            {
                _offsetX = -1;
            }
            pt.x = _clientX;
        }

        if (_fOffsetYSet || _fOnStack || _offsetY)
        {
            // either Y offset is set explicity or implicity as a result of being in a nested event.
            Assert(_fOffsetYSet || (_fOnStack && _fOffsetXSet) || (_offsetY && _fOffsetXSet));
            if (pLayout)
            {
                CPoint ptLocal(0, _offsetY);
                CPoint ptGlobal;
                pLayout->PhysicalLocalToPhysicalGlobal(ptLocal, &ptGlobal);
                pt.y = _clientY = ptGlobal.y;
            }
        }
        else
        {
            // X offset is set explicity, but Y offset is not set (explicitly or implicitly) 
            // -- event param created on heap --- calculate it based upon clientX of current location
            Assert(!_fOnStack && _fOffsetXSet);
            if (pLayout)
            {
                CPoint ptGlobal(0, _clientY);
                CPoint ptLocal;
                pLayout->PhysicalGlobalToPhysicalLocal(ptGlobal, &ptLocal);
                _offsetY = ptLocal.y;
            }
            else
            {
                _offsetY = -1;
            }
            pt.y = _clientY;
        }

        if (pDoc)
        {
            if (pDoc->_pInPlace)
            {
                ClientToScreen(pDoc->_pInPlace->_hwnd, &pt);
            }
        }
        else
        {
            ::GetCursorPos(&pt);
        }
        _screenX = pt.x;
        _screenY = pt.y;

        IGNORE_HR(GetParentCoordinates(&_x, &_y));
    }
}

HRESULT
CEventObj::PutUnknownPtr(DISPID dispid, IUnknown *pElement)
{
    HRESULT hr;

    MAKESUREPUTSAREALLOWED

    if(pElement)                                              \
        pElement->AddRef();                                   \

    hr = THR(AddUnknownObject(dispid, (IUnknown *)pElement, CAttrValue::AA_Internal));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::PutDispatchPtr(DISPID dispid, IDispatch *pDispatch)
{
    HRESULT hr;

    MAKESUREPUTSAREALLOWED

    if(pDispatch)
        pDispatch->AddRef();

    hr = THR(AddDispatchObject(dispid, pDispatch, CAttrValue::AA_Internal));

Cleanup:
    RRETURN(SetErrorInfo(hr));

}


HRESULT
CEventObj::GetUnknownPtr(DISPID dispid, IUnknown **ppElement)
{
    HRESULT hr;
    AAINDEX aaIndex = FindAAIndex(dispid, CAttrValue::AA_Internal);

    Assert(ppElement);

    if(aaIndex != AA_IDX_UNKNOWN)
        hr = THR(GetUnknownObjectAt(aaIndex, ppElement));
    else
    {
        *ppElement = NULL;
        hr = S_FALSE;
    }

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}


HRESULT
CEventObj::GetDispatchPtr(DISPID dispid, IDispatch **ppElement)
{
    HRESULT hr;
    AAINDEX aaIndex = FindAAIndex(dispid, CAttrValue::AA_Internal);

    if(aaIndex != AA_IDX_UNKNOWN)
        hr = THR(GetDispatchObjectAt(aaIndex, ppElement));
    else
        hr = S_FALSE;

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_dataTransfer
//
//  Synopsis :  Return the data transfer object.
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_dataTransfer(IHTMLDataTransfer **ppDataTransfer)
{
    HRESULT hr = S_OK;
    CDataTransfer * pDataTransfer;
    IDataObject * pDataObj = _pDoc ? _pDoc->_pInPlace->_pDataObj : NULL;

    if (!ppDataTransfer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDataTransfer = NULL;

    // are we in a drag-drop operation?
    if (!pDataObj)
    {
        CDragStartInfo * pDragStartInfo = _pDoc->_pDragStartInfo;
        if (!pDragStartInfo)
            // leave hr = S_OK and just return NULL
            goto Cleanup;
        if (!pDragStartInfo->_pDataObj)
        {
            hr = pDragStartInfo->CreateDataObj();
            if (hr || pDragStartInfo->_pDataObj == NULL)
                goto Cleanup;
        }

        pDataObj = pDragStartInfo->_pDataObj;
    }

    Assert(_pMarkupContext->Window()->Window());

    pDataTransfer = new CDataTransfer(_pMarkupContext->Window()->Window(), pDataObj, TRUE);   // fDragDrop = TRUE
    if (!pDataTransfer)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pDataTransfer->QueryInterface(
                IID_IHTMLDataTransfer,
                (void **) ppDataTransfer));
        pDataTransfer->Release();
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::get_behaviorCookie(LONG *plCookie)
{
    EVENTPARAM *pparam;

    HRESULT hr;
    
    if (!plCookie)
        hr = E_POINTER;
    else
    {
        hr = THR(GetParam(&pparam));

        if (hr == S_OK)
            *plCookie = pparam->_lBehaviorCookie;
    }

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::get_behaviorPart(LONG *plPartID)
{
    EVENTPARAM *pparam;

    HRESULT hr;
    
    if (!plPartID)
        hr = E_POINTER;
    else
    {
        hr = THR(GetParam(&pparam));

        if (hr == S_OK)
            *plPartID = pparam->_lBehaviorPartID;
    }

    RRETURN(SetErrorInfo(hr));
}

CMarkup *
CEventObj::GetMarkupContext()
{
    EVENTPARAM *pParam;

    if (_pMarkupContext)
        return _pMarkupContext;

    GetParam(&pParam);
    
    Assert(pParam);

    _pMarkupContext = pParam->_pElement ? pParam->_pElement->GetWindowedMarkupContext() : pParam->_pMarkup;
    if (_pMarkupContext)
        _pMarkupContext->SubAddRef();

    Assert(!_pMarkupContext || pParam->_pMarkup || pParam->_pElement);

    return _pMarkupContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\dimm.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module DIMM.CXX -- Handlers for Active IMM (component formerly known as Dynamic IMM)
 *
 *
 *  Owner: <nl>
 *      Ben Westbrook <nl>
 *      Chris Thrasher <nl>
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef NO_IME

#ifndef X_IMM_H_
#define X_IMM_H_
#include "imm.h"
#endif

#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif

DeclareTag(tagDIMM, "AIMM", "Tracking AIMM states");

static IActiveIMMApp * s_pActiveIMM;
const IID IID_IActiveIMMAppPostNT4 = {0xc839a84c, 0x8036, 0x11d3, {0x92, 0x70, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e}  };
//
// IEV6-23905-01/25/2000  ZhenbinX
// We call into AIMM1.2 directly on Win2000+ platforms
//
const CLSID CLSID_CActiveIMM12 = { 
    0xc1ee01f2,
    0xb3b6,
    0x4a6a,
    {0x9d, 0xdd, 0xe9, 0x88, 0xc0, 0x88, 0xec, 0x82}
  };

/* 50D5107A-D278-4871-8989-F4CEAAF59CFC */
const CLSID CLSID_CActiveIMM12_Trident = {
    0x50d5107a,
    0xd278,
    0x4871,
    {0x89, 0x89, 0xf4, 0xce, 0xaa, 0xf5, 0x9c, 0xfc}
   };



BOOL HasActiveIMM() { return s_pActiveIMM != NULL; }
IActiveIMMApp * GetActiveIMM() { return s_pActiveIMM; }

// returns TRUE iff plResult is set in lieu of call to DefWindowProc
BOOL DIMMHandleDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    if (HasActiveIMM())
    {
        if (GetActiveIMM()->OnDefWindowProc(hWnd, Msg, wParam, lParam, plResult) == S_OK)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT EnsureLoadedDIMM()
{
    static BOOL fFailedCoCreate = FALSE;
    HRESULT hr;

    if (HasActiveIMM())
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Already CoCreated [%x]", GetCurrentThreadId(), s_pActiveIMM));
        return S_OK;
    }

    // since the DIMM typically won't be installed on a system,
    // try to avoid constant calls to CoCreate
    if (fFailedCoCreate)
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Already failed to create AIMM before, simply bail out AIMM", GetCurrentThreadId()));
        return E_FAIL;
    }

    LOCK_GLOBALS;

    // Need to check again after locking globals.
    if (HasActiveIMM())
        return S_OK;

    if (   g_dwPlatformID != VER_PLATFORM_WIN32_NT
        || g_dwPlatformVersion < 0x00050000)
    {

        // mwatt changed the context from CLSCTX_INPROC_SERVER to CLSCTX_NO_CODE_DOWNLOAD
        // for Win2000 only.

        TraceTag((tagDIMM, "TID [%x] AIMM CoCreate CLSID_CActiveIMM, IID_IActiveIMMApp for platfroms other than Win2k+", GetCurrentThreadId()));
        hr = CoCreateInstance(CLSID_CActiveIMM, NULL, CLSCTX_INPROC_SERVER,
                              IID_IActiveIMMApp, (void**)&s_pActiveIMM);
    }
    else if (g_dwPlatformVersion == 0x00050000)     // Win2k - cicero wrapper layer
    {
        // 
        // IEV6-5013-2000/07/31/-zhenbinx:
        // CLSCTX_INPROC_SERVER has to be specified in any case! 
        //
        TraceTag((tagDIMM, "TID [%x] AIMM CoCreate CLSID_CActiveIMM, IID_IActiveIMMAppPostNT4 for Win2k", GetCurrentThreadId()));
        hr = CoCreateInstance(CLSID_CActiveIMM, NULL, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD,
                              IID_IActiveIMMAppPostNT4, (void**)&s_pActiveIMM);
        
    }
    else    // Whistler or above - talk to AIMM12 directly
    {
        TraceTag((tagDIMM, "TID [%x] AIMM CoCreate CLSID_CActiveIMM12, IID_IActiveIMMApp for Whistler+", GetCurrentThreadId()));
        hr = CoCreateInstance(CLSID_CActiveIMM12_Trident, NULL, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD,
                              IID_IActiveIMMApp, (void**)&s_pActiveIMM);
    }

    fFailedCoCreate = FAILED(hr);
#if DBG == 1
    if (fFailedCoCreate)
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Failed CoCreated with hr 0X%x", GetCurrentThreadId(), hr));
    }
    else
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Successfully CoCreated [%x]", GetCurrentThreadId(), s_pActiveIMM));
    }
#endif

    return hr;
}

HRESULT ActivateDIMM()
{
    if (FAILED(EnsureLoadedDIMM()))
        return E_FAIL;

    return GetActiveIMM()->Activate(TRUE);
}

HRESULT DeactivateDIMM()
{
    if (HasActiveIMM())
    {
        // NOTE: assuming here the correct thread is matching an original Begin() call.
        // Could add some debug code to tls to try to catch this....thinking not worth
        // the effort currently. (benwest)

        // Consider adding a cookie (threadid) to the interface if this becomes an issue?

        return GetActiveIMM()->Deactivate();
    }

    return E_FAIL;
}

HRESULT FilterClientWindowsDIMM(ATOM *aaWindowClasses, UINT uSize)
{
    if (FAILED(EnsureLoadedDIMM()))
    {
        return E_FAIL;
    }

    return GetActiveIMM()->FilterClientWindows(aaWindowClasses, uSize);
}

// Called during CServer shutdown, globals are already locked
void DeinitDIMM()
{
    ClearInterface(&s_pActiveIMM);
}

#endif // NO_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\domcoll.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DOMCOLL_HXX_
#define X_DOMCOLL_HXX_
#include "domcoll.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#define _cxx_
#include "domcoll.hdl"

MtDefine(CAttrCollectionator, ObjectModel, "CAttrCollectionator")
MtDefine(CAttrCollectionator_aryAttrDescs, CAttrCollectionator, "CAttrCollectionator::_aryAttrDescs")
MtDefine(CDOMChildrenCollectionGetNewEnum_pary, ObjectModel, "CDOMChildrenCollection::GetNewEnum pary")
MtDefine(CDOMChildrenCollectionGetNewEnum_pary_pv, ObjectModel, "CDOMChildrenCollection::GetNewEnum pary->_pv")
MtDefine(CAttrCollectionatorGetNewEnum_pary, ObjectModel, "CAttrCollectionator::GetNewEnum pary")
MtDefine(CAttrCollectionatorGetNewEnum_pary_pv, ObjectModel, "CAttrCollectionator::GetNewEnum pary->_pv")

MtDefine(CDOMChildrenCollection, ObjectModel, "CDOMChildrenCollection")

//+---------------------------------------------------------------
//
//  Member  : CAttrCollectionator::~CAttrCollectionator
//
//----------------------------------------------------------------

CAttrCollectionator::~CAttrCollectionator()
{
    Assert(_pElemColl);
    _pElemColl->FindAAIndexAndDelete(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, CAttrValue::AA_Internal);
    _pElemColl->Release();
}


//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAttrCollectionator::s_classdesc =
{
    &CLSID_HTMLAttributeCollection,   // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLAttributeCollection,  // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


HRESULT
CAttrCollectionator::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLAttributeCollection, NULL)
        QI_TEAROFF(this, IHTMLAttributeCollection2, NULL)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT
CAttrCollectionator::get_length(long *plLength)
{
    HRESULT hr = S_OK;

    if (!plLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *plLength = _aryAttrDescs.Size();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAttrCollectionator::EnsureCollection()
{
    HRESULT hr = S_OK;
    AttrDesc ad;
    DISPID startdispid = DISPID_STARTENUM;

    Assert(_pElemColl);
    CPtrBagVTableAggregate::CIterator vTableIterator(_pElemColl->GetStringTableAggregate());
        
    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(pPropDesc);
        
        ad._pPropdesc = pPropDesc;
        ad._dispid = pPropDesc->GetDispid();
        hr = THR(_aryAttrDescs.AppendIndirect(&ad));
        if (hr)
            goto Cleanup;
    }

    // Now store index, so we can directly access the expandos
    _lexpandoStartIndex = _aryAttrDescs.Size();

    // Now we fill in the dispids of the expandos
    ad._pPropdesc = NULL;
    while (hr != S_FALSE)
    {
        hr = THR(_pElemColl->GetNextDispIDExpando(startdispid, NULL, &ad._dispid));
        if (FAILED(hr))
            goto Cleanup;

        if (hr != S_FALSE)
        {
            Assert(_pElemColl->IsExpandoDISPID(ad._dispid));
            _aryAttrDescs.AppendIndirect(&ad);
        }
        
        startdispid = ad._dispid;
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT
CAttrCollectionator::item(VARIANT *pvarName, IDispatch **ppdisp)
{
    HRESULT   hr;
    CVariant  varArg;
    VARIANT   varDispatch;
    long      lIndex = 0;

    if (!ppdisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if ((V_VT(pvarName) != VT_ERROR) && (V_VT(pvarName) != VT_EMPTY))
    {
        // first attempt ordinal access...
        hr = THR(varArg.CoerceVariantArg(pvarName, VT_I4));
        if (hr==S_OK)
            lIndex = V_I4(&varArg);
        else
        {
            // not a number, try named access
            hr = THR_NOTRACE(varArg.CoerceVariantArg(pvarName, VT_BSTR));
            if (hr)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            else
            {
                // find the attribute with this name
                lIndex = FindByName((LPCTSTR)V_BSTR(&varArg));
            }
        }
    }

    // TODO(perf): can be optimized to combine FindByName and GetItem
    hr = THR(GetItem(lIndex, &varDispatch));
    if(hr == S_FALSE)
        hr = E_INVALIDARG;
    else
    {
        Assert(V_VT(&varDispatch) == VT_DISPATCH);
        *ppdisp = V_DISPATCH(&varDispatch);
    }
 
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttrCollectionator::GetItemAt(long lIndex, IDispatch **ppDisp)
{
    Assert(_pElemColl);

    HRESULT hr = S_OK;
    AAINDEX aaIdx;
    DISPID dispid = _aryAttrDescs[lIndex]._dispid;
    const PROPERTYDESC *pPropdesc = _aryAttrDescs[lIndex]._pPropdesc;
    CAttrArray *pAA = *(_pElemColl->GetAttrArray());
    CAttribute *pAttribute;
    LPCTSTR pchAttrName;

    Assert(dispid != DISPID_UNKNOWN);

    aaIdx = pAA->FindAAIndex(dispid, CAttrValue::AA_DOMAttribute);
    if (aaIdx == AA_IDX_UNKNOWN)
    {
        pAttribute = new CAttribute(pPropdesc, dispid, _pElemColl);
        if (!pAttribute)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (pPropdesc)
            pchAttrName = pPropdesc->pstrName;
        else
        {
            DISPID expDispid;
            IsExpandoDISPID(dispid, &expDispid);
            hr = THR(_pElemColl->GetExpandoName(expDispid, &pchAttrName));
            if (hr)
                goto Cleanup;
        }

        Assert(pchAttrName);
        hr = THR(pAttribute->_cstrName.Set(pchAttrName));
        if (hr)
            goto Cleanup;

        hr = THR(_pElemColl->AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttribute, CAttrValue::AA_DOMAttribute));
        pAttribute->Release();
        if (hr)
            goto Cleanup;
    }
    else
    {
        IUnknown *pUnk;
        hr = THR(_pElemColl->GetUnknownObjectAt(aaIdx, &pUnk));
        if (hr)
            goto Cleanup;

        pAttribute = (CAttribute *)pUnk;
        Assert(pAttribute);
        pAttribute->Release();
    }

    hr = THR(pAttribute->QueryInterface(IID_IDispatch, (void **)ppDisp));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

HRESULT
CAttrCollectionator::get__newEnum(IUnknown ** ppEnum)
{
    Assert(_pElemColl);

    HRESULT hr = S_OK;
    CPtrAry<LPUNKNOWN> *pary = NULL;
    long lSize;
    long l;
    IDispatch *pdisp;

    if (!ppEnum)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppEnum = NULL;

    pary = new(Mt(CAttrCollectionatorGetNewEnum_pary)) CPtrAry<LPUNKNOWN>(Mt(CAttrCollectionatorGetNewEnum_pary_pv));
    if (!pary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    lSize = _aryAttrDescs.Size();
    
    hr = THR(pary->EnsureSize(lSize));
    if (hr)
        goto Error;

    // Now make a snapshot of our collection.
    for (l = 0; l < lSize; ++l)
    {
        hr = THR(GetItemAt(l, &pdisp));
        if (hr)
            goto Error;

        hr = THR(pary->Append(pdisp));
        if (hr)
        {
            pdisp->Release();
            goto Error;
        }
    }

    // Turn the snapshot into an enumerator.
    hr = THR(pary->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **) ppEnum, FALSE, TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(SetErrorInfo(hr));

Error:
    pary->ReleaseAll();
    goto Cleanup;
}

long 
CAttrCollectionator::FindByName(LPCTSTR pszName, BOOL fCaseSensitive)
{
    HRESULT hr = S_OK;
    long  lIdx = 0;
    PROPERTYDESC *pPropDesc;
    DISPID dispid;
    long lloopindex;

    Assert(_pElemColl);
    pPropDesc = (PROPERTYDESC *)_pElemColl->FindPropDescForName(pszName, fCaseSensitive, &lIdx);

    if (pPropDesc)
        return lIdx;
    else
    {
        for (lloopindex = _lexpandoStartIndex; lloopindex < _aryAttrDescs.Size(); lloopindex++)
        {
            hr = THR(_pElemColl->GetExpandoDISPID((LPTSTR)pszName, &dispid, fCaseSensitive ? fdexNameCaseSensitive : 0));
            if (hr)
                goto Cleanup;

            if (dispid == _aryAttrDescs[lloopindex]._dispid)
                break;
        }

        if (lloopindex == _aryAttrDescs.Size())
            lloopindex = -1;

        return lloopindex;
    }

Cleanup:
    return -1;
}

LPCTSTR 
CAttrCollectionator::GetName(long lIdx)
{
    Assert(_pElemColl);

    LPCTSTR pch = NULL;
    DISPID dispid = _aryAttrDescs[lIdx]._dispid;
    const PROPERTYDESC *pPropdesc = _aryAttrDescs[lIdx]._pPropdesc;

    Assert(dispid != DISPID_UNKNOWN);
    
    if (pPropdesc)
        pch = pPropdesc->pstrExposedName ? pPropdesc->pstrExposedName : pPropdesc->pstrName;
    else
        IGNORE_HR(_pElemColl->GetExpandoName(dispid, &pch));

    return pch;        
}

HRESULT 
CAttrCollectionator::GetItem(long lIndex, VARIANT *pvar)
{
    Assert(_pElemColl);

    HRESULT hr = S_OK;

    if (lIndex < 0 || lIndex >= _aryAttrDescs.Size())
    {
        hr = S_FALSE;
        if (pvar)
            V_DISPATCH(pvar) = NULL;
        goto Cleanup;
    }

    if (!pvar)
    {
        // caller wanted only to check for correct range
        hr = S_OK;
        goto Cleanup;
    }

    V_VT(pvar) = VT_DISPATCH;
    hr = THR(GetItemAt(lIndex, &V_DISPATCH(pvar)));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT 
CAttrCollectionator::getNamedItem(BSTR bstrName, IHTMLDOMAttribute **ppAttribute)
{
    return _pElemColl->getAttributeNode(bstrName, ppAttribute);
}

HRESULT 
CAttrCollectionator::setNamedItem(IHTMLDOMAttribute *pAttrIn, IHTMLDOMAttribute **ppAttribute)
{
    return _pElemColl->setAttributeNode(pAttrIn, ppAttribute);
}

HRESULT 
CAttrCollectionator::removeNamedItem(BSTR bstrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;

    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    hr = THR(_pElemColl->RemoveAttributeNode(bstrName, ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CDOMChildrenCollection
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CDOMChildrenCollection::s_classdesc =
{
    &CLSID_DOMChildrenCollection,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLDOMChildrenCollection,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};


//+---------------------------------------------------------------
//
//  Member  : CDOMChildrenCollection::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------
HRESULT
CDOMChildrenCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLDOMChildrenCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CDOMChildrenCollection::item(long lIndex, IDispatch** ppResult)
{
    HRESULT     hr;
    VARIANT     varDispatch;

    if ( !ppResult )
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varDispatch));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varDispatch) == VT_DISPATCH);
    *ppResult = V_DISPATCH(&varDispatch);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CDOMChildrenCollection::get_length(long * plSize)
{
    HRESULT hr;
    if (!plSize)
        hr = E_INVALIDARG;
    else
    {
        *plSize = GetLength();
        hr = S_OK;
    }
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CDOMChildrenCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = E_INVALIDARG;
    CPtrAry<LPUNKNOWN> *pary = NULL;
    CElement *pElement;
    CObjectElement *pelObj = NULL;
    long lSize;
    long l;

    if (!_fIsElement)
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    if (!ppEnum)
        goto Cleanup;

    *ppEnum = NULL;

    pary = new(Mt(CDOMChildrenCollectionGetNewEnum_pary)) CPtrAry<LPUNKNOWN>(Mt(CDOMChildrenCollectionGetNewEnum_pary_pv));
    if (!pary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    lSize = GetLength();
    
    hr = THR(pary->EnsureSize(lSize));
    if (hr)
        goto Error;

    pElement = DYNCAST(CElement, _pOwner);
    if (pElement->Tag() == ETAG_OBJECT || pElement->Tag() == ETAG_APPLET)
    {
        pelObj = DYNCAST(CObjectElement, _pOwner);
    }

    // Now make a snapshot of our collection.
    for (l = 0; l < lSize; ++l)
    {
        IDispatch *pdisp;

        if (pelObj)
        {
            CParamElement *pelParam = pelObj->_aryParams[l];
            Assert(pelParam && pelParam->Tag() == ETAG_PARAM);
            Assert(pelParam->_pelObjParent == pelObj);
            hr = THR(pelParam->QueryInterface(IID_IDispatch, (void **)&pdisp));
        }
        else
            hr = THR(pElement->DOMWalkChildren(l, NULL, &pdisp));
    
        if (hr)
            goto Error;

        hr = THR(pary->Append(pdisp));
        if (hr)
        {
            pdisp->Release();
            goto Error;
        }
    }

    // Turn the snapshot into an enumerator.
    hr = THR(pary->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **) ppEnum, FALSE, TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(SetErrorInfo(hr));

Error:
    pary->ReleaseAll();
    goto Cleanup;
}

HRESULT 
CDOMChildrenCollection::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT     hr = S_OK;
    IDispatch **ppDisp;

    if ( lIndex < 0  )
        return E_INVALIDARG;

    if ( pvar )
        V_DISPATCH(pvar) = NULL;

    if ( _fIsElement )
    {
        // Pass through the NULL parameter correctly
        if (pvar)
            ppDisp = &V_DISPATCH(pvar);
        else
            ppDisp = NULL;

        CElement *pElement = DYNCAST(CElement, _pOwner);
        if (pElement->Tag() == ETAG_OBJECT || pElement->Tag() == ETAG_APPLET)
        {
            CObjectElement *pelObj = DYNCAST(CObjectElement, _pOwner);
            if (lIndex < pelObj->_aryParams.Size())
            {
                Assert(lIndex == pelObj->_aryParams[lIndex]->_idxParam);
                if (ppDisp)
                {
                    CParamElement *pelParam = pelObj->_aryParams[lIndex];
                    Assert(pelParam && pelParam->Tag() == ETAG_PARAM);
                    Assert(pelParam->_pelObjParent == pelObj);
                    hr = THR(pelParam->QueryInterface(IID_IDispatch, (void **)ppDisp));
                }
            }
            else
                hr = E_INVALIDARG;
        }
        else
            hr = THR(pElement->DOMWalkChildren(lIndex, NULL, ppDisp ));
    }
    else
        hr = E_INVALIDARG;

    if (!hr && pvar)
        V_VT(pvar) = VT_DISPATCH;

    RRETURN(hr);
}

HRESULT 
CDOMChildrenCollection::IsValidIndex ( long lIndex )
{
    return (lIndex >= 0 && lIndex < GetLength()) ? S_OK : S_FALSE;
}


long 
CDOMChildrenCollection::GetLength ( void )
{
    long lCount = 0;

    if ( _fIsElement )
    {
        CElement *pElement = DYNCAST(CElement, _pOwner);
        if (pElement->Tag() == ETAG_OBJECT || pElement->Tag() == ETAG_APPLET)
            lCount = DYNCAST(CObjectElement, _pOwner)->_aryParams.Size();
        else
            pElement->DOMWalkChildren ( -1, &lCount, NULL );
    }

    return lCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\intl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       intl.cxx
//
//  Contents:   Internationalization Support Functions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_MLANG_H_
#define X_MLANG_H_
#include <mlang.h>
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#undef WINCOMMCTRLAPI
#include <commctrl.h>
#endif

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

#ifndef X_WCHDEFS_H
#define X_WCHDEFS_H
#include <wchdefs.h>
#endif

#ifndef X_TXTDEFS_H
#define X_TXTDEFS_H
#include "txtdefs.h"
#endif

#include <inetreg.h>

//------------------------------------------------------------------------
//
//  Globals
//
//------------------------------------------------------------------------

PMIMECPINFO g_pcpInfo = NULL;
ULONG       g_ccpInfo = 0;
BOOL        g_cpInfoInitialized = FALSE;
TCHAR       g_szMore[32];

const TCHAR s_szCNumCpCache[] = TEXT("CNum_CpCache");
const TCHAR s_szCpCache[] = TEXT("CpCache");
const TCHAR s_szPathInternational[] = TEXT("\\International");

extern BYTE g_bUSPJitState;

#define BREAK_ITEM 20
#define CCPDEFAULT 1 // new spec: the real default is CP_ACP only

ULONG       CCachedCPInfo::_ccpInfo = CCPDEFAULT;
BOOL        CCachedCPInfo::_fCacheLoaded  = FALSE;
BOOL        CCachedCPInfo::_fCacheChanged = FALSE;
LPTSTR      CCachedCPInfo::_pchRegKey = NULL;
CPCACHE     CCachedCPInfo::_CpCache[5] = 
{
    {CP_ACP, 0, 0},
};

MtDefine(MimeCpInfo, PerProcess, "MIMECPINFO")
MtDefine(MimeCpInfoTemp, Locals, "MIMECPINFO_temp")
MtDefine(CpCache, PerProcess, "CpCache")
MtDefine(achKeyForCpCache, PerProcess, "achKeyForCpCache")

static struct {
    CODEPAGE cp;
    BYTE     bGDICharset;
} s_aryCpMap[] = {
    { CP_1252,  ANSI_CHARSET },
    { CP_1252,  SYMBOL_CHARSET },
#if !defined(WINCE)
    { CP_1250,  EASTEUROPE_CHARSET },
    { CP_1251,  RUSSIAN_CHARSET },
    { CP_1253,  GREEK_CHARSET },
    { CP_1254,  TURKISH_CHARSET },
    { CP_1255,  HEBREW_CHARSET },
    { CP_1256,  ARABIC_CHARSET },
    { CP_1257,  BALTIC_CHARSET },
    { CP_1258,  VIETNAMESE_CHARSET },
    { CP_THAI,  THAI_CHARSET },
#endif // !WINCE
    { CP_UTF_8, ANSI_CHARSET },
    { CP_ISO_8859_1, ANSI_CHARSET }
};

//+-----------------------------------------------------------------------
//
//  s_aryInternalCSetInfo
//
//  Note: This list is a small subset of the mlang list, used to avoid
//  loading mlang in certain cases.
//
//  *** There should be at least one entry in this list for each entry
//      in s_aryCpMap so that we can look up the name quickly. ***
//
//  NB (cthrash) List obtained from the following URL, courtesy of ChristW
//  http://iptdweb/intloc/internal/redmond/projects/ie4/charsets.htm
//
//------------------------------------------------------------------------

static const MIMECSETINFO s_aryInternalCSetInfo[] = {
    { CP_1252,  CP_ISO_8859_1,  _T("iso-8859-1") },
    { CP_1252,  CP_1252,  _T("windows-1252") },
    { NATIVE_UNICODE_CODEPAGE, CP_UTF_8, _T("utf-8") },
    { NATIVE_UNICODE_CODEPAGE, CP_UTF_8, _T("unicode-1-1-utf-8") },
    { NATIVE_UNICODE_CODEPAGE, CP_UTF_8, _T("unicode-2-0-utf-8") },
    { CP_1250,  CP_1250,  _T("windows-1250") },     // Eastern European windows
    { CP_1251,  CP_1251,  _T("windows-1251") },     // Cyrillic windows
    { CP_1253,  CP_1253,  _T("windows-1253") },     // Greek windows
    { CP_1254,  CP_1254,  _T("windows-1254") },     // Turkish windows
    { CP_1257,  CP_1257,  _T("windows-1257") },     // Baltic windows
    { CP_1258,  CP_1258,  _T("windows-1258") },     // Vietnamese windows
    { CP_1255,  CP_1255,  _T("windows-1255") },     // Hebrew windows
    { CP_1256,  CP_1256,  _T("windows-1256") },     // Arabic windows
    { CP_THAI,  CP_THAI,  _T("windows-874") },      // Thai Windows
};

//+-----------------------------------------------------------------------
//
//  g_aCPBitmapCPCharsetSid
//
//  CharSet Bitmap mapping to:
//  * codepage
//  * charset
//  * script ID
//
//------------------------------------------------------------------------

const CPBitmapCPCharsetSid g_aCPBitmapCPCharsetSid[g_nCPBitmapCount] = {
    { FS_JOHAB,         CP_1361,        JOHAB_CHARSET,          sidHangul   },
    { FS_CHINESETRAD,   CP_TWN,         CHINESEBIG5_CHARSET,    sidBopomofo },
    { FS_WANSUNG,       CP_KOR_5601,    HANGEUL_CHARSET,        sidHangul   },
    { FS_CHINESESIMP,   CP_CHN_GB,      GB2312_CHARSET,         sidHan      },
    { FS_JISJAPAN,      CP_JPN_SJ,      SHIFTJIS_CHARSET,       sidKana     },
    { FS_THAI,          CP_THAI,        THAI_CHARSET,           sidThai     },
    { FS_VIETNAMESE,    CP_1258,        VIETNAMESE_CHARSET,     sidLatin    },
    { FS_BALTIC,        CP_1257,        BALTIC_CHARSET,         sidLatin    },
    { FS_ARABIC,        CP_1256,        ARABIC_CHARSET,         sidArabic   },
    { FS_HEBREW,        CP_1255,        HEBREW_CHARSET,         sidHebrew   },
    { FS_TURKISH,       CP_1254,        TURKISH_CHARSET,        sidLatin    },
    { FS_GREEK,         CP_1253,        GREEK_CHARSET,          sidGreek    },
    { FS_CYRILLIC,      CP_1251,        RUSSIAN_CHARSET,        sidCyrillic },
    { FS_LATIN2,        CP_1250,        EASTEUROPE_CHARSET,     sidLatin    },
    { FS_LATIN1,        CP_1252,        ANSI_CHARSET,           sidLatin    }
};

const DWORD g_acpbitLang[LANG_NEPALI + 1] =
{
    /* LANG_NEUTRAL     0x00 */ 0,
    /* LANG_ARABIC      0x01 */ FS_ARABIC,
    /* LANG_BULGARIAN   0x02 */ FS_CYRILLIC,
    /* LANG_CATALAN     0x03 */ FS_LATIN1,
    /* LANG_CHINESE     0x04 */ (DWORD)-1,      // need to look at sublang id
    /* LANG_CZECH       0x05 */ FS_LATIN2,
    /* LANG_DANISH      0x06 */ FS_LATIN1,
    /* LANG_GERMAN      0x07 */ FS_LATIN1,
    /* LANG_GREEK       0x08 */ FS_GREEK,
    /* LANG_ENGLISH     0x09 */ FS_LATIN1,
    /* LANG_SPANISH     0x0a */ FS_LATIN1,
    /* LANG_FINNISH     0x0b */ FS_LATIN1,
    /* LANG_FRENCH      0x0c */ FS_LATIN1,
    /* LANG_HEBREW      0x0d */ FS_HEBREW,
    /* LANG_HUNGARIAN   0x0e */ FS_LATIN2,
    /* LANG_ICELANDIC   0x0f */ FS_LATIN1,
    /* LANG_ITALIAN     0x10 */ FS_LATIN1,
    /* LANG_JAPANESE    0x11 */ FS_JISJAPAN,
    /* LANG_KOREAN      0x12 */ (DWORD)-1,      // need to look at sublang id
    /* LANG_DUTCH       0x13 */ FS_LATIN1,
    /* LANG_NORWEGIAN   0x14 */ FS_LATIN1,
    /* LANG_POLISH      0x15 */ FS_LATIN2,
    /* LANG_PORTUGUESE  0x16 */ FS_LATIN1,
    /*                  0x17 */ 0,
    /* LANG_ROMANIAN    0x18 */ FS_LATIN2,
    /* LANG_RUSSIAN     0x19 */ FS_CYRILLIC,
    /* LANG_SERBIAN     0x1a */ (DWORD)-1,      // need to look at sublang id
    /* LANG_SLOVAK      0x1b */ FS_LATIN2,
    /* LANG_ALBANIAN    0x1c */ FS_LATIN2,
    /* LANG_SWEDISH     0x1d */ FS_LATIN1,
    /* LANG_THAI        0x1e */ FS_THAI,
    /* LANG_TURKISH     0x1f */ FS_TURKISH,
    /* LANG_URDU        0x20 */ FS_ARABIC,
    /* LANG_INDONESIAN  0x21 */ FS_LATIN1,
    /* LANG_UKRAINIAN   0x22 */ FS_CYRILLIC,
    /* LANG_BELARUSIAN  0x23 */ FS_CYRILLIC,
    /* LANG_SLOVENIAN   0x24 */ FS_LATIN2,
    /* LANG_ESTONIAN    0x25 */ FS_LATIN1,
    /* LANG_LATVIAN     0x26 */ FS_LATIN1,
    /* LANG_LITHUANIAN  0x27 */ FS_LATIN1,
    /*                  0x28 */ 0,
    /* LANG_FARSI       0x29 */ FS_ARABIC,
    /* LANG_VIETNAMESE  0x2a */ FS_VIETNAMESE,
    /* LANG_ARMENIAN    0x2b */ 0,              // FS_ shouldn't be used
    /* LANG_AZERI       0x2c */ (DWORD)-1,      // need to look at sublang id
    /* LANG_BASQUE      0x2d */ FS_LATIN1,
    /*                  0x2e */ 0,
    /* LANG_MACEDONIAN  0x2f */ FS_CYRILLIC,
    /* LANG_SUTU        0x30 */ FS_LATIN1,
    /*                  0x31 */ 0,
    /*                  0x32 */ 0,
    /*                  0x33 */ 0,
    /*                  0x34 */ 0,
    /*                  0x35 */ 0,
    /* LANG_AFRIKAANS   0x36 */ FS_LATIN1,
    /* LANG_GEORGIAN    0x37 */ 0,              // FS_ shouldn't be used
    /* LANG_FAEROESE    0x38 */ FS_LATIN1,
    /* LANG_HINDI       0x39 */ 0,              // FS_ shouldn't be used
    /*                  0x3a */ 0,
    /*                  0x3b */ 0,
    /*                  0x3c */ 0,
    /*                  0x3d */ 0,
    /* LANG_MALAY       0x3e */ FS_LATIN1,
    /* LANG_KAZAKH      0x3f */ FS_CYRILLIC,
    /*                  0x40 */ 0,
    /* LANG_SWAHILI     0x41 */ FS_LATIN1,
    /*                  0x42 */ 0,
    /* LANG_UZBEK       0x43 */ (DWORD)-1,      // need to look at sublang id
    /* LANG_TATAR       0x44 */ FS_CYRILLIC,
    /* LANG_BENGALI     0x45 */ 0,              // FS_ shouldn't be used
    /* LANG_PUNJABI     0x46 */ 0,              // FS_ shouldn't be used
    /* LANG_GUJARATI    0x47 */ 0,              // FS_ shouldn't be used
    /* LANG_ORIYA       0x48 */ 0,              // FS_ shouldn't be used
    /* LANG_TAMIL       0x49 */ 0,              // FS_ shouldn't be used
    /* LANG_TELUGU      0x4a */ 0,              // FS_ shouldn't be used
    /* LANG_KANNADA     0x4b */ 0,              // FS_ shouldn't be used
    /* LANG_MALAYALAM   0x4c */ 0,              // FS_ shouldn't be used
    /* LANG_ASSAMESE    0x4d */ 0,              // FS_ shouldn't be used
    /* LANG_MARATHI     0x4e */ 0,              // FS_ shouldn't be used
    /* LANG_SANSKRIT    0x4f */ 0,              // FS_ shouldn't be used
    /*                  0x50 */ 0,
    /*                  0x51 */ 0,
    /*                  0x52 */ 0,
    /*                  0x53 */ 0,
    /*                  0x54 */ 0,
    /* LANG_BURMESE     0x55 */ 0,              // FS_ shouldn't be used
    /*                  0x56 */ 0,
    /* LANG_KONKANI     0x57 */ 0,              // FS_ shouldn't be used
    /* LANG_MANIPURI    0x58 */ 0,              // FS_ shouldn't be used
    /* LANG_SINDHI      0x59 */ FS_ARABIC, 
    /*                  0x5a */ 0,
    /*                  0x5b */ 0,
    /*                  0x5c */ 0,
    /*                  0x5d */ 0,
    /*                  0x5e */ 0,
    /*                  0x5f */ 0,
    /* LANG_KASHMIRI    0x60 */ FS_ARABIC,
    /* LANG_NEPALI      0x61 */ 0               // FS_ shouldn't be used
};

//+-----------------------------------------------------------------------
//
//  Function:   IsPrimaryCodePage
//
//  Synopsis:   Return whether the structure in cpinfo represents the
//              'primary' codepage for a language.   Only primary codepages
//              are added, for example, to the language drop down menu.
//
//  Note:       Add special cases to pick primary codepage here.  In most
//              cases the comparison between the uiCodePage and
//              uiFamilyCodePage suffices.  HZ and Korean autodetect are 
//              other cases to consider.
//
//------------------------------------------------------------------------
inline UINT 
GetAutoDetectCp(PMIMECPINFO pcpinfo)
{
    UINT cpAuto;
    switch (pcpinfo->uiFamilyCodePage)
    {
        case CP_JPN_SJ:
           cpAuto = CP_AUTO_JP;
           break;
        default:
           cpAuto = CP_UNDEFINED;
           break;
    }
    return cpAuto;
}

inline BOOL 
IsPrimaryCodePage(MIMECPINFO *pcpinfo)
{
    UINT cpAuto = GetAutoDetectCp(pcpinfo);
    if (cpAuto != CP_UNDEFINED)
        return pcpinfo->uiCodePage == cpAuto;
    else
        return pcpinfo->uiCodePage == pcpinfo->uiFamilyCodePage;
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::RemoveInvalidCp
//  
//  Synopsis:   Clean up the last unsupported cp if it's there.
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::RemoveInvalidCp()
{
    for (UINT iCache = CCPDEFAULT; iCache < _ccpInfo; iCache++)
    {
        if (_CpCache[iCache].ulIdx == (ULONG)-1)
        {
            _ccpInfo--;
            if (_ccpInfo > iCache)
                memmove(&_CpCache[iCache], &_CpCache[iCache+1], sizeof(_CpCache[iCache])*(_ccpInfo-iCache));

            break;
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::InitCpCache
//  
//  Synopsis:   Initialize the cache with default codepages
//              which do not change through the session
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::InitCpCache(OPTIONSETTINGS *pOS, PMIMECPINFO pcp, ULONG ccp)
{
    UINT iCache, iCpInfo;

    
    if  (pcp &&  ccp > 0)
    {
        // load the existing setting from registry one time
        //
        LoadSetting(pOS);
        
        // clean up the last unsupport cp if it's there
        RemoveInvalidCp();
        
        // initialize the current setting including default
        for (iCache= 0; iCache < _ccpInfo; iCache++)
        {
            for (iCpInfo= 0; iCpInfo < ccp; iCpInfo++)
            {
                if ( pcp[iCpInfo].uiCodePage == _CpCache[iCache].cp )
                {
                    _CpCache[iCache].ulIdx = iCpInfo;

                    break;
                }   
            }
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::SaveCodePage
//  
//  Synopsis:   Cache the given codepage along with the index to
//              the given array of MIMECPINFO
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::SaveCodePage(UINT codepage, PMIMECPINFO pcp, ULONG ccp)
{
    int ccpSave = -1;
    BOOL bCached = FALSE;
    UINT i;

    // we'll ignore CP_AUTO, it's a toggle item on our menu
    if (codepage == CP_AUTO)
        return;

    // first check if we already have this cp
    for (i = 0; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cp == codepage)
        {
            ccpSave = i;
            bCached = TRUE;
            break;
        }
    }
    
    // if cache is not full, use the current
    // index to an entry
    if (ccpSave < 0  && _ccpInfo < ARRAY_SIZE(_CpCache))
    {
        ccpSave =  _ccpInfo;
    }

    //  otherwise, popout the least used entry. 
    //  the default codepages always stay
    //  this also decriments the usage count
    int cMinUsed = ARRAY_SIZE(_CpCache);
    UINT iMinUsed = 0; 
    for ( i = CCPDEFAULT; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cUsed > 0)
            _CpCache[i].cUsed--;
        
        if ( ccpSave < 0 && _CpCache[i].cUsed < cMinUsed)
        {
            cMinUsed =  _CpCache[i].cUsed;
            iMinUsed =  i;
        }
    }
    if (ccpSave < 0)
        ccpSave = iMinUsed; 
    
    // set initial usage count, which goes down to 0 if it doesn't get 
    // chosen twice in a row (with current array size)
    _CpCache[ccpSave].cUsed = ARRAY_SIZE(_CpCache)-1;
    
    // find a matching entry from given array of
    // mimecpinfo. Note that we always reassign the index
    // to the global array even when we've already had it 
    // in our cache because the index can be different 
    // after we jit-in a langpack
    //
    if (pcp &&  ccp > 0)
    {
        for (i= 0; i < ccp; i++)
        {
            if ( pcp[i].uiCodePage == codepage )
            {
                _CpCache[ccpSave].cp = codepage;
                _CpCache[ccpSave].ulIdx = i;

                break;
            }   
        }
    }
    
    if (!bCached)
    {
        _fCacheChanged = TRUE;
        if (_ccpInfo < ARRAY_SIZE(_CpCache))

            _ccpInfo++;

        // fallback case for non support codepages
        // we want have it on the tier1 menu but make
        // it disabled
        if ( i >= ccp )
        {
            _CpCache[ccpSave].cp = codepage;
            _CpCache[ccpSave].ulIdx = (ULONG)-1;
        }
    }
}

//------------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::SaveSetting
//  
//  Synopsis:   Writes out the current cache setting to registry
//              [REVIEW]
//              Can this be called from DeinitMultiLanguage?
//              Can we guarantee shlwapi is on memory there?
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::SaveSetting()
{
    UINT iCache;
    DWORD dwcbData, dwcNumCpCache;
    PUINT pcpCache;
    HRESULT hr;
    
    if (!_fCacheLoaded || !_fCacheChanged)
        goto Cleanup;

    RemoveInvalidCp();

    dwcNumCpCache = _ccpInfo-CCPDEFAULT; 
    
    dwcbData = sizeof(_CpCache[0].cp)*dwcNumCpCache; // DWORD for a terminator ?
    if (dwcNumCpCache > 0 && _pchRegKey)
    {
        pcpCache = (PUINT)MemAlloc(Mt(CpCache), dwcbData + sizeof (DWORD));
        if (pcpCache)
        {
            // Save the current num of cache
            hr =  SHSetValue(HKEY_CURRENT_USER, _pchRegKey, 
                       s_szCNumCpCache, REG_DWORD, (void *)&dwcNumCpCache, sizeof(dwcNumCpCache));

            if (hr == ERROR_SUCCESS)
            {
               // Save the current tier1 codepages
               for (iCache = 0; iCache <  dwcNumCpCache; iCache++)
                   pcpCache[iCache] = _CpCache[iCache+CCPDEFAULT].cp;
    
               IGNORE_HR(SHSetValue(HKEY_CURRENT_USER, _pchRegKey, 
                          s_szCpCache, REG_BINARY, (void *)pcpCache, dwcbData));
            }
            MemFree(pcpCache);
        }
    }
Cleanup:
    if (_pchRegKey)
    {
        MemFree(_pchRegKey);
        _pchRegKey = NULL;
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::LoadSetting
//  
//  Synopsis:   Reads cache setting from registry.
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::LoadSetting( OPTIONSETTINGS *pOS )
{
    UINT iCache;
    DWORD dwType, dwcbData, dwcNumCpCache;
    PUINT pcpCache;
    HRESULT hr;

    if (_fCacheLoaded)
        return;

    _ccpInfo = CCPDEFAULT;

    // load registry path from option settings
    if (_pchRegKey == NULL)
    {
        LPTSTR pchKeyRoot = pOS ? pOS->achKeyPath : TSZIEPATH;
        _pchRegKey = (LPTSTR)MemAlloc(Mt(achKeyForCpCache), 
                  (_tcslen(pchKeyRoot)+ARRAY_SIZE(s_szPathInternational)+1) * sizeof(TCHAR));
        if (!_pchRegKey)
            goto loaddefault;

        _tcscpy(_pchRegKey, pchKeyRoot);
        _tcscat(_pchRegKey, s_szPathInternational);
    }

    // first see if we have any entry 
    dwcbData = sizeof (dwcNumCpCache);
    hr =  SHGetValue(HKEY_CURRENT_USER, _pchRegKey, 
                   s_szCNumCpCache, &dwType, (void *)&dwcNumCpCache, &dwcbData);

    if (hr == ERROR_SUCCESS && dwcNumCpCache > 0)
    {
        if (dwcNumCpCache > ARRAY_SIZE(_CpCache)-CCPDEFAULT)
            dwcNumCpCache = ARRAY_SIZE(_CpCache)-CCPDEFAULT;
    
        dwcbData = sizeof(_CpCache[0].cp)*dwcNumCpCache; // DWORD for a terminator 
        pcpCache = (PUINT)MemAlloc(Mt(CpCache), dwcbData + sizeof (DWORD));
        if (pcpCache)
        {
            hr = THR(SHGetValue(HKEY_CURRENT_USER, _pchRegKey, 
                s_szCpCache, &dwType, (void *)pcpCache, &dwcbData));
                
            if (hr == ERROR_SUCCESS && dwType == REG_BINARY)
            {
                PUINT p = pcpCache;
                for (iCache=CCPDEFAULT; iCache < dwcNumCpCache+CCPDEFAULT; iCache++) 
                {
                    _CpCache[iCache].cp = *p;
                    _CpCache[iCache].cUsed = ARRAY_SIZE(_CpCache)-1;
                    p++;
                }
                _ccpInfo += dwcNumCpCache;
            }
            
            MemFree(pcpCache);
        }
    }
    
    // Load default entries that stay regardless of menu selection
    // Add ACP to the default entry of the cache
    //
loaddefault:
    MIMECPINFO mimeCpInfo;
    UINT       cpAuto;
    for (iCache = 0; iCache < CCPDEFAULT; iCache++)
    {
        _CpCache[iCache].cUsed = ARRAY_SIZE(_CpCache)-1;
        if (_CpCache[iCache].cp == CP_ACP )
            _CpCache[iCache].cp = GetACP();

        IGNORE_HR(QuickMimeGetCodePageInfo( _CpCache[iCache].cp, &mimeCpInfo ));
        
        cpAuto = GetAutoDetectCp(&mimeCpInfo);
        _CpCache[iCache].cp = (cpAuto != CP_UNDEFINED ? cpAuto : _CpCache[iCache].cp);
    }

    // this gets set even if we fail to read reg setting.
    _fCacheLoaded = TRUE;
}

//+-----------------------------------------------------------------------
//
//  Function:   EnsureCodePageInfo
//
//  Synopsis:   Hook up to mlang.  Note: it is not an error condition to
//              get back no codepage info structures from mlang.
//
//  IE5 JIT langpack support:
//              Now user can install fonts and nls files on the fly 
//              without restarting the session.
//              This means we always have to get real information
//              as to which codepage is valid and not.
//
//------------------------------------------------------------------------

HRESULT
EnsureCodePageInfo( BOOL fForceRefresh )
{
    if (g_cpInfoInitialized && !fForceRefresh)
        return S_OK;

    HRESULT         hr;
    UINT            cNum = 0;
    IEnumCodePage * pEnumCodePage = NULL;
    PMIMECPINFO     pcpInfo = NULL;
    ULONG           ccpInfo = 0;

    hr = THR(mlang().EnumCodePages(MIMECONTF_BROWSER, &pEnumCodePage));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(mlang().GetNumberOfCodePageInfo(&cNum));
    if (S_OK != hr)
        goto Cleanup;

    if (cNum > 0)
    {
        pcpInfo = (PMIMECPINFO)MemAlloc(Mt(MimeCpInfo), sizeof(MIMECPINFO) * (cNum));
        if (!pcpInfo)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = THR(pEnumCodePage->Next(cNum, pcpInfo, &ccpInfo));
        if (hr)
            goto Cleanup;

        if (ccpInfo > 0)
        {
            IGNORE_HR(MemRealloc(Mt(MimeCpInfo), (void **)&pcpInfo, sizeof(MIMECPINFO) * (ccpInfo)));
        }
        else
        {
            MemFree(pcpInfo);
            pcpInfo = NULL;
        }
    }

Cleanup:
    {
        LOCK_GLOBALS;

        if (S_OK == hr)
        {
            if (g_pcpInfo)
            {
                MemFree(g_pcpInfo);
            }

            g_pcpInfo = pcpInfo;
            g_ccpInfo = ccpInfo;
        }
        else if (pcpInfo)
        {
            MemFree(pcpInfo);
            pcpInfo = NULL;
        }

        // If any part of the initialization fails, we do not want to keep
        // returning this function, unless, of course, fForceRefresh is true.

        g_cpInfoInitialized = TRUE;
    }

    ReleaseInterface(pEnumCodePage);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Function:   DeinitMultiLanguage
//
//  Synopsis:   Detach from mlang.  Called from DllAllThreadsDetach.
//              Globals are locked during the call.
//
//------------------------------------------------------------------------

void
DeinitMultiLanguage()
{
    CCachedCPInfo::SaveSetting(); // [review] can this be dengerous? [yutakan]
    MemFree(g_pcpInfo);
    g_cpInfoInitialized = FALSE;
    g_pcpInfo = NULL;
    g_ccpInfo = 0;

    mlang().Unload();
}

//+-----------------------------------------------------------------------
//
//  Function:   QuickMimeGetCodePageInfo
//
//  Synopsis:   This function gets cp info from mlang, but caches some
//              values to avoid loading mlang unless necessary.
//
//------------------------------------------------------------------------

HRESULT
QuickMimeGetCodePageInfo(CODEPAGE cp, PMIMECPINFO pMimeCpInfo)
{
    HRESULT hr = S_OK;
    static MIMECPINFO s_mimeCpInfoBlank = {
        0, 0, 0, _T(""), _T(""), _T(""), _T(""),
        _T("Courier New"), _T("Arial"), DEFAULT_CHARSET
    };

    // If mlang is not loaded and it is acceptable to use our defaults,
    //  try to avoid loading it by searching through our internal
    //  cache.
    for (int n = 0; n < ARRAY_SIZE(s_aryCpMap); ++n)
    {
        if (cp == s_aryCpMap[n].cp)
        {
            // Search for the name in the cset array
            for (int j = 0; j < ARRAY_SIZE(s_aryInternalCSetInfo); ++j)
            {
                if (cp == s_aryInternalCSetInfo[j].uiInternetEncoding)
                {
                    memcpy(pMimeCpInfo, &s_mimeCpInfoBlank, sizeof(MIMECPINFO));
                    pMimeCpInfo->uiCodePage = pMimeCpInfo->uiFamilyCodePage = s_aryCpMap[n].cp;
                    pMimeCpInfo->bGDICharset = s_aryCpMap[n].bGDICharset;
                    _tcscpy(pMimeCpInfo->wszWebCharset, s_aryInternalCSetInfo[j].wszCharset);
                    goto Cleanup;
                }
            }
        }
    }

    hr = THR(mlang().GetCodePageInfo(cp, MLGetUILanguage(), pMimeCpInfo));
    if (S_OK != hr)
        goto Error;

Cleanup:
    return hr;

Error:
    // Could not load mlang, fill in with a default but return the error
    memcpy(pMimeCpInfo, &s_mimeCpInfoBlank, sizeof(MIMECPINFO));
    goto Cleanup;
}


#ifndef NO_MULTILANG
//+-----------------------------------------------------------------------
//
//  Function:   QuickMimeGetCharsetInfo
//
//  Synopsis:   This function gets charset info from mlang, but caches some
//              values to avoid loading mlang unless necessary.
//
//------------------------------------------------------------------------

HRESULT
QuickMimeGetCharsetInfo(LPCTSTR lpszCharset, PMIMECSETINFO pMimeCSetInfo)
{

    // If mlang is not loaded and it is acceptable to use our defaults,
    //  try to avoid loading it by searching through our internal
    //  cache.
    for (int n = 0; n < ARRAY_SIZE(s_aryInternalCSetInfo); ++n)
    {
        if (_tcsicmp((TCHAR*)lpszCharset, s_aryInternalCSetInfo[n].wszCharset) == 0)
        {
            *pMimeCSetInfo = s_aryInternalCSetInfo[n];
            return S_OK;
        }
    }

    HRESULT hr = THR(mlang().GetCharsetInfo((LPTSTR)lpszCharset, pMimeCSetInfo));
    return hr;
}
#endif // !NO_MULTILANG

//+-----------------------------------------------------------------------
//
//  Function:   GetCodePageFromMlangString
//
//  Synopsis:   Return a codepage id from an mlang codepage string.
//
//------------------------------------------------------------------------

HRESULT
GetCodePageFromMlangString(LPCTSTR pszMlangString, CODEPAGE* pCodePage)
{
#ifdef NO_MULTILANG
    return E_NOTIMPL;
#else
    HRESULT hr;
    MIMECSETINFO mimeCharsetInfo;

    hr = QuickMimeGetCharsetInfo(pszMlangString, &mimeCharsetInfo);
    if (hr)
    {
        hr = E_INVALIDARG;
        *pCodePage = CP_UNDEFINED;
    }
    else
    {
        *pCodePage = mimeCharsetInfo.uiInternetEncoding;
    }

    return hr;
#endif
}

//+-----------------------------------------------------------------------
//
//  Function:   GetMlangStringFromCodePage
//
//  Synopsis:   Return an mlang codepage string from a codepage id.
//
//------------------------------------------------------------------------

HRESULT
GetMlangStringFromCodePage(CODEPAGE codepage, LPTSTR pMlangStringRet,
                           size_t cchMlangString)
{
    HRESULT    hr;
    MIMECPINFO mimeCpInfo;
    TCHAR*     pCpString = _T("<undefined-cp>");
    size_t     cchCopy;

    Assert(codepage != CP_ACP);

    hr = QuickMimeGetCodePageInfo(codepage, &mimeCpInfo);
    if (hr == S_OK)
    {
        pCpString = mimeCpInfo.wszWebCharset;
    }

    cchCopy = min(cchMlangString-1, _tcslen(pCpString));
    _tcsncpy(pMlangStringRet, pCpString, cchCopy);
    pMlangStringRet[cchCopy] = 0;

    return hr;
}

#ifndef NO_MULTILANG
//+-----------------------------------------------------------------------
//
//  Function:   CheckEncodingMenu
//
//  Synopsis:   Given a mime charset menu, check the specified codepage.
//
//------------------------------------------------------------------------

void
CheckEncodingMenu(CODEPAGE codepage, HMENU hMenu, BOOL fAutoMode)
{
    ULONG i;

    IGNORE_HR(EnsureCodePageInfo(FALSE));

    Assert(codepage != CP_ACP);

    if (1 < g_ccpInfo)
    {
        MIMECPINFO mimeCpInfo;

        LOCK_GLOBALS;
        
        IGNORE_HR(QuickMimeGetCodePageInfo( codepage, &mimeCpInfo ));
        
        // find index to our cache
        for(i = 0; i < CCachedCPInfo::GetCcp() && codepage != CCachedCPInfo::GetCodePage(i); i++)
            ;

        if (i >= CCachedCPInfo::GetCcp())
        {
            // the codepage is not on the tier1 menu
            // put a button to the tier2 menu if possible
            LOCK_GLOBALS;
            for (i = 0;  i < g_ccpInfo;  i++)
            {
                if (g_pcpInfo[i].uiCodePage == codepage)
                {
                    // IDM_MIMECSET__LAST__-1 is now temporarily
                    // assigned to CP_AUTO
                    CheckMenuRadioItem(hMenu, 
                                       IDM_MIMECSET__FIRST__, IDM_MIMECSET__LAST__-1, 
                                       i + IDM_MIMECSET__FIRST__,
                                       MF_BYCOMMAND);
                    break;
                }
            }
        }
        else
        {
#ifndef UNIX // Unix doesn't support AutoDetect
            UINT uiPos = CCachedCPInfo::GetCcp() + 2 - 1 ; 
#else
            UINT uiPos = CCachedCPInfo::GetCcp() - 1 ; 
#endif
            ULONG uMenuId = CCachedCPInfo::GetMenuIdx(i);
            UINT uidItem;

            // the menuid is -1 if this is the one not available for browser
            // we have to put a radiobutton by position for that case.
            // 
            uMenuId = uMenuId == (ULONG)-1 ? uMenuId : uMenuId + IDM_MIMECSET__FIRST__;
           
#ifndef UNIX // Unix uiPos == 0 isn't AutoDetect 
            while (uiPos > 0)
#else
            while (uiPos >= 0)
#endif
            {
                // On Win95, GetMenuItemID can't return (ULONG)-1
                // so we use lower word only
                uidItem = GetMenuItemID(hMenu, uiPos);
                if ( LOWORD(uidItem) == LOWORD(uMenuId) )
                {
                    CheckMenuRadioItem(
                        hMenu, 
#ifndef UNIX // No AutoDetect for UNIX
                        1, CCachedCPInfo::GetCcp() + 2 - 1, // +2 for cp_auto -1 for 0 based
#else
                        0, CCachedCPInfo::GetCcp() - 1, // +2 for cp_auto -1 for 0 based
#endif
                        uiPos,
                        MF_BYPOSITION );

                    break; 
                }
                uiPos--;
            }
        }
    }
#ifndef UNIX // Unix doesn't support AutoDetect
    // then lastly, we put check mark for the auto detect mode
    // the AutoDetect item is always at pos 0
    CheckMenuItem(hMenu, 0, fAutoMode?
                            (MF_BYPOSITION|MF_CHECKED) :
                            (MF_BYPOSITION|MF_UNCHECKED) );
#endif
}

//+-----------------------------------------------------------------------
//
//  Function:   CheckFontMenu
//
//  Synopsis:   Given a font menu, check the specified font size.
//
//------------------------------------------------------------------------

void
CheckFontMenu(short sFontSize, HMENU hMenu)
{
    CheckMenuRadioItem(hMenu, IDM_BASELINEFONT1, IDM_BASELINEFONT5, 
                       sFontSize - BASELINEFONTMIN + IDM_BASELINEFONT1, MF_BYCOMMAND);
}

//+-----------------------------------------------------------------------
//
//  Function:   CheckMenuCharSet
//
//  Synopsis:   Assuming hMenu has both encoding/font size
//              this puts checks marks on it based on the given
//              codepage and font size
//
//------------------------------------------------------------------------

void 
CheckMenuMimeCharSet(CODEPAGE codepage, short sFontSize, HMENU hMenuLang, BOOL fAutoMode)
{
    CheckEncodingMenu(codepage, hMenuLang, fAutoMode);
    CheckFontMenu(sFontSize, hMenuLang);
}
#endif

//+-----------------------------------------------------------------------
//
//  Function:   CreateMimeCSetMenu
//
//  Synopsis:   Create the mime charset menu.  Can return an empty menu.
//
//------------------------------------------------------------------------

HMENU
CreateMimeCSetMenu(OPTIONSETTINGS *pOS, CODEPAGE cp)
{
    BOOL fBroken = FALSE;
    
    HMENU hMenu = CreatePopupMenu();

    IGNORE_HR(EnsureCodePageInfo(TRUE));

    if (hMenu && 0 < g_ccpInfo)
    {
        MIMECPINFO mimeCpInfo;

        Assert(g_pcpInfo);
        LOCK_GLOBALS;
       
#ifndef UNIX // Unix doesn't have Auto Detect 
        // always add the 'Auto Detect' entry
        // get the description from mlang
        // the id needs to be special - IDM_MIMECSET__LAST__
        // is fairly unique because there are 90 codepages to
        // have between FIRST and LAST
        IGNORE_HR(QuickMimeGetCodePageInfo( CP_AUTO, &mimeCpInfo ));
        AppendMenu(hMenu, MF_ENABLED, IDM_MIMECSET__LAST__, mimeCpInfo.wszDescription);
        
        // Also add a separator
        AppendMenu(hMenu, MF_SEPARATOR, 0, 0);
        // add the tier 1 entries to the first
        // level popup menu
#endif // UNIX

        ULONG i;
        ULONG iMenuIdx;

        CCachedCPInfo::InitCpCache(pOS, g_pcpInfo, g_ccpInfo);
        
        // Cache an autodetect codepage if it's available
        // for the given codepage
        // note that we have "AutoSelect"(CP_AUTO) for character set 
        // detection across whole codepages, and at the same time
        // "AutoDetect" within A codepage, such as JPAUTO (50932)
        // CP_AUTO is added to the menu as toggle item, so
        // we'll ignore it at SaveCodePage(), should it come down here
        //
        IGNORE_HR(QuickMimeGetCodePageInfo( cp, &mimeCpInfo ));
        UINT cpAuto = GetAutoDetectCp(&mimeCpInfo);
        
        if (cpAuto != CP_UNDEFINED)
            CCachedCPInfo::SaveCodePage(cpAuto, g_pcpInfo, g_ccpInfo);

        CCachedCPInfo::SaveCodePage(cp, g_pcpInfo, g_ccpInfo);

        for(i = 0; i < CCachedCPInfo::GetCcp(); i++)
        {
            iMenuIdx = CCachedCPInfo::GetMenuIdx(i);

            if (iMenuIdx == (ULONG)-1)
            {
                // the codepage is either not supported or 
                // not for browser. We need to add it to the
                // tier1 menu and make it disabled
                if (SUCCEEDED(QuickMimeGetCodePageInfo(CCachedCPInfo::GetCodePage(i), &mimeCpInfo)))
                {
                    AppendMenu(hMenu, MF_GRAYED, iMenuIdx, // == -1
                               mimeCpInfo.wszDescription);
                }
            }
            else
            {
                AppendMenu(hMenu, MF_ENABLED, iMenuIdx+IDM_MIMECSET__FIRST__,
                    g_pcpInfo[iMenuIdx].wszDescription);

                // mark the cp entry so we can skip it for submenu
                // this assumes we'd never use the MSB for MIMECONTF
                g_pcpInfo[iMenuIdx].dwFlags |= 0x80000000;
            }
        } 
        
        // add the submenu for the rest of encodings
        HMENU hSubMenu = CreatePopupMenu();
        UINT  uiLastFamilyCp = 0;
        if (hSubMenu)
        {
            // calculate the max # of menuitem we can show in one monitor
            unsigned int iMenuY, iScrY, iBreakItem, iItemAdded = 0;
            NONCLIENTMETRICSA ncma;
            HRESULT hr;
            
            if (g_dwPlatformVersion < 0x050000)
            {
                // Use systemparametersinfoA so it won't fail on w95
                // TODO (IE6 track bug 19) shlwapi W wrap should support this
                ncma.cbSize = sizeof(ncma);
                SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncma), &ncma, FALSE);
                iMenuY = ncma.lfMenuFont.lfHeight > 0 ? 
                         ncma.lfMenuFont.lfHeight: -ncma.lfMenuFont.lfHeight;
                iScrY  = GetSystemMetrics(SM_CYSCREEN);

                if ( iScrY > 0 && iMenuY > 0) 
                    iBreakItem = (iScrY + iMenuY - 1) / iMenuY; // round up
                else
                    iBreakItem = BREAK_ITEM; // a fallback
            }
            else // NT5 has nice auto menu scroll so let's not break
                iBreakItem = (UINT)-1;
                
            for (i = 0;  i < g_ccpInfo;  i++)
            {
                // skip codepages that are on teir1 menu
                // skip also Auto Select
                if (!(g_pcpInfo[i].dwFlags & 0x80000000)
                    && g_pcpInfo[i].uiCodePage != CP_AUTO
#ifdef UNIX // filter out Thai and Vietnamese
                    && g_pcpInfo[i].uiCodePage != CP_THAI
                    && g_pcpInfo[i].uiCodePage != CP_1258 // Vietnamese
                    && g_pcpInfo[i].uiCodePage != CP_1257 // Baltic
                    && g_pcpInfo[i].uiCodePage != CP_1256 // Arabic
#endif
                    )
                {
                    // if the codepage is not yet installed, 
                    // we show the primary codepage only
                    //
                    // we only see if the primary cp is valid, 
                    // then make the entire family shown without checking 
                    // if they're valid. this is for the case that just
                    // part of langpack (nls/font) is installed.
                    // this may need some more tweak after usability check

                    // Actually now we've decided to hide the menu items if
                    // the encodings are neither valid or installable
                    //

                    if (S_OK != THR(mlang().IsCodePageInstallable(g_pcpInfo[i].uiCodePage)))
                        continue;
                    
                    // we need to call the slow version that invokes mlang
                    // because quick version wouldn't set valid flags.
                    hr = THR(mlang().GetCodePageInfo(g_pcpInfo[i].uiFamilyCodePage, MLGetUILanguage(), &mimeCpInfo));
                    
                    if (   S_OK == hr
                        && (mimeCpInfo.dwFlags & MIMECONTF_VALID)
                        || IsPrimaryCodePage(g_pcpInfo+i))
                    {
                        UINT uiFlags = MF_ENABLED;

                        TCHAR wszDescription[ARRAY_SIZE(g_pcpInfo[0].wszDescription)];
                        _tcscpy(wszDescription, g_pcpInfo[i].wszDescription);

                        if (!(g_pcpInfo[i].dwFlags & MIMECONTF_VALID))
                        {
                            if (IsPrimaryCodePage(g_pcpInfo+i))
                            {
                                // this codepage will be added as a place holder
                                // let's rip out the detail to make it general
                                LPTSTR psz = StrChr(wszDescription, TEXT('('));
                                if (psz)
                                    *psz = TEXT('\0');        
                            }
                            else if (g_pcpInfo[i].uiCodePage == CP_GB_18030)
                            {
                                // Hide GB 18030 if it is not installed
                                continue;
                            }
                        }

                        if (uiLastFamilyCp > 0 
                        && uiLastFamilyCp != g_pcpInfo[i].uiFamilyCodePage)
                        {
                            // add separater between different family unless
                            // we will be adding the menu bar break
                            if(iItemAdded < iBreakItem || fBroken)
                            {
                                AppendMenu(hSubMenu, MF_SEPARATOR, 0, 0);
                                iItemAdded++;
                            }
                            else
                            {
                                // This menu gets really long. Let's break it so all
                                // fit on the screen
                                uiFlags |= MF_MENUBARBREAK;
                                fBroken = TRUE;
                            }
                        }
                        
                        AppendMenu(hSubMenu, 
                                   uiFlags, 
                                   i+IDM_MIMECSET__FIRST__,
                                   wszDescription);
                        iItemAdded++;

                        // save the family of added codepage
                        uiLastFamilyCp = g_pcpInfo[i].uiFamilyCodePage;
                    }
                }
                else
                    g_pcpInfo[i].dwFlags &= 0x7FFFFFFF;

            }

            // add this submenu to the last of tier1 menu
            if (!g_szMore[0])
            {
                Verify(LoadString( GetResourceHInst(), 
                                   RES_STRING_ENCODING_MORE,
                                   g_szMore,
                                   ARRAY_SIZE(g_szMore)));
            }
            if (GetMenuItemCount(hSubMenu) > 0)
            {
                AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hSubMenu, g_szMore);
            }
            else
            {
                DestroyMenu(hSubMenu);
            }
        }
    }
    return hMenu;
}

#ifndef NO_MULTILANG
//+-----------------------------------------------------------------------
//
//  Function:   CreateDocDirMenu
//
//  Synopsis:   Add document direction menu into mime charset menu.
//
//------------------------------------------------------------------------

HMENU
CreateDocDirMenu(BOOL fDocRTL, HMENU hMenuTarget)
{
    HMENU hMenu;
    hMenu = TFAIL_NOTRACE(0, LoadMenu(
                          GetResourceHInst(),
                          MAKEINTRESOURCE(IDR_HTMLFORM_DOCDIR)));

    if(hMenu != NULL)
    {

        int nItem = GetMenuItemCount(hMenu);

        if (0 < nItem)
        {
            if(hMenuTarget)
            {
                // append the menu at the bottom
                InsertMenu(hMenuTarget, 0xFFFFFFFF, MF_SEPARATOR | MF_BYPOSITION, 0, 0);
            }

            int nCheckItem= 0;

            for (int i = 0; i < nItem; i++)
            {
                UINT uiID;
                UINT uChecked = MF_BYCOMMAND | MF_ENABLED;
                TCHAR szBuf[MAX_MIMECP_NAME];

                uiID = GetMenuItemID(hMenu, i);
                GetMenuString(hMenu, i, szBuf, ARRAY_SIZE(szBuf), MF_BYPOSITION);

                if((uiID == IDM_DIRRTL) ^ (!fDocRTL))  
                    nCheckItem = i;
     
                if(hMenuTarget)
                {
                    InsertMenu(hMenuTarget, 0xFFFFFFFF, uChecked | MF_STRING, uiID, szBuf);
                }
            }
            if(hMenuTarget)
            {
                CheckMenuRadioItem(hMenuTarget, IDM_DIRLTR, IDM_DIRRTL, 
                                   IDM_DIRLTR + nCheckItem, MF_BYCOMMAND);
            }
            else
            {
                CheckMenuRadioItem(hMenu, IDM_DIRLTR, IDM_DIRRTL, 
                                   IDM_DIRLTR + nCheckItem, MF_BYCOMMAND);
            }
        }
    }
    if(hMenuTarget)
    {
        if(hMenu)
            DestroyMenu(hMenu);
        return NULL;
    }
    else
    {
        return hMenu;
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   AddFontSizeMenu
//
//  Synopsis:   Add font size menu into mime charset menu.
//
//------------------------------------------------------------------------

void
AddFontSizeMenu(HMENU hMenu)
{
    if (NULL != hMenu)
    {
        HMENU hMenuRes = TFAIL_NOTRACE(0, LoadMenu(
                GetResourceHInst(),
                MAKEINTRESOURCE(IDR_HTMLFORM_MENURUN)));

        if (NULL != hMenuRes)
        {
            HMENU hMenuView = GetSubMenu(hMenuRes, 1);
            HMENU hMenuFont = GetSubMenu(hMenuView, 3);
            int nItem = GetMenuItemCount(hMenuFont);

            if (0 < nItem)
            {
                for (int i = nItem - 1; i >= 0; i--)
                {
                    UINT uiID;
                    TCHAR szBuf[MAX_MIMECP_NAME];

                    uiID = GetMenuItemID(hMenuFont, i);
                    GetMenuString(hMenuFont, i, szBuf, ARRAY_SIZE(szBuf), MF_BYPOSITION);
                    InsertMenu(hMenu, 0, MF_STRING | MF_BYPOSITION, uiID, szBuf);
                }
            }
            DestroyMenu(hMenuRes);
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CreateFontSizeMenu
//
//  Synopsis:   Creates font size menu.
//
//------------------------------------------------------------------------

HMENU
CreateFontSizeMenu()
{
    HMENU hMenuFontSize = CreatePopupMenu();
    
    AddFontSizeMenu(hMenuFontSize);
    return hMenuFontSize;
}

//+-----------------------------------------------------------------------
//
//  Function:   ShowMimeCSetMenu
//
//  Synopsis:   Display the mime charset menu.
//
//------------------------------------------------------------------------

HRESULT
ShowMimeCSetMenu(OPTIONSETTINGS *pOS, int * pnIdm, CODEPAGE codepage, LPARAM lParam, BOOL fDocRTL, BOOL fAutoMode)
{
    HMENU hMenuEncoding = NULL;
    HRESULT hr = E_FAIL;

    Assert(NULL != pnIdm);

    hMenuEncoding = CreateMimeCSetMenu(pOS, codepage);
    if (NULL != hMenuEncoding)
    {
        POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

        CheckEncodingMenu(codepage, hMenuEncoding, fAutoMode);

        GetOrAppendDocDirMenu(codepage, fDocRTL, hMenuEncoding);

        hr = FormsTrackPopupMenu(hMenuEncoding, TPM_LEFTALIGN, pt.x, pt.y, NULL, pnIdm);
        DestroyMenu(hMenuEncoding);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:   ShowFontSizeMenu
//
//  Synopsis:   Display the font size menu.
//
//------------------------------------------------------------------------

HRESULT
ShowFontSizeMenu(int * pnIdm, short sFontSize, LPARAM lParam)
{
    HMENU hMenuFont = NULL;
    HRESULT hr = E_FAIL;

    Assert(NULL != pnIdm);

    hMenuFont = CreateFontSizeMenu();
    if (NULL != hMenuFont)
    {
        POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

        CheckFontMenu(sFontSize, hMenuFont);

        hr = FormsTrackPopupMenu(hMenuFont, TPM_LEFTALIGN, pt.x, pt.y, NULL, pnIdm);

        DestroyMenu(hMenuFont);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:   GetEncodingMenu
//
//  Synopsis:   Return the mime charset menu handle.
//
//------------------------------------------------------------------------

HMENU
GetEncodingMenu(OPTIONSETTINGS *pOS, CODEPAGE codepage, BOOL fDocRTL, BOOL fAutoMode)
{
    HMENU hMenuEncoding = CreateMimeCSetMenu(pOS, codepage);
    if (NULL != hMenuEncoding)
    {
        CheckEncodingMenu(codepage, hMenuEncoding, fAutoMode);

        GetOrAppendDocDirMenu(codepage, fDocRTL, hMenuEncoding);
    }
    
    return hMenuEncoding;
}

//+-----------------------------------------------------------------------
//
//  Function:   GetOrAppendDocDirMenu
//
//  Synopsis:   Return the document direction menu handle.
//              or append it to a given menu handle.
//
//------------------------------------------------------------------------

HMENU
GetOrAppendDocDirMenu(CODEPAGE codepage, BOOL fDocRTL, HMENU hMenuTarget)
{
    HMENU hMenuDocDir = NULL;

    // put up the document dir menu only if it is likely to have
    // right-to-left
    if(g_fBidiSupport || IsRTLCodepage(codepage))
    {
        hMenuDocDir = CreateDocDirMenu(fDocRTL, hMenuTarget);
    }
    return  hMenuDocDir;
}

//+-----------------------------------------------------------------------
//
//  Function:   GetFontSizeMenu
//
//  Synopsis:   Retrun the FontSize menu handle
//
//------------------------------------------------------------------------

HMENU
GetFontSizeMenu(short sFontSize)
{
    HMENU hMenuFontSize = CreateFontSizeMenu();
    if (NULL != hMenuFontSize)
    {
        CheckFontMenu(sFontSize, hMenuFontSize);
    }
    
    return hMenuFontSize;
}
#endif // ndef NO_MULTILANG

//+-----------------------------------------------------------------------
//
//  Function:   GetCodePageFromMenuID
//
//  Synopsis:   Given a menu id return the associated codepage.
//
//------------------------------------------------------------------------

CODEPAGE
GetCodePageFromMenuID(int nIdm)
{
    UINT idx = nIdm - IDM_MIMECSET__FIRST__;

    IGNORE_HR(EnsureCodePageInfo(FALSE));

    LOCK_GLOBALS;

    if (NULL != g_pcpInfo && idx < g_ccpInfo)
        return g_pcpInfo[idx].uiCodePage;
    return CP_UNDEFINED;
}

//+-----------------------------------------------------------------------
//
//  Function:   WindowsCodePageFromCodePage
//
//  Synopsis:   Return a Windows codepage from an mlang CODEPAGE
//
//------------------------------------------------------------------------

UINT
WindowsCodePageFromCodePage( CODEPAGE cp )
{
    Assert(cp != CP_UNDEFINED);

    if (cp == CP_AUTO)
    {
        // cp 50001 (CP_AUTO)is designated to cross-language detection,
        // it really should not come in here but we'd return the default 
        // code page.
        return g_cpDefault;
    }
    else if (IsLatin1Codepage(cp))
    {
        return CP_1252; // short-circuit most common case
    }
    else if (IsStraightToUnicodeCodePage(cp))
    {
        return CP_UCS_2; // TODO (cthrash, IE6 track bug 17) Should be NATIVE_UNICODE_CODEPAGE?
    }
    else
    {
        if (!g_cpInfoInitialized)
            THR(EnsureCodePageInfo(FALSE));

        if (g_cpInfoInitialized)
        {
            LOCK_GLOBALS;

            for (UINT n = 0; n < g_ccpInfo; n++)
            {
                if (cp == g_pcpInfo[n].uiCodePage)
                    return g_pcpInfo[n].uiFamilyCodePage;
            }
        }
    }

    // NOTE: (cthrash) There's a chance that this codepage is a 'hidden'
    // codepage and that MLANG may actually know the family codepage.
    // So we ask them again, only differently.

    {
        UINT uiFamilyCodePage = 0;
        if (S_OK == THR(mlang().GetFamilyCodePage(cp, &uiFamilyCodePage)))
            return uiFamilyCodePage;
    }

    return g_cpDefault;
}

//+-----------------------------------------------------------------------
//
//  Function:   WindowsCharsetFromCodePage
//
//  Synopsis:   Return a Windows charset from an mlang CODEPAGE id
//
//------------------------------------------------------------------------

BYTE
WindowsCharsetFromCodePage( CODEPAGE cp )
{
#ifndef NO_MULTILANG
    HRESULT    hr;
    MIMECPINFO mimeCpInfo;

    if (cp == CP_ACP)
    {
        return DEFAULT_CHARSET;
    }

    hr = QuickMimeGetCodePageInfo(cp, &mimeCpInfo);
    if (!hr)
    {
        return mimeCpInfo.bGDICharset;
    }

#endif // !NO_MULTILANG
    return DEFAULT_CHARSET;
}

//+-----------------------------------------------------------------------
//
//  Function:   DefaultCodePageFromCharSet
//
//  Synopsis:   Return a Windows codepage from a Windows font charset
//
//------------------------------------------------------------------------

UINT
DefaultCodePageFromCharSet(BYTE bCharSet, CODEPAGE cp, LCID lcid)
{
    HRESULT hr;
    UINT    n;
    static  BYTE bCharSetPrev = DEFAULT_CHARSET;
    static  CODEPAGE cpPrev = CP_UNDEFINED;
    static  CODEPAGE cpDefaultPrev = CP_UNDEFINED;
    CODEPAGE cpDefault;

#ifdef NO_MULTILANG
    return GetACP();
#else
    if (   DEFAULT_CHARSET == bCharSet
        || (   bCharSet == ANSI_CHARSET
            && (   cp == CP_UCS_2
                   || cp == CP_UTF_8
               )
           )
       )
    {
        return g_cpDefault;  // Don't populate the statics.
    }
    else if (bCharSet == bCharSetPrev && cpPrev == cp)
    {
        // Here's our gamble -- We have a high likelyhood of calling with
        // the same arguments over and over.  Short-circuit this case.

        return cpDefaultPrev;
    }

    // First pick the *TRUE* codepage
    if (lcid)
    {
        char pszCodePage[5];
        
        GetLocaleInfoA( lcid, LOCALE_IDEFAULTANSICODEPAGE,
                        pszCodePage, ARRAY_SIZE(pszCodePage) );

        cp = atoi(pszCodePage);
    }

    // First check our internal lookup table in case we can avoid mlang
    for (n = 0; n < ARRAY_SIZE(s_aryCpMap); ++n)
    {
        if (cp == s_aryCpMap[n].cp && bCharSet == s_aryCpMap[n].bGDICharset)
        {
            cpDefault = cp;
            goto Cleanup;
        }
    }

    hr = THR(EnsureCodePageInfo(FALSE));
    if (hr)
    {
        cpDefault = WindowsCodePageFromCodePage(cp);
        goto Cleanup;
    }

    {
        LOCK_GLOBALS;
        
        // First see if we find an exact match for both cp and bCharset.
        for (n = 0; n < g_ccpInfo; n++)
        {
            if (cp == g_pcpInfo[n].uiCodePage &&
                bCharSet == g_pcpInfo[n].bGDICharset)
            {
                cpDefault = g_pcpInfo[n].uiFamilyCodePage;
                goto Cleanup;
            }
        }

        // Settle for the first match of bCharset.

        for (n = 0; n < g_ccpInfo; n++)
        {
            if (bCharSet == g_pcpInfo[n].bGDICharset)
            {
                cpDefault = g_pcpInfo[n].uiFamilyCodePage;
                goto Cleanup;
            }
        }

        cpDefault = g_cpDefault;
    }

Cleanup:

    bCharSetPrev = bCharSet;
    cpPrev = cp;
    cpDefaultPrev = cpDefault;

    return cpDefault;
#endif // !NO_MULTILANG
}

//+-----------------------------------------------------------------------
//
//  Function:   DefaultFontInfoFromCodePage
//
//  Synopsis:   Fills a LOGFONT structure with appropriate information for
//              a 'default' font for a given codepage.
//
//------------------------------------------------------------------------

HRESULT
DefaultFontInfoFromCodePage(CODEPAGE cp, LOGFONT * lplf, CDoc * pDoc)
{
    HFONT hfont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );

    // The strategy is thus: If we ask for a stock font in the default
    // (CP_ACP) codepage, return the logfont information of that font.
    // If we don't, replace key pieces of information.  Note we could
    // do better -- we could get the right lfPitchAndFamily.

#ifndef NO_MULTILANG
    if (!hfont)
    {
        CPINFO cpinfo;

        GetCPInfo( WindowsCodePageFromCodePage(cp), &cpinfo );

        hfont = (HFONT)((cpinfo.MaxCharSize == 1)
                        ? GetStockObject( ANSI_VAR_FONT )
                        : GetStockObject( SYSTEM_FONT ));

        AssertSz( hfont, "We'd better have a font now.");
    }
#endif

    GetObject( hfont, sizeof(LOGFONT), (LPVOID)lplf );

#ifndef NO_MULTILANG
    if (   cp != CP_ACP
        && cp != g_cpDefault
        && (   cp != CP_ISO_8859_1
            || g_cpDefault != CP_1252))
    {
        MIMECPINFO mimeCpInfo;
        IGNORE_HR(QuickMimeGetCodePageInfo(cp, &mimeCpInfo));
        // Make sure we don't overflow static buffer
        Assert(_tcsclen(mimeCpInfo.wszProportionalFont) < LF_FACESIZE);
        mimeCpInfo.wszProportionalFont[LF_FACESIZE - 1] = 0;

        BYTE bCharSet = mimeCpInfo.bGDICharset;
        LONG latmFaceName;
        if (MapToInstalledFont(mimeCpInfo.wszProportionalFont, &bCharSet, &latmFaceName))
        {
            _tcscpy(lplf->lfFaceName, fc().GetFaceNameFromAtom(latmFaceName));

            // NOTE (grzegorz): The right thing to do is to set charset to
            // lplf->lfCharSet = bCharSet;
            // But on non-FE systems we usually ask about "MS Sans Serif", which 
            // has poor coverage for Latin unicode range. So its better to 
            // font link for some upper latin characters than render square boxes.
            // To do it simply set charset to original one, even if we don't
            // match charset for the requested font.
            lplf->lfCharSet = mimeCpInfo.bGDICharset; // set original charset
        }
        else
        {
            //
            // NOTE (grzegorz): It may be good idea in this case get default
            // proportional font from the registry/MLang
            //
            SCRIPT_ID sid = ScriptIDFromCodePage(WindowsCodePageFromCodePage(cp));
            LONG latmFontFace = pDoc->_pOptionSettings->alatmProporitionalFonts[sid];
            if (latmFontFace == -1)
            {
                CODEPAGESETTINGS CS;
                CS.SetDefaults(WindowsCodePageFromCodePage(cp), pDoc->_pOptionSettings->sBaselineFontDefault);

                pDoc->_pOptionSettings->ReadCodepageSettingsFromRegistry(&CS, 0, sid);

                pDoc->_pOptionSettings->alatmFixedPitchFonts[sid]    = CS.latmFixedFontFace;
                pDoc->_pOptionSettings->alatmProporitionalFonts[sid] = CS.latmPropFontFace;

                latmFontFace = CS.latmPropFontFace;
            }

            _tcscpy(lplf->lfFaceName, fc().GetFaceNameFromAtom(latmFontFace));
            lplf->lfCharSet = CharSetFromScriptId(sid);
        }
    }
    else
    {
        // NB (cthrash) On both simplified and traditional Chinese systems,
        // we get a bogus lfCharSet value when we ask for the DEFAULT_GUI_FONT.
        // This later confuses CCcs::MakeFont -- so override.

        if (cp == 950)
        {
            lplf->lfCharSet = CHINESEBIG5_CHARSET;
        }
        else if (cp == 936)
        {
            lplf->lfCharSet = GB2312_CHARSET;
        }
    }
#endif // !NO_MULTILANG

   return S_OK;
}

//+-----------------------------------------------------------------------
//
//  Function:   CodePageFromString
//
//  Synopsis:   Map a charset to a forms3 CODEPAGE enum.  Searches in the
//              argument a string of the form charset=xxx.  This is used
//              by the META tag handler in the HTML preparser.
//
//              If fLookForWordCharset is TRUE, pch is presumed to be in
//              the form of charset=XXX.  Otherwise the string is
//              expected to contain just the charset string.
//
//------------------------------------------------------------------------

inline BOOL
IsWhite(TCHAR ch)
{
    return ch == TEXT(' ') || InRange(ch, TEXT('\t'), TEXT('\r'));
}

CODEPAGE
CodePageFromString( TCHAR * pch, BOOL fLookForWordCharset )
{
    CODEPAGE cp = CP_UNDEFINED;

    while (pch && *pch)
    {
        for (;IsWhite(*pch);pch++);

        if (!fLookForWordCharset || (_tcslen(pch) >= 7 &&
            _tcsnicmp(pch, 7, _T("charset"), 7) == 0))
        {
            if (fLookForWordCharset)
            {
                pch = _tcschr(pch, L'=');
                pch = pch ? ++pch : NULL;
            }

            if (pch)
            {
                for (;IsWhite(*pch);pch++);

                if (*pch)
                {
                    TCHAR *pchEnd, chEnd;

                    for (pchEnd = pch;
                         *pchEnd && !(*pchEnd == L';' || IsWhite(*pchEnd));
                         pchEnd++);

                    chEnd = *pchEnd;
                    *pchEnd = L'\0';

                    cp = CodePageFromAlias( pch );

                    *pchEnd = chEnd;

                    break;
                }
            }
        }

        if (pch)
        {
            pch = _tcschr( pch, L';');
            if (pch) pch++;
        }

    }

    return cp;
}

//+-----------------------------------------------------------------------
//
//  Function:   IsFECharset
//
//  Synopsis:   Returns TRUE iff charset may be for a FE country.
//
//------------------------------------------------------------------------

BOOL 
IsFECharset(BYTE bCharSet)
{
    switch(bCharSet)
    {
        case CHINESEBIG5_CHARSET:
        case SHIFTJIS_CHARSET:
        case HANGEUL_CHARSET:
#if !defined(WINCE) && !defined(UNIX)
        case JOHAB_CHARSET:
        case GB2312_CHARSET:
#endif // !WINCE && !UNIX
            return TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  Member:     GetScriptProperties(eScript)
//
//  Synopsis:   Return a pointer to the script properties describing the script
//              eScript.
//
//-----------------------------------------------------------------------------

static const SCRIPT_PROPERTIES ** s_ppScriptProps = NULL;
static int s_cScript = 0;
static const SCRIPT_PROPERTIES s_ScriptPropsDefault =
{
    LANG_NEUTRAL,   // langid
    FALSE,          // fNumeric
    FALSE,          // fComplex
    FALSE,          // fNeedsWordBreaking
    FALSE,          // fNeedsCaretInfo
    ANSI_CHARSET,   // bCharSet
    FALSE,          // fControl
    FALSE,          // fPrivateUseArea
    FALSE,          // fReserved
};

const SCRIPT_PROPERTIES * 
GetScriptProperties(WORD eScript)
{
    if (s_ppScriptProps == NULL)
    {
        HRESULT hr;

        Assert(s_cScript == 0);
        if(g_bUSPJitState == JIT_OK)
            hr = ::ScriptGetProperties(&s_ppScriptProps, &s_cScript);
        else
            hr = E_PENDING;

        if (FAILED(hr))
        {
            // This should only fail if USP cannot be loaded. We shouldn't
            // really have made it here in the first place if this is true,
            // but you never know...
            return &s_ScriptPropsDefault;
        }
    }
    Assert(s_ppScriptProps != NULL && eScript < s_cScript &&
           s_ppScriptProps[eScript] != NULL);
    return s_ppScriptProps[eScript];
}

//+----------------------------------------------------------------------------
//  Member:     GetNumericScript(lang)
//
//  Synopsis:   Returns the script that should be used to shape digits in the
//              given language.
//
//-----------------------------------------------------------------------------

WORD 
GetNumericScript(DWORD lang)
{
    WORD eScript = 0;

    // We should never get here without having called GetScriptProperties().
    Assert(s_ppScriptProps != NULL && eScript < s_cScript &&
           s_ppScriptProps[eScript] != NULL);
    for (eScript = 0; eScript < s_cScript; eScript++)
    {
        if (s_ppScriptProps[eScript]->langid == lang &&
            s_ppScriptProps[eScript]->fNumeric)
        {
            return eScript;
        }
    }

    return SCRIPT_UNDEFINED;
}

//+----------------------------------------------------------------------------
//  Member:     ScriptItemize(...)
//
//  Synopsis:   Dynamically grows the needed size of paryItems as needed to
//              successfully itemize the input string.
//
//-----------------------------------------------------------------------------

HRESULT WINAPI 
ScriptItemize(
    PCWSTR                  pwcInChars,     // In   Unicode string to be itemized
    int                     cInChars,       // In   Character count to itemize
    int                     cItemGrow,      // In   Items to grow by if paryItems is too small
    const SCRIPT_CONTROL   *psControl,      // In   Analysis control (optional)
    const SCRIPT_STATE     *psState,        // In   Initial bidi algorithm state (optional)
    CDataAry<SCRIPT_ITEM>  *paryItems,      // Out  Array to receive itemization
    PINT                    pcItems)        // Out  Count of items processed
{
    HRESULT hr;

    // ScriptItemize requires that the max item buffer size be AT LEAST 2
    Assert(cItemGrow > 2);

    if(paryItems->Size() < 2)
    {
        hr = paryItems->Grow(cItemGrow);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    do {
        hr = ScriptItemize(pwcInChars, cInChars, paryItems->Size(),
                           psControl, psState, (SCRIPT_ITEM*)*paryItems, pcItems);

        if (hr == E_OUTOFMEMORY)
        {
            if (FAILED(paryItems->Grow(paryItems->Size() + cItemGrow)))
            {
                goto Cleanup;
            }
        }
    } while(hr == E_OUTOFMEMORY);

Cleanup:
    if (SUCCEEDED(hr))
    {
        // NB (mikejoch) *pcItems doesn't include the sentinel item.
        Assert(*pcItems < paryItems->Size());
        paryItems->SetSize(*pcItems + 1);
    }
    else
    {
        *pcItems = 0;
        paryItems->DeleteAll();
    }

    return hr;
}

// TODO (cthrash, IE5 track bug 112152) This class (CIntlFont) should be axed when we implement
// a light-weight fontlinking implementation of Line Services.  This LS
// implementation will work as a DrawText replacement, and can be used by
// intrinsics as well.

CIntlFont::CIntlFont(
    const CDocInfo * pdci,
    XHDC hdc,
    CODEPAGE codepage,
    LCID lcid,
    SHORT sBaselineFont,
    const TCHAR * psz)
{
    BYTE bCharSet = WindowsCharsetFromCodePage( codepage );

    // If we are working on scaled surface, avoid using stock fonts.
    BOOL fScaled = (pdci->GetUnitInfo() != &g_uiDisplay);

    _hdc = hdc;
    _hFont = NULL;

    Assert(sBaselineFont >= 0 && sBaselineFont <= 4);
    Assert(psz);

    if (IsStraightToUnicodeCodePage(codepage))
    {
        BOOL fSawHan = FALSE;
        SCRIPT_ID sid;
        
        // If the document is in a Unicode codepage, we need determine the
        // best-guess charset for this string.  To do so, we pick the first
        // interesting script id.

        while (*psz)
        {
            sid = ScriptIDFromCh(*psz++);

            if (sid == sidHan)
            {
                fSawHan = TRUE;
                continue;
            }
            
            if (sid > sidAsciiLatin)
                break;
        }

        if (*psz)
        {
            // We found something interesting, go pick that font up

            codepage = DefaultCodePageFromScript( &sid, CP_UCS_2, lcid );

        }
        else if (!fScaled)
        {
            if (!fSawHan)
            {
                // the string contained nothing interesting, go with the stock GUI font

                _hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
                _fIsStock = sBaselineFont == 2;
            }
            else
            {
                // We saw a Han character, but nothing else which would
                // disambiguate the script.  Furthermore, we don't have a good
                // fallback as we did in the above case.

                sid = sidHan;
                codepage = DefaultCodePageFromScript( &sid, CP_UCS_2, lcid );
            }
        }
    }
    else if ((  ANSI_CHARSET == bCharSet
                || (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID 
                    && !IsFECharset(bCharSet)))
             && !fScaled)
    {
        // If we're looking for an ANSI font, or if we're under NT and
        // looking for a non-FarEast font, the stockfont will suffice.

        _hFont = (HFONT)GetStockObject( ANSI_VAR_FONT );
        _fIsStock = sBaselineFont == 2;
    }
    else
    {
        codepage = WindowsCodePageFromCodePage( codepage );
    }

    if (!_hFont && codepage == g_cpDefault  && !fScaled)
    {
        // If we're going to get the correct native charset the, the
        // GUI font will work nicely.

        _hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
        _fIsStock = sBaselineFont == 2;
    }

    if (_hFont)
    {
        if (!_fIsStock)
        {
            LOGFONT lf;

            GetObject(_hFont, sizeof(lf), &lf);

            lf.lfHeight = MulDivQuick( lf.lfHeight, 4 + sBaselineFont, 6 );
            lf.lfWidth  = 0;
            lf.lfOutPrecision |= OUT_TT_ONLY_PRECIS;

            _hFont = CreateFontIndirect( &lf );
        }
    }
    else
    {
        // We'd better cook up a font if all else fails.

        LOGFONT lf;

        DefaultFontInfoFromCodePage(codepage, &lf, pdci->_pDoc);

        lf.lfHeight = MulDivQuick( lf.lfHeight, 
                                   (4 + sBaselineFont) * pdci->GetResolution().cy, 
                                   6 * g_uiDisplay.GetResolution().cy );
        lf.lfWidth  = 0;
        lf.lfOutPrecision |= OUT_TT_ONLY_PRECIS;

        _hFont = CreateFontIndirect( &lf );
        _fIsStock = FALSE;
    }

    _hOldFont = (HFONT)SelectObject( hdc, _hFont );
}

CIntlFont::~CIntlFont()
{
    SelectObject( _hdc, _hOldFont );

    if (!_fIsStock)
    {
        DeleteObject( _hFont );
    }
}

//+-----------------------------------------------------------------------------
//
//  Function:   DefaultCodePageFromCharSet
//
//  Synopsis:   Map charset to codepage.
//
//------------------------------------------------------------------------------

CODEPAGE
DefaultCodePageFromCharSet(BYTE bCharSet, CODEPAGE uiFamilyCodePage)
{
    CODEPAGE cp = uiFamilyCodePage;
    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (bCharSet == g_aCPBitmapCPCharsetSid[i].bGDICharset)
        {
            cp = g_aCPBitmapCPCharsetSid[i].cp;
            break;
        }
    }
    return cp;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CharSetFromLangId
//
//  Synopsis:   Map lang ID to charset.
//
//------------------------------------------------------------------------------

BYTE
CharSetFromLangId(LANGID lang)
{
    BYTE bCharSet = DEFAULT_CHARSET;
    DWORD dwCPBitmap = CPBitmapFromLangID(lang);

    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (dwCPBitmap & g_aCPBitmapCPCharsetSid[i].dwCPBitmap)
        {
            bCharSet = g_aCPBitmapCPCharsetSid[i].bGDICharset;
            break;
        }
    }
    return bCharSet;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CharSetFromScriptId
//
//  Synopsis:   Map script ID to charset.
//
//------------------------------------------------------------------------------

BYTE
CharSetFromScriptId(SCRIPT_ID sid)
{
    BYTE bCharSet = DEFAULT_CHARSET;

    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (sid == g_aCPBitmapCPCharsetSid[i].sid)
        {
            bCharSet = g_aCPBitmapCPCharsetSid[i].bGDICharset;
            break;
        }
    }
    return bCharSet;
}

//+-----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromCodePage
//
//  Synopsis:   Map code page to script id.
//
//------------------------------------------------------------------------------

SCRIPT_ID  
ScriptIDFromCodePage(CODEPAGE cp)
{
    SCRIPT_ID sid = sidDefault;

    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (cp == g_aCPBitmapCPCharsetSid[i].cp)
        {
            sid = g_aCPBitmapCPCharsetSid[i].sid;
            break;
        }
    }
    return sid;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CPBitmapFromLangIDSlow
//
//  Synopsis:   Map lang ID to codepages bitmap. (Slow version)
//
//------------------------------------------------------------------------------

DWORD 
CPBitmapFromLangIDSlow(LANGID lang)
{
    DWORD dwCPBitmap = 0;
    WORD sublang = SUBLANGID(lang);
    switch (PRIMARYLANGID(lang))
    {
    case LANG_CHINESE:
        dwCPBitmap = (sublang == SUBLANG_CHINESE_TRADITIONAL ? FS_CHINESETRAD : FS_CHINESESIMP);
        break;
    case LANG_KOREAN:
        dwCPBitmap = (sublang == SUBLANG_KOREAN ? FS_WANSUNG : FS_JOHAB);
        break;
    case LANG_SERBIAN:
        dwCPBitmap = (sublang == SUBLANG_SERBIAN_CYRILLIC ? FS_CYRILLIC : FS_LATIN2);
        break;
    case LANG_AZERI:
        dwCPBitmap = (sublang == SUBLANG_AZERI_CYRILLIC ? FS_CYRILLIC : FS_LATIN1);
        break;
    case LANG_UZBEK:
        dwCPBitmap = (sublang == SUBLANG_UZBEK_CYRILLIC ? FS_CYRILLIC : FS_LATIN1);
        break;
    default:
        Assert(FALSE);  // Should get data in fast vertion (FBSFromLangID)
    }
    return dwCPBitmap;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CPBitmapFromWindowsCodePage
//
//  Synopsis:   Maps windows codepage to codepages bitmap.
//
//------------------------------------------------------------------------------

DWORD 
CPBitmapFromWindowsCodePage(CODEPAGE cp)
{
    DWORD cpbits = 0;
    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (cp == g_aCPBitmapCPCharsetSid[i].cp)
        {
            cpbits = g_aCPBitmapCPCharsetSid[i].dwCPBitmap;
            break;
        }
    }
    return cpbits;
}

const WCHAR g_achLatin1MappingInUnicodeControlArea[32] =
{
#ifndef UNIX
    0x20ac, // 0x80
    0x0081, // 0x81
    0x201a, // 0x82
    0x0192, // 0x83
    0x201e, // 0x84
    0x2026, // 0x85
    0x2020, // 0x86
    0x2021, // 0x87
    0x02c6, // 0x88
    0x2030, // 0x89
    0x0160, // 0x8a
    0x2039, // 0x8b
    0x0152, // 0x8c <min>
    0x008d, // 0x8d
    0x017d, // 0x8e
    0x008f, // 0x8f
    0x0090, // 0x90
    0x2018, // 0x91
    0x2019, // 0x92
    0x201c, // 0x93
    0x201d, // 0x94
    0x2022, // 0x95
    0x2013, // 0x96
    0x2014, // 0x97
    0x02dc, // 0x98
    0x2122, // 0x99 <max>
    0x0161, // 0x9a
    0x203a, // 0x9b
    0x0153, // 0x9c
    0x009d, // 0x9d
    0x017e, // 0x9e
    0x0178  // 0x9f
#else
    _T('?'),  // 0x80
    _T('?'),  // 0x81
    _T(','),  // 0x82
    0x00a6,   // 0x83
    _T('?'),  // 0x84
    0x00bc,   // 0x85
    _T('?'),  // 0x86
    _T('?'),  // 0x87
    0x00d9,   // 0x88
    _T('?'),  // 0x89
    _T('?'),  // 0x8a
    _T('<'),  // 0x8b
    _T('?'),  // 0x8c
    _T('?'),  // 0x8d
    _T('?'),  // 0x8e
    _T('?'),  // 0x8f
    _T('?'),  // 0x90
    0x00a2,   // 0x91
    0x00a2,   // 0x92
    0x00b2,   // 0x93
    0x00b2,   // 0x94
    0x00b7,   // 0x95
    _T('-'),  // 0x96
    0x00be,   // 0x97
    _T('~'),  // 0x98
    0x00d4,   // 0x99
    _T('s'),  // 0x9a
    _T('>'),  // 0x9b
    _T('?'),  // 0x9c
    _T('?'),  // 0x9d
    _T('?'),  // 0x9e
    0x0055    // 0x9f
#endif
};

// ############################################################## UniSid.cxx
//+-----------------------------------------------------------------------
//
//  g_aSidInfo
//
//  Script ID mapping to:
//  * charset
//  * representative of average char width for the script id
//
//------------------------------------------------------------------------
#define SPECIAL_CHARSET 3

const SidInfo g_aSidInfo[sidTridentLim] =
{
    { /* sidDefault        (0) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidMerge          (1) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidAsciiSym       (2) */ ANSI_CHARSET,        0x0078    },
    { /* sidAsciiLatin     (3) */ SPECIAL_CHARSET,     0x0078    },
    { /* sidLatin          (4) */ SPECIAL_CHARSET,     0x0078    },
    { /* sidGreek          (5) */ GREEK_CHARSET,       0x03c7    },
    { /* sidCyrillic       (6) */ RUSSIAN_CHARSET,     0x0445    },
    { /* sidArmenian       (7) */ DEFAULT_CHARSET,     0x0562    },
    { /* sidHebrew         (8) */ HEBREW_CHARSET,      0x05d0    },
    { /* sidArabic         (9) */ ARABIC_CHARSET,      0x0637    },
    { /* sidDevanagari    (10) */ DEFAULT_CHARSET,     0x0909    },
    { /* sidBengali       (11) */ DEFAULT_CHARSET,     0x0989    },
    { /* sidGurmukhi      (12) */ DEFAULT_CHARSET,     0x0a19    },
    { /* sidGujarati      (13) */ DEFAULT_CHARSET,     0x0a89    },
    { /* sidOriya         (14) */ DEFAULT_CHARSET,     0x0b09    },
    { /* sidTamil         (15) */ DEFAULT_CHARSET,     0x0b8e    },
    { /* sidTelugu        (16) */ DEFAULT_CHARSET,     0x0c05    },
    { /* sidKannada       (17) */ DEFAULT_CHARSET,     0x0c85    },
    { /* sidMalayalam     (18) */ DEFAULT_CHARSET,     0x0d17    },
    { /* sidThai          (19) */ THAI_CHARSET,        0x0e01    },
    { /* sidLao           (20) */ DEFAULT_CHARSET,     0x0e81    },
    { /* sidTibetan       (21) */ DEFAULT_CHARSET,     0x0f40    },
    { /* sidGeorgian      (22) */ DEFAULT_CHARSET,     0x10d0    },
    { /* sidHangul        (23) */ HANGUL_CHARSET,      0xac00    },
    { /* sidKana          (24) */ SHIFTJIS_CHARSET,    0x4e00    },
    { /* sidBopomofo      (25) */ CHINESEBIG5_CHARSET, 0x4e00    },
    { /* sidHan           (26) */ GB2312_CHARSET,      0x4e00    },
    { /* sidEthiopic      (27) */ DEFAULT_CHARSET,     0x1210    },
    { /* sidCanSyllabic   (28) */ DEFAULT_CHARSET,     0x1405    },
    { /* sidCherokee      (29) */ DEFAULT_CHARSET,     0x13bb    },
    { /* sidYi            (30) */ DEFAULT_CHARSET,     0xa000    },
    { /* sidBraille       (31) */ DEFAULT_CHARSET,     0x2909    },
    { /* sidRunic         (32) */ DEFAULT_CHARSET,     0x16ba    },
    { /* sidOgham         (33) */ DEFAULT_CHARSET,     0x1683    },
    { /* sidSinhala       (34) */ DEFAULT_CHARSET,     0x0d85    },
    { /* sidSyriac        (35) */ DEFAULT_CHARSET,     0x0717    },
    { /* sidBurmese       (36) */ DEFAULT_CHARSET,     0x1000    },
    { /* sidKhmer         (37) */ DEFAULT_CHARSET,     0x1780    },
    { /* sidThaana        (38) */ DEFAULT_CHARSET,     0x0784    },
    { /* sidMongolian     (39) */ DEFAULT_CHARSET,     0x1824    },
    { /* sidUserDefined   (40) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidSurrogateA    (41) */ DEFAULT_CHARSET,     0x4e00    },
    { /* sidSurrogateB    (42) */ DEFAULT_CHARSET,     0x4e00    },
    { /* sidAmbiguous     (43) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidEUDC          (44) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidHalfWidthKana (45) */ SHIFTJIS_CHARSET,    0x4e00    },
    { /* sidCurrency      (46) */ SPECIAL_CHARSET,     0x0078    }
};

//
// We must not fontlink for sidEUDC -- GDI will handle
//

#define SCRIPT_BIT_CONST ScriptBit(sidEUDC)

//+----------------------------------------------------------------------------
//
//  Function:   UnUnifyHan, static
//
//  Synopsis:   Use a heuristic to best approximate the script actually
//              represented by sidHan.  This is necessary because of the
//              infamous Han-Unification brought upon us by the Unicode
//              consortium.
//
//              We prioritize the lcid if set.  This is set in HTML through
//              the use of the LANG attribute.  If this is not set, we
//              take the document codepage as reference.
//
//              The fallout case picks Japanese, as there is biggest market
//              share there today.
//
//  Returns:    Best guess script id.
//
//-----------------------------------------------------------------------------

SCRIPT_ID
UnUnifyHan(
    UINT uiFamilyCodePage,
    LCID lcid )
{
    if ( !lcid )
    {
        // No lang info.  Try codepages

        if (uiFamilyCodePage == CP_CHN_GB)
        {
            lcid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
        }
        else if (uiFamilyCodePage == CP_KOR_5601)
        {
            lcid = MAKELANGID(LANG_KOREAN, SUBLANG_NEUTRAL);
        }
        else if (uiFamilyCodePage == CP_TWN)
        {
            lcid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
        }
        else
        {
            lcid = MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL);
        }
    }

    LANGID lid = LANGIDFROMLCID(lcid);
    if (!IsFELang(lid))
        lid = MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL);
    return ScriptIDFromLangID(lid);
}

//+----------------------------------------------------------------------------
//
//  Function:   DefaultCodePageFromScript, static
//
//  Synopsis:   we return the best-guess default codepage based on the script
//              id passed.  It is a best-guess because scripts can cover
//              multiple codepages.
//
//  Returns:    Best-guess codepage for given information.
//              Also returns the ununified sid for sidHan.
//
//-----------------------------------------------------------------------------

CODEPAGE
DefaultCodePageFromScript(
    SCRIPT_ID * psid,   // IN/OUT
    CODEPAGE cpDoc,  // IN
    LCID lcid )         // IN
{
    AssertSz(psid, "Not an optional parameter.");
    AssertSz(cpDoc == WindowsCodePageFromCodePage(cpDoc),
             "Get an Internet codepage, expected a Windows codepage.");

    CODEPAGE cp;
    SCRIPT_ID sid = *psid;

    if (sid == sidMerge || sid == sidAmbiguous)
    {
        //
        // This is a hack -- the only time we should be called with sidMerge
        // is when the person asking about the font doesn't know what the sid
        // for the run is (e.g. treepos is non-text.)  In this event, we need
        // to pick a codepage which will give us the highest likelyhood of
        // being the correct one for ReExtTextOutW.
        //

        return cpDoc;
    }
    else if (cpDoc == CP_1250 && sid == sidDefault || sid == sidLatin)
    {
        // HACK (cthrash) CP_1250 (Eastern Europe) doesn't have it's own sid,
        // because its codepoints are covered by AsciiLatin, AsciiSym, and
        // Latin.  When printing, though, we may need to do a WC2MB (on a PCL
        // printer, for example) so we need the best approximation for the
        // actual codepage of the text.  In the simplest case, take the
        // document codepage over cp1252.

        cp = CP_1250;
    }
    else
    {
        // NB (cthrash) We assume the sidHan is the unified script for Han.
        // we use the usual heurisitics to pick amongst them.

        sid = (sid != sidHan) ? sid : UnUnifyHan( cpDoc, lcid );

        switch (sid)
        {
            default:            cp = CP_1252;       break;
            case sidGreek:      cp = CP_1253;       break;
            case sidCyrillic:   cp = CP_1251;       break;
            case sidHebrew:     cp = CP_1255;       break;
            case sidArabic:     cp = CP_1256;       break;
            case sidThai:       cp = CP_THAI;       break;
            case sidHangul:     cp = CP_KOR_5601;   break;
            case sidKana:       cp = CP_JPN_SJ;     break;
            case sidBopomofo:   cp = CP_TWN;        break;
            case sidHan:        cp = CP_CHN_GB;     break;
        }

        *psid = sid;
    }

    return cp;
}

//+----------------------------------------------------------------------------
//
//  Function:   DefaultCharSetFromScriptAndCharset/CodePage, static
//
//  Synopsis:   we return the best-guess default GDI charset based on the
//              script id passed.  We use the charformat charset is the tie-
//              breaker.
//
//              Note the sid should already been UnUnifyHan'd.
//
//  Returns:    Best-guess GDI charset for given information.
//
//-----------------------------------------------------------------------------

BYTE
DefaultCharSetFromScriptAndCharset(
    SCRIPT_ID sid,
    BYTE bCharSetCF )
{
    BYTE bCharSet = g_aSidInfo[sid]._bCharSet;

    if (bCharSet == SPECIAL_CHARSET)
    {
        if (   sid == sidLatin
            && (   bCharSetCF == TURKISH_CHARSET
                || bCharSetCF == ANSI_CHARSET
                || bCharSetCF == VIETNAMESE_CHARSET
                || bCharSetCF == BALTIC_CHARSET
                || bCharSetCF == EASTEUROPE_CHARSET
               )
           )
        {
            bCharSet = bCharSetCF;
        }
        else if (sid == sidHangul)
        {
            bCharSet = bCharSetCF == JOHAB_CHARSET
                       ? JOHAB_CHARSET
                       : HANGUL_CHARSET;
        }
        else
        {
            bCharSet = DEFAULT_CHARSET;
        }
    }

    return bCharSet;
}

//+----------------------------------------------------------------------------
//
//  Function:   DefaultCharSetFromScriptAndCodePage, static
//
//  Synopsis:   we return the best-guess default GDI charset based on the
//              script id passed and family codepage.
//
//              Note the sid should already been UnUnifyHan'd.
//
//  Returns:    Best-guess GDI charset for given information.
//
//-----------------------------------------------------------------------------

static const BYTE s_ab125xCharSets[] = 
{
    EASTEUROPE_CHARSET, // 1250
    RUSSIAN_CHARSET,    // 1251
    ANSI_CHARSET,       // 1252
    GREEK_CHARSET,      // 1253
    TURKISH_CHARSET,    // 1254
    HEBREW_CHARSET,     // 1255
    ARABIC_CHARSET,     // 1256
    BALTIC_CHARSET,     // 1257
    VIETNAMESE_CHARSET  // 1258
};

BYTE
DefaultCharSetFromScriptAndCodePage(
    SCRIPT_ID sid,
    UINT uiFamilyCodePage )
{
    BYTE bCharSet = g_aSidInfo[sid]._bCharSet;

    if (bCharSet == SPECIAL_CHARSET)
    {
        bCharSet = (uiFamilyCodePage >= 1250 && uiFamilyCodePage <= 1258)
                   ? s_ab125xCharSets[uiFamilyCodePage - 1250]
                   : ANSI_CHARSET;
    }

    return bCharSet;
}

//+-----------------------------------------------------------------------------
//
//  Function:   DefaultSidForCodePage
//
//  Returns:    The default SCRIPT_ID for a codepage.  For stock codepages, we
//              cache the answer.  For the rest, we ask MLANG.
//
//------------------------------------------------------------------------------

SCRIPT_ID
DefaultSidForCodePage( UINT uiFamilyCodePage )
{
    SCRIPT_ID sid = sidLatin;
#if DBG==1
    BOOL fCachedSidDbg = TRUE;
#endif

    switch (uiFamilyCodePage)
    {
        case CP_UCS_2:    sid = sidLatin; break;
        case CP_1250:     sid = sidLatin; break;
        case CP_1251:     sid = sidCyrillic; break;
        case CP_1252:     sid = sidLatin; break;
        case CP_1253:     sid = sidGreek; break;
        case CP_1254:     sid = sidLatin; break;
        case CP_1255:     sid = sidHebrew; break;
        case CP_1256:     sid = sidArabic; break;
        case CP_1257:     sid = sidLatin; break;
        case CP_1258:     sid = sidLatin; break;
        case CP_THAI:     sid = sidThai; break;
        case CP_JPN_SJ:   sid = sidKana; break;
        case CP_CHN_GB:   sid = sidHan; break;
        case CP_KOR_5601: sid = sidHangul; break;
        case CP_TWN:      sid = sidBopomofo; break;
        default:
        {
#if DBG==1
            fCachedSidDbg = FALSE;
#endif
            HRESULT hr = THR(mlang().CodePageToScriptID(uiFamilyCodePage, &sid));
            if (FAILED(hr))
            {
                sid = sidLatin;
            }
        }
        break;
    }
    // TODO (grzegorz): enable this code (removed only for performance testing)
#if NEVER
#if DBG==1
    if (fCachedSidDbg)
    {
        SCRIPT_ID sidDbg;
        HRESULT hr = THR(mlang().CodePageToScriptID(uiFamilyCodePage, &sidDbg));
        if (SUCCEEDED(hr))
        {
            if (   sidDbg == sidAsciiLatin
                && (   uiFamilyCodePage == CP_1250
                    || uiFamilyCodePage == CP_1252
                    || uiFamilyCodePage == CP_1254
                    || uiFamilyCodePage == CP_1257
                    || uiFamilyCodePage == CP_1258
                   )
               )
            {
                sidDbg = sidLatin;
            }
        }
        else
        {
            sid = sidLatin;
        }

        Assert(sid == sidDbg);
    }
#endif
#endif

    return sid;
}

//+----------------------------------------------------------------------------
//
//  Debug only code
//
//-----------------------------------------------------------------------------

#if DBG==1

const TCHAR * achSidNames[sidTridentLim] =
{
    _T("Default"),          // 0
    _T("Merge"),            // 1
    _T("AsciiSym"),         // 2
    _T("AsciiLatin"),       // 3
    _T("Latin"),            // 4
    _T("Greek"),            // 5
    _T("Cyrillic"),         // 6
    _T("Armenian"),         // 7
    _T("Hebrew"),           // 8
    _T("Arabic"),           // 9
    _T("Devanagari"),       // 10
    _T("Bengali"),          // 11
    _T("Gurmukhi"),         // 12
    _T("Gujarati"),         // 13
    _T("Oriya"),            // 14
    _T("Tamil"),            // 15
    _T("Telugu"),           // 16
    _T("Kannada"),          // 17
    _T("Malayalam"),        // 18
    _T("Thai"),             // 19
    _T("Lao"),              // 20
    _T("Tibetan"),          // 21
    _T("Georgian"),         // 22
    _T("Hangul"),           // 23
    _T("Kana"),             // 24
    _T("Bopomofo"),         // 25
    _T("Han"),              // 26
    _T("Ethiopic"),         // 27
    _T("CanSyllabic"),      // 28
    _T("Cherokee"),         // 29
    _T("Yi"),               // 30
    _T("Braille"),          // 31
    _T("Runic"),            // 32
    _T("Ogham"),            // 33
    _T("Sinhala"),          // 34
    _T("Syriac"),           // 35
    _T("Burmese"),          // 36
    _T("Khmer"),            // 37
    _T("Thaana"),           // 38
    _T("Mongolian"),        // 39
    _T("UserDefined"),      // 40
    _T("SurrogateA"),       // 41 *** Trident internal ***
    _T("SurrogateB"),       // 42 *** Trident internal ***
    _T("Ambiguous"),        // 43 *** Trident internal ***
    _T("EUDC"),             // 44 *** Trident internal ***
    _T("HalfWidthKana"),    // 45 *** Trident internal ***
    _T("Currency"),         // 46 *** Trident internal ***
};

//+----------------------------------------------------------------------------
//
//  Functions:  SidName
//
//  Returns:    Human-intelligible name for a script_id
//
//-----------------------------------------------------------------------------

const TCHAR *
SidName( SCRIPT_ID sid )
{
    return ( sid >= 0 && sid < sidTridentLim ) ? achSidNames[sid] : _T("#ERR");
}

//+----------------------------------------------------------------------------
//
//  Functions:  DumpSids
//
//  Synopsis:   Dump to the output window a human-intelligible list of names
//              of scripts coverted by the sids.
//
//-----------------------------------------------------------------------------

void
DumpSids( SCRIPT_IDS sids )
{
    SCRIPT_ID sid;

    for (sid=0; sid < sidTridentLim; sid++)
    {
        if (sids & ScriptBit(sid))
        {
            OutputDebugString(SidName(sid));
            OutputDebugString(_T("\r\n"));
        }
    }
}
#endif // DBG==1

static const BYTE s_aFESidsToCharSets[] = 
{                       // sidBopomofo sidKana sidHangul  
    GB2312_CHARSET,     //    0           0       0
    HANGUL_CHARSET,     //    0           0       1
    SHIFTJIS_CHARSET,   //    0           1       0
    HANGUL_CHARSET,     //    0           1       1
    CHINESEBIG5_CHARSET,//    1           0       0
    DEFAULT_CHARSET,    //    1           0       1       was HANGUL_CHARSET
    CHINESEBIG5_CHARSET,//    1           1       0
    DEFAULT_CHARSET     //    1           1       1       was HANGUL_CHARSET
};

BYTE
DefaultCharSetFromScriptsAndCodePage(
    SCRIPT_IDS sidsFace,
    SCRIPT_ID sid,
    UINT uiFamilyCodePage )
{
    BYTE bCharSet = DEFAULT_CHARSET;

    //
    // HACKHACK (grzegorz): most JA fonts claim to support sidHan and sidKana,
    // and some SCH fonts (like SimSun) claim to support sidHan and sidKana.
    // Hence there is no possibility to pickup the right charset.
    // So on SCH encoded page don't use font information as a hint to pick up 
    // the right charset, since for fonts supporting sidHan and sidKana we 
    // set charset to JA.
    //
    if (    sidsFace & ScriptBit(sid)
        &&  sidsFace & ScriptBit(sidHan)
        &&  uiFamilyCodePage != CP_CHN_GB)
    {
        LONG idx = (sidsFace & (ScriptBit(sidKana) | ScriptBit(sidBopomofo) | ScriptBit(sidHangul))) >> sidHangul;
        Assert(idx >= 0 && idx < 8);
        bCharSet = s_aFESidsToCharSets[idx];
    }
    if (bCharSet == DEFAULT_CHARSET)
    {
        bCharSet = DefaultCharSetFromScriptAndCodePage(sid, uiFamilyCodePage);
    }

    return bCharSet;
}


// ##############################################################
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\fontinfo.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module FONTINFO.H -- Font information
 *  
 *  Purpose:
 *      Font info, used with caching and fontlinking
 *  
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *
 *  History: <nl>
 *      6/25/98     cthrash     Created
 *
 *  Copyright (c) 1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FONTINFO_HXX_
#define X_FONTINFO_HXX_
#include "fontinfo.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

MtDefine(CFontInfoCache, Utilities, "CFontInfoCache")
MtDefine(CFontInfoCache_pv, CFontInfoCache, "CFontInfoCache::_pv")

// NB (cthrash) Face names are case-sensitive under Unix.

#ifdef UNIX
#define STRCMPFUNC StrCmpC
#else
#define STRCMPFUNC StrCmpIC
#endif

HRESULT
CFontInfoCache::AddInfoToAtomTable( LPCTSTR pchFaceName, LONG *plIndex )
{
    HRESULT hr = S_OK;
    LONG lIndex;
    CFontInfo * pfi;

    // Some users of CFontInfoCache assume that font face length is < LF_FACESIZE
    AssertSz(_tcsclen(pchFaceName) < LF_FACESIZE, "String length > LF_FACESIZE");
    
    for (lIndex = 0; lIndex < Size(); lIndex++)
    {
        pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);
        if (!STRCMPFUNC(pchFaceName, pfi->_cstrFaceName))
            break;
    }
    if (lIndex == Size())
    {
        CFontInfo fi;
        
        //
        // Not found, so add element to array.
        //

        hr = THR(AppendIndirect(&fi));
        if (hr)
            goto Cleanup;

        lIndex = Size() - 1;
        pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);
        pfi->_sids = sidsNotSet;
        pfi->_fFSOnly = FALSE;
        hr = THR(pfi->_cstrFaceName.Set(pchFaceName));
        if (hr)
            goto Cleanup;
    }

    if (plIndex)
    {
        *plIndex = lIndex;
    }

Cleanup:
    RRETURN(hr);

}


HRESULT
CFontInfoCache::GetAtomFromName( LPCTSTR pch, LONG *plIndex )
{
    LONG        lIndex;
    HRESULT     hr = S_OK;
    CFontInfo * pfi;

    for (lIndex = 0; lIndex < Size(); lIndex++)
    {
        pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);

        if(!STRCMPFUNC(pfi->_cstrFaceName, pch))
            break;
    }
    
    if (lIndex == Size())
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (plIndex)
    {
        *plIndex = lIndex;
    }

Cleanup:    
    RRETURN(hr);
}

HRESULT 
CFontInfoCache::GetInfoFromAtom(LONG lIndex, CFontInfo **ppfi)
{
    HRESULT hr = S_OK;
    CFontInfo * pfi;

    AssertSz(lIndex >= 0, "Font index < 0");
    
    if (Size() <= lIndex || lIndex < 0)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);
    *ppfi = pfi;
    
Cleanup:    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


void
CFontInfoCache::Free()
{
    CFontInfo *  pCFontInfo;
    LONG i;
    
    for (i=0; i<Size(); i++)
    {
        pCFontInfo = (CFontInfo *)Deref(sizeof(CFontInfo), i);
        pCFontInfo->_cstrFaceName.Free();
    }
    DeleteAll();
}


#if DBG==1
void
CFontInfoCache::Dump()
{
    CFontInfo *  pFontInfo;
    LONG i;

    OutputDebugStringA("*** FontInfoCache dump ***\r\n");

    for (i=0; i<Size(); i++)
    {
        TCHAR ach[LF_FACESIZE+20];
        BOOL fNotFirst = FALSE;
        SCRIPT_ID sid;

        pFontInfo = (CFontInfo *)Deref(sizeof(CFontInfo), i);

        wsprintf(ach, TEXT("%2d: "), i+1);

        OutputDebugString(ach);
        OutputDebugString(pFontInfo->_cstrFaceName);

        for (sid=0; sid < sidTridentLim; sid++)
        {
            if (pFontInfo->_sids & ScriptBit(sid))
            {
                OutputDebugStringA(fNotFirst ? ";" : " (");

                fNotFirst = TRUE;

                OutputDebugString(SidName(sid));
            }
        }
        
        OutputDebugStringA(fNotFirst ? ")\r\n" : "\r\n");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\filtcol.cxx ===
//=================================================================
//
//   File:      filtcol.cxx
//
//  Contents:   CFilterArray class
//
//  Classes:    CFilterArray
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DXTRANS_H_
#define X_DXTRANS_H_
#include "dxtrans.h"
#endif 

#ifndef X_DXTRANSP_H_
#define X_DXTRANSP_H_
#include "dxtransp.h"
#endif

#ifndef X_INTERNED_H_
#define X_INTERNED_HXX_
#include "interned.h"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "filter.hdl"

EXTERN_C const IID IID_IHTMLFiltersCollection;

MtDefine(CFilterBehaviorSite, Elements, "CFilterBehaviorSite")
MtDefine(CFilterArray, ObjectModel, "CFilterArray")
MtDefine(CFilterArray_aryFilters_pv, CFilterArray, "CFilterArray::_aryFilters::_pv")
MtDefine(CPageTransitionInfo, Filters, "CPageTransitionInfo")

MtExtern(CFancyFormat_pszFilters);


DeclareTag(tagPageTransitionsOn, "PageTrans", "Always do page transitions");
DeclareTag(tagPageTransitionTrace, "PageTrans", "Trace page transition calls");
DeclareTag(tagFilterChange, "filter", "Trace filter change events");


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFilterSite
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : CTOR
//
//-----------------------------------------------------------------

CFilterBehaviorSite::CFilterBehaviorSite(CElement * pElem) : super()
{
    _pElem    = pElem;
}


//+----------------------------------------------------------------
//
//  member : ClassDesc Structure
//
//-----------------------------------------------------------------

const CBase::CLASSDESC CFilterBehaviorSite::s_classdesc =
{
    NULL,                                // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                // _pcpi
    0,                                   // _dwFlags
    &IID_ICSSFilterSite,                 // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};


//+---------------------------------------------------------------------
//
//  Class:      CFilterBehaviorSite::PrivateQueryInterface
//
//  Synapsis:   Site object for CSS Extension objects on CElement
//
//------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::PrivateQueryInterface( REFIID iid, LPVOID *ppv )
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS((IServiceProvider *)this, IServiceProvider)
        QI_TEAROFF(this, IBindHost, (IOleClientSite*)this)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        
        default:
        if (iid == IID_IDispatchEx || iid == IID_IDispatch)
        {
            hr = THR(CreateTearOffThunk(this, s_apfnIDispatchEx, NULL, ppv));
        }
    }

    if (*ppv)
        ((IUnknown *)*ppv)->AddRef();
    else if (!hr)
        hr = E_NOINTERFACE;

    RRETURN(hr);
}


//+---------------------------------------------------------------------
//
//  Class:      CFilterBehaviorSite::Passivate
//
//  Synopsis:   Called when refcount goes to 0
//
//------------------------------------------------------------------------
void
CFilterBehaviorSite::Passivate()
{
    ClearInterface(&_pDXTFilterBehavior);
    ClearInterface(&_pDXTFilterCollection);

    super::Passivate();
}


//+-----------------------------------------------------------------------------
//
//  Method: CFilterBehaviorSite::GetIHTMLFiltersCollection
//
//  Overview:
//      In normal filter usage, this is called when the element's get_filters
//      method is called.  It is also called by this class when page
//      transitions are in use.
//
//------------------------------------------------------------------------------
HRESULT 
CFilterBehaviorSite::GetIHTMLFiltersCollection(IHTMLFiltersCollection ** ppCol)
{
    HRESULT                 hr              = S_OK;
    IDXTFilterCollection *  pDXTFilterCol   = NULL;

    Assert(_pDXTFilterBehavior);

    if (!_pDXTFilterBehavior)
    {
        hr = E_FAIL;

        goto Cleanup;
    }

    hr = THR(_pDXTFilterBehavior->GetFilterCollection(&pDXTFilterCol));

    if (hr)
    {
        goto Cleanup;
    }

    Assert(pDXTFilterCol);

    hr = THR(pDXTFilterCol->QueryInterface(IID_IHTMLFiltersCollection, (void **)ppCol));
    
Cleanup:

    ReleaseInterface(pDXTFilterCol);

    RRETURN(hr);
}
//  Method: CFilterBehaviorSite::GetIHTMLFiltersCollection


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::GetElement, public
//
//  Synopsis:   Returns the IHTMLElement pointer of the Element this site
//              belongs to.
//              This causes a hard AddRef on CElement. Clients are *not* to
//              cache this pointer.
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::GetElement( IHTMLElement **ppElement )
{
    RRETURN(_pElem->QueryInterface( IID_IHTMLElement,
                       (void **)ppElement ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::FireOnFilterEvent, public
//
//  Synopsis:   Fires an event for the extension object
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::FireOnFilterChangeEvent()
{
    HRESULT     hr = S_OK;

    CBase::CLock Lock1(this);
    CBase::CLock Lock2(_pElem);
    CDoc *       pDoc = _pElem->Doc();

    if(!_pElem || !_pElem->IsInMarkup())
        goto Cleanup;
    if(_pElem->IsRoot()  && _pElem->Document() && _pElem->Document()->HasPageTransitions())
    {
        // Post a request to remove the peer
        _pElem->Document()->PostCleanupPageTansitions();
        goto Cleanup;
    }


    if (!_pElem->GetAAdisabled())
    {
        EVENTPARAM  param(pDoc, _pElem, NULL, TRUE);

        CDoc::CLock Lock(pDoc);

        param.SetNodeAndCalcCoordinates(_pElem->GetFirstBranch());
        param.SetType(s_propdescCElementonfilterchange.a.pstrName + 2);
        
        hr = THR(_pDXTFilterBehavior->QueryInterface(IID_IElementBehavior, (void **)&(param.psrcFilter)));
        if(hr)
            goto Cleanup;
        // Released by dtor of EVENTPARAM

        TraceTag((tagFilterChange, "Post onfilterchange for %ls-%d",
                    _pElem->TagName(), _pElem->SN()));

        // Fire against the element
        hr = THR(GWPostMethodCall(_pElem, ONCALL_METHOD(CElement, Fire_onfilterchange, fire_onfilterchange), 
                                0, TRUE, "CElement::Fire_onfilterchange"));
    }
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::QueryService
//
//  Synopsis:   Get service from host. this delegates to the documents
//              implementation.
//
//-------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    if (IsEqualGUID(guidService, SID_SBindHost))
    {
        RRETURN (THR(QueryInterface(iid, ppv)));
    }
    else // delegate to the CDocument we are sitting in
    {
        CDocument * pDocument = _pElem->Document();

        if (pDocument)
        {
            RRETURN(pDocument->QueryService(guidService, iid, ppv));
        }
    }
    
    RRETURN(E_NOINTERFACE);
}


//+-----------------------------------------------------------------------
//
//  member : CFilterBehaviorSite::RemoveFilterBehavior
//
//  SYNOPSIS : Detaches the behavior from the element and removes it
//
//-------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::RemoveFilterBehavior()
{
    HRESULT         hr;
    VARIANT_BOOL    fbResult;

    Assert(_pDXTFilterBehavior != NULL);
    Assert(_pElem);
    
    hr = THR(_pElem->removeBehavior(_lBehaviorCookie, &fbResult));

    ClearInterface(&_pDXTFilterBehavior);
    ClearInterface(&_pDXTFilterCollection);

    _strFullText.Free();

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::CreateFilterBehavior
//
//  Overview: 
//      Creates the filter behavior and attaches it to given element.
//
//-------------------------------------------------------------------------------
STDMETHODIMP 
CFilterBehaviorSite::CreateFilterBehavior(CElement * pElem)
{
    HRESULT             hr                  = S_OK;
    CDoc *              pDoc                = pElem->Doc();
    IElementBehavior *  pIElemBehavior      = NULL;
    ICSSFilter *        pICSSFilter         = NULL;
    BSTR                bstrBehaviorFind    = NULL;
    BSTR                bstrBehaviorAdd     = NULL;
    VARIANT             varParam;

    Assert(pElem);
    Assert(pDoc);
    Assert(pDoc->_pFilterBehaviorFactory);
    Assert(_pElem);
    Assert(NULL == _pDXTFilterBehavior);
    Assert(NULL == _pDXTFilterCollection);

    bstrBehaviorFind = SysAllocString(L"DXTFilterBehavior");

    if (NULL == bstrBehaviorFind)
    {
        hr = E_OUTOFMEMORY;

        goto Cleanup;
    }

    bstrBehaviorAdd = SysAllocString(L"#DXTFilterFactory#DXTFilterBehavior");

    if (NULL == bstrBehaviorAdd)
    {
        hr = E_OUTOFMEMORY;

        goto Cleanup;
    }

    // ##ISSUE: (mcalkins) Instead of creating a filter behavior, a better idea
    //          for the future is to just create a lightweight filter collection
    //          object and let it decide when and if a filter behavior needs to
    //          be created, attached to the element, or destroyed.

    // Create the filter behavior.

    hr = THR(pDoc->_pFilterBehaviorFactory->FindBehavior(bstrBehaviorFind, NULL,
                                                         NULL, 
                                                         &pIElemBehavior));

    if (hr)
    {
        goto Cleanup;
    }

    V_VT(&varParam)         = VT_UNKNOWN;
    V_UNKNOWN(&varParam)    = pIElemBehavior;
    
    hr = THR(_pElem->addBehavior(bstrBehaviorAdd, &varParam, &_lBehaviorCookie));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(pIElemBehavior->QueryInterface(__uuidof(IDXTFilterBehavior), 
                                            (void **)&_pDXTFilterBehavior));
    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(_pDXTFilterBehavior->GetFilterCollection(&_pDXTFilterCollection));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(pIElemBehavior->QueryInterface(IID_ICSSFilter, 
                                            (void **)&pICSSFilter));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(pICSSFilter->SetSite((ICSSFilterSite *)&_CSSFilterSite));

    if (hr)
    {
        goto Cleanup;
    }

Cleanup:

    SysFreeString(bstrBehaviorFind);
    SysFreeString(bstrBehaviorAdd);
    ReleaseInterface(pIElemBehavior);
    ReleaseInterface(pICSSFilter);

    RRETURN(hr);
}
//  Member: CFilterBehaviorSite::CreateFilterBehavior


//+-----------------------------------------------------------------------
//
//  member : NextFilterDescStr
//
//  SYNOPSIS : Advances to the next filter desription string.
//             Then end if current description is considered
//             1. The end of the string
//             2. A ) symbol
//             3. A space that is not followed by a ( symbol
//
//-------------------------------------------------------------------------

TCHAR *
NextFilterDescStr(LPTSTR pszToken)
{
    BOOL fInParen = FALSE;

    while (_istspace(*pszToken))
        pszToken++;       // Skip any leading whitespace

    do
    {
        // Skip until end of string or ) or space
        while(*pszToken && *pszToken != _T(')') && *pszToken != _T('(') && (!_istspace(*pszToken) || fInParen))
            pszToken++;
        // Skip the extra spaces
        while(_istspace(*pszToken))
            pszToken++;
        // If it is a ( that means we need to continue to parse
        if(*pszToken != _T('('))
            break;
        // We are in inside ( and we will not break on spaces any more
        fInParen = TRUE;
        pszToken++;
    } while(*pszToken);

    if(*pszToken == _T(')'))
        pszToken++; 

    // Skip the extra spaces
    while(_istspace(*pszToken))
        pszToken++;

    return pszToken;     
}


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::ParseAndAddFilters
//
//  Overview:
//      Parses the filter stirng adds all the filters to the filter behavior.
//
//-------------------------------------------------------------------------

MtDefine(CFilterBehaviorSite_ParseAndAddFilters_pszCopy, Locals, "CFilterBehaviorSite::ParseAndAddFilters pszCopy");
HRESULT
CFilterBehaviorSite::ParseAndAddFilters()
{
    HRESULT hr              = S_OK;
    LPTSTR  pszCopy         = NULL;
    LPTSTR  pszFilterName   = NULL;
    LPTSTR  pszNextFilter   = NULL;
    LPTSTR  pszParams       = NULL;
    LPTSTR  pszEnd          = NULL;

    if(_strFullText.Length() == 0)
    {
        goto done;
    }

    // TODO: handle OOM here
    MemAllocString(Mt(CFilterBehaviorSite_ParseAndAddFilters_pszCopy), _strFullText, &pszCopy);
    pszFilterName = pszCopy;

    while(pszFilterName && *pszFilterName)
    {
        pszEnd = pszNextFilter = NextFilterDescStr(pszFilterName);

        // Find to the last nonspace before the next token
        // and zero the end of the stirng
        if( pszEnd > pszFilterName)
        {
            pszEnd--;
            while(pszEnd > pszFilterName && _istspace(*pszEnd))
            {
                *pszEnd = _T('\0');;   // Go back to the last nonspace
                pszEnd--;
            }
        }

        // Remove the ) if any
        if ( *pszEnd == _T(')') )
            *pszEnd-- = _T('\0');

        // Now separate the name from the parameters
        pszParams = pszFilterName;
        while(*pszParams && *pszParams != _T('('))
            pszParams++;
        
        // and remove the ( from the parameters
        if (*pszParams == _T('('))
            *pszParams++ = _T('\0');

        // Now remove all the extra spaces
        while (_istspace(*pszParams))
            pszParams++;       // Skip any leading whitespace
        while (_istspace(*pszFilterName))
            pszFilterName++;       // Skip any leading whitespace
        pszEnd = pszParams + _tcslen(pszParams) - 1;
        while(pszEnd >= pszParams && _istspace(*pszEnd))
            *pszEnd-- = 0;
        pszEnd = pszFilterName + _tcslen(pszFilterName) - 1;
        while(pszEnd >= pszFilterName && _istspace(*pszEnd))
            *pszEnd-- = 0;

        // pszFilterName should point to the function name, and pszParams should point to the parameter string
        IGNORE_HR(AddFilterToBehavior(pszFilterName, pszParams));

        // Move to the next filter description
        pszFilterName = pszNextFilter;
    }

done:

    if (pszCopy)
    {
        MemFree(pszCopy);
    }

    return hr;
}
//  Member: CFilterBehaviorSite::ParseAndAddFilters


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::AddFilterToBehavior
//
//  Overview: 
//      Adds a filter with given name and parameters to the behavior.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CFilterBehaviorSite::AddFilterToBehavior(TCHAR * szName, TCHAR * szArgs)
{
    HRESULT  hr     = S_OK;
    BSTR     bstr   = NULL;
    CStr     str;

    str.Set(szName);
    str.Append(_T("(")); 
    str.Append(szArgs);
    str.Append(_T(")"));

    hr = THR(str.AllocBSTR(&bstr));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(_pDXTFilterCollection->AddFilter(bstr, DXTFTF_CSS, NULL, NULL));

    if (hr)
    {
        goto Cleanup;
    }

Cleanup:

    FormsFreeString(bstr);

    RRETURN(hr);
}
//  Member: CFilterBehaviorSite::AddFilterToBehavior


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::RemoveAllCSSFilters
//
//------------------------------------------------------------------------------
STDMETHODIMP
CFilterBehaviorSite::RemoveAllCSSFilters()
{
    Assert(_pDXTFilterCollection);

    return _pDXTFilterCollection->RemoveFilters(DXTFTF_CSS);
}
//  Member: CFilterBehaviorSite::RemoveAllCSSFilters


//+-----------------------------------------------------------------------
//
//  member : CFilterBehaviorSite::GetICSSFilter
//
//  SYNOPSIS : Returns the ICSSFilter pointer from the filter behavior
//
//-------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::GetICSSFilter(ICSSFilter **ppICSSFilter)
{
    Assert(_pDXTFilterBehavior);
    Assert(ppICSSFilter);
    *ppICSSFilter = NULL;
    if(!_pDXTFilterBehavior)
        RRETURN(E_FAIL);
    RRETURN(_pDXTFilterBehavior->QueryInterface(IID_ICSSFilter, (void **)ppICSSFilter));
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::GetFilter
//
//  Synopsis:   Given the number of the filter in the collection returns the 
//                  IDXTFilter. If number is -1 returns last filter
//----------------------------------------------------------------------------

STDMETHODIMP 
CFilterBehaviorSite::GetFilter(int nFilterNum, 
                               ICSSFilterDispatch ** ppCSSFilterDispatch)
{
    HRESULT                     hr          = S_OK;
    IHTMLFiltersCollection *    pFiltCol    = NULL;
    long                        nItems      = 0;
    CVariant                    varIn;
    CVariant                    varOut;

    Assert(ppCSSFilterDispatch);
    Assert(!(*ppCSSFilterDispatch));

    *ppCSSFilterDispatch = NULL;

    // Get the filter collection first.

    hr = THR(GetIHTMLFiltersCollection(&pFiltCol));

    if(hr)
        goto Cleanup;

    Assert(pFiltCol);
    
    // get the number of items
    hr = THR(pFiltCol->get_length(&nItems));
    if(hr)
        goto Cleanup;
    if(nFilterNum == -1)
        nFilterNum = nItems - 1;

    // Check for being in range
    if(nFilterNum < 0 || nFilterNum >= nItems)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get the filter at given postiotion
    V_VT(&varIn) = VT_I4; V_I4(&varIn) = nFilterNum;
    hr = pFiltCol->item(&varIn, &varOut);
    if(hr)
        goto Cleanup;
    if(V_VT(&varOut) != VT_DISPATCH)
    {
        AssertSz(FALSE, "item() on filters collection returned a non-dispatch pointer");
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(V_DISPATCH(&varOut)->QueryInterface(__uuidof(ICSSFilterDispatch), 
                                                 (void **)ppCSSFilterDispatch));

Cleanup:
    ReleaseInterface(pFiltCol);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::ApplyFilter
//
//  Synopsis:   Invoke apply on given transition filter, or the last one if 
//                  nFilterNum is -1
//              Invoke takes the first snapshot for the transition. Later 
//                  Play will take the second snapshot (end of transition)
//----------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::ApplyFilter(int nFilterNum)
{
    HRESULT                 hr      = S_OK;
    ICSSFilterDispatch *    pCSSFD  = NULL;

    hr = THR(GetFilter(nFilterNum, &pCSSFD));

    if(hr)
        goto Cleanup;

    hr = THR(pCSSFD->Apply());
    
Cleanup:

    ReleaseInterface(pCSSFD);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::PlayFilter
//
//  Synopsis:   Invoke play on given transition filter, or the last one if 
//                  nFilterNum is -1
//              Invoke takes the first snapshot for the transition. Then
//                  Play takes the second snapshot (end of transition)
//----------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::PlayFilter(int nFilterNum, float fDuration /* = 0 */)
{
    HRESULT                 hr          = S_OK;
    ICSSFilterDispatch *    pCSSFD      = NULL;
    CVariant                varDuration;

    hr = THR(GetFilter(nFilterNum, &pCSSFD));

    if(hr)
        goto Cleanup;

    if(fDuration != 0)
    {
        V_VT(&varDuration) = VT_R4;
        V_R4(&varDuration) = fDuration;
    }
    else
    {
        V_VT(&varDuration) = VT_ERROR;
    }

    hr = THR(pCSSFD->Play(varDuration));
    
Cleanup:

    ReleaseInterface(pCSSFD);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::SetSize
//
//  Synopsis:   Explicitly calls SetSize of the filter behavior.
//----------------------------------------------------------------------------

HRESULT
CFilterBehaviorSite::SetSize(CSize *pSize)
{
    HRESULT           hr;
    CPeerHolder     * pPeerHolder;

    pPeerHolder = _pElem->GetPeerHolder();
    if(!pPeerHolder)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pPeerHolder->GetSize(BEHAVIORLAYOUTMODE_NATURAL, *pSize,
                                            NULL, NULL, pSize));
Cleanup:
    RRETURN(hr);   
}

HRESULT
CFilterBehaviorSite::InvokeEx(DISPID dispidMember,
                 LCID lcid,
                 WORD wFlags,
                 DISPPARAMS * pdispparams,
                 VARIANT * pvarResult,
                 EXCEPINFO * pexcepinfo,
                 IServiceProvider *pSrvProvider)
{
    HRESULT hr = S_OK;

    if (!pvarResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch (dispidMember)
    {
        case DISPID_AMBIENT_PALETTE:
        V_VT(pvarResult) = VT_HANDLE;
        V_BYREF(pvarResult) = (void *)_pElem->Doc()->GetPalette();
        break;
    }

Cleanup:
    RRETURN(hr);
}


// defined in site\ole\OleBindh.cxx:
extern HRESULT
MonikerBind(
    CMarkup *               pMarkup,
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppv,
    BOOL                    fObject,
    DWORD                   dwCompatFlags);


BEGIN_TEAROFF_TABLE(CFilterBehaviorSite, IBindHost)
    TEAROFF_METHOD(CFilterBehaviorSite, CreateMoniker, createmoniker,
    (LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved))
    TEAROFF_METHOD(CFilterBehaviorSite, MonikerBindToStorage, monikerbindtostorage,
    (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
    TEAROFF_METHOD(CFilterBehaviorSite, MonikerBindToObject, monikerbindtoobject,
    (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
END_TEAROFF_TABLE()

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CreateMoniker, IBindHost
//
//  Synopsis:   Parses display name and returns a URL moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFilterBehaviorSite::CreateMoniker(LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved)
{
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchUrl = cBuf;
    HRESULT     hr;

    hr = THR(CMarkup::ExpandUrl(
            _pElem->GetMarkup(), szName, ARRAY_SIZE(cBuf), pchUrl, _pElem));
    if (hr)
        goto Cleanup;

    hr = THR(CreateURLMoniker(NULL, pchUrl, ppmk));
        if (hr)
        goto Cleanup;
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::MonikerBindToStorage, IBindHost
//
//  Synopsis:   Calls BindToStorage on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFilterBehaviorSite::MonikerBindToStorage(
    IMoniker * pmk,
    IBindCtx * pbc,
    IBindStatusCallback * pbsc,
    REFIID riid,
    void ** ppvObj)
{
    RRETURN1(MonikerBind(
        _pElem->GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        FALSE,
        0), S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::MonikerBindToObject, IBindHost
//
//  Synopsis:   Calls BindToObject on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFilterBehaviorSite::MonikerBindToObject(
    IMoniker * pmk,
    IBindCtx * pbc,
    IBindStatusCallback * pbsc,
    REFIID riid,
    void ** ppvObj)
{
    RRETURN1(MonikerBind(
        _pElem->GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        TRUE,
        0), S_ASYNCHRONOUS);
}


HRESULT
CFilterBehaviorSite::OnCommand ( COnCommandExecParams * pParm )
{
    CTExec(_pDXTFilterBehavior, pParm->pguidCmdGroup, pParm->nCmdID,
               pParm->nCmdexecopt, pParm->pvarargIn,
               pParm->pvarargOut);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::AddRef, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
CFilterBehaviorSite::CCSSFilterSite::AddRef()
{
    return MyFBS()->SubAddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::Release, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
CFilterBehaviorSite::CCSSFilterSite::Release()
{
    return MyFBS()->SubRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::QueryInterface, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

HRESULT
CFilterBehaviorSite::CCSSFilterSite::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
        QI_INHERITS((ICSSFilterSite *)this, ICSSFilterSite)
    }

    if (!*ppv)
    {
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::GetElement, ICSSFilterSite
//
//  Synopsis:   Returns the IHTMLElement pointer of the Element this site
//              belongs to.
//              This causes a hard AddRef on CElement. Clients are *not* to
//              cache this pointer.
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::CCSSFilterSite::GetElement( IHTMLElement **ppElement )
{
    RRETURN(MyFBS()->GetElement(ppElement));
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::FireOnFilterChangeEvent, ICSSFilterSite
//
//  Synopsis:   Fires an event for the extension object
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::CCSSFilterSite::FireOnFilterChangeEvent()
{
    RRETURN(MyFBS()->FireOnFilterChangeEvent());
}



//+---------------------------------------------------------------------------
//  Member:     IsCrossWebSiteNavigation
//
//  Synopsis:   Returns True if old and new markup or on different sites (domains)
//----------------------------------------------------------------------------

BOOL 
IsCrossWebSiteNavigation(CMarkup *pMarkupOld, CMarkup * pMarkupNew)
{
    BOOL            fSite = TRUE;
    BYTE            abSID1[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID1 = ARRAY_SIZE(abSID1);
    BYTE            abSID2[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID2 = ARRAY_SIZE(abSID2);
    HRESULT         hr;

    hr = THR(pMarkupOld->GetSecurityID(abSID1, &cbSID1));
    if(hr)
        goto Cleanup;

    hr = THR(pMarkupNew->GetSecurityID(abSID2, &cbSID2));
    if(hr)
        goto Cleanup;

    if(cbSID1 == cbSID2 && !memcmp(abSID1, abSID2, cbSID1))
        fSite = FALSE;

Cleanup:
    return fSite;
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::ApplyPageTransitions
//
//  Synopsis:    Takes the old markup (that goes away, but is still the active markup)
//              and the new markup and sets up the page transition from the old one
//              to the new. Takes the snapshot from the old markup
//               As we are not guaranteed to have a body or frameset element on the
//              new markup yet, we add the filter for the page transition to the root
//              element and then delegate the calls to it to the body or frameset of 
//              the old markup (during apply) and new markup (during play and later).
//----------------------------------------------------------------------------

HRESULT 
CDocument::ApplyPageTransitions(CMarkup *pMarkupOld, CMarkup *pMarkupNew)
{
    HRESULT                hr = E_FAIL;
    CElement             * pRootElement = NULL;
    CFilterBehaviorSite  * pFS;
    CFancyFormat         * pFF;
    CPageTransitionInfo  * pPgTransInfo = GetPageTransitionInfo();
    LPCTSTR                szFilterStr;
    BOOL                   fSiteSwitch = FALSE;
    CSize                  size;
    CElement             * pCanvasElement;

    TraceTag((tagPageTransitionTrace, "PGTRANS: Apply called with markup %08lX.", pMarkupNew));

    // Get the program options object
    OPTIONSETTINGS  * pos = Doc() ? Doc()->_pOptionSettings : NULL;

    // Check if page transitions are disabled in the registry
    if(pos && !pos->fPageTransitions)
    {
        TraceTag((tagPageTransitionTrace, "PGTRANS: Transitions disabled in registry"));
        hr = S_OK;
        goto Cleanup;
    }

    // Check if the navigation is across the domains
    fSiteSwitch = IsCrossWebSiteNavigation(pMarkupOld, pMarkupNew);

#if DBG == 1
    if(IsTagEnabled(tagPageTransitionsOn))
    {
        // Do a hardcoded transition for every navigation
        EnsurePageTransitionInfo();
        pPgTransInfo = GetPageTransitionInfo();
        Assert(pPgTransInfo);
        LPCTSTR szTransEnterString = pPgTransInfo->GetTransitionEnterString(fSiteSwitch);
        if(!szTransEnterString)
        {
            if(!fSiteSwitch)
                pPgTransInfo->SetTransitionString(_T("Page-Enter"), _T("revealTrans(duration=4, transition=11"));
            else
                pPgTransInfo->SetTransitionString(_T("Site-Enter"), _T("revealTrans(duration=4, transition=9"));
        }

    }
#endif

    // If there is a transtion string set the state to requested
    if(pPgTransInfo && pPgTransInfo->GetTransitionEnterString(fSiteSwitch) &&
                pPgTransInfo->GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_NOTSTARTED)
        pPgTransInfo->SetPageTransitionState(CPageTransitionInfo::PAGETRANS_REQUESTED);


    // No transition info, nothing to do
    if(!HasPageTransitionInfo() )
    {
        TraceTag((tagPageTransitionTrace, "  PGTRANS: No page transition setup for switch to markup %08lX", pMarkupNew, NULL));
        hr = S_FALSE;
        goto Cleanup;
    }

    pCanvasElement = pMarkupOld->GetCanvasElement();
    if(!pCanvasElement)
    {
        // The old markup does not have a client element, bail out
        hr = S_FALSE;
        goto Cleanup;
    }

    // Add the filter behavior to the root of the new markup
    pRootElement = (CElement *)pMarkupNew->Root();
    if(!pRootElement)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // TODO: This is BAD BAD BAD.  The Fancy format is const for a reason.
    pFF = (CFancyFormat *)pRootElement->GetFirstBranch()->GetFancyFormat();
    Assert(pFF);

    // Set the filter string forom the transtion info structure
    pPgTransInfo = GetPageTransitionInfo();
    szFilterStr = (LPTSTR)pPgTransInfo->GetTransitionEnterString(fSiteSwitch);
    if(!szFilterStr || _tcslen(szFilterStr) == NULL)
    {
        // We do not have the right type fo the Transition
        TraceTag((tagPageTransitionTrace, "  PGTRANS: Apply: Do not have the right trans. set. Trans. cleaned up"));
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = MemAllocString( Mt(CFancyFormat_pszFilters), szFilterStr, &(pFF->_pszFilters) );
    if(hr)
    {
        goto Cleanup;
    }
    
    // Set the old markup. This will cause the paint calls to go to the root of 
    //  the old markup
    pPgTransInfo->SetTransitionFromMarkup(pMarkupOld);

    // Add the filter in pFF->_pszFilters to the root element
    hr = THR(pRootElement->AddFilters());

    Assert(pFF->_pszFilters);
    MemFree(pFF->_pszFilters);
    pFF->_pszFilters = NULL;

    if(hr)
    {
        // Something went totally wrong.
        AssertSz(FALSE, "Adding filters to the root for page transitions failed");
        goto Cleanup;
    }

    // Save the new markup in transitioninfo
    pPgTransInfo->SetTransitionToMarkup(pMarkupNew);

    pFS = pRootElement->GetFilterSitePtr();
    if(pFS == NULL)
    {
        hr = E_FAIL;
        AssertSz(FALSE, "Filter Site has not been created in page transition code");
        goto Cleanup;
    }

    // Make sure GetSize is called on the filter right now. If will wait long enough
    // it will eventually be called by the layout code, but we need it right now
    hr = THR(pCanvasElement->GetBoundingSize(size));
    if(hr)
        goto Cleanup;

    if(size.IsZero())
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    hr = THR(pFS->SetSize(&size));
    if(hr)
        goto Cleanup;

     // Invoke apply on the filter number 0 using the old document
    hr = THR(pFS->ApplyFilter(0));
    if(hr)
    {
        AssertSz(FALSE, "Apply Filter failed in page transition code");
        goto Cleanup;
    }

    // Set the state to Applied()
    pPgTransInfo->SetPageTransitionState(CPageTransitionInfo::PAGETRANS_APPLIED);

Cleanup:
    if(pPgTransInfo)
    {
        // Transition from markup will be deleted soon
        pPgTransInfo->SetTransitionFromMarkup(NULL);
        if(hr)
        {
            TraceTag((tagPageTransitionTrace, "  PGTRANS: Error occured in Apply. Trans. cleaned up"));
            CleanupPageTransitions(0);
        }
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::PlayPageTransitions
//
//  Synopsis:   Takes the second snapshot (of the page we are naviagting to) and
//              starts the page transition
//----------------------------------------------------------------------------

HRESULT
CDocument::PlayPageTransitions(BOOL fClenupIfFailed /* = TRUE */)
{
    HRESULT                hr;
    CFilterBehaviorSite  * pFS;
    CElement             * pRootElement;
    CElement             * pCanvasElement;
    CMarkup              * pMarkup = NULL;

    if(!HasPageTransitionInfo() ||  GetPageTransitionInfo()->GetPageTransitionState() 
                        != CPageTransitionInfo::PAGETRANS_APPLIED)
    {
        // We should have called Apply before if we really have a page transition
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(!GetPageTransitionInfo()->GetTransitionFromMarkup());

    pMarkup = GetPageTransitionInfo()->GetTransitionToMarkup();

    TraceTag((tagPageTransitionTrace, "PGTRANS: Play called with markup %08lX.", pMarkup));

    // If we do not have a body or frameste yet we cannot Play
    pCanvasElement = pMarkup->GetCanvasElement();
    if(pCanvasElement == NULL) 
    {
        TraceTag((tagPageTransitionTrace, "  PGTRANS: Not ready to play yet. Markup %08lX.", pMarkup));
        hr = fClenupIfFailed ? S_FALSE : S_OK;
        goto Cleanup;
    }

    pCanvasElement->Invalidate();

    // Filter behavior is on the root element
    pRootElement = (CElement *)pMarkup->Root();

    pFS = pRootElement->GetFilterSitePtr();
    if(pFS == NULL)
    {
        AssertSz(FALSE, "Filter Site has not been created");
        hr = E_FAIL;
        goto Cleanup;
    }

    // make sure there are no pending layout requests that could cause an EnsureView
    // at inapproprite times
    Doc()->GetView()->RemovePendingEnsureViewCalls();
     
    // Start playing the transition
    hr = THR(pFS->PlayFilter(0));
    if(hr)
        goto Cleanup;
    
    // Set the state to played
    GetPageTransitionInfo()->SetPageTransitionState(CPageTransitionInfo::PAGETRANS_PLAYED);

Cleanup:
    if(HasPageTransitions() && (FAILED(hr) || (hr == S_FALSE && fClenupIfFailed && 
            GetPageTransitionInfo()->GetPageTransitionState() != CPageTransitionInfo::PAGETRANS_PLAYED)))
    {
        TraceTag((tagPageTransitionTrace, "  PGTRANS: Play failed. Cleaning up with markup %08lX.", pMarkup));
        CleanupPageTransitions(0);
    }
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//  Member:     CDocument::CleanupPageTransitions
//
//  Synopsis:     We are done with the transition, free the peer and cleanup the 
//              fields on the transition info. We do not touch the transition strings,
//              bacause page-exit strings will be used later
//----------------------------------------------------------------------------

void 
CDocument::CleanupPageTransitions(DWORD_PTR fInPassivate)
{
    CElement              * pRootElement;
    CMarkup               * pMarkup;
    CFilterBehaviorSite   * pFS;

    TraceTag((tagPageTransitionTrace, "PGTRANS: Cleanup Page Transition Request Received"));

    if(HasPageTransitionInfo())
    {
        pMarkup = GetPageTransitionInfo()->GetTransitionToMarkup();
        if(pMarkup)
        {
            pMarkup->Doc()->_fPageTransitionLockPaint = FALSE;
            pRootElement = (CElement *)pMarkup->Root();

            if(pRootElement)
            {
                pFS = pRootElement->GetFilterSitePtr();
                Assert(pFS);

                pFS->RemoveFilterBehavior();
            }
        }

        GetPageTransitionInfo()->Reset();

    }

    if(!fInPassivate)
    {
        // Remove the posted calls, we have already cleaned up ourselvs
        GWKillMethodCall(this, ONCALL_METHOD(CDocument, CleanupPageTransitions, cleanuppagetransitions), 0);
    }
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::PostCleanupPageTansitions
//
//  Synopsis:     Call CleanupPageTransition asynchronously
//----------------------------------------------------------------------------

void 
CDocument::PostCleanupPageTansitions()
{
  TraceTag((tagPageTransitionTrace, "PGTRANS: Posting Cleanup Page Transition Request"));
  THR(GWPostMethodCall(this, ONCALL_METHOD(CDocument, CleanupPageTransitions, cleanuppagetransitions), 0, TRUE, "CDocument::CleanupPageTransitions"));
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::SetUpPageTransitionInfo
//
//  Synopsis:     Save the page transition string for future use. If pchHttpEquiv
//              is not one of the page-transitions, we ignore the information
//----------------------------------------------------------------------------

HRESULT 
CDocument::SetUpPageTransitionInfo(LPCTSTR pchHttpEquiv, LPCTSTR pchContent)
{
    HRESULT           hr;

    TraceTag((tagPageTransitionTrace, "PGTRANS: Setting up page transition for '%ls' to '%ls'", pchHttpEquiv, pchContent));

    hr = THR(EnsurePageTransitionInfo());
    if(hr)
        goto Cleanup;
    GetPageTransitionInfo()->SetTransitionString(pchHttpEquiv, pchContent);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     CPageTransitionInfo::ShiftTransitionStrings
//
//  Synopsis:     This will move the exit strings into the enter string positions,
//              so next navigation automatically uses them
//----------------------------------------------------------------------------

void 
CPageTransitionInfo::ShiftTransitionStrings()
{
    _cstrTransitionStrings[tePageEnter].Set(_cstrTransitionStrings[tePageExit]);
    _cstrTransitionStrings[tePageExit].Free();
    _cstrTransitionStrings[teSiteEnter].Set(_cstrTransitionStrings[teSiteExit]);
    _cstrTransitionStrings[teSiteExit].Free();
}


//+---------------------------------------------------------------------------
//  Member:     CPageTransitionInfo::SetTransitionString
//
//  Synopsis:    First param is transition type that can be "page-enter", "page-exit",
//              "site-enter" or "site-exit". If it is something else it is ignored.
//               The secod parameter is the transition string.
//----------------------------------------------------------------------------

void 
CPageTransitionInfo::SetTransitionString(LPCTSTR szType,  LPCTSTR szStr)
{
    if(!szType || !_tcslen(szType))
        return;

    for(int i = 0; i < teNumEvents; i++)
    {
        if(!_tcsicmp(szType, TransitionEventNames[i]))
        {
            SetTransitionString((TransitionEvent) i, szStr);
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//  Member:     CPageTransitionInfo::GetTransitionEnterString
//
//  Synopsis:    Returns the "enter" string for site (fSiteNavigation is TRUE)
//              or page transiton.
//               Returns NULL if there is no string
//----------------------------------------------------------------------------

LPCTSTR 
CPageTransitionInfo::GetTransitionEnterString(BOOL fSiteNavigation) const
{
    TransitionEvent te;
    LPCTSTR         szStr;

    te = fSiteNavigation ? teSiteEnter : tePageEnter;
    szStr = (LPCTSTR)_cstrTransitionStrings[te];
    if(fSiteNavigation && (!szStr || !_tcslen(szStr)))
    {
        // Not site transition, return the page transition instead
        szStr = (LPCTSTR)_cstrTransitionStrings[tePageEnter];
    }

    if(szStr && !_tcslen(szStr))
        szStr = NULL;

    return szStr;
}


//+---------------------------------------------------------------------------
//  Member:     Reset::Reset
//
//  Synopsis:    Clean up the fields in the transition info structure that 
//              are not needed across page transitions
//----------------------------------------------------------------------------

void 
CPageTransitionInfo::Reset() 
{ 
    Assert(!GetTransitionFromMarkup());
    SetPageTransitionState(PAGETRANS_NOTSTARTED); 
    SetTransitionToMarkup(NULL);
}


void 
CPageTransitionInfo::SetPageTransitionState(PAGE_TRANSITION_STATE eNewState) 
{ 
    _ePageTranstionState = eNewState;
    if(eNewState == CPageTransitionInfo::PAGETRANS_APPLIED)
    {
        Assert(GetTransitionToMarkup());
        GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = TRUE;
    }
    else
    {
        if(GetTransitionToMarkup())
            GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = FALSE;
    }
}

void 
CPageTransitionInfo::SetTransitionToMarkup(CMarkup *pMarkup) 
{ 
    if(GetTransitionToMarkup())
        GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = FALSE;
    else if(pMarkup)
        pMarkup->Doc()->_fPageTransitionLockPaint = FALSE;
    
    _pMarkupTransitionTo = pMarkup; 
}



CPageTransitionInfo::~CPageTransitionInfo()
{
    if(GetTransitionToMarkup())
        GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\lstcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       numconv.cxx
//
//  Contents:   Numeral String Conversions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TEXTEDIT_H_
#define X_TEXTEDIT_H_
#include "textedit.h"
#endif

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif

#ifndef X_ELEMENT_H_
#define X_ELEMENT_H_
#include "element.h"
#endif

#ifndef X_LSTCACHE_HXX_
#define X_LSTCACHE_HXX_
#include "lstcache.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member:     Set( wLevel, pLI, e )
//
//  Purpose:    Sets an entry in one of the two index caches.  The index
//              caches are CArray<LONG>'s.  They grow as necessary, but
//              do not ever shrink.
//
//              One important side effect is that the most current CListIndex
//              is stashed in liCurrentIndexValue.  This facilitates the
//              speedy query at render time.
//
//  Arguements: wLevel is a zero-based index into the cache. Note that
//              a level of zero indicates that there are no list containers.
//              lValue is the new value
//              e is either INDEXCACHE_TOP or INDEXCACHE_CURRENT
//
//  Returns:    Nothing.
//
//----------------------------------------------------------------------------

HRESULT
CListCache::Set(
    WORD wLevel,
    struct CListIndex * pLI,
    enum INDEXCACHE e)
{
    HRESULT hr = S_OK;

    // Make space if necessary.

    if (wLevel >= Depth(e))
    {
        if (!_pCache->_aryIndex[e].Add( 1 + wLevel - Depth(e), NULL ))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // Set the value.  Cache the value in liCurrentIndexValue for
    // speedy exectution of GetListIndex().

    *(_pCache->_aryIndex[e].Elem( wLevel )) = liCurrentIndexValue = *pLI;

    // Set the bit field, indicate that the array entry is valid.

    CListCache::ValidateLevel( wLevel, e );

Cleanup:

    RRETURN(hr);
}

HRESULT
CListCache::Instantiate()
{
    Assert( !Instantiated() );

    _pCache = new CListCacheInst;

    if (_pCache)
    {
        PrepareListIndexForRender();
        _pCache->_yScroll = 0;
    }

    return _pCache ? S_OK : E_OUTOFMEMORY;
}

void
CListCache::PrepareListIndexForRender( void )
{
    if (Instantiated())
    {
        ZeroMemory( _pCache->_abIndex[INDEXCACHE_CURRENT], (CListing::MAXLEVELS + 7) >> 3);

        _pCache->_aryIndex[INDEXCACHE_CURRENT].CopyFrom( _pCache->_aryIndex[INDEXCACHE_TOP] );
    }
}

#if DBG==1
void
CListCache::Dump()
{
    if (Instantiated())
    {
        int i;

        for (i=0;i<2;i++)
        {
            enum INDEXCACHE e = i ? INDEXCACHE_CURRENT : INDEXCACHE_TOP;
            char ach[256];
            char * pch = ach;
            WORD wLevel;

            pch += wsprintfA(ach, "%s: ", e ? "cur" : "top");

            for (wLevel = 0; wLevel <= Depth(e); wLevel++)
            {
                if (Valid(wLevel,e))
                {
                    CListIndex LI = GetAt(wLevel, e);

                    pch += wsprintfA(pch, "%3d ", LI.lValue);
                }
                else
                {
                    StrCpyA( pch, "--- " );
                    pch += 4;
                }
            }

            StrCpyA(pch, "\r\n");
            
            OutputDebugStringA(ach);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\mime64.cpp ===
/* mime64 */
/* MIME base64 encoder/decoder by Karl Hahn  hahn@lds.loral.com  3-Aug-94 */
/* Modified into an API by georgep@microsoft.com 8-Jan-96 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MIME64_HXX_
#define X_MIME64_HXX_
#include "mime64.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif


#define INVALID_CHAR (ULONG)-2
#define IGNORE_CHAR (ULONG)-1


static ULONG BinaryFromASCII2( TCHAR alpha )
{
    switch (alpha)
    {
    case _T(' '):
    case _T('\t'):
    case _T('\n'):
    case _T('\r'):
        return(IGNORE_CHAR);

    default:
        if      ( (alpha >= _T('A')) && (alpha <= _T('Z')))
        {
            return (int)(alpha - _T('A'));
        }
        else if ( (alpha >= _T('a')) && (alpha <= _T('z')))
        {
            return 26 + (int)(alpha - _T('a'));
        }
        else if ( (alpha >= _T('0')) && (alpha <= _T('9')))
        {
            return 52 + (int)(alpha - _T('0'));
        }

        return(INVALID_CHAR);

    case _T('+'):
        return 62;

    case _T('/'):
        return 63;
    }
}


struct BinASCIIData
{
    BOOL m_bInited;
    ULONG m_anBinary[256];
} g_cBinASCIIData = { FALSE } ;

static void InitTables()
{
    if (g_cBinASCIIData.m_bInited)
    {
        return;
    }

    for (int i=0; i<256; ++i)
    {
        // Note this is thread-safe, since we always set to the same value
        g_cBinASCIIData.m_anBinary[i] = BinaryFromASCII2((TCHAR)i);
    }

    // Set after initing other values to make thread-safe
    g_cBinASCIIData.m_bInited = TRUE;
}


inline static ULONG BinaryFromASCII( TCHAR alpha )
{
    return(g_cBinASCIIData.m_anBinary[alpha]);
}


HRESULT Mime64Decode(LPCMSTR pStrData, LPSTREAM *ppstm)
{
    *ppstm = NULL;

    InitTables();

    HGLOBAL hGlobal = GlobalAlloc(GPTR, (_tcslen(pStrData)*3)/4 + 2);
    LPBYTE pData = (BYTE *)GlobalLock(hGlobal);

    if (!pData)
    {
        return(E_OUTOFMEMORY);
    }

    int cbData = 0;
    int shift = 0;
    unsigned long accum = 0;

    // This loop will ignore white space, but quit at any other invalid characters
    for ( ; ; ++pStrData)
    {
        unsigned long value = BinaryFromASCII(*pStrData);

        if ( value < 64 )
        {
            accum <<= 6;
            shift += 6;
            accum |= value;

            if ( shift >= 8 )
            {
                shift -= 8;
                value = accum >> shift;
                pData[cbData++] = (BYTE)value & 0xFF;
            }
        }
        else if (IGNORE_CHAR == value)
        {
            continue;
        }
        else
        {
            break;
        }
    }

    IStream *pstm;
    HRESULT hr = THR(CreateStreamOnHGlobal(hGlobal, TRUE, &pstm));
    if(hr)
    {
        RRETURN(hr);
    }

    ULARGE_INTEGER ulibSize;

    ulibSize.HighPart = 0;
    ulibSize.LowPart = cbData;

    pstm->SetSize(ulibSize);
    *ppstm = pstm;

    return(NOERROR);
}


#define CHARS_PER_LINE 60


HRESULT Mime64Encode(LPBYTE pData, UINT cbData, LPTSTR pchData)
{
    static TCHAR const alphabet[] = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

    int shift = 0;
    int save_shift = 0;
    unsigned long accum = 0;
    TCHAR blivit;
    unsigned long value;
    BOOL quit = FALSE;

    while ( ( cbData ) || (shift != 0) )
    {
        if ( ( cbData ) && ( quit == FALSE ) )
        {
            blivit = *pData++;
            --cbData;
        }
        else
        {
            quit = TRUE;
            save_shift = shift;
            blivit = 0;
        }

        if ( (quit == FALSE) || (shift != 0) )
        {
            value = (unsigned long)blivit;
            accum <<= 8;
            shift += 8;
            accum |= value;
        }

        while ( shift >= 6 )
        {
            shift -= 6;
            value = (accum >> shift) & 0x3Fl;

            blivit = alphabet[value];

            *pchData++ = blivit;

            if ( quit != FALSE )
            {
                shift = 0;
            }
        }
    }

    if ( save_shift == 2 )
    {
        *pchData++ = _T('=');
        *pchData++ = _T('=');
    }
    else if ( save_shift == 4 )
    {
        *pchData++ = _T('=');
    }

    *pchData++ = 0;

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\listhlp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       listhlp.cxx
//
//  Contents:   List helpers.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include "eli.hxx"
#endif

#ifndef X_EOLIST_HXX_
#define X_EOLIST_HXX_
#include "eolist.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

//+----------------------------------------------------------------------------
//
//  Function:   IsBlockListElement
//
//  Synopsis:   Callback used by SearchBranchForCriteria to determine whenever
//              a node is a block list element.
//
//-----------------------------------------------------------------------------

BOOL IsBlockListElement(
    CTreeNode * pNode, 
    void *pvData)
{
    return pNode->Element()->IsFlagAndBlock(TAGDESC_LIST);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsListItemNode
//
//  Synopsis:   Callback used by SearchBranchForCriteriaInStory to determine 
//              if a node is a list item (LI or display:list-item).
//
//-----------------------------------------------------------------------------

BOOL IsListItemNode(
    CTreeNode * pNode)
{
    return IsListItem(pNode, NULL);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsListItem
//
//  Synopsis:   Determines if a node is a list item (LI or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (pNode->Tag() == ETAG_LI)
        return TRUE;
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   IsBlockListItem
//
//  Synopsis:   Determines if a node is a block list item (LI or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsBlockListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    if (pNode->Tag() == ETAG_LI && pNode->_fBlockNess)
        return TRUE;
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   IsGenericListItem
//
//  Synopsis:   Determines if a node is a generic list item 
//              (LI, DD, DT or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsGenericListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (pNode->Element()->HasFlag(TAGDESC_LISTITEM))
        return TRUE;
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   IsGenericBlockListItem
//
//  Synopsis:   Determines if a node is a generic block list item 
//              (LI, DD, DT or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsGenericBlockListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    if (pNode->Element()->HasFlag(TAGDESC_LISTITEM) && pNode->_fBlockNess)
        return TRUE;
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   NumberOrBulletFromStyle
//
//  Synopsis:   Does the style type denote number or bullet type list?
//
//-----------------------------------------------------------------------------

CListing::LISTING_TYPE NumberOrBulletFromStyle(
    styleListStyleType listType)
{
    switch (listType)
    {
        case styleListStyleTypeNotSet:
        case styleListStyleTypeNone:
        case styleListStyleTypeDisc:
        case styleListStyleTypeCircle:
        case styleListStyleTypeSquare:
            return (CListing::BULLET);
            break;
    }
    return (CListing::NUMBERING);
}

//+------------------------------------------------------------------------
//
//  Member:     GetValidValue
//
//  Synopsis:   This is the main function which returns the list index value
//              for a list item. Its only called by the renderer.
//
//-------------------------------------------------------------------------

void GetValidValue(
    CTreeNode * pNodeListItem,
    CTreeNode * pNodeList,
    CMarkup * pMarkup,
    CElement * pElementFL,
    CListValue * pLV)
{
    const CParaFormat *pPF;

    Assert(pNodeListItem);
    Assert(pLV);

    // Delegate LI's to LI related calculator
    if (   pNodeListItem->Tag() == ETAG_LI
        && !pNodeListItem->GetFancyFormat()->IsListItem())
    {
        CLIElement * pLIElement = DYNCAST(CLIElement, pNodeListItem->Element());
        pLIElement->GetValidValue(pLV, pMarkup, pNodeListItem, pNodeList, pElementFL);
        return;
    }

    pPF = pNodeListItem->GetParaFormat();
    const CListing & listing = pPF->GetListing();

    pLV->_style  = listing.GetStyle();
    pLV->_lValue = 0;

    // If the current list items is an LI, and it has a 'value', use it.
    if (pNodeListItem->Tag() == ETAG_LI)
    {
        CLIElement * pLIElement = DYNCAST(CLIElement, pNodeListItem->Element());
        if (pLIElement->GetAAvalue() > 0)
        {
            pLV->_lValue = pLIElement->GetAAvalue();
        }
    }

    if (pLV->_lValue == 0)
    {
        LONG lStart  = 0;
        pLV->_lValue = 1;

        // pNodeList was deduced by the caller by calling FindMyListContainer()
        // If now this list item is not LI/has display:list-item, then 
        // then that node information is not useful. The pNodeList for
        // this item is the direct parent.
        pNodeList = pNodeListItem->Parent();

        // If containing element is a list element and it has starting number, use it.
        if (pNodeList->Tag() == ETAG_OL && IsBlockListElement(pNodeList, NULL))
        {
            COListElement * pOListElement = DYNCAST(COListElement, pNodeList->Element());
            if (pOListElement->GetAAstart() > 0)
            {
                lStart = pOListElement->GetAAstart();
            }
        }

        // For numbered list item retrieve the number.
        if (   CListing::NUMBERING == NumberOrBulletFromStyle(listing.GetStyle())
            && pNodeList)
        {
            CTreeNode * pNodeSibling;
            CChildIterator ci(pNodeList->Element(), pNodeListItem->Element());

            // Walk back siblings collection
            while ((pNodeSibling = ci.PreviousChild()) != NULL)
            {
                const CFancyFormat * pFFSibling = pNodeSibling->GetFancyFormat();

                if (   pFFSibling->_bDisplay != styleDisplayNone
                    && pNodeSibling->Tag() != ETAG_RAW_COMMENT)
                {
                    // If a sibling is a list item LI and it has a 'value', use it as a base number.
                    if (   pNodeSibling->Tag() == ETAG_LI
                        && pFFSibling->IsListItem())
                    {
                        CLIElement * pLIElement = DYNCAST(CLIElement, pNodeSibling->Element());
                        if (pLIElement->GetAAvalue() > 0)
                        {
                            pLV->_lValue += pLIElement->GetAAvalue();
                            break;
                        }
                    }

                    // Otherwise continue enumeraiton.
                    ++pLV->_lValue;
                }
            }

            // If we didn't find LI with a valid 'value' attribute, add list starting number.
            if (!pNodeSibling && lStart > 0)
            {
                pLV->_lValue += lStart - 1;
            }
        }
    }

    if (pLV->_style == styleListStyleTypeNotSet)
        pLV->_style  = styleListStyleTypeDisc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\numconv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       numconv.cxx
//
//  Contents:   Numeral String Conversions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#if defined(UNIX) || defined(_MAC)
/***
*wchar_t *_wcsrev(string) - reverse a wide-character string in place
*
*Purpose:
*       Reverses the order of characters in the string.  The terminating
*       null character remains in place (wide-characters).
*
*Entry:
*       wchar_t *string - string to reverse
*
*Exit:
*       returns string - now with reversed characters
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsrev (
        wchar_t * string
        )
{
        wchar_t *start = string;
        wchar_t *left = string;
        wchar_t ch;

        while (*string++)                 /* find end of string */
                ;
        string -= 2;

        while (left < string)
        {
                ch = *left;
                *left++ = *string;
                *string-- = ch;
        }

        return(start);
}

#endif // UNIX

//+----------------------------------------------------------------------
//
//  Function:   RomanNumberHelper( pn, nDivisor, szBuffer, szRomanLetter )
//
//              Computes the roman numeral for a single decimal-digit
//              equivalent.
//
//              *pn contains the current value.  We determine the string
//              that corresponds to a single decimal digit.
//
//              nDivisor is the power of 10 for which we are computing
//              the substring.
//
//              szBuffer is the pointer into the buffer into which the
//              string is written.
//
//              szRomanLetter is a three character buffer which contains
//              the 1-digit, the 5-digit, and the 10-digit, in that
//              order.  For example, when computing the unit position,
//              szRomanLetter is "ivx".
//
//  Returns:    The value of *pn is changed to the modulo of the original.
//              The roman 'digit' is written into szBuffer.
//              The updated string pointer into szBuffer is returned.
//
//-----------------------------------------------------------------------

static TCHAR * RomanNumberHelper(
    LONG *pn,
    LONG nDivisor,
    TCHAR * szBuffer,
    TCHAR * szRomanLetter )
{
    LONG digit = *pn / nDivisor;
    *pn %= nDivisor;

    if (digit > 4 && digit < 9)
        *szBuffer++ = szRomanLetter[1];

    switch (digit%5)
    {
        case 3:
            *szBuffer++ = szRomanLetter[0];
        case 2:
            *szBuffer++ = szRomanLetter[0];
        case 4:
        case 1:
            *szBuffer++ = szRomanLetter[0];
            break;
    }

    if (4 == digit)
        *szBuffer++ = szRomanLetter[1];
    else if (9 == digit)
        *szBuffer++ = szRomanLetter[2];

    return szBuffer;
}
                       
//+----------------------------------------------------------------------
//
//  Function:   RomanNumber( n, szBuffer, achRomanChars )
//
//              Convert a long value to its roman numeral equivalent.
//              We can process any value between 1 and 3999.
//              We call RomanNumberHelper() for each power of 10.
//
//  Returns:    A roman numeral string in achRomanChars[].
//
//-----------------------------------------------------------------------

static void RomanNumber(
    LONG    n,
    TCHAR * szBuffer,
    TCHAR * achRomanChars )
{
    // Emulate IE behavior -- numbers in excess of 3999 just render as
    // arabic numerals.  Netscape does weird module + offset; 4000 is
    // rendered as ii, etc.

    if (n < 1 || n > 3999)
    {
        NumberToNumeral(n, szBuffer);
    }
    else
    {
        TCHAR *p = szBuffer;

        p = RomanNumberHelper( &n, 1000, p, achRomanChars );
        p = RomanNumberHelper( &n, 100, p, achRomanChars + 3 );
        p = RomanNumberHelper( &n, 10, p, achRomanChars + 6 );
        p = RomanNumberHelper( &n, 1, p, achRomanChars + 9 );

        *p++ = _T('.');
        *p = _T('\0');
    }
}
                          
//+----------------------------------------------------------------------
//
//  Function:   NumberToRomanUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to it's roman numeral equivalent.
//              The letters used here are in lowercase.
//
//  Returns:    Returns a roman number in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToRomanLower(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    RomanNumber(n, achBuffer, _T("m??cdmxlcivx"));
}

//+----------------------------------------------------------------------
//
//  Function:   NumberToRomanUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to it's roman numeral equivalent.
//              The letters used here are in uppercase.
//
//  Returns:    Returns a roman number in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToRomanUpper(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    RomanNumber(n, achBuffer, _T("M??CDMXLCIVX"));
}

//+----------------------------------------------------------------------
//
//  Function:   AlphaNumber( n, szBuffer, chBase )
//
//              A helper function for NumberToRoman(Upper|Lower).
//              Pass in either 'a' or 'A' in chBase to get an
//              'alphabetic' number of n.
//
//              Zero are represented as @. (a hack.)
//              Negative numbers are represented as would decimal
//              numbers, ie with a preceeding minus sign (another hack.)
//
//  Returns:    Returns an 'alphabetic' number in szBuffer.
//
//-----------------------------------------------------------------------

static void AlphaNumber(
    LONG    n,
    TCHAR * szBuffer,
    TCHAR   chBase )
{
    TCHAR *p = szBuffer;

    if (n)
    {
        LONG m = abs(n);

        // It is easier to compute from the least-significant 'digit',
        // so we generate the string backwards, and then reverse it
        // at the end.
        
        *p++ = '.';

        while (m)
        {
            m--;
            *p++ = (TCHAR)(chBase + (m % 26));
            m /= 26;        
        }

        if (n < 0)
        {
            // A nerdly hack to represent negative numbers.

            *p++ = _T('-');
        }

        *p = _T('\0');

        _tcsrev(szBuffer);

        
    }
    else
    {
        // A nerdly hack to represent zero.

        *p++ = _T('@');
        *p++ = _T('.');
        *p++ = _T('\0');
    }
}
                          
//+----------------------------------------------------------------------
//
//  Function:   NumberToAlphaUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to a 'alphabetic' string.  An
//              alphabetic string is a,b,..z,aa,ab,..,ba,..,zz,aaa, etc.
//              The letters used here will be in lowercase.
//
//  Returns:    A string in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToAlphaLower(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    AlphaNumber(n, achBuffer, _T('a'));
}

//+----------------------------------------------------------------------
//
//  Function:   NumberToAlphaUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to a 'alphabetic' string.  An
//              alphabetic string is A,B,..Z,AA,AB,..,BA,..,ZZ,AAA, etc.
//              The letters used here will be in uppercase.
//
//  Returns:    A string in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToAlphaUpper(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    AlphaNumber(n, achBuffer, _T('A'));
}

//+----------------------------------------------------------------------
//
//  Function:   NumberToNumeral( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to a numeric string.
//
//  Returns:    A string in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToNumeral(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    _ltot(n, achBuffer, 10);
    _tcscat(achBuffer, _T("."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\optshold.cxx ===
//=================================================================
//
//   File:      optshold.cxx
//
//  Contents:   COptionsHolder class
//
//  Classes:    COptionsHolder
//              CFontNameOptions
//              CFontSizeOptions
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#define _cxx_
#include "optshold.hdl"

MtDefine(COptionsHolder, ObjectModel, "COptionsHolder")
MtDefine(COptionsHolder_aryFontSizeObjects_pv, COptionsHolder, "COptionsHolder::_aryFontSizeObjects::_pv")
MtDefine(CFontNameOptions, ObjectModel, "CFontNameOptions")
MtDefine(CFontNameOptions_aryFontNames_pv, CFontNameOptions, "CFontNameOptions::_aryFontNames::_pv")
MtDefine(CFontSizeOptions, ObjectModel, "CFontSizeOptions")
MtDefine(CFontSizeOptions_aryFontSizes_pv, CFontSizeOptions, "CFontSizeOptions::_aryFontSize::_pv")

#define  START_OF_SAMPLE_STRINGS    0x0700

extern CGlobalCriticalSection   g_csFile;
extern TCHAR                    g_achSavePath[];
extern BSTR                     g_bstrFindText;

HRESULT
SetFindText(LPCTSTR bstr)
{
    LOCK_GLOBALS;

    FormsFreeString(g_bstrFindText);
    g_bstrFindText = NULL;
    RRETURN(FormsAllocString(bstr, &g_bstrFindText));
}


//+-------------------------------------------------------------------
//
//  Callbacks:   GetFont*Proc
//
//  These procedures are called by the EnumFontFamilies and EnumFont calls.
//  It fills the combobox with the font facename and the size
//
//--------------------------------------------------------------------

int CALLBACK
GetFontNameProc(LOGFONT FAR    * lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    // Do not show vertical fonts
    if (lParam && lplf->lfFaceName[0] != _T('@'))
        ((CFontNameOptions *)lParam)->AddName(lplf->lfFaceName);

    return TRUE;
}

int CALLBACK
GetFontSizeProc(LOGFONT FAR *    lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    if (lParam)
       ((CFontSizeOptions *)lParam)->AddSize(lplf->lfHeight);

    return TRUE;
}

//+----------------------------------------------------------------
//
//  member : classdesc
//
//  Synopsis : CBase Class Descriptor Structure
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COptionsHolder::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLOptionsHolder,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : CTOR
//
//+----------------------------------------------------------------

COptionsHolder::COptionsHolder(CWindow * pWindow) : super(), _pWindow(pWindow)
{
    Assert(pWindow);

    _pWindow->AddRef();
    _pFontNameObj=NULL;

    VariantInit(&_execArg);
    _hParentWnd = NULL;
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

COptionsHolder::~COptionsHolder()
{
    _aryFontSizeObjects.ReleaseAll();

    _pWindow->Release();
    ReleaseInterface(_pFontNameObj);

    VariantClear(&_execArg);
}

void
COptionsHolder::Passivate()
{
    IGNORE_HR(SetFindText(GetAAfindText()));

    super::Passivate();
}


//+---------------------------------------------------------------
//
//  Member  : COptionsHolder::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COptionsHolder::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLOptionsHolder)
        {
           *ppv = (IHTMLOptionsHolder *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+----------------------------------------------------------------
//
//  member : get_document
//
//  Synopsis : IHTMLOptionsHolder property. returns the document
//      member
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_document(IHTMLDocument2 ** ppDocDisp)
{
    HRESULT hr = S_OK;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDocDisp = NULL;

    hr = THR_NOTRACE(_pWindow->Document()->QueryInterface(IID_IHTMLDocument2,
                                            (void**) ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_unsecuredWindowOfDocument
//
//  Synopsis : IHTMLOptionsHolder property. returns the unsecured
//              window of the document
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_unsecuredWindowOfDocument(IHTMLWindow2 ** ppDocDisp)
{
    HRESULT         hr = S_OK;
    CWindow *       pWindow = NULL;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pWindow = _pWindow;
    Assert(pWindow);

    hr = THR_NOTRACE(pWindow->QueryInterface(IID_IHTMLWindow2,
                                            (void**)ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_fonts(IHTMLFontNamesCollection ** ppFontCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    LOGFONT lf;

    if (!ppFontCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFontCollection = NULL;
    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CFontNameOptions();
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ReleaseDC(hWndInPlace, hdc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // QI for an interface to return
    hr = THR_NOTRACE(_pFontNameObj->QueryInterface(
                                    IID_IHTMLFontNamesCollection,
                                    (void**)ppFontCollection));

    // We keep an additional ref because we cache the name collection obj

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : secureProtocolInfo
//
//  Synopsis : IHTMLOptionsHolder Property. returns a BSTR which 
//      describes the secure connection info. 
//      Empty string if current connection is insecure
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_secureConnectionInfo(BSTR * p)
{
    HRESULT hr = S_OK;
    BOOL bSuccess = FALSE;

    if ( p == NULL)
    {
        return E_POINTER;
    }
                
    if (CMarkup::HtmCtxHelper(_pWindow->_pMarkup) != NULL)
    {
        INTERNET_SECURITY_CONNECTION_INFO * pSCI = NULL;
        CMarkup::HtmCtxHelper(_pWindow->_pMarkup)->GetSecConInfo(&pSCI);

        if (!pSCI)
        {
            // Without benefit of INTERNET_SECURITY_CONNECTION_INFO, report "Encrypted."
            // if we believe the original source of the page to be secure
            
            TCHAR achMessage[FORMS_BUFLEN + 1];
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE sps;

            _pWindow->Doc()->GetRootSslState(FALSE, &sss, &sps);

            if (sss > SSL_SECURITY_MIXED)
            {
                if (!LoadString(GetResourceHInst(), IDS_SECURESOURCE, achMessage, ARRAY_SIZE(achMessage)))
                    return E_FAIL;

                *p = SysAllocString(achMessage);
                if (*p == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    bSuccess = TRUE;
                }
            }
        }
        
        if (pSCI != NULL && pSCI->fSecure)
        {
            // These are way beyond the sizes required for protocol & algorithm names (SSL 2.0, RC4, ...)
            // Assert's added in case the strings ever exceed the limit. 
            TCHAR achProtocol[32]; 
            TCHAR achAlgCipher[64];
            TCHAR achAlgExch[64];
            DWORD dwProtocol = ARRAY_SIZE(achProtocol);;
            DWORD dwAlgCipher = ARRAY_SIZE(achAlgCipher);
            DWORD dwAlgExch = ARRAY_SIZE(achAlgExch);
             
            if ( InternetSecurityProtocolToString(pSCI->dwProtocol, achProtocol, &dwProtocol, 0) && 
                 InternetAlgIdToString(pSCI->aiCipher, achAlgCipher, &dwAlgCipher, 0) &&
                 InternetAlgIdToString(pSCI->aiExch, achAlgExch, &dwAlgExch, 0)
               )
            {
                int idCipherQuality;
                
                if ( pSCI->dwCipherStrength < 56 )
                    idCipherQuality = IDS_SECURE_LOW;
                else if ( pSCI->dwCipherStrength < 128 )
                    idCipherQuality = IDS_SECURE_MEDIUM;
                else
                    idCipherQuality = IDS_SECURE_HIGH;
                
                TCHAR achSecurityInfo[256]; // This is way beyond what we can handle. 
                                
                hr = THR(Format(0,
                                achSecurityInfo,
                                ARRAY_SIZE(achSecurityInfo),
                                MAKEINTRESOURCE(IDS_SECURECONNECTIONINFO),
                                achProtocol,
                                achAlgCipher,
                                pSCI->dwCipherStrength,
                                GetResourceHInst(), idCipherQuality,
                                achAlgExch,
                                pSCI->dwExchStrength
                            ));

                if (SUCCEEDED(hr))
                {
                    *p = SysAllocString(achSecurityInfo);
                    if (*p == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        bSuccess = TRUE;
                    }
                }
            }
            else
            {
                DWORD dwError = GetLastError();
                // This implies the stack buffers we have allocated are not big enough!!
                Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }  /* if the connection was secure */
    } /* if we found a _pHtmCtx */

    // If we failed somewhere along the way. just allocate an empty string and return quietly. 
    if (!bSuccess)
    {
        *p = SysAllocString(_T(""));
        if (*p == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }                                                                                                                
                                         
    return hr;    
}



//+----------------------------------------------------------------
//
//  member : sizes
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole Collecion of
//      longs of the available sizes available for the given font
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::sizes( BSTR bstrFontName,
                       IHTMLFontSizesCollection ** ppOptsCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    CStr    strName;
    long    lIndex;

    if (!ppOptsCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    if (!bstrFontName || !SysStringLen(bstrFontName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lIndex = GetObjectLocation(bstrFontName);
    if (lIndex<0)
    {
        // some error happened
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If we don't have the sizes cached for this font....
    if (lIndex == _aryFontSizeObjects.Size())
    {
        CFontSizeOptions * pfsObject=NULL;

        // add a new one to the list
        hr = THR(_aryFontSizeObjects.EnsureSize(lIndex+1));
        if (hr)
            goto Cleanup;

        pfsObject = new CFontSizeOptions();
        if (!pfsObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pfsObject->_cstrFont.SetBSTR(bstrFontName);
        pfsObject->SetSize(0);

        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        EnumFonts( hdc, pfsObject->_cstrFont,
                   (FONTENUMPROC) GetFontSizeProc,
                   (LPARAM)pfsObject);
        ReleaseDC(hWndInPlace, hdc);

        _aryFontSizeObjects[lIndex] = pfsObject;
    }

        // QI for an interface to return
    hr = THR_NOTRACE(_aryFontSizeObjects[lIndex]->QueryInterface(
                                    IID_IHTMLFontSizesCollection,
                                    (void**)ppOptsCollection));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : openfiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::openfiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, FALSE)));
}

//+----------------------------------------------------------------
//
//  member : savefiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::savefiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, TRUE)));
}

//+----------------------------------------------------------------
//
//  member : OpenSaveFileDlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open or save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

#define VERIFY_VARARG_4BSTR(arg, var)           \
    switch(V_VT(&arg))                          \
    {                                           \
    case    VT_BSTR:                            \
        var = &arg;                             \
        break;                                  \
    case    VT_BYREF|VT_BSTR:                   \
        var = V_VARIANTREF(&arg);               \
        break;                                  \
    default:                                    \
        var = NULL;                             \
    }

HRESULT
COptionsHolder::OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName, BOOL fSaveFile)
{
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    VARIANT *       pvarInitFile;
    VARIANT *       pvarInitDir;
    VARIANT *       pvarFilter;
    VARIANT *       pvarTitle;
    OPENFILENAME    ofn;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    BSTR            bstrFile = 0;
    TCHAR           *pstrExt;
    TCHAR           achPath[MAX_PATH];

    VERIFY_VARARG_4BSTR(initFile, pvarInitFile);
    VERIFY_VARARG_4BSTR(initDir, pvarInitDir);
    VERIFY_VARARG_4BSTR(filter, pvarFilter);
    VERIFY_VARARG_4BSTR(title, pvarTitle);

    hr = THR(FormsAllocStringLen(NULL, MAX_PATH, &bstrFile));
    if (hr)
    {
        goto Cleanup;
    }

    if (pvarInitFile)
    {
        _tcscpy(bstrFile, V_BSTR(pvarInitFile));
    }
    else
    {
        *bstrFile = _T('\0');
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    Assert(_hParentWnd);
    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    // ofn.hwndOwner       = hWndInPlace;
    ofn.hwndOwner       = _hParentWnd;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
                            // no readonly checkbox, per request

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = bstrFile;     // file name buffer
    ofn.nMaxFile        = MAX_PATH;     // file name buffer size
    
    if (pvarInitDir)
    {
        ofn.lpstrInitialDir = V_BSTR(pvarInitDir);
    }

    if (pvarFilter)
    {
        BSTR    bstrFilter = V_BSTR(pvarFilter);
        TCHAR   *cp;

        for ( cp = bstrFilter; *cp; cp++ )
        {
            if ( *cp == _T('|') )
            {
                *cp = _T('\0');
            }
        }
        ofn.lpstrFilter = bstrFilter;
    }

    if (pvarTitle)
    {
        ofn.lpstrTitle = V_BSTR(pvarTitle);
    }

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = bstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt > bstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }

    if( pstrExt > bstrFile )
    {
        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');

                break;
            }
            pSearch += _tcslen(pSearch);
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    {
        LOCK_SECTION(g_csFile);

        _tcscpy(achPath, g_achSavePath);
        ofn.lpstrInitialDir = *achPath ? achPath : NULL;
    }

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (!fOK)
    {
        FormsFreeString(bstrFile);
        bstrFile = NULL;
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
#else //WINCE
        hr = E_FAIL;
#endif //WINCE
    }
    else
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName =_tcsrchr(g_achSavePath, _T('\\'));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }
        hr = S_OK;
    }

Cleanup:

    *pathName = bstrFile;

    return hr;
}

HRESULT
COptionsHolder::choosecolordlg( VARIANTARG initColor, long *rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    VARIANT *       pvarRGBColor;
    DWORD           dwResult;
    VARIANTARG      varArgTmp;

    hr = THR (VariantChangeTypeSpecial(&varArgTmp, &initColor, VT_I4));
    if (hr)
    {
        pvarRGBColor = NULL;
    }
    else
    {
        if (V_VT(&initColor) & VT_BYREF)
        {
            pvarRGBColor = V_VARIANTREF(&varArgTmp);
        }
        else
        {
            pvarRGBColor = &varArgTmp;
        }
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = _hParentWnd;
    structCC.lpCustColors    = aCColors;
    
    if (pvarRGBColor)
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = V_I4(pvarRGBColor);
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:

    *rgbColor = dwResult;

    RRETURN(SetErrorInfo( hr ));
#endif // WINCE
}

HRESULT
COptionsHolder::showSecurityInfo()
{
    HWND    hwnd = _hParentWnd;
    CDoc *  pDoc = _pWindow->Doc();

    if (!_hParentWnd)
        pDoc->GetWindow(&hwnd);
        
    InternetShowSecurityInfoByURL((TCHAR*)CMarkup::GetUrl(_pWindow->Markup()), hwnd);

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
COptionsHolder::isApartmentModel( IHTMLObjectElement* object, 
                                 VARIANT_BOOL * fApartment)
{
    HRESULT             hr = S_OK;
    IClientSecurity    *pCL = NULL;
    VARIANT_BOOL        vbRetVal = VB_FALSE;
    VARIANT             var;
    IOleCommandTarget  *pCT = NULL;

    VariantInit(&var);

    hr = THR(object->QueryInterface(IID_IOleCommandTarget, (void **) &pCT));
    if (hr)
        goto Cleanup;

    hr = THR(pCT->Exec((GUID *)&CGID_MSHTML, 
                        IDM_GETPUNKCONTROL, 
                        0, 
                        NULL, 
                        &var));
    if (hr)
        goto Cleanup;

    //
    //  QI IClientSecurity returns S_OK if the control is NOT 
    //  apartment model!
    //
    hr = var.punkVal->QueryInterface(IID_IClientSecurity, (void **) &pCL);
    if (!hr)
    {
        hr = S_OK;      // It really is OK.
        goto Cleanup;
    }

    vbRetVal = VB_TRUE;

Cleanup:
    ReleaseInterface(pCL);
    ReleaseInterface(pCT);

    *fApartment = vbRetVal;

    RRETURN( SetErrorInfo( S_OK ) );
}


HRESULT
COptionsHolder::getCharset(BSTR fontName, long * charset)
{
    HRESULT         hr = S_OK;
    LOGFONT         lf;
    UINT            uintResult = 0;
    HDC             hdc = NULL;
    HFONT           hfont = NULL, hfontOld = NULL;

    if (!charset)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *charset = 0;

    hdc = GetDC(NULL);
    if (!hdc)
        goto Cleanup;

    memset(&lf, 0, sizeof(lf));

    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality  = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    
    // If fontName is too long, we have to shorten it.
    _tcsncpy(lf.lfFaceName, fontName, LF_FACESIZE - 1);
    lf.lfFaceName[LF_FACESIZE - 1] = 0;
    
    hfont = CreateFontIndirect(&lf);
    if (!hfont)
        goto Cleanup;

    hfontOld = (HFONT) SelectObject(hdc, hfont);
    if (!hfontOld)
        goto Cleanup;

    uintResult = GetTextCharset(hdc);

    *charset = uintResult;

Cleanup:

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }

    if (hfont)
    {
        DeleteObject(hfont);
    }
    
    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    RRETURN( SetErrorInfo( hr ) );
}



//+----------------------------------------------------------------
//
//  Member GetObjetLocation
//
//  Synopsis : helper function for sizes. this will search the
//      pointer array of size collections to see if this one
//      already exists. if not, size() is returned.
//
//-----------------------------------------------------------------

long
COptionsHolder::GetObjectLocation(BSTR strTargetFontName)
{
    long    lSize = _aryFontSizeObjects.Size();
    long    l;

    // Look for a free slot in the non-reserved part of the cache.
    for (l=0; l < lSize; ++l)
    {
        if (!FormsStringICmp(_aryFontSizeObjects[l]->_cstrFont,
                             strTargetFontName))
            break;
    }

    return l;
}


HRESULT
STDMETHODCALLTYPE COptionsHolder::put_execArg(VARIANT varExecArg)
{
    VariantClear(&_execArg);
    RRETURN(SetErrorInfo(VariantCopy(&_execArg, &varExecArg)));
}

HRESULT 
STDMETHODCALLTYPE COptionsHolder::get_execArg(VARIANT *pexecArg)
{
    HRESULT     hr;

    if (pexecArg == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantCopy(pexecArg, &_execArg);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontNameOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontNameOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontNamesCollection,  // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CFontNameOptions::~CFontNameOptions()
{
    CStr *  pcstr;
    long    i;

    for (i = _aryFontNames.Size(), pcstr = _aryFontNames;
         i > 0;
         i--, pcstr++)
    {
        pcstr->Free();
    }

    _aryFontNames.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontNamesCollection)
        {
           *ppv = (IHTMLFontNamesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::AddName(TCHAR * strFontName)
{
    HRESULT hr = S_OK;
    long    lIndex;
    long    lSizeAry = _aryFontNames.Size();

    // does this name already exist in the list
    for (lIndex = 0; lIndex < lSizeAry ; lIndex++)
    {
        if (_tcsiequal(strFontName, _aryFontNames[lIndex]))
            break;
    }

    // Not found, so add element to array.
    if (lIndex == lSizeAry)
    {
        CStr *pcstr;

        hr = THR(_aryFontNames.AppendIndirect(NULL, &pcstr));
        if (hr)
            goto Cleanup;

        hr = pcstr->Set(strFontName);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::length
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontNames.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::item
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::item(long lIndex, BSTR * pstrName)
{
    HRESULT   hr   = S_OK;

    if (!pstrName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontNames.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aryFontNames[lIndex].AllocBSTR(pstrName);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontNames.EnumVARIANT(VT_BSTR,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontSizeOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontSizeOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontSizesCollection,  // _piidDispinterface
    &s_apHdlDescs,                      // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontSizesCollection)
        {
           *ppv = (IHTMLFontSizesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::AddSize
//
//  Sysnopsis : adds the given size to the aryFontSizes
//          in ascending order.
//
//----------------------------------------------------------------
HRESULT
CFontSizeOptions::AddSize(long lFSize)
{
    HRESULT hr = S_OK;
    int     i, value, iSizeAry = _aryFontSizes.Size();

    for (i=0; i<iSizeAry; i++)
    {
        value = _aryFontSizes[i];

        // is it already in the list
        if (lFSize == value)
            goto Cleanup;

        // is it smaller than the thing we're looking at
        if (lFSize < value)
            break;
    }

    // it is not in the list and smaller than the value at index i
    // or i = iSizeAry and we want to tack this at the end.
    hr = THR(_aryFontSizes.Insert(i, lFSize));

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::length
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontSizes.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::item
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::item(long lIndex, long *plSize)
{
    HRESULT hr = S_OK;

    if (!plSize)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontSizes.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plSize = _aryFontSizes[lIndex];

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::_newEnum
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontSizes.EnumVARIANT(VT_I4,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\postdata.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

DeclareTag(tagFormEncoding, "Form", "Form submission encoding")

MtDefine(CPostData, Dwn, "CPostData")
MtDefine(CPostData_pv, CPostData, "CPostData::_pv")
MtDefine(CPostItem, Dwn, "CPostItem (vector)")
MtDefine(CPostItem_psz, CPostItem, "CPostItem::_pszAnsi/Wide")

// This is the number of characters we allocate by default on the stack
// for string buffers. Only if the number of characters in a string exceeds
// this will we need to allocate memory for string buffers.
#define STACK_ALLOCED_BUF_SIZE 64

// Helpers for Form Submit - copied from IE3 and modified approriately
//
static int x_hex_digit(int c)
{
    if (c >= 0 && c <= 9)
    {
        return c + '0';
    }
    if (c >= 10 && c <= 15)
    {
        return c - 10 + 'A';
    }
    return '0';
}



static const char s_achDisposition[] = "\r\nContent-Disposition: form-data; name=\"";

// MIME types constants
// Multipart/Form-Data are constructed in CreateHeader()
static const char s_achTextPlain[]  = "text/plain\r\n";
static const char s_achUrlEncoded[] = "application/x-www-form-urlencoded\r\n";



/*
   The following array was copied directly from NCSA Mosaic 2.2
 */
static const unsigned char isAcceptable[96] =
/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,    /* 2x   !"#$%&'()*+,-./  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,    /* 3x  0123456789:;<=>?  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,    /* 5x  PQRSTUVWXYZ[\]^_  */
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};   /* 7x  pqrstuvwxyz{\}~  DEL */

// Performs URL-encoding of null-terminated strings. Pass NULL in pbOut
// to find buffer length required. Note that '\0' is not written out.

int
URLEncode(unsigned char * pbOut, const char * pchIn)
{
    int     lenOut = 0;
    char *  pchOut = (char *)pbOut;

    Assert(pchIn);

    for (; *pchIn; pchIn++, lenOut++)
    {
        if (*pchIn == ' ')
        {
            if (pchOut)
                *pchOut++ = '+';
        }
        else if (*pchIn >= 32 && *pchIn <= 127 && isAcceptable[*pchIn - 32])
        {
            if (pchOut)
                *pchOut++ = (TCHAR)*pchIn;
        }
        else
        {
            if (pchOut)
                *pchOut++ = '%';
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit((*pchIn >> 4) & 0xf);
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit(*pchIn & 0xf);
        }
    }
    return lenOut;
}



// Support for internationalization
class CSubmitIntl : public CEncodeWriter
{
public:
    CSubmitIntl(CODEPAGE cp);
    HRESULT Convert(TCHAR * pchIn);
};

CSubmitIntl::CSubmitIntl(CODEPAGE cp)
    // just give a large enough block size
    : CEncodeWriter(NavigatableCodePage(cp), 256)
{
    TraceTag((tagFormEncoding, "%lx constructing CSubmitIntl with codepage %d", this, cp));
}



HRESULT
CSubmitIntl::Convert(TCHAR * pchIn)
{
    HRESULT hr=S_OK;
    int     cch;

    Assert(pchIn);

    // So MultiByteFromWideChar knows what to convert
    _pchBuffer = (TCHAR *)pchIn;
    _cchBuffer = _cchBufferMax = _tcslen(pchIn) + 1;

    hr = THR(MultiByteFromWideChar(FALSE, &cch));

    // Do this to prevent the destructor from trying to
    // free _pchBuffer
     _pchBuffer = NULL;
     _cchBuffer = _cchBufferMax = 0;

    return hr; 
}


//+---------------------------------------------------------------------------
//
//  Member:     CPostData::IsStringInCodePage
//
//  Synopsis:   Takes a wide char string and an code page and returns whether
//              all the charaters in the string are the code page
//
//----------------------------------------------------------------------------

BOOL 
CPostData::IsStringInCodePage(CODEPAGE cpMlang, LPCWSTR lpWideCharStr, int cchWideChar)
{
    BOOL        fRetVal = FALSE;
    HRESULT     hr = S_OK;
    DWORD       dwMode = 0;

    TraceTag((tagFormEncoding, "IsStringInCodePage called: cp: %d, str: %S", cpMlang, lpWideCharStr));

    if (IsStraightToUnicodeCodePage(cpMlang))
    {
        fRetVal = TRUE;
        goto Cleanup;
    }

    hr = THR(mlang().ConvertStringFromUnicodeEx(&dwMode, cpMlang,
                    (LPWSTR) lpWideCharStr, (UINT *) &cchWideChar, 
                    NULL, NULL, MLCONVCHARF_NOBESTFITCHARS, NULL));
    if (FAILED(hr))
        goto Cleanup;

    fRetVal = (hr == S_OK); // S_FALSE means some characters were outside the target codepage.

Cleanup: 
    TraceTag((tagFormEncoding, "IsStringInCodePage returning %d for %S", fRetVal, lpWideCharStr));
    return fRetVal;
}


CODEPAGE
CPostData::GetCP(CMarkup * pMarkup)
{
    if (_cp)
    {
        TraceTag((tagFormEncoding, "CPostData::GetCP returning %d", _cp));
        return _cp;
    }

    CSubmitIntl intl(_fUseUtf8 ? CP_UTF8 : pMarkup->GetCodePage());
    _cp = intl.GetCodePage();

    TraceTag((tagFormEncoding, "CPostData::GetCP returning %d", _cp));
    return _cp;

}

///////////////////////////////////////////////////////////////////////////////
//  CPostData

HRESULT
CPostData::AppendEscaped(const TCHAR * pszWide, CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;
    CODEPAGE    cp;
    long        cch = pszWide ? _tcslen(pszWide) : 0;

    if (!pszWide)
        return S_OK;

    // Internationalize to produce multi-byte stream
    Assert(pMarkup);
    if (_fUseCustomCodePage)
    {
        cp = _cpInit;
    }
    else
    {
        cp = (_fUseUtf8 ? CP_UTF8 : pMarkup->GetCodePage());
    }        
    CSubmitIntl intl(cp);

    // CSubmitIntl sometimes maps the doc's codepage to something else.
    // We must cache that cp for use in CFormElement::DoSubmit.
    _cp = intl.GetCodePage();

    if (!_fUseUtf8 && !IsStringInCodePage(_cp,
                        pszWide,
                        cch + 1) && !_fUseCustomCodePage)
    {
        DWORD       dwCodePages = 0;
        long        cchCodePages = 0;

        _fCharsetNotDefault = TRUE;
        TraceTag((tagFormEncoding, "CPostData::_fCharsetNotDefault set to TRUE"));

        hr = THR(mlang().GetStrCodePages(pszWide, cch, NULL, &dwCodePages, &cchCodePages));
        if (S_OK != hr)
            goto Cleanup;

        if (cch > cchCodePages)
        {
            _fCodePageError = TRUE;
            TraceTag((tagFormEncoding, "CPostData::_fCodePageError set to TRUE"));
        }

        _dwCodePages |= dwCodePages;
    }

    hr = THR(intl.Convert((TCHAR*)pszWide));
    if ( hr )
        RRETURN(hr);

    {
        // Now, do the URL encoding
        const char * pszAnsi = (char *)intl._pbBuffer;
        UINT cbOld = Size();

        switch ( _encType )
        {
            case htmlEncodingURL:
                {    
                    UINT cbLen = URLEncode(NULL, pszAnsi);
                    if (0 == cbLen)
                        goto Cleanup;

                    hr = THR(Grow(cbOld + cbLen));
                    if ( hr )
                        goto Cleanup;

                    URLEncode(Base()+cbOld, pszAnsi);
                }
                break;

            default:
                {
                    // TODO (laszlog, IE6 track bug 16):
                    // Snap in the RFC1522 encoder here when we have one.

                    hr = THR(Append(pszAnsi));
                }
                break;

        } // switch
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CPostData::Append(const char * pszAnsi)
{
    if (!pszAnsi || !pszAnsi[0])
        return S_OK;

    UINT cbOld = Size();
    UINT cbLen = strlen(pszAnsi);

    if (Grow(cbOld+cbLen) != S_OK)
        return E_OUTOFMEMORY;

    // don't copy '\0'
    memcpy((char *)Base() + cbOld, pszAnsi, cbLen);

    _fItemSeparatorIsLast = FALSE;
    return S_OK;
}

HRESULT
CPostData::Append(int num)
{
    char sz[256];

    wsprintfA(sz, "%d", num);
    return Append(sz);
}

HRESULT
CPostData::Terminate(BOOL fOverwriteLastChar)
{
    if (!fOverwriteLastChar || Size() == 0)
    {
        if (Grow(Size()+1) != S_OK)
            return E_OUTOFMEMORY;
    }
    (*this)[Size()-1] = 0;

    _fItemSeparatorIsLast = FALSE;
    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendUnicode
//
//  Synopsis:   Appends a filename in Unicode
//
//  Arguments:  pszWideFilename     points to the null-terminated filename
//
//  Note:       As it is used for a single Unicode filename
//              this Append routine copies the whole string
//              including the terminating wide NULL
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendUnicode(const TCHAR * pszWideFilename)
{
    UINT cbOld;
    UINT cbLen;

    Assert(_eCurrentKind == POSTDATA_FILENAME);
    Assert(pszWideFilename);

    cbOld = Size();
    cbLen = sizeof(TCHAR) * (1 + _tcslen(pszWideFilename));

    if ( S_OK != Grow(cbOld + cbLen) )
        return E_OUTOFMEMORY;

    memcpy((char*)Base()+cbOld, pszWideFilename, cbLen);

    _fItemSeparatorIsLast = FALSE;

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::CreateHeader
//
//  Synopsis:   Creates the 'Content-type:' header value. It also has the
//              side-effect of creating the multipart boundary string that
//              we use in multipart form submissions.
//
//---------------------------------------------------------------------------
HRESULT
CPostData::CreateHeader(void)
{
    switch ( _encType )
    {
        case htmlEncodingMultipart:
        {
            SYSTEMTIME time;

            GetLocalTime( &time );
            wsprintfA(_achBoundary,
                      "\r\n-----------------------------%x%x%x%x",  // CRLF removed from here
                      time.wYear,
                      time.wMilliseconds,
                      time.wSecond,
                      GetForegroundWindow());
    
            //  _achBoundary is the complete separator string written into the submit stream
            //  complete with the CRLF and double-hyphen "--" prefix
            //  the separator value proper is the string following that prefix;
            //  that's the string that goes into the multipart header.

            wsprintfA(_achEncoding,
                "multipart/form-data; boundary=%s\r\n",
                _achBoundary + 4 );

            Assert(1 + strlen(_achEncoding) <= sizeof(_achEncoding));
            break;
        }

        case htmlEncodingURL:
            Assert(sizeof(s_achUrlEncoded) <= sizeof(_achEncoding));
            memcpy(_achEncoding, s_achUrlEncoded, sizeof(s_achUrlEncoded));
            break;

        case htmlEncodingText:
            Assert(sizeof(s_achTextPlain) <= sizeof(_achEncoding));
            memcpy(_achEncoding, s_achTextPlain, sizeof(s_achUrlEncoded));
            break;
    }

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendItemSeparator
//
//  Synopsis:   Writes the item separator
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendItemSeparator()
{
    HRESULT hr = S_OK;

    Assert(_eCurrentKind == POSTDATA_LITERAL);

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {
                if ( ! _fItemSeparatorIsLast )
                {
                    _lLastItemSeparator = Size();

                    //  Don't prepend the CR/LF if this is the first item
                    if ( _lLastItemSeparator || _cItems )
                    {
                        hr = THR(Append(_achBoundary));
                        if ( hr )
                            goto Cleanup;
                    }
                    else
                    {
                        hr = THR(Append(_achBoundary+2));
                        if ( hr )
                            goto Cleanup;
                    }
                    hr = THR(Append(s_achDisposition));
                    if ( hr )
                        goto Cleanup;

                    _fItemSeparatorIsLast = TRUE;
                }
            }
            break;

        case htmlEncodingText:
            {
                if (( Size() > 0 )
                   && ( ! _fItemSeparatorIsLast ))
                {
                    _lLastItemSeparator = Size();

                    hr = THR(Append("\r\n"));
                    if ( hr )
                        goto Cleanup;

                    _fItemSeparatorIsLast = TRUE;
                }
            }
            break;

        case htmlEncodingURL:
            {
                if ( Size() > 0 && *(Base()+(Size() - 1)) != '&' )
                {
                    _lLastItemSeparator = Size();

                    hr = THR(Append("&"));
                    if ( hr )
                        goto Cleanup;

                    _fItemSeparatorIsLast = TRUE;
                }
            }
            break;

    } // switch

    _cbOld = Size();


Cleanup:
    RRETURN(hr);
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::RemoveLastItemSeparator
//
//  Synopsis:   Removes the separator appended after the last submit item
//
//---------------------------------------------------------------------------
HRESULT
CPostData::RemoveLastItemSeparator(void)
{
    Assert(_eCurrentKind == POSTDATA_LITERAL);

    if ( _fItemSeparatorIsLast )
    {
        Assert(_lLastItemSeparator <= Size());

        SetSize(_lLastItemSeparator);
        _fItemSeparatorIsLast = FALSE;
    }

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendValueSeparator
//
//  Synopsis:   Writes the separator between the name and the value
//              of the control
//
//  note:       This is an equal sign for URLEncoding and text/plain,
//              closing quote and a line break for multipart
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendValueSeparator()
{
    HRESULT hr=S_OK;

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {
                hr = THR(Append("\"\r\n\r\n"));
            }
            break;

        case htmlEncodingText:
        case htmlEncodingURL:
            {
                hr = THR(Append("="));
            }
            break;

    } // switch

    _fItemSeparatorIsLast = FALSE;

    RRETURN(hr);
}




//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendNameValuePair
//
//  Synopsis:   Appends a name-value submit pair to the submit stream
//              according to the current encoding
//
//  Arguments:  pchName     the name. If NULL->no submit.
//              pchValue    the value string
//              pDoc        the Doc. Used for Unicode->ANSI mapping
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendNameValuePair(LPCTSTR pchName, LPCTSTR pchValue, CMarkup * pMarkup)
{
    HRESULT hr;

    Assert(pMarkup);

    if ( ! pchName )
        return S_FALSE;

    hr = THR(AppendEscaped(pchName, pMarkup));
    if (hr)
        goto Cleanup;

    hr = THR(AppendValueSeparator());
    if (hr)
        goto Cleanup;

    hr = THR(AppendEscaped(pchValue, pMarkup));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendNameFilePair
//
//  Synopsis:   Appends a name-file submit pair to the submit stream
//              according to the current encoding
//              Called by the File Upload control
//
//  Arguments:  pchName     the name. If NULL->no submit.
//              pchFileName the filename string
//              pDoc        the Doc. Used for Unicode->ANSI mapping
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendNameFilePair(LPCTSTR pchName, LPCTSTR pchFileName, CMarkup * pMarkup)
{
    TCHAR * pszMimeType = NULL;
    HRESULT hr=S_OK;

    if ( ! pchName )
        return S_FALSE;

    Assert(pMarkup);

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {
                hr = THR(AppendEscaped(pchName, pMarkup));
                if (hr)
                    goto Cleanup;

                hr = THR(Append("\x22; filename=\""));
                if (hr)
                    goto Cleanup;

                if ( ! pchFileName )
                {
                    pchFileName = g_Zero.ach;
                }
#ifndef UNIX
                hr = THR(AppendEscaped(pchFileName, pMarkup));
#else
                {
                    TCHAR *pchFileNameLastPart = _tcsrchr(pchFileName,_T('/'));
                    if(pchFileNameLastPart)
                        hr = THR(AppendEscaped(pchFileNameLastPart+1, pDoc));
                    else
                        hr = THR(AppendEscaped(pchFileName, pDoc));
                }
#endif // !UNIX
                if (hr)
                    goto Cleanup;

                hr = THR(Append("\"\r\nContent-Type: "));
                if (hr)
                    goto Cleanup;

                //  Look up the file type in the MIME database
                //  or use the extension

        #if JOHANN_FIXED_URLMON_TO_SNIFF_FILENAME

                TCHAR achFileMoniker[FORMS_BUFLEN];

                _tcscpy(achFileMoniker, _T("file://"));
                _tcscat(achFileMoniker, pchFileName);

                hr = THR(FindMimeFromData(NULL,             // bind context - can be NULL                                     
                                          pchFileName,   // url - can be null                                              
                                          NULL,             // buffer with data to sniff - can be null (pwzUrl must be valid) 
                                          0,                // size of buffer                                                 
                                          NULL,             // proposed mime if - can be null                                 
                                          0,                // will be defined                                                
                                          &pszMimeType,     // the suggested mime                                             
                                          0));   
        #else
                //  Use the achFileMoniker for data buffering, it's large enough
                HANDLE hFile = INVALID_HANDLE_VALUE;
                ULONG cb;
                char achFileBuf[FORMS_BUFLEN];

                hFile = CreateFile(pchFileName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,                //  security descriptor
                                   OPEN_EXISTING,
                                   0,
                                   NULL);

                if ( hFile == INVALID_HANDLE_VALUE )
                {
                    hr = E_FAIL;
                    goto CloseFile;
                }

                if (FILE_TYPE_DISK != GetFileType(hFile))
                {
                    hr = E_FAIL;
                    goto CloseFile;
                }

                //  Here the file should be open and ripe for consumption
                cb = 0;
                if ( !ReadFile(hFile, achFileBuf, sizeof(achFileBuf), &cb, NULL) )
                {
                    hr = E_FAIL;
                    goto CloseFile;
                }


                hr = THR(FindMimeFromData(NULL,             // bind context - can be NULL                                     
                                          pchFileName,      // url - can be null                                              
                                          achFileBuf,       // buffer with data to sniff - can be null (pwzUrl must be valid) 
                                          cb,               // size of buffer                                                 
                                          NULL,             // proposed mime if - can be null                                 
                                          0,                // will be defined                                                
                                          &pszMimeType,     // the suggested mime                                             
                                          0));

        CloseFile:
                if ( hFile != INVALID_HANDLE_VALUE )
                {
                    Verify(CloseHandle(hFile));
                }
        #endif
                // must be 0
                // Change the EXE sniff from application/x-msdownload because it's better in this case
                
                if ( SUCCEEDED(hr) && StrCmpIC(pszMimeType, _T("application/x-msdownload")) != 0 )
                {
                    hr = THR(AppendEscaped(pszMimeType, pMarkup));
                    if (hr)
                        goto Cleanup;

                    hr = THR(Append("\r\n"));
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    hr = THR(Append("application/octet-stream\r\n"));
                    if (hr)
                        goto Cleanup;
                }



                //  Depending on the MIME type decide on the encoding
                //  If encoding is needed we'll do mime64

                //  Note: Neither Netscape 3 nor apparently IE3.02 do
                //        any encoding when sending binary stuff.
                //        They just send it straight up.

                //hr = pSubmitData->Append("Content-Transfer-Encoding: base64\r\n");
                //if (hr)
                //    goto Cleanup;

                // designates end of header
                hr = THR(Append("\r\n"));
                if (hr)
                    goto Cleanup;

                hr = THR(StartNewItem(POSTDATA_FILENAME));
                if (hr)
                    goto Cleanup;

                hr = THR(AppendUnicode(pchFileName));
                if (hr)
                    goto Cleanup;

                hr = THR(StartNewItem(POSTDATA_LITERAL));
                if (hr)
                    goto Cleanup;

            }
            break;

        case htmlEncodingText:
        case htmlEncodingURL:
            {
                hr = THR(AppendNameValuePair(pchName, pchFileName, pMarkup));
            }
            break;

    } // switch

Cleanup:
    CoTaskMemFree(pszMimeType);
    RRETURN1(hr, S_FALSE);

}

//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendFooter
//
//  Synopsis:   Writes the footer for multipart
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendFooter()
{
    HRESULT hr;

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {   
                hr = THR(Append(_achBoundary));
                if ( hr )
                    goto Cleanup;

                hr = THR(Append("--\r\n"));

                _fItemSeparatorIsLast = FALSE;
            }
            break;

        case htmlEncodingText:
            {
                hr = AppendItemSeparator();
            }
            break;

        default:
            {
                hr = S_OK;
            }
            break;

    } // switch

Cleanup:
    RRETURN(hr);
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::Finish
//
//  Synopsis:   Wraps up the construction of the submit data
//
//---------------------------------------------------------------------------
HRESULT
CPostData::Finish(void)
{
    HRESULT hr;

    // Eat up any trailing '&'; no need to add the NULL terminator
    hr = THR(RemoveLastItemSeparator());
    if ( hr )
        goto Cleanup;

    hr = THR(AppendFooter());
    if ( hr )
        goto Cleanup;

    //  Flush the last string into its own memory block

    hr = THR(StartNewItem(POSTDATA_UNKNOWN));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+--------------------------------------------------------------
//
//  Member:     CPostData::StartNewItem
//
//  Synopsis:   Flushes the collected data into a string
//              The new Item type will be remembered
//              as new data is being collected.
//
//---------------------------------------------------------------
HRESULT
CPostData::StartNewItem(POSTDATA_KIND ekindNewItem)
{
    HRESULT hr = S_OK;
    CPostItem * pItem;

    //  Create the new chunk if there is any data
    //  Grow the descriptor array as needed

    pItem = new(Mt(CPostItem)) CPostItem[_cItems + 1];
    if ( ! pItem )
        goto MemoryError;

    memcpy(pItem, _pItems, _cItems * sizeof(*pItem) );

    delete [] _pItems;

    _pItems = pItem;

    pItem = _pItems + _cItems;

    _cItems++;

    //  Dump the current data into the Item, set the flag

    pItem->_ePostDataType = _eCurrentKind;

    if ( _eCurrentKind == POSTDATA_FILENAME )
    {
        TCHAR * pszWide;
        UINT ctchAlloc = 1 + _tcslen((TCHAR *)Base());

        pszWide = new(Mt(CPostItem_psz)) TCHAR [ ctchAlloc ];
        if ( ! pszWide )
            goto MemoryError;

        memcpy(pszWide, Base(), ctchAlloc * sizeof(TCHAR));

        pItem->_pszWide = pszWide;
    }
    else if ( _eCurrentKind == POSTDATA_LITERAL )
    {
        char * pszAnsi;

        pszAnsi = new(Mt(CPostItem_psz)) char[1 + Size()];
        if ( ! pszAnsi )
            goto MemoryError;

        memcpy(pszAnsi, Base(), Size());
        pszAnsi[Size()] = '\0';

        pItem->_pszAnsi = pszAnsi;
        pItem->_dwSize = Size();
    }

    //  Reset the data area

    _eCurrentKind = ekindNewItem;
    SetSize(0);
    _cbOld = 0;
    _lLastItemSeparator = 0;
    _fItemSeparatorIsLast = FALSE;

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+--------------------------------------------------------------
//
//  Member:     CPostData::DeleteAllData
//
//  Synopsis:   Deletes all the data in the post form
//
//---------------------------------------------------------------
void
CPostData::DeleteAllData()
{
    // Clear the form items
    _cItems = 0;

    delete [] _pItems;
    _pItems = 0;

    // Clear the data array
    DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\propbag.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       propbag.cxx
//
//  Contents:   CPropertyBag
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

MtDefine(CPropertyBag, ObjectModel, "CPropertyBag")
MtDefine(CPropertyBag_aryProps_pv, CPropertyBag, "CPropertyBag::_aryProps::_pv")
MtDefine(CPropertyBagGetPropertyBagContents_pVar, Locals, "CPropertyBag::GetPropertyBagContents pVar->pbVal")
MtDefine(CPropertyBagGetPropertyBagContents_pch, Locals, "CPropertyBag::GetPropertyBagContents pch")

DeclareTag(tagPropBag, "Property Bag", "Property Bag methods")

//+---------------------------------------------------------------------------
//
//  Member:     PROPNAMEVALUE::Set
//
//  Synopsis:   Initialize the struct with a name value pair.
//
//----------------------------------------------------------------------------

HRESULT
PROPNAMEVALUE::Set(TCHAR *pchPropName, VARIANT *pVar)
{
    HRESULT hr = _cstrName.Set(pchPropName);
    if (hr)
        goto Cleanup;
        
    hr = THR(VariantCopy(&_varValue, pVar));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     PROPNAMEVALUE::Free
//
//  Synopsis:   Free memory associated with this name value pair.
//
//----------------------------------------------------------------------------

void
PROPNAMEVALUE::Free()
{
    _cstrName.Free();
    VariantClear(&_varValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::CPropertyBag
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

CPropertyBag::CPropertyBag()
{
    _ulRefs = 1;
    _aryProps.SetSize(0);
    _pElementExpandos = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::~CPropertyBag
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

CPropertyBag::~CPropertyBag()
{
    Clear();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Clear
//
//----------------------------------------------------------------------------

void
CPropertyBag::Clear()
{
    long            c;
    PROPNAMEVALUE * pprop;
    
    for (c = _aryProps.Size(), pprop = _aryProps; c > 0; c--, pprop++)
    {
        pprop->Free();
    }
    _aryProps.SetSize(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::QueryInterface
//
//  Synopsis:   per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyBag::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if (riid == IID_IPropertyBag ||
        riid == IID_IUnknown)
    {
        *ppv = (IPropertyBag *) this;
    }
    else if (riid == IID_IPropertyBag2)
    {
        *ppv = (IPropertyBag2 *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Read
//
//  Synopsis:   per IPropertyBag.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyBag::Read(LPCOLESTR pchPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    RRETURN (Read(pchPropName, pVar, pErrorLog, -1));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Read
//
//  Synopsis:   helper
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Read(LPCOLESTR pchPropName, VARIANT *pVar, IErrorLog *pErrorLog, long iLikelyIndex)
{
    HRESULT         hr = S_OK;
    PROPNAMEVALUE * pprop = NULL;
    VARTYPE         vt;
    
    // NOTE istvanc error log is not supported yet
    if (!pchPropName || !pVar)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    TraceTag((tagPropBag, "IPropertyBag::Read name=%ls", pchPropName));

    vt = V_VT(pVar);

    // NOTE istvanc cannot deal with objects yet
    if (vt == VT_UNKNOWN)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // The Java VM (the one which does not know about IPropertyBag2)
    // calls Read with this hacked up string.  Call GetPropertyBagContents
    // in response
    //
    
    if (_tcsequal(pchPropName, _T("%%pbcontents%%")))
    {
        V_VT(pVar) = vt;
        hr = THR(GetPropertyBagContents(pVar, pErrorLog));
    }
    else
    {
        pprop = Find((TCHAR *)pchPropName, iLikelyIndex);
        if (!pprop)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (vt == VT_EMPTY)
        {
            vt = VT_BSTR;

            //
            // !!! (alexz) (anandra) (lylec) (cfranks)
            // We have to return variant of VT_BSTR for compatibility with IE3.01 and IE3.02.
            // Note that changing this to VT_I4 as IE3.00 did can have complications because
            // non-numeric string parameters can not be converted to VT_I4.
            //
        }

        //
        // Set the vt of the variant to VT_EMPTY.
        // There are controls that call in here with garbage values in the
        // the variant and VariantChangeType will choke.  Look at ie4 
        // bug 38350.  (anandra)
        //
    
        V_VT(pVar) = VT_EMPTY;

        // Do not change this to use VariantChangeTypeSpecial, due to IE3 compatability concerns
        hr = THR(VariantChangeTypeEx(pVar,
                                     &pprop->_varValue,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     vt));
        if (hr)
        {
            //
            // some controls rely on vt untouched after call to Read method of propbag.
            // If VariantChangeTypeEx succeeds in this code, then the variant remains untouched.
            // However, if VariantChangeTypeEx fails, then vt will be set to VT_EMPTY because we
            // cleared the variant. To preserve those controls who rely on untouched variant,
            // we restore here the type.
            // Control: marquee. IE4 Bug: 54109.
            // (alexz)

            V_VT(pVar) = vt;
            goto Cleanup;
        }
    }

    //
    // if we are in expandos loading mode, then, according the protocol, after reading each expando,
    // the expando is supposed to be removed from the element.
    //

    if (_pElementExpandos)
    {
        BSTR    bstrName;

        hr = THR(FormsAllocString(pchPropName, &bstrName));
        if (hr)
            goto Cleanup;

        hr = THR(_pElementExpandos->removeAttribute(bstrName, 0, NULL));

        FormsFreeString(bstrName);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Write
//
//  Synopsis:   per IPropertyBag.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyBag::Write(LPCOLESTR pchPropName, VARIANT *pVar)
{
    HRESULT         hr = S_OK;
    PROPNAMEVALUE * pprop = NULL;
    PROPNAMEVALUE   propNew;
    
    if (!pchPropName || !pVar)
        return E_POINTER;

    TraceTag((tagPropBag, "IPropertyBag::Write name=%ls", pchPropName));

    pprop = Find((TCHAR *)pchPropName);

    //
    // Add only newly encountered properties.  Ignore new values of
    // properties we've seen before (compat with IE 3.0).
    //
    
    if (pprop)
        goto Cleanup;
        
    hr = THR(_aryProps.AppendIndirect(&propNew, &pprop));
    if (hr)
        goto Cleanup;

    hr = THR(pprop->Set((TCHAR *)pchPropName, pVar));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Read
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Read(
    ULONG cProperties, 
    PROPBAG2 *pPB2, 
    IErrorLog *pErrorLog,
    VARIANT *pVar,
    HRESULT *phrError)
{
    long        i;
    HRESULT     hr;
    BOOL        fFail = FALSE;
    
    if (phrError)
    {
        //
        // Assume no errors
        //
        
        memset(phrError, S_OK, sizeof(HRESULT) * cProperties);
    }
        
    //
    // Temp implementation.  Delegate to IPropertyBag::Read
    //

    for (i = cProperties; i > 0; i--, pPB2++, pVar++)
    {
        VariantClear(pVar);
        
        V_VT(pVar) = pPB2->vt;

        hr = THR_NOTRACE(Read(pPB2->pstrName, pVar, pErrorLog, pPB2->dwHint));

        // mwatt we like not to assign the variant type until after the read,
        // However, the variant is used in the read. So instead I going to VariantInit if the read fails

        if (hr)
        {
            VariantInit(pVar);

            fFail = TRUE;
            if (phrError)
            {
                *(phrError + cProperties - i) = hr;
            }
        }
    }

    RRETURN((fFail) ? E_FAIL : S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Write
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Write(ULONG cProperties, PROPBAG2 *pPB2, VARIANT *pVar)
{
    long        i;
    BOOL        fFail = FALSE;
    HRESULT     hr;
    
    //
    // Temp implementation.  Delegate to IPropertyBag::Write
    //

    for (i = cProperties; i > 0; i--, pPB2++, pVar++)
    {
        hr = THR(Write(pPB2->pstrName, pVar));
        if (hr)
        {
            fFail = TRUE;
        }
    }

    RRETURN((fFail) ? E_FAIL : S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::CountProperties
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::CountProperties(ULONG *pcProp)
{
    if (!pcProp)
        RRETURN(E_POINTER);

    *pcProp = _aryProps.Size();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::GetPropertyInfo
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::GetPropertyInfo(
    ULONG iProperty,
    ULONG cProperties,
    PROPBAG2 *pPropBag,
    ULONG *pcProperties)
{
    PROPNAMEVALUE * pprop = NULL;
    HRESULT         hr = S_OK;
    long            i, iStop;
    
    //
    // Perform initializations
    //
    
    *pcProperties = 0;
    memset(pPropBag, 0, sizeof(PROPBAG2) * cProperties);
    
    if (iProperty >= (ULONG)_aryProps.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Figure out the number of PROPBAG2 structs to fill.  This
    // is the min of the number requested and the size of the array.
    //

    *pcProperties = min(cProperties, _aryProps.Size() - iProperty);
    
    //
    // For now only reply with PROPBAG2_TYPE_DATA
    //
    
    for (pprop = (PROPNAMEVALUE *)_aryProps + iProperty, i = iProperty, iStop = iProperty + *pcProperties; 
         i < iStop; 
         pprop++, i++, pPropBag++)
    {
        pPropBag->dwType = PROPBAG2_TYPE_DATA;
        pPropBag->vt = V_VT(&pprop->_varValue);
        pPropBag->cfType = CF_TEXT;
        pPropBag->pstrName = (TCHAR *)
            CoTaskMemAlloc((pprop->_cstrName.Length() +1) * sizeof(TCHAR));
        pPropBag->dwHint = i;
        if (!pPropBag->pstrName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(pPropBag->pstrName, pprop->_cstrName);
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::LoadObject
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::LoadObject(
    LPCOLESTR pstrName,
    DWORD dwHint,
    IUnknown *pUnkObject,
    IErrorLog *pErrorLog)
{
    RRETURN(E_NOTIMPL);
}


//======================================================================
//
// NOTE: istvanc from OHARE -> HACKHACK davidna 5/7/96 Beta1 Hack
//
// Called when PropertyBag::read() is called with the Property name set
// to "%%pbcontents%%"
//
// Put the contents in a block of memory as name & value pairs.
// Stored as char FAR * 's
// Return this in the callers Variant
//
// The storage goes like this:
// We have pointers to the name/value pairs following the
// the count (ULONG) of items (or pairs) in _pbcontent
//
//

//$ WIN64: CPropertyBag::GetPropertyBagContents constructs a buffer of counts and
//$ WIN64:   pointers to strings.  It assumes that sizeof(void *) == sizeof(ULONG).
//$ WIN64:   Appears that Java VM understands this format as well (%%pbcontents%%).

HRESULT 
CPropertyBag::GetPropertyBagContents(VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT         hr = S_OK;
    BYTE *          pbcontent = NULL;
    PROPNAMEVALUE * pprop;
    long            c;
    CVariant        Var;
    ULONG           cb;
    ULONG *         pul;
    
    DbgMemoryTrackDisable(TRUE);
    
    if (!pVar)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Must be this type for this HACK!
    if (V_VT(pVar) != (VT_BYREF|VT_UI1))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_aryProps.Size())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // allocate storage for the count (ULONG/number of items)
    // plus each of the items or name/value pairs
    cb = sizeof(ULONG) + (sizeof(char *) * _aryProps.Size()) * 2;

    Assert(sizeof(ULONG) == sizeof(char *));

    pbcontent = new(Mt(CPropertyBagGetPropertyBagContents_pVar)) BYTE [cb];
    if (!pbcontent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    memset(pbcontent, 0, cb);

    pul = (ULONG *)pbcontent;

    // first ULONG is count of items
    c = _aryProps.Size();
    *pul++ = c;

    // Fill in the blanks
    for (pprop = _aryProps;
         c > 0;
         c--, pprop++)
    {
        VARIANT * pVar;
        char * pch;

        //  Convert to ansi 'cause Java Applets probably won't like BSTR's
        //   and they're our only users of this

        //
        // store a pointer to the name
        //
        cb = WideCharToMultiByte(CP_ACP, 0, pprop->_cstrName, -1, NULL, 0,
              NULL, NULL);

        pch = new(Mt(CPropertyBagGetPropertyBagContents_pch)) char[cb + 1];
        if (!pch)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, pprop->_cstrName, -1, pch, cb,
            NULL, NULL);
        
        pch[cb] = 0;

        *pul++ = (ULONG)(ULONG_PTR)pch;

        // Now store a pointer to the value
        //
        if (pprop->_varValue.vt != VT_BSTR)
        {
            // Do not change this to use VariantChangeTypeSpecial, due to IE3 compatability concerns
            hr = VariantChangeTypeEx(&Var,
                                     &pprop->_varValue,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR);
            if (hr)
                goto Cleanup;
            pVar = &Var;
        }
        else
        {
            pVar = &pprop->_varValue;
        }

        //
        // store a pointer to the value
        //
        
        cb = WideCharToMultiByte(CP_ACP, 0, pVar->bstrVal,
          FormsStringLen(pVar->bstrVal), NULL, 0, NULL, NULL);
        
        pch = new(Mt(CPropertyBagGetPropertyBagContents_pch)) char[cb + 1];
        if (!pch)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, pVar->bstrVal,
            FormsStringLen(pVar->bstrVal), pch, cb, NULL, NULL);

        pch[cb] = 0;

        *pul++ = (ULONG)(ULONG_PTR)pch;
    }

    // put in variant
    pVar->pbVal = pbcontent;

Cleanup:
    DbgMemoryTrackDisable(FALSE);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::AddProp
//
//  Synopsis:   Helper to add a given property and name value pair.
//              with count of chars in name & value.
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::AddProp(
    TCHAR *pchName, 
    int cchName, 
    TCHAR *pchValue, 
    int cchValue)
{
    HRESULT     hr;
    CStr        cstrName;
    CVariant    Var;

    Assert (pchName && (0 < cchName) && (0 <= cchValue));

    hr = THR(cstrName.Set (pchName, cchName));
    if (hr)
        goto Cleanup;

    if (cchValue > 0 && pchValue)
    {
        V_VT(&Var) = VT_BSTR;
        hr = THR(FormsAllocStringLen(pchValue, cchValue, &V_BSTR(&Var)));
        if (hr)
            goto Cleanup;
    }
    else
    {   // Zero length or NULL values are treated as VT_EMPTY:
        V_VT(&Var) = VT_EMPTY;
    }

    hr = THR(Write(cstrName, &Var));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::AddProp
//
//  Synopsis:   Helper to add a given property and name value pair.
//              These are null terminated strings.
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::AddProp(TCHAR *pchName, TCHAR *pchValue)
{
    RRETURN(AddProp(
        pchName, _tcslen(pchName),
        pchValue, _tcslen(pchValue)));
}

//----------------------------------------------------------------------------
//  Member:     CPropertyBag::FindAndSetProp
//
//  Synopsis:   Helper to change a property value after the property bag 
//              has been prepared
//----------------------------------------------------------------------------
HRESULT
CPropertyBag::FindAndSetProp( TCHAR *pchName, TCHAR *pchValue)
{
    HRESULT     hr;
    CStr        cstrName;
    CVariant    Var;

    Assert (pchName);

    PROPNAMEVALUE * pprop = NULL;
    int             cchName = _tcslen(pchName);
    int             cchValue= 0;
    
    if (pchValue)
        cchValue = _tcslen(pchValue);
    
    Assert (0 < cchName);

    hr = THR(cstrName.Set (pchName, cchName));
    if (hr)
        goto Cleanup;

    if (cchValue > 0)   //implies that pchValue!=NULL
    {
        V_VT(&Var) = VT_BSTR;
        hr = THR(FormsAllocStringLen(pchValue, cchValue, &V_BSTR(&Var)));
        if (hr)
            goto Cleanup;
    }
    else
    {   // Zero length or NULL values are treated as VT_EMPTY:
        V_VT(&Var) = VT_EMPTY;
    }

//
// TODO:(ferhane) Move this before the if statement above on the 5.x tree
//                  for perf.
//
    pprop = Find( pchName, 0);

    if (!pprop)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // free the old variant that was stored in the propertybag
    pprop->Free();

    hr = THR(pprop->Set(cstrName, &Var));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Save
//
//  Synopsis:   saves to pStreamWrBuff html-formatted param bag
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Save(CStreamWriteBuff * pStreamWrBuff)
{
    HRESULT         hr = S_OK;
    long            c;
    PROPNAMEVALUE * pprop;
    DWORD           dwOldBuffFlags;
    
    dwOldBuffFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
    pStreamWrBuff->BeginPre();
    pStreamWrBuff->BeginIndent();

    for (c = _aryProps.Size(), pprop = _aryProps;
         c > 0; 
         c--, pprop++)
    {
        //
        // First try to convert this param into a string.
        //
        
        if (VT_BSTR != V_VT(&pprop->_varValue))
        {
            // Do not change this to use VariantChangeTypeSpecial, due to IE3 compatability concerns
            hr = VariantChangeTypeEx(&pprop->_varValue,
                                     &pprop->_varValue,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR);
            if (hr)
            {
                // a property in param bag could not be converted to string;
                // we still try to save other properties

                // NOTE: need to report this error to user somehow;
                // e.g., by putting a comment to html about failure to save
                // the property.   Also handle catastrophic failure such as out-of-mem
                // appropriately.

                hr = S_OK;  // so if this was the last property everyone continues merrily along.
                continue;
            }
        }

        hr = THR(pStreamWrBuff->NewLine());
        if (hr)
            break;

        hr = THR(pStreamWrBuff->Write(
                     pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && pStreamWrBuff->TestFlag(WBF_SAVE_FOR_XML)
                        ? _T("<HTML:PARAM NAME=") : _T("<PARAM NAME=") )
                );
        if (hr)
            break;

        hr = THR(pStreamWrBuff->WriteQuotedText(pprop->_cstrName, TRUE));
        if (hr)
            break;

        hr = THR(pStreamWrBuff->Write(_T(" VALUE=")));
        if (hr)
            break;

        Assert(V_VT(&pprop->_varValue) == VT_BSTR);
        hr = THR(pStreamWrBuff->WriteQuotedText(
                V_BSTR(&pprop->_varValue), 
                TRUE));
        if (hr)
            break;

        hr = THR(pStreamWrBuff->Write(_T(">")));
        if (hr)
            break;
    }

    pStreamWrBuff->EndIndent();
    pStreamWrBuff->EndPre();
    pStreamWrBuff->RestoreFlags(dwOldBuffFlags);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Find
//
//  Synopsis:   Return struct of PROPNAMEVALUE of given name
//
//----------------------------------------------------------------------------

PROPNAMEVALUE *
CPropertyBag::Find(TCHAR *pchName, long iLikelyIndex)
{
    PROPNAMEVALUE * pprop;
    long            c;

    Assert(pchName);

    if (0 <= iLikelyIndex && iLikelyIndex < _aryProps.Size())
    {
        pprop = &_aryProps[iLikelyIndex];
        if (0 == _tcsicmp(pchName, pprop->_cstrName))
        {
            return pprop;
        }
    }

    for (c = _aryProps.Size(), pprop = _aryProps; c > 0; c--, pprop++)
    {
        if (0 == _tcsicmp(pchName, pprop->_cstrName))
        {
            // Found, so return it.
            return pprop;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\datcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       datcache.cxx
//
//  Contents:   Data Cache (CDataCache class and related)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DATCACHE_HXX_
#define X_DATCACHE_HXX_
#include "datcache.hxx"
#endif

PerfDbgTag(tagDataCacheDisable, "DataCache", "Disable sharing entries (to find leaks)");
MtDefine(CDataCacheBase, Tree, "CDataCacheBase")
MtDefine(CDataCacheBaseMetrics, Metrics, "CDataCacheBase metrics");
MtDefine(CDataCacheBaseHits,  CDataCacheBaseMetrics, "CDataCacheBase hits")
MtDefine(CDataCacheBaseTotal, CDataCacheBaseMetrics, "CDataCacheBase total")

#define celGrow 8

#if DBG==1
#define TO_HASHING   30
#define FROM_HASHING 20
#else
#define TO_HASHING   200
#define FROM_HASHING 150
#endif

#if DBG==1
#define CheckFreeChain()\
            CheckFreeChainFn()
#else
#define CheckFreeChain()
#endif


// ===============================  CDataCacheBase  =================================


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::constructor
//
//  Synopsis:
//
//  Returns:
//
//-------------------------------------------------------------------------

CDataCacheBase::CDataCacheBase() : _HtCrcI()
{
    _pael = NULL;
    _cel = 0;
    _ielFirstFree = -1;
    _fSwitched = FALSE;
    _HtCrcI.SetCallBack(this, CompareIt);
    _celsInCache = 0;
#if DBG==1
    _cMaxEls     = 0;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Add
//
//  Synopsis:   Add a new DATA to the cache.
//
//  Arguments:  pvData - DATA to add to the cache
//              piel  - return index of DATA in the cache
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  Note:       This DO NOT addref the new data in the cache
//
//-------------------------------------------------------------------------

HRESULT CDataCacheBase::Add(const void * pvData, LONG *piel, BOOL fClone)
{
    HRESULT hr = S_OK;
    CDataCacheElem *pel;
    LONG iel;
    LONG ielRet = NULL;
    CDataCacheElem *pelRet;

    if (_ielFirstFree >= 0)             // Return first element of free list
    {
        ielRet = _ielFirstFree;

        hr = InitData(Elem(ielRet), pvData, fClone);
        if(hr)
            goto Cleanup;

        pelRet = Elem(ielRet);
        _ielFirstFree = pelRet->_ielNextFree;
    }
    else                                // All lower positions taken: need
    {                                   //  to add another celGrow elements
        pel = _pael;
        hr = MemRealloc(Mt(CDataCacheBase), (void **) & pel, (_cel + celGrow) * sizeof(CDataCacheElem));
        if(hr)
            goto Cleanup;
        MemSetName((pel, "CDataCacheBase data - %d elements", _cel + celGrow));
        _pael = pel;

        ielRet = _cel;
        pelRet = pel + ielRet;
        _cel += celGrow;

#if DBG==1
        pelRet->_pvData = NULL;
#endif

        hr = InitData(pelRet, pvData, fClone);
        if(hr)
        {
            // Put all added elements in free list
            iel = ielRet;
        }
        else
        {
            // Use first added element
            // Put next element and subsequent ones added in free list
            iel = ielRet + 1;
        }

        // Add non yet used elements to free list
        _ielFirstFree = iel;

        for(pel = Elem(iel); ++iel < _cel; pel++)
        {
            pel->_pvData = NULL;
            pel->_ielNextFree = iel;
        }

        // Mark last element in free list
        pel->_pvData = NULL;
        pel->_ielNextFree = -1;
    }

    if(!hr)
    {
        Assert(pelRet);
        Assert(pelRet->_pvData);
        DWORD dwCrc = ComputeDataCrc(pelRet->_pvData);
        pelRet->_dwCrc = dwCrc;
        pelRet->_cRef = 0;
        if (_fSwitched)
        {
#if DBG==1
            _HtCrcI.Insert(ULongToPtr(pelRet->_dwCrc), ULongToPtr(ielRet), pelRet->_pvData);
#else
            _HtCrcI.Insert(ULongToPtr(pelRet->_dwCrc), ULongToPtr(ielRet));
#endif
        }

        if(piel)
            *piel = ielRet;
    }

    _celsInCache++;
#if DBG == 1
    _cMaxEls = max(_cMaxEls, _celsInCache);
#endif

    if (  !_fSwitched
        && _celsInCache >= TO_HASHING
       )
    {
        CDataCacheElem *pel;
        LONG iel;
        HRESULT hr = S_OK;
        WHEN_DBG(LONG celsAdded = 0;)

        for (iel = 0, pel = Elem(0); iel < _cel; pel++, iel++)
        {
            if (pel->_pvData)
            {
#if DBG==1
                hr = _HtCrcI.Insert(ULongToPtr(pel->_dwCrc), ULongToPtr(iel), pel->_pvData);
#else
                hr = _HtCrcI.Insert(ULongToPtr(pel->_dwCrc), ULongToPtr(iel));
#endif
                if (hr != S_OK)
                {
                    _HtCrcI.ReInit();
                    break;
                }
                WHEN_DBG(celsAdded++;)
            }
        }
        if (hr == S_OK)
        {
            Assert(celsAdded == _celsInCache);
            _fSwitched = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Free(iel)
//
//  Synopsis:   Free up a DATA in the cache by moving it to the
//              free list
//
//  Arguments:  iel  - index of DATA to free in the cache
//
//  Returns:    none
//
//-------------------------------------------------------------------------

void CDataCacheBase::Free(LONG iel)
{
    CDataCacheElem * pElem = Elem(iel);

    Assert(pElem->_pvData);

    if (_fSwitched)
    {
        if (_celsInCache < FROM_HASHING)
        {
            _HtCrcI.ReInit();
            _fSwitched = FALSE;
        }
        else
        {
#if DBG==1
            LONG ielRemoved = (LONG)(LONG_PTR)_HtCrcI.Remove(ULongToPtr(pElem->_dwCrc), pElem->_pvData);
            Assert(ielRemoved == iel);
#else
            _HtCrcI.Remove(ULongToPtr(pElem->_dwCrc), pElem->_pvData);
#endif
        }
    }

    // Passivate data
    PassivateData(pElem);

    // Add it to free list
    pElem->_ielNextFree = _ielFirstFree;
    _ielFirstFree = iel;

    // Flag it's freed
    pElem->_pvData = NULL;

    _celsInCache--;

    Assert( _celsInCache >=0 );
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Free()
//
//  Synopsis:   Free up entire cache and deallocate memory
//
//-------------------------------------------------------------------------

void CDataCacheBase::Free()
{
#if DBG==1
    LONG   iel;
    static BOOL fAssertDone = FALSE;

    if (!fAssertDone)
    {
        for(iel = 0; iel < _cel; iel++)
        {
            if(Elem(iel)->_pvData != NULL)
            {
                TraceTag((tagError, "Cel : %d", iel));
                AssertSz(FALSE, "CDataCacheBase::Free() - one or more cells not Empty");
                // Don't put up more than one assert
                fAssertDone = TRUE;
                break;
            }
        }
    }
#endif

    MemFree(_pael);
    _HtCrcI.ReInit();

    _pael = NULL;
    _cel = 0;
    _ielFirstFree = -1;
    _celsInCache = 0;
    _fSwitched = FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Find(iel)
//
//  Synopsis:   Find given DATA in the cache and returns its index
//
//  Arguments:  pvData  - data to lookup
//
//  Returns:    index of DATA in the cache, -1 if not found
//
//-------------------------------------------------------------------------
LONG CDataCacheBase::Find(const void * pvData) const
{
    DWORD dwCrc = ComputeDataCrc(pvData);
    void *pVal;
    LONG iel;

    if (_fSwitched)
    {
        if (((CHtPvPv*)&_HtCrcI)->LookupSlow(ULongToPtr(dwCrc), (void*)pvData, &pVal) == S_OK)
            iel = PtrToInt(pVal);
        else
            iel = -1;
    }
    else
    {
        for(iel = 0; iel < _cel; iel++)
        {
            CDataCacheElem * pElem = Elem(iel);
            if(pElem->_pvData && pElem->_dwCrc == dwCrc)
            {
                if(CompareData(pvData, pElem->_pvData))
                {
                    goto done;
                }
            }
        }
        iel = -1;
    }

    Assert(iel == FindSlow(pvData));
done:
    return iel;
}

#if DBG==1
LONG CDataCacheBase::FindSlow(const void * pvData) const
{
    LONG iel;
    DWORD dwCrc;

    CheckFreeChain();

    dwCrc = ComputeDataCrc(pvData);

    for(iel = 0; iel < _cel; iel++)
    {
        CDataCacheElem * pElem = Elem(iel);
        if(pElem->_pvData && pElem->_dwCrc == dwCrc)
        {
            if(CompareData(pvData, pElem->_pvData))
            {
                return iel;
            }
        }
    }
    return -1;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::CheckFreeChain(iel)
//
//  Synopsis:   Check validity of the free chain
//
//  Arguments:  iel  - index of DATA to free in the cache
//
//  Returns:    none
//
//-------------------------------------------------------------------------

#if DBG==1

void CDataCacheBase::CheckFreeChainFn() const
{
    LONG cel = 0;
    LONG iel = _ielFirstFree;

    while(iel > 0)
    {
        AssertSz(iel == -1 || iel <= _cel, "CDataCacheBase::CheckFreeChain() - Elem points to out of range elem");

        iel = Elem(iel)->_ielNextFree;

        if (++cel > _cel)
        {
            AssertSz(FALSE, "CDataCacheBase::CheckFreeChain() - Free chain seems to contain an infinite loop");
            return;
        }
    }
}

#endif


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::ReleaseData(iel)
//
//  Synopsis:   Decrement the ref count of DATA of given index in the cache
//              Free it if ref count goes to 0
//
//  Arguments:  iel  - index of DATA to release in the cache
//
//  Returns:    none
//
//-------------------------------------------------------------------------

void CDataCacheBase::ReleaseData(LONG iel)
{
    CheckFreeChain();

    Assert( iel >= 0 );
    Assert(Elem(iel)->_pvData);
    Assert(Elem(iel)->_cRef > 0);

    if(--(Elem(iel)->_cRef) == 0)         // Entry no longer referenced
        Free (iel);                         // Add it to the free chain
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::CacheData(*pvData, *piel, *pfDelete, fClone)
//
//  Synopsis:   Cache new DATA. This looks up the DATA and if found returns
//              its index and addref it, otherwise adds it to the cache.
//
//  Arguments:  pvData - DATA to add to the cache
//              piel  - return index of DATA in the cache
//              pfDelete - returns whether or not to delete pvData on success
//              fClone - tells whether to clone or copy pointer
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-------------------------------------------------------------------------

HRESULT
CDataCacheBase::CacheData(const void *pvData, LONG *piel, BOOL *pfDelete, BOOL fClone)
{
    HRESULT hr = S_OK;
    LONG iel = Find(pvData);

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDataCacheDisable))
        iel = -1;
#endif

    if (pfDelete)
    {
        *pfDelete = FALSE;
    }

    if(iel >= 0)
    {
       MtAdd(Mt(CDataCacheBaseHits), 1, 0);
       Assert(Elem(iel)->_pvData);
       if (pfDelete)
       {
           *pfDelete = TRUE;
       }
    }
    else
    {
        hr = THR(Add(pvData, &iel, fClone));
        if(hr)
            goto Cleanup;
    }

    MtAdd(Mt(CDataCacheBaseTotal), 1, 0);
    AddRefData(iel);

    CheckFreeChain();

    if(piel)
    {
        *piel = iel;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::CacheDataPointer(**ppvData, *piel)
//
//  Synopsis:   Caches new data via CacheData, but does not clone.
//              On success, it takes care of memory management of input data.
//
//  Arguments:  ppvData - DATA to add to the cache
//              piel  - return index of DATA in the cache
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-------------------------------------------------------------------------

HRESULT CDataCacheBase::CacheDataPointer(void **ppvData, LONG *piel) {
    BOOL fDelete;
    HRESULT hr;

    Assert(ppvData);
    hr = CacheData(*ppvData, piel, &fDelete, FALSE);
    if (!hr)
    {
        if (fDelete)
        {
            DeletePtr(*ppvData);
        }
        *ppvData = NULL;
    }
    RRETURN(hr);
}

BOOL CDataCacheBase::CompareIt(const void *pObject, const void *pvKeyPassedIn, const void *pvVal2)
{
    CDataCacheBase *pBase = (CDataCacheBase*)pObject;
    long index = (long)PtrToInt(pvVal2);
    return pBase->CompareData(pvKeyPassedIn, pBase->Elem(index)->_pvData);
}

#if DBG==1
extern void __cdecl WriteHelp(HANDLE hFile, TCHAR *format, ...);
extern void WriteString(HANDLE hFile, TCHAR *pszStr);

void DumpCharFormat(HANDLE hfile, int i, const CCharFormat * pCF)
{
    Assert(pCF);

    WriteHelp(hfile, _T("<<div class=c<0d>>\r\n"), i%5);
    WriteString(hfile, _T("<B class=cc>+</B><B class=ff style='display:none'>-</B>\r\n"));
    WriteHelp(hfile, _T("<<u><<b>CharFormat: <0d> (Crc:<1x>)<</b><</u><<br>\r\n"), i, pCF->ComputeCrc());

    WriteString(hfile, _T("<span class=c style='display:none'>\r\n"));

    WriteHelp(hfile, _T("<<table><<tr><<td rowspan=8><<b>Flags:<</b><0x><</td><</tr>\r\n"), (pCF->_wFlagsVar << 16 | pCF->_wFontSpecificFlagsVar));

    WriteHelp(hfile, _T("<<tr><<td><<b>Underline:<</b><0d><</td><<td><<b>NoBreak:<</b><1d><</td><<td><<b>NoBreakInner:<</b><2d><</td><<td><<b>StrikeOut:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fUnderline ? 1 : 0, pCF->_fNoBreak ? 1 : 0, pCF->_fNoBreakInner ? 1 : 0, pCF->_fStrikeOut ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>VisibilityHidden:<</b><0d><</td><<td><<b>Display:<</b><1d><</td><</tr>\r\n"),
                        pCF->_fVisibilityHidden ? 1 : 0, pCF->_fDisplayNone ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>Disabled:<</b><0d><</td><<td><<b>BgColor:<</b><1d><</td><<td><<b>BgImage:<</b><2d><</td><<td><<b>Overline:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fDisabled ? 1 : 0, pCF->_fHasBgColor ? 1 : 0, pCF->_fHasBgImage ? 1 : 0, pCF->_fOverline ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>Relative:<</b><0d><</td><<td><<b>ExplicitFace:<</b><1d><</td><<td>&nbsp;<</td><</tr>\r\n"),
                        pCF->_fRelative ? 1 : 0, pCF->_fExplicitFace ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>Bold:<</b><0d><</td><<td><<b>Italic:<</b><1d><</td><<td><<b>Sup:<</b><2d><</td><<td><<b>Sub:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fBold ? 1 : 0, pCF->_fItalic ? 1 : 0, pCF->_fSuperscript ? 1 : 0, pCF->_fSubscript ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>RTL:<</b><0d><</td><<td><<b>BidiEmbed:<</b><1d><</td><<td><<b>BidiOverride:<</b><2d><</td><</tr>\r\n"),
                        pCF->_fRTL ? 1 : 0, pCF->_fBidiEmbed ? 1 : 0, pCF->_fBidiOverride ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>BumpSizeDown:<</b><0d><</td><<td><<b>Password:<</b><1d><</td><<td><<b>Protected:<</b><2d><</td><<td><<b>SizeDontScale:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fBumpSizeDown ? 1 : 0, pCF->_fPassword ? 1 : 0, pCF->_fProtected ? 1 : 0, pCF->_fSizeDontScale ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>DownloadedFont:<</b><0d><</td><<td><<b>IsPrintDoc:<</b><1d><</td><<td><<b>SubSuperSized:<</b><2d><</td><<td><<b>Accelerator:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fDownloadedFont ? 1 : 0, pCF->_fIsPrintDoc ? 1 : 0, pCF->_fSubSuperSized ? 1 : 0, pCF->_fAccelerator ? 1 : 0);


    WriteHelp(hfile, _T("<<tr><<td rowspan=5><</td><<td><<b>Weight:<</b><0d><</td><<td><<b>Kerning:<</b><1d><</td><<td><<b>Height:<</b><2d><</td><</tr>\r\n"),
                        pCF->_wWeight, pCF->_wKerning, pCF->_yHeight);

    WriteHelp(hfile, _T("<<tr><<td><<b>lcid:<</b><0d><</td><<td><<b>CharSet:<</b><1d><</td><<td><<b>PitchAndFamily:<</b><2d><</tr>\r\n"),
                        pCF->_lcid, pCF->_bCharSet, pCF->_bPitchAndFamily);

    WriteHelp(hfile, _T("<<tr><<td><<b>LetterSpacing:<</b><0d><</td><<td><<b>LineHeight:<</b><1d><</td><<td><<b>PadBord:<</b><2d><</td><<td><<b>SCBumpSizeDown:<</b><3d><</td><</tr>\r\n"),
                        pCF->_cuvLetterSpacing, pCF->_cuvLineHeight, pCF->_fPadBord, pCF->_fSCBumpSizeDown ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>TextColor:<</b><0x> <</td><<td><<b>CursorIdx:<</b><1d><</td><<td><<b>FaceName:<</b><2s><</td><<td><<b>TxtTransform:<</b><3d><</td><</tr>\r\n"),
                        pCF->_ccvTextColor, pCF->_bCursorIdx, pCF->GetFaceName(), pCF->_bTextTransform);

    WriteString(hfile, _T("</table></span></div>\r\n"));
}

void DumpParaFormat(HANDLE hfile, int i, const CParaFormat * pPF)
{
    Assert(pPF);

    WriteHelp(hfile, _T("<<div class=c<0d>>\r\n"), i%5);
    WriteString(hfile, _T("<B class=cc>+</B><B class=ff style='display:none'>-</B>\r\n"));
    WriteHelp(hfile, _T("<<u><<b>ParaFormat: <0d> (Crc:<1x>)<</b><</u><<br>\r\n"), i, pPF->ComputeCrc());

    WriteString(hfile, _T("<span class=c style='display:none'>\r\n"));

    WriteHelp(hfile, _T("<<table><<tr><<td rowspan=4><<b>Flags:<</b><0x><</td><</tr>\r\n"), pPF->_dwFlagsVar);

    WriteHelp(hfile, _T("<<tr><<td><<b>Pre: <0d><</td><<td><<b>TabStops: <1d><</td><<td><<b>CompactDL: <2d><</td><</tr>\r\n"),
                        pPF->_fPre, pPF->_fTabStops, pPF->_fCompactDL);

    WriteHelp(hfile, _T("<<tr><<td><<b>InclEOLWhite: <0d><</td><<td><<b>ResetDLLevel: <1d><</td><</tr>\r\n"),
                        pPF->_fInclEOLWhite, pPF->_fResetDLLevel);

    WriteHelp(hfile, _T("<<tr><<td rowspan=7><</td><<td><<b>BlockAlign: <0d><</td><<td><<b>TableVAlignment: <1d><</td><<td><<b>TabCount: <2d><</td><</tr>\r\n"),
                        pPF->_bBlockAlign, pPF->_bTableVAlignment, pPF->_cTabCount);

    WriteHelp(hfile, _T("<<tr><<td><<b>Listing: <0d><</td><<td><<b>NumberingStart: <1d><</td><<td><<b> ListPosition: <2d><</td><<td><<b>FontHeightTwips: <3d><</td><</tr>\r\n"),
                        pPF->_cListing, pPF->_lNumberingStart, pPF->_bListPosition, pPF->_lFontHeightTwips);

    WriteHelp(hfile, _T("<<tr><<td><<b>LeftIndentPoints: <0d><</td><<td><<b>LeftIndentPercent: <1d><</td><<td><<b>RightIndentPoints: <2d><</td><<td><<b>RightIndentPercent: <3d><</td><</tr>\r\n"),
                        pPF->_cuvLeftIndentPoints, pPF->_cuvLeftIndentPercent,
                        pPF->_cuvRightIndentPoints, pPF->_cuvRightIndentPercent);

    WriteHelp(hfile, _T("<<tr><<td><<b>NonBulletIndentPoints: <0d><</td><<td><<b>OffsetPoints: <1d><</td><<td><<b>ListyStyleType: <2d><</td><</tr>\r\n"),
                        pPF->_cuvNonBulletIndentPoints, pPF->_cuvOffsetPoints, pPF->GetListStyleType());

    WriteHelp(hfile, _T("<<tr><<td><<b>ImgCookie: <1d><</td><<td><<b>TextIndent: <2d><</td><<td><<b>InnerRTL: <2d><</td><<td><<b>OuterRTL: <3d><</td><</tr>\r\n"),
                        pPF->_lImgCookie, pPF->_cuvTextIndent,
                        pPF->HasRTL(TRUE) ? 1 : 0, pPF->HasRTL(FALSE) ? 1 : 0);

    WriteString(hfile, _T("</table></span></div>\r\n"));
}

void DumpFancyFormat(HANDLE hfile, int i, const CFancyFormat * pFF)
{
    Assert(pFF);

    WriteHelp(hfile, _T("<<div class=c<0d>>\r\n"), i%5);
    WriteString(hfile, _T("<B class=cc>+</B><B class=ff style='display:none'>-</B>\r\n"));
    WriteHelp(hfile, _T("<<u><<b>FancyFormat: <0d> (Crc:<1x>)<</b><</u><<br>\r\n"), i, pFF->ComputeCrc());

    WriteString(hfile, _T("<span class=c style='display:none'>\r\n"));

    WriteHelp(hfile, _T("<<table><<tr><<td rowspan=5><<b>Flags1:<</b><0x><</td><</tr>\r\n"), pFF->_dwFlagsVar1);

    WriteHelp(hfile, _T("<<tr><<td><<b>BgRepeatX:<</b><0d><</td><<td><<b>BgRepeatY:<</b><1d><</td><<td><<b>BgFixed:<</b><2d><</td><<td><<b>Relative:<</b><3d><</td><</tr>\r\n"),
        pFF->GetBgRepeatX() ? 1 : 0,
        pFF->GetBgRepeatY() ? 1 : 0,
        pFF->_fBgFixed ? 1 : 0,
        pFF->_fRelative ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderSoftEdges:<</b><0d><</td><<td><<b>BorderColorsSetUnique:<</b><1d><</td><<td><</td><<td><</td><</tr>\r\n"),
        pFF->_bd._bBorderSoftEdges ? 1 : 0,
        pFF->_bd._bBorderColorsSetUnique ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>ExplicitLeftMargin:<</b><0d><</td><<td><<b>ExplicitRightMargin:<</b><1d><</td><<td><<b>ExplicitTopMargin:<</b><2d>,  <</td><<td><<b>ExplicitBottomMargin:<</b><3d><</td><</tr>\r\n"),
        pFF->HasExplicitMargin(SIDE_LEFT) ? 1 : 0,
        pFF->HasExplicitMargin(SIDE_RIGHT) ? 1 : 0,
        pFF->HasExplicitMargin(SIDE_TOP) ? 1 : 0,
        pFF->HasExplicitMargin(SIDE_BOTTOM) ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>BlockNess:<</b><0d><</td><<td><<b>ShouldHaveLayout:<</b><1d><</td><<td><<b>AlignedLayout:<</b><2d><</td><<td><<b>CtrlAlignFromCSS:<</b><3d><</td><</tr>\r\n"),
        pFF->_fBlockNess ? 1 : 0,
        pFF->_fShouldHaveLayout ? 1 : 0,
        pFF->_fAlignedLayout ? 1 : 0,
        pFF->_fCtrlAlignFromCSS ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>HeightPercent:<</b><0d><</td><<td><<b>WidthPercent:<</b><1d><</td><<td><<b>ZParent:<</b><2d><</td><<td><<b>TableLayout:<</b><3d><</td><</tr>\r\n"),
        pFF->IsHeightPercent() ? 1 : 0,
        pFF->IsWidthPercent() ? 1 : 0,
        pFF->_fZParent ? 1 : 0,
        pFF->_bTableLayout);

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderCollapse:<</b><0d><</td><<td><<b>OverrideTablewideBorderDefault:<</b><1d><</td><<td><<b>Positioned:<</b><2d><</td><<td><<b>AutoPositioned:<</b><3d><</td><</tr>\r\n"),
        pFF->_bd._bBorderCollapse ? 1 : 0,
        pFF->_bd._fOverrideTablewideBorderDefault ? 1 : 0,
        pFF->_fPositioned ? 1 : 0,
        pFF->_fAutoPositioned ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>ScrollingParent:<</b><0d><</td><<td><</td><<td><<b>PercentHorzPadding:<</b><2d><</td><<td><<b>PercentVertPadding:<</b><3d><</td><</tr>\r\n"),
        pFF->_fScrollingParent ? 1 : 0,
        pFF->HasPercentHorzPadding() ? 1 : 0,
        pFF->HasPercentVertPadding() ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>HasMargins:<</b><0d><</td><<td><<b>HasExpressions:<</b><1d><</td><<td><<b>HasNoWrap:<</b><2d><</td><<td><<b>ZIndex:<</b><3d><</td><</tr>\r\n"),
        pFF->_fHasMargins ? 1 : 0,
        pFF->_fHasExpressions ? 1 : 0,
        pFF->_fHasNoWrap ? 1 : 0,
        pFF->_lZIndex);

    WriteHelp(hfile, _T("<<tr><<td rowspan=14><</td><<td><<b>PaddingTop:<</b><0d><</td><<td><<b>PaddingRight:<</b><1d><</td><<td><<b>PaddingBottom:<</b><2d><</td><<td><<b>PaddingLeft:<</b><3d><</td><</tr>\r\n"),
        pFF->GetPadding(SIDE_TOP),
        pFF->GetPadding(SIDE_RIGHT),
        pFF->GetPadding(SIDE_BOTTOM),
        pFF->GetPadding(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>SpaceBefore:<</b><0d><</td><<td><<b>SpaceAfter:<</b><1d><</td><<td><<b>Width:<</b><2d><</td><<td><<b>Height:<</b><3d><</td><</tr>\r\n"),
        pFF->_cuvSpaceBefore,
        pFF->_cuvSpaceAfter,
        pFF->GetWidth(),
        pFF->GetHeight());

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderColorTop:<</b><0x> <</td><<td><<b>BorderColorRight:<</b><1x> <</td><<td><<b>BorderColorBottom:<</b><2x> <</td><<td><<b>BorderColorLeft:<</b><3x><</td><</tr>\r\n"),
        pFF->_bd.GetBorderColor(SIDE_TOP),
        pFF->_bd.GetBorderColor(SIDE_RIGHT),
        pFF->_bd.GetBorderColor(SIDE_BOTTOM),
        pFF->_bd.GetBorderColor(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderWidthTop:<</b><0d><</td><<td><<b>BorderWidthRight:<</b><1d><</td><<td><<b>BorderWidthBottom:<</b><2d><</td><<td><<b>BorderWidthLeft:<</b><3d><</td><</tr>\r\n"),
        pFF->_bd.GetBorderWidth(SIDE_TOP),
        pFF->_bd.GetBorderWidth(SIDE_RIGHT),
        pFF->_bd.GetBorderWidth(SIDE_BOTTOM),
        pFF->_bd.GetBorderWidth(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderColorLight:<</b><0x> <</td><<td><<b>BorderColorDark:<</b><1x> <</td><<td><<b>BorderColorHilight:<</b><2x> <</td><<td><<b>BorderColorShadow:<</b><3x><</td><</tr>\r\n"),
        pFF->_bd._ccvBorderColorLight,
        pFF->_bd._ccvBorderColorDark,
        pFF->_bd._ccvBorderColorHilight,
        pFF->_bd._ccvBorderColorShadow);

    WriteHelp(hfile, _T("<<tr><<td><<b>ClipTop:<</b><0d><</td><<td><<b>ClipRight:<</b><1d><</td><<td><<b>ClipBottom:<</b><2d><</td><<td><<b>ClipLeft:<</b><3d><</td><</tr>\r\n"),
        pFF->GetClip(SIDE_TOP),
        pFF->GetClip(SIDE_RIGHT),
        pFF->GetClip(SIDE_BOTTOM),
        pFF->GetClip(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>MarginLeft:<</b><0d><</td><<td><<b>MarginTop:<</b><1d><</td><<td><<b>MarginRight:<</b><2d><</td><<td><<b>MarginBottom:<</b><3d><</td><</tr>\r\n"),
        pFF->GetMargin(SIDE_LEFT),
        pFF->GetMargin(SIDE_TOP),
        pFF->GetMargin(SIDE_RIGHT),
        pFF->GetMargin(SIDE_BOTTOM));

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderStyles(Top:<</b><0d><</td><<td><<b>Right:<</b><1d><</td><<td><<b>Bottom:<</b><2d><</td><<td><<b>Left:<</b><3d>)<</td><</tr>\r\n"),
        pFF->_bd.GetBorderStyle(SIDE_TOP),
        pFF->_bd.GetBorderStyle(SIDE_RIGHT),
        pFF->_bd.GetBorderStyle(SIDE_BOTTOM),
        pFF->_bd.GetBorderStyle(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>Filters:<</b><0s><</td><<td><</td><</tr>\r\n"),
        pFF->_pszFilters ? pFF->_pszFilters : _T(""));

    WriteHelp(hfile, _T("<<tr><<td><<b>Top:<</b><0d><</td><<td><<b>Bottom:<</b><1d><</td><<td><<b>Left:<</b><2d><</td><<td><<b>Right:<</b><3d><</td><</tr>\r\n"),
        pFF->GetPosition(SIDE_TOP),
        pFF->GetPosition(SIDE_BOTTOM),
        pFF->GetPosition(SIDE_LEFT),
        pFF->GetPosition(SIDE_RIGHT));

    WriteHelp(hfile, _T("<<tr><<td><<b>BackColor:<</b><0d><</td><<td><<b>BgPosX:<</b><1d><</td><<td><<b>BgPosY:<</b><2d><</td><</tr>\r\n"),
        pFF->_ccvBackColor,
        pFF->GetBgPosX(),
        pFF->GetBgPosY());

    WriteHelp(hfile, _T("<<tr><<td><<b>Padding:<</b><0d><</td><<td><<b>StyleFloat:<</b><1d><</td><<td><</td><<td><<b>Rectangular:<</b><2d><</td><<td><<b>ImgCtxCookie:<</b><3d><</td><</tr>\r\n"),
        pFF->_iPEI,
        pFF->_bStyleFloat,
        pFF->_fRectangular,
        pFF->_lImgCtxCookie); // the doc's bgUrl-imgCtx cache

    WriteHelp(hfile, _T("<<tr><<td><<b>OverflowX:<</b><0d><</td><<td><<b>OverflowY:<</b><1d><</td><<td><<b>VerticalAlign:<</b><2d><</td><<td><<b>CSSVerticalAlign:<</b><3d><</td><</tr>\r\n"),
        pFF->GetOverflowX(),
        pFF->GetOverflowY(),
        pFF->GetVerticalAlign(),
        pFF->HasCSSVerticalAlign());

    WriteHelp(hfile, _T("<<tr><<td><<b>ControlAlign:<</b><0d><</td><<td><<b>PageBreaks:<</b><1d><</td><<td><<b>PositionType:<</b><2d><</td><<td><<b>Expandos:<</b><3d><</td><</tr>\r\n"),
        pFF->_bControlAlign,
        pFF->_bPageBreaks,
        pFF->_bPositionType,
        pFF->_iExpandos);

    WriteHelp(hfile, _T("<<tr><<td><<b>Display:<</b><0d><</td><<td><<b>Visibility:<</b><1d><</td><<td><<b>ClearLeft:<</b><2d><</td><<td><<b>ClearRight:<</b><3d><</td><</tr>\r\n"),
        pFF->_bDisplay,
        pFF->_bVisibility,
        pFF->_fClearLeft ? 1 : 0,
        pFF->_fClearRight ? 1 : 0);

    WriteString(hfile, _T("</table></span></div>\r\n"));
}

void DumpFormatCaches()
{
    CCharFormatCache  * pCFCache = TLS(_pCharFormatCache);
    CParaFormatCache  * pPFCache = TLS(_pParaFormatCache);
    CFancyFormatCache * pFFCache = TLS(_pFancyFormatCache);
    HANDLE              hfile    = CreateFile(_T("c:\\formatcache.htm"),
                                        GENERIC_WRITE | GENERIC_READ,
                                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

    if (hfile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    SetFilePointer( hfile, 0, 0, 0 );

    WriteString( hfile, _T("\
<HTML>\r\n\
<head>\r\n\
<style>\r\n\
div     { padding-left:10; padding-right:10; padding-top:3; padding-bottom:2 }\r\n\
div.root   { background-color:eeeeee }\r\n\
div.c0     { background-color:ffe8e8 }\r\n\
div.c1     { background-color:e8ffff }\r\n\
div.c2     { background-color:e8ffe8 }\r\n\
div.c3     { background-color:ffe8ff }\r\n\
div.c4     { background-color:e8e8ff }\r\n\
H4         { margin-bottom:0; margin-top:10; cursor: hand }\r\n\
u          { cursor: hand }\r\n\
</style>\r\n"));
    WriteString( hfile, _T("\
<script>\r\n\
function OnClick()\r\n\
{\r\n\
  var srcElem = event.srcElement;\r\n\
\r\n\
  while(srcElem && srcElem.tagName != 'DIV')\r\n\
  {\r\n\
     srcElem = srcElem.parentElement;\r\n\
  }\r\n\
\r\n\
  if(srcElem)\r\n\
  {\r\n\
    var elem = srcElem.children.tags('SPAN');\r\n\
    var elem2 = srcElem.children.tags('B');\r\n\
    \r\n\
    if(elem.length > 0 && elem[0].className == 'c')\r\n\
    {\r\n\
      if(elem2.length > 1 && elem2[0].className == 'cc' && elem2[1].className == 'ff')\r\n\
      {\r\n\
        if(elem[0].style.display == '')\r\n\
        {\r\n\
          elem2[0].style.display = '';\r\n\
          elem2[1].style.display = 'none';\r\n\
        }\r\n\
        else\r\n\
        {\r\n\
          elem2[0].style.display = 'none';\r\n\
          elem2[1].style.display = '';\r\n\
        }\r\n\
      }\r\n\
      \r\n\
      elem[0].style.display = elem[0].style.display == '' ? 'none' : '';\r\n\
    }\r\n\
  }\r\n\
}\r\n\
</script>\r\n"));
    WriteString( hfile, _T("\
</head>\r\n\
<body>\r\n\
<span class=rootspan onclick=OnClick()>\r\n\
<div class=foo><B class=cc>+</B><B class=ff style='display:none'>-</B><U><B>Char  Format Cache</B></U><br>\r\n\
  <span class=c style='display:none'>\r\n"));
    if(pCFCache)
    {
        for(int i = 0; i < pCFCache->Size(); i++)
        {
            const CCharFormat * pCF = pCFCache->ElemData(i);

            if(pCF)
                DumpCharFormat(hfile, i, pCF);
        }
    }
    WriteString( hfile, _T("\
  </span>\r\n\
</div>\r\n\
<div class=foo><B class=cc>+</B><B class=ff style='display:none'>-</B><U><B>Para  Format Cache</B></U><br>\r\n\
  <span class=c style='display:none'>\r\n"));

   if(pPFCache)
    {
        for(int i = 0; i < pPFCache->Size(); i++)
        {
            const CParaFormat * pPF =  pPFCache->ElemData(i);

            if(pPF)
                DumpParaFormat(hfile, i, pPF);
        }
    }

    WriteString( hfile, _T("\
  </span>\r\n\
</div>\r\n\
<div class=foo><B class=cc>+</B><B class=ff style='display:none'>-</B><U><B>Fancy  Format Cache</B></U><br>\r\n\
  <span class=c style='display:none'>\r\n"));
   if(pFFCache)
    {
        for(int i = 0; i < pFFCache->Size(); i++)
        {
            const CFancyFormat * pFF = pFFCache->ElemData(i);

            if(pFF)
                DumpFancyFormat(hfile, i, pFF);
        }
    }
    WriteString( hfile, _T("\
  </span>\r\n\
</div>\r\n\
</span>\r\n\
</body>\r\n\
</html>\r\n"));

    CloseHandle(hfile);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\omrect.cxx ===
//=================================================================
//
//   File:      omrect.cxx
//
//  Contents:   COMRect and COMRectCollection classes
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OMRECT_HXX_
#define X_OMRECT_HXX_
#include "omrect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "omrect.hdl"

MtDefine(COMRect, ObjectModel, "COMRect")
MtDefine(COMRectCollection, ObjectModel, "COMRectCollections")
MtDefine(COMRectCollection_aryRects_pv, COMRectCollection, "COMRectCollection::::aryRects::pv")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COMRect::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLRect,                 // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+---------------------------------------------------------------
//
//  Member  : COMRect::COMRect(RECT *)
//
//  Sysnopsis : Constructs an COMRect instance given a rect pointer
//
//----------------------------------------------------------------

COMRect::COMRect(RECT *pRect)
{
    Assert(pRect);
    CopyRect(&_Rect, pRect);
}


//+---------------------------------------------------------------
//
//  Member  : COMRect::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COMRect::PrivateQueryInterface(REFIID iid, void **ppv)
{
    if(!ppv)
        return E_POINTER;
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLRect)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member  : COMRect::get_left
//
//  Sysnopsis : Returns the "left" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_left(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.left;

Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_left
//
//  Sysnopsis : Sets the "left" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_left(long lVal)
{
    _Rect.left = lVal;
    return SetErrorInfo(S_OK);
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::get_top
//
//  Sysnopsis : Returns the "top" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_top(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.top;
    
Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_top
//
//  Sysnopsis : Sets the "top" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_top(long lVal)
{
    _Rect.top = lVal;
    return SetErrorInfo(S_OK);
}


//+---------------------------------------------------------------
//
//  Member  : COMRect::get_right
//
//  Sysnopsis : Returns the "right" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_right(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.right;
    
Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_right
//
//  Sysnopsis : Sets the "right" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_right(long lVal)
{
    _Rect.right = lVal;
    return SetErrorInfo(S_OK);
}


//+---------------------------------------------------------------
//
//  Member  : COMRect::get_bottom
//
//  Sysnopsis : Returns the "bottom" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_bottom(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.bottom;
    
Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_bottom
//
//  Sysnopsis : Sets the "bottom" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_bottom(long lVal)
{
    _Rect.bottom = lVal;
    return SetErrorInfo(S_OK);
}


//
//============================================================================
//


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::~COMRectCollection
//
//----------------------------------------------------------------

COMRectCollection::~COMRectCollection()
{
    _aryRects.ReleaseAll();
}


//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COMRectCollection::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLRectCollection,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COMRectCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    if(!ppv)
        return E_POINTER;
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLRectCollection)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::length
//
//  Sysnopsis : Returns number of elements in the collection
//
//----------------------------------------------------------------

HRESULT
COMRectCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    // Simply return the array size
    *pLength = _aryRects.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::item
//
//  Sysnopsis : Returns rect at given index
//----------------------------------------------------------------

HRESULT
COMRectCollection::item(VARIANT * pvarIndex, VARIANT * pvarRet)
{
    HRESULT   hr = S_OK;
    CVariant  varArg;
    long      lIndex;

    if (!pvarRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // ECMA rule - return empty for access beyond array bounds
    V_VT(pvarRet) = VT_EMPTY;

    // first attempt ordinal access...
    hr = THR(varArg.CoerceVariantArg(pvarIndex, VT_I4));
    if (hr==S_OK)
    {
        lIndex = V_I4(&varArg);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItem(lIndex, pvarRet));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
COMRectCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryRects.EnumVARIANT(VT_DISPATCH,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::SetRects
//
//  Sysnopsis : Get the rects from given array of rects and save
//              them into the member array.
//
//----------------------------------------------------------------

HRESULT 
COMRectCollection::SetRects(CDataAry<RECT> *pSrcRect)
{
    HRESULT   hr = S_OK;
    int       nNumRects;
    COMRect * pOMRect;

    Assert(pSrcRect);
    nNumRects = pSrcRect->Size();
    Assert(nNumRects > 0);

    _aryRects.Grow(nNumRects);

    for(int i = 0; i < nNumRects; i++)
    {
        pOMRect = new COMRect(&(*pSrcRect)[i]);
        if (!pOMRect)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _aryRects[i] = pOMRect;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::FindByName
//
//  Sysnopsis : This function seraches for an item having given
//                name in the collection and returns its index.
//                It returns -1 if item is not found.
//              We do not support named items for rectangle 
//               collection so we always return a -1
//----------------------------------------------------------------
long 
COMRectCollection::FindByName(LPCTSTR pszName, BOOL fCaseSensitive)
{
    return -1;
}

//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::GetName
//
//  Sysnopsis : This virtual function returns the name of given item.
//              We do not support named collection access.
//----------------------------------------------------------------

LPCTSTR 
COMRectCollection::GetName(long lIdx)
{
    return NULL;
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::GetItem
//
//  Sysnopsis : Returns the item that has given order in the collection.
//              If the index is out of range returns S_FALSE.
//              If ppDisp is NULL only checks that range and returns
//               S_OK if index is in range, S_FALSE if out
//
//----------------------------------------------------------------

HRESULT 
COMRectCollection::GetItem( long lIndex, VARIANT *pvar )
{
    HRESULT hr;
    COMRect * pRect;

    if (lIndex < 0 || lIndex >= _aryRects.Size())
    {
        hr = S_FALSE;
		if(pvar)
			V_DISPATCH(pvar) = NULL;
        goto Cleanup;
    }

    if(!pvar)
    {
        // No ppDisp, caller wanted only to check for correct range
        hr = S_OK;
        goto Cleanup;
    }

    V_DISPATCH(pvar) = NULL;

    pRect = _aryRects[lIndex];
    Assert(pRect);
    hr = THR(pRect->PrivateQueryInterface(IID_IDispatch, (void **) &V_DISPATCH(pvar)));
    if (hr)
        goto Cleanup;

    V_VT(pvar) = VT_DISPATCH;
Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\shape.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       shape.cxx
//
//  Contents:   CShape - generic shape class implementation
//
//  Classes:    CShape
//
//---------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_DRAWINFO_HXX_
#include "drawinfo.hxx"
#define X_DRAWINFO_HXX_
#endif

DeclareTag(tagShape, "CShape", "CShape methods");
MtDefine(CShape, Utilities, "CShape")
MtDefine(CWigglyAry, Utilities, "CWigglyAry")
MtDefine(CWigglyAry_pv, Utilities, "CWigglyAry_pv")
MtDefine(CStateArray_pv, Utilities, "CStateArray_pv")
MtDefine(CVSegArray_pv, Utilities, "CVSegArray_pv")
MtDefine(CRectArray_pv, Utilities, "CRectArray_pv")

// Clipping drawing helpers
static void PatBltClipped(XHDC hDC, int x, int y, int dx, int dy, DWORD rop);
static void PatBltRectClipped(XHDC hDC, RECT * prc, int cThick, DWORD rop);

//+-------------------------------------------------------------------------
//
//  Method:     CShape::DrawFocus
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape to
//              indicate that this shape has the focus.
//
//--------------------------------------------------------------------------

void
CShape::DrawShape(CFormDrawInfo * pDI)
{
    POINT           pt;
    XHDC            hDC = pDI->GetDC() ;
    COLORREF        crOldBk, crOldFg ;
    CRect           rectBound;
    const SIZECOORD cThick = (_cThick) ? _cThick : ((g_fHighContrastMode) ? 2 : 1);

    GetBoundingRect(&rectBound);
    if (!rectBound.Intersects(*pDI->ClipRect()))
        return;

    crOldBk = SetBkColor (hDC, RGB (0,0,0)) ;
    crOldFg = SetTextColor (hDC, RGB(0xff,0xff,0xff)) ;

    GetViewportOrgEx (hDC, &pt) ;
    SetBrushOrgEx(hDC, POSITIVE_MOD(pt.x,8)+POSITIVE_MOD(rectBound.left, 8),
                       POSITIVE_MOD(pt.y,8)+POSITIVE_MOD(rectBound.top, 8), NULL);

    Draw(hDC, cThick);

    SetTextColor (hDC, crOldFg);
    SetBkColor   (hDC, crOldBk);
}



//+-------------------------------------------------------------------------
//
//  Method:     CRectShape::GetBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the region(s) enclosed by
//              this shape.
//
//--------------------------------------------------------------------------
void
CRectShape::GetBoundingRect(CRect * pRect)
{
    Assert(pRect);
    *pRect = _rect;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRectShape::OffsetShape
//
//  Synopsis:   Shifts the shape by the given amounts along x and y axes.
//
//--------------------------------------------------------------------------
void
CRectShape::OffsetShape(const CSize & sizeOffset)
{
    _rect.OffsetRect(sizeOffset);
}


//+-------------------------------------------------------------------------
//
//  Method:     CRectShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CRectShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    static short bBrushBits[8] = {0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55};

    HBITMAP         hbm;
    HBRUSH          hBrushOld;

    TraceTag((tagShape, "CRectShape::Draw"));

    hbm = CreateBitmap (8, 8, 1, 1, (LPBYTE)bBrushBits) ;
    if (hbm)
    {
        hBrushOld = (HBRUSH)SelectObject(hDC, CreatePatternBrush (hbm));
        if (hBrushOld)
        {
            PatBltRectClipped(hDC, &_rect, cThick, PATINVERT);
            DeleteObject(SelectObject(hDC, hBrushOld));
        }
        DeleteObject (hbm);
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CCircleShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CCircleShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    HBRUSH  hBrushOld;
    HPEN    hPenOld;
    int     nROPOld;

    TraceTag((tagShape, "CCircleShape::Draw"));

    // Select transparent brush to fill the circle
    nROPOld = SetROP2(hDC, R2_XORPEN);
    hPenOld = (HPEN)SelectObject(hDC, (HBRUSH)GetStockObject(WHITE_PEN));
    hBrushOld  = (HBRUSH)SelectObject(hDC, (HBRUSH)GetStockObject(HOLLOW_BRUSH));


    // TODO (MohanB) cThick ignored
    Ellipse(hDC, _rect.left, _rect.top, _rect.right, _rect.bottom);

    SelectObject(hDC, hBrushOld);
    SelectObject(hDC, hPenOld);
    SetROP2(hDC, nROPOld);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCircleShape::Set
//
//  Synopsis:   Set using center and radius
//
//--------------------------------------------------------------------------
void
CCircleShape::Set(POINTCOORD xCenter, POINTCOORD yCenter, SIZECOORD radius)
{
    _rect.SetRect(xCenter - radius, yCenter - radius, xCenter + radius, yCenter + radius);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetPolyBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the given polygon.
//
//--------------------------------------------------------------------------
void
GetPolyBoundingRect(CPointAry& aryPoint, CRect * pRect)
{
    UINT    c;
    POINT * pPt;

    Assert(pRect);
    pRect->SetRectEmpty();

    for (c = aryPoint.Size(), pPt = aryPoint; c > 0; c--, pPt++)
    {
        pRect->Union(*pPt);
    }

}

//+-------------------------------------------------------------------------
//
//  Method:     CPolyShape::GetBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the region(s) enclosed by
//              this shape.
//
//--------------------------------------------------------------------------
void
CPolyShape::GetBoundingRect(CRect * pRect)
{
    GetPolyBoundingRect(_aryPoint, pRect);
}

//+-------------------------------------------------------------------------
//
//  Method:     CPolyShape::OffsetShape
//
//  Synopsis:   Shifts the shape by the given amounts along x and y axes.
//
//--------------------------------------------------------------------------
void
CPolyShape::OffsetShape(const CSize & sizeOffset)
{
    CPoint *    ppt;
    long        cPoints;

    for(cPoints = _aryPoint.Size(), ppt = (CPoint *)&(_aryPoint[0]);
        cPoints > 0;
        cPoints--, ppt++)
    {
        *ppt += sizeOffset;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     DrawPoly
//
//  Synopsis:   Draw the boundary of the given polygon.
//
//--------------------------------------------------------------------------

void
DrawPoly(CPointAry & aryPoint, XHDC hDC, SIZECOORD cThick)
{
    POINT * ppt;
    UINT    c;
    HPEN    hPenOld;
    HBRUSH  hBrushOld;
    int     nROPOld;

    // Do we have enough points to draw a polygon ?
    if (aryPoint.Size() < 2)
        return;

    // TODO (MohanB) cThick ignored

    nROPOld = SetROP2(hDC, R2_XORPEN);
    hPenOld = (HPEN)SelectObject(hDC, (HBRUSH)GetStockObject(WHITE_PEN));
    hBrushOld  = (HBRUSH)SelectObject(hDC, (HBRUSH)GetStockObject(HOLLOW_BRUSH));

    MoveToEx(hDC, aryPoint[0].x, aryPoint[0].y, (POINT *)NULL);
    for(c = aryPoint.Size(), ppt = &(aryPoint[1]);
        c > 1;                  // c > 1, because we MoveTo'd the first pt
        ppt++, c--)
    {
        LineTo(hDC, ppt->x, ppt->y);
    }
    //
    // If there are only 2 points in the polygon, we don't want to draw
    // the same line twice and end up with nothing!
    //

    if(aryPoint.Size() != 2)
    {
        LineTo(hDC, aryPoint[0].x, aryPoint[0].y);

    }
    SelectObject(hDC, hBrushOld);
    SelectObject(hDC, hPenOld);
    SetROP2(hDC, nROPOld);
}


//+-------------------------------------------------------------------------
//
//  Method:     CPolyShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CPolyShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    TraceTag((tagShape, "CPolyShape::Draw"));

    DrawPoly(_aryPoint, hDC, cThick);

}


//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::~CWigglyShape
//
//  Synopsis:   Release the CRectShape objects in the array
//
//--------------------------------------------------------------------------
CWigglyShape::~CWigglyShape()
{
    UINT           c;
    CRectShape **  ppWiggly;

    for(c = _aryWiggly.Size(), ppWiggly = _aryWiggly; c > 0; c--, ppWiggly++)
    {
        delete *ppWiggly;
        *ppWiggly = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::GetBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the region(s) enclosed by
//              this shape.
//
//--------------------------------------------------------------------------
void
CWigglyShape::GetBoundingRect(CRect * pRect)
{
    UINT           c;
    CRectShape **  ppWiggly;
    CRect          rectWiggly;

    Assert(pRect);
    pRect->SetRectEmpty();

    for(c = _aryWiggly.Size(), ppWiggly = _aryWiggly; c > 0; c--, ppWiggly++)
    {
        (*ppWiggly)->GetBoundingRect(&rectWiggly);
        pRect->Union(rectWiggly);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::OffsetShape
//
//  Synopsis:   Shifts the shape by the given amounts along x and y axes.
//
//--------------------------------------------------------------------------
void
CWigglyShape::OffsetShape(const CSize & sizeOffset)
{
    CRectShape ** ppWiggly;
    long          cWigglies;

    for(cWigglies = _aryWiggly.Size(), ppWiggly = _aryWiggly;
        cWigglies > 0;
        cWigglies--, ppWiggly++)
    {
        (*ppWiggly)->_rect.OffsetRect(sizeOffset);

    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CWigglyShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    static short bBrushBits[8] = {0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55};

    HBITMAP         hbm;
    HBRUSH          hBrushOld;

    TraceTag((tagShape, "CWigglyShape::Draw"));
    
    hbm = CreateBitmap (8, 8, 1, 1, (LPBYTE)bBrushBits) ;
    hBrushOld = (HBRUSH)SelectObject(hDC, CreatePatternBrush (hbm));


    // In the case there is just one rect, just draw the rect
    // This will be the majority of cases.
    if (_aryWiggly.Size() == 1)
    {
        _aryWiggly[0]->Draw(hDC, cThick);
    }
    else
    {
        DrawMultiple(hDC, cThick);
    }

    DeleteObject(SelectObject(hDC, hBrushOld));
    DeleteObject (hbm);
}


// here are some data structures used by DrawMultiple, below

DECLARE_CStackPtrAry(CRectArray, CRectShape *, 16, Mt(Mem), Mt(CRectArray_pv));

struct SWEEPSTATE { LONG cx;  LONG cDelta; };
DECLARE_CStackDataAry(CStateArray, SWEEPSTATE, 16, Mt(Mem), Mt(CStateArray_pv));

struct VSEGMENT { long cx;  CPoint ptTopLeft; };
DECLARE_CStackDataAry(CVSegArray, VSEGMENT, 16, Mt(Mem), Mt(CVSegArray_pv));


//+-------------------------------------------------------------------------
//
//  Method:     AddDelta (local helper)
//
//  Synopsis:   Add an (x, delta) pair to the given sweep state array.
//              Keep the array sorted in descending order by x, so that
//              looping through it backwards corresponds to left-to-right.
//
//--------------------------------------------------------------------------

static void
AddDelta(CStateArray *pary, LONG cx, LONG cDelta)
{
    int i;
    int n = pary->Size();

    for (i = 0;  i < n;  ++i)
    {
        if ((*pary)[i].cx <= cx)
            break;
    }

    if (i < n  &&  (*pary)[i].cx == cx)
    {
        // update delta for an existing x
        (*pary)[i].cDelta += cDelta;

        // if it's now zero, remove it
        if ((*pary)[i].cDelta == 0)
        {
            pary->Delete(i);
        }
    }
    else
    {
        // add a new x
        SWEEPSTATE s = {cx, cDelta};
        pary->InsertIndirect(i, &s);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::DrawMultiple
//
//  Synopsis:   When there's more than one rect, perform a sweep-line algorithm
//              to identify which edges (or pieces thereof) need to be drawn.
//              We only draw an edge where one side of the edge is outside all
//              the rects and the other is inside at least one.  We need to
//              handle cases where edges from different rects lie atop one
//              another.  We'll sweep a horizontal line from top to bottom.
//              At each step, we'll draw horizontal segments that lie on the
//              sweep line, identify and remember vertical segments that begin
//              on the sweep line, and draw vertical segments that end on
//              the sweep line.
//
//--------------------------------------------------------------------------

void
CWigglyShape::DrawMultiple(XHDC hDC, SIZECOORD cThick)
{
    int             i, j;
    CRectShape *    pWiggly;
    int             cWigglys = _aryWiggly.Size();

    // Step 1.  To prepare for the sweep-line loop, make two sorted lists of the
    // rects, one sorted by top edge, the other by bottom edge.

    CRectArray aryByTop;
    CRectArray aryByBottom;

    aryByTop.EnsureSize(cWigglys);
    aryByBottom.EnsureSize(cWigglys);
    for (i = 0;  i < cWigglys;  ++i)    // insertion sort
    {
        pWiggly = _aryWiggly[i];
        
        for (j = i-1;  j>=0 && aryByTop[j]->_rect.top > pWiggly->_rect.top;  --j)
        {
            aryByTop[j+1] = aryByTop[j];
        }
        aryByTop[j+1] = pWiggly;

        for (j = i-1;  j>=0 && aryByBottom[j]->_rect.bottom > pWiggly->_rect.bottom;  --j)
        {
            aryByBottom[j+1] = aryByBottom[j];
        }
        aryByBottom[j+1] = pWiggly;
    }

    // Step 2.  Initialize two arrays that hold the state of the sweep
    // line just before and just after the current y position.  The state is
    // represented by an array of (x, delta) pairs, one for each x-coordinate
    // where a vertical line crosses the sweep line.  The delta measures the
    // change in the number of enclosing rectangles as we cross from left to right.
    // Each array ends with a sentinel value (x = infinity) to make loops easy.

    CStateArray aryState1, aryState2;

    aryState1.SetSize(1);
    aryState1[0].cx = MAXLONG;

    aryState2.SetSize(1);
    aryState2[0].cx = MAXLONG;

    CStateArray *paryStateAbove = &aryState1;
    CStateArray *paryStateBelow = &aryState2;
    CStateArray *paryStateTemp;

    // Step 3.  Initialize (to empty) the list of visible vertical segments
    // that cross the sweep line.  Each edge is represented by its x coordinate,
    // plus the top-left point where we'll start drawing it once the sweep
    // line reaches its bottom.

    CVSegArray aryVSegments;
    VSEGMENT vseg;

    // Step 4.  Start the sweep line.

    int iTop = 0,  iBottom = 0;
    LONG x, y;

    while (iBottom < cWigglys)  // iBottom <= iTop, so this test is enough
    {
        Assert(iBottom <= iTop);

        // Step 5.  Advance sweep line to the next interesting y, namely the
        // smaller of the first remaining values in the "top" and "bottom"
        // lists.

        y = aryByBottom[iBottom]->_rect.bottom;
        if (iTop < cWigglys && y > aryByTop[iTop]->_rect.top)
            y = aryByTop[iTop]->_rect.top;

        // Step 6.  The sweep state just above y is the same as the state just
        // below the previous y.  Switch the roles of above and below.  To
        // prepare for computing the sweep state just below y,
        // copy the state just above it.

        paryStateTemp = paryStateAbove;
        paryStateAbove = paryStateBelow;
        paryStateBelow = paryStateTemp;

        paryStateBelow->Grow(paryStateAbove->Size());
        for (i = paryStateAbove->Size() - 1;  i >= 0;  --i)
        {
            (*paryStateBelow)[i] = (*paryStateAbove)[i];
        }

        // Step 7.  Change the state below y by accounting for the rects whose
        // top or bottom edge is at y.

        for ( ;  iTop < cWigglys && y == aryByTop[iTop]->_rect.top;  ++iTop)
        {
            AddDelta( paryStateBelow, aryByTop[iTop]->_rect.left,  +1 );
            AddDelta( paryStateBelow, aryByTop[iTop]->_rect.right, -1 );
        }

        for ( ;  iBottom < cWigglys && y == aryByBottom[iBottom]->_rect.bottom;  ++iBottom)
        {
            AddDelta( paryStateBelow, aryByBottom[iBottom]->_rect.left,  -1 );
            AddDelta( paryStateBelow, aryByBottom[iBottom]->_rect.right, +1 );
        }

        // Step 8.  Move left-to-right across the sweep line, stopping at each
        // x-coordinate mentioned in either state.

        int iAbove = paryStateAbove->Size() - 1;
        int iBelow = paryStateBelow->Size() - 1;
        LONG cRectsAbove = 0,  cRectsBelow = 0;
        LONG xStart = 0, yStart = 0;        // current horizontal segment

        for (;;)
        {
            x = (*paryStateAbove)[iAbove].cx;
            if (x > (*paryStateBelow)[iBelow].cx)
                x = (*paryStateBelow)[iBelow].cx;
            if (x == MAXLONG)
                break;

            // Step 9.  Determine whether each of the four quadrants around
            // (x,y) is inside or outside the region.  Encode the results
            // in a string of four bits where 1=inside, 0=outside.  The
            // bits, in msb-to-lsb order are: above-left, above-right,
            // below-left, below-right.

            unsigned u = ((cRectsAbove>0) <<3 ) | ((cRectsBelow>0) << 1);

            for ( ;  x == (*paryStateAbove)[iAbove].cx;  --iAbove)
            {
                cRectsAbove += (*paryStateAbove)[iAbove].cDelta;
            }

            for ( ;  x == (*paryStateBelow)[iBelow].cx;  --iBelow)
            {
                cRectsBelow += (*paryStateBelow)[iBelow].cDelta;
            }

            u |= ((cRectsAbove>0) << 2) | ((cRectsBelow>0) << 0);

            // Step 10.  The interesting part.  Depending on what's happening
            // near (x, y), start or stop visible segments.  The best way
            // to understand what to do is to simply draw the picture.  Words
            // don't help much.  Except to note that at corners, we always
            // give the corner to the horizontal segment.

            #define StartHorizontalSegment(x, cx, cy) \
                xStart = cx; \
                yStart = cy;

            #define EndHorizontalSegment(x, cx, cy) \
                PatBltClipped (hDC, \
                        xStart, yStart, \
                        cx-xStart, cy-yStart, \
                        PATINVERT);

            #define StartVerticalSegment(x, xx, yy) \
                vseg.cx = x; \
                vseg.ptTopLeft.x = xx; \
                vseg.ptTopLeft.y = yy; \
                aryVSegments.AppendIndirect(&vseg);

            #define EndVerticalSegment(x, xx, yy) \
                for (i=aryVSegments.Size()-1; i>=0; --i) \
                { \
                    if (x == aryVSegments[i].cx) \
                        break; \
                } \
                if (i >= 0) \
                { \
                    PatBltClipped (hDC, \
                            aryVSegments[i].ptTopLeft.x, aryVSegments[i].ptTopLeft.y, \
                            xx-aryVSegments[i].ptTopLeft.x, yy-aryVSegments[i].ptTopLeft.y, \
                            PATINVERT); \
                    aryVSegments.Delete(i); \
                }
                    
                
            switch (u)
            {
            case 0x0:   // 00/00    this shouldn't happen
            default:    //          this really shouldn't happen
                AssertSz(0, "This shouldn't happen");
                break;

            case 0x1:   // 00/01
                StartHorizontalSegment(x, x, y);
                StartVerticalSegment(x, x, y+cThick);
                break;

            case 0x3:   // 00/11
                break;

            case 0x2:   // 00/10
                EndHorizontalSegment(x, x, y+cThick);
                StartVerticalSegment(x, x-cThick, y+cThick);
                break;

            case 0x4:   // 01/00
                StartHorizontalSegment(x, x, y-cThick);
                EndVerticalSegment(x, x+cThick, y-cThick);
                break;

            case 0x5:   // 01/01
                break;

            case 0x6:   // 01/10
                EndHorizontalSegment(x, x, y+cThick);
                StartHorizontalSegment(x, x, y-cThick);
                EndVerticalSegment(x, x+cThick, y-cThick);
                StartVerticalSegment(x, x-cThick, y+cThick);
                break;

            case 0x7:   // 01/11
                EndHorizontalSegment(x, x+cThick, y+cThick);
                EndVerticalSegment(x, x+cThick, y);
                break;

            case 0x8:   // 10/00
                EndHorizontalSegment(x, x, y);
                EndVerticalSegment(x, x, y-cThick);
                break;

            case 0x9:   // 10/01
                EndHorizontalSegment(x, x, y);
                StartHorizontalSegment(x, x, y);
                EndVerticalSegment(x, x, y-cThick);
                StartVerticalSegment(x, x, y+cThick);
                break;

            case 0xA:   // 10/10
                break;

            case 0xB:   // 10/11
                StartHorizontalSegment(x, x-cThick, y);
                EndVerticalSegment(x, x, y);
                break;

            case 0xC:   // 11/00
                break;

            case 0xD:   // 11/01
                EndHorizontalSegment(x, x+cThick, y);
                StartVerticalSegment(x, x, y);
                break;

            case 0xE:   // 11/10
                StartHorizontalSegment(x, x-cThick, y-cThick);
                StartVerticalSegment(x, x-cThick, y);
                break;

            case 0xF:   // 11/11
                break;
            }
            
        } // for (;;) -- left-to-right scan across sweep line

        Assert(cRectsAbove == 0 && cRectsBelow == 0);

    } // while (iBottom < cWigglys) -- main sweep-line loop

    Assert(aryVSegments.Size() == 0);
}

//+-----------------------------------------------------------------------------
//
//  Method:     PatBltClipped
//
//  Synopsis:   Draw specified rectangle, as XHDC::PatBlt() do,
//              but clip it before drawing, if XHDC contains proper clipping data.
//
//  Arguments:  hDC     extended DC to draw in
//              x,y     rectangle left top (source coords)
//              dx,dy   rectangle size (source coords)
//              rop     rater operation code
//
//  Note:
//      there is a suspicion that XHDC should do clipping itself.
//      If it will be corrected so, this method can be removed, with changing
//      calls to PatBlt(XHDC...) (mikhaill 10/27/00, bug 6672)
//
//------------------------------------------------------------------------------

static void
PatBltClipped(XHDC hDC, int x, int y, int dx, int dy, DWORD rop)
{
    CRect const*  pClipRect = 0;
    {
        const CDispSurface *pSurface = hDC.pSurface();
        if (pSurface)
        {
            CDispClipTransform const* pTransform = ((CDispSurface*)pSurface)->GetTransform();
            if (pTransform)
            {
                pClipRect = &pTransform->GetClipRect();
            }
        }
    }

    CRect rc(x, y, x+dx, y+dy);
    if (pClipRect)
        rc.IntersectRect(*pClipRect);
    if (!rc.IsEmpty())
        PatBlt(hDC, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, rop);
}

//+-----------------------------------------------------------------------------
//
//  Method:     PatBltRectClipped
//
//  Synopsis:   Draw specified rectangle boundaries
//
//  Arguments:  hDC     extended DC to draw in
//              prc     rectangle to draw, in hDC source coords
//              cThick  boundary thickness
//              rop     rater operation code
//
//  Note:
//      This routine made by cut-and-paste from PatBltRect(), in order to add clipping.
//      If XHDC implementation will be corrected to provide clipping itself,
//      these two routines can be combined in single one.
//
//------------------------------------------------------------------------------

static void
PatBltRectClipped(XHDC hDC, RECT * prc, int cThick, DWORD rop)
{
    PatBltClipped(
            hDC,
            prc->left,
            prc->top,
            prc->right - prc->left,
            cThick,
            rop);

    PatBltClipped(
            hDC,
            prc->left,
            prc->bottom - cThick,
            prc->right - prc->left,
            cThick,
            rop);

    PatBltClipped(
            hDC,
            prc->left,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            rop);

    PatBltClipped(
            hDC,
            prc->right - cThick,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            rop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\recalc.cxx ===
// ---------------------------------------------------------
//
// Microsoft Trident
// Copyright Microsoft corporation 1998
//
// File: recalc.cxx
//
// The Trident recalc engine: CRecalcEngine
//
// ---------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECALC_H
#define X_RECALC_H
#include "recalc.h"
#endif

#ifndef X_RECALC_HXX_
#define X_RECALC_HXX_
#include "recalc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

MtDefine(Recalc, Mem, "Recalc")
MtDefine(CRecalcEngine, Recalc, "CRecalcEngine")
MtDefine(CRecalcObject, Recalc, "CRecalcObject")
MtDefine(CRecalcProperty, Recalc, "CRecalcProperty")

#ifndef RECALC_USE_SCRIPTDEBUG
MtDefine(CScriptAuthorHolder, Recalc, "CScriptAuthorHolder")
#endif

DeclareTag(tagRecalcEngine, "Recalc Engine", "Recalc Engine trace")
DeclareTag(tagRecalcMemory, "Recalc Memory", "Track recalc memory use")
DeclareTag(tagRecalcDump, "Recalc Dump", "Enable dumping of recalc graph")
DeclareTag(tagRecalcEval, "Recalc Eval", "Trace expression evaluation in recalc")

ExternTag(tagRecalcStyle);

#if DBG == 1
unsigned CRecalcProperty::s_serialNumber = 0;
unsigned CRecalcObject::s_serialNumber = 0;
unsigned CRecalcEngine::s_serialNumber = 0;
#ifndef RECALC_USE_SCRIPTDEBUG
unsigned CScriptAuthorHolder::s_serialNumber = 0;
#endif
#endif

#ifndef RECALC_USE_SCRIPTDEBUG
//---------------------------------------------------------------
//
// Method:      CScriptAuthorHolder::CScriptAuthorHolder
//
// Description: the constructor
//
//---------------------------------------------------------------
CScriptAuthorHolder::CScriptAuthorHolder()
{
#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcMemory, "Constructing CScriptAuthorHolder # %d p=%08x", _serialNumber, this));
#endif
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::~CScriptAuthorHolder
//
// Description: the destroyer
//
//---------------------------------------------------------------}
CScriptAuthorHolder::~CScriptAuthorHolder()
{
    Assert(_pScriptAuthor == 0);
    TraceTag((tagRecalcMemory, "Destroying CScriptAuthorHolder # %d p=%08x", _serialNumber, this));
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::Init
//
// Description: Initialize the holder, actually CoCreates the engine
//
//---------------------------------------------------------------
HRESULT
CScriptAuthorHolder::Init(LPOLESTR szLanguage)
{
    CLSID clsid;
    HRESULT hr;
    CStr strTemp;

    hr = THR(_sLanguage.Set(szLanguage));
    if (hr)
        goto Cleanup;

    hr = THR(strTemp.Set(_sLanguage));
    if (hr)
        goto Cleanup;

    hr = THR(strTemp.Append(_T(" Author")));
    if (hr)
        goto Cleanup;

    hr = THR(CLSIDFromProgID(strTemp, &clsid));
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScriptAuthor, (LPVOID *)&_pScriptAuthor));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::Compare
//
// Description: Are you the right engine for me?
//
//---------------------------------------------------------------
BOOL
CScriptAuthorHolder::Compare(LPOLESTR szLanguage)
{
    return (_tcsicmp(szLanguage, _sLanguage) == 0);
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::Detach
//
// Description: 'Hallo, my name is Diego Montoya, you killed my
//              father, prepare to die.'  Time to free all resources
//
//---------------------------------------------------------------
void
CScriptAuthorHolder::Detach()
{
    TraceTag((tagRecalcMemory, "Destroying CScriptAuthorHolder # %d p=%08x", _serialNumber, this));

    ClearInterface(&_pScriptAuthor);
}

#endif

//---------------------------------------------------------------
//
// Function:    CreateRecalcEngine(IUnknown
//
// Description: A helper used by our class factory to get things going
//
//---------------------------------------------------------------
STDMETHODIMP
CreateRecalcEngine(IUnknown *pUnkOuter, IUnknown **ppUnk)
{
    HRESULT hr;

    Assert(ppUnk);

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
        *ppUnk = 0;
    }
    else
    {
        *ppUnk = static_cast<IUnknown *>(static_cast<IRecalcEngine *>(new CRecalcEngine()));
        hr = *ppUnk ? S_OK : E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::CRecalcEngine
//
// Description: The constructor
//
//---------------------------------------------------------------}
CRecalcEngine::CRecalcEngine() : _ulRefs(1)
{
    _iFoundLast = -1;
    _pUnkFoundLast = 0;

#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcDetail, "Constructing CRecalcEngine # %d p=%08x", _serialNumber, this));
#endif
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::~CRecalcEngine
//
// Description: The destructor
//
//---------------------------------------------------------------}
CRecalcEngine::~CRecalcEngine()
{
    TraceTag((tagRecalcDetail, "Destroying CRecalcEngine # %d p=%08x", _serialNumber, this));
    Assert(_objects.Size() == 0);
    Assert(_ulRefs == 0);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::QueryInterface
//
// Description: IUnknown::QueryInterface
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if (ppv == NULL)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IRecalcEngine *)this, IUnknown)
        QI_INHERITS((IRecalcEngine *)this, IRecalcEngine)
        QI_INHERITS(this, IObjectWithSite)
    default:
        if (IsEqualIID(iid, CLSID_CRecalcEngine))
        {
            *ppv = this;
            return S_OK;
        }
    }
    if (*ppv == NULL)
        RRETURN(E_NOINTERFACE);

    (*(IRecalcEngine **)ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::AddRef
//
// Description: IUnknown::AddRef
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcEngine::AddRef()
{
    return ++_ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::Release
//
// Description: IUnknown::Release
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcEngine::Release()
{
    Assert(_ulRefs > 0);

    unsigned long ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        Assert(_pHost == 0 && "Recalc Engine Released before SetSite(NULL)");
        Assert(_objects.Size() == 0);
#ifndef RECALC_USE_SCRIPTDEBUG
        Assert(_authors.Size() == 0);
#endif
        delete this;
    }
    return ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::Detach
//
// Description: Blows away all objects, unwinding any ref loops as we go
//
//---------------------------------------------------------------
void
CRecalcEngine::Detach()
{
    CRecalcObject **ppObject;
#ifndef RECALC_USE_SCRIPTDEBUG
    CScriptAuthorHolder **ppAuthor;
#endif

    int i;

    for (i = _objects.Size() , ppObject = _objects; i > 0 ; i-- , ppObject++)
    {
        (*ppObject)->Detach();
        (*ppObject)->Release();
    }
    _objects.DeleteAll();

#ifndef RECALC_USE_SCRIPTDEBUG
    for (i = _authors.Size() , ppAuthor = _authors ; i > 0 ; i-- , ppAuthor++)
    {
        (*ppAuthor)->Detach();
        delete (*ppAuthor);
    }
    _authors.DeleteAll();
#endif
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::SetSite
//
// Description: IObjectWithSite::SetSite
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::SetSite(IUnknown *pUnk)
{
    HRESULT hr;

    // We only expect to be called twice:
    // once at setup (!_pUnk && pUnk) and
    // once at teardown (_pUnk && !pUnk).
    //
    Assert((!_pHost && pUnk) || (_pHost && !pUnk));

    if (_pHost)
    {
        Detach();
        ClearInterface(&_pHost);
        WHEN_DBG(ClearInterface(&_pDebugHost);)
    }

    Assert(_objects.Size() == 0);
#ifndef RECALC_USE_SCRIPTDEBUG
    Assert(_authors.Size() == 0);
#endif

    if (pUnk)
    {
        hr = THR(pUnk->QueryInterface(IID_IRecalcHost, (LPVOID *)&_pHost));
#if DBG == 1
        if (SUCCEEDED(hr))
            pUnk->QueryInterface(IID_IRecalcHostDebug, (LPVOID *)&_pDebugHost);
#endif
    }
    else
        hr = S_OK;

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::GetSite
//
// Description: IObjectWithSite::GetSite
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::GetSite(REFIID riid, LPVOID *ppUnk)
{
    if (ppUnk == 0)
        RRETURN(E_INVALIDARG);
    *ppUnk = 0;
    if (!_pHost)
        RRETURN(E_FAIL);

    RRETURN(_pHost->QueryInterface(riid, ppUnk));
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::RemoveObject
//
// Description: Removes an object from the recalc engine
//
//---------------------------------------------------------------
void
CRecalcEngine::RemoveObject(CRecalcObject *pObject, BOOL fRemoveDependencies /* = FALSE */)
{
    int i = _objects.Find(pObject);
    if (i >= 0)
    {
        _objects[i]->Detach(fRemoveDependencies);

        // fRemoveDependencies may cause other objects to be deleted
        // so we need to recompute the index
        if (fRemoveDependencies)
        {
            i = _objects.Find(pObject);
            Assert (i >= 0);
        }
 
        _objects.ReleaseAndDelete(i);
    }
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::RecalcAll
//
// Description: IRecalcEngine::RecalcAll
//
//              Recalculates all dirty expressions.  Ignores dirty
//              state if fForce is set.
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::RecalcAll(BOOL fForce)
{
    HRESULT hr = S_OK;
    int i;

    TraceTag((tagRecalcEngine, "CRecalcEngine::RecalcAll(%d)", fForce));

    // Find any properties with dirty dependencies and update them.
    // Although resolving dependencies can change the graph (by adding
    // new property objects), none of the new objects should require
    // dependency checking

    WHEN_DBG(int cDirtyDeps = _dirtyDeps.Size());

    _fInDeps = TRUE;
    for (i = 0 ; i < _dirtyDeps.Size() ; i++)
    {
        _dirtyDeps[i]->UpdateDependencies();
    }

    _fInDeps = FALSE;

    Assert(cDirtyDeps == _dirtyDeps.Size());

    _dirtyDeps.DeleteAll();

    _fInRecalc = TRUE;

    // Now find anyone who needs recalc
    for (i = 0; i < _objects.Size(); i++)
    {
        hr = THR(_objects[i]->RecalcAll(fForce));
        if (hr)
            break;
    }

    _fInRecalc = FALSE;

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::SetExpression
//
// Description: IRecalcEngine::SetExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::SetExpression(IUnknown *pUnk, DISPID dispid, LPOLESTR szExpression, LPOLESTR szLanguage)
{
    CRecalcProperty *pProperty = 0;
    HRESULT hr;

    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

#if DBG == 1
    if (_fInRecalc)
        TraceTag((tagRecalcEngine, "SetExpression while in recalc: %ls", szExpression));

    if (_fInDeps)
        TraceTag((tagRecalcEngine, "SetExpression while in recalc deps: %ls", szExpression));
#endif

    hr = THR(FindProperty(pUnk, dispid, TRUE, &pProperty));
    if (hr)
        goto Cleanup;

    hr = THR(pProperty->SetExpression(szExpression, szLanguage));
    if (hr)
        goto Cleanup;

Cleanup:
    if (hr)
    {
        if (pProperty)
            pProperty->DeleteIfEmpty();
    }

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::GetExpression
//
// Description: IRecalcEngine::GetExpression
//
// Returns:     S_OK or S_FALSE
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::GetExpression(IUnknown *pUnk, DISPID dispid, BSTR *pstrExpression, BSTR *pstrLanguage)
{
    CRecalcProperty *pProperty = NULL;

    HRESULT hr = THR(FindProperty(pUnk, dispid, FALSE, &pProperty));
    if (!hr)
    {
        hr = THR(pProperty->GetExpression(pstrExpression, pstrLanguage));
    }

    if (hr == S_FALSE)
    {
        *pstrExpression = 0;
        *pstrLanguage = 0;
    }
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::ClearExpression
//
// Description: IRecalcEngine::ClearExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::ClearExpression(IUnknown *pUnk, DISPID dispid)
{
    CRecalcProperty *pProperty = NULL;

    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

    HRESULT hr = THR(FindProperty(pUnk, dispid, FALSE, &pProperty));
    if (!hr)
    {
        hr = THR(pProperty->ClearExpression());
    }

    RRETURN1(hr, S_FALSE);
}


//---------------------------------------------------------------
//
// Function:    CRecalcEngine::BeginStyle
//
// Description: IRecalcEngine::BeginStyle
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::BeginStyle(IUnknown *pUnk)
{
    HRESULT hr = E_INVALIDARG;
    CRecalcObject *pObject;

    Assert(!_fInRecalc);

    hr = THR(FindObject(pUnk, TRUE, &pObject));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->BeginStyle());
    if (hr)
        goto Cleanup;
Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::BeginStyle
//
// Description: IRecalcEngine::EndStyle
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::EndStyle(IUnknown *pUnk)
{
    HRESULT hr = E_INVALIDARG;
    CRecalcObject *pObject;

    hr = THR(FindObject(pUnk, FALSE, &pObject));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->EndStyle());
    if (hr)
        goto Cleanup;
Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------
//
// Function:    CRecalcEngine::Find
//
// Description: Find an object by pUnk (returns the index)
//
//---------------------------------------------------------------
int
CRecalcEngine::Find(IUnknown *pUnk)
{
    TraceTag((tagRecalcDetail, "Looking for %08x", pUnk));

    CRecalcObject **ppObject;
    int i;

    if ((pUnk == _pUnkFoundLast) && (_iFoundLast < _objects.Size()) && (_objects[_iFoundLast]->GetUnknown() == pUnk))
        return _iFoundLast;

    for (i = _objects.Size() , ppObject = _objects ; i > 0 ; i-- , ppObject++)
    {
        if ((*ppObject)->GetUnknown() == pUnk)
        {
            TraceTag((tagRecalcDetail, "Found at index %d", ppObject - _objects));
            _iFoundLast = i;
            _pUnkFoundLast = pUnk;

            return ppObject - _objects;
        }
    }

    return -1;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::FindObject
//
// Description: Finds an object (by _pUnk), optionally creating it if not found
//
//---------------------------------------------------------------
HRESULT
CRecalcEngine::FindObject(IUnknown *pUnk, BOOL fCreate, CRecalcObject **ppObject, unsigned *pIndex)
{
    HRESULT hr = S_FALSE;

    CRecalcObject *pObject = 0;
    int i = Find(pUnk);
    
    if (i >= 0)
    {
        pObject = _objects[i];
        hr = S_OK;
    }
    else if (fCreate)
    {
        pObject = new CRecalcObject(this, pUnk);
        if (!pObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_objects.Append(pObject));
        if (hr)
        {
            ClearInterface(&pObject);
            goto Cleanup;
        }

        Assert(_objects.Size() > 0);

        i = _objects.Size() - 1;

        Assert(_objects[i] == pObject);
    }

Cleanup:
    *ppObject = pObject;
    if (pIndex)
        *pIndex = i;
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::FindProperty
//
// Description: Find a property (optionally creating the object
//              the property along the way
//
//---------------------------------------------------------------
HRESULT
CRecalcEngine::FindProperty(IUnknown *pUnk, DISPID dispid, BOOL fCreate, CRecalcProperty **ppProperty)
{
    Assert(ppProperty);
    HRESULT hr;

    CRecalcProperty *pProperty = 0;
    CRecalcObject *pObject = 0;

    hr = THR(FindObject(pUnk, fCreate, &pObject));
    if (!hr)
    {
        Assert(pObject);
        hr = THR(pObject->FindProperty(dispid, fCreate, &pProperty));
        if (!hr)
        {
            *ppProperty = pProperty;

            hr = S_OK;
        }
    }

    RRETURN1(hr, S_FALSE);
}

#ifndef RECALC_USE_SCRIPTDEBUG
//---------------------------------------------------------------
//
// Function:    CRecalcEngine::GetScriptAuthor
//
// Description: A helper to get the IActiveScriptAuthor interface
//
//---------------------------------------------------------------
HRESULT
CRecalcEngine::GetScriptAuthor(LPOLESTR szLanguage, IActiveScriptAuthor **ppScriptAuthor)
{
    Assert(ppScriptAuthor);

    HRESULT hr ;

    CScriptAuthorHolder **ppScriptHolder;
    int i;

    for (i = _authors.Size() , ppScriptHolder = _authors ; i > 0 ; i-- , ppScriptHolder++)
    {
        if ((*ppScriptHolder)->Compare(szLanguage))
        {
            *ppScriptAuthor = (*ppScriptHolder)->ScriptAuthor();
            RRETURN(S_OK);
        }
    }

    CScriptAuthorHolder *psh = new CScriptAuthorHolder();
    if (!psh)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = THR(psh->Init(szLanguage));
    if (hr)
        goto Error;

    hr = THR(_authors.Append(psh));
    if (hr)
        goto Error;

    *ppScriptAuthor = psh->ScriptAuthor();

Cleanup:
    RRETURN(hr);
Error:
    if (psh)
    {
        psh->Detach();
        delete psh;
    }
    goto Cleanup;
}

#endif

HRESULT
CRecalcEngine::AddDependencyUpdateRequest(CRecalcProperty *pProperty)
{
    Assert(!_fInDeps);
    GetHost()->RequestRecalc();
    RRETURN(_dirtyDeps.Append(pProperty));
}

HRESULT
CRecalcEngine::RemoveDependencyUpdateRequest(CRecalcProperty *pProperty)
{
    RRETURN(_dirtyDeps.DeleteByValue(pProperty) ? S_OK : E_INVALIDARG);
}


//---------------------------------------------------------------------------------------
//
// CRecalcObject
//

//---------------------------------------------------------------
//
// Function:    CRecalcObject::CRecalcObject
//
// Description: The constructor
//
// Notes:       CRecalcObject lifetime is controlled by refcount
//              However, its lifetime in the recalc engine is
//              controlled by the number of properties.  When the
//              number of properties drops to zero, the object
//              removes itself from the engine.  When the engine
//              releases the object it should go away.  Errant
//              holders of IPropertyNotifySink will cause the
//              CRecalcObject to live on.
//
//---------------------------------------------------------------
CRecalcObject::CRecalcObject(CRecalcEngine *pEngine, IUnknown *pUnk) : _pEngine(pEngine) , _pUnk(pUnk) , _ulRefs(1)
{
    Assert(_pUnk);
    Assert(_pEngine);

#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcMemory, "Constructing CRecalcObject # %d p=%08x", _serialNumber, this));

    GetDebugHost()->GetObjectInfo(_pUnk, 0, &_bstrID, 0, &_bstrTag);

    if (_bstrID == 0)
        _bstrID = SysAllocString(_T("{no-id}"));

    if (_bstrTag == 0)
        _bstrTag = SysAllocString(_T("{no-tag}"));

#endif

    _iFoundLast = -1;
    _dispidFoundLast = DISPID_UNKNOWN;

    _pUnk->AddRef();
    if (THR(ConnectSink(_pUnk, IID_IPropertyNotifySink, (IPropertyNotifySink *)this, &_dwCookie)) == S_OK)
        _fGotSink = TRUE;

}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::~CRecalcObject
//
// Description: The destructor
//
//---------------------------------------------------------------}
CRecalcObject::~CRecalcObject()
{
    TraceTag((tagRecalcMemory, "Destroying CRecalcObject # %d p=%08x", _serialNumber, this));
    Assert(_properties.Size() == 0);
    Assert(_pUnk == 0);
    Assert(!_fGotSink);
    Assert(_ulRefs == 0);
#if DBG == 1
    FormsFreeString(_bstrID);
    FormsFreeString(_bstrTag);
#endif
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::Detach
//
// Description: Time to cleanup and release all resources.
//
//---------------------------------------------------------------
void
CRecalcObject::Detach(BOOL fRemoveDependencies /* = FALSE */)
{
    TraceTag((tagRecalcMemory, "Detaching CRecalcObject # %d p=%08x", _serialNumber, this));

    Assert(_pUnk);
    Assert(_pEngine);

    int i;
    CRecalcProperty **ppProperty;

    for (i = _properties.Size() , ppProperty = _properties ; i > 0 ; i-- , ppProperty++)
    {
        if (fRemoveDependencies)
        {
            _fDoingStyle = TRUE;  // this is to prevent the object itself from being deleted
            IGNORE_HR((*ppProperty)->RemoveAllDependencies());
            IGNORE_HR((*ppProperty)->CleanupDependents());
            _fDoingStyle = FALSE;
        }

        delete (*ppProperty);
    }

    _properties.DeleteAll();

    if (_fGotSink)
    {
        IGNORE_HR(DisconnectSink(_pUnk, IID_IPropertyNotifySink, &_dwCookie));
        Assert(_dwCookie == 0);
        _fGotSink = FALSE;
    }

    ClearInterface(&_pUnk);
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::QueryInterface
//
// Description: IUnknown::QueryInterface
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcObject::QueryInterface(REFIID iid, LPVOID *ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPropertyNotifySink *)this, IUnknown)
        QI_INHERITS(this, IPropertyNotifySink)
    }
    if (*ppv == NULL)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::AddRef
//
// Description: IUnknown::AddRef
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcObject::AddRef()
{
    return ++_ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::Release
//
// Description: IUnknown::Release
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcObject::Release()
{
    Assert(_ulRefs > 0);

    unsigned long ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::OnChanged
//
// Description: IPropertyNotifySink::OnChanged
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcObject::OnChanged(DISPID dispid)
{
    Assert(_properties.Size());

    CRecalcProperty *pProperty = 0;
    if (FindProperty(dispid, FALSE, &pProperty) == S_OK)
    {
        Assert(pProperty);
        pProperty->OnChanged();
    }
    RRETURN(S_OK);
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::OnRequestEdit
//
// Description: IPropertyNotifySink::OnRequestEdit
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcObject::OnRequestEdit(DISPID dispid)
{
    // Don't care
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::FindProperty
//
// Description: Find a property by dispid, optionally create it
//
//---------------------------------------------------------------
HRESULT
CRecalcObject::FindProperty(DISPID dispid, BOOL fCreate, CRecalcProperty **ppProperty)
{
    HRESULT hr = S_FALSE;

    CRecalcProperty *pProperty = 0;
    int i = Find(dispid);

    if (i >= 0)
    {
        pProperty = _properties[i];
        hr = S_OK;
    }
    else if (fCreate)
    {
        hr = THR(CRecalcProperty::CreateProperty(this, dispid, &pProperty));
        if (hr)
            goto Cleanup;

        Assert(pProperty);

        hr = THR(_properties.Append(pProperty));
        if (hr)
            goto Cleanup;
Cleanup:
        if (hr && pProperty)
        {
            pProperty->DeleteIfEmpty();
            pProperty = 0;
        }

    }

    *ppProperty = pProperty;
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::Find
//
// Description: Find a property by dispid
//
//---------------------------------------------------------------
int
CRecalcObject::Find(DISPID dispid)
{
    CRecalcProperty **ppProperty;
    unsigned i;

    if ((dispid == _dispidFoundLast) && (_iFoundLast < _properties.Size()) && (_properties[_iFoundLast]->GetDispid() == dispid))
        return _iFoundLast;

    for (i = _properties.Size() , ppProperty = _properties ; i > 0 ; i-- , ppProperty++)
    {
        if ((*ppProperty)->GetDispid() == dispid)
        {
            return ppProperty - _properties;
        }
    }
    return -1;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::RecalcAll
//
// Description: Recalc all of your properties
//              Only properties with no dependents are recalc'd.
//              They will in turn call their dependencies before
//              trying to eval.  Depth first traversal of a tree
//---------------------------------------------------------------
HRESULT
CRecalcObject::RecalcAll(BOOL fForce)
{
    int i;

    TraceTag((tagRecalcEngine, "RecalcAll: object: %ls", GetID()));

    //
    // Because SetExpression (or worse, removeExpression) could
    // be called during recalc, we iterate the old fashioned way.
    // At worst we'll 
    // Iterating using the index ensures that additions to the
    // recalc dep graph doesn't cause any problems.  (SetExpression can 
    // be called during recalc).  This 
    //
    //
    for (i = 0 ; i < _properties.Size() ; i++)
    {
        CRecalcProperty *pProperty = _properties[i];

        if (pProperty->IsTopLevel())
        {
            // Just because one expression fails doesn't mean we should
            // stop trying others.
            //
            // NOTE: (michaelw) It would be nice if I know if the user
            // has said "No" when asked if they want to keep running
            // scripts.
            //
            IGNORE_HR(pProperty->Eval(fForce));
        }
    }

    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::RemoveProperty
//
// Description: This property is no longer needed
//
//---------------------------------------------------------------
void
CRecalcObject::RemoveProperty(CRecalcProperty *pProperty)
{
    int i = _properties.Find(pProperty);

    if (i >= 0)
    {
        delete _properties[i];
        _properties.Delete(i);

        if (!_fDoingStyle && (_properties.Size() == 0))
            _pEngine->RemoveObject(this);
    }
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::BeginStyle
//
// Description: Any calls to SetExpression are for style props
//
//---------------------------------------------------------------
HRESULT
CRecalcObject::BeginStyle()
{
    Assert(!_fDoingStyle);

    _fDoingStyle = TRUE;
#if DBG == 1
    for (int i = 0 ; i < _properties.Size() ; i++)
        if (_properties[i]->IsStyleProp())
            Assert(!_properties[i]->CheckAndClearStyleSet());
#endif
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::EndStyle
//
// Description: After all the style expressions have been set,
//              remove anything left over
//
//---------------------------------------------------------------
HRESULT
CRecalcObject::EndStyle()
{
    Assert(_fDoingStyle);

    // Because we are removing elements from the arraw as we go,
    // This array is enumerated using an index only.

    for (int i = _properties.Size() - 1 ; i >= 0 ; i--)
    {
        CRecalcProperty *pProp = _properties[i];

        if (pProp->IsStyleProp() && !pProp->CheckAndClearStyleSet())
        {
            TraceTag((tagRecalcStyle, "Removing style expression: _pUnk: %08x _dispid: %08x _expr: %ls", pProp->GetUnknown(), pProp->GetDispid(), pProp->GetExpression()));
            IGNORE_HR(pProp->ClearExpression());
        }
    }

    _fDoingStyle = FALSE;

    if (_properties.Size() == 0)
        _pEngine->RemoveObject(this);

    return S_OK;
}


//---------------------------------------------------------------------------------------------------
//
// CRecalcProperty::CreateProperty
//
// The only place where property objects get created.
//
// This function ensures that the property is properly constructed and initialized.
//
// It may need to create the canonical property at the same time.
//
//---------------------------------------------------------------------------------------------------


HRESULT CRecalcProperty::CreateProperty(CRecalcObject *pObject, DISPID dispid, CRecalcProperty **ppProperty)
{
    CRecalcProperty *pProperty = 0;
    CRecalcProperty *pPropertyCanonical = 0;
    IUnknown *pUnkCanonical = NULL;
    DISPID dispidCanonical;

    HRESULT hr;

    pProperty = new CRecalcProperty(pObject, dispid);
    if (!pProperty)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(GetCanonicalProperty(pObject->GetUnknown(), dispid, &pUnkCanonical, &dispidCanonical));
    if (hr == S_FALSE)
    {
        // This property is not aliased
        hr = S_OK;
    }
    else
    {
        // The property is aliased, find and create it's canonical property

        pProperty->_fAlias = TRUE;

        hr = THR(pObject->GetEngine()->FindProperty(pUnkCanonical, dispidCanonical, TRUE, &pPropertyCanonical));
        if (hr)
            goto Cleanup;

        hr = THR(pPropertyCanonical->AddAlias(pProperty));
        if (hr)
            goto Cleanup;

        pProperty->_pPropertyCanonical = pPropertyCanonical;
    }

Cleanup:
    if (hr)
    {
        if (pPropertyCanonical)
            pPropertyCanonical->DeleteIfEmpty();
        if (pProperty)
            pProperty->DeleteIfEmpty();

        *ppProperty = 0;
    }
    else
        *ppProperty = pProperty;

    ReleaseInterface(pUnkCanonical);
    RRETURN(hr);
}


//-----------------------------------------------
//
// Method:      CRecalcProperty::CRecalcProperty
//
// Description: Constructor
//
//-----------------------------------------------
CRecalcProperty::CRecalcProperty(CRecalcObject *pObject, DISPID dispid) : _pObject(pObject) , _dispid(dispid)
{
#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcMemory, "Constructing CRecalcProperty # %d p=%08x", _serialNumber, this));
    GetDebugHost()->GetObjectInfo(GetUnknown(), _dispid, NULL, &_bstrName, NULL);

    if (_bstrName == 0)
        _bstrName = SysAllocString(_T("{no-name}"));

#endif

    _fNoNotify = !_pObject->GotSink();

}

//-----------------------------------------------
//
// Method:      CRecalcProperty::
//
// Description: Destructor
//
//-----------------------------------------------
CRecalcProperty::~CRecalcProperty()
{
    TraceTag((tagRecalcMemory, "Destroying CRecalcProperty # %d p=%08x", _serialNumber, this));

    if (_fDirtyDeps)
        GetEngine()->RemoveDependencyUpdateRequest(this);

    ClearInterface(&_pdispThis);
    ClearInterface(&_pdispExpression);
#if DBG == 1
    FormsFreeString(_bstrName);
#endif
}


//-----------------------------------------------
//
// Method:      CRecalcProperty::OnChanged
//
// Description: IPropertyNotifySink::OnChanged (as delegated by CRecalcObject)
//
//-----------------------------------------------

void
CRecalcProperty::OnChanged()
{
    TraceTag((tagRecalcDetail, "OnChange() this: %08x _pUnk: %08x _dispid: %08x has changed", this, _pObject->GetUnknown(), _dispid));

    if (_fSetValue)
    {
        // This is an expected prop change.
#if DBG == 1
        _cChanged++;
#endif
    }
/*
 * No more automatic removal of expressions!
 *
 * Although this is the "right" way, it isn't
 * practical to make it work for all cases.
 * The case where a property is set to its 
 * current value doesn't always fire a prop
 * change so we would behave very inconsistently.
 *
    else if (HasExpression())
    {
        ClearExpression();
    }
*/
    else
    {
        SetDirty(TRUE);
    }
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::SetDirty
//
// Description: We're dirty.  Tell our dependents and request a recalc
//
//-----------------------------------------------
void
CRecalcProperty::SetDirty(BOOL fDirty, BOOL fRequestRecalc)
{
    if (_fSetDirty)
    {
        TraceTag((tagRecalcEngine, "SetDirty detected circularity"));
        _fCircular = TRUE;

        return;
    }

    if (IsAlias())
    {
        _pPropertyCanonical->SetDirty(fDirty, fRequestRecalc);

        return;
    }

    // Canonicalize the incoming BOOL and make it an unsigned
    unsigned ufDirty = !!fDirty;

    if (ufDirty != _fDirty)
    {
        _fDirty = ufDirty;

        if (ufDirty)
        {
            Assert(!_fSetDirty);
            _fSetDirty = TRUE;

            NotifyDependents();

            Assert(_fSetDirty);
            _fSetDirty = FALSE;

            if (fRequestRecalc)
                GetHost()->RequestRecalc();
        }
    }
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::NotifyDependents
//
// Description: Tell our dependents that we're dirty
//
//---------------------------------------------------------------
void
CRecalcProperty::NotifyDependents()
{
    int i;
    CRecalcProperty **ppProperty;

    Assert(IsCanonical());

    for (i = _dependents.Size() , ppProperty = _dependents ; i > 0 ; i-- , ppProperty++)
        (*ppProperty)->SetDirty(TRUE, FALSE);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::
//
// Description: Are we needed anymore?
//
//-----------------------------------------------
void
CRecalcProperty::DeleteIfEmpty()
{
    //
    // Any dependents?  Any dependencies?  Any aliases?  An Expression?
    //
    // It is possible for _dependencies.Size() == 0 and _dependencyNames.Size() != 0
    // This happens when there are unresolved names.  We will stick around hoping, waiting...
    //
    if (_dependencyNames.Size() + _dependents.Size() + _dependencies.Size() + _aliases.Size() + _sExpression.Length() == 0)
    {
        if (IsAlias())
        {
            _pPropertyCanonical->RemoveAlias(this);
        }

        _pObject->RemoveProperty(this);
    }
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::AddDependent
//
// Description: Add's a property to the list of dependents.
//              Dependents will be notified whenever this
//              property changes.
//
// Returns:     S_OK        everything is fine
//              S_FALSE     added ok but can't notify on prop change
//
//-----------------------------------------------
HRESULT
CRecalcProperty::AddDependent(CRecalcProperty *pProperty, BOOL *pfNoNotify)
{
    Assert(pProperty);
    Assert(pfNoNotify);

    HRESULT hr;

    *pfNoNotify = _fNoNotify;

    Assert(IsCanonical());

    if (_dependents.Find(pProperty) >= 0)
        hr = S_OK;
    else
    {
        hr = _dependents.Append(pProperty);
    }

    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::RemoveDependent
//
// Description: Someone doesn't depend on us anymore
//
//-----------------------------------------------
HRESULT
CRecalcProperty::RemoveDependent(CRecalcProperty *pProperty)
{
    HRESULT hr;

    Assert(IsCanonical());

    if (_dependents.DeleteByValue(pProperty))
    {
        hr = S_OK;
        DeleteIfEmpty();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}

//---------------------------------------------------
//
// Method:      CRecalcProperty::AddAlias
//
// Description: Add an alias to the list of known aliases
//
//---------------------------------------------------
HRESULT
CRecalcProperty::AddAlias(CRecalcProperty *pProperty)
{
    Assert(pProperty);

   if (_aliases.Find(pProperty) >= 0)
        return S_OK;

    RRETURN(_aliases.Append(pProperty));
}


//---------------------------------------------------
//
// Method:      CRecalcProperty::RemoveAlias
//
// Description: Remove an alias to the list of known aliases
//
//---------------------------------------------------
HRESULT
CRecalcProperty::RemoveAlias(CRecalcProperty *pProperty)
{
    Assert(pProperty);

    if (!_aliases.DeleteByValue(pProperty))
        RRETURN(E_INVALIDARG);

    DeleteIfEmpty();

    return S_OK;
}


//-----------------------------------------------
//
// Method:      CRecalcProperty::AddDependency
//
// Description: We depend on some other property.
//
//-----------------------------------------------
HRESULT
CRecalcProperty::AddDependency(IDispatch *pDispatch, DISPID dispid)
{
    CRecalcProperty *pProperty = NULL;
    IUnknown *pUnkDepend = 0;
    DISPID dispidDepend;
    BOOL fNoNotify;
    HRESULT hr;
    int i;

    // First try to get the canonical property
    hr = THR(GetCanonicalProperty((IUnknown *)pDispatch, dispid, &pUnkDepend, &dispidDepend));
    if (FAILED(hr))
        goto Cleanup;
    else if (hr == S_FALSE)
    {
        // This property isn't aliased, use the pUnk
        dispidDepend = dispid;
        hr = THR(pDispatch->QueryInterface(IID_IUnknown, (LPVOID *)&pUnkDepend));
        if (hr)
            goto Cleanup;
    }

    // Do we already have this dependency?

    for (i = 0 ; i < _dependencies.Size() ; i++)
    {
        if ((_dependencies[i]->GetUnknown() == pUnkDepend) && (_dependencies[i]->_dispid == dispidDepend))
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    // We don't already have this dependency, time to add it.

    hr = THR(GetEngine()->FindProperty(pUnkDepend, dispidDepend, TRUE, &pProperty));
    if (hr)
        goto Cleanup;

    hr = THR(_dependencies.Append(pProperty));
    if (hr)
        goto Cleanup;

    hr = THR(pProperty->AddDependent(this, &fNoNotify));
    if (hr)
        goto Cleanup;

    if (fNoNotify)
        _fNoNotify = TRUE;

Cleanup:
    ReleaseInterface(pUnkDepend);

    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::RemoveDependency
//
// Description: Remove the dependency for this property
//
//-----------------------------------------------
HRESULT
CRecalcProperty::RemoveDependency(CRecalcProperty *pProperty)
{
    HRESULT hr;

    if (_dependencies.DeleteByValue(pProperty))
    {
        hr = S_OK;
        DeleteIfEmpty();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::CleanupDependents
//
// Description: Tell our dependents that we're gone - they shouldn't count on us
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::CleanupDependents()
{
    HRESULT hr = S_OK;
    int i;
    CRecalcProperty **ppProperty;

    for (i = _dependents.Size() , ppProperty = _dependents ; i > 0 ; i-- , ppProperty++)
    {
        hr = THR((*ppProperty)->RemoveDependency(this));
        if (hr)
            goto Cleanup;    
    }

    _dependents.DeleteAll();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------
//
// Function:    CRecalcProperty::RemoveAllDependencies
//
// Description: Clean out the bunch of them, we depend on nobody!
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::RemoveAllDependencies()
{
    HRESULT hr = S_OK;
    int i;
    CRecalcProperty **ppProperty;

    for (i = _dependencies.Size() , ppProperty = _dependencies ; i > 0 ; i-- , ppProperty++)
    {
        hr = THR((*ppProperty)->RemoveDependent(this));
        if (hr)
            goto Cleanup;
    }

    _dependencies.DeleteAll();

    _fNoNotify = !_pObject->GotSink();
Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::ClearExpression
//
// Description: Clear's the expression, may delete the object
//
//-----------------------------------------------
HRESULT
CRecalcProperty::ClearExpression()
{
    Assert(!GetEngine()->InRecalc());
    // Tell the host to remove the attribute value
    GetHost()->RemoveValue(GetUnknown(), _dispid);
    HRESULT hr = clearExpressionHelper();
    if (hr)
        goto Cleanup;

    DeleteIfEmpty();

Cleanup:
    RRETURN(hr);
}

HRESULT
CRecalcProperty::clearExpressionHelper()
{
    Assert(!_fSetDirty);
    Assert(!_fSetValue);
    Assert(!_fInEval);
    Assert(!GetEngine()->InRecalc());

    HRESULT hr = THR(RemoveAllDependencies());
    if (hr)
        goto Cleanup;

    _dependencyNames.DeleteAll();

    _sExpression.Free();
    _sLanguage.Free();
    _sExpressionNames.Free();

    _fError = FALSE;

    ClearInterface(&_pdispExpression);
    ClearInterface(&_pdispThis);

    _fCircular = FALSE;

    if (IsAlias())
        _pPropertyCanonical->_pPropertyExpression = NULL;
    else
        _pPropertyExpression = NULL;

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::EvalExpression
//
// Description: The real McCoy.  This is where all
//              the magic happens.  This is it.  Hold on
//              to your socks.
//
//-----------------------------------------------
HRESULT
CRecalcProperty::EvalExpression(VARIANT *pv)
{
    HRESULT hr;
    CExcepInfo  excepinfo;
    DISPPARAMS dispParams;

    Assert((LPOLESTR)_sExpression);

    if (_pdispExpression)
    {
        if (_pdispThis)     // We actually have a _pDEXExpression
        {
            DISPID dispidThis = DISPID_THIS;
            VARIANTARG  vThis;

            dispParams.rgvarg = &vThis;
            dispParams.rgdispidNamedArgs = &dispidThis;
            dispParams.cArgs = 1;
            dispParams.cNamedArgs = 1;

            V_VT(&vThis) = VT_DISPATCH;
            V_DISPATCH(&vThis) = _pdispThis;

            hr = THR(_pDEXExpression->InvokeEx(DISPID_VALUE,
                                          0,
                                          DISPATCH_METHOD,
                                          &dispParams,
                                          pv,
                                          &excepinfo,
                                          NULL));
        }
        else
        {
            dispParams = g_Zero.dispparams;
            hr = THR(_pdispExpression->Invoke(DISPID_VALUE,
                                          IID_NULL,
                                          0,
                                          DISPATCH_METHOD,
                                          &dispParams,
                                          pv,
                                          &excepinfo,
                                          NULL));
        }
    }
    else
    {
        hr = THR(GetHost()->EvalExpression(_pObject->GetUnknown(), _dispid, _sExpression, _sLanguage, pv));
    }
#if DBG == 1
    CVariant vStr;

    vStr.CoerceVariantArg(pv, VT_BSTR);

    TraceTag((tagRecalcEval, "%ls returned %ls", (LPOLESTR)_sExpression, V_BSTR(&vStr)));
#endif
    RRETURN(hr);
}

//---------------------------------------------------
//
// Method:      CRecalcProperty::Eval
//
// Description: This ensures that a property is up to date
//              This method should be called for any dependencies
//              Before actuallying evaluating the expression on a property
//
//              This method will also ensure that the computed value is
//              put into the OM
//
//              Circularity is detected but tolerated
//
//---------------------------------------------------
HRESULT
CRecalcProperty::Eval(BOOL fForce)
{
    HRESULT hr = S_OK;
    CVariant v;
    int i;

    TraceTag((tagRecalcEval, "%ls.%ls", _pObject->GetID(), _bstrName));

    //
    // Catch circularity
    //
    // For the cases where the circularlity is implicit (inner relationships between
    // properties) or hidden (global references to properties inside function calls), _fInEval
    // is used to dynamically detect circularity.
    //
    if (_fInEval)
    {
        TraceTag((tagRecalcEval, "bailing due to circularity", _pObject->GetID(), _bstrName));
        hr = S_OK;
        goto Cleanup;
    }

    // If we're trying to evaluate a property that doesn't have an expression
    // it must be canonical (because we only put dependencies on canonical properties)
    // In some cases, the real expression is on another object, in which case we eval
    // that object.  Otherwise we're done.
    if (_sExpression.IsNull())
    {
        // Aliases shouldn't be dependencies or top level evals.
        Assert(IsCanonical());

        // If we're looking at this object and we're not the one with the expression, go do the expression 
        if (_pPropertyExpression)
        {
            TraceTag((tagRecalcEval, "evaluating alias"));
            hr = THR(_pPropertyExpression->Eval(fForce));
        }

        goto Cleanup;
    }

    _fInEval = TRUE;

    Assert(!_sExpression.IsNull());

    //
    // This property has an expression.  Now we need to make sure all its dependencies
    // have been evaluated first.
    //
    // This loop needs to handle the possibility that some properties will go away
    // I actually think this is a pretty rare case but if all expressions are somehow
    // cleared as a result of evaluating one of them then the entire recalc graph could
    // be destroyed.

#if DBG == 1
    if (_dependencies.Size())
        TraceTag((tagRecalcEval, "Evaluating dependencies"));
#endif
    for (i = 0 ; i < _dependencies.Size() ; i++)
    {
        // Just because a dependency fails doesn't mean we should
        IGNORE_HR(_dependencies[i]->Eval(fForce));
    }

    if (_fDirtyDeps || fForce || (IsAlias() ? _pPropertyCanonical->_fDirty : _fDirty) || _fNoNotify || _fUnresolved)
    {
        // Now actually evaluate our expression

        hr = THR(EvalExpression(&v));

        if (hr)
        {
            // The expression eval failed for some reason.
            _fError = TRUE;
            hr = S_OK;          // gobble the error
            goto Cleanup;
        }

        else
        {
            _fError = FALSE;
            hr = THR(SetValue(&v, fForce));
            if (hr)
                goto Cleanup;
        }
    }

    TraceTag((tagRecalcEval, "%ls.%ls done\n", _pObject->GetID(), _bstrName));
Cleanup:
    SetDirty(FALSE);

    _fInEval = FALSE;
    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::SetExpression
//
// Description: Assigns an expression to a property
//
// REVIEW michaelw  Needs more error handling
//
//-----------------------------------------------
HRESULT
CRecalcProperty::SetExpression(LPCOLESTR szExpression, LPCOLESTR szLanguage)
{
    HRESULT hr;
    IDispatchEx *pDEXExpression = 0;
    CRecalcProperty *pPropertyExpression = 0;

    Assert(!GetEngine()->InRecalc());

    if (!szExpression || !szLanguage)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pPropertyExpression = IsAlias() ? _pPropertyCanonical->_pPropertyExpression : _pPropertyExpression;

    if (pPropertyExpression && pPropertyExpression != this)
    {
        // There is already an expression on this property group and it isn't on this property

        TraceTag((tagRecalcEngine, "SetExpression: you can't have two expressions on a property group"));
        hr = E_FAIL;
        goto Cleanup;
    }

    _fStyleProp = _pObject->InStyle();
    if (_fStyleProp)
    {
        _fStyleSet = TRUE;
    }

    // Quickly ignore the case where the expression and language are the same
    if ((_tcscmp(szExpression, _sExpression) == 0) && (_tcscmp(szLanguage, _sLanguage) == 0))
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = clearExpressionHelper();
    if (hr)
        goto Cleanup;

    hr = THR(_sExpression.Set(szExpression));
    if (hr)
        goto Cleanup;

    hr = THR(_sLanguage.Set(szLanguage));
    if (hr)
        goto Cleanup;

    hr = THR(GetHost()->CompileExpression(_pObject->GetUnknown(), _dispid, _sExpression, _sLanguage, &_pdispExpression, &_pdispThis));
    if (hr == S_OK)
    {
        hr = THR(_pdispExpression->QueryInterface(IID_IDispatchEx, (LPVOID *)&pDEXExpression));
        if (hr == E_NOINTERFACE)
        {
            ClearInterface(&_pdispThis);
        }
        else if (hr)
            goto Cleanup;
        else
        {
            ClearInterface(&_pdispExpression);
            _pDEXExpression = pDEXExpression;
        }
    }

    hr = THR(ParseExpressionDependencies());
    if (hr)
        goto Cleanup;

    _fDirtyDeps = TRUE;

    hr = THR(GetEngine()->AddDependencyUpdateRequest(this));
    if (hr)
        goto Cleanup;

    if (IsAlias())
        _pPropertyCanonical->_pPropertyExpression = this;
    else
        _pPropertyExpression = this;

Cleanup:
    if (hr)
        IGNORE_HR(clearExpressionHelper());
    RRETURN(hr);
}

HRESULT
CRecalcProperty::GetExpression(BSTR *pstrExpression, BSTR *pstrLanguage)
{
    Assert(!_fSetDirty);
    Assert(!_fSetValue);
    Assert(!_fInEval);

    HRESULT hr;

    if (_sExpression.IsNull())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(_sExpression.AllocBSTR(pstrExpression));
    if (hr)
        goto Cleanup;

    hr = THR(_sLanguage.AllocBSTR(pstrLanguage));
    if (hr)
    {
        SysFreeString(*pstrExpression);
        *pstrExpression = 0;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::ParseExpressionDependencies
//
// Description: Extract out identifiers from an expression.  Cool stuff.
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::ParseExpressionDependencies()
{
    SOURCE_TEXT_ATTR *pAttr = NULL, *pA;
    WCHAR *pch = 0;
    WCHAR *pchEnd = 0;
    HRESULT hr;
#ifndef RECALC_USE_SCRIPTDEBUG
    IActiveScriptAuthor *pScriptAuthor = 0;
#endif

    TraceTag((tagRecalcInfo, "ParseExpressionDependencies %08x (%d) \"%ls\"", this, _serialNumber, (LPOLESTR)_sExpression));
    if (_sExpression.Length() == 0)
        return S_OK;

    hr = THR(_sExpressionNames.Set(_sExpression));
    if (hr)
        goto Cleanup;

    pAttr = new SOURCE_TEXT_ATTR[_sExpressionNames.Length()];
    if (!pAttr)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#ifndef RECALC_USE_SCRIPTDEBUG
    hr = THR(GetEngine()->GetScriptAuthor(_sLanguage, &pScriptAuthor));
    if (hr)
        goto Cleanup;

    hr = THR(pScriptAuthor->GetScriptTextAttributes(_sExpressionNames, _sExpressionNames.Length(), NULL, GETATTRTYPE_DEPSCAN, pAttr));
    if (hr)
        goto Cleanup;

#else
    hr = THR(GetHost()->GetScriptTextAttributes(_sLanguage, _sExpressionNames, _sExpressionNames.Length(), NULL, GETATTRTYPE_DEPSCAN | GETATTRFLAG_THIS, pAttr));
    if (hr)
        goto Cleanup;
#endif

    //
    // Start finding identifiers.  Only simple names (no array refs) are allowed
    //
    pch = _sExpressionNames;
    pchEnd = pch + _sExpressionNames.Length();
    pA = pAttr;
    while (pch < pchEnd)
    {
        if ((*pA == SOURCETEXT_ATTR_IDENTIFIER) || (*pA == SOURCETEXT_ATTR_THIS))
        {
            WCHAR *pchBegin = pch;

            while (pch < pchEnd && (*pA == SOURCETEXT_ATTR_IDENTIFIER || *pA == SOURCETEXT_ATTR_THIS || *pA == SOURCETEXT_ATTR_MEMBERLOOKUP))
            {
                if (*pA == SOURCETEXT_ATTR_MEMBERLOOKUP)
                    *pch = _T('.');
                pch++;
                pA++;
            }

            *pch = 0;

            TraceTag((tagRecalcDetail, "Got identifier: \"%ls\"", pchBegin));
            hr = THR(_dependencyNames.Append(pchBegin));
            if (hr)
                goto Cleanup;
        }
        pch++;
        pA++;
    }
Cleanup:
    if (pAttr)
        delete [] pAttr;
    return hr;
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::UpdateDependencies
//
// Description: We've got a bunch of identifiers, resolve them to
//              actual object/dispid pairs and then setup the
//              dependencies.
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::UpdateDependencies()
{
    IDispatch *pDispatch = 0;
    DISPID dispid;
    HRESULT hr = S_OK;
    int i;
    LPOLESTR *psz;

    _fUnresolved = FALSE;

    Assert(_fDirtyDeps);
    _fDirtyDeps = FALSE;

    for (i = _dependencyNames.Size() , psz = _dependencyNames ; i > 0 ; i-- , psz++)
    {
        hr = THR(GetHost()->ResolveNames(_pdispThis ? _pdispThis : _pObject->GetUnknown(), _dispid, 1, psz, &pDispatch, &dispid));
        if (!hr)
        {
            hr = THR(AddDependency(pDispatch, dispid));

            ClearInterface(&pDispatch);

            if (hr)
                goto Cleanup;
        }
        else
        {
            _fUnresolved = TRUE;
            hr = S_OK;
            // Silently swallow the error
        }
    }

    _fCircular = FALSE;

    SetDirty(TRUE);
    if (_fCircular)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::SetValue
//
// Description: Stuff a value into a property without blowing the
//              expression away.
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::SetValue(VARIANT *pv, BOOL fForce)
{
    Assert(pv);
    Assert(_fSetValue == FALSE);

    HRESULT hr = S_OK;

    if (fForce || !IsVariantEqual(&_vCurrent, pv))
    {
        _fSetValue = TRUE;

#if DBG == 1
        _cChanged = 0;
#endif

        hr = THR(GetHost()->SetValue(_pObject->GetUnknown(), _dispid, pv, _fStyleProp));
        Assert(_fSetValue);
        _fSetValue = FALSE;

        if (hr)
            goto Cleanup;

#if DBG == 1
        if (_cChanged != 1)
            TraceTag((tagRecalcDetail, "\n\n!!!!!!!!!!     Received %d change notifications after put\n\n", _cChanged));
        _cChanged = 0;
#endif

        hr = THR(VariantCopy(&_vCurrent, pv));
        if (hr)
        {
            VariantClear(&_vCurrent);
            goto Cleanup;
        }
    }

Cleanup:
    Assert(_fSetValue == FALSE);
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::CheckAndClearStyleSet
//
// Description: Checks to see if the styleSet bit has been set
//              Clears after the check
//
//---------------------------------------------------------------
BOOL
CRecalcProperty::CheckAndClearStyleSet()
{
    BOOL fStyleSet = _fStyleSet;
    _fStyleSet = FALSE;
    return fStyleSet;
}


//---------------------------------------------------
//
// Function:        GetCanonicalProperty
//
// Description:     Helper function to get the canonical
//                  property from a particular punk/dispid.
//                  Does "all" the work of QI'ing and so forth
//
//---------------------------------------------------
HRESULT
GetCanonicalProperty(IUnknown *pUnk, DISPID dispid, IUnknown **ppUnkCanonical, DISPID *pdispidCanonical)
{
    HRESULT hr;
    IRecalcProperty *pRecalcProperty;


    hr = pUnk->QueryInterface(IID_IRecalcProperty, (LPVOID *)&pRecalcProperty);
    if (hr == E_NOINTERFACE)
    {
        *ppUnkCanonical = 0;
        *pdispidCanonical = DISPID_UNKNOWN;
        hr = S_FALSE;
    }
    else if (SUCCEEDED(hr))
    {
        hr = THR(pRecalcProperty->GetCanonicalProperty(dispid, ppUnkCanonical, pdispidCanonical));
        pRecalcProperty->Release();
    }

    RRETURN1(hr, S_FALSE);
}

#if DBG == 1
//---------------------------------------------------------------
//
// Function:    int CRecalcEngine::
//
// Description: Debug dump
//
//---------------------------------------------------------------

void RecalcDumpVariant(LPOLESTR szName, VARIANT *pv)
{
    CVariant v;

    v.CoerceVariantArg(pv, VT_BSTR);

    if (V_VT(&v) == VT_ERROR)
        RecalcDumpFormat(_T("<0s>=[error]"), szName);
    else if (V_VT(&v) == VT_EMPTY)
        RecalcDumpFormat(_T("<0s>=[null]"), szName);
    else if (V_VT(&v) == VT_BSTR)
        RecalcDumpFormat(_T("<0s>=<1s> "), szName, V_BSTR(&v));
    else
        RecalcDumpFormat(_T("<0s>=[???] "), szName);
}

HANDLE g_hfileRecalcDump = INVALID_HANDLE_VALUE;

BOOL RecalcDumpOpen()
{
    if (g_hfileRecalcDump == INVALID_HANDLE_VALUE)
    {
        g_hfileRecalcDump = CreateFile(_T("c:\\recalcdump.htm"),
                                            GENERIC_WRITE | GENERIC_READ,
                                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                                            NULL,
                                            OPEN_ALWAYS,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL);

        if (g_hfileRecalcDump == INVALID_HANDLE_VALUE)
            return FALSE;

        DWORD dwSize = GetFileSize(g_hfileRecalcDump, 0);

        if (dwSize == 0)
            r_p(_T("<html><head><link rel=stylesheet type=text/css href=recalcdump.css></head>\n"));
        else
            SetFilePointer( g_hfileRecalcDump, GetFileSize( g_hfileRecalcDump, 0 ), 0, 0 );
    }

    return TRUE;
}

void __cdecl RecalcDumpFormat(LPOLESTR szFormat, ...)
{
    va_list arg;

    va_start(arg, szFormat);

    WriteHelpV(g_hfileRecalcDump, szFormat, &arg);
}

int CRecalcEngine::Dump(DWORD dwFlags)
{
    int i;

    r_pf((_T("\t<<div id=e<0d>>Recalc Engine\n"), _serialNumber));
    r_p(_T("\t\t<div class=recalcmembers>"));
    r_pb(_fInRecalc);
    r_pb(_fRecalcRequested);
    r_pb(_fInDeps);
    r_p(_T(">\n"));

    for (i = 0 ; i < _objects.Size() ; i++)
    {
        _objects[i]->Dump(dwFlags);
    }

    r_p(_T("</div></BODY></HTML>\n"));

    return 0;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::
//
// Description: Dump interesting stuff for debugging
//
//---------------------------------------------------------------
int
CRecalcObject::Dump(DWORD dwFlags)
{
    int i;

    r_pf((_T("\t\t<<div class=recalcobject id=o<0d>>Object o<0d> <1s>\n "), _serialNumber, _bstrID));
    r_p(_T("\t\t\t<div class=recalcmembers>Members"));
    r_p(_T("\t\t\t\t<div class=recalcvalues>"));
    r_ps(_bstrID);
    r_ps(_bstrTag);
    r_pb(_fGotSink);
    r_pb(_fDoingStyle);
    r_pb(_fInRecalc);
    r_p(_T("</div>\n"));
    r_p(_T("\t\t\t</div>\n"));

    for (i = 0 ; i < _properties.Size() ; i++)
    {
        _properties[i]->Dump(dwFlags);
    }
    r_p(_T("</div>"));
    return 0;
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::TraceDump
//
// Description: Dump stuff
//
//---------------------------------------------------------------
int CRecalcProperty::Dump(DWORD dwFlags)
{
    r_pf((_T("\t\t\t<<div class=recalcproperty id=p<0d>>Property p<0d> <1s>.<2s>"), _serialNumber, _pObject->GetID(), _bstrName));
    r_p(_T("\t\t\t\t<div class=recalcmembers>Members\n"));
    r_p(_T("\t\t\t\t\t<div class=recalcvalues>"));

    r_ps(_bstrName);
    r_pn(_dispid);

    r_pb(_fDirty);
    r_pb(_fInEval);
    r_pb(_fSetValue);
    r_pb(_fCircular);
    r_pb(_fSetDirty);
    r_pb(_fStyleSet);
    r_pb(_fAlias);

    if (!_sExpression.IsNull())
    {
        r_ps(_sExpression);
        r_pv(&_vCurrent);
        r_ps(_sLanguage);
    }

    if (IsAlias())
    {
        r_pf((_T("canonical=p<0d> "), _pPropertyCanonical->_serialNumber));
    }
    else if (_pPropertyExpression)
    {
        r_pf((_T("aliasexp=p<0d> "), _pPropertyExpression->_serialNumber));
    }
    r_p(_T("\t\t\t\t\t</div>\n"));
    r_p(_T("\t\t\t\t</div>\n"));

    int i;

    if (_dependencyNames.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcdependencies>DependencyNames: <0d>\n"), _dependencyNames.Size()));

        for (i = 0 ; i < _dependencyNames.Size() ; i++)
            r_pf((_T("\t\t\t\t<<span class=recalcdependencyName><0s><</span><<br>\n"), (LPOLESTR)_dependencyNames[i]));

        r_p(_T("\t\t\t\t</div>\n"));
    }

    if (_dependencies.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcdependencies>Dependencies: <0d>\n"), _dependencies.Size()));

        for (i = 0 ; i < _dependencies.Size() ; i++)
            r_pf((_T("\t\t\t\t\t<<a class=recalcdependency href=#p'<0d>'>p<0d><</a><<br>\n"), (LPOLESTR)UIntToPtr(_dependencies[i]->_serialNumber)));

        r_p(_T("\t\t\t\t</div>\n"));
    }

    if (_dependents.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcdependents>Dependents: <0d>\n"), _dependents.Size()));

        for (i = 0 ; i < _dependents.Size() ; i++)
            r_pf((_T("\t\t\t\t\t<<a class=recalcdependent href=#p'<0d>'>p<0d><</a><<br>\n"), (LPOLESTR)UIntToPtr(_dependents[i]->_serialNumber)));
        r_p(_T("\t\t\t\t</div>\n"));
    }

    if (_aliases.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcaliases>Aliases: <0d>\n"), _aliases.Size()));

        for (i = 0 ; i < _aliases.Size() ; i++)
            r_pf((_T("\t\t\t\t\t<<a class=recalcalias href=#p'<0d>'>p<0d><</a><<br>\n"), (LPOLESTR)UIntToPtr(_aliases[i]->_serialNumber)));

        r_p(_T("\t\t\t\t</div>\n"));
    }

    r_p(_T("</div>\n"));
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\switches.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       switches.cxx
//
//  Contents:   Runtime switches
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

PerfDbgTag(tagSwitchSerialize,     "Switches", "Serialize pre-parser and post-parser")
PerfDbgTag(tagSwitchNoBgRecalc,    "Switches", "Disable background recalc")
PerfDbgTag(tagSwitchNoRecalcLines, "Switches", "Disable flow measuring")
PerfDbgTag(tagSwitchNoRenderLines, "Switches", "Disable flow rendering")
PerfDbgTag(tagSwitchNoImageCache,  "Switches", "Disable image caching")
PerfDbgTag(tagSwitchSyncDatabind,  "Switches", "Grab all databinding records at once")

#if defined(PRODUCT_PROF) || defined(USESWITCHES)

BOOL g_fSwitchSerialize     = FALSE;
BOOL g_fSwitchNoBgRecalc    = FALSE;
BOOL g_fSwitchNoRecalcLines = FALSE;
BOOL g_fSwitchNoRenderLines = FALSE;
BOOL g_fSwitchNoImageCache  = FALSE;
BOOL g_fSwitchSyncDatabind  = FALSE;
BOOL g_fSwitchUseTimers     = FALSE;
BOOL g_fSwitchUseImageTimer = FALSE;
BOOL g_fIsProfiling         = FALSE;
BOOL g_fSwitchNoGDIBatch    = FALSE;

CGlobalCriticalSection g_csTimers;
__int64          g_rgtSum[SWITCHES_TIMER_COUNT];
__int64          g_rgtStack[128];
int              g_rgiStack[128];
int              g_iStackDepth;
int              g_iTimerProfile = -1;
char *           g_rgpchNames[] = 
    { "Tokenize", "Parse", "ComputeFormats", "RecalcLines", "DecodeImage", "Paint", 
      "SBHeapAlloc", "SBHeapAllocClear", "SBHeapGetSize", "SBHeapFree", "SBHeapReAlloc", 
      "ProcHeapAlloc", "ProcHeapAllocClear", "ProcHeapGetSize", "ProcHeapFree", "ProcHeapReAlloc" };

void
InitRuntimeSwitchesFn()
{
#if defined(PRODUCT_PROF)
    char * pszSection = "profile";
#else
    char * pszSection = "retail";
#endif

    g_fSwitchSerialize     = GetPrivateProfileIntA(pszSection, "serialize",     FALSE, "mshtmdbg.ini");
    g_fSwitchNoBgRecalc    = GetPrivateProfileIntA(pszSection, "nobgrecalc",    FALSE, "mshtmdbg.ini");
    g_fSwitchNoRecalcLines = GetPrivateProfileIntA(pszSection, "norecalclines", FALSE, "mshtmdbg.ini");
    g_fSwitchNoRenderLines = GetPrivateProfileIntA(pszSection, "norenderlines", FALSE, "mshtmdbg.ini");
    g_fSwitchNoImageCache  = GetPrivateProfileIntA(pszSection, "noimagecache",  FALSE, "mshtmdbg.ini");
    g_fSwitchSyncDatabind  = GetPrivateProfileIntA(pszSection, "syncdatabind",  FALSE, "mshtmdbg.ini");
    g_fSwitchUseTimers     = GetPrivateProfileIntA(pszSection, "usetimers",     FALSE, "mshtmdbg.ini");
    g_fSwitchUseImageTimer = GetPrivateProfileIntA(pszSection, "useimagetimer", FALSE, "mshtmdbg.ini");
    g_fSwitchNoGDIBatch    = GetPrivateProfileIntA(pszSection, "nogdibatch",    FALSE, "mshtmdbg.ini");

#ifdef PRODUCT_PROF
    char ach[256];
    ach[0] = 0;
    GetPrivateProfileStringA(pszSection, "profiletimer", "", ach, ARRAY_SIZE(ach), "mshtmdbg.ini");
    g_fSwitchUseTimers = FALSE;
    for (int i = 0; i < ARRAY_SIZE(g_rgpchNames); ++i)
    {
        if (lstrcmpiA(ach, g_rgpchNames[i]) == 0)
        {
            g_iTimerProfile = i;
            g_fSwitchUseTimers = TRUE;
            break;
        }
    }
#endif
}

#endif

#ifdef SWITCHTIMERS_ENABLED

void
SwitchesBegTimer(int iTimer)
{
    if (!g_fSwitchUseTimers)
        return;

    if (iTimer == SWITCHES_TIMER_DECODEIMAGE && !g_fSwitchUseImageTimer)
        return;

    SuspendCAP();

    g_csTimers.Enter();

    int i = g_iStackDepth;

    if (i < ARRAY_SIZE(g_rgiStack))
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&g_rgtStack[i]);
        g_rgiStack[i] = iTimer;
        g_iStackDepth += 1;

#ifdef PRODUCT_PROF
        if (g_iTimerProfile >= 0)
        {
            if (g_fIsProfiling && iTimer != g_iTimerProfile)
            {
                StopCAP();
                g_fIsProfiling = FALSE;
            }
            else if (!g_fIsProfiling && iTimer == g_iTimerProfile)
            {
                StartCAP();
                g_fIsProfiling = TRUE;
            }
        }
#endif
    }

    g_csTimers.Leave();

    ResumeCAP();
}

void
SwitchesEndTimer(int iTimer)
{
    if (!g_fSwitchUseTimers)
        return;

    if (iTimer == SWITCHES_TIMER_DECODEIMAGE && !g_fSwitchUseImageTimer)
        return;

    SuspendCAP();

    g_csTimers.Enter();

    int i = g_iStackDepth;
    int j;

    if (i > 0)
    {
        i -= 1;
        __int64 * ptBeg = &g_rgtStack[i];
        int * piTimer = &g_rgiStack[i];
        __int64 tBeg, tEnd;

        for (j = i; j >= 0; --j, --ptBeg, --piTimer)
        {
            if (*piTimer == iTimer)
                break;
        }

        if (j >= 0)
        {
            tBeg = *ptBeg;

            if (j < i)
            {
                tEnd = *(ptBeg + 1);
                memmove(ptBeg, ptBeg + 1, (i - j) * sizeof(__int64));
                memmove(piTimer, piTimer + 1, (i - j) * sizeof(int));
            }
            else
            {
                QueryPerformanceCounter((LARGE_INTEGER *)&tEnd);
            }

            g_iStackDepth -= 1;

            tEnd -= tBeg;

            g_rgtSum[iTimer] += tEnd;

            for (--j, --ptBeg; j >= 0; --j, --ptBeg)
                *ptBeg += tEnd;
        }
    }

#ifdef PRODUCT_PROF
    if (g_iTimerProfile >= 0)
    {
        if (g_fIsProfiling && (g_iStackDepth == 0 || g_rgiStack[g_iStackDepth - 1] != g_iTimerProfile))
        {
            StopCAP();
            g_fIsProfiling = FALSE;
        }
        else if (!g_fIsProfiling && g_iStackDepth > 0 && g_rgiStack[g_iStackDepth - 1] == g_iTimerProfile)
        {
            StartCAP();
            g_fIsProfiling = TRUE;
        }
    }
#endif

    g_csTimers.Leave();

    ResumeCAP();
}

void
SwitchesGetTimers(char * pchBuf)
{
    char * pch = pchBuf;

    if (pch)
    {
        *pch = 0;

        if (!g_fSwitchUseTimers)
            return;

#if !defined(PRODUCT_PROF)
        __int64 tFreq;
        QueryPerformanceFrequency((LARGE_INTEGER *)&tFreq);

        for (int i = 0; i < SWITCHES_TIMER_COUNT; ++i)
        {
            if (g_rgtSum[i] == 0)
                continue;

            wsprintfA(pch, "%s=%ld ", g_rgpchNames[i], ((LONG)(g_rgtSum[i] * 1000L / tFreq)));
            pch += lstrlenA(pch);
        }
#endif
    }

    memset(g_rgtSum, 0, sizeof(g_rgtSum));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\strbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       strbuf.cxx
//
//  Contents:   CStreamWriteBuff
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

MtDefine(CStreamReadBuff,  Utilities, "CStreamReadBuff")
MtDefine(CStreamWriteBuff, Utilities, "CStreamWriteBuff")

extern const TCHAR* LookUpErTable(TCHAR ch, BOOL fCp1252);

BOOL ChrLower(TCHAR ch) { return _T('a') <= ch && ch <= _T('z'); } ;

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::CStreamWriteBuff
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------

CStreamWriteBuff::CStreamWriteBuff(IStream *pStm, CODEPAGE cp) :
                   CEncodeWriter( cp, WBUFF_SIZE )
{
    Assert(pStm);

    _pStm               = pStm;
    _pStm->AddRef( );

    _ichLastNewLine     = 0;        // index of the last newline char in the
                                    // wide char buffer
    _iLastValidBreak    = 0;        // index of the last valid break char in the
                                    // wide char buffer
    _cPreFormat         = 0;        // indicates the level of preformatted mode
    _cSuppress          = 0;        // level of suppression
    _cchIndent          = 0;        // no. of indentation chars at the begining
                                    // of the line
    _dwFlags            = WBF_ENTITYREF;
                                    // Turn on entity reference conversion mode.

    _pElementContext    = NULL;     // Element which we are saving (null if no
                                    // specific element)

    _fNeedIndent        = TRUE;     // Keep track of indent state

    _pExtendedTagTable  = NULL;

    WHEN_DBG( _fValidateDbg = TRUE );
}

HRESULT
CStreamWriteBuff::Init()
{
    HRESULT hr;
    WHEN_DBG( _fInited = TRUE );
    
    // Allocate a wide char buffer (this will allocate _nBlockSize wchars)
    hr = THR( PrepareToEncode() );
    if( hr )
        goto Cleanup;
    Assert( _pchBuffer );

    // Allocate a MB buffer (this may grow if necessary)
    hr = THR( MakeRoomForChars( _nBlockSize * 2 ) );
    if( hr )
        goto Cleanup;
    Assert( _pbBuffer );

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::~CStreamWriteBuff
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CStreamWriteBuff::~CStreamWriteBuff()
{
#if DBG==1
    if( _fValidateDbg )
    {
//        AssertSz(_cchIndent == 0, "Improper indentation");
//        AssertSz(_cPreFormat == 0, "Pre-formated block(s) not terminated");
        AssertSz(_cSuppress == 0, "Suppress mode not terminated");
    }
#endif // DBG

    Flush();
    _pStm->Release( );

    if (_pExtendedTagTable)
    {
        _pExtendedTagTable->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::Terminate
//
//  Synopsis:   Appends a null character at the end of the stream
//
//----------------------------------------------------------------------------
HRESULT CStreamWriteBuff::Terminate()
 {
    HRESULT hr = S_OK;

    Assert( _fInited );
    hr = FlushWBuffer(FALSE, FALSE);   // flush from wchar to multibyte
    if( hr )
        goto Cleanup;

    Assert( _pbBuffer != NULL );

    hr = WriteDirectToMultibyte('\0', 1);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::FlushMBBuffer()
//
//  Synopsis:   Flush the ansi buffer on to an IStream object.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::FlushMBBuffer()
{
    HRESULT hr = S_OK;

    Assert( _fInited );
    if (_pbBuffer && _cbBuffer)
    {
        hr = THR(_pStm->Write(_pbBuffer, _cbBuffer, NULL));

        _cbBuffer = 0;                           // reset index to 0
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::Write
//
//  Synopsis:   Write a string into the buffer
//
//  Arguments:  const   TCHAR *     output string
//                      int         length of the string
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::Write(const TCHAR *pch, int cch)
{
            HRESULT hr = S_OK;
    const   TCHAR*  pchER;      // entity reference
            TCHAR   chCur;
            TCHAR   chCR[20];   // character reference
            int     cchWAvail;
            int     nLen;
            // contain indentation
            int     cchIndent = (_cchIndent > 32) ? 32 : _cchIndent;
    const   BOOL    fCp1252 = (_uiWinCodepage == 1252);
    const   TCHAR   chNBSPMaybe = (   TestFlag(WBF_FOR_RTF_CONV)
                                   || TestFlag(WBF_SAVE_PLAINTEXT))
                                  ? WCH_NBSP : 0;
    const   BOOL    fVerbatim = _cPreFormat || TestFlag(WBF_SAVE_VERBATIM);

    Assert( _fInited );

    // Check if we are suppressing output
    if (_cSuppress)
        return S_OK;

    if( !TestFlag(WBF_FORMATTED) )
        cchIndent = 0;

    if ( !pch || !cch )
        return S_OK;

    if(cch < 0)
        cch = _tcslen(pch);

    chCR[0] = _T('#');

    while (cch)
    {
        if (_fNeedIndent)
        {
            _fNeedIndent = FALSE;

            if (!fVerbatim)
            {
                hr = THR(WriteDirectToMultibyte(' ', cchIndent));
                if (hr)
                    goto CleanUp;
            }
        }

        cchWAvail = _nBlockSize - _cchBuffer;
        AssertSz (_cchBuffer <= _nBlockSize, "CStreamWriteBuff::Wide Char Buffer overflow");

        chCur = *pch;
        pchER = NULL;

        // If we are in enitise mode and not saving in plaintext,
        // entitise the current char - otherwise, we may convert NBSPs to
        // spaces in two cases:
        // 1. if we're on a FE system and writing plaintext, since those
        //    charsets do not have a multibyte NBSP character.
        // 2. if we're saving for the rtf converter

        nLen = 1;

        if (chCur == chNBSPMaybe)
        {
            chCur = L' ';  // (cthrash) this is a bit of a hack.
        }
        else if (TestFlag(WBF_ENTITYREF) && !TestFlag(WBF_SAVE_PLAINTEXT))
        {
            BOOL fEntitize;

            if (IsAscii(chCur))
            {
                fEntitize =    (chCur == WCH_QUOTATIONMARK && !TestFlag(WBF_NO_DQ_ENTITY))
                            || (chCur == WCH_AMPERSAND     && !TestFlag(WBF_NO_AMP_ENTITY))
                            || (chCur == WCH_LESSTHAN      && !TestFlag(WBF_NO_LT_ENTITY))
                            || (chCur == WCH_GREATERTHAN   && !TestFlag(WBF_NO_LT_ENTITY))
                            || (chCur <  _T(' ')           &&  TestFlag(WBF_CRLF_ENTITY));
            }
            else 
            {
                fEntitize =    !TestFlag(WBF_NO_NAMED_ENTITIES)
                            && (   chCur == WCH_NBSP
                                || chCur == WCH_NONREQHYPHEN);
            }

            if (fEntitize)
            {
                // N.B. (johnv) If we do not have an entry in the entity table,
                // just let the character through as is.  Our superclass
                // CEncodeWriter will take care of entitizing characters not
                // available in the current character set.

                if (chCur < _T(' ') && TestFlag(WBF_CRLF_ENTITY))
                {
                    pchER = chCR;
                    _ultot(chCur, chCR + 1, 10);
                }
                else
                {
                    pchER = LookUpErTable(chCur, fCp1252);
                    Assert(pchER);
                }
                nLen = _tcslen(pchER) + 2; // for & and ;
            }
        }

        // If we do not have enough space in the wide char buffer,
        // move the contents from lastnewline to the end of the
        // buffer to the begining of the buffer
        while(cchWAvail < nLen + 1)
        {
            // If we did not find a place to break in the entire buffer
            // flush the entire buffer.
            if(!_ichLastNewLine)
            {
                // If we need to make space then we should have flushed
                // the line when we went over 80 chars.  We should never
                // have the case where we have a line under 80 chars and
                // we need to make space.
                Assert( _iLastValidBreak == 0 );

                // full buffer without a valid line break
                _iLastValidBreak = _cchBuffer;    // to flush the entire buffer

                hr = FlushWBuffer(FALSE, FALSE);
                if( hr )
                    goto CleanUp;

                _cchBuffer = 0;
                _ichLastNewLine = 0;
                _iLastValidBreak = 0;
                cchWAvail = _nBlockSize;

                Assert( cchWAvail >= nLen + 1 );
            }
            else
            {
                // move the memory from lastnewline
                _cchBuffer = _nBlockSize - _ichLastNewLine - cchWAvail;
                memmove(&_pchBuffer[0],
                        &_pchBuffer[_ichLastNewLine],
                        _cchBuffer * sizeof(TCHAR));
                _iLastValidBreak = _iLastValidBreak - _ichLastNewLine;
                _ichLastNewLine = 0;
                cchWAvail = _nBlockSize - _cchBuffer;
            }
        }

        // If we can break, and we are not saving pre formatted text
        // updated the valid break index.
        if(!TestFlag(WBF_NO_WRAP) && !_cPreFormat)
        {
            if (chCur == _T(' '))           // space is a valid break
            {
                _iLastValidBreak = _cchBuffer+1;
            }
        }

        // Ignore cariage returns and linefeed if we are not
        // are not saving preformatted text
        if(!_cPreFormat && !TestFlag(WBF_KEEP_BREAKS) &&
                (chCur == _T('\r') || chCur == _T('\n')))
        {
            _iLastValidBreak = _cchBuffer;

            pch++;
            cch--;
            continue;
        }

        // write the entitised string or char in to the wide char buffer.
        if(pchER)
        {
            _pchBuffer[_cchBuffer++] = _T('&');
            memcpy(&_pchBuffer[_cchBuffer], pchER, sizeof(TCHAR) *(nLen - 2));
            _cchBuffer += nLen - 2;
            _pchBuffer[_cchBuffer++] = _T(';');
        }
        else
        {
            _pchBuffer[_cchBuffer++] = chCur;

            // For preformatted we have written the \r, now we have to write \n
            //  (unless already present)
            // NOTE: \r's need \n's when saving from textarea (paulpark)
            if(chCur == _T('\r') && _cPreFormat)
            {
                if (!TestFlag(WBF_SAVE_VERBATIM) &&
                    (cch == 1 ||
                    (cch > 1 && pch[1] != _T('\n'))))
                {
                    _pchBuffer[_cchBuffer++] = _T('\n');
                }
                _iLastValidBreak = _cchBuffer;
                NewLine();
            }
        }

        // If we have more than 80 chars in the wide char buff,
        // and have seen a break, flush them to the ansi char buffer
        if(_ichLastNewLine != _iLastValidBreak &&
                _cchBuffer - _ichLastNewLine + cchIndent > 80)
        {
            hr = NewLine();
            if(hr)
                goto CleanUp;
        }

        cch--;
        pch++;
    }

CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::WriteDirectToMultibyte
//
//  Synopsis:   This function throws characters as is into the multibyte character,
//              unless we are writing out unicode, in which case we add a null
//              character after each byte.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::WriteDirectToMultibyte(CHAR ch, int iRepeat)
{
    HRESULT hr = S_OK;

    Assert( _fInited );

    // Make sure we have something to do
    if( _cSuppress || iRepeat <= 0 )
        return S_OK;

    if(     _cp == NATIVE_UNICODE_CODEPAGE 
        ||  _cp == NATIVE_UNICODE_CODEPAGE_BIGENDIAN )
    {
        // CONSIDER: support for NONNATIVE (UCS_4 on Win32) support
        WCHAR  tch = WCHAR(ch);
        WCHAR *pch;
        int    cch;

        // Shift for BIGENDIAN -- 8 for Win32, 24 for UNIX
        if (_cp == NATIVE_UNICODE_CODEPAGE_BIGENDIAN )
        {
#ifdef UNIX
            tch <<= 24;
#else
            tch <<= 8;
#endif
        }

        if (_cbBuffer + int(iRepeat * sizeof(TCHAR)) >= _cbBufferMax )
        {
            hr = FlushMBBuffer();
            if( hr )
                goto Cleanup;
        }

        Assert(_cbBufferMax - _cbBuffer >= int(iRepeat * sizeof(TCHAR)));

        cch = min( int((_cbBufferMax - _cbBuffer) / sizeof(TCHAR)), iRepeat);
        pch = (WCHAR *)(_pbBuffer + _cbBuffer);
        _cbBuffer += cch * sizeof(TCHAR);
        while(cch-- > 0)
        {
            *pch++ = tch;
        }
    }
    else
    {
        int cb;

        if (_cbBuffer + iRepeat >= _cbBufferMax)
        {
            hr = FlushMBBuffer();
            if( hr )
                goto Cleanup;
        }

        Assert(_cbBufferMax - _cbBuffer >= iRepeat);

        cb = min(_cbBufferMax - _cbBuffer, iRepeat);
        memset(_pbBuffer + _cbBuffer, ch, cb);
        _cbBuffer += cb;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::FlushWBuffer
//
//  Synopsis:   Writes the current line from wide char buffer to the ansi
//              buffer and write new line and spaces if there is any indentation
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::FlushWBuffer(BOOL fIndent, BOOL fNewLine)
{
    HRESULT hr = S_OK;
    int     nLineLength;
    int     cchIndent = (_cchIndent > 32) ? 32 : _cchIndent;

    Assert( _fInited );

    if( !TestFlag(WBF_FORMATTED) )
        cchIndent = 0;

    // new line is called explictly or when the number of chars in the
    // wide char buffer exceed 80.
    if(_cchBuffer - _ichLastNewLine + cchIndent > 80 &&
        _ichLastNewLine != _iLastValidBreak)
    {
        nLineLength = _iLastValidBreak  - _ichLastNewLine;
    }
    else
    {
        // line without a word break or in a pre
        nLineLength = _cchBuffer - _ichLastNewLine;
    }

    // convert wide char to ansi and save in the ansi buffer
    if(nLineLength)
    {
        int cch;

        if(int(sizeof(TCHAR) * nLineLength) > _cbBufferMax - _cbBuffer)
        {
            hr = THR( FlushMBBuffer( ) );
            if( hr )
                goto Cleanup;

            Assert( _pbBuffer != NULL );
        }

        {
            // N.B. (johnv) This will be cleaned up when this class gets
            // re-worked.
            TCHAR* pchBufferPtrSave = _pchBuffer;
            int    cchBufferSave = _cchBuffer;

            _cchBuffer  = nLineLength;
            _pchBuffer += _ichLastNewLine;

            hr = THR( MultiByteFromWideChar( TRUE, &cch ) );

            _pchBuffer = pchBufferPtrSave;
            _cchBuffer = cchBufferSave;

            // N.B. (johnv) Make sure _pchBuffer and _cchBuffer are restored
            // before cleaning up, or you may free invalid memory.
            if( hr )
                goto Cleanup;

        }
    }

    _ichLastNewLine += nLineLength;
    _iLastValidBreak = _ichLastNewLine;

    // If we are not in a preformatted block then write a carriage return,
    // linefeed and spaces for indentation if any.
    if (fNewLine)
    {
        if (!_cPreFormat && !TestFlag(WBF_SAVE_VERBATIM))
        {
            IGNORE_HR(WriteDirectToMultibyte('\r', 1));
            IGNORE_HR(WriteDirectToMultibyte('\n', 1));

            _fNeedIndent = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::WriteRule
//
//  Synopsis:   Writes a horizontal rule
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT CStreamWriteBuff::WriteRule()
{
    HRESULT hr = S_OK;
    int     cchIndent = (_cchIndent > 32) ? 32 : _cchIndent;

    Assert( _fInited );

    // Check to see if we are in suppress mode
    if (_cSuppress)
        return S_OK;

    if( !TestFlag(WBF_FORMATTED) )
        cchIndent = 0;

    hr = THR(WriteDirectToMultibyte('-', 80 - cchIndent));

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::Flush()
//
//  Synopsis:   Flush the contents of the stream buffer to the IStream object.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::Flush()
{
    HRESULT hr;

    Assert( _fInited );

    hr = FlushWBuffer(FALSE, FALSE);
    if(!hr)
    {
        hr = FlushMBBuffer();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::WriteQuotedText( TCHAR* pch )
//
//  Synopsis:   This function writes the specified text in either single or
//              double quotes.  If necessary, it entitizes the contents
//              of pch.  The rules are as follows:
//
//              1. If pch contains no single quotes or spaces, do not
//                 entitize, and output pch in double quotes.
//              2. If pch contains double quotes but no single quotes,
//                 do not entitize, and output pch in single quotes.
//              3. If pch contains both double and single quotes, output
//                 an entitized pch in double quotes.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::WriteQuotedText( const TCHAR * pch, BOOL fAlwaysQuote )
{
    HRESULT hr = S_OK;
    const TCHAR*  pbuf;
    BOOL    fHasDoubleQuotes = FALSE, fHasSingleQuotes = FALSE;

    Assert( _fInited );

    // First search for double quotes, single quotes, and characters less
    // than the space character.
    pbuf = pch;
    if( !*pbuf )
    {
        fAlwaysQuote = TRUE;
    }
    else
    {
        while( *pbuf )
        {
            if( *pbuf == _T('"') )
                fHasDoubleQuotes = TRUE;
            else if( *pbuf == _T('\'') )
                fHasSingleQuotes = TRUE;
            else if( *pbuf <= _T(' ') )
                fAlwaysQuote = TRUE;        // if we have spaces, we must quote
            else if( *pbuf == _T('<') || *pbuf == _T('>') )
                fAlwaysQuote = TRUE;        // if we have an ASP script, we must quote

            pbuf++;
        }
    }

    if( fAlwaysQuote || fHasDoubleQuotes || fHasSingleQuotes )
    {
        TCHAR   szQuote[2];
        DWORD   dwOldFlags = 0;
        DWORD   dwNewFlags = 0;
    
        if (fHasDoubleQuotes && !fHasSingleQuotes)
        {
            // Although IE5 26994 indicates we should never use single quotes,
            // IE5 53563 indicates we should use single quotes if double quotes are inside
            // the string; 53563 won, so we use single quotes (dbau)
            szQuote[0] = _T('\'');
            szQuote[1] = 0;
            dwNewFlags = WBF_ENTITYREF | WBF_CRLF_ENTITY | WBF_NO_WRAP | WBF_NO_LT_ENTITY | WBF_KEEP_BREAKS | WBF_NO_DQ_ENTITY;
        }
        else
        {
            szQuote[0] = _T('"');
            szQuote[1] = 0;
            // We should not be entitizing LT and GT, since ASP editing using VID counts on that.
            // Although it is not IE40 behavior, this is necessary for ASP editing. (ferhane)
            dwNewFlags = WBF_ENTITYREF | WBF_CRLF_ENTITY | WBF_NO_WRAP | WBF_NO_LT_ENTITY | WBF_KEEP_BREAKS;
        }

 
        hr = Write(szQuote, 1*sizeof(TCHAR), 0);
        if( hr )
            goto Cleanup;

        // Special entity rules when quoting
        dwOldFlags = SetFlags(dwNewFlags);

        hr = Write(pch, _tcslen(pch)*sizeof(TCHAR), 0);
        if( hr )
            goto Cleanup;

        RestoreFlags(dwOldFlags);

        hr = Write(szQuote, 1*sizeof(TCHAR), 0);
        if( hr )
            goto Cleanup;
    }
    else
    {
        // If we do not use quotes, we must entitize all quotes and LT/GT symbols

        DWORD dwOldFlags = SetFlags(WBF_ENTITYREF | WBF_CRLF_ENTITY | WBF_KEEP_BREAKS);

        hr = Write( pch, _tcslen(pch)*sizeof(TCHAR), 0 );

        RestoreFlags( dwOldFlags );
    }


Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::SaveNamespaceAttrPI
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::SaveNamespaceAttrPI(LPTSTR pchNamespace, LPTSTR pchUrn)
{
    HRESULT     hr;
    LPTSTR      pch_XmlNS;

    Assert( _fInited );
    Assert (pchNamespace);

    // if appears to be originally lower-case
    if (ChrLower(pchNamespace[0]))
    {
        pch_XmlNS = _T(" xmlns:");
    }
    else // if appears to be originally upper-case
    {
        pch_XmlNS = _T(" XMLNS:");
    }

    hr = THR(Write(pch_XmlNS));
    if (hr)
        goto Cleanup;

    hr = THR(Write(pchNamespace));
    if (hr)
        goto Cleanup;

    if (pchUrn)
    {
        hr = THR(Write(_T(" = \"")));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\"")));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::SaveNamespacePI
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::SaveNamespacePI(LPTSTR pchNamespace, LPTSTR pchUrn)
{
    HRESULT     hr;
    LPTSTR      pch_Xml_Namespace_Prefix;
    LPTSTR      pch_Urn;
    DWORD       dwOldFlags;

    Assert( _fInited );
    dwOldFlags = ClearFlags(WBF_ENTITYREF);

    // if appears to be originally lower-case
    if (ChrLower(pchNamespace[0]))
    {
        pch_Xml_Namespace_Prefix = _T("<?xml:namespace prefix = ");
        pch_Urn                  = _T(" ns = \"");
    }
    else // if appears to be originally upper-case
    {
        pch_Xml_Namespace_Prefix = _T("<?XML:NAMESPACE PREFIX = ");
        pch_Urn                  = _T(" NS = \"");
    }

    hr = THR(Write(pch_Xml_Namespace_Prefix));
    if (hr)
        goto Cleanup;

    hr = THR(Write(pchNamespace));
    if (hr)
        goto Cleanup;

    if (pchUrn && pchUrn[0])
    {
        hr = THR(Write(pch_Urn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\"")));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Write(_T(" />")));
    if (hr)
        goto Cleanup;

#if 0
    hr = THR(NewLine());
    if (hr)
        goto Cleanup;
#endif

    RestoreFlags(dwOldFlags);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::SaveImportPI
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::SaveImportPI(LPTSTR pchNamespace, LPTSTR pchUrn, LPTSTR pchImplementation, BOOL fDeclareNamespace)
{
    HRESULT     hr;
    DWORD       dwOldFlags;
    LPTSTR      pch_Import;
    LPTSTR      pch_Urn;
    LPTSTR      pch_Implementation;
    LPTSTR      pch_DeclareNamespace;

    Assert( _fInited );
    dwOldFlags = ClearFlags(WBF_ENTITYREF);

    // if appears to be originally lower-case
    if (ChrLower(pchNamespace[0]))
    {
        pch_Import           = _T("<?import namespace = ");
        pch_Urn              = _T("urn = \"");
        pch_Implementation   = _T("implementation = \"");
        pch_DeclareNamespace = _T("declareNamespace ");
    }
    else // if appears to be originally upper-case
    {
        pch_Import           = _T("<?IMPORT NAMESPACE = ");
        pch_Urn              = _T("URN = \"");
        pch_Implementation   = _T("IMPLEMENTATION = \"");
        pch_DeclareNamespace = _T("DECLARENAMESPACE ");
    }

    hr = THR(Write(pch_Import));
    if (hr)
        goto Cleanup;

    hr = THR(Write(pchNamespace));
    if (hr)
        goto Cleanup;

    hr = THR(Write(_T(" ")));
    if (hr)
        goto Cleanup;

    if (pchUrn)
    {
        hr = THR(Write(pch_Urn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\" ")));
        if (hr)
            goto Cleanup;
    }

    if (pchImplementation)
    {
        hr = THR(Write(pch_Implementation));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchImplementation));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\" ")));
        if (hr)
            goto Cleanup;
    }

    if (fDeclareNamespace)
    {
        hr = THR(Write(pch_DeclareNamespace));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Write(_T("/>")));
    if (hr)
        goto Cleanup;

    RestoreFlags(dwOldFlags);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::EnsurePIsSaved
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::EnsurePIsSaved (CElement * pElement, CExtendedTagDesc * pTagDesc, DWORD dwDeclStyle)
{
    HRESULT     hr = S_OK;

    Assert( _fInited );
    Assert (pElement && pTagDesc);
    Assert (pTagDesc->IsValid() && pTagDesc->Namespace());

    if (    TestFlag(WBF_SAVE_FOR_PRINTDOC)
        ||  pTagDesc->IsPIRequired()        )
    {
        hr = THR(EnsurePIsSaved(
            pElement->Doc(), pElement->GetMarkup(),
            pTagDesc->Namespace(), pTagDesc->Urn(),
            pTagDesc->Implementation(),
            dwDeclStyle));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::EnsurePIsSaved
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::EnsurePIsSaved (
    CDoc *              pDoc,
    CMarkup *           pMarkup,
    LPTSTR              pchNamespace,
    LPTSTR              pchUrn,
    LPTSTR              pchImplementation,
    DWORD               dwDeclStyle)
{
    HRESULT                 hr = S_OK;
    BOOL                    fNamespaceChange = TRUE;
    BOOL                    fImportPI;
    CExtendedTagNamespace * pNamespace = NULL;

    Assert( _fInited );
    Assert ( pDoc && pchNamespace );
    Assert( !TestFlag( WBF_FOR_TREESYNC ) );

    // If we're saving some generic element off in the ether, we have no markup, so
    // we don't make a tag table - we don't need one anyway.
    if( pMarkup )
    {
        if (!_pExtendedTagTable)
        {
            _pExtendedTagTable = new CExtendedTagTable(pDoc, pMarkup, /* fShareBooster = */FALSE);
            if (!_pExtendedTagTable)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        hr = THR(_pExtendedTagTable->EnsureNamespace(pchNamespace, pchUrn, &pNamespace, &fNamespaceChange));
        if (hr)
            goto Cleanup;

        Assert (pNamespace);
    }

    switch (dwDeclStyle)
    {
    case XMLNAMESPACEDECL_STD:

        if (fNamespaceChange)
        {
            hr = THR(SaveNamespaceAttrPI(pchNamespace, pchUrn));
            if (hr)
                goto Cleanup;
        }

        break;

    case XMLNAMESPACEDECL_TAG:
        if( fNamespaceChange )
        {
            hr = THR(SaveNamespacePI(pchNamespace, pchUrn));
            if( hr )
                goto Cleanup;
        }

        break;

    case XMLNAMESPACEDECL_IMPORT:

        fImportPI = fNamespaceChange;
        if (pchImplementation && pNamespace)
        {
            if (pNamespace->_cstrFactoryUrl.IsNull() ||
                0 != StrCmpIC(pNamespace->_cstrFactoryUrl, pchImplementation))
            {
                pNamespace->_cstrFactoryUrl.Free();

                hr = THR(pNamespace->_cstrFactoryUrl.Set(pchImplementation));
                if (hr)
                    goto Cleanup;

                fImportPI = TRUE;
            }
        }

        if (fImportPI)
        {
            hr = THR(SaveImportPI(pchNamespace, pchUrn, pchImplementation, /* fDeclareNamespace = */ fNamespaceChange));
            if (hr)
                goto Cleanup;
        }

        break;

    default:
        Assert (0 && "not implemented");
    }

Cleanup:

    RRETURN (hr);
}
//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::CStreamReadBuff
//
//  Synopsis:   Instantiates our class from a IStream pointer.
//
//  Returns:
//
//----------------------------------------------------------------------------

CStreamReadBuff::CStreamReadBuff( IStream* pIStream, CODEPAGE cp )
                    : _pStm( pIStream ),
                       CEncodeReader( cp, WBUFF_SIZE )
{
    Assert( pIStream );
    _pStm->AddRef( );
    _eof              = FALSE;
    _lastGetCharError = S_OK;
    _iIndex           = -1;
    _cchChunk         = 0;
}

CStreamReadBuff::~CStreamReadBuff( )
{
    _pStm->Release( );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::Get
//
//  Synopsis:   Copies at most cbBuffer bytes into pBuffer, but less if we encounter
//              end of file or an error first.  *pcbRead gets set to the number of
//              bytes copied.  No null termination.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::Get( TCHAR* pBuffer, int cchAvailable, int* pchRead )
{
    int lCharsToCopy;
    TCHAR* pBufCur = pBuffer;

    *pchRead = 0;

    if( _eof )
        RRETURN1( S_FALSE, S_FALSE );

    // Loop until we have exhausted the size of pBuffer or encounter an error/end of file
    while( cchAvailable > 0 && !_eof )
    {
        if( _iIndex < 0 || _iIndex >= _cchChunk )
        {
            // If the _iIndex is set to an invalid position, we need to read another chunk.
            HRESULT hr = ReadChunk( );
            if( hr )
            {
                if( !(*pchRead) )
                    // If we didn't read anything at all and get an error in ReadChunk return it.
                    RRETURN1( hr, S_FALSE );
                else
                    break;
            }
        }
        // Copy into pBuffer but be careful not to overflow it
        lCharsToCopy = min( cchAvailable, _cchChunk - _iIndex );
        memcpy( (void*)pBufCur, _achBuffer+_iIndex, lCharsToCopy * sizeof(TCHAR) );
        cchAvailable -= lCharsToCopy;
        _iIndex   += lCharsToCopy;
        *pchRead  += lCharsToCopy;
        pBufCur   += lCharsToCopy;
    }

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetLine
//
//  Synopsis:   Copies the next non-empty 'line' of text in the supplied buffer,
//              copying at most cchBuffer-1 bytes.  Null terminates the buffer.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetLine( TCHAR* pBuffer, int cchBuffer )
{
    HRESULT hr = S_OK;
    int  index = 0;

    if( _eof )
        RRETURN1( S_FALSE, S_FALSE );

    // Read until we get to end of file or to a cr or lf, copying into the buffer
    while( GetChar() != 0 && GetChar() != _T('\r') && GetChar() != _T('\n') &&
            index < cchBuffer - 1)
    {
        pBuffer[ index++ ] = GetChar( );
        hr = THR( Advance( ) );
        if( FAILED( hr ) )
            goto Cleanup;
    }

    pBuffer[ index ] = 0;

    // Skip over cr/lfs
    if( GetChar() == _T('\r') )
    {
        hr = THR( Advance( ) );
        if( FAILED( hr ) )
            goto Cleanup;
    }
    if( GetChar() == _T('\n') )
    {
        hr = THR( Advance( ) );
        if( FAILED( hr ) )
            goto Cleanup;
    }

Cleanup:
    // S_FALSE means we hit end of file, which is still ok.  This is different
    // than starting at the end of the file, where we want to return S_FALSE
    if( hr == S_FALSE )
        hr = S_OK;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::ReadChunk
//
//  Synopsis:   Reads a chunk of data from the stream at the current position,
//              and populates the _achBuffer and _abBuffer internal buffers.
//              Performs a MultiByteToWideChar conversion to fill _achBuffer
//              from _abBuffer, depending on the current mapping mode.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::ReadChunk( )
{
    ULONG cbRead;
    HRESULT hr = S_OK;

    if( _eof )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( PrepareToEncode( ) );
    if( hr )
        goto Cleanup;

    // Read a chunk from the stream

    Assert( _pbBuffer );
    Assert( _cbBuffer + BlockSize() <= _cbBufferMax );

    hr = _pStm->Read(_pbBufferPtr, BlockSize(), &cbRead);
    if( hr == S_FALSE )
    {
        Assert(cbRead == 0);
        cbRead = 0;
    }
    else if( hr )
        goto Cleanup;

    _cbBuffer += cbRead;
    _pbBufferPtr = _pbBuffer;

    // If we didn't read anything at all, we have an end of file condition
    if( cbRead == 0 )
    {
        _iIndex   = -1;
        _cchChunk = 0;
        _eof      = TRUE;
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( WideCharFromMultiByte( TRUE, &_cchChunk ) );
    if( hr )
        goto Cleanup;

    _achBuffer = _pchBuffer;
    _iIndex    = 0;

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::MakeRoomForChars
//
//  Synopsis:   Make sure we have enough room for at least 'cch' characters in
//              out wide char buffer.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::MakeRoomForChars(int cch)
{
    HRESULT hr = S_OK;

    if (!_pchBuffer)
    {
        // round up to block size multiple >= cch+1
        _cchBuffer = (cch + BlockSize()) & ~(BlockSize()-1);

        _pchBuffer = (TCHAR*)MemAlloc(Mt(CStreamReadBuff), _cchBuffer * sizeof(TCHAR));
        if (!_pchBuffer)
            return(E_OUTOFMEMORY);

        _pchEnd = _pchBuffer;
    }
    else
    {
        int cchCur  = (_pchEnd - _pchBuffer);
        int cchNeed = cchCur + cch;

        if (cchNeed >= _cchBuffer)
        {
            TCHAR *pchNewBuffer = _pchBuffer;

            cchNeed = (cchNeed + BlockSize() - 1) & ~(BlockSize()-1);

            hr = THR(MemRealloc(Mt(CStreamReadBuff), (void**)&pchNewBuffer, cchNeed * sizeof(TCHAR)));
            if (hr)
                goto Cleanup;

            _pchBuffer = pchNewBuffer;
            _pchEnd    = _pchBuffer + cchCur;
            _cchBuffer = cchNeed;
        }
    }

    CEncodeReader::MakeRoomForChars(cch);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetChar
//
//  Synopsis:   Returns the character at the current position in the stream,
//              or 0 if an error has occurred.
//
//  Returns:
//
//----------------------------------------------------------------------------

TCHAR
CStreamReadBuff::GetChar( )
{
    if( _eof )
        return 0;

    // If we are not within range, advance to get there
    if( _iIndex < 0 || _iIndex >= _cchChunk )
    {
        HRESULT hr = Advance( );
        if( hr )
        {
            _lastGetCharError = hr;
            return 0;
        }
    }

    return _achBuffer[ _iIndex ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::Advance
//
//  Synopsis:   Move the current position one character to the right.  Note that
//              Advance() when the chunk buffer is empty will keep us at position
//              zero.
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT
CStreamReadBuff::Advance( )
{
    if( _eof || _lastGetCharError )
        RRETURN1( S_FALSE, S_FALSE );

    if( _iIndex < 0 || _iIndex >= _cchChunk - 1)
    {
        HRESULT hr = ReadChunk( );
        if( hr )
            RRETURN1( hr, S_FALSE );
    }
    else
        ++_iIndex;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::SetPosition
//
//  Synopsis:   Set the current stream position to the supplied absolute offset.
//              If mode==STREAM_SEEK_CUR, lPosition is relative to the current
//              position in the file.  mode==STREAM_SEEK_SET, lPosition is
//              absolute.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::SetPosition( LONG lPosition, DWORD dwOrigin )
{
    LARGE_INTEGER liPosition;
    HRESULT hr;

#ifdef UNIX
    QUAD_PART(liPosition) = (LONGLONG)lPosition;
#else
    liPosition.QuadPart = (LONGLONG)lPosition;
#endif

    hr = _pStm->Seek( liPosition, dwOrigin, NULL );
    if( hr )
        RRETURN( hr );

    _iIndex   = -1;       // Signal Read routines that we need to read again
    _eof      = FALSE;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetPosition
//
//  Synopsis:   Find the current absolue position as a long.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetPosition( LONG* plPositionRet )
{
    HRESULT hr;
    ULARGE_INTEGER lPosition;
    LARGE_INTEGER   zero = { 0, 0 };

    // Get our current position in the stream
    hr = _pStm->Seek( zero, STREAM_SEEK_CUR, &lPosition );
    if( hr )
        RRETURN( hr );

#ifdef UNIX
    *plPositionRet = (LONG) U_QUAD_PART(lPosition);
#else
    *plPositionRet = (LONG) lPosition.QuadPart;
#endif

    // Adjust for any characters we have not yet eaten from the chunk buffer
    if( _iIndex >= 0 && _iIndex < _cchChunk )
        *plPositionRet -= _cchChunk - _iIndex;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetStringValue
//
//  Synopsis:   Look for Tag:Value, and copy Value into pString (though at most
//              cchString-1) if you find it.  Otherwise pString will be empty.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetStringValue( TCHAR* pTag, TCHAR* pString, int cchString )
{
    HRESULT hr;
    TCHAR buffer[ 256 ];
    int  cbTag;

    pString[0] = 0;

    // Read in a line from the stream
    hr = GetLine( buffer, ARRAY_SIZE( buffer ) );
    if( hr )
        RRETURN( hr );

    cbTag = _tcsclen( pTag );

    // Make sure the tag matches
    if( memcmp( pTag, buffer, cbTag * sizeof(TCHAR) ) )
        RRETURN1( S_FALSE, S_FALSE );

    // Make sure we have a semicolon after in
    if( buffer[cbTag] != _T(':') )
        RRETURN1( S_FALSE, S_FALSE );

    // Copy contents after the colon into pString
    int n;
    for( n = 0; n < cchString - 1 && buffer[ cbTag + n + 1]; ++n )
        pString[ n ]  = buffer[ cbTag + n + 1 ];

    pString[ n ] = 0;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetLongValue
//
//  Synopsis:   Same as GetStringValue, except returns a number.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetLongValue( TCHAR* pTag, LONG* pLong )
{
    TCHAR numberAsString[ 33 ];
    HRESULT hr;

    // Simply call GetString value and then convert what it returns to a long
    hr = GetStringValue( pTag, numberAsString, ARRAY_SIZE(numberAsString) );
    if( hr )
    {
        *pLong = 0;
        RRETURN1( hr, S_FALSE );
    }
    else
    {
        IGNORE_HR(ttol_with_error( numberAsString, pLong));
        RRETURN( S_OK );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\unidir.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File: unipart.cxx
//
//  This is a generated file.  Do not modify by hand.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#ifndef X__UNIDIR_H
#define X__UNIDIR_H
#include "unidir.h"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//  Generating script: unidir_make_cxx.pl
//  Generated on Mon Dec  4 20:07:03 2000


const DIRCLS s_aDirClassFromCharClass[CHAR_CLASS_MAX] =
{
    NEU, // WOB_
    NEU, // NOPP
    NEU, // NOPA
    NEU, // NOPW
    NEU, // HOP_
    NEU, // WOP_
    NEU, // WOP5
    NEU, // NOQW
    NEU, // AOQW
    NEU, // WOQ_
    NEU, // WCB_
    NEU, // NCPP
    NEU, // NCPA
    NEU, // NCPW
    NEU, // HCP_
    NEU, // WCP_
    NEU, // WCP5
    NEU, // NCQW
    NEU, // ACQW
    NEU, // WCQ_
    NEU, // ARQW
    CSP, // NCSA
    NEU, // HCO_
    NEU, // WC__
    CSP, // WCS_
    NEU, // WC5_
    CSP, // WC5S
    LTR, // NKS_
    NEU, // WKSM
    LTR, // WIM_
    NEU, // NSSW
    NEU, // WSS_
    LTR, // WHIM
    LTR, // WKIM
    LTR, // NKSL
    LTR, // WKS_
    CBN, // WKSC
    LTR, // WHS_
    NEU, // NQFP
    NEU, // NQFA
    NEU, // WQE_
    NEU, // WQE5
    NEU, // NKCC
    NEU, // WKC_
    CSP, // NOCP
    NEU, // NOCA
    NEU, // NOCW
    NEU, // WOC_
    CSP, // WOCS
    CSP, // WOC5
    NEU, // WOC6
    NEU, // AHPW
    CSP, // NPEP
    LTR, // NPAR
    NEU, // HPE_
    NEU, // WPE_
    CSP, // WPES
    CSP, // WPE5
    NEU, // NISW
    NEU, // AISW
    WSP, // NQCS
    NEU, // NQCW
    CBN, // NQCC
    ETM, // NPTA
    NEU, // NPNA
    ETM, // NPEW
    ETM, // NPEH
    ETM, // NPEV
    NEU, // APNW
    ETM, // HPEW
    ETM, // WPR_
    ETM, // NQEP
    ETM, // NQEW
    NEU, // NQNW
    ETM, // AQEW
    NEU, // AQNW
    LTR, // AQLW
    ETM, // WQO_
    WSP, // NSBL
    WSP, // WSP_
    LTR, // WHI_
    LTR, // NKA_
    LTR, // WKA_
    NEU, // ASNW
    ETM, // ASEW
    LTR, // ASRN
    ENM, // ASEN
    LTR, // ALA_
    LTR, // AGR_
    LTR, // ACY_
    LTR, // WID_
    LTR, // WPUA
    LTR, // NHG_
    LTR, // WHG_
    LTR, // WCI_
    NEU, // NOI_
    NEU, // WOI_
    CBN, // WOIC
    LTR, // WOIL
    ESP, // WOIS
    ETM, // WOIT
    ENM, // NSEN
    ETM, // NSET
    NEU, // NSNW
    LTR, // ASAN
    ENM, // ASAE
    ENM, // NDEA
    ENM, // WD__
    LTR, // NLLA
    LTR, // WLA_
    WSP, // NWBL
    NEU, // NWZW
    LTR, // NPLW
    NEU, // NPZW
    RTL, // NPF_
    LTR, // NPFL
    NEU, // NPNW
    LTR, // APLW
    CBN, // APCO
    NEU, // ASYW
    NEU, // NHYP
    NEU, // NHYW
    NEU, // AHYW
    NEU, // NAPA
    NEU, // NQMP
    ESP, // NSLS
    SEG, // NSF_
    WSP, // NSBS
    BLK, // NSBB
    LTR, // NLA_
    LTR, // NLQ_
    NEU, // NLQN
    UNK, // NLQC
    NEU, // ALQ_
    NEU, // ALQN
    LTR, // NGR_
    NEU, // NGRN
    LTR, // NGQ_
    NEU, // NGQN
    LTR, // NCY_
    CBN, // NCYP
    CBN, // NCYC
    LTR, // NAR_
    LTR, // NAQL
    NEU, // NAQN
    RTL, // NHB_
    CBN, // NHBC
    ETM, // NHBW
    RTL, // NHBR
    CSP, // NASR
    ARA, // NAAR
    CBN, // NAAC
    ANM, // NAAD
    ENM, // NAED
    NEU, // NANW
    ETM, // NAEW
    ARA, // NAAS
    LTR, // NHI_
    LTR, // NHIN
    CBN, // NHIC
    LTR, // NHID
    LTR, // NBE_
    CBN, // NBEC
    LTR, // NBED
    ETM, // NBET
    LTR, // NGM_
    CBN, // NGMC
    LTR, // NGMD
    LTR, // NGJ_
    CBN, // NGJC
    LTR, // NGJD
    LTR, // NOR_
    CBN, // NORC
    LTR, // NORD
    LTR, // NTA_
    CBN, // NTAC
    LTR, // NTAD
    LTR, // NTE_
    CBN, // NTEC
    LTR, // NTED
    LTR, // NKD_
    CBN, // NKDC
    LTR, // NKDD
    LTR, // NMA_
    CBN, // NMAC
    LTR, // NMAD
    LTR, // NTH_
    CBN, // NTHC
    LTR, // NTHD
    ETM, // NTHT
    LTR, // NLO_
    CBN, // NLOC
    LTR, // NLOD
    LTR, // NTI_
    CBN, // NTIC
    LTR, // NTID
    NEU, // NTIN
    LTR, // NGE_
    LTR, // NGEQ
    LTR, // NBO_
    CSP, // NBSP
    WSP, // NBSS
    SEG, // NOF_
    BLK, // NOBS
    ETM, // NOEA
    NEU, // NONA
    NEU, // NONP
    NEU, // NOEP
    NEU, // NONW
    ETM, // NOEW
    LTR, // NOLW
    CBN, // NOCO
    FMT, // NOSP
    ENM, // NOEN
    NEU, // NOBN
    LTR, // NET_
    LTR, // NETP
    LTR, // NETD
    LTR, // NCA_
    LTR, // NCH_
    LTR, // WYI_
    NEU, // WYIN
    NEU, // NBR_
    LTR, // NRU_
    LTR, // NOG_
    WSP, // NOGS
    NEU, // NOGN
    LTR, // NSI_
    CBN, // NSIC
    ARA, // NTN_
    CBN, // NTNC
    LTR, // NKH_
    CBN, // NKHC
    LTR, // NKHD
    ETM, // NKHT
    LTR, // NBU_
    CBN, // NBUC
    LTR, // NBUD
    ARA, // NSY_
    ARA, // NSYP
    CBN, // NSYC
    NEU, // NSYW
    LTR, // NMO_
    CBN, // NMOC
    LTR, // NMOD
    NEU, // NMOB
    NEU, // NMON
    LTR, // NHS_
    LTR, // WHT_
    LTR, // LS__
    UNK, // XNW_
    UNK, // XNWA
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\uniwbk.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module UNIWBK.CXX -- Unicode Word-breaking classes
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *
 *  History: <nl>
 *      06/19/98     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__UNIWBK_H_
#define X__UNIWBK_H_
#include "uniwbk.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__TXTDEFS_H
#define X__TXTDEFS_H
#include <txtdefs.h>
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

const WBKCLS awbkclsWordBreakClassFromCharClass[]=
{
    // CC           wbkcls
    /* WOB_   1*/   wbkclsPunctSymb,
    /* NOPP   2*/   wbkclsPunctSymb,
    /* NOPA   2*/   wbkclsPunctSymb,
    /* NOPW   2*/   wbkclsPunctSymb,
    /* HOP_   3*/   wbkclsPunctSymb,
    /* WOP_   4*/   wbkclsPunctSymb,
    /* WOP5   5*/   wbkclsPunctSymb,
    /* NOQW   6*/   wbkclsPunctSymb,
    /* AOQW   7*/   wbkclsPunctSymb,
    /* WOQ_   8*/   wbkclsPunctSymb,
    /* WCB_   9*/   wbkclsPunctSymb,
    /* NCPP  10*/   wbkclsPunctSymb,
    /* NCPA  10*/   wbkclsPunctSymb,
    /* NCPW  10*/   wbkclsPunctSymb,
    /* HCP_  11*/   wbkclsPunctSymb,
    /* WCP_  12*/   wbkclsPunctSymb,
    /* WCP5  13*/   wbkclsPunctSymb,
    /* NCQW  14*/   wbkclsPunctSymb,
    /* ACQW  15*/   wbkclsPunctSymb,
    /* WCQ_  16*/   wbkclsPunctSymb,
    /* ARQW  17*/   wbkclsPunctInText,
    /* NCSA  18*/   wbkclsPunctSymb,
    /* HCO_  19*/   wbkclsPunctSymb,
    /* WC__  20*/   wbkclsPunctSymb,
    /* WCS_  20*/   wbkclsPunctSymb,
    /* WC5_  21*/   wbkclsPunctSymb,
    /* WC5S  21*/   wbkclsPunctSymb,
    /* NKS_  22*/   wbkclsKanaFollow,
    /* WKSM  23*/   wbkclsKanaFollow,
    /* WIM_  24*/   wbkclsIdeoW,
    /* NSSW  25*/   wbkclsPunctSymb,
    /* WSS_  26*/   wbkclsPunctSymb,
    /* WHIM  27*/   wbkclsHiragana,
    /* WKIM  28*/   wbkclsKatakanaW,
    /* NKSL  29*/   wbkclsKatakanaN,
    /* WKS_  30*/   wbkclsKatakanaW,
    /* WKSC  30*/   wbkclsKatakanaW,
    /* WHS_  31*/   wbkclsHiragana,
    /* NQFP  32*/   wbkclsPunctSymb,
    /* NQFA  32*/   wbkclsPunctSymb,
    /* WQE_  33*/   wbkclsPunctSymb,
    /* WQE5  34*/   wbkclsPunctSymb,
    /* NKCC  35*/   wbkclsKanaDelim,
    /* WKC_  36*/   wbkclsKanaDelim,
    /* NOCP  37*/   wbkclsPunctSymb,
    /* NOCA  37*/   wbkclsPunctSymb,
    /* NOCW  37*/   wbkclsPunctSymb,
    /* WOC_  38*/   wbkclsPunctSymb,
    /* WOCS  38*/   wbkclsPunctSymb,
    /* WOC5  39*/   wbkclsPunctSymb,
    /* WOC6  39*/   wbkclsPunctSymb,
    /* AHPW  40*/   wbkclsPunctInText,
    /* NPEP  41*/   wbkclsPunctSymb,
    /* NPAR  41*/   wbkclsPunctSymb,
    /* HPE_  42*/   wbkclsPunctSymb,
    /* WPE_  43*/   wbkclsPunctSymb,
    /* WPES  43*/   wbkclsPunctSymb,
    /* WPE5  44*/   wbkclsPunctSymb,
    /* NISW  45*/   wbkclsPunctSymb,
    /* AISW  46*/   wbkclsPunctSymb,
    /* NQCS  47*/   wbkclsPunctInText,
    /* NQCW  47*/   wbkclsPunctInText,
    /* NQCC  47*/   wbkclsPunctInText,
    /* NPTA  48*/   wbkclsPrefix,
    /* NPNA  48*/   wbkclsPrefix,
    /* NPEW  48*/   wbkclsPrefix,
    /* NPEH  48*/   wbkclsPrefix,
    /* NPEV  48*/   wbkclsPrefix,
    /* APNW  49*/   wbkclsPrefix,
    /* HPEW  50*/   wbkclsPrefix,
    /* WPR_  51*/   wbkclsPrefix,
    /* NQEP  52*/   wbkclsPostfix,
    /* NQEW  52*/   wbkclsPostfix,
    /* NQNW  52*/   wbkclsPostfix,
    /* AQEW  53*/   wbkclsPostfix,
    /* AQNW  53*/   wbkclsPostfix,
    /* AQLW  53*/   wbkclsPostfix,
    /* WQO_  54*/   wbkclsPostfix,
    /* NSBL  55*/   wbkclsSpaceA,
    /* WSP_  56*/   wbkclsSpaceA,
    /* WHI_  57*/   wbkclsHiragana,
    /* NKA_  58*/   wbkclsKatakanaN,
    /* WKA_  59*/   wbkclsKatakanaW,
    /* ASNW  60*/   wbkclsPunctSymb,
    /* ASEW  60*/   wbkclsPunctSymb,
    /* ASRN  60*/   wbkclsPunctSymb,
    /* ASEN  60*/   wbkclsPunctSymb,
    /* ALA_  61*/   wbkclsAlpha,
    /* AGR_  62*/   wbkclsAlpha,
    /* ACY_  63*/   wbkclsAlpha,
    /* WID_  64*/   wbkclsIdeoW,
    /* WPUA  65*/   wbkclsIdeoW,
    /* NHG_  66*/   wbkclsHangul,
    /* WHG_  67*/   wbkclsHangul,
    /* WCI_  68*/   wbkclsIdeoW,
    /* NOI_  69*/   wbkclsIdeoW,
    /* WOI_  70*/   wbkclsIdeoW,
    /* WOIC  70*/   wbkclsIdeoW,
    /* WOIL  70*/   wbkclsIdeoW,
    /* WOIS  70*/   wbkclsIdeoW,
    /* WOIT  70*/   wbkclsIdeoW,
    /* NSEN  71*/   wbkclsSuperSub,
    /* NSET  71*/   wbkclsSuperSub,
    /* NSNW  71*/   wbkclsSuperSub,
    /* ASAN  72*/   wbkclsSuperSub,
    /* ASAE  72*/   wbkclsSuperSub,
    /* NDEA  73*/   wbkclsDigitsN,
    /* WD__  74*/   wbkclsDigitsW,
    /* NLLA  75*/   wbkclsAlpha,
    /* WLA_  76*/   wbkclsLatinW,
    /* NWBL  77*/   wbkclsSpaceA,
    /* NWZW  77*/   wbkclsSpaceA,
    /* NPLW  78*/   wbkclsPunctInText,
    /* NPZW  78*/   wbkclsPunctInText,
    /* NPF_  78*/   wbkclsPunctInText,
    /* NPFL  78*/   wbkclsPunctInText,
    /* NPNW  78*/   wbkclsPunctInText,
    /* APLW  79*/   wbkclsPunctInText,
    /* APCO  79*/   wbkclsPunctInText,
    /* ASYW  80*/   wbkclsPunctInText,
    /* NHYP  81*/   wbkclsPunctSymb,
    /* NHYW  81*/   wbkclsPunctSymb,
    /* AHYW  82*/   wbkclsPunctSymb,
    /* NAPA  83*/   wbkclsPunctInText,
    /* NQMP  84*/   wbkclsPunctSymb,
    /* NSLS  85*/   wbkclsPostfix,
    /* NSF_  86*/   wbkclsTab,
    /* NSBS  86*/   wbkclsTab,
    /* NSBB  86*/   wbkclsTab,
    /* NLA_  87*/   wbkclsAlpha,
    /* NLQ_  88*/   wbkclsAlpha,
    /* NLQN  88*/   wbkclsAlpha,
    /* NLQC  88*/   wbkclsAlpha,
    /* ALQ_  89*/   wbkclsAlpha,
    /* ALQN  89*/   wbkclsAlpha,
    /* NGR_  90*/   wbkclsAlpha,
    /* NGRN  90*/   wbkclsAlpha,
    /* NGQ_  91*/   wbkclsAlpha,
    /* NGQN  91*/   wbkclsAlpha,
    /* NCY_  92*/   wbkclsAlpha,
    /* NCYP  93*/   wbkclsAlpha,
    /* NCYC  93*/   wbkclsAlpha,
    /* NAR_  94*/   wbkclsAlpha,
    /* NAQL  95*/   wbkclsAlpha,
    /* NAQN  95*/   wbkclsAlpha,
    /* NHB_  96*/   wbkclsAlpha,
    /* NHBC  96*/   wbkclsAlpha,
    /* NHBW  96*/   wbkclsAlpha,
    /* NHBR  96*/   wbkclsAlpha,
    /* NASR  97*/   wbkclsAlpha,
    /* NAAR  97*/   wbkclsAlpha,
    /* NAAC  97*/   wbkclsAlpha,
    /* NAAD  97*/   wbkclsDigitsN,
    /* NAED  97*/   wbkclsDigitsN,
    /* NANW  97*/   wbkclsAlpha,
    /* NAEW  97*/   wbkclsAlpha,
    /* NAAS  97*/   wbkclsAlpha,
    /* NHI_  98*/   wbkclsAlpha,
    /* NHIN  98*/   wbkclsAlpha,
    /* NHIC  98*/   wbkclsAlpha,
    /* NHID  98*/   wbkclsDigitsN,
    /* NBE_  99*/   wbkclsAlpha,
    /* NBEC  99*/   wbkclsAlpha,
    /* NBED  99*/   wbkclsDigitsN,
    /* NBET  99*/   wbkclsPunctSymb,
    /* NGM_ 100*/   wbkclsAlpha,
    /* NGMC 100*/   wbkclsAlpha,
    /* NGMD 100*/   wbkclsDigitsN,
    /* NGJ_ 101*/   wbkclsAlpha,
    /* NGJC 101*/   wbkclsAlpha,
    /* NGJD 101*/   wbkclsDigitsN,
    /* NOR_ 102*/   wbkclsAlpha,
    /* NORC 102*/   wbkclsAlpha,
    /* NORD 102*/   wbkclsDigitsN,
    /* NTA_ 103*/   wbkclsAlpha,
    /* NTAC 103*/   wbkclsAlpha,
    /* NTAD 103*/   wbkclsDigitsN,
    /* NTE_ 104*/   wbkclsAlpha,
    /* NTEC 104*/   wbkclsAlpha,
    /* NTED 104*/   wbkclsDigitsN,
    /* NKD_ 105*/   wbkclsAlpha,
    /* NKDC 105*/   wbkclsAlpha,
    /* NKDD 105*/   wbkclsDigitsN,
    /* NMA_ 106*/   wbkclsAlpha,
    /* NMAC 106*/   wbkclsAlpha,
    /* NMAD 106*/   wbkclsDigitsN,
    /* NTH_ 107*/   wbkclsAlpha,
    /* NTHC 107*/   wbkclsAlpha,
    /* NTHD 107*/   wbkclsDigitsN,
    /* NTHT 107*/   wbkclsPunctSymb,
    /* NLO_ 108*/   wbkclsAlpha,
    /* NLOC 108*/   wbkclsAlpha,
    /* NLOD 108*/   wbkclsDigitsN,
    /* NTI_ 109*/   wbkclsAlpha,
    /* NTIC 109*/   wbkclsAlpha,
    /* NTID 109*/   wbkclsDigitsN,
    /* NTIN 109*/   wbkclsPunctSymb,
    /* NGE_ 110*/   wbkclsAlpha,
    /* NGEQ 111*/   wbkclsAlpha,
    /* NBO_ 112*/   wbkclsAlpha,
    /* NBSP 113*/   wbkclsSpaceA,
    /* NBSS 113*/   wbkclsSpaceA,
    /* NOF_ 114*/   wbkclsPunctSymb,
    /* NOBS 114*/   wbkclsPunctSymb,
    /* NOEA 114*/   wbkclsPunctSymb,
    /* NONA 114*/   wbkclsPunctSymb,
    /* NONP 114*/   wbkclsPunctSymb,
    /* NOEP 114*/   wbkclsPunctSymb,
    /* NONW 114*/   wbkclsPunctSymb,
    /* NOEW 114*/   wbkclsPunctSymb,
    /* NOLW 114*/   wbkclsPunctSymb,
    /* NOCO 114*/   wbkclsPunctSymb,
    /* NOSP 114*/   wbkclsPunctSymb,
    /* NOEN 114*/   wbkclsPunctSymb,
    /* NOBN 114*/   wbkclsPunctSymb,
    /* NET_ 115*/   wbkclsAlpha,
    /* NETP 115*/   wbkclsPunctSymb,
    /* NETD 115*/   wbkclsAlpha,
    /* NCA_ 116*/   wbkclsAlpha,
    /* NCH_ 117*/   wbkclsAlpha,
    /* WYI_ 118*/   wbkclsIdeoW,
    /* WYIN 118*/   wbkclsIdeoW,
    /* NBR_ 119*/   wbkclsAlpha,
    /* NRU_ 120*/   wbkclsAlpha,
    /* NOG_ 121*/   wbkclsAlpha,
    /* NOGS 121*/   wbkclsAlpha,
    /* NOGN 121*/   wbkclsAlpha,
    /* NSI_ 122*/   wbkclsAlpha,
    /* NSIC 122*/   wbkclsAlpha,
    /* NTN_ 123*/   wbkclsAlpha,
    /* NTNC 123*/   wbkclsAlpha,
    /* NKH_ 124*/   wbkclsAlpha,
    /* NKHC 124*/   wbkclsAlpha,
    /* NKHD 124*/   wbkclsDigitsN,
    /* NKHT 124*/   wbkclsPunctSymb,
    /* NBU_ 125*/   wbkclsAlpha,
    /* NBUC 125*/   wbkclsAlpha,
    /* NBUD 125*/   wbkclsAlpha,
    /* NSY_ 126*/   wbkclsAlpha,
    /* NSYP 126*/   wbkclsPunctSymb,
    /* NSYC 126*/   wbkclsAlpha,
    /* NSYW 126*/   wbkclsAlpha,    
    /* NMO_ 127*/   wbkclsAlpha,
    /* NMOC 127*/   wbkclsAlpha,
    /* NMOD 127*/   wbkclsDigitsN,
    /* NMOB 127*/   wbkclsPunctSymb,
    /* NMON 127*/   wbkclsPunctSymb,
    /* NHS_ 128*/   wbkclsAlpha,
    /* WHT_ 129*/   wbkclsAlpha,
    /* LS__ 130*/   wbkclsAlpha,
    /* XNW_ 131*/   wbkclsPunctSymb,
    /* XNWA 131*/   wbkclsPunctSymb,
};

#define PACKEDWORDBREAKLENGTH 3
enum
{
    WORDBREAK_DEFAULT   = 0x1,
    WORDBREAK_KOREAN    = 0x2,
    WORDBREAK_PROOF     = 0x4,
};

#ifndef _MAC
struct PACKEDWORDBREAKBITS
{
    LONGLONG i1 :3;
    LONGLONG i2 :3;
    LONGLONG i3 :3;
    LONGLONG i4 :3;
    LONGLONG i5 :3;
    LONGLONG i6 :3;
    LONGLONG i7 :3;
    LONGLONG i8 :3;
    LONGLONG i9 :3;
    LONGLONG i10:3;
    LONGLONG i11:3;
    LONGLONG i12:3;
    LONGLONG i13:3;
    LONGLONG i14:3;
    LONGLONG i15:3;
    LONGLONG i16:3;
    LONGLONG i17:3;
    LONGLONG i18:3;
};
#endif //_MAC
  
// Note the indices (enum wbkcls) really are 0-base, but the comments are
// written to reflect the spec, which is 1 based.
const BYTE aWordBreakBits[wbkclsLim][wbkclsLim] =
{
   // 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
    { 0, 7, 7, 7, 3, 7, 7, 0, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 1  PunctSymb 
    { 7, 0, 0, 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7 }, // 2  KanaFollow
    { 7, 0, 0, 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7 }, // 3  KatakanaW 
    { 7, 0, 7, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7 }, // 4  Hiragana  
    { 3, 7, 7, 7, 3, 7, 7, 7, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 5  Tab       
    { 7, 0, 0, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7 }, // 6  KanaDelim 
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7 }, // 7  Prefix    
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 8  Postfix
    { 7, 7, 7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 9  SpaceA    
    { 3, 7, 7, 7, 7, 7, 7, 3, 7, 0, 7, 0, 0, 0, 7, 7, 7, 7 }, // 10 Alpha     
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 7, 7, 0, 7, 7, 1, 7 }, // 11 IdeoW     
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7 }, // 12 SuperSub  
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 0, 0, 0, 7, 7, 7, 7 }, // 13 DigitsN   
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 0, 7, 0, 0, 0, 0, 7, 0, 0 }, // 14 PunctInText
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 0, 7, 0, 0, 7, 0, 0 }, // 15 DigitsW   
    { 7, 0, 7, 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7 }, // 16 KatakanaN 
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 0, 7, 0, 0, 7, 0, 7 }, // 17 Hangul    
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 0, 7, 0, 0, 7, 7, 0 }, // 18 LatinW    
};

#if 0
const BYTE aWordBreakBits[wbkclsLim][wbkclsLim] =
{
   //18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1    // After/Before
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 0, 7, 7, 3, 7, 7, 7, 0 }, // 1  PunctSymb
    { 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7, 0, 0, 7 }, // 2  KanaFollow
    { 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7, 0, 0, 7 }, // 3  KatakanaW
    { 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 0, 7, 0, 7 }, // 4  Hiragana
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 3, 7, 7, 7, 3 }, // 5  Tab
    { 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 0, 0, 7 }, // 6  KanaDelim
    { 7, 7, 7, 0, 7, 0, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 7  Prefix
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 8  Postfix
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 7, 7, 7, 7, 7 }, // 9  SpaceA
    { 7, 7, 7, 7, 0, 0, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 7, 3 }, // 10 Alpha
    { 7, 1, 7, 7, 0, 7, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 11 IdeoW
    { 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 12 SuperSub
    { 7, 7, 7, 7, 0, 0, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 13 DigitsN
    { 0, 0, 7, 0, 0, 0, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 14 PunctInText
    { 0, 0, 7, 0, 0, 7, 0, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 15 DigitsW
    { 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7, 7, 0, 7 }, // 16 KatakanaN
    { 7, 0, 7, 0, 0, 7, 0, 1, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 17 Hangul
    { 0, 7, 7, 0, 0, 7, 0, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 18 LatinW
};
#endif // 0
    
    
BOOL
IsWordBreakBoundaryDefault( WCHAR chBefore, WCHAR chAfter )
{
    const CHAR_CLASS ccBefore = CharClassFromCh(chBefore);
    const CHAR_CLASS ccAfter  = CharClassFromCh(chAfter);
    const WBKCLS wbkclsBefore = WordBreakClassFromCharClass(ccBefore);
    const WBKCLS wbkclsAfter  = WordBreakClassFromCharClass(ccAfter);

#if 0
    // Find appropriate row
    return ((*(LONGLONG *)(aWordBreakBits+wbkclsBefore)) >> 
                // Shift over to appropriate column
                ( wbkclsAfter * PACKEDWORDBREAKLENGTH ) & 
                    // Mask off the correct level
                    ( IsKoreanSelectionMode() ? WORDBREAK_KOREAN : WORDBREAK_DEFAULT ) );
#endif // 0
    return ( aWordBreakBits[wbkclsBefore][wbkclsAfter] & 
        ( IsKoreanSelectionMode() ? WORDBREAK_KOREAN : WORDBREAK_DEFAULT ) );
}

BOOL
IsProofWordBreakBoundary( WCHAR chBefore, WCHAR chAfter )
{
    const CHAR_CLASS ccBefore   = CharClassFromCh( chBefore );
    const CHAR_CLASS ccAfter    = CharClassFromCh( chAfter );
    const WBKCLS wbkclsBefore   = WordBreakClassFromCharClass( ccBefore );
    const WBKCLS wbkclsAfter    = WordBreakClassFromCharClass( ccAfter );

#if 0
    return ((*(DWORD *)( aWordBreakBits+wbkclsBefore )) >>
                ( wbkclsAfter * PACKEDWORDBREAKLENGTH ) & WORDBREAK_PROOF );
#endif 0
    return ( aWordBreakBits[wbkclsBefore][wbkclsAfter] & WORDBREAK_PROOF );    
}

//+----------------------------------------------------------------------------
//
//  Function:   WordBreakClassFromCharClass
//
//  Synopsis:   Given a character class, this function returns the proper
//              word breaking class.
//
//-----------------------------------------------------------------------------

WBKCLS
WordBreakClassFromCharClass(CHAR_CLASS cc)
{
    Assert(cc >=0 && cc < CHAR_CLASS_MAX);

    return awbkclsWordBreakClassFromCharClass[cc];
}

//+----------------------------------------------------------------------------
//
//  Function:   IsURLBreak
//
//  Synopsis:   Given a character, find out if URL should break at this point
//
//-----------------------------------------------------------------------------
BOOL
IsURLBreak(WCHAR wch)
{
    if (IsValidWideChar(wch))
    {
        WBKCLS  wbkcls = WordBreakClassFromCharClass(CharClassFromCh(wch));

        if (wbkcls == wbkclsSpaceA)
            return TRUE;

        //
        // See RAID bug 1242 -- MSKK does not want CJK in URLs. 
        // so we break at CJK except for Hangul.  This should
        // be changed in the future to consider Kinsoku as 
        // well. Also, we should indeed include CJK in URLs
        // however limit the number of characters  as Office does. 
        //
        if (wch >= 0x03000 && wbkcls != wbkclsHangul)
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\textxfrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       textxfrm.cxx
//
//  Contents:   CSS Text Transformation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_H_
#define X_STYLE_H_
#include <style.h>
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X_UNIWBK_H_
#define X_UNIWBK_H_
#include "uniwbk.h"
#endif

#define CHARCAST(ch) (LPTSTR)(DWORD_PTR)(WORD)(ch)

//+----------------------------------------------------------------------------
//
// Function:    TransformText
//
// Synopsis:    CSS Attribute TextTransform.  Takes an input string and
//              performs capitalization based on bTextTransform, as
//              was specified in the style.
//
//    Note:     Will assert unless a transform is needed.  (This is for
//              optimization.)
//
//-----------------------------------------------------------------------------

const TCHAR *
TransformText(
    CStr &str,
    const TCHAR * pch,
    LONG cchIn,
    BYTE bTextTransform,
    TCHAR chPrev )
{
    HRESULT hr = S_OK;
    const TCHAR * pchRet = pch;

    Assert(pch);

    // Don't call it unless you need a transform done.
    Assert( (bTextTransform != styleTextTransformNotSet) && (bTextTransform != styleTextTransformNone) );

    if (cchIn > 0)
    {
        hr = str.Set(pch, cchIn);
        if (hr)
            goto Cleanup;

        switch (bTextTransform)
        {
        case styleTextTransformLowercase:
            CharLower(str);
            break;

        case styleTextTransformUppercase:
            CharUpper(str);
            break;

        case styleTextTransformCapitalize:
            {
                TCHAR *pszChar = str;
                while (*pszChar)
                {
                    if (IsWordBreakBoundaryDefault(chPrev, *pszChar))
                        *pszChar = (TCHAR)CharUpper(CHARCAST(*pszChar));

                    chPrev = *pszChar;
                    pszChar++;
                }
            }
            break;

        default:
            Assert(FALSE);
            break;
        }

        pchRet = str;
    }

Cleanup:
    return pchRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\uniprop.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module UNIPROP.CXX -- Miscellaneous Unicode partition properties
 *
 *
 *  Owner: <nl>
 *      Michael Jochimsen <nl>
 *
 *  History: <nl>
 *      11/30/98     mikejoch created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__UNIPROP_H_
#define X__UNIPROP_H_
#include "uniprop.h"
#endif

const UNIPROP s_aPropBitsFromCharClass[CHAR_CLASS_MAX] =
{
    // CC               fNeedsGlyphing  fCombiningMark  fZeroWidth  fWhiteBetweenWords  fMoveByCluster
    /* WOB_   1*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOPP   2*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOPA   2*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOPW   2*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HOP_   3*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOP_   4*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOP5   5*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOQW   6*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AOQW   7*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOQ_   8*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCB_   9*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCPP  10*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCPA  10*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCPW  10*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HCP_  11*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCP_  12*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCP5  13*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCQW  14*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ACQW  15*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCQ_  16*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ARQW  17*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCSA  18*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HCO_  19*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WC__  20*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCS_  20*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WC5_  21*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WC5S  21*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKS_  22*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKSM  23*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WIM_  24*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSSW  25*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WSS_  26*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WHIM  27*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKIM  28*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKSL  29*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKS_  30*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKSC  30*/   {   FALSE,          TRUE,           TRUE,       TRUE,               FALSE,  },
    /* WHS_  31*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQFP  32*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQFA  32*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WQE_  33*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WQE5  34*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKCC  35*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKC_  36*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCP  37*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCA  37*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCW  37*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOC_  38*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOCS  38*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOC5  39*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOC6  39*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AHPW  40*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEP  41*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPAR  41*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HPE_  42*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPE_  43*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPES  43*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPE5  44*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NISW  45*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AISW  46*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQCS  47*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQCW  47*/   {   FALSE,          FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NQCC  47*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NPTA  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPNA  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEW  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEH  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEV  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* APNW  49*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HPEW  50*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPR_  51*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQEP  52*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQEW  52*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQNW  52*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AQEW  53*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AQNW  53*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AQLW  53*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WQO_  54*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSBL  55*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WSP_  56*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WHI_  57*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKA_  58*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKA_  59*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASNW  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASEW  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASRN  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASEN  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ALA_  61*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AGR_  62*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ACY_  63*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WID_  64*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPUA  65*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHG_  66*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WHG_  67*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCI_  68*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOI_  69*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOI_  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOIC  70*/   {   FALSE,          TRUE,           TRUE,       TRUE,               FALSE,  },
    /* WOIL  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOIS  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOIT  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSEN  71*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSET  71*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSNW  71*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASAN  72*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASAE  72*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NDEA  73*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WD__  74*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLLA  75*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WLA_  76*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NWBL  77*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NWZW  77*/   {   FALSE,          FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPLW  78*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPZW  78*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPF_  78*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPFL  78*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPNW  78*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* APLW  79*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* APCO  79*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* ASYW  80*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHYP  81*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHYW  81*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AHYW  82*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAPA  83*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQMP  84*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSLS  85*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSF_  86*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSBS  86*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSBB  86*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLA_  87*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLQ_  88*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLQN  88*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLQC  88*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ALQ_  89*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ALQN  89*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGR_  90*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGRN  90*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGQ_  91*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGQN  91*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCY_  92*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCYP  93*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCYC  93*/   {   FALSE,          TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NAR_  94*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAQL  95*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAQN  95*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHB_  96*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHBC  96*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NHBW  96*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHBR  96*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NASR  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAAR  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAAC  97*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NAAD  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAED  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NANW  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAEW  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAAS  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHI_  98*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NHIN  98*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NHIC  98*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NHID  98*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBE_  99*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NBEC  99*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NBED  99*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBET  99*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGM_ 100*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NGMC 100*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NGMD 100*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGJ_ 101*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NGJC 101*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NGJD 101*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOR_ 102*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NORC 102*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NORD 102*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTA_ 103*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NTAC 103*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NTAD 103*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTE_ 104*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NTEC 104*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NTED 104*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKD_ 105*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NKDC 105*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NKDD 105*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NMA_ 106*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NMAC 106*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NMAD 106*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTH_ 107*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   },
    /* NTHC 107*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   },
    /* NTHD 107*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  },
    /* NTHT 107*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   },
    /* NLO_ 108*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   },
    /* NLOC 108*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   },
    /* NLOD 108*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  },
    /* NTI_ 109*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NTIC 109*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NTID 109*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTIN 109*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGE_ 110*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGEQ 111*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBO_ 112*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBSP 113*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBSS 113*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOF_ 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOBS 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOEA 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NONA 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NONP 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOEP 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NONW 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOEW 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOLW 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCO 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOSP 114*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NOEN 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOBN 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NET_ 115*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ethiopic
    /* NETP 115*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ethiopic
    /* NETD 115*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ethiopic
    /* NCA_ 116*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Canadian Syllabics
    /* NCH_ 117*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Cherokee
    /* WYI_ 118*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Yi
    /* WYIN 118*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Yi
    /* NBR_ 119*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NRU_ 120*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOG_ 121*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ogham
    /* NOGS 121*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ogham
    /* NOGN 121*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ogham
    /* NSI_ 122*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, // Check on Sinhala
    /* NSIC 122*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, // Check on Sinhala
    /* NTN_ 123*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, // Check on Thaana
    /* NTNC 123*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, // Check on Thaana
    /* NKH_ 124*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   }, // Check on Khmer
    /* NKHC 124*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   }, // Check on Khmer
    /* NKHD 124*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  }, // Check on Khmer
    /* NKHT 124*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  }, // Check on Khmer
    /* NBU_ 125*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   }, // Check on Burmese/Myanmar
    /* NBUC 125*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   }, // Check on Burmese/Myanmar
    /* NBUD 125*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   }, // Check on Burmese/Myanmar
    /* NSY_ 126*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, 
    /* NSYP 126*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, 
    /* NSYC 126*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, 
    /* NSYW 126*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, 
    /* NMO_ 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, // Check on Mongolian
    /* NMOC 127*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, // Check on Mongolian
    /* NMOD 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Mongolian
    /* NMOB 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Mongolian
    /* NMON 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Mongolian
    /* NHS_ 128*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // High Surrogate
    /* WHT_ 129*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // High Surrogate
    /* LS__ 130*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Low Surrogate
    /* XNW_ 131*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* XNWA 131*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\util\xmlns.cxx ===
//+---------------------------------------------------------------------
//
//  File:       xmlns.cxx
//
//  Classes:    CXmlNamespaceTable, CXmlUrnAtomTable
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(XML,                                  Mem,                "XML");
MtDefine(CXmlNamespaceTable,                   XML,                "CXmlNamespaceTable");
MtDefine(CXmlUrnAtomTable,                     XML,                "CXmlUrnAtomTable");

MtDefine(CXmlNamespaceTable_CItemsArray,       CXmlNamespaceTable, "CXmlNamespaceTable::CItemsArray");

EXTERN_C const GUID SID_SXmlNamespaceMapping;
EXTERN_C const GUID CGID_XmlNamespaceMapping;
#define XMLNAMESPACEMAPPING_GETURN 1

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CXmlNamespaceTable::CItem
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::CItem::Clear
//
//-------------------------------------------------------------------------

void
CXmlNamespaceTable::CItem::Clear()
{
    _cstr.Free();
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CXmlNamespaceTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable constructor
//
//-------------------------------------------------------------------------

CXmlNamespaceTable::CXmlNamespaceTable (CDoc * pDoc)
{
    _ulRefs = 1;
    _pDoc = pDoc;
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable destructor
//
//-------------------------------------------------------------------------

CXmlNamespaceTable::~CXmlNamespaceTable ()
{
    int     c;
    CItem * pItem;

    for (pItem = _aryItems, c = _aryItems.Size(); 0 < c; pItem++, c--)
    {
        pItem->Clear();
    }
    _aryItems.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::QueryInterface(REFIID iid, void** ppv)
{
    if (!ppv)
        RRETURN(E_POINTER);

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IOleCommandTarget)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::Init
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::Init()
{
    HRESULT     hr;

    hr = THR(RegisterNamespace(COMPONENT_NAMESPACE, COMPONENT_URN, XMLNAMESPACETYPE_ATTR));
    if (hr)
        goto Cleanup;

    _urnAtomComponent = 0;

#if DBG == 1
    LPTSTR pchUrnComponent;
    Assert (_pDoc->_pXmlUrnAtomTable);
    Assert (S_OK == THR(_pDoc->_pXmlUrnAtomTable->GetUrn(_urnAtomComponent, &pchUrnComponent)));
    Assert (0 == StrCmp(COMPONENT_URN, pchUrnComponent));
#endif

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::FindItem
//
//-------------------------------------------------------------------------

CXmlNamespaceTable::CItem *
CXmlNamespaceTable::FindItem(LPTSTR pch)
{
    int         c;
    CItem *     pItem;

    // check cached value
    if (_pLastItem)
    {
        if (0 == StrCmpIC(_pLastItem->_cstr, pch))
            return _pLastItem;
    }

    // do the search
    for (pItem = _aryItems, c = _aryItems.Size(); 0 < c; pItem++, c--)
    {
        Assert (!pItem->_cstr.IsNull());
        if (pItem != _pLastItem && 0 == StrCmpIC(pItem->_cstr, pch))
        {
            // succeeded
            _pLastItem = pItem;
            return pItem;
        }
    }

    // failed
    _pLastItem = NULL;
    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::EnsureItem
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::EnsureItem(LPTSTR pch, CItem ** ppItem, BOOL * pfNew)
{
    HRESULT     hr = S_OK;

    (*ppItem) = FindItem(pch);

    if (!(*ppItem))
    {
        (*ppItem) = _aryItems.Append();
        if (!(*ppItem))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        (*ppItem)->_atom = -1;
        (*ppItem)->_type = XMLNAMESPACETYPE_NULL;

        hr = THR((*ppItem)->_cstr.Set(pch));
        if (hr)
            goto Cleanup;

        if (pfNew)
        {
            *pfNew = TRUE;
        }
    }
    else
    {
        if (pfNew)
        {
            *pfNew = FALSE;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::RegisterNamespace
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::RegisterNamespace(
    LPTSTR pchNamespace, LPTSTR pchUrn, XMLNAMESPACETYPE namespaceType, BOOL * pfChangeDetected)
{
    HRESULT             hr;
    CItem *             pItem;
    CXmlUrnAtomTable *  pUrnAtomTable;

    //
    // startup
    //

    Assert (pchNamespace && pchNamespace[0]);   // namespace should be present and non-empty

    if (pchUrn && 0 == pchUrn[0])               // don't allow empty urns
        pchUrn = NULL;

    //
    // ensure table and item in the table
    //

    hr = THR(_pDoc->EnsureXmlUrnAtomTable(&pUrnAtomTable));
    if (hr)
        goto Cleanup;

    hr = THR(EnsureItem(pchNamespace, &pItem, /* pfNew = */pfChangeDetected));
    if (hr)
        goto Cleanup;

    pItem->_type = namespaceType;

    //
    // setup urn
    //

    if (pchUrn)
    {
        LPTSTR  pchCurrentUrn;

        if (-1 != pItem->_atom)         // if currently the namespace maps to a urn
        {
            hr = THR(pUrnAtomTable->GetUrn(pItem->_atom, &pchCurrentUrn));
            if (hr)
                goto Cleanup;

            if (0 == StrCmpIC(pchUrn, pchCurrentUrn))   // if the urn this namespace currently maps to is the same as requested
                goto Cleanup;                           // done - nothing more todo
        }

        // Assert (pchUrn is different from urn specified in pItem);

        hr = THR(pUrnAtomTable->EnsureUrnAtom(pchUrn, &pItem->_atom));
        if (hr)
            goto Cleanup;

        if (pfChangeDetected)
        {
            *pfChangeDetected = TRUE;
        }
    }


Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::IsXmlSprinkle
//
//-------------------------------------------------------------------------

ELEMENT_TAG
CXmlNamespaceTable::IsXmlSprinkle (LPTSTR pchNamespace)
{
    CItem * pItem = FindItem(pchNamespace);

    if (pItem)
    {
        if (pItem->_atom == _urnAtomComponent)
        {
            return ETAG_GENERIC_BUILTIN;
        }
        else
        {
            return ETAG_GENERIC;
        }
    }

    return ETAG_UNKNOWN;
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::GetUrnAtom
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::GetUrnAtom(LPTSTR pchNamespace, LONG * pAtom)
{
    CItem *     pItem = FindItem(pchNamespace);

    Assert (pAtom);

    *pAtom = pItem ? pItem->_atom : -1;

    RRETURN (S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::GetUrn
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::GetUrn(LONG urnAtom, LPTSTR * ppchUrn)
{
    HRESULT     hr = S_OK;

    Assert (ppchUrn);

    if (-1 != urnAtom)
    {
        Assert (_pDoc->_pXmlUrnAtomTable);      // should have been ensured when we stored urnAtom

        hr = THR(_pDoc->_pXmlUrnAtomTable->GetUrn(urnAtom, ppchUrn));
    }
    else
    {
        *ppchUrn = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::GetUrn
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::GetUrn(LPTSTR pchNamespace, LPTSTR * ppchUrn)
{
    HRESULT     hr;
    LONG        urnAtom;

    hr = GetUrnAtom(pchNamespace, &urnAtom);
    if (hr)
        goto Cleanup;

    hr = THR(GetUrn(urnAtom, ppchUrn));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::SaveNamespaceAttrs
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::SaveNamespaceAttrs (CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT     hr = S_OK;
    int         c;
    CItem *     pItem;
    LPTSTR      pchUrn;

    for (pItem = _aryItems, c = _aryItems.Size(); 0 < c; pItem++, c--)
    {
        if (XMLNAMESPACETYPE_ATTR == pItem->_type)
        {
            if (_urnAtomComponent == pItem->_atom &&
                0 == StrCmpIC(COMPONENT_NAMESPACE, pItem->_cstr))
                continue;

            if (-1 != pItem->_atom)
            {
                Assert (_pDoc->_pXmlUrnAtomTable);

                hr = THR(_pDoc->_pXmlUrnAtomTable->GetUrn (pItem->_atom, &pchUrn));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                pchUrn = NULL;
            }

            hr = THR(pStreamWriteBuff->EnsurePIsSaved(
                _pDoc, NULL, pItem->_cstr, pchUrn, NULL, XMLNAMESPACEDECL_STD));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::Exec
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANT *       pvarArgIn,
    VARIANT *       pvarArgOut)
{
    HRESULT     hr;

    if (!pguidCmdGroup)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsEqualGUID(CGID_XmlNamespaceMapping, *pguidCmdGroup))
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case XMLNAMESPACEMAPPING_GETURN:

            if (!pvarArgOut ||                                              // if no out arg or
                !pvarArgIn ||                                               // no in arg or
                VT_BSTR != V_VT(pvarArgIn) ||                               // in arg is not a string or
                !V_BSTR(pvarArgIn) || 0 == ((LPTSTR)V_BSTR(pvarArgIn))[0])  // the string is empty
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            {
                LPTSTR  pchUrn;

                hr = THR(GetUrn(V_BSTR(pvarArgIn), &pchUrn));
                if (hr)
                    goto Cleanup;

                V_VT  (pvarArgOut) = VT_BSTR;
                if (pchUrn)
                {
                    hr = THR(FormsAllocString(pchUrn, &V_BSTR(pvarArgOut)));
                }
                else
                {
                    V_BSTR(pvarArgOut) = NULL;
                    hr = S_OK;
                }
            }

            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CXmlUrnAtomTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CXmlUrnAtomTable constructor
//
//-------------------------------------------------------------------------

CXmlUrnAtomTable::CXmlUrnAtomTable ()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlUrnAtomTable destructor
//
//-------------------------------------------------------------------------

CXmlUrnAtomTable::~CXmlUrnAtomTable ()
{
    Free();
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlUrnAtomTable::EnsureUrnAtom
//
//-------------------------------------------------------------------------

HRESULT
CXmlUrnAtomTable::EnsureUrnAtom(LPTSTR pchUrn, LONG * pAtom)
{
    HRESULT     hr;

    Assert (pAtom);

    hr = THR(AddNameToAtomTable(pchUrn, pAtom));

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\view\adorner.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Adorner.HXX
//
// Contents:    Implementation of CAdorner class
//
//  An Adorner provides the addition of  'non-content-based' nodes in the display tree
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef _X_ADORNER_HXX_
#define _X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

DeclareTagOther(tagAdornerShow,    "AdornerShow",    "Fill adorners with a hatched brush")
DeclareTag(tagFocusAdornerChange, "AdornerChange", "Trace focus adorner changes")

MtDefine(CElementAdorner, Layout, "CElementAdorner")
MtDefine(CFocusAdorner,   Layout, "CFocusAdorner")

const int GRAB_INSET = 4;

//+====================================================================================
//
//  Member:     CAdorner, ~CAdorner
//
//  Synopsis:   Constructor/desctructor for CAdorner
//
//  Arguments:  pView    - Associated CView
//              pElement - Associated CElement
//
//------------------------------------------------------------------------------------

CAdorner::CAdorner( CView * pView, CElement * pElement )
{
    Assert( pView );

    _cRefs     = 1;
    _pView     = pView;
    _pDispNode = NULL;
    _pElement  = pElement && pElement->HasMasterPtr()
                    ? pElement->GetMasterPtr()
                    : pElement;

    Assert( !_pElement
        ||  _pElement->IsInMarkup() );
}

CAdorner::~CAdorner()
{
    Assert( !_cRefs );
    DestroyDispNode();
}


//+====================================================================================
//
// Method:EnsureDispNode
//
// Synopsis: Creates a display leaf node suitable for 'Adornment'
//
//------------------------------------------------------------------------------------

VOID
CAdorner::EnsureDispNode()
{
    Assert( _pElement );
    Assert( _pView );
    Assert( _pView->IsInState(CView::VS_OPEN) );

    CTreeNode* pTreeNode = _pElement->GetFirstBranch();

    if ( !_pDispNode && pTreeNode)
    {
        _pDispNode = (CDispNode *)CDispLeafNode::New(this, DISPEX_EXTRACOOKIE | DISPEX_USERTRANSFORM);

        if ( _pDispNode )
        {
            _pDispNode->SetExtraCookie( GetDispCookie() );
            _pDispNode->SetLayerType( GetDispLayer() );
            _pDispNode->SetOwned(TRUE);
        }
    }

    if (    _pDispNode
        &&  !_pDispNode->HasParent() )
    {
        CNotification   nf;

        nf.ElementAddAdorner( _pElement );
        nf.SetData((void *)this);

        _pElement->SendNotification( &nf );
    }
}


//+====================================================================================
//
// Method:GetBounds
//
// Synopsis: Return the bounds of the adorner in global coordinates
//
//------------------------------------------------------------------------------------

void
CAdorner::GetBounds(
    CRect * prc) const
{
    Assert( prc );

    if ( _pDispNode )
    {
        _pDispNode->GetClientRect( prc, CLIENTRECT_CONTENT );
        _pDispNode->TransformRect( *prc, COORDSYS_FLOWCONTENT, prc, COORDSYS_GLOBAL );
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+====================================================================================
//
// Method:  GetRange
//
// Synopsis: Retrieve the cp range associated with an adorner
//
//------------------------------------------------------------------------------------

void
CAdorner::GetRange(
    long *  pcpStart,
    long *  pcpEnd) const
{
    Assert( pcpStart );
    Assert( pcpEnd );

    if ( _pElement && _pElement->GetFirstBranch() )
    {
        long    cch;

        _pElement->GetRange( pcpStart, &cch );

        *pcpEnd = *pcpStart + cch;
    }
    else
    {
        *pcpStart =
        *pcpEnd   = 0;
    }
}


//+====================================================================================
//
// Method:  All CDispClient overrides
//
//------------------------------------------------------------------------------------

void
CAdorner::GetOwner(
    CDispNode const* pDispNode,
    void ** ppv)
{
    Assert(pDispNode);
    Assert(ppv);
    *ppv = NULL;
}

void
CAdorner::DrawClient(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         cookie,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

void
CAdorner::DrawClientBackground(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

void
CAdorner::DrawClientBorder(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

void
CAdorner::DrawClientScrollbar(
    int whichScrollbar,
    const RECT* prcBounds,
    const RECT* prcRedraw,
    LONG contentSize,
    LONG containerSize,
    LONG scrollAmount,
    CDispSurface *pSurface,
    CDispNode *pDispNode,
    void *pClientData,
    DWORD dwFlags)
{
    AssertSz(0, "Unexpected/Unimplemented method called in CAdorner");
}

void
CAdorner::DrawClientScrollbarFiller(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

BOOL
CAdorner::HitTestContent(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData,
    BOOL fDeclinedByPeer)
{
    return FALSE;
}

BOOL
CAdorner::HitTestFuzzy(
    const POINT *pptHitInBoxCoords,
    CDispNode *pDispNode,
    void *pClientData)
{
    return FALSE;
}

BOOL
CAdorner::HitTestScrollbar(
    int whichScrollbar,
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
    return FALSE;
}

BOOL
CAdorner::HitTestScrollbarFiller(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
    return FALSE;
}

BOOL
CAdorner::HitTestBorder(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
    return FALSE;
}

LONG
CAdorner::GetZOrderForSelf(CDispNode const* pDispNode)
{
    return 0;
}

LONG
CAdorner::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    Assert(pDispNode1);
    Assert(pDispNode2);
    Assert(pDispNode1 == _pDispNode);
    Assert(_pElement);

    //
    // Try to compare the 2 disp nodes - by asking the view
    //
    long result = _pView->CompareZOrder( pDispNode1, pDispNode2);
    if ( result != 0 )
        return result;

    //
    // TODO - comparison of elements is fairly meaningless 
    // Long term fix is to make Adorner Z-Index controllable by external interface
    // 
    
    CElement *  pElement = ::GetDispNodeElement(pDispNode2);

    //
    //  Compare element z-order
    //  If the same element is associated with both display nodes,
    //  then the second display node is probably the element itself
    //

    return _pElement != pElement
                ? _pElement->CompareZOrder(pElement)
                : 1;
}

void
CAdorner::HandleViewChange(
    DWORD flags,
    const RECT* prcClient,  // global coordinates
    const RECT* prcClip,    // global coordinates
    CDispNode* pDispNode)
{
    AssertSz(0, "Unexpected/Unimplemented method called in CAdorner");
}

BOOL
CAdorner::ProcessDisplayTreeTraversal(
                        void *pClientData)
{
    return TRUE;
}

void
CAdorner::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

DWORD
CAdorner::GetClientPainterInfo( CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    return 0;
}

void
CAdorner::DrawClientLayers(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

#if DBG==1
void
CAdorner::DumpDebugInfo(
    HANDLE hFile,
    long level,
    long childNumber,
    CDispNode const* pDispNode,
    void* cookie)
{
    WriteHelp(hFile, _T("<<tag>Adorner on <0s><</tag>\r\n"),
            GetElement()
                ? GetElement()->TagName()
                : _T("Range"));
}
#endif

//+====================================================================================
//
//  Member:     DestroyDispNode
//
//  Synopsis:   Destroy the adorner display node (if any)
//
//------------------------------------------------------------------------------------

void
CAdorner::DestroyDispNode()
{
    if ( _pDispNode )
    {
        Assert( _pView );
        Assert( _pView->IsInState(CView::VS_OPEN) );    
        _pDispNode->Destroy();
        _pDispNode = NULL;
    }
}


#if DBG==1
//+====================================================================================
//
//  Member:     ShowRectangle
//
//  Synopsis:   Fill the adorner rectangle with a hatched brush
//
//  Arguments:  pDI - Pointer to CFormDrawInfo to use
//
//------------------------------------------------------------------------------------

void
CAdorner::ShowRectangle(
    CFormDrawInfo * pDI)
{
    static COLORREF s_aclr[] =  {
                                RGB( 255,   0,   0 ),
                                RGB(   0, 255,   0 ),
                                RGB( 255, 255,   0 ),
                                RGB(   0, 255, 255 ),
                                };

    if ( IsTagEnabled( tagAdornerShow ) )
    {
        XHDC    hdc    = pDI->GetDC();
        int     bkMode = ::SetBkMode( hdc, TRANSPARENT );
        HBRUSH  hbrPat = ::CreateHatchBrush( HS_DIAGCROSS, s_aclr[ (((ULONG)(ULONG_PTR)this) >> 8) & 0x00000003 ] );
        HBRUSH  hbrOld;

        hbrOld = (HBRUSH) SelectObject( hdc, hbrPat );
        ::PatBlt( hdc, pDI->_rc.left, pDI->_rc.top, pDI->_rc.Width(), pDI->_rc.Height(), PATCOPY );
        ::DeleteObject( ::SelectObject( hdc, hbrOld ) );
        ::SetBkMode( hdc, bkMode );
    }
}
#endif


//+====================================================================================
//
//  Member:     CElementAdorner, ~CElementAdorner
//
//  Synopsis:   Constructor/desctructor for CElementAdorner
//
//  Arguments:  pView    - Associated CView
//              pElement - Associated CElement
//
//------------------------------------------------------------------------------------

CElementAdorner::CElementAdorner( CView* pView, CElement* pElement )
    : CAdorner( pView, pElement )
{
    Assert( pView );
    Assert( pElement );
}

CElementAdorner::~CElementAdorner()
{
    SetSite( NULL );
}

//+====================================================================================
//
// Method: PositionChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CElementAdorner::PositionChanged( const CSize * psize )
{
    Assert( _pView->IsInState(CView::VS_OPEN) );

    if ( _pIElementAdorner )
    {
        if ( !psize )
        {
            HRESULT hr = S_OK;
            CPoint ptElemPos;
            POINT ptAdornerPos ;

            CLayout* pLayout = _pElement->GetUpdatedNearestLayout();
            Assert( pLayout );

            pLayout->GetPosition( &ptElemPos, COORDSYS_GLOBAL );

            hr = THR( _pIElementAdorner->GetPosition( (POINT*) & ptElemPos,  & ptAdornerPos ) );

            if ( ! hr )
            {
                EnsureDispNode();

                _pDispNode->TransformPoint(ptAdornerPos, COORDSYS_GLOBAL, &ptElemPos, COORDSYS_PARENT );
                _pDispNode->SetPosition( ptElemPos );
            }
        }
        else
        {
            if ( ! _pDispNode )
            {
                EnsureDispNode();
                Assert( _pDispNode );
            }
            
            CPoint  pt = _pDispNode->GetPosition();

            pt += *psize;

            _pDispNode->SetPosition( pt );
        }

        IGNORE_HR( _pIElementAdorner->OnPositionSet());        
    }
}

//+====================================================================================
//
// Method: ShapeChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CElementAdorner::ShapeChanged()
{
    Assert( _pView->IsInState(CView::VS_OPEN) );

    if ( _pIElementAdorner )
    {
        HRESULT hr = S_OK;

        CLayout* pLayout =  _pElement->GetUpdatedNearestLayout();
        Assert( pLayout );
        CSize elemSize;
        SIZE szAdorner ;

        pLayout->GetApparentSize( &elemSize );

        hr = THR( _pIElementAdorner->GetSize( (SIZE*) &elemSize, & szAdorner ));
        if ( ! hr )
        {
            elemSize.cx = szAdorner.cx;
            elemSize.cy = szAdorner.cy;

            EnsureDispNode();

            _pDispNode->SetSize( elemSize , NULL, TRUE );
        }
    }
}


//+====================================================================================
//
// Method: UpdateAdorner
//
// Synopsis: Brute-force way of updating an adorners position
//
//------------------------------------------------------------------------------------


void 
CElementAdorner::UpdateAdorner()
{
    CNotification   nf;
    long cpStart, cpEnd ;
    
    GetRange( & cpStart, & cpEnd );        
    nf.MeasuredRange(cpStart, cpEnd - cpStart);
    _pView->Notify(&nf); 
}

//+====================================================================================
//
// Method: ScrollIntoView
//
// Synopsis: Scroll the Adorner into view
//
//------------------------------------------------------------------------------------


void 
CElementAdorner::ScrollIntoView()
{
    if ( _pDispNode )
        _pDispNode->ScrollIntoView(SP_MINIMAL, SP_MINIMAL );
}


//+====================================================================================
//
// Method: Draw
//
// Synopsis: Wraps call to IElementAdorner.Draw - to allow adorner
//           to draw.
//
//------------------------------------------------------------------------------------

void
CElementAdorner::DrawClient(
            const RECT *   prcBounds,
            const RECT *   prcRedraw,
            CDispSurface * pDispSurface,
            CDispNode *    pDispNode,
            void *         cookie,
            void *         pClientData,
            DWORD          dwFlags)
{
    if ( _pIElementAdorner )
    {
        Assert(pClientData);

        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds( pDI, prcBounds, prcRedraw, pDispSurface );

        WHEN_DBG( ShowRectangle( pDI ) );

        // TODO (donmarsh) -- this is a temporary hack until MichaelW's checkin
        // implements adorners as behaviors, and this all just goes away.
        CSize sizeTranslate = g_Zero.size;  // keep compiler happy
        HDC hdc = 0;                        // keep compiler happy
        if (pDI->GetDC().GetTranslatedDC(&hdc, &sizeTranslate))
        {
            pDI->_rc.OffsetRect(sizeTranslate);
            IGNORE_HR( _pIElementAdorner->Draw(hdc, (RECT*) & pDI->_rc ));
        }
    }
}


static HTC
AdornerHTIToHTC ( ADORNER_HTI eAdornerHTC )
{
    HTC eHTC = HTC_NO;

    switch( eAdornerHTC )
    {

    case ADORNER_HTI_TOPBORDER :
        eHTC = HTC_TOPBORDER;
        break;

    case ADORNER_HTI_LEFTBORDER:
        eHTC = HTC_LEFTBORDER;
        break;

    case ADORNER_HTI_BOTTOMBORDER:
        eHTC = HTC_LEFTBORDER ;
        break;

    case ADORNER_HTI_RIGHTBORDER :
        eHTC = HTC_RIGHTBORDER;
        break;
        
    case ADORNER_HTI_TOPLEFTHANDLE:
        eHTC = HTC_TOPLEFTHANDLE;
        break;
            
    case ADORNER_HTI_LEFTHANDLE:
        eHTC = HTC_LEFTHANDLE       ;
        break;
    case ADORNER_HTI_TOPHANDLE:
        eHTC = HTC_TOPHANDLE ;
        break;
        
    case ADORNER_HTI_BOTTOMLEFTHANDLE:
        eHTC = HTC_BOTTOMLEFTHANDLE ;
        break;

    case ADORNER_HTI_TOPRIGHTHANDLE:
        eHTC = HTC_TOPRIGHTHANDLE   ;
        break;
        
    case ADORNER_HTI_BOTTOMHANDLE:
        eHTC = HTC_BOTTOMHANDLE ;
        break;
        
    case ADORNER_HTI_RIGHTHANDLE:
        eHTC = HTC_RIGHTHANDLE ;
        break;
        
    case ADORNER_HTI_BOTTOMRIGHTHANDLE:
        eHTC = HTC_BOTTOMRIGHTHANDLE ;
        break;

    }

    return eHTC;
}

//+====================================================================================
//
// Method: HitTestContent
//
// Synopsis: IDispClient - hit test point. Wraps call to IElementAdorner.HitTestPoint
//
//------------------------------------------------------------------------------------

BOOL
CElementAdorner::HitTestContent(
            const POINT *  pptHit,
            CDispNode *    pDispNode,
            void *         pClientData,
            BOOL           fDeclinedByPeer)
{
    BOOL fDidWeHitAdorner = FALSE;
    ADORNER_HTI eAdornerHTI = ADORNER_HTI_NONE;
    
    if (    _pIElementAdorner
        &&  _pElement->IsInMarkup() )
    {
        CRect myRect;
        HRESULT hr = S_OK;

        _pDispNode->GetClientRect( &myRect, CLIENTRECT_CONTENT );

        hr = THR( _pIElementAdorner->HitTestPoint(
                                                    const_cast<POINT*> (pptHit),
                                                    (RECT*) ( const_cast<CRect*> (&myRect)),
                                                    & fDidWeHitAdorner,
                                                    & eAdornerHTI ));
        if (  ( ! hr ) && ( fDidWeHitAdorner ))
        {
            //
            // If we hit the adorner, we fix the node of hit test info to
            // be that of the element we adorn.
            //
            CHitTestInfo *  phti = (CHitTestInfo *)pClientData;
            phti->_htc = AdornerHTIToHTC( eAdornerHTI );
            phti->_pNodeElement = _pElement->GetFirstBranch();
        }
    }

    return fDidWeHitAdorner;
}


//+====================================================================================
//
// Method: GetZOrderForSelf
//
// Synopsis: IDispClient - get z-order.
//
//------------------------------------------------------------------------------------

LONG
CElementAdorner::GetZOrderForSelf(CDispNode const* pDispNode)
{
    return LONG_MAX;
}

//+====================================================================================
//
//  Member:     CFocusAdorner, ~CFocusAdorner
//
//  Synopsis:   Constructor/desctructor for CFocusAdorner
//
//  Arguments:  pView    - Associated CView
//              pElement - Associated CElement
//
//------------------------------------------------------------------------------------

CFocusAdorner::CFocusAdorner( CView* pView )
    : CAdorner( pView )
{
    Assert( pView );
}

CFocusAdorner::~CFocusAdorner()
{
    delete _pShape;
}

//+====================================================================================
//
// Method:  EnsureDispNode
//
// Synopsis: Ensure the display node is created and properly inserted in the display tree
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::EnsureDispNode()
{
    Assert( _pElement );
    if (!_pView->IsInState(CView::VS_OPEN) )
    {
        _pView->OpenView();
    }

    if ( _pShape )
    {
        CTreeNode * pTreeNode = _pElement->GetFirstBranch();

        if ( !_pDispNode && pTreeNode)
        {
            _dnl = _pElement->GetFirstBranch()->IsPositionStatic()
                        ? DISPNODELAYER_FLOW
                        : _pElement->GetFirstBranch()->GetCascadedzIndex() >= 0
                                ? DISPNODELAYER_POSITIVEZ
                                : DISPNODELAYER_NEGATIVEZ;
            _adl = _dnl == DISPNODELAYER_FLOW
                        ? ADL_TOPOFFLOW
                        : ADL_ONELEMENT;
        }

        if (    !_pDispNode
            ||  !_pDispNode->HasParent() )
        {
            super::EnsureDispNode();

            if (_pDispNode)
            {
                _pDispNode->SetAffectsScrollBounds(FALSE);
            }
        }
    }

    else
    {
        DestroyDispNode();
    }
}


//+====================================================================================
//
// Method:  EnsureFocus
//
// Synopsis: Ensure focus display node exists and is properly inserted in the display tree
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::EnsureFocus()
{
    Assert( _pElement );
    if (    _pShape
        &&  (   !_pDispNode
            ||  !_pDispNode->HasParent() ) )
    {
        EnsureDispNode();
    }
}


//+====================================================================================
//
// Method:  SetElement
//
// Synopsis: Set the associated element
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::SetElement( CElement * pElement, long iDivision )
{
    Assert( _pView && _pView->IsInState(CView::VS_OPEN) );
    Assert( pElement );
    Assert( pElement->IsInMarkup() );

    if ( pElement->Tag() == ETAG_INPUT
            && DYNCAST(CInput, pElement)->GetType() == htmlInputFile)
    {
        // force shape change
        _pElement = NULL;
    }

    if (    pElement  != _pElement
        ||  iDivision != _iDivision)
    {
        _pElement  = pElement;
        _iDivision = iDivision;

        DestroyDispNode();
        ShapeChanged();
    }

}

//+====================================================================================
//
// Method: PositionChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::PositionChanged( const CSize * psize )
{
    Assert( _pElement );
    Assert( _pElement->GetFirstBranch() );
    Assert( _pView->IsInState(CView::VS_OPEN) );

    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_INDENT, "(CFocusAdorner::PositionChanged() - size(cx:%d cy:%d)", psize ? psize->cx : 0, psize ? psize->cy : 0 ));

    if ( _pDispNode )
    {
        CLayout *   pLayout     = _pElement->GetUpdatedNearestLayout();
        CTreeNode * pTreeNode   = _pElement->GetFirstBranch();
        BOOL        fRelative   = pTreeNode->GetCharFormat()->_fRelative;
        CDispNode * pDispParent = _pDispNode->GetParentNode();
        CDispNode * pDispNode   = NULL;

        Assert  ( _pShape );

        //
        //  Get the display node which contains the element with focus
        //  (If the focus display node is not yet anchored in the display tree, pretend the element
        //   is not correct as well. After the focus display node is anchored, this routine will
        //   get called again and can correctly associate the display nodes at that time.)
        //

        if ( pDispParent )
        {
// TODO: Move this logic down into GetElementDispNode (passing a flag so that GetElementDispNode
//         can distinguish between "find nearest" and "find exact" with this call being a "find nearest"
//         and virtually all others being a "find exact" (brendand)
            CElement *  pDisplayElement = NULL;

            if (    !pTreeNode->IsPositionStatic()
                ||  _pElement->ShouldHaveLayout() )
            {
                pDisplayElement = _pElement;
            }
            else if ( !fRelative )
            {
                pDisplayElement = pLayout->ElementOwner();
            }
            else
            {
                CTreeNode * pDisplayNode = pTreeNode->GetCurrentRelativeNode( pLayout->ElementOwner() );

                Assert( pDisplayNode );     // This should never be NULL, but be safe anyway
                if ( pDisplayNode )
                {
                    pDisplayElement = pDisplayNode->Element();
                }
            }

            Assert( pDisplayElement );      // This should never be NULL, but be safe anyway
            if ( pDisplayElement )
            {
                pDispNode = pLayout->GetElementDispNode( pDisplayElement );
            }
        }


        //
        //  Verify that the display node which contains the element with focus and the focus display node
        //  are both correctly anchored in the display tree (that is, have a common parent)
        //  (If they do not, this routine will get called again once both get correctly anchored
        //   after layout is completed)
        //

        if ( pDispNode )
        {
            CDispNode * pDispNodeTemp;

            for ( pDispNodeTemp = pDispNode;
                    pDispNodeTemp
                &&  pDispNodeTemp != pDispParent;
                pDispNodeTemp = pDispNodeTemp->GetParentNode() );

            if ( !pDispNodeTemp )
            {
                pDispNode = NULL;
            }

            Assert( !pDispNode
                ||  pDispNodeTemp == pDispParent );
        }

        if ( pDispNode )
        {
            if ( !_fTopLeftValid )
            {
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - _fTopLeftValid NOT valid (currently %d,%d)", _ptTopLeft.x, _ptTopLeft.y ));

                CRect   rc;
    
                _pShape->GetBoundingRect( &rc );
                _ptTopLeft = rc.TopLeft();
                _pShape->OffsetShape( -_ptTopLeft.AsSize() );

                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - offset shape by new topleft" ));
    
                if (    !_pElement->ShouldHaveLayout()
                    &&  fRelative )
                {
                    CPoint  ptOffset;
                    
                    _pElement->GetUpdatedParentLayout()->GetFlowPosition( pDispNode, &ptOffset );
                    _ptTopLeft -= ptOffset.AsSize();
                }
                
                _fTopLeftValid = TRUE;
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - _fTopLeftValid now valid (%d,%d)", _ptTopLeft.x, _ptTopLeft.y ));
            }

            Assert(pDispParent != NULL);
            
            // calculate user transform for adorner.  Get the total
            // transform for the adorned node, and multiply by the
            // inverse of the total transform for the adorner node.
            CDispTransform transform;
            CDispTransform transformAdorner;
            CSize sizeOffset = _ptTopLeft.AsSize();

            // psize is only valid if the element doesn't have layout (bug #105637)
            if ( psize && !_pElement->ShouldHaveLayout() )
            {
                sizeOffset += *psize;
                _ptTopLeft += *psize;
            }

            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - using _fTopLeftValid (%d,%d)", _ptTopLeft.x, _ptTopLeft.y ));

            pDispNode->GetNodeTransform(&transform, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
            pDispParent->GetNodeTransform(&transformAdorner, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);

#if DBG == 1
            if (transform.GetWorldTransform()->IsOffsetOnly())
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorned dispnode 0x%x, transform offset %d,%d", pDispNode, transform.GetWorldTransform()->GetOffsetOnly().cx, transform.GetWorldTransform()->GetOffsetOnly().cy ));
            else
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorned dispnode 0x%x, complex transform", pDispNode ));

            if (transformAdorner.GetWorldTransform()->IsOffsetOnly())
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Parent dn of adorner 0x%x, transform offset %d,%d", pDispParent, transformAdorner.GetWorldTransform()->GetOffsetOnly().cx, transformAdorner.GetWorldTransform()->GetOffsetOnly().cy ));
            else
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Parent dn of adorner 0x%x, complex transform", pDispParent ));

            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorner dn 0x%x, old t:%d, l:%d", _pDispNode, _pDispNode->GetPosition().x, _pDispNode->GetPosition().y ));
#endif

            transform.AddPreOffset( sizeOffset );
            transform.AddPostTransform(transformAdorner);
            _pDispNode->SetUserTransform(&transform);
            _pDispNode->SetPosition(g_Zero.pt);


            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorner dn 0x%x, new t:%d, l:%d", _pDispNode, _pDispNode->GetPosition().x, _pDispNode->GetPosition().y ));
        }

        //
        //  If the display node containing the element with focus is not correctly placed in the display
        //  tree, remove the focus display node as well to prevent artifacts
        //

        else
        {
            _pView->ExtractDispNode(_pDispNode);
        }
    }

    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_OUTDENT, ")CFocusAdorner::PositionChanged())" ));
}

//+====================================================================================
//
// Method: ShapeChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::ShapeChanged()
{
    Assert( _pView->IsInState(CView::VS_OPEN) );
    Assert( _pElement );

    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_INDENT, "(CFocusAdorner::ShapeChanged()" ));

    delete _pShape;
    _pShape = NULL;

    _fTopLeftValid = FALSE;

    CDoc *      pDoc = _pView->Doc();
    CDocInfo    dci(pDoc->_dciRender);
    CShape *    pShape;
    BOOL        fIWasDestroyed = FALSE;

    if (    (_pElement->HasMarkupPtr() && _pElement->GetMarkup()->IsMarkupTrusted())
        &&  (   (_pElement->_etag == ETAG_SPAN && DYNCAST(CSpanElement, _pElement)->GetAAnofocusrect())
             || (_pElement->_etag == ETAG_DIV && DYNCAST(CDivElement, _pElement)->GetAAnofocusrect())))
    {
        pShape = NULL;
    }
    else
    {
        //(dmitryt) IE6/18891. After making OnScroll to fire asyncronously,
        // I've got a crash here. _pElement->GetFocusShape will call get_scrollTop 
        // and other OM, so potentially will destroy/replace the adorner we are in now. 
        // Inserting AddRef/Release and check to avoid crash.
        AddRef();

        _pElement->GetFocusShape( _iDivision, &dci, &pShape );

        fIWasDestroyed = 
            (   !pDoc->GetView()->_pFocusAdorner 
             || pDoc->GetView()->_pFocusAdorner != this);

        Release();
    }

    if(fIWasDestroyed)
    {
        delete pShape;
    }
    else
    {
        if ( pShape )
        {
            CRect       rc;

            pShape->GetBoundingRect( &rc );

            if ( rc.IsEmpty() )
            {
                delete pShape;
            }
            else
            {
                if (_pShape)
                {
                    delete _pShape;
                    _pShape = NULL;
                }

                _pShape = pShape;
            }
        }
        
        EnsureDispNode();

        if ( _pDispNode )
        {
            CRect   rc;

            Assert( _pShape );

            _pShape->GetBoundingRect( &rc );
            _pDispNode->SetSize( rc.Size(), NULL, TRUE );

            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::ShapeChanged() - setting dn 0x%x to size(cx:%d cy:%d)", _pDispNode, rc.right-rc.left, rc.bottom-rc.top ));
        }
    }
    
    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_OUTDENT, ")CFocusAdorner::ShapeChanged()" ));
}

//+====================================================================================
//
// Method: Draw
//
// Synopsis: Wraps call to IElementAdorner.Draw - to allow adorner
//           to draw.
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::DrawClient(
            const RECT *   prcBounds,
            const RECT *   prcRedraw,
            CDispSurface * pDispSurface,
            CDispNode *    pDispNode,
            void *         cookie,
            void *         pClientData,
            DWORD          dwFlags)
{
    Assert( _pElement );
    if (  _pElement &&  !_pElement->IsEditable( TRUE )
        &&  _pView->Doc()->HasFocus()
        &&  !(_pView->Doc()->_wUIState & UISF_HIDEFOCUS))
    {
        Assert(pClientData);

        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds( pDI, prcBounds, prcRedraw, pDispSurface );

        WHEN_DBG( ShowRectangle( pDI ) );

        _pShape->DrawShape( pDI );
    }
}

//+====================================================================================
//
// Method: GetZOrderForSelf
//
// Synopsis: IDispClient - get z-order.
//
//------------------------------------------------------------------------------------

LONG
CFocusAdorner::GetZOrderForSelf(CDispNode const* pDispNode)
{
    Assert( _pElement );
    Assert( !_pElement->GetFirstBranch()->IsPositionStatic() );
    Assert( _dnl != DISPNODELAYER_FLOW );
    return _pElement->GetFirstBranch()->GetCascadedzIndex();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\view\focus.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Adorner.HXX
//
// Contents:    Implementation of CAdorner class
//
//  An Adorner provides the addition of  'non-content-based' nodes in the display tree
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef _X_FOCUS_HXX_
#define _X_FOCUS_HXX_
#include "focus.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifdef FOCUS_BEHAVIOR

MtDefine(CFocusBehavior,  Layout, "CFocusBehavior")

STDMETHODIMP
CFocusBehavior::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementBehavior *)this, IUnknown);
    QI_INHERITS(this, IElementBehavior);
    QI_INHERITS(this, IHTMLPainter);
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        return E_NOINTERFACE;
}

CFocusBehavior::~CFocusBehavior()
{
    if (_pElement)
        SetElement(NULL, 0);

    Assert(_pView->_pFocusBehavior == NULL);

    ClearInterface(&_pBehaviorSite);
    ClearInterface(&_pPaintSite);

    delete _pShape;
    return pElement;
}

STDMETHODIMP
CFocusBehavior::GetPainterInfo(HTML_PAINTER_INFO *pInfo)
{
    pInfo->lFlags = HTMLPAINTER_TRANSPARENT | HTMLPAINTER_HITTEST | HTMLPAINTER_NOSAVEDC;
    pInfo->lZOrder = HTMLPAINT_ZORDER_ABOVE_FLOW;
    SetRect(&pInfo->rcExpand, 0, 0, 0, 0);
    pInfo->iidDrawObject = NULL;

    return S_OK;
}

void
CFocusBehavior::UpdateShape()
{
    // TODO (michaelw) This code was copied from adorneres and doesn't have a hope of actually working
    // Close but no cigar.  This code assumes that we can actually have a rendering behavior on an element
    // that doesn't have a layout.  Ha ha ha ha!
    Assert( _pElement );

    delete _pShape;

    _fDirtyShape = FALSE;

    CDoc *      pDoc = _pView->Doc();
    CDocInfo    dci(pDoc->_dciRender);

    if (    (_pElement->HasMarkupPtr() && _pElement->GetMarkup()->IsMarkupTrusted())
        &&  (   (_pElement->_etag == ETAG_SPAN && DYNCAST(CSpanElement, _pElement)->GetAAnofocusrect())
             || (_pElement->_etag == ETAG_DIV && DYNCAST(CDivElement, _pElement)->GetAAnofocusrect())))
    {
        _pShape = NULL;
    }
    else
    {
        _pElement->GetFocusShape( _iDivision, &dci, &_pShape );

        // Shapes come back in COORDSYS_FLOWCONTENT whilst the behavior is in COORDSYS_CONTENT
        // We need to get the offset and convert

        if (_pShape)
        {
            CLayout *pLayout = _pElement->GetUpdatedLayout();

            Assert(pLayout);

            RECT rcContent;
            RECT rcFlow;

            pLayout->GetClientRect(&rcFlow, COORDSYS_FLOWCONTENT);
            pLayout->GetClientRect(&rcContent, COORDSYS_CONTENT);

            CSize size(_rcBounds.left + rcContent.left - rcFlow.left, _rcBounds.top + rcContent.top - rcFlow.top);

            _pShape->OffsetShape(size);
        }
    }
}

STDMETHODIMP
CFocusBehavior::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    if (_rcBounds != rcBounds)
    {
        _rcBounds = rcBounds;
        UpdateShape();
    }
    else if (_fDirtyShape)
            UpdateShape();

    if (_pShape)
    {
        // TODO (michaelw) This should change to the xhdc passed in via the pvDrawObject (sambent needs to do this)
        XHDC xhdc(hdc, NULL);
        _pShape->Draw(xhdc, 1);
    }

    return S_OK;
}

void
CFocusBehavior::SetElement(CElement *pElement, long iDivision)
{
    if (_pElement)
    {
        if (_pPaintSite)
            _pPaintSite->InvalidateRect(NULL);

        VARIANT_BOOL fResultDontCare;
        _pElement->removeBehavior(_lCookie, &fResultDontCare);
        _lCookie = 0;   // For sambent
        _pElement = 0;
    }

    if (pElement)
    {
        Assert( _pView->IsInState(CView::VS_OPEN) );
        Assert( pElement );
        Assert( pElement->IsInMarkup() );

        if (pElement->HasMasterPtr())
        {
            pElement = pElement->GetMasterPtr();
        }

        // If this element is a checkbox or a radio button, use the associated
        // label element if one exists for drawing the focus shape.
        else if (   pElement->Tag() == ETAG_INPUT
                 && DYNCAST(CInput, pElement)->IsOptionButton())
        {
            CLabelElement * pLabel = pElement->GetLabel();
            if (pLabel)
            {
                pElement = pLabel;
            }
        }

        VARIANT v;

        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = (IUnknown *)(IElementBehavior *)this;

        HRESULT hr = pElement->addBehavior(L"", &v, &_lCookie);

        if (!hr)
        {
            _pElement = pElement;
            _iDivision = iDivision;
            ShapeChanged();
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\view\view.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       view.cxx
//
//  Contents:   CView and related classes
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WRAPDEFS_H_
#define X_WRAPDEFS_H_
#include "wrapdefs.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_HTMLLYT_HXX_
#define X_HTMLLYT_HXX_
#include "htmllyt.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_VIEW_HXX_
#define X_VIEW_HXX_
#include "view.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef _X_ADORNER_HXX_
#define _X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef _X_FOCUS_HXX
#define _X_FOCUS_HXX_
#include "focus.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

#ifndef X_ICADD_H_
#define X_ICADD_H_
typedef LONG NTSTATUS;      // from <ntdef.h> - needed by winsta.h
#include <winsta.h>
#include <icadd.h>
#endif

ExternTag(tagNoOffScr);
ExternTag(tagOscFullsize);
ExternTag(tagOscTinysize);
ExternTag(tagNoTile);
ExternTag(tagLayoutTasks);

DeclareTag(tagView, "View: General trace", "Trace view processing");
DeclareTag(tagViewRender, "View: Render trace", "Trace RenderView processing");
DeclareTag(tagOscForceDDBanding, "Display: Force offscreen",  "Force banding when using DirectDraw")
DeclareTag(tagViewHwndChange, "View", "trace changes to HWNDs");
DeclareTag(tagNoSmoothScroll, "Scroll", "disable smooth scrolling");
DeclareTag(tagViewInvalidate, "View", "invalidation");
DeclareTag(tagFilterFakeSource, "Filter", "Don't render the source disp tree")
DeclareTag(tagFilterPaintScreen, "Filter", "Paint source to the screen in Draw")
DeclareTag(tagLowResPrinter, "Layout: LowRes", "Use low-res virtual printer");
DeclareTag(tagViewTreeOpen, "View", "trace VF_TREEOPEN");

PerfDbgTag(tagCViewEnsure,      "View", "Trace CView::EnsureView")
PerfDbgTag(tagChildWindowOrder, "ChildWindowOrder", "Count child windows reordered")

MtDefine(CView,                  Layout, "CView")
MtDefine(CView_aryTaskMisc_pv,   Layout, "CView::_aryTaskMisc::_pv")
MtDefine(CView_aryTaskLayout_pv, Layout, "CView::_aryTaskLayout::_pv")
MtDefine(CView_aryTaskEvent_pv,  Layout, "CView::_aryTaskEvent::_pv")

MtDefine(CView_arySor_pv,        Layout, "CView::_arySor::_pv")
MtDefine(CView_aryTransition_pv, Layout, "CView::_aryTransition::_pv")
MtDefine(CView_aryWndPos_pv,     Layout, "CView::_aryWndPos::_pv")
MtDefine(CView_aryWndRgn_pv,     Layout, "CView::_aryWndRgn::_pv")
MtDefine(CView__aryClippingOuterHwnd_pv, Layout, "CView::aryClippingOuterHwnd::pv")
MtDefine(CView_aryAdorners_pv,   Layout, "CView::_aryAdorners::_pv")
MtDefine(CViewDispClient,        Layout, "CViewDispClient")
MtDefine(CView_aryHWND_pv,       Layout, "CView::pAryHWND::_pv")

// number of lines in default offscreen buffer
const long  s_cBUFFERLINES = 150;

#if DBG==1
#define MARKRECURSION(grf)  { if (IsLockSet(VL_RENDERINPROGRESS) || !IsLockSet(VL_UPDATEINPROGRESS) || !(grf & LAYOUT_INPAINT)) _fDEBUGRecursion = TRUE; }
#define CHECKRECURSION()    { if (_fDEBUGRecursion) { AssertSz(!_fDEBUGRecursion, "CView::EnsureView was recursively entered from this point"); _fDEBUGRecursion = FALSE; } }
#define CLEARRECURSION()    _fDEBUGRecursion = FALSE
void    DumpRegion(HRGN hrgn);
void    DumpClipRegion(HDC hdc);
void    DumpHDC(HDC hdc);
#else
#define MARKRECURSION(grf)
#define CHECKRECURSION()
#define CLEARRECURSION()
#endif

#define IsRangeCrossRange(a1, a2, b1, b2) (((a2) >= (b1)) && ((a1) <= (b2)))

//+---------------------------------------------------------------------------
//
//  Member:     Getxxxxx
//
//  Synopsis:   Return _pv properly type-casted
//
//----------------------------------------------------------------------------

CElement *
CViewTask::GetElement() const
{
    return DYNCAST(CElement, _pElement);
}

CLayout *
CViewTask::GetLayout() const
{
    return DYNCAST(CLayout, _pLayout);
}

DISPID
CViewTask::GetEventDispID() const
{
    return (DISPID) _dispidEvent;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetSourceIndex
//
//  Synopsis:   Return the source index for the object associated with a task
//
//----------------------------------------------------------------------------

long
CViewTask::GetSourceIndex() const
{
    Assert(_vtt == VTT_LAYOUT);
    return GetLayout()->ElementOwner()->GetSourceIndex();
}


//+---------------------------------------------------------------------------
//
//  Member:     GetOwner
//
//  Synopsis:   Return display node owner
//
//----------------------------------------------------------------------------

void
CViewDispClient::GetOwner(
    CDispNode const* pDispNode,
    void **     ppv)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    Assert(pDispNode);
    Assert(pDispNode == View()->_pDispRoot);
    Assert(ppv);
    *ppv = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClient
//
//  Synopsis:   Draw client content
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClient(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         cookie,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientBackground
//
//  Synopsis:   Draw background
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientBackground(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    Assert(pDispNode);
    Assert(pDispNode == View()->_pDispRoot);
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    View()->RenderBackground(pDI);
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientBorder
//
//  Synopsis:   Draw border
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientBorder(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientScrollbar
//
//  Synopsis:   Draw scrollbar
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientScrollbar(
    int            iDirection,
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    long           contentSize,
    long           containerSize,
    long           scrollAmount,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientScrollbarFiller
//
//  Synopsis:   Draw scrollbar
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientScrollbarFiller(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestScrollbar
//
//  Synopsis:   Hit test the scrollbar
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestScrollbar(
    int            iDirection,
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     HitTestScrollbarFiller
//
//  Synopsis:   Hit test the scrollbar filler
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestScrollbarFiller(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     HitTestContent
//
//  Synopsis:   Hit test the display node
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestContent(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData,
    BOOL           fDeclinedByPeer)
{
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     HitTestFuzzy
//
//  Synopsis:   Hit test the display node
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestFuzzy(
    const POINT *  pptHitInBoxCoords,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestBorder
//
//  Synopsis:   Hit test the display node
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestBorder(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     ProcessDisplayTreeTraversal
//
//  Synopsis:   Process display tree traversal
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::ProcessDisplayTreeTraversal(
    void *         pClientData)
{
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetZOrderForSelf
//
//  Synopsis:   Return z-index
//
//----------------------------------------------------------------------------

LONG
CViewDispClient::GetZOrderForSelf(CDispNode const* pDispNode)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CompareZOrder
//
//  Synopsis:   Compare the z-order of a display node with this display node
//
//----------------------------------------------------------------------------

LONG
CViewDispClient::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to a change in position
//
//----------------------------------------------------------------------------

void
CViewDispClient::HandleViewChange(
    DWORD          flags,
    const RECT *   prcClient,
    const RECT *   prcClip,
    CDispNode *    pDispNode)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     NotifyScrollEvent
//
//  Synopsis:   Respond to a change in scroll position
//
//----------------------------------------------------------------------------

void
CViewDispClient::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClientPainterInfo
//
//  Synopsis:   Return rendering layer information flags
//
//----------------------------------------------------------------------------

DWORD
CViewDispClient::GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientLayers
//
//  Synopsis:   Render a layer
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientLayers(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     GetServiceProvider
//
//  Synopsis:   return the client's service provider (refcounted)
//
//----------------------------------------------------------------------------

IServiceProvider *
CViewDispClient::GetServiceProvider()
{
    IServiceProvider *pSP = NULL;

    IGNORE_HR(Doc()->QueryInterface(IID_IServiceProvider, (void**)&pSP));

    return pSP;
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     DumpDebugInfo
//
//  Synopsis:   Dump debugging information
//
//----------------------------------------------------------------------------

void
CViewDispClient::DumpDebugInfo(
    HANDLE           hFile,
    long             level,
    long             childNumber,
    CDispNode const* pDispNode,
    void *           cookie)
{
    WriteString(hFile, _T("<tag>Active View</tag>\r\n"));
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     Invalidate
//
//  Synopsis:   Forward invalidate to appropriate receiver
//
//  Arguments:  prcInvalid - The invalid rect (if rgnInvalid is NULL)
//              rgnInvalid - The invalid region
//              fSynchronousRedraw  - draw synchronously before returning
//              fInvalChildWindows  - invalidate child windows
//
//----------------------------------------------------------------------------

void
CViewDispClient::Invalidate(
    const CRect*    prcInvalid,
    HRGN            rgnInvalid,
    BOOL            fSynchronousRedraw,
    BOOL            fInvalChildWindows)
{
    if (View()->GetLayoutFlags() & LAYOUT_FORCE)
        fSynchronousRedraw = FALSE;

    if (rgnInvalid)
    {
        View()->Invalidate(rgnInvalid, fSynchronousRedraw, fInvalChildWindows);
    }
    else if (prcInvalid)
    {
        View()->Invalidate(prcInvalid, fSynchronousRedraw, fInvalChildWindows);
    }
    else if (fSynchronousRedraw)
    {
        View()->PostRenderView(TRUE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     ScrollRect
//
//  Synopsis:   Scroll pixels on screen
//
//----------------------------------------------------------------------------

void
CViewDispClient::ScrollRect(
    const CRect& rcgScroll,
    const CSize& sizegScrollDelta,
    CDispScroller* pScroller)
{
    View()->ScrollRect(rcgScroll, sizegScrollDelta, pScroller);
}


//+---------------------------------------------------------------------------
//
//  Member:     OpenViewForRoot
//
//  Synopsis:   Open the view (called only by disp root)
//
//----------------------------------------------------------------------------

void
CViewDispClient::OpenViewForRoot()
{
    View()->OpenView();
}


//+---------------------------------------------------------------------------
//
//  Member:     CView/~CView
//
//  Synopsis:   Constructor/Destructor
//
//----------------------------------------------------------------------------

CView::CView()
{
#ifdef DEADCODE
    _iZoomFactor = 100;
#endif
    ClearRanges();
}

CView::~CView()
{
    delete _pAryHwnd;
    Assert(_pDispRoot == NULL);
    Assert(_aryTaskMisc.Size() == 0);
    Assert(_aryTaskLayout.Size() == 0);
    Assert(_aryTaskEvent.Size() == 0);
    Assert(!HasInvalid());
}


//+---------------------------------------------------------------------------
//
//  Member:     Initialize
//
//  Synopsis:   Initialize the view
//
//  Arguments:  pDoc - Pointer to owning CDoc
//
//----------------------------------------------------------------------------

void
CView::Initialize(
    CDoc *  pDoc,
    SIZEL & szlDefault) // himetric
{
    Assert(pDoc);
    Assert(!_dciDefaultMedia._pDoc);
    Assert(!_pDispRoot);

    // initialize CDocInfo for all resolutions
#if DBG==1
    // allow using different device resolution for debugging purposes
    if (!IsTagEnabled(tagLowResPrinter))
    {
        AssertSz(g_uiVirtual.GetResolution().cx == 16384, "Changing virtual printer to high resolution!");
        g_uiVirtual.SetResolution(16384, 16384);
    }
    else
    {
        AssertSz(g_uiVirtual.GetResolution().cx == 300, "Changing virtual printer to low resolution!");
        g_uiVirtual.SetResolution(300, 300);
    }

#endif

    _dciVirtualPrinter.SetUnitInfo(&g_uiVirtual);
    _dciVirtualPrinter._pDoc = pDoc;
    
    _dciDefaultMedia.SetUnitInfo(&g_uiDisplay);
    _dciDefaultMedia._pDoc = pDoc;
}


//+---------------------------------------------------------------------------
//
//  Member:     Activate
//
//  Synopsis:   Activate the view
//
//----------------------------------------------------------------------------

HRESULT
CView::Activate()
{
    Assert(IsInitialized());
    Assert(!_pDispRoot);
    Assert(!_pLayout);
    Assert(!_pDispRoot);

    TraceTagEx((tagView, TAG_NONAME,
           "View : Activate"));

    _pDispRoot = CDispRoot::New(&_client, &_client);

    if (_pDispRoot)
    {
        //
        //  Mark the view active and open it
        //

        SetFlag(VF_ACTIVE);

        Verify(OpenView());

        //
        //  Initialize the display tree
        //

        _pDispRoot->SetOwned();
        _pDispRoot->SetLayerFlow();
        _pDispRoot->SetBackground(TRUE);
        _pDispRoot->SetOpaque(TRUE);
        if (Doc()->_fActiveDesktop)
            _pDispRoot->DisableObscureProcessing();

        //
        //  Allocate display contexts
        //  
        
        _pDrawContext = new CDispDrawContext(TRUE);
        _pRecalcContext = new CDispRecalcContext();
        
        //
        //  Enable the recalc engine
        //  NOTE: This is a workaround that stops recalc from running until
        //        the view is around.  When the OM is robust enough to handle
        //        no view documents then this should be removed.
        //

        Doc()->suspendRecalc(FALSE);
    }

    RRETURN (_pDispRoot
                ? S_OK
                : E_FAIL);
}


//+---------------------------------------------------------------------------
//
//  Member:     Deactivate
//
//  Synopsis:   Deactivate a view
//
//----------------------------------------------------------------------------

void
CView::Deactivate()
{
    TraceTagEx((tagView, TAG_NONAME,
           "View : Deactivate"));

    Unload();

    if (_pDispRoot)
    {
        Assert(_pDispRoot->GetObserver() == (CDispObserver *)(&_client));

        // TODO (donmarsh) -- theoretically, DestroyTreeWithPrejudice should
        // be faster than Destroy.  However, the last time I checked (11/06/98),
        // unloadchk reported only a 0.2% perf improvement, and that's not
        // enough to risk a change like this.
        //_pDispRoot->DestroyTreeWithPrejudice();
        _pDispRoot->Destroy();
        _pDispRoot = NULL;
    }
    
    delete _pDrawContext;
    _pDrawContext = NULL;
    
    delete _pRecalcContext;
    _pRecalcContext = NULL;
    
    ReleaseRenderSurface();
    ReleaseOffscreenBuffer();

    _grfFlags = 0;

    Assert(!_grfLocks);
}


//+---------------------------------------------------------------------------
//
//  Member:     Unload
//
//  Synopsis:   Unload a view
//
//----------------------------------------------------------------------------

void
CView::Unload()
{
    Assert(!IsActive() || _pDispRoot);

    TraceTagEx((tagView, TAG_NONAME,
           "View : Unload"));

    if (IsActive())
    {
        EndDeferSetWindowPos(0, TRUE);
        EndDeferSetWindowRgn(0, TRUE);
        EndDeferSetObjectRects(0, TRUE);
        EndDeferTransition(0, TRUE);

        EnsureDisplayTreeIsOpen();

#ifdef ADORNERS
        DeleteAdorners();
#endif

#ifdef FOCUS_BEHAVIOR
        if (_pFocusBehavior)
        {
            CFocusBehavior *pFocusBehavior = _pFocusBehavior;
            _pFocusBehavior = 0;
            delete _pFocusBehavior;
        }
#endif

        _aryTaskMisc.DeleteAll();
        _aryTaskLayout.DeleteAll();
        _aryTaskEvent.DeleteAll();


        if (_pDispRoot)
        {
            _pDispRoot->Unload();
        }

        ClearRanges();
        ClearInvalid();
        CloseView(LAYOUT_SYNCHRONOUS);
    }

    Assert(!HasTasks());
    Assert(!HasInvalid());

    TraceTag((tagViewTreeOpen, "%x -TreeOpen (Unload)  was %d",
                this, IsFlagSet(VF_TREEOPEN)));

    _pLayout   = NULL;
    _grfFlags &= VF_ACTIVE | VF_TREEOPEN;
    _grfLayout = 0;

    CLEARRECURSION();
}


//+---------------------------------------------------------------------------
//
//  Member:     ExtractDispNode
//
//  Synopsis:   remove the given node from the display tree
//
//  Arguments:  pDispNode   - the node to remove
//
//----------------------------------------------------------------------------

void
CView::ExtractDispNode(CDispNode * pDispNode)
{
    Assert(_pDispRoot);
    if (_pDispRoot)
        _pDispRoot->ExtractNode(pDispNode);
}


//+---------------------------------------------------------------------------
//
//  Member:     ExtractDispNodes
//
//  Synopsis:   remove the given nodes from the display tree
//
//  Arguments:  pDispNodeStart  - the first node to remove
//              pDispNodeStop   - the last node to remove
//
//----------------------------------------------------------------------------

void
CView::ExtractDispNodes(CDispNode * pDispNodeStart, CDispNode * pDispNodeStop)
{
    Assert(_pDispRoot);
    if (_pDispRoot)
        _pDispRoot->ExtractNodes(pDispNodeStart, pDispNodeStop);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureView
//
//  Synopsis:   Ensure the view is ready for rendering
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//  Returns:    TRUE if processing completed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::EnsureView(DWORD grfLayout)
{
    Assert(IsInitialized());

    PerfDbgLog(tagCViewEnsure, this, "+CView::EnsureView");

    if (IsActive())
    {
        TraceTagEx((tagView, TAG_NONAME,
               "View : EnsureView - Enter"));

        //  A note on recursive entry to EnsureView:
        //  This can happen anytime something causes us to crank our windows message queue, or
        //  (much less likely) we are synchronously called into - ex: ActiveX control.
        //  The CHECK/MARK recursion should cause an assert whenever the recursive call comes from
        //  a place we did not expect - it will most likely be legal, but needs to be examined.
        //  Currently examined & allowed states:
        //  1.  If the recursion occured from a WM_PAINT generated by an earlier call
        //      to EnsureView, return success (so rendering continues).
        //  2.  Script may fire an EnsureViewCallback that is processed because it fires a
        //      modal dialog box or explicitly calls (as with ElementFromPoint).
        
        if (    IsLockSet(VL_ENSUREINPROGRESS)
            ||  IsLockSet(VL_RENDERINPROGRESS)
            ||  IsInState (VS_BLOCKED)
            )
        {
            BOOL    fReturn;

            //
            // we do allow recursion, thus we don't need the assert
            //
            // MARKRECURSION(grfLayout);

            fReturn = (    grfLayout & LAYOUT_INPAINT
                       && IsLockSet(VL_UPDATEINPROGRESS)
                       && !IsLockSet(VL_ACCUMULATINGINVALID)
                       && !IsFlagSet(VF_BLOCKED_FOR_OM)
                      )
                            ? TRUE
                            : FALSE;

            TraceTagEx((tagView, TAG_NONAME,
                   "View : EnsureView  - Exit(%S), Skipped processing",
                   fReturn
                        ? _T("TRUE")
                        : _T("FALSE")));

            PerfDbgLog(tagCViewEnsure, this, "-CView::EnsureView - Exit 1");

            return fReturn;
        }

        //
        //  Add flags left by asynchronous requests
        //

        Assert(!(grfLayout & LAYOUT_TASKFLAGS));
        Assert(!(_grfLayout & LAYOUT_TASKFLAGS));

        grfLayout |= _grfLayout;
        _grfLayout = 0;

        //
        //  If processing synchronously, delete any outstanding asynchronous requests
        //  (Asynchronous requests remove the posted message when dispatched)
        //

        PerfDbgLog(tagCViewEnsure, this, "+CloseView");
        CloseView(grfLayout);
        PerfDbgLog(tagCViewEnsure, this, "-CloseView");
        grfLayout &= ~LAYOUT_SYNCHRONOUS;

        //
        //  If there is no work to do, exit immediately
        //

        BOOL    fSizingNeeded = !IsSized(GetRootLayout());

        if (    !fSizingNeeded
            &&  !(_grfFlags & (VF_TREEOPEN | VF_NEEDSRECALC | VF_FORCEPAINT))
            &&  !HasTasks()
            &&  !HasDeferred()
            &&  Doc()->_aryPendingFilterElements.Size() == 0
            &&  !HasInvalid()
            &&  !(grfLayout & LAYOUT_SYNCHRONOUSPAINT)
            &&  !(grfLayout & LAYOUT_FORCE))
        {
            Assert((grfLayout & ~(  LAYOUT_NOBACKGROUND
                                |   LAYOUT_INPAINT
                                |   LAYOUT_DEFEREVENTS
                                |   LAYOUT_DEFERENDDEFER
                                |   LAYOUT_DEFERINVAL
                                |   LAYOUT_DEFERPAINT)) == 0);
            Assert(!IsDisplayTreeOpen());

            TraceTagEx((tagView, TAG_NONAME,
                   "View : EnsureView - Exit(TRUE)"));

            PerfDbgLog(tagCViewEnsure, this, "-CView::EnsureView - Exit 2");

            return TRUE;
        }

        //
        //  Ensure the view
        //

        {
            CView::CLock    lockEnsure(this, VL_ENSUREINPROGRESS);

            //
            //  Update the view (if requested)
            //

            {
                CView::CLock    lockUpdate(this, VL_UPDATEINPROGRESS);

                //
                //  Perform layout and accumulate invalid rectangles/region
                //

                {
                    CView::CLock    lockInvalid(this, VL_ACCUMULATINGINVALID);

                    //
                    //  Process tasks in the following order:
                    //      1) Ensure the display tree is open (so it can be changed)
                    //      2) Transition any waiting objects
                    //      3) Execute pending recalc tasks (which could post events and layout tasks)
                    //      4) Execute pending asynchronous events (which could post layout tasks)
                    //      5) Ensure focus is up-to-date (which may post layout tasks)
                    //      6) Ensure the root layout is correctly sized (which may override pending layout tasks)
                    //      7) Execute pending measure/positioning layout tasks (which can size and move adorners)
                    //      8) Update adorners
                    //      9) Execute pending adorner layout tasks
                    //     10) Close the display tree (which may generate invalid regions and deferred requests)
                    //
                    //  TODO: This routine needs to first process foreground tasks (and it should process all foreground
                    //          tasks regardless how much time has passed?) and then background tasks. If too much time
                    //          has passed and tasks remain, it should then post a background view closure to complete the
                    //          work. (brendand)
                    //

                    {
                        CView::CLock    lockLayout(this, VL_TASKSINPROGRESS);

                        PerfDbgLog(tagCViewEnsure, this, "+EnsureDisplayTreeIsOpen");
                        EnsureDisplayTreeIsOpen();
                        PerfDbgLog(tagCViewEnsure, this, "-EnsureDisplayTreeIsOpen");

                        PerfDbgLog(tagCViewEnsure, this, "+EndDeferTransition");
                        EndDeferTransition(grfLayout);
                        PerfDbgLog(tagCViewEnsure, this, "-EndDeferTransition");

                        // Take care of any pending expression requests
                        PerfDbgLog(tagCViewEnsure, this, "+ExecuteExpressionTasks");
                        Doc()->ExecuteExpressionTasks();
                        PerfDbgLog(tagCViewEnsure, this, "-ExecuteExpressionTasks");

                        // Recompute all dirty expressions
                        // Also clear the VF_NEEDSRECALC - it will be set back along with
                        // a call to PostCloseView in case we had something to recompute
                        PerfDbgLog(tagCViewEnsure, this, "+EngineRecalcAll");
                        ClearFlag(VF_NEEDSRECALC);
                        Doc()->_recalcHost.EngineRecalcAll(FALSE);
                        PerfDbgLog(tagCViewEnsure, this, "-EngineRecalcAll");

// NOTE (mikhaill 4/21/00) -- this extra lock, VL_EXECUTINGEVENTTASKS, (disabled with slashes)
// appeared during bug #101879 inspecting. The matter is we sometimes can't execute client's
// requests. In particular, when client is called from ExecuteEventTasks() and handle event
// by direct (unbuffered) way, and calls mshtml for changing markup tree data, then asking for
// geometry data assumed to be affected by these changes, we can't provide the calculations
// because we are still inside EnsureView(). The following additional re-locking intended
// to bypass it.
// But luckily (or unfortunately?) this change, in spite of making client more happy, did not
// fix the bug's case, so was disabled in order to keep this well-tested core code undisturbed.
// However, maybe we'll need to re-enable it later.
                        
// 
//                    if (!IsLockSet(VL_EXECUTINGEVENTTASKS))
//                    {
//                        CView::CLock lockEventTasks(this, VL_EXECUTINGEVENTTASKS,
//                                                          VL_ENSUREINPROGRESS |
//                                                          VL_UPDATEINPROGRESS |
//                                                          VL_ACCUMULATINGINVALID);


                        PerfDbgLog(tagCViewEnsure, this, "+ExecuteEventTasks");
                        ExecuteEventTasks(grfLayout);
                        PerfDbgLog(tagCViewEnsure, this, "-ExecuteEventTasks");
//                    }

                        Doc()->ExecuteFilterTasks();

                        EnsureFocus();
        
                        PerfDbgLog(tagCViewEnsure, this, "+EnsureSize");
                        EnsureSize(grfLayout);
                        PerfDbgLog(tagCViewEnsure, this, "-EnsureSize");
                        grfLayout &= ~LAYOUT_FORCE;

                        PerfDbgLog(tagCViewEnsure, this, "+CView::ExecuteLayoutTasks(LAYOUT_MEASURE)");
                        ExecuteLayoutTasks(grfLayout | LAYOUT_MEASURE);
                        PerfDbgLog(tagCViewEnsure, this, "-CView::ExecuteLayoutTasks(LAYOUT_MEASURE)");

                        PerfDbgLog(tagCViewEnsure, this, "+CView::ExecuteLayoutTasks(LAYOUT_POSITION)");
                        ExecuteLayoutTasks(grfLayout | LAYOUT_POSITION);
                        PerfDbgLog(tagCViewEnsure, this, "-CView::ExecuteLayoutTasks(LAYOUT_POSITION)");

#ifdef ADORNERS
                        PerfDbgLog(tagCViewEnsure, this, "+CView::ExecuteLayoutTasks(LAYOUT_ADORNERS)");
                        UpdateAdorners(grfLayout);
                        ExecuteLayoutTasks(grfLayout | LAYOUT_ADORNERS);
                        PerfDbgLog(tagCViewEnsure, this, "-CView::ExecuteLayoutTasks(LAYOUT_ADORNERS)");
#endif

#if DBG == 1
                        // Make sure that no tasks were left lying around
                        for (int i = 0 ; i < _aryTaskLayout.Size() ; i++)
                        {
                            CViewTask vt = _aryTaskLayout[i];
                            Assert(vt.IsFlagSet(LAYOUT_TASKDELETED));
                        }
#endif

                        _aryTaskLayout.DeleteAll();


                        PerfDbgLog(tagCViewEnsure, this, "+CloseDisplayTree");
                        CloseDisplayTree();
                        PerfDbgLog(tagCViewEnsure, this, "-CloseDisplayTree");
                        Assert(!IsDisplayTreeOpen());
                    }

                    //
                    //  Process remaining deferred requests and, if necessary, adjust HWND z-ordering
                    //

                    PerfDbgLog(tagCViewEnsure, this, "+EndDeferSetWindowPos");
                    EndDeferSetWindowPos(grfLayout);
                    PerfDbgLog(tagCViewEnsure, this, "-EndDeferSetWindowPos");

                    PerfDbgLog(tagCViewEnsure, this, "+EndDeferSetObjectRects");
                    EndDeferSetObjectRects(grfLayout);
                    PerfDbgLog(tagCViewEnsure, this, "-EndDeferSetObjectRects");

                    PerfDbgLog(tagCViewEnsure, this, "+EndDeferSetWindowRgn");
                    EndDeferSetWindowRgn(grfLayout);
                    PerfDbgLog(tagCViewEnsure, this, "-EndDeferSetWindowRgn");

                    if (IsFlagSet(VF_DIRTYZORDER))
                    {
                        ClearFlag(VF_DIRTYZORDER);
                        PerfDbgLog(tagCViewEnsure, this, "+FixWindowZOrder");
                        FixWindowZOrder();
                        PerfDbgLog(tagCViewEnsure, this, "-FixWindowZOrder");
                    }
                }

                //
                //  Publish the accumulated invalid rectangles/region
                //

                PublishInvalid(grfLayout);

                //
                //  If requested and not in WM_PAINT handling, render the view (by forcing a WM_PAINT)
                //

                if (    !(grfLayout & (LAYOUT_INPAINT | LAYOUT_DEFERPAINT))
                    &&  (   IsFlagSet(VF_FORCEPAINT)
                        ||  grfLayout & LAYOUT_SYNCHRONOUSPAINT))
                {
                    TraceTagEx((tagView, TAG_NONAME,
                           "View : EnsureView  - Calling UpdateForm"));

                    PerfDbgLog(tagCViewEnsure, this, "+UpdateForm");
                    Doc()->UpdateForm();
                    PerfDbgLog(tagCViewEnsure, this, "-UpdateForm");
                }
                ClearFlag(VF_FORCEPAINT);
            }

            //
            //  Update the caret position
            //
            
            CLayout  * pLayout = GetRootLayout();

            if (    pLayout
                &&  (!pLayout->IsDisplayNone())
                &&  (   fSizingNeeded
                    ||  HasDirtyRange()))
            {
                CCaret * pCaret = Doc()->_pCaret;
                
                if (pCaret)
                {
                    BOOL    fVisible;
                    
                    pCaret->IsVisible(&fVisible);
                    if (fVisible)
                    {
                        CMarkup  *pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();               
                        LONG cp = pCaret->GetCp(NULL);
                        
                        if (  fSizingNeeded || pLayoutMarkup != pCaret->GetMarkup()
                            ||  (   cp >= _cpStartMeasured
                                &&  cp <= _cpEndMeasured)
                            ||  (   cp >= _cpStartTranslated
                                &&  cp <= _cpEndTranslated))
                        {
                            PerfDbgLog(tagCViewEnsure, this, "+UpdateCaret");
                            pCaret->UpdateCaret(FALSE, FALSE);            
                            PerfDbgLog(tagCViewEnsure, this, "-UpdateCaret");
                        }
                    }
                }
            }
            ClearRanges();
        }
    }

#ifndef NO_ETW_TRACING
    // Send event to ETW if it is enabled by the shell.
    if (g_pHtmPerfCtl &&
        (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT)) {
        g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_LAYOUT,
                               (TCHAR *)Doc()->GetPrimaryUrl());
    }
#endif

    TraceTagEx((tagView, TAG_NONAME,
           "View : EnsureView - Exit(TRUE)"));

    PerfDbgLog(tagCViewEnsure, this, "-CView::EnsureView - Exit 3");

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetViewPosition, SetViewPosition
//              
//  Synopsis:   Get/Set the position at which display tree content will be rendered
//              in its host coordinates (used for device offsets when printing).
//              
//  Arguments:  pt      point in host coordinates
//              
//----------------------------------------------------------------------------

void
CView::GetViewPosition(
    CPoint *    ppt)
{
    Assert(ppt);

    *ppt = _pDispRoot
                ? _pDispRoot->GetRootPosition()
                : g_Zero.pt;
}

void
CView::SetViewPosition(
    const POINT &   pt)
{
    if (IsActive())
    {
        OpenView();
        _pDispRoot->SetRootPosition(pt);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     SetViewOffset
//              
//  Synopsis:   Set the view offset, which shifts displayed content (used by
//              printing to display a series of pages with content effectively
//              scrolled between pages).
//              
//  Arguments:  sizeOffset      offset where positive values display content
//                              farther to the right and bottom
//              
//----------------------------------------------------------------------------

BOOL
CView::SetViewOffset(
    const SIZE &    sizeOffset)
{
    if (IsActive())
    {
        OpenView();
        return _pDispRoot->SetContentOffset(sizeOffset);
    }
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  CVIew::BlockViewForOM
//
//----------------------------------------------------------------------------
void        
CView::BlockViewForOM(BOOL fBlock)
{
    if (fBlock)
    {
        SetFlag(VF_BLOCKED_FOR_OM);
    }
    else
    {
        ClearFlag(VF_BLOCKED_FOR_OM);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     EraseBackground
//              
//  Synopsis:   Draw background and border
//              
//  Arguments:  pDI      - Draw context
//              hrgnDraw - Region to draw (if not NULL)
//              prcDraw  - Rect to draw (if not NULL)
//              fEraseChildWindow   if TRUE, we are erasing the background of
//                                  a child window (the IE Label control)
//              
//----------------------------------------------------------------------------

void
CView::EraseBackground(
    CFormDrawInfo * pDI,
    HRGN            hrgnDraw,
    const RECT *    prcDraw,
    BOOL            fEraseChildWindow)
{
    CLayout  * pLayout = GetRootLayout();

    if (pLayout)
    {   
        CMarkup  * pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();
        if(pLayoutMarkup->Document())
        {
            CDocument * pDocument = pLayoutMarkup->Document();
            {
                if(pDocument->HasPageTransitionInfo() && pDocument->GetPageTransitionInfo()->
                              GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_APPLIED)
                {
                    return;
                }
            }
        }
    }

    if (IsActive())
    {
        Assert(!IsLockSet(VL_RENDERINPROGRESS));
        Assert( hrgnDraw
            ||  prcDraw);

        // WARNING (donmarsh) -- we were hitting this lock when we had a
        // windowless Java applet on a page that was trying to do a 
        // page transition -- yikes!  Unfortunately, if we let this go
        // through, we will almost certainly crash, as the Display Tree
        // does not expect to be reentered while it is in the middle of
        // drawing.
        if (IsLockSet(VL_RENDERINPROGRESS))
            return;

#if DBG==1
        if (prcDraw)
        {
            TraceTagEx((tagView, TAG_NONAME,
                   "View : EraseBackground - HDC(0x%x), RECT(%d, %d, %d, %d)",
                   pDI->_hdc,
                   prcDraw->left,
                   prcDraw->top,
                   prcDraw->right,
                   prcDraw->bottom));
        }
        else if (hrgnDraw)
        {
            RECT rc;
            int rgnType = ::GetRgnBox(hrgnDraw, &rc);

            TraceTagEx((tagView, TAG_NONAME,
                   "View : EraseBackground - HDC(0x%x), HRNG bounds(%d, %d, %d, %d)",
                   pDI->_hdc,
                   rgnType == NULLREGION ? "NULLREGION" :
                   rgnType == SIMPLEREGION ? "SIMPLEREGION" :
                   rgnType == COMPLEXREGION ? "COMPLEXREGION" : "ERROR",
                   rc.left,
                   rc.top,
                   rc.right,
                   rc.bottom));
        }
        else
        {
            TraceTagEx((tagView, TAG_NONAME,
                   "View : EraseBackground - HDC(0x%x), No HRGN or rectangle was passed!",
                   pDI->_hdc));
        }
#endif

        Assert(!pDI->_hdc.IsEmpty());
        
        if (!pDI->_hdc.IsEmpty())
        {
            CView::CLock    lock(this, VL_RENDERINPROGRESS);
            XHDC            hdc = pDI->_hdc;

            AssertSz(hdc.pSurface() == NULL, "is surface information being lost?");
            SetRenderSurface(hdc, NULL);
            
            if (_pRenderSurface != NULL)
            {
                CPaintCaret hc(Doc()->_pCaret);
                POINT       ptOrg = g_Zero.pt;
                
                pDI->_hdc = NULL;
    
                ::GetViewportOrgEx(hdc, &ptOrg);
    
                _pDrawContext->SetDispSurface(_pRenderSurface);
                _pDrawContext->SetToIdentity();

#ifdef DEADCODE
                //  If we have a document zoom factor, hit it.
                if (_iZoomFactor != 100)
                {
                    AssertSz(0, "Debug Me: document zoom != 100%");
                    _pDrawContext->GetClipTransform().GetWorldTransform()->AddScaling(_iZoomFactor/100.0, _iZoomFactor/100.0);
                }
#endif
                
                _pDispRoot->EraseBackground(_pRenderSurface, _pDrawContext, (void*)pDI, hrgnDraw, prcDraw, fEraseChildWindow);
    
                ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
        
                pDI->_hdc = hdc;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderBackground
//
//  Synopsis:   Render the background of the view
//
//  Arguments:  pDI - Current CFormDrawInfo
//
//----------------------------------------------------------------------------

void
CView::RenderBackground(
    CFormDrawInfo * pDI)
{
    if (IsActive())
    {
        Assert(pDI);
        Assert(pDI->GetDC() != NULL);

        PatBltBrush(pDI->GetDC(), &pDI->_rcClip, PATCOPY, Doc()->_pOptionSettings->crBack());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderElement
//
//  Synopsis:   Render the element (and all its children) onto the passed HDC
//
//  Arguments:  pElement - the element to render
//              pContext - the display draw context (non-null if this is a filter callback)
//              hdc - HDC on to which to render the element
//              punkDrawObject - if non-null, takes precedence over hdc
//              prcBounds - bounding rect
//              prcUpdate - rect that needs drawing
//              lDrawLayers - layers that need drawing
//
//  Notes:      For now this will assume no clip region and draw at 0, 0
//              Later on we may want to allow the caller to specify an offset
//              and a clip rect/region.
//
//----------------------------------------------------------------------------

HRESULT
CView::RenderElement(
        CElement *          pElement,
        CDispDrawContext*   pContext,
        HDC                 hdc,
        IUnknown *          punkDrawObject,
        RECT *              prcBounds,
        RECT *              prcUpdate,
        LONG                lDrawLayers)
{
    Assert(hdc != NULL || punkDrawObject != NULL);

    HRESULT                 hr                  = S_OK;
    BOOL                    fPaletteSwitched    = FALSE;
    bool                    fPassMatrix         = false;
    IDirectDrawSurface *    pDDS                = NULL;
    CDispSurface *          pDispSurface        = NULL;
    CLayoutContext *        pLayoutContext      = pContext
                                                  ? pContext->GetLayoutContext() 
                                                  : NULL;
    MAT                     matrix;

    WHEN_DBG(POINT pt;)

    // the only draw object we support is DirectDrawSurface
    if (punkDrawObject)
    {
        Assert(hdc == NULL);

        if (OK(punkDrawObject->QueryInterface(IID_IDirectDrawSurface, (void**)&pDDS)))
        {
            pDDS->GetDC(&hdc);
        }
    }

    // Can't do anything if there's nowhere to draw.

    if (hdc == NULL)
    {
        hr = E_FAIL;

        goto Cleanup;
    }

    Assert(!punkDrawObject || pDDS);

    pElement->Doc()->GetPalette(hdc, NULL, &fPaletteSwitched);

    // Set up the surface where we'll draw.

    if (!pContext || pContext->GetDispSurface()->GetRawDC() != hdc)
    {
        pDispSurface = pDDS ? new CDispSurface(pDDS)
                            : new CDispSurface(hdc);

        if (pDispSurface == NULL)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        if (pDDS)
        {
            // If we're drawing to a direct draw surface and we're print media, 
            // we need to set up a transform to scale down the drawing to 
            // pixels instead of the printer measurement scale.  This supports
            // drawing the unfiltered element for the filter behavior.

            if ( pLayoutContext
                && (pLayoutContext != GUL_USEFIRSTLAYOUT)
                && (pLayoutContext->GetMedia() & mediaTypePrint))
            {
                matrix.eM11 =   (float)g_uiDisplay.GetResolution().cx 
                              / (float)g_uiVirtual.GetResolution().cx;
                matrix.eM12 = 0.0F;
                matrix.eM21 = 0.0F;
                matrix.eM22 =   (float)g_uiDisplay.GetResolution().cy 
                              / (float)g_uiVirtual.GetResolution().cy;
                matrix.eDx  = 0.0F;
                matrix.eDy  = 0.0F;

                fPassMatrix = true;
            }
            else if (g_uiDisplay.IsDeviceScaling())
            {
                matrix.eM11 =   FIXED_PIXELS_PER_INCH 
                              / (float)g_uiDisplay.GetResolution().cx;
                matrix.eM12 = 0.0F;
                matrix.eM21 = 0.0F;
                matrix.eM22 =   FIXED_PIXELS_PER_INCH 
                              / (float)g_uiDisplay.GetResolution().cy;
                matrix.eDx  = 0.0F;
                matrix.eDy  = 0.0F;

                fPassMatrix = true;
            }
        }
    }

    WHEN_DBG(GetViewportOrgEx(hdc, &pt);)

#if DBG == 1

    if (IsTagEnabled(tagFilterFakeSource))
    {
        SaveDC(hdc);

        HBRUSH  hbrush  = CreateHatchBrush(HS_DIAGCROSS, RGB(0, 255, 0));
        HPEN    hpen    = CreatePen(PS_SOLID, 2, RGB(0, 255, 255));

        SelectBrush(hdc, hbrush);
        SelectPen(hdc, hpen);
        Rectangle(hdc, prcBounds->left, prcBounds->top, prcBounds->right, prcBounds->bottom);
        
        SetTextColor(hdc, RGB(255, 0, 0));
        SetBkMode(hdc, TRANSPARENT);

        TCHAR *sz = _T("This text was rendered instead of the filtered element, it is primarily to test filters");

        DrawText(hdc, sz, -1, prcBounds, DT_CENTER | DT_WORDBREAK);

        RestoreDC(hdc, -1);
    }
    else
    {

#endif

    if (pContext)
    {
        // This is a draw call in response to our Draw on the filter.
        // Get the layout context from CDispDrawContext and pass it
        // to the GetUpdatedLayout to get the correct one of the 
        // multiple layouts
        CLayout *   pLayout = pElement->GetUpdatedLayout(pContext->GetLayoutContext());

        Assert(pLayout);

        CDispNode *pDispNode = pLayout->GetElementDispNode();

        Assert(pDispNode);

        pDispNode->DrawNodeForFilter(pContext, pDispSurface,
                                     fPassMatrix ? &matrix : NULL, lDrawLayers);
    }
    else
    {
        // This is an out of band call, typically done by a transition when Apply is called.  We need to
        // enlist the help of the view.

        POINT ptOrg;

        ::SetViewportOrgEx(hdc, 0, 0, &ptOrg);

        RenderElement(pElement, NULL, lDrawLayers, pDispSurface, TRUE,
                      fPassMatrix ? &matrix : NULL);

        ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
    }

#if DBG == 1

    }

    if (IsTagEnabled(tagFilterPaintScreen))
    {
        HDC hdcScreen = CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        if (hdcScreen)
        {
            CRect rc(*prcBounds);
            CSize size = rc.Size();

            BitBlt(hdcScreen, 0, 0, size.cx, size.cy, hdc, prcBounds->left, prcBounds->top, BLACKNESS);
            BitBlt(hdcScreen, 0, 0, size.cx, size.cy, hdc, prcBounds->left, prcBounds->top, SRCCOPY);  

            DeleteDC(hdcScreen);
        }
    }

#endif

    if (hdc && fPaletteSwitched)
    {
        SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    }

Cleanup:

    delete pDispSurface;

    ReleaseInterface(pDDS);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderElement
//
//  Synopsis:   Render the element (and all its children) onto the passed HDC
//
//  Arguments:  pElement - the element to render
//              hdc - HDC on to which to render the element
//              pDispSurface - surface on to which to render the element
//                  (if not NULL, takes precedence over hdc)
//              fIgnoreUserClip - artificially remove user clip during this render
//
//              2001/04/12 mcalkins:
//              pMatrix - Added this argument, only used when filters call to
//                        have the element drawn in response to a call to
//                        Apply() the filter.
//
//  Notes:      For now this will assume no clip region and draw at 0, 0
//              Later on we may want to allow the caller to specify an offset
//              and a clip rect/region.
//
//----------------------------------------------------------------------------

HRESULT
CView::RenderElement(
    CElement *      pElement,
    HDC             hdc,
    long            lDrawLayers,     /* = FILTER_DRAW_ALLLAYERS */
    CDispSurface *  pDispSurface,    /* = NULL                  */
    BOOL            fIgnoreUserClip, /* = FALSE                 */
    MAT *           pMatrix          /* = NULL                  */)
{
    Assert(pElement != NULL);
    Assert(hdc != NULL || pDispSurface != NULL);

    if (pDispSurface)
    {
        hdc = pDispSurface->GetRawDC();
    }

    if (IsActive() && hdc != NULL)
    {
        CLayout *pLayout = pElement->GetUpdatedNearestLayout(); // find the appropriate layout

        TraceTagEx((tagView, TAG_NONAME,
               "View : RenderElement - HDC(0x%x), Element(0x%x, %S)",
               hdc,
               pElement,
               pElement->TagName()));

        if (    !IsSized(GetRootLayout())
            ||  (_grfFlags & (VF_TREEOPEN | VF_NEEDSRECALC))
            ||  HasTasks()
            ||  (_grfLayout & LAYOUT_FORCE))
        {
            if (    IsLockSet(VL_ACCUMULATINGINVALID)
                ||  IsLockSet(VL_RENDERINPROGRESS))
            {
                pElement->Invalidate();
                RRETURN(E_UNEXPECTED);
            }
            
            EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_DEFEREVENTS | LAYOUT_DEFERPAINT);
        }

        CView::CLock    lock(this, VL_RENDERINPROGRESS);

        CDispNode *pDispNode = pLayout->GetElementDispNode();

        // If this node isn't in the display tree, don't draw anything.

        if (!pDispNode || !pDispNode->GetRootNode() || !pDispNode->GetRootNode()->IsDispRoot())
        {
            RRETURN(S_OK);
        }

        // Save the DC always
        if(!SaveDC(hdc))
            RRETURN(GetLastWin32Error());

        //TODO (dmitryt): we have to review this busines with CFormDrawInfo and DospSurface both 
        //        wrapping HDC and CDispDrawContext and DispSurface both having 
        //        transforms and clip rects. I think CDispSurface should only have normalized DC
        //        (or GDI+ pointer) and CDispDrawContext should have clip and transform.
        //        It would be good to eliminate CFormDrawInfo at all.
        CFormDrawInfo DI;

        DI.Init(pElement, XHDC(hdc, NULL));
        DI._hdc = NULL;             
        DI._fInplacePaint = FALSE; //to force select and olecontrols to draw 
        DI._fIsMetafile   = (GetDeviceCaps(hdc,TECHNOLOGY) == DT_METAFILE);

       //create and set context...
       //try to init all fields because constructor does not do it.
        CDispDrawContext context(FALSE); //we can be drawing something that is not in view
        
        context.SetClientData(&DI);
        context.SetFirstDrawNode(pDispNode);
        context.SetRootNode(_pDispRoot);
        context._fBypassFilter = TRUE;
        
        //initialize context transformation...
        context.GetClipTransform().SetToIdentity();

        //equalize resolutions (1" in the output device should be 1" on the default device)
        CSize sizeInch;
        sizeInch.cx = GetDeviceCaps(hdc, LOGPIXELSX);
        sizeInch.cy = GetDeviceCaps(hdc, LOGPIXELSY);

        // Find layout resolution of the parent. Display transformation currently
        // set in the display node is computed to translate from inner resolution to 
        // outer (parent) resolution, plus it takes in account any additional transformations.
        // We want to keep transformations (e.g. rotation), but we want to scale from parent's
        // media to output device media.
        CLayoutContext const * pContainingLayoutContext = pLayout->HasLayoutContext()        
                                                        ? pLayout->LayoutContext()
                                                        : NULL;
                         
        mediaType mediaLayout = pContainingLayoutContext 
                              ? pContainingLayoutContext->GetMedia() 
                              : mediaTypeNotSet;
                              
        CDocInfo const * pdciParent = GetMeasuringDevice(mediaLayout);
        
        if (sizeInch != pdciParent->GetResolution())
        {
            CDispTransform dispTrans;
            CWorldTransform *pWorldTrans = dispTrans.GetWorldTransform();

            AssertSz(pdciParent->IsDeviceIsotropic(), "Only isotropic measurement devices are supported.");

            pWorldTrans->AddScaling((FLOAT) sizeInch.cx / pdciParent->GetResolution().cx,
                                    (FLOAT) sizeInch.cy / pdciParent->GetResolution().cy);

            context.GetClipTransform().AddPostTransform(dispTrans);
        }

#ifdef DEADCODE
        //add "view zoom". 
        if (_iZoomFactor != 100)
            context.GetClipTransform().GetWorldTransform()->AddScaling(_iZoomFactor/100.0, _iZoomFactor/100.0);                                 
#endif

        //remove origin from DC and add it to context's transform
        CSize szOffset(0,0);
        SetViewportOrgEx(hdc,0,0,&(szOffset.AsPoint()));
        context.AddPostOffset(szOffset);
        
        //account for offset inside container (bounds)
        CRect bounds = pDispNode->GetBounds();
        szOffset.AsPoint() = bounds.TopLeft();
        context.AddPreOffset(-szOffset);

        //set clip and redraw region
        context.ForceClipRect(bounds);

// NOTE (mikhaill) -- something is totaly incorrect in CDispSurface::_prgn handling.
// Which coordinates it should be expessed in? I hope - device coordinates. If so, following
// rcgClip calculations is incorrect. If not - we should change CDispSurface::SetClip() routine
#if 0 //weird clip rgn
        CRect rcgClip;
        context.GetClipTransform().Transform(bounds, &rcgClip);  // to global coords
        CRegion rgngClip(rcgClip);
        context.SetRedrawRegion(&rgngClip);
#else //weird clip rgn
        {
            CRect rc(0, 0, ::GetDeviceCaps(hdc, HORZRES), ::GetDeviceCaps(hdc, VERTRES));
            // alternative way: int r1 = GetClipBox(hdc, &rc);
            CRegion rg(rc);
            context.SetRedrawRegion(&rg);
        }
#endif //weird clip rgn

        //create surface and connect it to context
        CDispSurface *pSurfaceNew = NULL;
        if (pDispSurface == NULL)
        {
            pSurfaceNew = new CDispSurface(hdc);
            pDispSurface = pSurfaceNew;
        }
        context.SetDispSurface(pDispSurface);

        //do the thing
        // we ignore user clip during Apply() of a transition, so that
        // the "before" picture is fully available at Play() time (bug 96041)
#if 0
        // Bug 104556 (mikhaill) -- we should ignore not only user clip,
        // but also user transform. The previous code is kept
        // for reference under this #if 0.
        BOOL fHadUserClip = pDispNode->HasUserClip();

        if (fIgnoreUserClip)
        {
            pDispNode->SetFlag(CDispNode::s_hasUserClip, FALSE);
        }

        _pDispRoot->DrawNode(pDispNode, pDispSurface, &context, lDrawLayers);
        pDispNode->SetFlag(CDispNode::s_hasUserClip, fHadUserClip);
#else
        if (fIgnoreUserClip)
        {
            pDispNode->DrawNodeForFilter(&context, pDispSurface, pMatrix, lDrawLayers);
        }
        else
        {
            _pDispRoot->DrawNode(pDispNode, pDispSurface, &context, lDrawLayers);
        }
#endif

        delete pSurfaceNew;

        RestoreDC(hdc, -1);
    
        RRETURN(S_OK);
    }

    RRETURN(E_UNEXPECTED);
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderView
//
//  Synopsis:   Render the view onto the passed HDC
//              
//  Arguments:  pDI      - Draw context
//              hrgnDraw - Region to draw (if not NULL)
//              prcDraw  - Rect to draw (if not NULL)
//              pClientScale - ptr to array or two scale coefficients,
//                             for X and Y correspondingly. If ptr is zero,
//                             both coefs are treated as 1.
//
//  Note:       pClientScale argument added as a patch to fix bug #106814
//              (mikhaill 4/6/00)
//----------------------------------------------------------------------------

void
CView::RenderView(
    CFormDrawInfo * pDI,
    HRGN            hrgnDraw,
    const RECT *    prcDraw,
    float const*    pClientScale /* = 0 */)
{   
    if (IsActive())
    {
        Assert(!IsLockSet(VL_ACCUMULATINGINVALID));
        Assert(!IsLockSet(VL_RENDERINPROGRESS));
        Assert( hrgnDraw
            ||  prcDraw);

        TraceTagEx((tagView, TAG_NONAME,
               "View : RenderView - Enter"));

#if DBG==1
        if (prcDraw)
        {
            TraceTagEx((tagViewRender, TAG_NONAME,
                   "View : RenderView - HDC(0x%x), RECT(%d, %d, %d, %d)",
                   pDI->_hdc,
                   prcDraw->left,
                   prcDraw->top,
                   prcDraw->right,
                   prcDraw->bottom));
        }
        else if (hrgnDraw)
        {
            RECT rc;
            int rgnType = ::GetRgnBox(hrgnDraw, &rc);

            TraceTagEx((tagViewRender, TAG_NONAME,
                   "View : RenderView - HDC(0x%x), HRNG(%s) bounds(%d, %d, %d, %d)",
                   pDI->_hdc.GetDebugDC(),
                   rgnType == NULLREGION ? "NULLREGION" :
                   rgnType == SIMPLEREGION ? "SIMPLEREGION" :
                   rgnType == COMPLEXREGION ? "COMPLEXREGION" : "ERROR",
                   rc.left,
                   rc.top,
                   rc.right,
                   rc.bottom));
        }
        else
        {
            TraceTagEx((tagViewRender, TAG_NONAME,
                   "View : RenderView - HDC(0x%x), No HRGN or rectangle was passed!",
                   pDI->_hdc.GetDebugDC()));
        }
#endif       

        CLayout  * pLayout = GetRootLayout();

        if (pLayout)
        {   
            CMarkup  * pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();
            if(pLayoutMarkup->Document())
            {
                CDocument * pDocument = pLayoutMarkup->Document();
                {
                    if(pDocument->HasPageTransitionInfo() && pDocument->GetPageTransitionInfo()->
                                  GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_APPLIED)
                    {
                        return;
                    }
                }
            }
        }

        if (    IsLockSet(VL_ACCUMULATINGINVALID)
            ||  IsLockSet(VL_RENDERINPROGRESS))
        {
            if (IsLockSet(VL_ACCUMULATINGINVALID))
            {
                SetFlag(VF_FORCEPAINT);
            }
        }

        else if (!pDI->_hdc.IsEmpty())
        {
            CView::CLock    lock(this, VL_RENDERINPROGRESS);
            XHDC            hdc = pDI->_hdc;

            SetRenderSurface(hdc, NULL);
            
            if (_pRenderSurface != NULL)
            {
                CPaintCaret     pc( Doc()->_pCaret );
                
#if DBG==1
                if (IsTagEnabled(tagViewRender))
                {
                    DumpHDC(hdc.GetDebugDC());
                }
#endif

                pDI->_hdc = NULL;
                
                _pDrawContext->SetDispSurface(_pRenderSurface);
                _pDrawContext->SetToIdentity();

                if (pClientScale)
                {
                    CDispTransform dispTrans;
                    CWorldTransform *pWorldTrans = dispTrans.GetWorldTransform();


                    //pWorldTrans->AddScaling(pClientScale[0], pClientScale[1]);
                    //hack isotropic
                    float scale = min(pClientScale[0], pClientScale[1]);
                    pWorldTrans->AddScaling(scale, scale);

                    _pDrawContext->GetClipTransform().AddPostTransform(dispTrans);
                }

#ifdef DEADCODE
                //  If we have a document zoom factor, hit it.
                if (_iZoomFactor != 100)
                {
                    AssertSz(0, "Debug Me: document zoom != 100%");
                    _pDrawContext->GetClipTransform().GetWorldTransform()->AddScaling(_iZoomFactor/100.0, _iZoomFactor/100.0);
                }
#endif
    
                //
                //  Update the buffer size
                //  (We need to set this information each time in case something has changed.
                //   Fortunately, it won't do any real work until it absolutely has to)
                //

                SetOffscreenBuffer(
                    Doc()->GetPalette(), 
                    Doc()->_bufferDepth, 
                    (Doc()->_cSurface > 0), 
                    (Doc()->_c3DSurface > 0), 
                    WantOffscreenBuffer(),
                    AllowOffscreenBuffer());
                                                
                _pDispRoot->DrawRoot(
                    _pRenderSurface,
                    _pOffscreenBuffer,
                    _pDrawContext,
                    (void*)pDI,
                    hrgnDraw,
                    prcDraw);
    
                pDI->_hdc = hdc;
    
                SetFlag(VF_HASRENDERED);
            }
        }

        TraceTagEx((tagView, TAG_NONAME,
               "View : RenderView - Exit"));
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     HitScrollInset
//
//  Synopsis:   Find the top-most scroller that contains the given hit point
//              near its edge, and is capable of scrolling in that direction.
//
//  Arguments:  pptHit       - Point to test
//              pdwScrollDir - Returns the direction(s) that this scroller
//                             can scroll in
//
//  Returns:    CDispScroller that can scroll, NULL otherwise
//
//----------------------------------------------------------------------------

CDispScroller *
CView::HitScrollInset(
    CPoint *    pptHit,
    DWORD *     pdwScrollDir)
{
    return IsActive()
                ? _pDispRoot->HitScrollInset(*pptHit, pdwScrollDir)
                : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestPoint
//
//  Synopsis:   Initiate a hit-test through the display tree
//
//  Arguments:  pMessage   - CMessage for which to hit test
//              ppTreeNode - Where to return CTreeNode of hit element
//              grfFlags   - HT_xxxx flags
//
//  Returns:    HTC_xxx value
//
//----------------------------------------------------------------------------

HTC
CView::HitTestPoint(
    CMessage *      pMessage,
    CTreeNode **    ppTreeNode,
    DWORD           grfFlags)
{
    if (!IsActive())
        return HTC_NO;

    CDispNode * pDispNode = NULL;
    COORDINATE_SYSTEM   cs = COORDSYS_BOX;
    POINT       ptContent = g_Zero.pt;
    HTC         htc       = HitTestPoint(
                                pMessage->pt,
                                &cs,
                                NULL,
                                grfFlags,
                                &pMessage->resultsHitTest,
                                ppTreeNode,
                                ptContent,
                                &pDispNode,
                                &pMessage->pLayoutContext,
                                &pMessage->pElementEventTarget,
                                &pMessage->lBehaviorCookie,
                                &pMessage->lBehaviorPartID);

    //
    //  Save content coordinate point and associated CDispNode
    //

    pMessage->SetContentPoint(ptContent, pDispNode);
    pMessage->coordinateSystem = cs;

    return htc;
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestPoint
//
//  Synopsis:   Initiate a hit-test through the display tree
//
//  Arguments:  pt         - POINT to hit test
//              pcs        - Coordinate system for the point
//              pElement   - The CElement start hittesting at (if NULL, start at the root)
//              grfFlags   - HT_xxxx flags
//              phtr       - Pointer to a HITTESTRESULTS
//              ppTreeNode - Where to return CTreeNode of hit element
//              ptContent  - Hit tested point in content coordinates
//              ppDispNode - Display node that was hit
//
//  Returns:    HTC_xxx value
//
//----------------------------------------------------------------------------

HTC
CView::HitTestPoint(
    const POINT         &pt,
    COORDINATE_SYSTEM * pcs,
    CElement *          pElement,
    DWORD               grfFlags,
    HITTESTRESULTS *    pHTRslts,
    CTreeNode **        ppTreeNode,
    POINT               &ptContent,
    CDispNode **        ppDispNode,
    CLayoutContext **   ppLayoutContext,
    CElement **         ppElementEventTarget /* = NULL */,
    LONG *              plBehaviorCookie /* = NULL */,
    LONG *              plBehaviorPartID /* = NULL */)
{
    Assert(ppTreeNode);
    Check(!IsLockSet(VL_ACCUMULATINGINVALID));

    if (    !IsActive()
        ||  IsLockSet(VL_ACCUMULATINGINVALID))
        return HTC_NO;

    CPoint          ptHit(pt);
    CHitTestInfo    hti;
    CDispNode *     pDispNode = NULL;

    //
    //  TODO: The fuzzy border should be used whenever the container of is
    //          in edit-mode. For now, only use it when the document itself
    //          is in design-mode. (donmarsh)
    //

    long            cFuzzyBorder = Doc()->DesignMode()
                                        ? 7
                                        : 0;

    //
    //  Ensure the view is up-to-date so the hit-test is accurate
    //

    if (    !IsSized(GetRootLayout())
        ||  (_grfFlags & (VF_TREEOPEN | VF_NEEDSRECALC))
        ||  HasTasks()
        ||  (_grfLayout & LAYOUT_FORCE))
    {
        if (    IsLockSet(VL_ENSUREINPROGRESS)
            ||  IsLockSet(VL_RENDERINPROGRESS))
            return HTC_NO;

        EnsureView(LAYOUT_DEFEREVENTS | LAYOUT_DEFERPAINT);
    }

    //
    //  Construct the default CHitTestInfo
    //

    hti._htc          = HTC_NO;
    hti._phtr         = pHTRslts;
    hti._pNodeElement = *ppTreeNode;
    hti._pDispNode    = NULL;
    hti._ptContent    = g_Zero.pt;
    hti._grfFlags     = grfFlags;
    hti._pLayoutContext = NULL;
    hti._ppElementEventTarget = ppElementEventTarget;
    hti._plBehaviorCookie = plBehaviorCookie;
    hti._plBehaviorPartID = plBehaviorPartID;

    //
    //  Determine the starting display node
    //  NOTE: This must be obtained after calling EnsureView since pending layout
    //        can change the display nodes associated with a element
    //

    if (pElement)
    {
        CLayout *   pLayout = pElement->GetUpdatedNearestLayout();

        if (pLayout)
        {
            pDispNode = pLayout->GetElementDispNode(pElement);
        }
    }

    if (!pDispNode)
    {
        pDispNode = _pDispRoot;
    }

    //
    //  Find the hit
    //

    pDispNode->HitTest(&ptHit, pcs, &hti, !!(grfFlags & HT_VIRTUALHITTEST), cFuzzyBorder);

    //
    //  Save content coordinate point and associated CDispNode
    //

    if (!hti._pNodeElement)
    {
        Assert(!hti._pDispNode);

        CElement *  pElement = CMarkup::GetCanvasElementHelper(Doc()->PrimaryMarkup());

        if (pElement && (!pElement->IsDisplayNone()))
        {
            hti._htc          = HTC_YES;
            hti._pNodeElement = pElement->GetFirstBranch();

            if (hti._phtr)
            {
                hti._phtr->_fWantArrow = TRUE;
            }
        }
    }
    // TODO (MohanB) Need to re-visit this. Hack for frames so that we return BODY instead
    // of the root as the element hit
    else if (   hti._pNodeElement->Tag() == ETAG_ROOT 
             && hti._pNodeElement->Element()->HasMasterPtr())
    {
        CElement * pElement = (hti._pNodeElement->GetMarkup()) 
                                ? hti._pNodeElement->GetMarkup()->GetCanvasElement()
                                : NULL;

        if (pElement)
        {
            hti._pNodeElement = pElement->GetFirstBranch();
        }
    }

    ptContent   = hti._ptContent;
    *ppDispNode = hti._pDispNode;
    *ppTreeNode = hti._pNodeElement;
    *ppLayoutContext = hti._pLayoutContext;

    return hti._htc;
}


//+---------------------------------------------------------------------------
//
//  Member:     Invalidate
//
//  Synopsis:   Invalidate the view
//
//  Arguments:  prcInvalid         - Invalid rectangle
//              rgn                - Invalid region
//              fSynchronousRedraw - TRUE to redraw synchronously
//              fInvalChildWindows - TRUE to invalidate child windows
//
//----------------------------------------------------------------------------

void
CView::Invalidate(
    const CRect *   prcInvalid,
    BOOL            fSynchronousRedraw,
    BOOL            fInvalChildWindows,
    BOOL            fPostRender)
{
    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI())
    {
        if (!prcInvalid)
        {
            prcInvalid = (CRect *)&_pDispRoot->GetBounds();
        }

        TraceTag((tagViewInvalidate, "Invalidate - rc(%d, %d, %d, %d)",
               prcInvalid->left,
               prcInvalid->top,
               prcInvalid->right,
               prcInvalid->bottom
               ));

        //
        //  For a few sections of various other strategies for tracking invalid rectangles pls see the SHIST.
        //  They were discarded since they, at this time, did not provide a performance benefit and were more complex
        //

        //
        //  Maintain a small number of invalid rectangles
        //
        
        if (_cInvalidRects < MAX_INVALID)
        {
            //
            //  Ignore the rectangle if contained within another
            //

            for (int i = 0; i < _cInvalidRects; i++)
            {
                if (_aryInvalidRects[i].Contains(*prcInvalid))
                    break;
            }

            if (i >= _cInvalidRects)
            {
                _aryInvalidRects[_cInvalidRects++] = *prcInvalid;
            }
        }

        //
        //  If too many arrive, union the rectangle into that which results in the least growth
        //

        else
        {
            CRect   rc;
            long    i, iBest;
            long    c, cBest;

            iBest = 0;
            cBest = MINLONG;

            for (i=0; i < MAX_INVALID; i++)
            {
                rc = _aryInvalidRects[i];
                c  = rc.FastArea();

                rc.Union(*prcInvalid);
                c -= rc.FastArea();

                if (c > cBest)
                {
                    iBest = i;
                    cBest = c;

                    if (!cBest)
                        break;
                }
            }

            Assert(iBest >= 0 && iBest < MAX_INVALID);

            if (cBest)
            {
                _aryInvalidRects[iBest].Union(*prcInvalid);
            }
        }

        //
        //  Note if child HWNDs need invalidation
        //

        if (fInvalChildWindows)
        {
            SetFlag(VF_INVALCHILDWINDOWS);
        }

        //
        //  If not actively accumulating invalid rectangles/region,
        //  ensure that the view will eventually render
        //

        if(fPostRender)
            PostRenderView(fSynchronousRedraw);
    }
}

void
CView::Invalidate(
    const CRegion&  rgn,
    BOOL            fSynchronousRedraw,
    BOOL            fInvalChildWindows)
{
    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI())
    {
        //
        //  If the region is a rectangle, forward and return
        //

        if (!rgn.IsComplex())
        {
            RECT rc;
            rgn.GetBounds(&rc);
            Invalidate(&rc, fSynchronousRedraw, fInvalChildWindows);
            return;
        }

#if DBG==1
        if (IsTagEnabled(tagViewInvalidate))
        {
            TraceTag((tagViewInvalidate, "Invalidate region"));
            DumpRegion(rgn);
        }
#endif

        //
        //  Collect the invalid region
        //

        _rgnInvalid.Union(rgn);

        //
        //  Note if child HWNDs need invalidation
        //

        if (fInvalChildWindows)
        {
            SetFlag(VF_INVALCHILDWINDOWS);
        }

        //
        //  If not actively accumulating invalid rectangles/region,
        //  ensure that the view will eventually render
        //

        PostRenderView(fSynchronousRedraw);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     InvalidateBorder
//
//  Synopsis:   Invalidate a border around the edge of the view
//
//  Arguments:  cBorder - Border width to invalidate
//
//-----------------------------------------------------------------------------

void
CView::InvalidateBorder(
    long    cBorder)
{
    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI()
        &&  cBorder)
    {
        CSize   size;

        GetViewSize(&size);

        CRect   rc(size);
        CRect   rcBorder;

        rcBorder = rc;
        rcBorder.right = rcBorder.left + cBorder;
        Invalidate(&rcBorder);

        rcBorder = rc;
        rcBorder.bottom = rcBorder.top + cBorder;
        Invalidate(&rcBorder);

        rcBorder = rc;
        rcBorder.left = rcBorder.right - cBorder;
        Invalidate(&rcBorder);

        rcBorder = rc;
        rcBorder.top = rcBorder.bottom - cBorder;
        Invalidate(&rcBorder);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a notification
//
//  Arguments:  pnf - Notification sent
//
//-----------------------------------------------------------------------------

void
CView::Notify(
    CNotification * pnf)
{
    if (IsActive())
    {
        switch (pnf->Type())
        {
        case NTYPE_MEASURED_RANGE:
            AccumulateMeasuredRange(pnf->Cp(0), pnf->Cch(LONG_MAX));
            break;

        case NTYPE_TRANSLATED_RANGE:
            AccumulateTranslatedRange(pnf->DataAsSize(), pnf->Cp(0), pnf->Cch(LONG_MAX));
            break;

        case NTYPE_ELEMENT_SIZECHANGED:
        case NTYPE_ELEMENT_POSITIONCHANGED:
#ifdef ADORNERS
            if (HasAdorners())
            {
                long    iAdorner;
                BOOL    fShapeChange = pnf->IsType(NTYPE_ELEMENT_SIZECHANGED);

                Assert(!pnf->Element()->IsPositionStatic());

                for (iAdorner = GetAdorner(pnf->Element());
                    iAdorner >= 0;
                    iAdorner = GetAdorner(pnf->Element(), iAdorner+1))
                {
                    if (fShapeChange)
                    {
                        _aryAdorners[iAdorner]->ShapeChanged();
                    }
                    else
                    {
                        _aryAdorners[iAdorner]->PositionChanged();
                    }
                }
            }
#endif
            break;

        case NTYPE_ELEMENT_ENSURERECALC:
            EnsureSize(_grfLayout);
            _grfLayout &= ~LAYOUT_FORCE;
            break;

        case NTYPE_ELEMENT_RESIZE:
        case NTYPE_ELEMENT_RESIZEANDREMEASURE:
                Verify(OpenView());
                if (    pnf->Element()->GetMarkup()
                    &&  pnf->Element() == pnf->Element()->GetMarkup()->GetCanvasElement() )
            {
                pnf->Element()->DirtyLayout(pnf->LayoutFlags());
            }
            ClearFlag(VF_SIZED);
            break;

        case NTYPE_DISPLAY_CHANGE:
        case NTYPE_VIEW_ATTACHELEMENT:
        case NTYPE_VIEW_DETACHELEMENT:
            Verify(OpenView());
            ClearFlag(VF_SIZED);
            ClearFlag(VF_ATTACHED);
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     AddLayoutTask
//
//  Synopsis:   Add a layout view task
//
//  Arguments:  pLayout   - CLayout to invoke
//              grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

HRESULT
CView::AddLayoutTask(
    CLayout *   pLayout,
    DWORD       grfLayout)
{
    Assert(!((grfLayout & ~(LAYOUT_FORCE | LAYOUT_SYNCHRONOUSPAINT)) & LAYOUT_NONTASKFLAGS));
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    if (!IsActive())
        return S_OK;

    Assert(pLayout);
    Assert(pLayout->ElementOwner());
    Assert(!pLayout->ElementOwner()->IsPassivating());
    Assert(!pLayout->ElementOwner()->IsPassivated());
    Assert(!pLayout->ElementOwner()->IsDestructing());

    HRESULT hr = AddTask(pLayout, CViewTask::VTT_LAYOUT, (grfLayout & LAYOUT_TASKFLAGS));

    if (SUCCEEDED(hr))
    {
        grfLayout  &= ~LAYOUT_FORCE;
        _grfLayout |= grfLayout & LAYOUT_NONTASKFLAGS;

        TraceTagEx((tagLayoutTasks, TAG_NONAME,
                    "Layout Task: Added to view for ly=0x%x [e=0x%x,%S sn=%d] by CView::AddLayoutTask()",
                    pLayout,
                    pLayout->ElementOwner(),
                    pLayout->ElementOwner()->TagName(),
                    pLayout->ElementOwner()->_nSerialNumber));

        if (_grfLayout & LAYOUT_SYNCHRONOUS)
        {
            EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_SYNCHRONOUSPAINT);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveEventTasks
//
//  Synopsis:   Remove all event tasks for the passed element
//
//  Arguments:  pElement - The element whose tasks are to be removed
//
//----------------------------------------------------------------------------

void
CView::RemoveEventTasks(
    CElement *  pElement)
{
    Assert(IsActive() || !_aryTaskEvent.Size());
    Assert(pElement);
    Assert(pElement->_fHasPendingEvent);

    if (IsActive())
    {
        int cTasks = _aryTaskEvent.Size();
        int iTask;

        for (iTask = 0; iTask < cTasks; )
        {
            if (_aryTaskEvent[iTask]._pElement == pElement)
            {
                _aryTaskEvent.Delete(iTask);
                cTasks--;
            }
            else
            {
                iTask++;
            }
        }
    }

    pElement->_fHasPendingEvent = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     RequestRecalc
//
//  Synopsis:   Request a call into the recalc engine
//
//----------------------------------------------------------------------------
void
CView::RequestRecalc()
{
    if (IsActive())
    {
        SetFlag(VF_NEEDSRECALC);
        PostCloseView();
    }
}

#ifdef ADORNERS
//+---------------------------------------------------------------------------
//
//  Member:     CreateAdorner
//
//  Synopsis:   Create an adorner
//
//  Arguments:  adt      - The type of adorner to create
//              pElement - The element associated with the adorner
//
//                  -or-
//
//              cpStart  - The starting cp associated with the adorner
//              cpEnd    - The ending cp associated with the adorner
//
//----------------------------------------------------------------------------

CAdorner *
CView::CreateAdorner(
    CElement *  pElement)
{
    if (!IsActive())
        return NULL;

    CAdorner *  pAdorner;

    pAdorner = new CElementAdorner(this, pElement);

    if (    pAdorner
        &&  !SUCCEEDED(AddAdorner(pAdorner)))
    {
        pAdorner->Destroy();
        pAdorner = NULL;
    }

    return pAdorner;
}

CAdorner *
CView::CreateAdorner(
    long        cpStart,
    long        cpEnd)
{
    AssertSz(FALSE, "Range adorners are not yet supported");
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveAdorners
//
//  Synopsis:   Remove all adorners associated with an element
//
//  Arguments:  pElement - CElement associated with the adorner
//
//----------------------------------------------------------------------------

void
CView::RemoveAdorners(
    CElement * pElement)
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (    IsActive()
        &&  _aryAdorners.Size())
    {
        long    iAdorner;

        for (iAdorner = GetAdorner(pElement);
            iAdorner >= 0;
            iAdorner = GetAdorner(pElement, iAdorner))
        {
            RemoveAdorner(_aryAdorners[iAdorner], FALSE);
        }

        if (pElement->CurrentlyHasAnyLayout())
        {
            pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->SetIsAdorned(FALSE);
        }
    }
}

#endif


//+---------------------------------------------------------------------------
//
//  Member:     EndDeferred
//
//  Synopsis:   End all deferred requests
//              NOTE: This routine is meant only for callers outside of CView.
//                    CView should call the underlying routines directly.
//
//----------------------------------------------------------------------------

void
CView::EndDeferred()
{
    Assert(!IsLockSet(VL_ENSUREINPROGRESS));
    Assert(!IsLockSet(VL_RENDERINPROGRESS));

    EndDeferSetWindowPos();
    EndDeferSetObjectRects();
    EndDeferSetWindowRgn();
    EndDeferTransition();

    if (IsFlagSet(VF_DIRTYZORDER))
    {
        ClearFlag(VF_DIRTYZORDER);
        FixWindowZOrder();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetObjectRects, EndDeferSetObjectRects, SetObjectRectsHelper
//
//  Synopsis:   Collect, defer, and execute SetObjectRects requests
//
//----------------------------------------------------------------------------

void
CView::DeferSetObjectRects(
    IOleInPlaceObject * pInPlaceObject,
    const RECT *        prcObj,
    const RECT *        prcClip,
    HWND                hwnd,
    BOOL                fInvalidate)
{
    Assert(IsActive() || !_arySor.Size());

    if (    !IsActive()
        ||  pInPlaceObject == NULL)
        return;

    TraceTag((tagViewHwndChange, "defer SOR %x Client: %ld %ld %ld %ld  Clip: %ld %ld %ld %ld",
                    pInPlaceObject,
                    prcObj->left, prcObj->top, prcObj->right, prcObj->bottom,
                    prcClip->left, prcClip->top, prcClip->right, prcClip->bottom));

    //
    //  Scan array for matching entry
    //  If one is found, update it; Otherwise, append a new entry
    //
    int i;
    SOR * psor;

    for (i = _arySor.Size(), psor = &(_arySor[0]); i > 0; i--, psor++)
    {
        if (psor->hwnd == hwnd && psor->pInPlaceObject == pInPlaceObject)
        {
            psor->rc              = *prcObj;
            psor->rcClip          = *prcClip;
            psor->fInvalidate     = psor->fInvalidate || fInvalidate;
            break;
        }
    }

    //
    //  No match was found, append a new entry
    //

    if (i <= 0)
    {
        if (_arySor.EnsureSize(_arySor.Size() + 1) == S_OK)
        {
            psor = &_arySor[_arySor.Size()];
            psor->pInPlaceObject  = pInPlaceObject;
            pInPlaceObject->AddRef();
            psor->rc              = *prcObj;
            psor->rcClip          = *prcClip;
            psor->hwnd            = hwnd;
            psor->fInvalidate     = fInvalidate;
            _arySor.SetSize(_arySor.Size() + 1);
        }
        else
        {
            CServer::CLock Lock(Doc(), SERVERLOCK_BLOCKPAINT | SERVERLOCK_IGNOREERASEBKGND);
            SetObjectRectsHelper(pInPlaceObject, prcObj, prcClip, hwnd, fInvalidate);
        }
    }
}

void
CView::EndDeferSetObjectRects(
    DWORD   grfLayout,
    BOOL    fIgnore)
{

    SOR *   psor;
    int     i;

    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_arySor.Size());

    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_arySor.Size())
        return;

    {
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

        for (i = _arySor.Size(), psor = &(_arySor[0]); i > 0; i--, psor++)
        {
            if (!fIgnore)
            {
                SetObjectRectsHelper(psor->pInPlaceObject,
                                     &psor->rc, &psor->rcClip, psor->hwnd,
                                     psor->fInvalidate);
            }

            psor->pInPlaceObject->Release();
        }
    }

    _arySor.DeleteAll();
}


// used to enumerate children of a suspected clipping outer window
struct INNERWINDOWTESTSTRUCT
{
    HWND    hwndParent;
    CView * pView;
    CRect   rc;
};


    // this callback checks each of the children of a particular
    // outer window.  If the child is positioned in the given place
    // (namely the client rect), we'll mark the parent as a clipping
    // outer window.  It's called from SetObjectRectsHelper, below.
BOOL CALLBACK
TestInnerWindow(HWND hwndChild, LPARAM lparam)
{
    INNERWINDOWTESTSTRUCT *piwts = (INNERWINDOWTESTSTRUCT *)lparam;
    CRect rcActual;

    piwts->pView->GetHWNDRect(hwndChild, &rcActual);
    if (rcActual == piwts->rc)
    {
        piwts->pView->AddClippingOuterWindow(piwts->hwndParent);
        return FALSE;
    }
    return TRUE;
}


void
CView::SetObjectRectsHelper(
    IOleInPlaceObject * pInPlaceObject,
    const RECT *        prcObj,
    const RECT *        prcClip,
    HWND                hwnd,
    BOOL                fInvalidate)
{
    CRect rcWndBefore(0,0,0,0);
    CRect rcWndAfter(0,0,0,0);
    HRGN hrgnBefore=NULL, hrgnAfter;

    if (hwnd)
    {
        hrgnBefore = ::CreateRectRgnIndirect(&g_Zero.rc);
        if (hrgnBefore)
            ::GetWindowRgn(hwnd, hrgnBefore);
        GetHWNDRect(hwnd, &rcWndBefore);
    }

    TraceTag((tagViewHwndChange, "SOR %x Client: %ld %ld %ld %ld  Clip: %ld %ld %ld %ld  inv: %d",
                    hwnd,
                    prcObj->left, prcObj->top, prcObj->right, prcObj->bottom,
                    prcClip->left, prcClip->top, prcClip->right, prcClip->bottom,
                    fInvalidate));

    {
        CView::CLockWndRects lock(this, NULL, pInPlaceObject);
        IGNORE_HR(pInPlaceObject->SetObjectRects(ENSUREOLERECT(prcObj),
                                             ENSUREOLERECT(prcClip)));
    }

    // MFC controls change the HWND to the rcClip instead of the rcObj,
    // but they don't change the Window region accordingly.  We try to
    // detect that, and make the right change for them (bug 75218).

    // only do this if it looks like SetObjectRects moved the position
    if (hwnd)
        GetHWNDRect(hwnd, &rcWndAfter);
    if (hwnd && rcWndBefore != rcWndAfter)
    {
        CSize sizeOffset = rcWndBefore.TopLeft() - rcWndAfter.TopLeft();
        BOOL fPendingCall = FALSE;

        // SetObjectRects moved the window.  Any SetWindowRgn calls
        // were set up with the old window position in mind, and need to
        // be adjusted.  Do so now.

        // First adjust pending SetWindowRgn calls.
        for (int i = _aryWndRgn.Size()-1;  i >= 0;  --i)
        {
            if (hwnd == _aryWndRgn[i].hwnd)
            {
                fPendingCall = TRUE;
                if (_aryWndRgn[i].hrgn)
                {
                    ::OffsetRgn(_aryWndRgn[i].hrgn, sizeOffset.cx, sizeOffset.cy);
                }
                else
                {
                    _aryWndRgn[i].rc.OffsetRect(sizeOffset);
                }
            }
        }

        // Now adjust calls that have already happened (if none were pending)
        if (!fPendingCall && hrgnBefore)
        {
            hrgnAfter = ::CreateRectRgnIndirect(&g_Zero.rc);
            if (hrgnAfter)
            {
                CRect rcRegion;

                ::GetWindowRgn(hwnd, hrgnAfter);
                ::GetRgnBox(hrgnAfter, &rcRegion);

                WHEN_DBG(CRegionRects rrBefore(hrgnBefore));
                WHEN_DBG(CRegionRects rrAfter(hrgnAfter));

                // if the position moved but the region didn't, move the region
                if (EqualRgn(hrgnBefore, hrgnAfter) && !rcRegion.IsEmpty())
                {
                    ::OffsetRgn(hrgnAfter, sizeOffset.cx, sizeOffset.cy);
                    ::SetWindowRgn(hwnd, hrgnAfter, FALSE);

                    TraceTag((tagViewHwndChange, "move window rgn for %x by %ld %ld",
                                hwnd, sizeOffset.cy, sizeOffset.cx));
                }
                else
                {
                    ::DeleteObject(hrgnAfter);
                }
            }
        }

#if 0
        // this is commented out to resolve SE Bug 22181 where extraneous
        // repaints were occuring when iframes containing a mfc control overlapped.

        // if SetObjectRects moved the position to the clipping rect, we
        // may want to mark the hwnd so that we move it we can move it directly
        // to the clipping rect in the future.
        if (rcWndAfter == *prcClip && rcWndAfter != *prcObj)
        {
            INNERWINDOWTESTSTRUCT iwts;

            iwts.hwndParent = hwnd;
            iwts.pView = this;
            iwts.rc = *prcObj;
            
            EnumChildWindows(hwnd, TestInnerWindow, (LPARAM)&iwts);
        }
#endif
    }

    if (hrgnBefore)
    {
        ::DeleteObject(hrgnBefore);
    }

    if (hwnd && fInvalidate)
    {
        ::InvalidateRect(hwnd, NULL, FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     IsChangingRectsFor
//
//  Synopsis:   See if we're in the middle of a SetObjectRects call for
//              the given control.  We want to ignore certain callbacks
//              in this case (see COleSite::CClient::OnPosRectChange)
//
//----------------------------------------------------------------------------


BOOL
CView::IsChangingRectsFor(HWND hwnd, IOleInPlaceObject * pInPlaceObject) const
{
    CView::CLockWndRects *pLock;

    for (pLock = _pLockWndRects;  pLock;  pLock = pLock->Next())
    {
        if (pLock->IsFor(hwnd, pInPlaceObject))
            return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetHWNDRect, AddClippingOuterWindow, RemoveClippingOuterWindow,
//              IndexOfClippingOuterWindow
//
//  Synopsis:   Some controls (MFC controls, prominently) implement clipping
//              by a pair of windows:  an outer window set to the clip rect
//              and an inner window set to the content rect.  These routines
//              help detect such HWNDs, so that we can move them to their
//              real positions and avoid flicker.
//
//----------------------------------------------------------------------------


void
CView::GetHWNDRect(HWND hwnd, CRect *prcWndActual) const
{    
    Assert(Doc());
    Assert(prcWndActual);
    
    CInPlace* pInPlace = Doc()->_pInPlace;

    if (pInPlace && hwnd)
    {
        HWND hwndParent = pInPlace->_hwnd;

        if (hwndParent)
        {
            ::GetWindowRect(hwnd, prcWndActual);
            CPoint ptActual(prcWndActual->TopLeft());
            ::ScreenToClient(hwndParent, &ptActual);
            prcWndActual->MoveTo(ptActual);   // change to parent window coords.
        }
        else
        {
            *prcWndActual = g_Zero.rc;
        }
    }
    else
    {
        *prcWndActual = g_Zero.rc;
    }
}


void
CView::AddClippingOuterWindow(HWND hwnd)
{
    if (!IsClippingOuterWindow(hwnd))
    {
        _aryClippingOuterHwnd.AppendIndirect(&hwnd);
        TraceTag((tagViewHwndChange, "hwnd %x marked as MFC control", hwnd));
    }
}


void
CView::RemoveClippingOuterWindow(HWND hwnd)
{
    _aryClippingOuterHwnd.DeleteByValueIndirect(&hwnd);
}


int
CView::IndexOfClippingOuterWindow(HWND hwnd)
{
    return _aryClippingOuterHwnd.FindIndirect(&hwnd);
}


//+---------------------------------------------------------------------------
//
//  Member:     HideClippedWindow, UnHideClippedWindow
//
//  Synopsis:   When a window is totally obscured by IFRAMEs, we send it a
//              HideWindow message.  We remember windows in this state,
//              so that if something 
//
//----------------------------------------------------------------------------

void
CView::HideClippedWindow(HWND hwnd)
{
    _aryHwndHidden.AppendIndirect(&hwnd);
}


void
CView::UnHideClippedWindow(HWND hwnd)
{
    _aryHwndHidden.DeleteByValueIndirect(&hwnd);
}


void
CView::CleanupWindow(HWND hwnd)
{
    RemoveClippingOuterWindow(hwnd);
    UnHideClippedWindow(hwnd);
}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetWindowPos, EndDeferSetWindowPos
//
//  Synopsis:   Collect, defer, and execute SetWindowPos requests
//
//----------------------------------------------------------------------------

void
CView::DeferSetWindowPos(
    HWND         hwnd,
    const RECT * prc,
    UINT         uFlags,
    const RECT * prcInvalid)
{
    Assert(IsActive() || !_aryWndPos.Size());

    if (!IsActive())
        return;

#if DBG==1
    if (prcInvalid)
        TraceTag((tagViewHwndChange, "defer SWP %x Rect: %ld %ld %ld %ld  Flags: %x  Inval: %ld %ld %ld %ld",
                    hwnd,
                    prc->left, prc->top, prc->right, prc->bottom,
                    uFlags,
                    prcInvalid->left, prcInvalid->top, prcInvalid->right, prcInvalid->bottom));
    else
        TraceTag((tagViewHwndChange, "defer SWP %x Rect: %ld %ld %ld %ld  Flags: %x  Inval: null",
                    hwnd,
                    prc->left, prc->top, prc->right, prc->bottom,
                    uFlags));
#endif

#ifndef _MAC
    if (hwnd)
    {
        WND_POS *   pWndPos;

        //
        //  Add to invalid area
        //

        // TODO (donmarsh) -- not used right now, and including region.hxx
        // in view.hxx makes region development difficult.
#ifdef NEVER

        if (prcInvalid)
        {
            _rgnInvalid.Union(*prcInvalid);
        }
#endif

        // always no z-order change... this is handled by FixWindowZOrder
        uFlags |= SWP_NOZORDER;

        //
        //  Scan array for matching entry
        //  If one is found, update it; Otherwise, append a new entry
        //

#if 1 // TODO (donmarsh) - this seems to be superfluous code that causes bugs, about to remove
        int i;
        for (i = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); i > 0; i--, pWndPos++)
        {
            if (pWndPos->hwnd == hwnd)
            {
                pWndPos->rc = *prc;

                //
                //  Reset flags
                //  (Always keep the flags that include either SWP_SHOWWINDOW or SWP_HIDEWINDOW)
                //

                if (    (uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW))
                    ||  !(pWndPos->uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW)))
                {
                    //  NOTE: If ever not set, SWP_NOREDRAW is ignored
                    if (    (uFlags & SWP_NOREDRAW)
                        &&  !(pWndPos->uFlags & SWP_NOREDRAW))
                    {
                        uFlags &= ~SWP_NOREDRAW;
                    }

                    pWndPos->uFlags = uFlags;
                }

                break;
            }
        }

        //
        //  No match was found, append a new entry
        //

        if (i <= 0)
#endif
        {
            pWndPos = _aryWndPos.Append();

            if (pWndPos != NULL)
            {
                pWndPos->hwnd   = hwnd;
                pWndPos->rc     = *prc;
                pWndPos->uFlags = uFlags;
                pWndPos->uViewFlags = 0;
            }
        }
    }
#endif // _MAC
}

void
CView::EndDeferSetWindowPos(
    DWORD   grfLayout,
    BOOL    fIgnore)
{
    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_aryWndPos.Size());

    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_aryWndPos.Size())
        return;

#ifndef _MAC
    if (!fIgnore)
    {
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

        const int cLockArraySize = 8;
        CLockWndRects aryLockStack[cLockArraySize];
        const BOOL fAllocateLocks = (_aryWndPos.Size() > cLockArraySize);
        
        CLockWndRects *aryLock = NULL;
        CLockWndRects *pLock = _pLockWndRects;
        CLockWndRects *pLockWndRectsOrig = _pLockWndRects;
        int iLock = 0;

        WND_POS *   pWndPos;
        HDWP        hdwpShowHide = NULL;
        HDWP        hdwpOther    = NULL;
        HDWP        hdwp;
        int         cShowHideWindows = 0;
        int         i, j;

        //  First look at all windows that have previously been hidden
        //  due to clipping (e.g. by obscuring IFRAMEs), to amend the
        //  arguments to SetWindowPos.

        for (i = _aryHwndHidden.Size()-1; i>=0; --i)
        {
            for (j = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); j > 0; j--, pWndPos++)
            {
                if (_aryHwndHidden[i] == pWndPos->hwnd)
                {
                    // remember that the hwnd is on the hidden list
                    pWndPos->uViewFlags |= SWPVF_HIDDEN;

                    // if we want to hide the window by clipping...
                    if (pWndPos->uViewFlags & SWPVF_HIDE)
                    {
                        // hiddden by clipping overrides showing
                        if (pWndPos->uFlags & SWP_SHOWWINDOW)
                            pWndPos->uFlags = (pWndPos->uFlags & (~SWP_SHOWWINDOW)) | SWP_HIDEWINDOW;

                        // hidden by layout overrides hidden by clipping
                        else if (pWndPos->uFlags & SWP_HIDEWINDOW)
                            UnHideClippedWindow(pWndPos->hwnd);
                    }

                    // if we don't want to hide the window by clipping...
                    else
                    {
                        // no longer hidden
                        UnHideClippedWindow(pWndPos->hwnd);

                        // if layout thinks it's visible, show it
                        if (!(pWndPos->uFlags & (SWP_SHOWWINDOW | SWP_HIDEWINDOW)))
                            pWndPos->uFlags |= SWP_SHOWWINDOW;
                    }
                }
            }
        }

        //
        //  Since positioning requests and SWP_SHOW/HIDEWINDOW requests cannot be safely mixed,
        //  process first all positioning requests followed by all SWP_SHOW/HIDEWINDOW requests
        //

        for (i = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); i > 0; i--, pWndPos++)
        {
            // if this is the initial request to hide the window by clipping...
            if ((pWndPos->uViewFlags & (SWPVF_HIDE|SWPVF_HIDDEN)) == SWPVF_HIDE)
            {
                // add to hidden list (unless layout is doing the hiding)
                if (!(pWndPos->uFlags & SWP_HIDEWINDOW))
                    HideClippedWindow(pWndPos->hwnd);

                // hide the window
                pWndPos->uFlags = (pWndPos->uFlags & (~SWP_SHOWWINDOW)) | SWP_HIDEWINDOW;
            }

            if (pWndPos->uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW))
            {
                cShowHideWindows++;
            }
        }

        //
        //  Allocate deferred structures large enough for each set of requests
        //

        if (cShowHideWindows > 0)
        {
            hdwpShowHide = ::BeginDeferWindowPos(cShowHideWindows);
            if (!hdwpShowHide)
                goto Cleanup;
        }

        if (cShowHideWindows < _aryWndPos.Size())
        {
            hdwpOther = ::BeginDeferWindowPos(_aryWndPos.Size() - cShowHideWindows);
            if (!hdwpOther)
                goto Cleanup;
        }

        //
        //  Collect and issue the requests
        //

        Assert( cShowHideWindows <= 0
            ||  hdwpShowHide != NULL);
        Assert( cShowHideWindows >= _aryWndPos.Size()
            ||  hdwpOther != NULL);

        aryLock = fAllocateLocks ? new CLockWndRects[ _aryWndPos.Size() ]
                                 : aryLockStack;
        
        for (i = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); i > 0; i--, pWndPos++)
        {
            //
            // The window cached by DeferSetWindowPos may be destroyed
            // before we come here.
            //
            if (!IsWindow(pWndPos->hwnd))
                continue;

            pLock = aryLock[iLock++].Lock(pWndPos->hwnd, pLock);

            TraceTag((tagViewHwndChange, "SWP %x Rect: %ld %ld %ld %ld  Flags: %x",
                    pWndPos->hwnd,
                    pWndPos->rc.left, pWndPos->rc.top, pWndPos->rc.right, pWndPos->rc.bottom,
                    pWndPos->uFlags));

            if (pWndPos->uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW))
            {
                hdwp = ::DeferWindowPos(hdwpShowHide,
                                        pWndPos->hwnd,
                                        NULL,
                                        pWndPos->rc.left,
                                        pWndPos->rc.top,
                                        pWndPos->rc.Width(),
                                        pWndPos->rc.Height(),
                                        pWndPos->uFlags);

                if (!hdwp)
                    goto Cleanup;

                hdwpShowHide = hdwp;
            }
            else
            {
                hdwp = ::DeferWindowPos(hdwpOther,
                                        pWndPos->hwnd,
                                        NULL,
                                        pWndPos->rc.left,
                                        pWndPos->rc.top,
                                        pWndPos->rc.Width(),
                                        pWndPos->rc.Height(),
                                        pWndPos->uFlags);

                if (!hdwp)
                    goto Cleanup;

                hdwpOther = hdwp;
            }
        }

    Cleanup:
        _pLockWndRects = pLock;

        if (hdwpOther != NULL)
        {
            ::EndDeferWindowPos(hdwpOther);
        }

        if (hdwpShowHide != NULL)
        {
            ::EndDeferWindowPos(hdwpShowHide);
        }

        if (fAllocateLocks)
            delete [] aryLock;
        _pLockWndRects = pLockWndRectsOrig;

        _aryWndPos.DeleteAll();

        //
        // perform deferred invalidation
        //

        // TODO: Not used right now, and including region.hxx
        // in view.hxx makes region development difficult.
#ifdef NEVER
        if (!_rgnInvalid.IsEmpty())
        {
            Assert(_pDispRoot != NULL);
            _pDispRoot->InvalidateRoot(_rgnInvalid);
            _rgnInvalid.SetEmpty();
        }
#endif
    }

#endif // _MAC
}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetWindowRgn, EndDeferWindowRgn
//
//  Synopsis:   Collect, defer, and execute SetWindowRgn requests
//
//----------------------------------------------------------------------------

void
CView::DeferSetWindowRgn(
    HWND            hwnd,
    const RECT *    prc,
    BOOL            fRedraw)
{
    Assert(prc);
    Assert(IsActive() || !_aryWndRgn.Size());

    if (!IsActive())
        return;

    TraceTag((tagViewHwndChange, "SWRgn (defer) %x Rect: %ld %ld %ld %ld  Redraw: %d",
            hwnd,
            prc->left, prc->top, prc->right, prc->bottom,
            fRedraw));

    int i;
    WND_RGN * pwrgn;

    //
    //  Scan array for matching entry
    //  If one is found, update it; Otherwise, append a new entry
    //

    for (i = _aryWndRgn.Size(), pwrgn = &(_aryWndRgn[0]); i > 0; i--, pwrgn++)
    {
        if (pwrgn->hwnd == hwnd)
        {
            pwrgn->hrgn    = NULL;
            pwrgn->rc      = *prc;
            pwrgn->fRedraw = pwrgn->fRedraw || fRedraw;
            break;
        }
    }

    //
    //  No match was found, append a new entry
    //

    if (i <= 0)
    {
        if (_aryWndRgn.EnsureSize(_aryWndRgn.Size() + 1) == S_OK)
        {
            pwrgn = &_aryWndRgn[_aryWndRgn.Size()];

            pwrgn->hrgn    = NULL;
            pwrgn->hwnd    = hwnd;
            pwrgn->rc      = *prc;
            pwrgn->fRedraw = fRedraw;

            _aryWndRgn.SetSize(_aryWndRgn.Size() + 1);
        }
        else
        {
            TraceTag((tagViewHwndChange, "SWRgn %x Rect: %ld %ld %ld %ld  Redraw: %d",
                hwnd,
                prc->left, prc->top, prc->right, prc->bottom,
                fRedraw));
           ::SetWindowRgn(hwnd, ::CreateRectRgnIndirect(prc), fRedraw);
        }
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetWindowRgn, EndDeferWindowRgn
//
//  Synopsis:   Collect, defer, and execute SetWindowRgn requests
//
//----------------------------------------------------------------------------

static const CRect s_rcUseRegion(1,-2,3,-4);

void
CView::DeferSetWindowRgn(
    HWND            hwnd,
    HRGN            hrgn,
    const CRect*    prc,
    BOOL            fRedraw)
{
    Assert(IsActive() || !_aryWndRgn.Size());

    if (!IsActive())
        return;

    TraceTag((tagViewHwndChange, "defer SWRgn %x Rgn: %x  Redraw: %d",
            hwnd,
            hrgn,
            fRedraw));

    int i;
    WND_RGN * pwrgn;

    //
    //  If there's a pending SetObjectRects for this window, update its
    //  clip rect.  This eliminates some flashing (bug 108347).
    //

    if (prc)
    {
        SOR * psor;

        for (i = _arySor.Size(), psor = &(_arySor[0]); i > 0; i--, psor++)
        {
            if (psor->hwnd == hwnd)
            {
                CRect rcClip = *prc;
                rcClip.OffsetRect(psor->rc.left, psor->rc.top);
                psor->rcClip = rcClip;

                // if we're hiding the window completely, set the HIDEWINDOW bit
                if (prc->IsEmpty())
                {
                    int j;
                    WND_POS * pwp;

                    for (j=_aryWndPos.Size(), pwp = &(_aryWndPos[0]);
                         j > 0;
                         --j, ++pwp)
                    {
                        if (pwp->hwnd == hwnd)
                        {
                            pwp->uViewFlags |= SWPVF_HIDE;
                        }
                    }
                }
                break;
            }
        }
    }

    //
    //  Scan array for matching entry
    //  If one is found, update it; Otherwise, append a new entry
    //

    for (i = _aryWndRgn.Size(), pwrgn = &(_aryWndRgn[0]); i > 0; i--, pwrgn++)
    {
        if (pwrgn->hwnd == hwnd)
        {
            pwrgn->hrgn    = hrgn;
            pwrgn->rc      = s_rcUseRegion;
            pwrgn->fRedraw = pwrgn->fRedraw || fRedraw;
            break;
        }
    }

    //
    //  No match was found, append a new entry
    //

    if (i <= 0)
    {
        if (_aryWndRgn.EnsureSize(_aryWndRgn.Size() + 1) == S_OK)
        {
            pwrgn = &_aryWndRgn[_aryWndRgn.Size()];

            pwrgn->hrgn    = hrgn;
            pwrgn->hwnd    = hwnd;
            pwrgn->rc      = s_rcUseRegion;
            pwrgn->fRedraw = fRedraw;

            _aryWndRgn.SetSize(_aryWndRgn.Size() + 1);
        }
        else
        {
            TraceTag((tagViewHwndChange, "SWRgn %x Rgn: %x  Redraw: %d",
                hwnd,
                hrgn,
                fRedraw));
           ::SetWindowRgn(hwnd, hrgn, fRedraw);
        }

    }
}



void
CView::EndDeferSetWindowRgn(
    DWORD   grfLayout,
    BOOL    fIgnore)
{
    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_aryWndRgn.Size());
        
    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_aryWndRgn.Size())
        return;

    // prevent reentry of Display Tree if the following calls cause
    // a WM_ERASEBKGND message to be sent
    CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);
    WND_RGN *   pwrgn;
    int         i;

    for (   i = _aryWndRgn.Size()-1, pwrgn = &(_aryWndRgn[_aryWndRgn.Size()-1]);
            i >= 0;
            i--, pwrgn--)
    {
        if (!fIgnore)
        {
            if (pwrgn->hrgn || pwrgn->rc == s_rcUseRegion)
            {
#if DBG == 1
                if (IsTagEnabled(tagViewHwndChange))
                {
                    TraceTag((tagViewHwndChange, "SWRgn End  %x Rgn: %x  Redraw: %u",
                        pwrgn->hwnd, pwrgn->hrgn, pwrgn->fRedraw));

                    extern void DumpRegion(HRGN);
                    DumpRegion(pwrgn->hrgn);
                }
#endif
               ::SetWindowRgn(pwrgn->hwnd, pwrgn->hrgn, pwrgn->fRedraw);
            }
            else
            {
                TraceTag((tagViewHwndChange, "SWRgn End %x Rect: %ld %ld %ld %ld  Redraw: %d",
                    pwrgn->hwnd,
                    pwrgn->rc.left, pwrgn->rc.top, pwrgn->rc.right, pwrgn->rc.bottom,
                    pwrgn->fRedraw));

                ::SetWindowRgn(pwrgn->hwnd, ::CreateRectRgnIndirect(&pwrgn->rc), pwrgn->fRedraw);
      